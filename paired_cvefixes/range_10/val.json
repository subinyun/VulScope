[
  {
    "input": "\n  size_t mem_limit = specify_workspace_limit ? memory_limit_bytes : 0ULL;\n  for (int r = 0; r < num_returned_algos; r++) {\n    if (perf_results[r].status == CUDNN_STATUS_SUCCESS &&\n        perf_results[r].algo !=\n            CUDNN_CONVOLUTION_BWD_FILTER_ALGO_WINOGRAD_NONFUSED &&\n        perf_results[r].memory <= mem_limit) {\n      return perf_results[r].algo;\n    }\n  }\n  return tsl::Status(port::error::INTERNAL,\n                     \"cudnnGetConvolutionBackwardFilterAlgorithm_v7 returned \"\n                     \"no suitable algorithms. This could be a cudnn bug.\");\n#else\n  cudnnConvolutionBwdFilterPreference_t preference =\n      specify_workspace_limit\n          ? CUDNN_CONVOLUTION_BWD_FILTER_SPECIFY_WORKSPACE_LIMIT\n          : CUDNN_CONVOLUTION_BWD_FILTER_NO_WORKSPACE;\n  cudnnConvolutionBwdFilterAlgo_t algo_to_use;\n  RETURN_IF_CUDNN_ERROR(cudnnGetConvolutionBackwardFilterAlgorithm(\n      cudnn.handle(), input_nd.handle(), output_nd.handle(), conv.handle(),",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n  size_t mem_limit = specify_workspace_limit ? memory_limit_bytes : 0ULL;\n  for (int r = 0; r < num_returned_algos; r++) {\n    if (perf_results[r].status == CUDNN_STATUS_SUCCESS &&\n        perf_results[r].algo !=\n            CUDNN_CONVOLUTION_BWD_FILTER_ALGO_WINOGRAD_NONFUSED &&\n        perf_results[r].memory <= mem_limit) {\n      return perf_results[r].algo;\n    }\n  }\n  return tsl::Status(tsl::error::INTERNAL,\n                     \"cudnnGetConvolutionBackwardFilterAlgorithm_v7 returned \"\n                     \"no suitable algorithms. This could be a cudnn bug.\");\n#else\n  cudnnConvolutionBwdFilterPreference_t preference =\n      specify_workspace_limit\n          ? CUDNN_CONVOLUTION_BWD_FILTER_SPECIFY_WORKSPACE_LIMIT\n          : CUDNN_CONVOLUTION_BWD_FILTER_NO_WORKSPACE;\n  cudnnConvolutionBwdFilterAlgo_t algo_to_use;\n  RETURN_IF_CUDNN_ERROR(cudnnGetConvolutionBackwardFilterAlgorithm(\n      cudnn.handle(), input_nd.handle(), output_nd.handle(), conv.handle(),",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n\tif (sunkbd->layout == -1) {\n\t\tsunkbd->layout = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\n\tswitch (data) {\n\n\tcase SUNKBD_RET_RESET:\n\t\tschedule_work(&sunkbd->tq);\n\t\tsunkbd->reset = -1;\n\t\tbreak;\n\n\tcase SUNKBD_RET_LAYOUT:\n\t\tsunkbd->layout = -1;\n\t\tbreak;\n\n\tcase SUNKBD_RET_ALLUP: /* All keys released */\n\t\tbreak;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n\tif (sunkbd->layout == -1) {\n\t\tsunkbd->layout = data;\n\t\twake_up_interruptible(&sunkbd->wait);\n\t\tgoto out;\n\t}\n\n\tswitch (data) {\n\n\tcase SUNKBD_RET_RESET:\n\t\tif (sunkbd->enabled)\n\t\t\tschedule_work(&sunkbd->tq);\n\t\tsunkbd->reset = -1;\n\t\tbreak;\n\n\tcase SUNKBD_RET_LAYOUT:\n\t\tsunkbd->layout = -1;\n\t\tbreak;\n\n\tcase SUNKBD_RET_ALLUP: /* All keys released */\n\t\tbreak;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void track_set_index(Track *track, int i, long ind)\n{\n\tif (i > MAXINDEX) {\n\t\tfprintf(stderr, \"too many indexes\\n\");\n                return;\n        }\n\n\ttrack->index[i] = ind;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void track_set_index(Track *track, int i, long ind)\n{\n\tif (i < 0 || i > MAXINDEX) {\n\t\tfprintf(stderr, \"too many indexes\\n\");\n                return;\n        }\n\n\ttrack->index[i] = ind;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  OpContext op_context(context, node);\n  if (IsConstantTensor(op_context.input) && op_data->float_input_initialized) {\n    return kTfLiteOk;\n  }\n\n  // Dequantize the input\n  TfLiteTensor* dequantized = GetTemporary(context, node, /*index=*/0);\n  auto status = builtin::dequantize::DequantizeImpl<kernel_type>(\n      context, node, op_context.input, dequantized);\n  if (status != kTfLiteOk) {\n    return status;\n  }\n\n  if (IsConstantTensor(op_context.input)) {\n    op_data->float_input_initialized = true;\n  }\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n  OpContext op_context(context, node);\n  if (IsConstantTensor(op_context.input) && op_data->float_input_initialized) {\n    return kTfLiteOk;\n  }\n\n  // Dequantize the input\n  TfLiteTensor* dequantized;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, /*index=*/0, &dequantized));\n  auto status = builtin::dequantize::DequantizeImpl<kernel_type>(\n      context, node, op_context.input, dequantized);\n  if (status != kTfLiteOk) {\n    return status;\n  }\n\n  if (IsConstantTensor(op_context.input)) {\n    op_data->float_input_initialized = true;\n  }\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TfLiteStatus AverageEval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  switch (input->type) {  // Already know in/out types are same.\n    case kTfLiteFloat32:\n      AverageEvalFloat<kernel_type>(context, node, params, data, input, output);\n      break;\n    case kTfLiteUInt8:\n      AverageEvalQuantizedUint8<kernel_type>(context, node, params, data, input,\n                                             output);\n      break;\n    case kTfLiteInt8:\n      AverageEvalQuantizedInt8<kernel_type>(context, node, params, data, input,\n                                            output);\n      break;\n    case kTfLiteInt16:\n      AverageEvalQuantizedInt16<kernel_type>(context, node, params, data, input,\n                                             output);\n      break;\n    default:\n      TF_LITE_KERNEL_LOG(context, \"Type %s not currently supported.\",\n                         TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus AverageEval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  switch (input->type) {  // Already know in/out types are same.\n    case kTfLiteFloat32:\n      return AverageEvalFloat<kernel_type>(context, node, params, data, input,\n                                           output);\n    case kTfLiteUInt8:\n      return AverageEvalQuantizedUint8<kernel_type>(context, node, params, data,\n                                                    input, output);\n    case kTfLiteInt8:\n      return AverageEvalQuantizedInt8<kernel_type>(context, node, params, data,\n                                                   input, output);\n    case kTfLiteInt16:\n      return AverageEvalQuantizedInt16<kernel_type>(context, node, params, data,\n                                                    input, output);\n    default:\n      TF_LITE_KERNEL_LOG(context, \"Type %s not currently supported.\",\n                         TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                    errors::InvalidArgument(\"values must be a vector, saw: \",\n                                            values_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n  // TODO(ebrevdo): add shape checks between values, indices,\n  // dense_shape.  Also add check that dense rank > 0.\n\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),\n                       done);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()),\n                    errors::InvalidArgument(\"values must be a vector, saw: \",\n                                            values_t.shape().DebugString()),\n                    done);\n  OP_REQUIRES_ASYNC(\n      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n  // TODO(ebrevdo): add shape checks between values, indices,\n  // Also add check that dense rank > 0.\n  OP_REQUIRES_ASYNC(context, dense_shape_t.NumElements() != 0,\n                    errors::InvalidArgument(\"Dense shape cannot be empty.\"),\n                    done);\n\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),\n                       done);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "struct lib_t* MACH0_(get_libs)(struct MACH0_(obj_t)* bin) {\n\tstruct lib_t *libs;\n\tint i;\n\n\tif (!bin->nlibs)\n\t\treturn NULL;\n\tif (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t))))\n\t\treturn NULL;\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tstrncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH);\n\t\tlibs[i].name[R_BIN_MACH0_STRING_LENGTH-1] = '\\0';\n\t\tlibs[i].last = 0;\n\t}\n\tlibs[i].last = 1;\n\treturn libs;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "struct lib_t* MACH0_(get_libs)(struct MACH0_(obj_t)* bin) {\n\tstruct lib_t *libs;\n\tint i;\n\n\tif (!bin->nlibs) {\n\t\treturn NULL;\n\t}\n\tif (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tstrncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH);\n\t\tlibs[i].name[R_BIN_MACH0_STRING_LENGTH-1] = '\\0';\n\t\tlibs[i].last = 0;\n\t}\n\tlibs[i].last = 1;\n\treturn libs;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    aescrypt_hdr aeshdr;\n    sha256_t digest;\n    unsigned char IV[16];\n    unsigned char iv_key[48];\n    unsigned i, j, n;\n    size_t bytes_read;\n    unsigned char buffer[64], buffer2[32];\n    unsigned char *head, *tail;\n    unsigned char ipad[64], opad[64];\n    int reached_eof = 0;\n    \n    /* Read the file header */\n    if ((bytes_read = fread(&aeshdr, 1, sizeof(aeshdr), infp)) !=\n         sizeof(aescrypt_hdr))\n    {\n        if (feof(infp))\n        {\n            fprintf(stderr, \"Error: Input file is too short.\\n\");\n        }\n        else\n        {\n            perror(\"Error reading the file header:\");\n        }\n        return -1;\n    }\n\n    if (!(aeshdr.aes[0] == 'A' && aeshdr.aes[1] == 'E' &&\n          aeshdr.aes[2] == 'S'))\n    {\n        fprintf(stderr, \"Error: Bad file header (not aescrypt file or is corrupted? [%x, %x, %x])\\n\", aeshdr.aes[0], aeshdr.aes[1], aeshdr.aes[2]);\n        return -1;\n    }\n\n    /* Validate the version number and take any version-specific actions */\n    if (aeshdr.version == 0)\n    {\n        /*\n         * Let's just consider the least significant nibble to determine\n         * the size of the last block\n         */\n\n    /* Skip over extensions present v2 and later files */\n    if (aeshdr.version >= 0x02)\n    {\n        do\n        {\n            if ((bytes_read = fread(buffer, 1, 2, infp)) != 2)\n            {\n                if (feof(infp))\n                {\n                    fprintf(stderr, \"Error: Input file is too short.\\n\");\n                }\n                else\n                {\n                    perror(\"Error reading the file extensions:\");\n                }\n                return -1;\n            }\n            /* Determine the extension length, zero means no more extensions */\n            i = j = (((int)buffer[0]) << 8) | (int)buffer[1];\n            while (i--)\n            {\n                if ((bytes_read = fread(buffer, 1, 1, infp)) != 1)\n                {\n                    if (feof(infp))\n                    {\n                        fprintf(stderr, \"Error: Input file is too short.\\n\");\n                    }\n                    else\n                    {\n                        perror(\"Error reading the file extensions:\");\n                    }\n                    return -1;\n                }\n            }\n        } while(j);\n    }\n\n    /* Read the initialization vector from the file */\n    if ((bytes_read = fread(IV, 1, 16, infp)) != 16)\n    {\n        if (feof(infp))\n        {\n            fprintf(stderr, \"Error: Input file is too short.\\n\");\n        }\n        else\n        {\n            perror(\"Error reading the initialization vector:\");\n        }\n        return -1;\n    }\n\n    /* Hash the IV and password 8192 times */\n    memset(digest, 0, 32);\n    memcpy(digest, IV, 16);\n    for(i=0; i<8192; i++)\n    {\n        sha256_starts(  &sha_ctx);\n        sha256_update(  &sha_ctx, digest, 32);\n        sha256_update(  &sha_ctx,\n                        passwd,\n                        passlen);\n        sha256_finish(  &sha_ctx,\n                        digest);\n    }\n\n    /* Set the AES encryption key */\n    aes_set_key(&aes_ctx, digest, 256);\n\n    /* Set the ipad and opad arrays with values as\n     * per RFC 2104 (HMAC).  HMAC is defined as\n     *   H(K XOR opad, H(K XOR ipad, text))\n     */\n    memset(ipad, 0x36, 64);\n    memset(opad, 0x5C, 64);\n\n    for(i=0; i<32; i++)\n    {\n        ipad[i] ^= digest[i];\n        opad[i] ^= digest[i];\n    }\n\n    sha256_starts(&sha_ctx);\n    sha256_update(&sha_ctx, ipad, 64);\n\n    /* If this is a version 1 or later file, then read the IV and key\n     * for decrypting the bulk of the file.\n     */\n    if (aeshdr.version >= 0x01)\n    {\n        for(i=0; i<48; i+=16)\n        {\n            if ((bytes_read = fread(buffer, 1, 16, infp)) != 16)\n            {\n                if (feof(infp))\n                {\n                    fprintf(stderr, \"Error: Input file is too short.\\n\");\n                }\n                else\n                {\n                    perror(\"Error reading input file IV and key:\");\n                }\n                return -1;\n            }\n\n            memcpy(buffer2, buffer, 16);\n\n            sha256_update(&sha_ctx, buffer, 16);\n            aes_decrypt(&aes_ctx, buffer, buffer);\n\n            /*\n             * XOR plain text block with previous encrypted\n             * output (i.e., use CBC)\n             */\n            for(j=0; j<16; j++)\n            {\n                iv_key[i+j] = (buffer[j] ^ IV[j]);\n            }\n\n            /* Update the IV (CBC mode) */\n            memcpy(IV, buffer2, 16);\n        }\n\n        /* Verify that the HMAC is correct */\n        sha256_finish(&sha_ctx, digest);\n        sha256_starts(&sha_ctx);\n        sha256_update(&sha_ctx, opad, 64);\n        sha256_update(&sha_ctx, digest, 32);\n        sha256_finish(&sha_ctx, digest);\n\n        if ((bytes_read = fread(buffer, 1, 32, infp)) != 32)\n        {\n            if (feof(infp))\n            {\n                fprintf(stderr, \"Error: Input file is too short.\\n\");\n            }\n            else\n            {\n                perror(\"Error reading input file digest:\");\n            }\n            return -1;\n        }\n\n        if (memcmp(digest, buffer, 32))\n        {\n            fprintf(stderr, \"Error: Message has been altered or password is incorrect\\n\");\n            return -1;\n        }\n\n        /*\n         * Re-load the IV and encryption key with the IV and\n         * key to now encrypt the datafile.  Also, reset the HMAC\n         * computation.\n         */\n        memcpy(IV, iv_key, 16);\n\n        aes_set_key(&aes_ctx, iv_key+16, 256);\n\n        /*\n         * Set the ipad and opad arrays with values as\n         * per RFC 2104 (HMAC).  HMAC is defined as\n         *   H(K XOR opad, H(K XOR ipad, text))\n         */\n        memset(ipad, 0x36, 64);\n        memset(opad, 0x5C, 64);\n\n        for(i=0; i<32; i++)\n        {\n            ipad[i] ^= iv_key[i+16];\n            opad[i] ^= iv_key[i+16];\n        }\n\n        /* Wipe the IV and encryption key from memory */\n        memset_secure(iv_key, 0, 48);\n\n        sha256_starts(&sha_ctx);\n        sha256_update(&sha_ctx, ipad, 64);\n    }\n    \n    /*\n     * Decrypt the balance of the file\n     *\n     * Attempt to initialize the ring buffer with contents from the file.\n     * Attempt to read 48 octets of the file into the ring buffer.\n     */\n    if ((bytes_read = fread(buffer, 1, 48, infp)) < 48)\n    {\n        if (!feof(infp))\n        {\n            perror(\"Error reading input file ring:\");\n            return -1;\n        }\n        else\n        {\n            /*\n             * If there are less than 48 octets, the only valid count\n             * is 32 for version 0 (HMAC) and 33 for version 1 or\n             * greater files ( file size modulo + HMAC)\n             */\n            if ((aeshdr.version == 0x00 && bytes_read != 32) ||\n                (aeshdr.version >= 0x01 && bytes_read != 33))\n            {\n                fprintf(stderr, \"Error: Input file is corrupt (1:%u).\\n\",\n                        (unsigned) bytes_read);\n                return -1;\n            }\n            else\n            {\n                /*\n                 * Version 0 files would have the last block size\n                 * read as part of the header, so let's grab that\n                 * value now for version 1 files.\n                 */\n                     * last block size.\n                     */\n                    aeshdr.last_block_size = (buffer[0] & 0x0F);\n                }\n                /*\n                 * If this initial read indicates there is no encrypted\n                 * data, then there should be 0 in the last_block_size field\n                 */\n                if (aeshdr.last_block_size != 0)\n                {\n                    fprintf(stderr, \"Error: Input file is corrupt (2).\\n\");\n                    return -1;\n                }\n            }\n            reached_eof = 1;\n        }\n    }\n    head = buffer + 48;\n    tail = buffer;\n\n    while(!reached_eof)\n            {\n                perror(\"Error reading input file:\");\n                return -1;\n            }\n            else\n            {\n                /* The last block for v0 must be 16 and for v1 it must be 1 */\n                if ((aeshdr.version == 0x00 && bytes_read > 0) ||\n                    (aeshdr.version >= 0x01 && bytes_read != 1))\n                {\n                    fprintf(stderr, \"Error: Input file is corrupt (3:%u).\\n\",\n                            (unsigned) bytes_read);\n                    return -1;\n                }\n\n                /*\n                 * If this is a v1 file, then the file modulo is located\n                 * in the ring buffer at tail + 16 (with consideration\n                 * given to wrapping around the ring, in which case\n                 * it would be at buffer[0])\n                 */\n\n            memcpy(buffer2, tail, 16);\n\n            sha256_update(&sha_ctx, tail, 16);\n            aes_decrypt(&aes_ctx, tail, tail);\n\n            /*\n             * XOR plain text block with previous encrypted\n             * output (i.e., use CBC)\n             */\n            for(i=0; i<16; i++)\n            {\n                tail[i] ^= IV[i];\n            }\n\n            /* Update the IV (CBC mode) */\n            memcpy(IV, buffer2, 16);\n\n            /*\n             * If this is the final block, then we may\n             * write less than 16 octets\n             */\n            n = ((!reached_eof) ||\n                 (aeshdr.last_block_size == 0)) ? 16 : aeshdr.last_block_size;\n\n            /* Write the decrypted block */\n            if ((i = fwrite(tail, 1, n, outfp)) != n)\n            {\n                perror(\"Error writing decrypted block:\");\n                return -1;\n            }\n            \n            /* Move the tail of the ring buffer forward */\n            tail += 16;\n            if (tail == (buffer+64))\n            {\n                tail = buffer;\n            }\n        }\n    }\n\n    /* Verify that the HMAC is correct */\n        {\n            tail = buffer;\n        }\n        memcpy(buffer2+31, tail, 1);\n    }\n\n    if (memcmp(digest, buffer2, 32))\n    {\n        if (aeshdr.version == 0x00)\n        {\n            fprintf(stderr, \"Error: Message has been altered or password is incorrect\\n\");\n        }\n        else\n        {\n            fprintf(stderr, \"Error: Message has been altered and should not be trusted\\n\");\n        }\n\n        return -1;\n    }\n\n    /* Flush the output buffer to ensure all data is written to disk */\n    if (fflush(outfp))\n    {\n        fprintf(stderr, \"Error: Could not flush output file buffer\\n\");\n        return -1;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    aescrypt_hdr aeshdr;\n    sha256_t digest;\n    unsigned char IV[16];\n    unsigned char iv_key[48];\n    unsigned i, j, n;\n    size_t bytes_read;\n    unsigned char buffer[64], buffer2[32];\n    unsigned char *head, *tail;\n    unsigned char ipad[64], opad[64];\n    int reached_eof = 0;\n\n    /* Read the file header */\n    if ((bytes_read = fread(&aeshdr, 1, sizeof(aeshdr), infp)) !=\n         sizeof(aescrypt_hdr))\n    {\n        if (feof(infp))\n        {\n            fprintf(stderr, \"Error: Input file is too short\\n\");\n        }\n        else\n        {\n            perror(\"Error reading the file header:\");\n        }\n        return -1;\n    }\n\n    if (!(aeshdr.aes[0] == 'A' && aeshdr.aes[1] == 'E' &&\n          aeshdr.aes[2] == 'S'))\n    {\n        fprintf(stderr,\n                \"Error: Bad file header (not aescrypt file or is corrupted? \"\n                \"[%x, %x, %x])\\n\",\n                aeshdr.aes[0],\n                aeshdr.aes[1],\n                aeshdr.aes[2]);\n        return -1;\n    }\n\n    /* Validate the version number and take any version-specific actions */\n    if (aeshdr.version == 0)\n    {\n        /*\n         * Let's just consider the least significant nibble to determine\n         * the size of the last block\n         */\n\n    /* Skip over extensions present v2 and later files */\n    if (aeshdr.version >= 0x02)\n    {\n        do\n        {\n            if ((bytes_read = fread(buffer, 1, 2, infp)) != 2)\n            {\n                if (feof(infp))\n                {\n                    fprintf(stderr, \"Error: Input file is too short\\n\");\n                }\n                else\n                {\n                    perror(\"Error reading the file extensions:\");\n                }\n                return -1;\n            }\n            /* Determine the extension length, zero means no more extensions */\n            i = j = (((int)buffer[0]) << 8) | (int)buffer[1];\n            while (i--)\n            {\n                if ((bytes_read = fread(buffer, 1, 1, infp)) != 1)\n                {\n                    if (feof(infp))\n                    {\n                        fprintf(stderr, \"Error: Input file is too short\\n\");\n                    }\n                    else\n                    {\n                        perror(\"Error reading the file extensions:\");\n                    }\n                    return -1;\n                }\n            }\n        } while(j);\n    }\n\n    /* Read the initialization vector from the file */\n    if ((bytes_read = fread(IV, 1, 16, infp)) != 16)\n    {\n        if (feof(infp))\n        {\n            fprintf(stderr, \"Error: Input file is too short\\n\");\n        }\n        else\n        {\n            perror(\"Error reading the initialization vector:\");\n        }\n        return -1;\n    }\n\n    /* Hash the IV and password 8192 times */\n    memset(digest, 0, 32);\n    memcpy(digest, IV, 16);\n    for (i = 0; i < 8192; i++)\n    {\n        sha256_starts(&sha_ctx);\n        sha256_update(&sha_ctx, digest, 32);\n        sha256_update(&sha_ctx, passwd, passlen);\n        sha256_finish(&sha_ctx, digest);\n    }\n\n    /* Set the AES encryption key */\n    aes_set_key(&aes_ctx, digest, 256);\n\n    /* Set the ipad and opad arrays with values as\n     * per RFC 2104 (HMAC).  HMAC is defined as\n     *   H(K XOR opad, H(K XOR ipad, text))\n     */\n    memset(ipad, 0x36, 64);\n    memset(opad, 0x5C, 64);\n\n    for (i = 0; i < 32; i++)\n    {\n        ipad[i] ^= digest[i];\n        opad[i] ^= digest[i];\n    }\n\n    sha256_starts(&sha_ctx);\n    sha256_update(&sha_ctx, ipad, 64);\n\n    /* If this is a version 1 or later file, then read the IV and key\n     * for decrypting the bulk of the file.\n     */\n    if (aeshdr.version >= 0x01)\n    {\n        for (i = 0; i < 48; i += 16)\n        {\n            if ((bytes_read = fread(buffer, 1, 16, infp)) != 16)\n            {\n                if (feof(infp))\n                {\n                    fprintf(stderr, \"Error: Input file is too short\\n\");\n                }\n                else\n                {\n                    perror(\"Error reading input file IV and key:\");\n                }\n                return -1;\n            }\n\n            memcpy(buffer2, buffer, 16);\n\n            sha256_update(&sha_ctx, buffer, 16);\n            aes_decrypt(&aes_ctx, buffer, buffer);\n\n            /*\n             * XOR plain text block with previous encrypted\n             * output (i.e., use CBC)\n             */\n            for (j = 0; j < 16; j++)\n            {\n                iv_key[i + j] = (buffer[j] ^ IV[j]);\n            }\n\n            /* Update the IV (CBC mode) */\n            memcpy(IV, buffer2, 16);\n        }\n\n        /* Verify that the HMAC is correct */\n        sha256_finish(&sha_ctx, digest);\n        sha256_starts(&sha_ctx);\n        sha256_update(&sha_ctx, opad, 64);\n        sha256_update(&sha_ctx, digest, 32);\n        sha256_finish(&sha_ctx, digest);\n\n        if ((bytes_read = fread(buffer, 1, 32, infp)) != 32)\n        {\n            if (feof(infp))\n            {\n                fprintf(stderr, \"Error: Input file is too short\\n\");\n            }\n            else\n            {\n                perror(\"Error reading input file digest:\");\n            }\n            return -1;\n        }\n\n        if (memcmp(digest, buffer, 32))\n        {\n            fprintf(stderr,\n                    \"Error: Message has been altered or password is \"\n                    \"incorrect\\n\");\n            return -1;\n        }\n\n        /*\n         * Re-load the IV and encryption key with the IV and\n         * key to now encrypt the datafile.  Also, reset the HMAC\n         * computation.\n         */\n        memcpy(IV, iv_key, 16);\n\n        aes_set_key(&aes_ctx, iv_key+16, 256);\n\n        /*\n         * Set the ipad and opad arrays with values as\n         * per RFC 2104 (HMAC).  HMAC is defined as\n         *   H(K XOR opad, H(K XOR ipad, text))\n         */\n        memset(ipad, 0x36, 64);\n        memset(opad, 0x5C, 64);\n\n        for (i = 0; i < 32; i++)\n        {\n            ipad[i] ^= iv_key[i + 16];\n            opad[i] ^= iv_key[i + 16];\n        }\n\n        /* Wipe the IV and encryption key from memory */\n        memset_secure(iv_key, 0, 48);\n\n        sha256_starts(&sha_ctx);\n        sha256_update(&sha_ctx, ipad, 64);\n    }\n\n    /*\n     * Decrypt the balance of the file\n     *\n     * Attempt to initialize the ring buffer with contents from the file.\n     * Attempt to read 48 octets of the file into the ring buffer.\n     */\n    if ((bytes_read = fread(buffer, 1, 48, infp)) < 48)\n    {\n        if (!feof(infp))\n        {\n            perror(\"Error reading input file ring:\");\n            return -1;\n        }\n        else\n        {\n            /*\n             * If there are less than 48 octets, the only valid count\n             * is 32 for version 0 (HMAC) and 33 for version 1 or\n             * greater files (file size modulo + HMAC)\n             */\n            if ((aeshdr.version == 0x00 && bytes_read != 32) ||\n                (aeshdr.version >= 0x01 && bytes_read != 33))\n            {\n                fprintf(stderr, \"Error: Input file is corrupt (1:%u)\\n\",\n                        (unsigned) bytes_read);\n                return -1;\n            }\n            else\n            {\n                /*\n                 * Version 0 files would have the last block size\n                 * read as part of the header, so let's grab that\n                 * value now for version 1 files.\n                 */\n                     * last block size.\n                     */\n                    aeshdr.last_block_size = (buffer[0] & 0x0F);\n                }\n                /*\n                 * If this initial read indicates there is no encrypted\n                 * data, then there should be 0 in the last_block_size field\n                 */\n                if (aeshdr.last_block_size != 0)\n                {\n                    fprintf(stderr, \"Error: Input file is corrupt (2)\\n\");\n                    return -1;\n                }\n            }\n            reached_eof = 1;\n        }\n    }\n    head = buffer + 48;\n    tail = buffer;\n\n    while(!reached_eof)\n            {\n                perror(\"Error reading input file:\");\n                return -1;\n            }\n            else\n            {\n                /* The last block for v0 must be 16 and for v1 it must be 1 */\n                if ((aeshdr.version == 0x00 && bytes_read > 0) ||\n                    (aeshdr.version >= 0x01 && bytes_read != 1))\n                {\n                    fprintf(stderr, \"Error: Input file is corrupt (3:%u)\\n\",\n                            (unsigned) bytes_read);\n                    return -1;\n                }\n\n                /*\n                 * If this is a v1 file, then the file modulo is located\n                 * in the ring buffer at tail + 16 (with consideration\n                 * given to wrapping around the ring, in which case\n                 * it would be at buffer[0])\n                 */\n\n            memcpy(buffer2, tail, 16);\n\n            sha256_update(&sha_ctx, tail, 16);\n            aes_decrypt(&aes_ctx, tail, tail);\n\n            /*\n             * XOR plain text block with previous encrypted\n             * output (i.e., use CBC)\n             */\n            for (i = 0; i < 16; i++)\n            {\n                tail[i] ^= IV[i];\n            }\n\n            /* Update the IV (CBC mode) */\n            memcpy(IV, buffer2, 16);\n\n            /*\n             * If this is the final block, then we may\n             * write less than 16 octets\n             */\n            n = ((!reached_eof) ||\n                 (aeshdr.last_block_size == 0)) ? 16 : aeshdr.last_block_size;\n\n            /* Write the decrypted block */\n            if ((i = fwrite(tail, 1, n, outfp)) != n)\n            {\n                perror(\"Error writing decrypted block:\");\n                return -1;\n            }\n\n            /* Move the tail of the ring buffer forward */\n            tail += 16;\n            if (tail == (buffer+64))\n            {\n                tail = buffer;\n            }\n        }\n    }\n\n    /* Verify that the HMAC is correct */\n        {\n            tail = buffer;\n        }\n        memcpy(buffer2+31, tail, 1);\n    }\n\n    if (memcmp(digest, buffer2, 32))\n    {\n        if (aeshdr.version == 0x00)\n        {\n            fprintf(stderr,\n                    \"Error: Message has been altered or password is \"\n                    \"incorrect\\n\");\n        }\n        else\n        {\n            fprintf(stderr,\n                    \"Error: Message has been altered and should not be \"\n                    \"trusted\\n\");\n        }\n\n        return -1;\n    }\n\n    /* Flush the output buffer to ensure all data is written to disk */\n    if (fflush(outfp))\n    {\n        fprintf(stderr, \"Error: Could not flush output file buffer\\n\");\n        return -1;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void fanout_release(struct sock *sk)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_fanout *f;\n\n\tf = po->fanout;\n\tif (!f)\n\t\treturn;\n\n\tmutex_lock(&fanout_mutex);\n\tpo->fanout = NULL;\n\n\tif (atomic_dec_and_test(&f->sk_ref)) {\n\t\tlist_del(&f->list);\n\t\tdev_remove_pack(&f->prot_hook);\n\t\tfanout_release_data(f);\n\t\tkfree(f);\n\t}\n\tmutex_unlock(&fanout_mutex);\n\n\tif (po->rollover)\n\t\tkfree_rcu(po->rollover, rcu);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void fanout_release(struct sock *sk)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_fanout *f;\n\n\tmutex_lock(&fanout_mutex);\n\tf = po->fanout;\n\tif (f) {\n\t\tpo->fanout = NULL;\n\n\t\tif (atomic_dec_and_test(&f->sk_ref)) {\n\t\t\tlist_del(&f->list);\n\t\t\tdev_remove_pack(&f->prot_hook);\n\t\t\tfanout_release_data(f);\n\t\t\tkfree(f);\n\t\t}\n\n\t\tif (po->rollover)\n\t\t\tkfree_rcu(po->rollover, rcu);\n\t}\n\tmutex_unlock(&fanout_mutex);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void fb_write_bin(uint8_t *bin, int len, const fb_t a) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tif (len != RLC_FB_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tRLC_TRY {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void fb_write_bin(uint8_t *bin, size_t len, const fb_t a) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tif (len != RLC_FB_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tRLC_TRY {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "MONGO_EXPORT int bson_append_symbol_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_SYMBOL );\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "MONGO_EXPORT int bson_append_symbol_n( bson *b, const char *name, const char *value, size_t len ) {\n    return bson_append_string_base( b, name, value, len, BSON_SYMBOL );\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n\n    clear(); // clear response\n\n    sessionInitialize();\n    if (!sessionActive() && !isAuthNeeded())\n        sessionStart();\n\n    if (isBanned()) {\n        status(403, \"Forbidden\");\n        print(QObject::tr(\"Your IP address has been banned after too many failed authentication attempts.\"), Http::CONTENT_TYPE_TXT);\n    }\n    else {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "Http::Response AbstractWebApplication::processRequest(const Http::Request &request, const Http::Environment &env)\n{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n\n    // clear response\n    clear();\n\n    // avoid clickjacking attacks\n    header(Http::HEADER_X_FRAME_OPTIONS, \"SAMEORIGIN\");\n\n    sessionInitialize();\n    if (!sessionActive() && !isAuthNeeded())\n        sessionStart();\n\n    if (isBanned()) {\n        status(403, \"Forbidden\");\n        print(QObject::tr(\"Your IP address has been banned after too many failed authentication attempts.\"), Http::CONTENT_TYPE_TXT);\n    }\n    else {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int fb_bits(const fb_t a) {\n\tint i = RLC_FB_DIGS - 1;\n\n\twhile (i >= 0 && a[i] == 0) {\n\t\ti--;\n\t}\n\n\tif (i > 0) {\n\t\treturn (i << RLC_DIG_LOG) + util_bits_dig(a[i]);\n\t} else {\n\t\treturn util_bits_dig(a[0]);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "size_t fb_bits(const fb_t a) {\n\tint i = RLC_FB_DIGS - 1;\n\n\twhile (i >= 0 && a[i] == 0) {\n\t\ti--;\n\t}\n\n\tif (i > 0) {\n\t\treturn (i << RLC_DIG_LOG) + util_bits_dig(a[i]);\n\t} else {\n\t\treturn util_bits_dig(a[0]);\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "          \"Data of TensorProto ( tensor name: \",\n          tensor.name(),\n          \") is stored externally and should not have data field.\",\n          value_field);\n    }\n\n    bool has_location = false;\n    for (const StringStringEntryProto& entry : tensor.external_data()) {\n      if (entry.has_key() && entry.has_value() && entry.key() == \"location\") {\n        has_location = true;\n#ifdef _WIN32\n        auto file_path = std::filesystem::path(utf8str_to_wstring(entry.value()));\n        if (file_path.is_absolute()) {\n          fail_check(\n              \"Location of external TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be a relative path, but it is an absolute path: \",\n              entry.value());\n        }\n        auto relative_path = file_path.lexically_normal().make_preferred().wstring();\n        // Check that normalized relative path contains \"..\" on Windows.\n        if (relative_path.find(L\"..\", 0) != std::string::npos) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be file inside the \",\n              ctx.get_model_dir(),\n              \", but the '\",\n              entry.value(),\n              \"' points outside the directory\");\n        }\n        std::wstring data_path = path_join(utf8str_to_wstring(ctx.get_model_dir()), relative_path);\n        struct _stat64 buff;\n        if (data_path.empty() || (data_path[0] != '#' && _wstat64(data_path.c_str(), &buff) != 0)) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be stored in \",\n              entry.value(),\n              \", but it doesn't exist or is not accessible.\");\n        }\n#else // POSIX\n        if (entry.value().empty()) {\n          fail_check(\"Location of external TensorProto ( tensor name: \", tensor.name(), \") should not be empty.\");\n        } else if (entry.value()[0] == '/') {\n          fail_check(\n              \"Location of external TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be a relative path, but it is an absolute path: \",\n              entry.value());\n        }\n        std::string relative_path = clean_relative_path(entry.value());\n        // Check that normalized relative path contains \"..\" on POSIX\n        if (relative_path.find(\"..\", 0) != std::string::npos) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be file inside the \",\n              ctx.get_model_dir(),\n              \", but the '\",\n              entry.value(),\n              \"' points outside the directory\");\n        }\n        std::string data_path = path_join(ctx.get_model_dir(), relative_path);\n        // use stat64 to check whether the file exists\n#if defined(__APPLE__) || defined(__wasm__) || !defined(__GLIBC__)\n        struct stat buffer; // APPLE, wasm and non-glic stdlibs do not have stat64\n        if (data_path.empty() || (data_path[0] != '#' && stat((data_path).c_str(), &buffer) != 0)) {\n#else\n        struct stat64 buffer; // All POSIX under glibc except APPLE and wasm have stat64\n        if (data_path.empty() || (data_path[0] != '#' && stat64((data_path).c_str(), &buffer) != 0)) {\n#endif\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be stored in \",\n              data_path,\n              \", but it doesn't exist or is not accessible.\");\n        }\n        // Do not allow symlinks or directories.\n        if (data_path.empty() || (data_path[0] != '#' && !S_ISREG(buffer.st_mode))) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be stored in \",\n              data_path,\n              \", but it is not regular file.\");\n        }\n#endif\n      }\n    }\n    if (!has_location) {\n      fail_check(\"TensorProto ( tensor name: \", tensor.name(), \") is stored externally but doesn't have a location.\");\n    }\n    return;\n  }\n  int64_t nelem = 1;\n  for (auto x : tensor.dims()) {\n    nelem *= x;\n        check_field(string_data);\n        break;\n\n      default:\n        fail_check(\"Unrecognized data_type (tensor name: \", tensor.name(), \"): \", tensor.data_type());\n    }\n  }\n\n#undef check_field\n}\n\nvoid check_sequence(const SequenceProto& sequence, const CheckerContext& ctx) {\n  enforce_has_field(sequence, elem_type);\n  if (sequence.elem_type() == SequenceProto::TENSOR) {\n    for (const TensorProto& tensor : sequence.tensor_values()) {\n      check_tensor(tensor, ctx);\n    }\n  } else if (sequence.elem_type() == SequenceProto::SPARSE_TENSOR) {\n    for (const SparseTensorProto& sparse_tensor : sequence.sparse_tensor_values()) {\n      check_sparse_tensor(sparse_tensor, ctx);\n    }\n  } else if (sequence.elem_type() == SequenceProto::SEQUENCE) {\n    for (const SequenceProto& seq : sequence.sequence_values()) {\n      check_sequence(seq, ctx);\n    }\n  } else if (sequence.elem_type() == SequenceProto::MAP) {\n    for (const MapProto& map : sequence.map_values()) {\n      check_map(map, ctx);\n    }\n  } else {\n    fail_check(\n        \"Sequence ( Structure name: \",\n        sequence.name(),\n        \", elem_type: \",\n        sequence.elem_type(),\n        \") is not have a valid element type.\");\n  }\n}\n\nvoid check_optional(const OptionalProto& optional, const CheckerContext& ctx) {\n  enforce_has_field(optional, elem_type);\n  if (optional.elem_type() == OptionalProto::UNDEFINED) {\n    return;\n  } else if (optional.elem_type() == OptionalProto::TENSOR) {\n    if (optional.has_tensor_value())\n      check_tensor(optional.tensor_value(), ctx);\n  } else if (optional.elem_type() == OptionalProto::SPARSE_TENSOR) {\n    if (optional.has_sparse_tensor_value())\n      check_sparse_tensor(optional.sparse_tensor_value(), ctx);\n  } else if (optional.elem_type() == OptionalProto::SEQUENCE) {\n    if (optional.has_sequence_value())\n      check_sequence(optional.sequence_value(), ctx);\n  } else if (optional.elem_type() == OptionalProto::MAP) {\n    if (optional.has_map_value())\n      check_map(optional.map_value(), ctx);\n  } else {\n    fail_check(\n        \"Optional ( Structure name: \",\n        optional.name(),\n        \", elem_type: \",\n        optional.elem_type(),\n        \") is not have a valid element type.\");\n  }\n}\n\nvoid check_map(const MapProto& map, const CheckerContext& ctx) {\n  enforce_has_field(map, key_type);\n  if (map.key_type() == TensorProto::UNDEFINED) {\n    fail_check(\"setting key_type field (map name: \", map.name(), \") to UNDEFINED is not allowed\");\n  }\n  // Check if key is a valid type, specifically INT8, INT16, INT32, INT64,\n  // UINT8, UINT16, UINT32, UINT64, or STRING.\n  if ((map.key_type() == TensorProto::FLOAT) || (map.key_type() == TensorProto::BOOL) ||\n      (map.key_type() == TensorProto::FLOAT16) || (map.key_type() == TensorProto::COMPLEX64) ||\n      (map.key_type() == TensorProto::COMPLEX128)) {\n    fail_check(\n        \"setting key_type field (map name: \",\n        map.name(),\n        \") to invalid TensorProto key_type \",\n        map.key_type(),\n        \" is not allowed\");\n  }\n\n  // MapProto will use either keys or string_keys, so only one should be > 0.\n  if ((map.keys_size() > 0) && (map.string_keys_size() > 0)) {\n    fail_check(\"Map (name: \", map.name(), \") should not contain more than one keys field.\");\n  }\n\n  int num_keys = map.keys_size() + map.string_keys_size();\n  int num_values = 0;\n\n  enforce_has_field(map, values);\n  check_sequence(map.values(), ctx);\n\n  if (map.values().elem_type() == SequenceProto::TENSOR) {\n    num_values = map.values().tensor_values_size();\n  } else if (map.values().elem_type() == SequenceProto::SPARSE_TENSOR) {\n    num_values = map.values().sparse_tensor_values_size();\n  } else if (map.values().elem_type() == SequenceProto::SEQUENCE) {\n    num_values = map.values().sequence_values_size();\n  } else if (map.values().elem_type() == SequenceProto::MAP) {\n    num_values = map.values().map_values_size();\n  }\n\n  if (num_keys != num_values) {\n    fail_check(\"Length of map keys and map values are not the same (map name: \", map.name(), \")\");\n  }\n}\n\n// Check that the index data stored in a SparseTensorProto is valid.\n// indices: a 1-dimensional tensor; indices[i] represents the\n// linearized index value for the i-th nonzero value.\nvoid check_sparse_tensor_indices_1(\n    const TensorProto& indices,\n    const SparseTensorProto& sparse_tensor_proto,\n    size_t nnz) {\n  int dense_rank = sparse_tensor_proto.dims_size();\n  int64_t dense_size = 1;\n  for (int i = 0; i < dense_rank; ++i)\n    dense_size *= sparse_tensor_proto.dims(i);\n  if (static_cast<size_t>(indices.dims(0)) != nnz) {\n    fail_check(\"Sparse tensor indices (\", indices.name(), \") has \", indices.dims(0), \" values, but NNZ is \", nnz);\n  }\n\n  // Check if indices appear in ascending order, and if they have valid\n  // values. The i-th value in index_data is the linear index of the i-th\n  // non-zero value.\n  const std::vector<int64_t> index_data = ParseData<int64_t>(&indices);\n\n  int64_t prev_index = -1;\n  for (size_t i = 0; i < nnz; ++i) {\n    int64_t curr_index = index_data[i]; // linearized index of i-th value\n    if (curr_index < 0 || curr_index >= dense_size) {\n      fail_check(\n          \"Sparse tensor (\",\n          indices.name(),\n          \") index value at position [\",\n          i,\n          \"] out of range [0, \",\n          dense_size - 1,\n          \"]\");\n    }\n    if (curr_index <= prev_index) {\n      fail_check(\"Sparse tensor (\", indices.name(), \") index value at position [\", i, \"] not in sorted order.\");\n    }\n    prev_index = curr_index;\n  }\n}\n\n// Check that the index data stored in a SparseTensorProto is valid.\n// indices: a 2-dimensional tensor; indices[i,j] represents the j-th\n// index value for the i-th nonzero value.\nvoid check_sparse_tensor_indices_2(\n    const TensorProto& indices,\n    const SparseTensorProto& sparse_tensor_proto,\n    size_t nnz) {\n  int dense_rank = sparse_tensor_proto.dims_size();\n  if (static_cast<size_t>(indices.dims(0)) != nnz) {\n    fail_check(\"Sparse tensor indices (\", indices.name(), \") first dimension size does not equal NNZ.\");\n  }\n  if (indices.dims(1) != dense_rank) {\n    fail_check(\"Sparse tensor indices (\", indices.name(), \") second dimension size does not match rank of tensor.\");\n  }\n\n  // Check if indices appear in ascending order, and if they have valid\n  // values.\n  const std::vector<int64_t> index_data = ParseData<int64_t>(&indices);\n  int64_t prev_index = -1;\n  for (size_t i = 0; i < nnz; ++i) {\n    int64_t curr_index = 0; // linearized index of i-th value\n    for (int j = 0; j < dense_rank; ++j) {\n      auto index_ij = index_data[i * dense_rank + j];\n      if ((index_ij < 0) || (index_ij >= sparse_tensor_proto.dims(j))) {\n        fail_check(\"Sparse tensor (\", indices.name(), \") index value at position [\", i, \",\", j, \"] out of range.\");\n      }\n      curr_index = curr_index * sparse_tensor_proto.dims(j) + index_ij;\n    }\n    if (curr_index <= prev_index) {\n      fail_check(\n          \"Sparse tensor (\", indices.name(), \") index value at position [\", i, \"] not in lexicographic sorted order.\");\n    }\n    prev_index = curr_index;\n  }\n}\n\nvoid check_sparse_tensor(const SparseTensorProto& sparse_tensor_proto, const CheckerContext& ctx) {\n  enforce_has_field(sparse_tensor_proto, values);\n\n  const TensorProto& values = sparse_tensor_proto.values();\n  check_tensor(values, ctx);\n\n  // values must be a tensor of shape [NNZ]\n  // Currently we restrict the value associated with a particular index-tuple\n  // to be a single value. In the future, if there is a requirement,\n  // we may extend this to permit the value to be a \"sub-tensor\", in which\n  // case values will have dimension > 1.\n  if (values.dims_size() != 1) {\n    fail_check(\"Sparse tensor values (\", values.name(), \") must have rank 1.\");\n  }\n  size_t nnz = static_cast<size_t>(values.dims(0));\n  int dense_rank = sparse_tensor_proto.dims_size();\n  if (dense_rank == 0) {\n    fail_check(\"Sparse tensor (\", values.name(), \") must have a dense-rank > 0\");\n  }\n  for (int i = 0; i < dense_rank; ++i) {\n    if (sparse_tensor_proto.dims(i) <= 0) {\n      fail_check(\"Sparse tensor (\", values.name(), \") dimensions are not positive.\");\n    }\n  }\n\n  if (sparse_tensor_proto.has_indices()) {\n    const TensorProto& indices = sparse_tensor_proto.indices();\n    check_tensor(indices, ctx);\n    if (indices.data_type() != TensorProto::INT64) {\n      fail_check(\"Sparse tensor indices (\", indices.name(), \") must have INT64 type.\");\n    }\n    switch (indices.dims().size()) {\n      case 1:\n        // Indices in linearized format\n        check_sparse_tensor_indices_1(indices, sparse_tensor_proto, nnz);\n        return;\n      case 2:\n        // Check COO-style index. E.g., an index for a 3D tensor is a 3-tuple.\n        check_sparse_tensor_indices_2(indices, sparse_tensor_proto, nnz);\n        return;\n      default:\n        fail_check(\"Sparse tensor indices (\", indices.name(), \") must have rank 1 or 2.\");\n    }\n  } else if (nnz != 0) {\n    fail_check(\"Sparse tensor (\", values.name(), \") has no index values.\");\n  }\n}\n\n// NB: This is a generic \"attribute well-formedness\" check, it doesn't\n// actually test if an attribute is valid per a schema\nvoid check_attribute(const AttributeProto& attr, const CheckerContext& ctx, const LexicalScopeContext& lex_ctx) {\n  enforce_non_empty_field(attr, name);\n\n  if (ctx.get_ir_version() >= 0x00000002) {\n    enforce_has_field(attr, type);\n  }\n\n  int used_fields = 0;\n\n#define check_type(expected_type)                                                     \\\n  if (attr.has_type() && attr.type() != expected_type) {                              \\\n    fail_check(\"type field and data field mismatch in attribute \", attr.name(), \".\"); \\\n  }\n\n#define check_singular_field(field, type) \\\n  if (attr.has_##field()) {               \\\n    ++used_fields;                        \\\n    check_type(type);                     \\\n  }\n\n#define check_repeated_field(field, type) \\\n  if (attr.field##_size() > 0) {          \\\n    ++used_fields;                        \\\n    check_type(type);                     \\\n  }\n\n  check_singular_field(f, AttributeProto::FLOAT);\n  check_singular_field(i, AttributeProto::INT);\n  check_singular_field(s, AttributeProto::STRING);\n  check_singular_field(t, AttributeProto::TENSOR);\n  check_singular_field(g, AttributeProto::GRAPH);\n  check_singular_field(tp, AttributeProto::TYPE_PROTO);\n  check_singular_field(sparse_tensor, AttributeProto::SPARSE_TENSOR);\n  check_repeated_field(floats, AttributeProto::FLOATS);\n  check_repeated_field(ints, AttributeProto::INTS);\n  check_repeated_field(strings, AttributeProto::STRINGS);\n  check_repeated_field(tensors, AttributeProto::TENSORS);\n  check_repeated_field(graphs, AttributeProto::GRAPHS);\n  check_repeated_field(sparse_tensors, AttributeProto::SPARSE_TENSORS);\n  check_repeated_field(type_protos, AttributeProto::TYPE_PROTOS);\n\n#undef check_type\n#undef check_singular_field\n#undef check_repeated_field\n\n  // Normally, used_fields is expected to be 1.\n  // In proto3, when the value to be set is type default value (say 0 for\n  // int), used_fields may be 0.\n  if (used_fields > 1) {\n    fail_check(\"Attribute (name: \", attr.name(), \") should not contain more than one value field.\");\n  }\n\n  if (!ctx.is_main_graph()) {\n    // It's an attribute of a node in function body.\n    if (attr.has_ref_attr_name() && used_fields != 0) {\n      // The attribute proto is supposed to refer to data outside and does not\n      // have its own value field set.\n      fail_check(\"Attribute (name: \", attr.name(), \") should refer to attribute in parent node.\");\n    }\n  }\n\n  if (attr.has_t()) {\n    check_tensor(attr.t(), ctx);\n  }\n\n  if (attr.has_sparse_tensor()) {\n    check_sparse_tensor(attr.sparse_tensor(), ctx);\n  }\n\n  if (attr.has_g()) {\n    CheckerContext subgraph_ctx(ctx);\n    subgraph_ctx.set_is_main_graph(false);\n    check_graph(attr.g(), subgraph_ctx, lex_ctx);\n  }\n\n  for (const auto& tensor : attr.tensors()) {\n    check_tensor(tensor, ctx);\n  }\n  for (const auto& sparse_tensor : attr.sparse_tensors()) {\n    check_sparse_tensor(sparse_tensor, ctx);\n  }\n  if (attr.graphs().size() > 0) {\n    CheckerContext subgraph_ctx(ctx);\n    subgraph_ctx.set_is_main_graph(false);\n    for (const auto& graph : attr.graphs()) {\n      check_graph(graph, subgraph_ctx, lex_ctx);\n    }\n  }\n}\n\nvoid print_warning_if_has_experimental(const std::unordered_set<std::string>& used_experimental_ops) {\n  if (!used_experimental_ops.empty()) {\n    std::string all_experimental_ops;\n    for (const auto& op : used_experimental_ops) {\n      all_experimental_ops += \" \" + op + \",\";\n    }\n    // Remove the last comma which is unnecessary\n    all_experimental_ops.pop_back();\n    std::cout << \"Warning: Model contains experimental ops:\" + all_experimental_ops << std::endl;\n  }\n}\n\nvoid check_node(const NodeProto& node, const CheckerContext& ctx, const LexicalScopeContext& lex_ctx) {\n  enforce_non_empty_field(node, op_type);\n\n  if (node.input().empty() && node.output().empty()) {\n    fail_check(\"NodeProto (name: \", node.name(), \", type: \", node.op_type(), \") has zero input and zero output.\");\n  }\n\n  // Resolve domain for node\n  const auto& opset_imports = ctx.get_opset_imports();\n  auto dit = opset_imports.find(node.domain());\n  if (dit == opset_imports.end()) {\n    fail_check(\"No opset import for domain '\" + node.domain() + \"'\");\n  }\n  auto domain_version = dit->second;\n\n  // for ops referencing local functions, there is no schema to verify it.\n  // will add a check to verify consistency between these ops and local functions.\n  std::unordered_set<std::string> seen_attr_names{};\n  for (const auto& attr : node.attribute()) {\n    if (!seen_attr_names.insert(attr.name()).second) {\n      fail_check(\"Attribute '\", attr.name(), \"' appeared multiple times.\");\n    };\n\n    check_attribute(attr, ctx, lex_ctx);\n  }\n\n  // This issue will be caught by check_graph instead\n  if (check_is_experimental_op(node)) {\n    return;\n  }\n\n  const auto* schema = ctx.get_schema_registry()->GetSchema(node.op_type(), domain_version, node.domain());\n  if (!schema) {\n    if (node.domain() == ONNX_DOMAIN || node.domain() == AI_ONNX_ML_DOMAIN || node.domain() == \"ai.onnx\" ||\n        node.domain() == AI_ONNX_TRAINING_DOMAIN) {\n      // fail the checker if op in built-in domains has no schema\n      fail_check(\n          \"No Op registered for \" + node.op_type() + \" with domain_version of \" +\n          ONNX_NAMESPACE::to_string(domain_version));\n    } else {\n      // TODO: expose the registration of the op schemas appropriately in\n      // python, so we can load and register operators in other domains\n      //\n      // before we complete the above todo, let's skip the schema check for\n      // now\n    }\n  } else if (schema->Deprecated()) {\n    fail_check(\n        \"Op registered for \" + node.op_type() + \" is deprecated in domain_version of \" +\n        ONNX_NAMESPACE::to_string(domain_version));\n  } else {\n    schema->Verify(node);\n  }\n}\n\nvoid check_graph(const GraphProto& graph, const CheckerContext& ctx, const LexicalScopeContext& parent_lex) {\n  enforce_non_empty_field(graph, name);\n\n  for (const auto& value_info : graph.input()) {\n    check_value_info(value_info, ctx);\n  }\n  for (const auto& value_info : graph.output()) {\n    check_value_info(value_info, ctx);\n  }\n\n  // Inherit values available in outer scope\n  // Note that we do not allow shadowing, so the presence of an already-defined\n  // name is always an error.\n  LexicalScopeContext lex_ctx{parent_lex};\n\n  for (const auto& value_info : graph.input()) {\n    // TODO: If shadowing isn't allowed, this should maybe use\n    // this_or_ancestor_graph_has\n    if (lex_ctx.this_graph_has(value_info.name())) {\n      fail_check(\n          \"Graph must be in single static assignment (SSA) form, however '\",\n          value_info.name(),\n          \"' has been used as graph input names multiple times.\");\n    }\n    lex_ctx.add(value_info.name());\n  }\n\n  std::unordered_set<std::reference_wrapper<const std::string>, std::hash<std::string>, std::equal_to<std::string>>\n      initializer_name_checker;\n\n  for (const auto& init : graph.initializer()) {\n    enforce_has_field(init, name);\n    const auto& name = init.name();\n    if (name.empty()) {\n      fail_check(\"Tensor initializers must have a non-empty name\");\n    }\n\n    if (!initializer_name_checker.insert(std::cref(name)).second) {\n      fail_check(name + \" initializer name is not unique\");\n    }\n\n    check_tensor(init, ctx);\n\n    if (ctx.get_ir_version() <= 0x00000003) {\n      // Initializers are a subset of graph inputs for IR_VERSION <= 3\n      if (!lex_ctx.this_graph_has(name)) {\n        fail_check(name + \" in initializer but not in graph input\");\n      }\n    } else {\n      // An initializer is allowed to have the same name as an input,\n      // but is not required to (for IR_VERSION >= 4)\n      lex_ctx.add(name);\n    }\n  }\n\n  for (const auto& sparse_init : graph.sparse_initializer()) {\n    const auto& values = sparse_init.values();\n    enforce_has_field(values, name);\n    const auto& name = values.name();\n    if (name.empty()) {\n      fail_check(\"Sparse tensor initializers must have a non-empty name\");\n    }\n    if (!initializer_name_checker.insert(std::cref(name)).second) {\n      fail_check(name + \" sparse initializer name is not unique across initializers and sparse_initializers\");\n    }\n    check_sparse_tensor(sparse_init, ctx);\n    lex_ctx.add(name);\n  }\n  std::unordered_set<std::string> used_experimental_ops;\n  for (const auto& node : graph.node()) {\n    // nodes must be in topologically sorted order\n    for (const auto& input : node.input()) {\n      // explicit optional input\n      if (input.empty()) {\n        continue;\n      }\n      if (!lex_ctx.this_or_ancestor_graph_has(input)) {\n        fail_check(\n            \"Nodes in a graph must be topologically sorted, however input '\",\n            input,\n            \"' of node: \\n\",\n            \"name: \",\n            node.name(),\n            \" OpType: \",\n            node.op_type(),\n            \"\\n is not output of any previous nodes.\");\n      }\n    }\n\n    if (check_is_experimental_op(node)) {\n      used_experimental_ops.insert(node.op_type());\n    }\n\n    // This needs to happen before SSA check since we don't want to recurse and\n    // find that outputs from control flow ops are colliding with names in the\n    // inner block\n\n    ONNX_TRY {\n      check_node(node, ctx, lex_ctx);\n    }\n    ONNX_CATCH(ValidationError & ex) {\n      ONNX_HANDLE_EXCEPTION([&]() {\n        ex.AppendContext(\"Bad node spec for node. Name: \" + node.name() + \" OpType: \" + node.op_type());\n        ONNX_THROW_EX(ex);\n      });\n    }\n    // check for SSA form\n    for (const auto& output : node.output()) {\n      // optional output\n      if (output.empty()) {\n        continue;\n      }\n\n      if (lex_ctx.this_or_ancestor_graph_has(output)) {\n        fail_check(\n            \"Graph must be in single static assignment (SSA) form, however '\",\n            output,\n            \"' has been used as output names multiple times.\");\n      }\n      lex_ctx.add(output);\n    }\n  }\n  print_warning_if_has_experimental(used_experimental_ops);\n}\n\n// Utilify function to get the imported version of domain from opset imports\n// Returns -1 if requested domain is not found in the opset_imports\nint get_version_for_domain(const std::string& domain, const std::unordered_map<std::string, int>& opset_imports) {\n  auto it = opset_imports.find(domain);\n  if (it == opset_imports.end()) {\n    return -1;\n  }\n\n  return it->second;\n}\n\nvoid check_opset_compatibility(\n    const NodeProto& node,\n    const CheckerContext& ctx,\n    const std::unordered_map<std::string, int>& func_opset_imports,\n    const std::unordered_map<std::string, int>& model_opset_imports) {\n  auto func_opset_version = get_version_for_domain(node.domain(), func_opset_imports);\n  auto model_opset_version = get_version_for_domain(node.domain(), model_opset_imports);\n\n  if (func_opset_version == -1) {\n    fail_check(\"No Opset registered for domain \" + node.domain());\n  }\n\n  if (model_opset_version == -1) {\n    // model does not include opset import for a node present in function body.\n    // This is ok as along as the opset import is present in function level opset imports.\n    return;\n  }\n\n  if (func_opset_version == model_opset_version) {\n    // both versions are same, no need to verify schema.\n    return;\n  }\n\n  const auto* schema_for_model_import =\n      ctx.get_schema_registry()->GetSchema(node.op_type(), model_opset_version, node.domain());\n\n  const auto* schema_for_function_import =\n      ctx.get_schema_registry()->GetSchema(node.op_type(), func_opset_version, node.domain());\n\n  if (!schema_for_model_import && !schema_for_function_import) {\n    // the op belongs to a custom domain so we cannot verify schema\n    return;\n  }\n\n  // if schema is present for 1 but not other or the schema since versions do not match then raise an error\n  if (!schema_for_model_import || !schema_for_function_import ||\n      schema_for_function_import->since_version() != schema_for_model_import->since_version()) {\n    fail_check(\n        \"Opset import for domain \" + node.domain() + \" in function op \" + node.op_type() +\n        \"is not compatible with the version imported by model. FunctionOp imports version \" +\n        ONNX_NAMESPACE::to_string(func_opset_version) + \" whereas model imports version \" +\n        ONNX_NAMESPACE::to_string(model_opset_version));\n  }\n}\n\nvoid check_model_local_functions(\n    const ModelProto& model,\n    const CheckerContext& ctx,\n    const LexicalScopeContext& parent_lex) {\n  // make a copy of model opset imports to maintain a main copy of opset imports across the model and\n  // all model local functions to verify opset compatibility\n  std::unordered_map<std::string, int> model_opset_imports(ctx.get_opset_imports());\n\n  // merge the opset imports from every function in model_opset_imports\n  // only add the opset import if an entry for it does not exist in model_opset_imports\n  // if there is an entry then the compatibility will be checked later on in check_opset_compatibility\n  // called by check_function.\n  for (const auto& function_proto : model.functions()) {\n    for (const auto& opset_import : function_proto.opset_import()) {\n      if (get_version_for_domain(opset_import.domain(), model_opset_imports) == -1) {\n        model_opset_imports[opset_import.domain()] = opset_import.version();\n      }\n    }\n  }\n\n  CheckerContext ctx_copy = ctx;\n  ctx_copy.set_opset_imports(model_opset_imports);\n\n  for (const auto& function_proto : model.functions()) {\n    check_function(function_proto, ctx_copy, parent_lex);\n  }\n}\n\nvoid check_function(const FunctionProto& function, const CheckerContext& ctx, const LexicalScopeContext& parent_lex) {\n  enforce_non_empty_field(function, name);\n\n  if (ctx.get_ir_version() >= 0x00000008) {\n    enforce_has_field(function, domain);\n  }\n\n  const auto& model_opset_imports = ctx.get_opset_imports();\n  CheckerContext ctx_copy = ctx;\n\n  std::unordered_map<std::string, int> func_opset_imports;\n  for (auto& relied_opset : function.opset_import()) {\n    func_opset_imports[relied_opset.domain()] = static_cast<int>(relied_opset.version());\n  }\n\n  ctx_copy.set_opset_imports(func_opset_imports);\n\n  LexicalScopeContext lex_ctx{parent_lex};\n\n  for (const auto& input : function.input()) {\n    // TODO: If shadowing isn't allowed, this should maybe use\n    // this_or_ancestor_graph_has\n    if (lex_ctx.this_graph_has(input)) {\n      fail_check(\n          \"Graph must be in single static assignment (SSA) form, however '\", input, \"' has been used multiple times.\");\n    }\n    lex_ctx.add(input);\n  }\n\n  std::unordered_set<std::string> outputs;\n  for (const auto& output : function.output()) {\n    auto result = outputs.insert(output);\n    if (!result.second) {\n      fail_check(\"function (\", function.name(), \") should not have duplicate outputs specified.\");\n    }\n  }\n\n  std::unordered_set<std::string> attrs;\n  for (const auto& attr : function.attribute()) {\n    auto result = attrs.insert(attr);\n    if (!result.second) {\n      fail_check(\"function (\", function.name(), \") should not have duplicate attributes specified.\");\n    }\n  }\n  std::unordered_set<std::string> used_experimental_ops;\n  for (const auto& node : function.node()) {\n    // nodes must be in topologically sorted order\n    for (const auto& input : node.input()) {\n      // explicit optional input\n      if (input.empty()) {\n        continue;\n      }\n      if (!lex_ctx.this_graph_has(input)) {\n        fail_check(\n            \"Nodes in a function must be topologically sorted, however input '\",\n            input,\n            \"' of node: \\n\",\n            \"Name: \",\n            node.name(),\n            \" OpType: \",\n            node.op_type(),\n            \"\\n is neither output of any previous nodes nor input of the function.\");\n      }\n    }\n\n    // check whether the opset version imported for a domain by function and model are\n    // compatible\n    if (!ctx_copy.skip_opset_compatibility_check())\n      check_opset_compatibility(node, ctx_copy, func_opset_imports, model_opset_imports);\n    if (check_is_experimental_op(node)) {\n      used_experimental_ops.insert(node.op_type());\n    }\n    check_node(node, ctx_copy, lex_ctx);\n\n    // check for SSA form\n    for (const auto& output : node.output()) {\n      // optional output\n      if (output.empty()) {\n        continue;\n      }\n      if (lex_ctx.this_or_ancestor_graph_has(output)) {\n        fail_check(\n            \"Function must be in single static assignment (SSA) form, however '\",\n            output,\n            \"' has been used as output names multiple times.\");\n      }\n      lex_ctx.add(output);\n    }\n  }\n  print_warning_if_has_experimental(used_experimental_ops);\n}\n\nvoid check_model(const ModelProto& model, CheckerContext& ctx) {\n  if (!model.ir_version()) {\n    fail_check(\"The model does not have an ir_version set properly.\");\n  }\n  if (model.ir_version() > IR_VERSION) {\n    fail_check(\"Your model ir_version \", model.ir_version(), \" is higher than the checker's (\", IR_VERSION, \").\");\n  }\n  if (model.metadata_props_size() > 1) {\n    std::unordered_set<std::string> keys;\n    for (const StringStringEntryProto& entry : model.metadata_props()) {\n      auto i = keys.insert(entry.key());\n      if (!i.second) {\n        fail_check(\"Your model has duplicate keys in metadata_props.\");\n      }\n    }\n  }\n  std::unordered_map<std::string, int> versions;\n  ctx.set_ir_version(static_cast<int>(model.ir_version()));\n  std::unordered_map<std::string, int> opset_imports;\n  for (const auto& opset_import : model.opset_import()) {\n    opset_imports[opset_import.domain()] = static_cast<int>(opset_import.version());\n  }\n  if (model.ir_version() >= 3) {\n    if (opset_imports.empty()) {\n      fail_check(\"model with IR version >= 3 must specify opset_import for ONNX\");\n    }\n  } else {\n    if (opset_imports.empty())\n      opset_imports[ONNX_DOMAIN] = 1;\n    else {\n      fail_check(\"model with IR version < 3 cannot have opset_import specified\");\n    }\n  }\n  ctx.set_opset_imports(opset_imports);\n  LexicalScopeContext lex_ctx;\n  check_graph(model.graph(), ctx, lex_ctx);\n\n  if (ctx.get_ir_version() >= 0x00000008) {\n    check_model_local_functions(model, ctx, lex_ctx);\n    // TODO: check consistency between local functions and ops referencing it.\n  }\n}\n\nvoid check_model(const std::string& model_path, bool full_check, bool skip_opset_compatibility_check) {\n  ModelProto model;\n  LoadProtoFromPath(model_path, model);\n\n  CheckerContext ctx;\n  std::string model_dir;\n  size_t pos = model_path.find_last_of(\"\\\\/\");\n  if (pos != std::string::npos) {\n    model_dir = model_path.substr(0, pos + 1);\n  }\n  ctx.set_model_dir(model_dir);\n  ctx.set_skip_opset_compatibility_check(skip_opset_compatibility_check);\n  check_model(model, ctx);\n\n  if (full_check) {\n    ShapeInferenceOptions options{true, 1, false};\n    ONNX_NAMESPACE::shape_inference::InferShapes(model, ctx.get_schema_registry(), options);\n  }\n}\n\nvoid check_model(const ModelProto& model, bool full_check, bool skip_opset_compatibility_check) {\n  CheckerContext ctx;\n  ctx.set_skip_opset_compatibility_check(skip_opset_compatibility_check);\n  check_model(model, ctx);\n  if (full_check) {\n    ShapeInferenceOptions options{true, 1, false};\n    // Do not update the model in place by the check from shape inference\n    // because checker should not modify the original model\n    ModelProto copy = model;\n    ONNX_NAMESPACE::shape_inference::InferShapes(copy, ctx.get_schema_registry(), options);\n  }\n}\n\nstd::set<std::string> experimental_ops = {\n    \"ATen\",\n    \"Affine\",\n    \"ConstantFill\",\n    \"Crop\",\n    \"DynamicSlice\",\n    \"GRUUnit\",\n    \"GivenTensorFill\",\n    \"ImageScaler\",\n    \"ParametricSoftplus\",\n    \"Scale\",\n    \"ScaledTanh\"};\n\nbool check_is_experimental_op(const NodeProto& node) {\n  return (node.domain() == ONNX_DOMAIN || node.domain() == \"ai.onnx\") && experimental_ops.count(node.op_type());\n}\n\n#undef enforce_has_field\n#undef enforce_non_empty_field\n\n} // namespace checker",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "          \"Data of TensorProto ( tensor name: \",\n          tensor.name(),\n          \") is stored externally and should not have data field.\",\n          value_field);\n    }\n\n    bool has_location = false;\n    for (const StringStringEntryProto& entry : tensor.external_data()) {\n      if (entry.has_key() && entry.has_value() && entry.key() == \"location\") {\n        has_location = true;\n        resolve_external_data_location(ctx.get_model_dir(), entry.value(), tensor.name());\n      }\n    }\n    if (!has_location) {\n      fail_check(\"TensorProto ( tensor name: \", tensor.name(), \") is stored externally but doesn't have a location.\");\n    }\n    return;\n  }\n  int64_t nelem = 1;\n  for (auto x : tensor.dims()) {\n    nelem *= x;\n      case TensorProto::STRING:\n        check_field(string_data);\n        break;\n\n      default:\n        fail_check(\"Unrecognized data_type (tensor name: \", tensor.name(), \"): \", tensor.data_type());\n    }\n  }\n\n#undef check_field\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tpopulate_cache_headers (cache);\n\tif (!cache->hdr) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tpopulate_cache_maps (cache);\n\tif (!cache->maps) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps);\n\tcache->bins = create_cache_bins (bf, cache);\n\tif (!cache->bins) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->locsym = r_dyld_locsym_new (cache);\n\tcache->rebase_infos = get_rebase_infos (bf, cache);\n\tif (cache->rebase_infos) {\n\t\tif (!rebase_infos_get_slide (cache)) {\n\t\t\tif (!pending_bin_files) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tpopulate_cache_headers (cache);\n\tif (!cache->hdr) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tpopulate_cache_maps (cache);\n\tif (!cache->maps) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps, cache->n_maps);\n\tcache->bins = create_cache_bins (bf, cache);\n\tif (!cache->bins) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->locsym = r_dyld_locsym_new (cache);\n\tcache->rebase_infos = get_rebase_infos (bf, cache);\n\tif (cache->rebase_infos) {\n\t\tif (!rebase_infos_get_slide (cache)) {\n\t\t\tif (!pending_bin_files) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  DeletionConfirmationDlg(QWidget *parent, const int &size, const QString &name, bool defaultDeleteFiles): QDialog(parent) {\n    setupUi(this);\n    if (size == 1)\n      label->setText(tr(\"Are you sure you want to delete '%1' from the transfer list?\", \"Are you sure you want to delete 'ubuntu-linux-iso' from the transfer list?\").arg(name));\n    else\n      label->setText(tr(\"Are you sure you want to delete these %1 torrents from the transfer list?\", \"Are you sure you want to delete these 5 torrents from the transfer list?\").arg(QString::number(size)));\n    // Icons\n    lbl_warn->setPixmap(GuiIconProvider::instance()->getIcon(\"dialog-warning\").pixmap(lbl_warn->height()));\n    lbl_warn->setFixedWidth(lbl_warn->height());\n    rememberBtn->setIcon(GuiIconProvider::instance()->getIcon(\"object-locked\"));\n\n    move(Utils::Misc::screenCenter(this));\n    checkPermDelete->setChecked(defaultDeleteFiles || Preferences::instance()->deleteTorrentFilesAsDefault());\n    connect(checkPermDelete, SIGNAL(clicked()), this, SLOT(updateRememberButtonState()));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  DeletionConfirmationDlg(QWidget *parent, const int &size, const QString &name, bool defaultDeleteFiles): QDialog(parent) {\n    setupUi(this);\n    if (size == 1)\n      label->setText(tr(\"Are you sure you want to delete '%1' from the transfer list?\", \"Are you sure you want to delete 'ubuntu-linux-iso' from the transfer list?\").arg(Utils::String::toHtmlEscaped(name)));\n    else\n      label->setText(tr(\"Are you sure you want to delete these %1 torrents from the transfer list?\", \"Are you sure you want to delete these 5 torrents from the transfer list?\").arg(QString::number(size)));\n    // Icons\n    lbl_warn->setPixmap(GuiIconProvider::instance()->getIcon(\"dialog-warning\").pixmap(lbl_warn->height()));\n    lbl_warn->setFixedWidth(lbl_warn->height());\n    rememberBtn->setIcon(GuiIconProvider::instance()->getIcon(\"object-locked\"));\n\n    move(Utils::Misc::screenCenter(this));\n    checkPermDelete->setChecked(defaultDeleteFiles || Preferences::instance()->deleteTorrentFilesAsDefault());\n    connect(checkPermDelete, SIGNAL(clicked()), this, SLOT(updateRememberButtonState()));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void trustedEnclaveInit(uint32_t _logLevel) {\n    CALL_ONCE\n    LOG_INFO(__FUNCTION__);\n\n    globalLogLevel_ = _logLevel;\n\n    oc_realloc_func = &reallocate_function;\n    oc_free_func = &free_function;\n\n    LOG_INFO(\"Setting memory functions\");\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void trustedEnclaveInit(uint64_t _logLevel) {\n    CALL_ONCE\n    LOG_INFO(__FUNCTION__);\n\n    globalLogLevel_ = _logLevel;\n\n    oc_realloc_func = &reallocate_function;\n    oc_free_func = &free_function;\n\n    LOG_INFO(\"Setting memory functions\");\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "inline typename V::VectorType FBUnserializer<V>::unserializeList() {\n  p_ += CODE_SIZE;\n\n  // the list size is written so we can reserve it in the vector\n  // in future. Skip past it for now.\n  unserializeInt64();\n\n  typename V::VectorType ret = V::createVector();\n\n  size_t code = nextCode();\n  while (code != FB_SERIALIZE_STOP) {\n    V::vectorAppend(ret, unserializeThing());\n    code = nextCode();\n  }\n  p_ += CODE_SIZE;\n  return ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "inline typename V::VectorType FBUnserializer<V>::unserializeList(size_t depth) {\n  p_ += CODE_SIZE;\n\n  // the list size is written so we can reserve it in the vector\n  // in future. Skip past it for now.\n  unserializeInt64();\n\n  typename V::VectorType ret = V::createVector();\n\n  size_t code = nextCode();\n  while (code != FB_SERIALIZE_STOP) {\n    V::vectorAppend(ret, unserializeThing(depth + 1));\n    code = nextCode();\n  }\n  p_ += CODE_SIZE;\n  return ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "ResponsePtr Server::ServeStatic(RequestPtr request) {\n  assert(request->method() == methods::kGet);\n\n  if (doc_root_.empty()) {\n    LOG_INFO(\"The doc root was not specified\");\n    return {};\n  }\n\n  fs::path path = doc_root_ / request->url().path();\n\n  try {\n    // NOTE: FileBody might throw Error::kFileError.\n    auto body = std::make_shared<FileBody>(path, file_chunk_size_);\n\n    auto response = std::make_shared<Response>(Status::kOK);\n\n    std::string extension = path.extension().string();\n    response->SetContentType(media_types::FromExtension(extension), \"\");\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "ResponsePtr Server::ServeStatic(RequestPtr request) {\n  assert(request->method() == methods::kGet);\n\n  if (doc_root_.empty()) {\n    LOG_INFO(\"The doc root was not specified\");\n    return {};\n  }\n\n  std::string url_path = Url::DecodeUnsafe(request->url().path());\n  fs::path sub_path = utility::TranslatePath(url_path);\n  fs::path path = doc_root_ / sub_path;\n\n  try {\n    // NOTE: FileBody might throw Error::kFileError.\n    auto body = std::make_shared<FileBody>(path, file_chunk_size_);\n\n    auto response = std::make_shared<Response>(Status::kOK);\n\n    std::string extension = path.extension().string();\n    response->SetContentType(media_types::FromExtension(extension), \"\");\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void dvb_usbv2_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *name = d->name;\n\tstruct device dev = d->udev->dev;\n\n\tdev_dbg(&d->udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\n\tif (d->props->exit)\n\t\td->props->exit(d);\n\n\tdvb_usbv2_exit(d);\n\n\tdev_info(&dev, \"%s: '%s' successfully deinitialized and disconnected\\n\",\n\t\t\tKBUILD_MODNAME, name);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void dvb_usbv2_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *devname = kstrdup(dev_name(&d->udev->dev), GFP_KERNEL);\n\tconst char *drvname = d->name;\n\n\tdev_dbg(&d->udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\n\tif (d->props->exit)\n\t\td->props->exit(d);\n\n\tdvb_usbv2_exit(d);\n\n\tpr_info(\"%s: '%s:%s' successfully deinitialized and disconnected\\n\",\n\t\tKBUILD_MODNAME, drvname, devname);\n\tkfree(devname);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\tset_acl_inode(inode, inode->i_mode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tset_acl_inode(inode, inode->i_mode);\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    inline int check(int itemSize, int nItems=1)\n    {\n      if (ptr + itemSize * nItems > end) {\n        if (ptr + itemSize > end)\n          return overrun(itemSize, nItems);\n\n        nItems = (end - ptr) / itemSize;\n      }\n      return nItems;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    inline size_t check(size_t itemSize, size_t nItems=1)\n    {\n      if (ptr + itemSize * nItems > end) {\n        if (ptr + itemSize > end)\n          return overrun(itemSize, nItems);\n\n        nItems = (end - ptr) / itemSize;\n      }\n      return nItems;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "String UTF16BEDecoder::to_utf8(const StringView& input)\n{\n    StringBuilder builder(input.length() / 2);\n    for (size_t i = 0; i < input.length(); i += 2) {\n        u16 code_point = (input[i] << 8) | input[i + 1];\n        builder.append_code_point(code_point);\n    }\n    return builder.to_string();\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "String UTF16BEDecoder::to_utf8(const StringView& input)\n{\n    StringBuilder builder(input.length() / 2);\n    size_t utf16_length = input.length() - (input.length() % 2);\n    for (size_t i = 0; i < utf16_length; i += 2) {\n        u16 code_point = (input[i] << 8) | input[i + 1];\n        builder.append_code_point(code_point);\n    }\n    return builder.to_string();\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t}\n\n\tre->last = 0;\n\n\tjs_newarray(J);\n\n\tlen = 0;\n\ta = text;\n\te = text + strlen(text);\n\twhile (a <= e) {\n\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n\t\t\tbreak;\n\n\t\tb = m.sub[0].sp;\n\t\tc = m.sub[0].ep;\n\n\t\tjs_pushlstring(J, b, c - b);\n\t\tjs_setindex(J, -2, len++);\n\n\t\ta = c;\n\t\tif (c - b == 0)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t}\n\n\tre->last = 0;\n\n\tjs_newarray(J);\n\n\tlen = 0;\n\ta = text;\n\te = text + strlen(text);\n\twhile (a <= e) {\n\t\tif (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n\t\t\tbreak;\n\n\t\tb = m.sub[0].sp;\n\t\tc = m.sub[0].ep;\n\n\t\tjs_pushlstring(J, b, c - b);\n\t\tjs_setindex(J, -2, len++);\n\n\t\ta = c;\n\t\tif (c - b == 0)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t\tpf_set_protostate(*stp, pdst,\n\t\t\t\t    TCPS_FIN_WAIT_2);\n\t\t}\n\t\tif (th->th_flags & TH_RST)\n\t\t\tpf_set_protostate(*stp, PF_PEER_BOTH, TCPS_TIME_WAIT);\n\n\t\t/* update expire time */\n\t\t(*stp)->expire = getuptime();\n\t\tif (src->state >= TCPS_FIN_WAIT_2 &&\n\t\t    dst->state >= TCPS_FIN_WAIT_2)\n\t\t\t(*stp)->timeout = PFTM_TCP_CLOSED;\n\t\telse if (src->state >= TCPS_CLOSING &&\n\t\t    dst->state >= TCPS_CLOSING)\n\t\t\t(*stp)->timeout = PFTM_TCP_FIN_WAIT;\n\t\telse if (src->state < TCPS_ESTABLISHED ||\n\t\t    dst->state < TCPS_ESTABLISHED)\n\t\t\t(*stp)->timeout = PFTM_TCP_OPENING;\n\t\telse if (src->state >= TCPS_CLOSING ||\n\t\t    dst->state >= TCPS_CLOSING)\n\t\t\t(*stp)->timeout = PFTM_TCP_CLOSING;\n\t\telse\n\t\t\t(*stp)->timeout = PFTM_TCP_ESTABLISHED;\n\n\t\t/* Fall through to PASS packet */\n\t} else if ((dst->state < TCPS_SYN_SENT ||\n\t\tdst->state >= TCPS_FIN_WAIT_2 ||\n\t\tsrc->state >= TCPS_FIN_WAIT_2) &&\n\t    SEQ_GEQ(src->seqhi + MAXACKWINDOW, data_end) &&\n\t    /* Within a window forward of the originating packet */\n\t    SEQ_GEQ(seq, src->seqlo - MAXACKWINDOW)) {\n\t    /* Within a window backward of the originating packet */\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\t\tpf_set_protostate(*stp, pdst,\n\t\t\t\t    TCPS_FIN_WAIT_2);\n\t\t}\n\t\tif (th->th_flags & TH_RST)\n\t\t\tpf_set_protostate(*stp, PF_PEER_BOTH, TCPS_TIME_WAIT);\n\n\t\t/* update expire time */\n\t\t(*stp)->expire = getuptime();\n\t\tif (src->state >= TCPS_FIN_WAIT_2 &&\n\t\t    dst->state >= TCPS_FIN_WAIT_2)\n\t\t\tpf_update_state_timeout(*stp, PFTM_TCP_CLOSED);\n\t\telse if (src->state >= TCPS_CLOSING &&\n\t\t    dst->state >= TCPS_CLOSING)\n\t\t\tpf_update_state_timeout(*stp, PFTM_TCP_FIN_WAIT);\n\t\telse if (src->state < TCPS_ESTABLISHED ||\n\t\t    dst->state < TCPS_ESTABLISHED)\n\t\t\tpf_update_state_timeout(*stp, PFTM_TCP_OPENING);\n\t\telse if (src->state >= TCPS_CLOSING ||\n\t\t    dst->state >= TCPS_CLOSING)\n\t\t\tpf_update_state_timeout(*stp, PFTM_TCP_CLOSING);\n\t\telse\n\t\t\tpf_update_state_timeout(*stp, PFTM_TCP_ESTABLISHED);\n\n\t\t/* Fall through to PASS packet */\n\t} else if ((dst->state < TCPS_SYN_SENT ||\n\t\tdst->state >= TCPS_FIN_WAIT_2 ||\n\t\tsrc->state >= TCPS_FIN_WAIT_2) &&\n\t    SEQ_GEQ(src->seqhi + MAXACKWINDOW, data_end) &&\n\t    /* Within a window forward of the originating packet */\n\t    SEQ_GEQ(seq, src->seqlo - MAXACKWINDOW)) {\n\t    /* Within a window backward of the originating packet */\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkinName;\n\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkinName;\n\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkinName;\n        }\n    }\n\n    return sRet + \"/\";\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    const CString sSkin = sSkinName.Replace_n(\"/\", \"_\").Replace_n(\".\", \"_\");\n\n    CString sRet = CZNC::Get().GetZNCPath() + \"/webskins/\" + sSkin;\n\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"/webskins/\" + sSkin;\n\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"/\" + sSkin;\n        }\n    }\n\n    return sRet + \"/\";\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int16_t decodeSample(ms_adpcm_state &state,\n\tuint8_t code, const int16_t *coefficient)\n{\n\tint linearSample = (state.sample1 * coefficient[0] +\n\t\tstate.sample2 * coefficient[1]) >> 8;\n\n\tlinearSample += ((code & 0x08) ? (code - 0x10) : code) * state.delta;\n\n\tlinearSample = clamp(linearSample, MIN_INT16, MAX_INT16);\n\n\tint delta = (state.delta * adaptationTable[code]) >> 8;\n\tif (delta < 16)\n\t\tdelta = 16;\n\n\tstate.delta = delta;\n\tstate.sample2 = state.sample1;\n\tstate.sample1 = linearSample;\n\n\treturn static_cast<int16_t>(linearSample);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int16_t decodeSample(ms_adpcm_state &state,\n\tuint8_t code, const int16_t *coefficient, bool *ok=NULL)\n{\n\tint linearSample = (state.sample1 * coefficient[0] +\n\t\tstate.sample2 * coefficient[1]) >> 8;\n\tint delta;\n\n\tlinearSample += ((code & 0x08) ? (code - 0x10) : code) * state.delta;\n\n\tlinearSample = clamp(linearSample, MIN_INT16, MAX_INT16);\n\n\tif (multiplyCheckOverflow(state.delta, adaptationTable[code], &delta))\n\t{\n                if (ok) *ok=false;\n\t\t_af_error(AF_BAD_COMPRESSION, \"Error decoding sample\");\n\t\treturn 0;\n\t}\n\tdelta >>= 8;\n\tif (delta < 16)\n\t\tdelta = 16;\n\n\tstate.delta = delta;\n\tstate.sample2 = state.sample1;\n\tstate.sample1 = linearSample;\n\tif (ok) *ok=true;\n\n\treturn static_cast<int16_t>(linearSample);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void hashtable_clear(hashtable_t *hashtable)\n{\n    size_t i;\n\n    hashtable_do_clear(hashtable);\n\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n\n    list_init(&hashtable->list);\n    hashtable->size = 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void hashtable_clear(hashtable_t *hashtable)\n{\n    size_t i;\n\n    hashtable_do_clear(hashtable);\n\n    for(i = 0; i < hashsize(hashtable->order); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n\n    list_init(&hashtable->list);\n    hashtable->size = 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static CACHE_BRUSH_ORDER* update_read_cache_brush_order(rdpUpdate* update, wStream* s, UINT16 flags)\n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\tCACHE_BRUSH_ORDER* cache_brush = calloc(1, sizeof(CACHE_BRUSH_ORDER));\n\n\tif (!cache_brush)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_brush->index); /* cacheEntry (1 byte) */\n\tStream_Read_UINT8(s, iBitmapFormat);      /* iBitmapFormat (1 byte) */\n\n\tif (iBitmapFormat >= ARRAYSIZE(BMF_BPP))\n\t\tgoto fail;\n\n\tcache_brush->bpp = BMF_BPP[iBitmapFormat];\n\tStream_Read_UINT8(s, cache_brush->cx);     /* cx (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->cy);     /* cy (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->style);  /* style (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->length); /* iBytes (1 byte) */\n\n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static CACHE_BRUSH_ORDER* update_read_cache_brush_order(rdpUpdate* update, wStream* s, UINT16 flags)\n{\n\tint i;\n\tBOOL rc;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\tCACHE_BRUSH_ORDER* cache_brush = calloc(1, sizeof(CACHE_BRUSH_ORDER));\n\n\tif (!cache_brush)\n\t\tgoto fail;\n\n\tif (Stream_GetRemainingLength(s) < 6)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_brush->index); /* cacheEntry (1 byte) */\n\tStream_Read_UINT8(s, iBitmapFormat);      /* iBitmapFormat (1 byte) */\n\n\tcache_brush->bpp = get_bmf_bpp(iBitmapFormat, &rc);\n\tif (!rc)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_brush->cx);     /* cx (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->cy);     /* cy (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->style);  /* style (1 byte) */\n\tStream_Read_UINT8(s, cache_brush->length); /* iBytes (1 byte) */\n\n\tif ((cache_brush->cx == 8) && (cache_brush->cy == 8))\n\t{\n\t\tif (cache_brush->bpp == 1)\n\t\t{\n\t\t\tif (cache_brush->length != 8)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)\n\t\treturn 0;\n\t\t\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (!hmhd || (hmhd->type != GF_ISOM_BOX_TYPE_HMHD))\n\t\treturn 0;\n\t\t\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;\n\t\tif (a) hmhd->subType = a->type;\n\t\treturn hmhd->subType;\n\t}\n\treturn hmhd->subType;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "BGD_DECLARE(void *) gdImageJpegPtr(gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageJpegCtx(im, out, quality);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "BGD_DECLARE(void *) gdImageJpegPtr(gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tif (!_gdImageJpegCtx(im, out, quality)) {\n\t\trv = gdDPExtractData(out, size);\n\t} else {\n\t\trv = NULL;\n\t}\n\tout->gd_free(out);\n\treturn rv;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,\n                     const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,\n                     Ssl::HandshakerFactoryCb handshaker_factory_cb)\n    : transport_socket_options_(transport_socket_options),\n      ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)),\n      info_(std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(\n          ctx_->newSsl(transport_socket_options_), ctx_->sslExtendedSocketInfoIndex(), this))) {\n  if (state == InitialState::Client) {\n    SSL_set_connect_state(rawSsl());\n  } else {\n    ASSERT(state == InitialState::Server);\n    SSL_set_accept_state(rawSsl());\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx,\n                     const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options)\n    : transport_socket_options_(transport_socket_options),\n      ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)) {}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tif (should != NULL && should[0] == '@') {\n\t\tat = should + 1;\n\t\tshould = (char*) \"\";\n\t}\n\n\t/* check rm_so and rm_eo for consistency */\n\tif (sub.rm_so > sub.rm_eo || (sub.rm_so == -1 && sub.rm_eo != -1) ||\n\t\t\t\t(sub.rm_so != -1 && sub.rm_eo == -1) ||\n\t\t\t\t(sub.rm_so != -1 && sub.rm_so < 0) ||\n\t\t\t\t(sub.rm_eo != -1 && sub.rm_eo < 0) ) {\n\t\tsprintf(grump, \"start %ld end %ld\", (long)sub.rm_so,\n\t\t\t\t\t\t\t(long)sub.rm_eo);\n\t\treturn(grump);\n\t}\n\n\t/* check for no match */\n\tif (sub.rm_so == -1 && should == NULL)\n\t\treturn(NULL);\n\tif (sub.rm_so == -1)\n\t\treturn((char*) \"did not match\");\n\n\t/* check for in range */\n\tif ((int) sub.rm_eo > (int) strlen(str)) {\n\t\tsprintf(grump, \"start %ld end %ld, past end of string\",\n\t\t\t\t\t(long)sub.rm_so, (long)sub.rm_eo);\n\t\treturn(grump);\n\t}\n\n\tlen = (int)(sub.rm_eo - sub.rm_so);\n\tshlen = (int)strlen(should);\n\tp = str + sub.rm_so;\n\n\t/* check for not supposed to match */\n\tif (should == NULL) {\n\t\tsprintf(grump, \"matched `%.*s'\", len, p);\n\t\treturn(grump);\n\t}\n\n\t/* check for wrong match */\n\tif (len != shlen || strncmp(p, should, (size_t)shlen) != 0) {\n\t\tsprintf(grump, \"matched `%.*s' instead\", len, p);\n\t\treturn(grump);\n\t}\n\tif (shlen > 0)\n\t\treturn(NULL);\n\n\t/* check null match in right place */\n\tif (at == NULL)\n\t\treturn(NULL);\n\tshlen = strlen(at);\n\tif (shlen == 0)\n\t\tshlen = 1;\t/* force check for end-of-string */\n\tif (strncmp(p, at, shlen) != 0) {\n\t\tsprintf(grump, \"matched null at `%.20s'\", p);\n\t\treturn(grump);\n\t}\n\treturn(NULL);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tif (should != NULL && should[0] == '@') {\n\t\tat = should + 1;\n\t\tshould = (char*) \"\";\n\t}\n\n\t/* check rm_so and rm_eo for consistency */\n\tif (sub.rm_so > sub.rm_eo || (sub.rm_so == -1 && sub.rm_eo != -1) ||\n\t\t\t\t(sub.rm_so != -1 && sub.rm_eo == -1) ||\n\t\t\t\t(sub.rm_so != -1 && sub.rm_so < 0) ||\n\t\t\t\t(sub.rm_eo != -1 && sub.rm_eo < 0) ) {\n\t\tsnprintf(grump, sizeof(grump),\n\t\t\t \"start %ld end %ld\", (long)sub.rm_so,\n\t\t\t\t\t\t\t(long)sub.rm_eo);\n\t\treturn(grump);\n\t}\n\n\t/* check for no match */\n\tif (sub.rm_so == -1 && should == NULL)\n\t\treturn(NULL);\n\tif (sub.rm_so == -1)\n\t\treturn((char*) \"did not match\");\n\n\t/* check for in range */\n\tif ((int) sub.rm_eo > (int) strlen(str)) {\n\t\tsnprintf(grump, sizeof(grump),\n\t\t\t \"start %ld end %ld, past end of string\",\n\t\t\t\t\t(long)sub.rm_so, (long)sub.rm_eo);\n\t\treturn(grump);\n\t}\n\n\tlen = (int)(sub.rm_eo - sub.rm_so);\n\tshlen = (int)strlen(should);\n\tp = str + sub.rm_so;\n\n\t/* check for not supposed to match */\n\tif (should == NULL) {\n\t\tsnprintf(grump, sizeof(grump),\n\t\t\t \"matched `%.*s'\", len, p);\n\t\treturn(grump);\n\t}\n\n\t/* check for wrong match */\n\tif (len != shlen || strncmp(p, should, (size_t)shlen) != 0) {\n\t\tsnprintf(grump, sizeof(grump),\n\t\t\t \"matched `%.*s' instead\", len, p);\n\t\treturn(grump);\n\t}\n\tif (shlen > 0)\n\t\treturn(NULL);\n\n\t/* check null match in right place */\n\tif (at == NULL)\n\t\treturn(NULL);\n\tshlen = strlen(at);\n\tif (shlen == 0)\n\t\tshlen = 1;\t/* force check for end-of-string */\n\tif (strncmp(p, at, shlen) != 0) {\n\t\tsnprintf(grump, sizeof(grump),\n\t\t\t \"matched null at `%.20s'\", p);\n\t\treturn(grump);\n\t}\n\treturn(NULL);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  void CalculateOutputIndexValueRowID(\n      const RowPartitionTensor& value_rowids,\n      const vector<INDEX_TYPE>& parent_output_index,\n      INDEX_TYPE output_index_multiplier, INDEX_TYPE output_size,\n      vector<INDEX_TYPE>* result) {\n    const INDEX_TYPE index_size = value_rowids.size();\n    result->reserve(index_size);\n    if (index_size == 0) {\n      return;\n    }\n\n    INDEX_TYPE current_output_column = 0;\n          }\n        }\n      } else {\n        current_output_column = 0;\n        current_value_rowid = next_value_rowid;\n        DCHECK_LT(next_value_rowid, parent_output_index.size());\n        current_output_index = parent_output_index[next_value_rowid];\n      }\n      result->push_back(current_output_index);\n    }\n    DCHECK_EQ(result->size(), value_rowids.size());\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  void CalculateOutputIndexValueRowID(\n      OpKernelContext* context, const RowPartitionTensor& value_rowids,\n      const vector<INDEX_TYPE>& parent_output_index,\n      INDEX_TYPE output_index_multiplier, INDEX_TYPE output_size,\n      vector<INDEX_TYPE>* result) {\n    const INDEX_TYPE index_size = value_rowids.size();\n    result->reserve(index_size);\n    if (index_size == 0) {\n      return;\n    }\n\n    INDEX_TYPE current_output_column = 0;\n          }\n        }\n      } else {\n        current_output_column = 0;\n        current_value_rowid = next_value_rowid;\n        DCHECK_LT(next_value_rowid, parent_output_index.size());\n        current_output_index = parent_output_index[next_value_rowid];\n      }\n      result->push_back(current_output_index);\n    }\n    OP_REQUIRES(context, result->size() == value_rowids.size(),\n                errors::InvalidArgument(\"Invalid row ids.\"));\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "            // Mark outpoint as not spent\n            txindex.vSpent[prevout.n].SetNull();\n\n            // Write back\n            if (!txdb.UpdateTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : UpdateTxIndex failed\");\n        }\n    }\n\n    // Remove transaction from index\n    if (!txdb.EraseTxIndex(*this))\n        return error(\"DisconnectInputs() : EraseTxPos failed\");\n\n    return true;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "            // Mark outpoint as not spent\n            txindex.vSpent[prevout.n].SetNull();\n\n            // Write back\n            if (!txdb.UpdateTxIndex(prevout.hash, txindex))\n                return error(\"DisconnectInputs() : UpdateTxIndex failed\");\n        }\n    }\n\n    // Remove transaction from index\n    // This can fail if a duplicate of this transaction was in a chain that got\n    // reorganized away. This is only possible if this transaction was completely\n    // spent, so erasing it would be a no-op anway.\n    txdb.EraseTxIndex(*this);\n\n    return true;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "            }\n\n            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;\n            config->num_channels = WaveHeader.NumChannels;\n            config->sample_rate = WaveHeader.SampleRate;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n\n            int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;\n            char *buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "            }\n\n            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;\n            config->num_channels = WaveHeader.NumChannels;\n            config->sample_rate = WaveHeader.SampleRate;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n\n            int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;\n            char *buff;\n\n            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tint result;\n\thandle_t *handle = NULL;\n\tstruct super_block *sb = file_inode(vma->vm_file)->i_sb;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\t\t\tEXT4_DATA_TRANS_BLOCKS(sb));\n\t}\n\n\tif (IS_ERR(handle))\n\t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_fault(vma, vmf, ext4_get_block_dax,\n\t\t\t\t\t\text4_end_io_unwritten);\n\n\tif (write) {\n\t\tif (!IS_ERR(handle))\n\t\t\text4_journal_stop(handle);\n\t\tsb_end_pagefault(sb);\n\t}\n\n\treturn result;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tint result;\n\thandle_t *handle = NULL;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct super_block *sb = inode->i_sb;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\t\t\tEXT4_DATA_TRANS_BLOCKS(sb));\n\t} else\n\t\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\n\tif (IS_ERR(handle))\n\t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_fault(vma, vmf, ext4_get_block_dax,\n\t\t\t\t\t\text4_end_io_unwritten);\n\n\tif (write) {\n\t\tif (!IS_ERR(handle))\n\t\t\text4_journal_stop(handle);\n\t\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\t\tsb_end_pagefault(sb);\n\t} else\n\t\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\n\treturn result;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "          }\n        }\n        delete Result;\n      }\n    }\n\n    // recover all the data in the buffer minus one byte\n    ReadIndex = SizeIdx - 1;\n    memmove(&PossibleIdNSize[0], &PossibleIdNSize[1], ReadIndex);\n    UpperLevel = UpperLevel_original;\n  } while ( MaxDataSize > DataStream.getFilePointer() - SizeIdx + PossibleID_Length );\n\n  return NULL;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "          }\n        }\n        delete Result;\n      }\n    }\n\n    // recover all the data in the buffer minus one byte\n    ReadIndex = SizeIdx - 1;\n    memmove(&PossibleIdNSize[0], &PossibleIdNSize[1], ReadIndex);\n    UpperLevel = UpperLevel_original;\n  } while ( MaxDataSize >= ReadSize );\n\n  return NULL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int http1_on_error(http1_parser_s *parser) {\n  FIO_LOG_DEBUG(\"HTTP parser error at HTTP/1.1 buffer position %zu/%zu\",\n                parser->state.next - parser2http(parser)->buf,\n                parser2http(parser)->buf_len);\n  fio_close(parser2http(parser)->p.uuid);\n  return -1;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int http1_on_error(http1_parser_s *parser) {\n  if (parser2http(parser)->close)\n    return -1;\n  FIO_LOG_DEBUG(\"HTTP parser error.\");\n  fio_close(parser2http(parser)->p.uuid);\n  return -1;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode)\n{\n\tint result = parse_rock_ridge_inode_internal(de, inode, 0);\n\n\t/*\n\t * if rockridge flag was reset and we didn't look for attributes\n\t * behind eventual XA attributes, have a look there\n\t */\n\tif ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)\n\t    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {\n\t\tresult = parse_rock_ridge_inode_internal(de, inode, 14);\n\t}\n\treturn result;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode,\n\t\t\t   int relocated)\n{\n\tint flags = relocated ? RR_RELOC_DE : 0;\n\tint result = parse_rock_ridge_inode_internal(de, inode, flags);\n\n\t/*\n\t * if rockridge flag was reset and we didn't look for attributes\n\t * behind eventual XA attributes, have a look there\n\t */\n\tif ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)\n\t    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {\n\t\tresult = parse_rock_ridge_inode_internal(de, inode,\n\t\t\t\t\t\t\t flags | RR_REGARD_XA);\n\t}\n\treturn result;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "         //Check current character\n         if(c == '\\0')\n         {\n            //The list of parameters is empty\n            error = ERROR_NOT_FOUND;\n         }\n         else if(c == ' ' || c == '\\t' || c == ',' || c == ';')\n         {\n            //Discard whitespace and separator characters\n         }\n         else if(isalnum(c) || strchr(\"!#$%&'*+-.^_`|~\", c) || c >= 128)\n         {\n            //Point to the first character of the parameter name\n            param->name = p + i;\n         }\n         else\n         {\n            //Invalid character\n            error = ERROR_INVALID_SYNTAX;\n         }\n      }\n            //Save the length of the parameter name\n            param->nameLen = p + i - param->name;\n         }\n         else if(c == '=')\n         {\n            //The key/value separator has been found\n            separatorFound = TRUE;\n            //Save the length of the parameter name\n            param->nameLen = p + i - param->name;\n         }\n         else if(isalnum(c) || strchr(\"!#$%&'*+-.^_`|~\", c) || c >= 128)\n         {\n            //Advance data pointer\n         }\n         else\n         {\n            //Invalid character\n            error = ERROR_INVALID_SYNTAX;\n         }\n      }\n      else if(!separatorFound)\n            //The key/value separator has been found\n            separatorFound = TRUE;\n         }\n         else if(c == '\\\"')\n         {\n            //Point to the first character that follows the parameter name\n            i = param->name + param->nameLen - p;\n            //Successful processing\n            error = NO_ERROR;\n         }\n         else if(isalnum(c) || strchr(\"!#$%&'*+-.^_`|~\", c) || c >= 128)\n         {\n            //Point to the first character that follows the parameter name\n            i = param->name + param->nameLen - p;\n            //Successful processing\n            error = NO_ERROR;\n         }\n         else\n         {\n            //Invalid character\n            error = ERROR_INVALID_SYNTAX;\n         else if(c == ' ' || c == '\\t')\n         {\n            //Discard whitespace characters\n         }\n         else if(c == '\\\"')\n         {\n            //A string of text is parsed as a single word if it is quoted\n            //using double-quote marks (refer to RFC 7230, section 3.2.6)\n            param->value = p + i;\n         }\n         else if(isalnum(c) || strchr(\"!#$%&'*+-.^_`|~\", c) || c >= 128)\n         {\n            //Point to the first character of the parameter value\n            param->value = p + i;\n         }\n         else\n         {\n            //Invalid character\n            error = ERROR_INVALID_SYNTAX;\n         }\n      }\n         else\n         {\n            //Check current character\n            if(c == '\\0' || c == ' ' || c == '\\t' || c == ',' || c == ';')\n            {\n               //Save the length of the parameter value\n               param->valueLen = p + i - param->value;\n               //Successful processing\n               error = NO_ERROR;\n            }\n            else if(isalnum(c) || strchr(\"!#$%&'*+-.^_`|~\", c) || c >= 128)\n            {\n               //Advance data pointer\n            }\n            else\n            {\n               //Invalid character\n               error = ERROR_INVALID_SYNTAX;\n            }\n         }\n      }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "         //Check current character\n         if(c == '\\0')\n         {\n            //The list of parameters is empty\n            error = ERROR_NOT_FOUND;\n         }\n         else if(c == ' ' || c == '\\t' || c == ',' || c == ';')\n         {\n            //Discard whitespace and separator characters\n         }\n         else if(isalnum(c) || osStrchr(\"!#$%&'*+-.^_`|~\", c) || c >= 128)\n         {\n            //Point to the first character of the parameter name\n            param->name = p + i;\n         }\n         else\n         {\n            //Invalid character\n            error = ERROR_INVALID_SYNTAX;\n         }\n      }\n            //Save the length of the parameter name\n            param->nameLen = p + i - param->name;\n         }\n         else if(c == '=')\n         {\n            //The key/value separator has been found\n            separatorFound = TRUE;\n            //Save the length of the parameter name\n            param->nameLen = p + i - param->name;\n         }\n         else if(isalnum(c) || osStrchr(\"!#$%&'*+-.^_`|~\", c) || c >= 128)\n         {\n            //Advance data pointer\n         }\n         else\n         {\n            //Invalid character\n            error = ERROR_INVALID_SYNTAX;\n         }\n      }\n      else if(!separatorFound)\n            //The key/value separator has been found\n            separatorFound = TRUE;\n         }\n         else if(c == '\\\"')\n         {\n            //Point to the first character that follows the parameter name\n            i = param->name + param->nameLen - p;\n            //Successful processing\n            error = NO_ERROR;\n         }\n         else if(isalnum(c) || osStrchr(\"!#$%&'*+-.^_`|~\", c) || c >= 128)\n         {\n            //Point to the first character that follows the parameter name\n            i = param->name + param->nameLen - p;\n            //Successful processing\n            error = NO_ERROR;\n         }\n         else\n         {\n            //Invalid character\n            error = ERROR_INVALID_SYNTAX;\n         else if(c == ' ' || c == '\\t')\n         {\n            //Discard whitespace characters\n         }\n         else if(c == '\\\"')\n         {\n            //A string of text is parsed as a single word if it is quoted\n            //using double-quote marks (refer to RFC 7230, section 3.2.6)\n            param->value = p + i;\n         }\n         else if(isalnum(c) || osStrchr(\"!#$%&'*+-.^_`|~\", c) || c >= 128)\n         {\n            //Point to the first character of the parameter value\n            param->value = p + i;\n         }\n         else\n         {\n            //Invalid character\n            error = ERROR_INVALID_SYNTAX;\n         }\n      }\n         else\n         {\n            //Check current character\n            if(c == '\\0' || c == ' ' || c == '\\t' || c == ',' || c == ';')\n            {\n               //Save the length of the parameter value\n               param->valueLen = p + i - param->value;\n               //Successful processing\n               error = NO_ERROR;\n            }\n            else if(isalnum(c) || osStrchr(\"!#$%&'*+-.^_`|~\", c) || c >= 128)\n            {\n               //Advance data pointer\n            }\n            else\n            {\n               //Invalid character\n               error = ERROR_INVALID_SYNTAX;\n            }\n         }\n      }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void md_map_sh512(uint8_t *hash, const uint8_t *msg, int len) {\n\tSHA512Context ctx;\n\n\tif (SHA512Reset(&ctx) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\tif (SHA512Input(&ctx, msg, len) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void md_map_sh512(uint8_t *hash, const uint8_t *msg, size_t len) {\n\tSHA512Context ctx;\n\n\tif (SHA512Reset(&ctx) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\tif (SHA512Input(&ctx, msg, len) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val = data;\n\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n\n    stb_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val = data;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return;\n    }\n\n    stb_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);\n    }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "                ||\n                (SDL_memcmp\n                 (src->colors, dst->colors,\n                  src->ncolors * sizeof(SDL_Color)) == 0)) {\n                *identical = 1;\n                return (NULL);\n            }\n        }\n        *identical = 0;\n    }\n    map = (Uint8 *) SDL_malloc(src->ncolors);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < src->ncolors; ++i) {\n        map[i] = SDL_FindColor(dst,\n                               src->colors[i].r, src->colors[i].g,\n                               src->colors[i].b, src->colors[i].a);\n    }\n    return (map);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "                ||\n                (SDL_memcmp\n                 (src->colors, dst->colors,\n                  src->ncolors * sizeof(SDL_Color)) == 0)) {\n                *identical = 1;\n                return (NULL);\n            }\n        }\n        *identical = 0;\n    }\n    map = (Uint8 *) SDL_calloc(256, sizeof(Uint8));\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < src->ncolors; ++i) {\n        map[i] = SDL_FindColor(dst,\n                               src->colors[i].r, src->colors[i].g,\n                               src->colors[i].b, src->colors[i].a);\n    }\n    return (map);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    c = 1;\n\n  for (; c <= TocDocCount; c ++)\n  {\n    if (chapter_starts[c] < 0)\n      continue;\n\n    chapter_outstarts[c] = num_outpages;\n\n    for (i = chapter_starts[c], j = 0, nup = -1, page = pages + i;\n         i <= chapter_ends[c];\n\t i ++, page ++)\n    {\n      if (nup != page->nup)\n      {\n        if (j)\n\t{\n\t  // Break the current output page...\n\t  outpage ++;\n\t  num_outpages ++;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    c = 1;\n\n  for (; c <= TocDocCount; c ++)\n  {\n    if (chapter_starts[c] < 0)\n      continue;\n\n    chapter_outstarts[c] = num_outpages;\n\n    for (i = chapter_starts[c], j = 0, nup = -1, page = pages + i;\n         i <= chapter_ends[c] && num_outpages < num_pages;\n\t i ++, page ++)\n    {\n      if (nup != page->nup)\n      {\n        if (j)\n\t{\n\t  // Break the current output page...\n\t  outpage ++;\n\t  num_outpages ++;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "testHuf (const std::string&)\n{\n    try\n    {\n\tcout << \"Testing Huffman encoder\" << endl;\n\n\tIMATH_NAMESPACE::Rand48 rand48 (0);\n\n\tconst int N = 1000000;\n\tArray <unsigned short> raw (N);\n\n\tfill1 (raw, N, 1, rand48);\t  // test various symbol distributions\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill1 (raw, N, 10, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill1 (raw, N, 100, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill1 (raw, N, 1000, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tfill2 (raw, N, 1, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill2 (raw, N, 10, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill2 (raw, N, 100, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill2 (raw, N, 1000, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tfill3 (raw, N, 0);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill3 (raw, N, 1);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill3 (raw, N, USHRT_MAX - 1);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill3 (raw, N, USHRT_MAX);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tfill4 (raw, USHRT_MAX + 1);\n        compressVerify(raw, USHRT_MAX + 1, HUF_COMPRESS_DEK_HASH_FOR_FILL4_USHRT_MAX_PLUS_ONE);\n\tcompressUncompress (raw, USHRT_MAX + 1);\n\tcompressUncompressSubset (raw, USHRT_MAX + 1);\n\tfill4 (raw, N);\n        compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL4_N);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tfill4 (raw, 0);\n\tcompressUncompress (raw, 0);\t// test small input data sets\n\tfill4 (raw, 1);\n\tcompressUncompress (raw, 1);\n\tfill4 (raw, 2);\n\tcompressUncompress (raw, 2);\n\tfill4 (raw, 3);\n\tcompressUncompress (raw, 3);\n\n\tfill5 (raw, N);\t\t\t// test run-length coding of code table\n        compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL5_N);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tcout << \"ok\\n\" << endl;\n    }\n    catch (const std::exception &e)\n    {\n\tcerr << \"ERROR -- caught exception: \" << e.what() << endl;\n\tassert (false);\n    }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "testHuf (const std::string&)\n{\n    try\n    {\n\tcout << \"Testing Huffman encoder\" << endl;\n\n\tIMATH_NAMESPACE::Rand48 rand48 (0);\n\n        //\n        // FastHufDecoder is used for more than 128 bits, so first test with fewer than 128 bits,\n        // then test FastHufDecoder\n        //\n        for (int pass = 0 ; pass < 2 ; ++pass)\n        {\n\n            int N = pass==0 ? 12 : 1000000;\n            Array <unsigned short> raw (N);\n\n            fill1 (raw, N, 1, rand48);\t  // test various symbol distributions\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill1 (raw, N, 10, rand48);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill1 (raw, N, 100, rand48);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill1 (raw, N, 1000, rand48);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n\n            fill2 (raw, N, 1, rand48);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill2 (raw, N, 10, rand48);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill2 (raw, N, 100, rand48);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill2 (raw, N, 1000, rand48);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n\n            fill3 (raw, N, 0);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill3 (raw, N, 1);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill3 (raw, N, USHRT_MAX - 1);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill3 (raw, N, USHRT_MAX);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n\n            if (pass==1)\n            {\n                fill4 (raw, USHRT_MAX + 1);\n                compressVerify(raw, USHRT_MAX + 1, HUF_COMPRESS_DEK_HASH_FOR_FILL4_USHRT_MAX_PLUS_ONE);\n\n                compressUncompress (raw, USHRT_MAX + 1);\n                compressUncompressSubset (raw, USHRT_MAX + 1);\n                fill4 (raw, N);\n                compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL4_N);\n            }\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n\n            fill4 (raw, 0);\n            compressUncompress (raw, 0);\t// test small input data sets\n            fill4 (raw, 1);\n            compressUncompress (raw, 1);\n            fill4 (raw, 2);\n            compressUncompress (raw, 2);\n            fill4 (raw, 3);\n            compressUncompress (raw, 3);\n\n            fill5 (raw, N);\t\t\t// test run-length coding of code table\n            if (pass==1)\n            {\n                compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL5_N);\n            }\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n\n        }\n\n\tcout << \"ok\\n\" << endl;\n    }\n    catch (const std::exception &e)\n    {\n\tcerr << \"ERROR -- caught exception: \" << e.what() << endl;\n\tassert (false);\n    }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteUnpackParams* data =\n      reinterpret_cast<TfLiteUnpackParams*>(node->builtin_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  switch (input->type) {\n    case kTfLiteFloat32: {\n      UnpackImpl<float>(context, node, input, data->num, data->axis);\n      break;\n    }\n    case kTfLiteInt32: {\n      UnpackImpl<int32_t>(context, node, input, data->num, data->axis);\n      break;\n    }\n    case kTfLiteUInt8: {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteUnpackParams* data =\n      reinterpret_cast<TfLiteUnpackParams*>(node->builtin_data);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  switch (input->type) {\n    case kTfLiteFloat32: {\n      UnpackImpl<float>(context, node, input, data->num, data->axis);\n      break;\n    }\n    case kTfLiteInt32: {\n      UnpackImpl<int32_t>(context, node, input, data->num, data->axis);\n      break;\n    }\n    case kTfLiteUInt8: {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "                    }\n                }\n                break;\n            case DOUBLESTAR:\n                ch = CHILD(n, i+1);  /* tfpdef */\n                assert(TYPE(ch) == tfpdef || TYPE(ch) == vfpdef);\n                kwarg = ast_for_arg(c, ch);\n                if (!kwarg)\n                    return NULL;\n                i += 2; /* the double star and the name */\n                if (TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n                break;\n            case TYPE_COMMENT:\n                assert(i);\n\n                if (kwarg)\n                    arg = kwarg;\n\n                /* arg will be equal to the last argument processed */\n                arg->type_comment = NEW_TYPE_COMMENT(ch);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "                    }\n                }\n                break;\n            case DOUBLESTAR:\n                ch = CHILD(n, i+1);  /* tfpdef */\n                assert(TYPE(ch) == tfpdef || TYPE(ch) == vfpdef);\n                kwarg = ast_for_arg(c, ch);\n                if (!kwarg)\n                    return NULL;\n                i += 2; /* the double star and the name */\n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n                break;\n            case TYPE_COMMENT:\n                assert(i);\n\n                if (kwarg)\n                    arg = kwarg;\n\n                /* arg will be equal to the last argument processed */\n                arg->type_comment = NEW_TYPE_COMMENT(ch);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static enum try_read_result try_read_network(conn *c) {\n    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;\n    int res;\n\n    assert(c != NULL);\n\n    if (c->rcurr != c->rbuf) {\n        if (c->rbytes != 0) /* otherwise there's nothing to copy */\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n        c->rcurr = c->rbuf;\n    }\n\n    while (1) {\n        if (c->rbytes >= c->rsize) {\n            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);\n            if (!new_rbuf) {\n                if (settings.verbose > 0)\n                    fprintf(stderr, \"Couldn't realloc input buffer\\n\");\n                c->rbytes = 0; /* ignore what we read */\n                out_string(c, \"SERVER_ERROR out of memory reading request\");\n                c->write_and_go = conn_closing;\n                return READ_MEMORY_ERROR;\n            }\n            c->rcurr = c->rbuf = new_rbuf;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static enum try_read_result try_read_network(conn *c) {\n    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;\n    int res;\n    int num_allocs = 0;\n    assert(c != NULL);\n\n    if (c->rcurr != c->rbuf) {\n        if (c->rbytes != 0) /* otherwise there's nothing to copy */\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n        c->rcurr = c->rbuf;\n    }\n\n    while (1) {\n        if (c->rbytes >= c->rsize) {\n            if (num_allocs == 4) {\n                return gotdata;\n            }\n            ++num_allocs;\n            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);\n            if (!new_rbuf) {\n                if (settings.verbose > 0)\n                    fprintf(stderr, \"Couldn't realloc input buffer\\n\");\n                c->rbytes = 0; /* ignore what we read */\n                out_string(c, \"SERVER_ERROR out of memory reading request\");\n                c->write_and_go = conn_closing;\n                return READ_MEMORY_ERROR;\n            }\n            c->rcurr = c->rbuf = new_rbuf;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "QPDFObjectHandle::parseInternal(PointerHolder<InputSource> input,\n                                std::string const& object_description,\n                                QPDFTokenizer& tokenizer, bool& empty,\n                                StringDecrypter* decrypter, QPDF* context,\n                                bool in_array, bool in_dictionary,\n                                bool content_stream)\n{\n    // This method must take care not to resolve any objects. Don't\n    // check the type of any object without first ensuring that it is\n    // a direct object. Otherwise, doing so may have the side effect\n    // of reading the object and changing the file pointer.\n\n    empty = false;\n    if (in_dictionary && in_array)\n    {\n\t// Although dictionaries and arrays arbitrarily nest, these\n\t// variables indicate what is at the top of the stack right\n\t// now, so they can, by definition, never both be true.\n\tthrow std::logic_error(\n\t    \"INTERNAL ERROR: parseInternal: in_dict && in_array\");\n    }\n\n    QPDFObjectHandle object;\n\n    qpdf_offset_t offset = input->tell();\n    std::vector<QPDFObjectHandle> olist;\n    bool done = false;\n    while (! done)\n    {\n\tobject = QPDFObjectHandle();\n\n\tQPDFTokenizer::Token token =\n            tokenizer.readToken(input, object_description);\n\n\tswitch (token.getType())\n\t{\n          case QPDFTokenizer::tt_eof:\n            if (content_stream)\n            {\n                // Return uninitialized object to indicate EOF\n                return object;\n            }\n            else\n            {\n                // When not in content stream mode, EOF is tt_bad and\n                // throws an exception before we get here.\n                throw std::logic_error(\n                    \"EOF received while not in content stream mode\");\n            }\n            break;\n\n\t    QTC::TC(\"qpdf\", \"QPDFObjectHandle bad brace\");\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \"treating unexpected brace token as null\"));\n            object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_close:\n\t    if (in_array)\n\t    {\n\t\tdone = true;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad array close\");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"treating unexpected array close token as null\"));\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_dict_close:\n\t    if (in_dictionary)\n\t    {\n\t\tdone = true;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad dictionary close\");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"unexpected dictionary close token\"));\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_open:\n\t    object = parseInternal(\n\t\tinput, object_description, tokenizer, empty,\n                decrypter, context, true, false, content_stream);\n\t    break;\n\n\t  case QPDFTokenizer::tt_dict_open:\n\t    object = parseInternal(\n\t\tinput, object_description, tokenizer, empty,\n                decrypter, context, false, true, content_stream);\n\t    break;\n\n\t  case QPDFTokenizer::tt_bool:\n\t    object = newBool((token.getValue() == \"true\"));\n\t    break;\n\n\t  case QPDFTokenizer::tt_null:\n\t    object = newNull();\n\t    break;\n\n\t    object = newName(token.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_word:\n\t    {\n\t\tstd::string const& value = token.getValue();\n                if (content_stream)\n                {\n                    object = QPDFObjectHandle::newOperator(value);\n                }\n\t\telse if ((value == \"R\") && (in_array || in_dictionary) &&\n\t\t    (olist.size() >= 2) &&\n                    (! olist.at(olist.size() - 1).isIndirect()) &&\n\t\t    (olist.at(olist.size() - 1).isInteger()) &&\n                    (! olist.at(olist.size() - 2).isIndirect()) &&\n\t\t    (olist.at(olist.size() - 2).isInteger()))\n\t\t{\n                    if (context == 0)\n                    {\n                        QTC::TC(\"qpdf\", \"QPDFObjectHandle indirect without context\");\n                        throw std::logic_error(\n                            \"QPDFObjectHandle::parse called without context\"\n                            \" on an object with indirect references\");\n                    }\n\t\t    // Try to resolve indirect objects\n\t\t    object = newIndirect(\n\t\t\tcontext,\n\t\t\tolist.at(olist.size() - 2).getIntValue(),\n\t\t\tolist.at(olist.size() - 1).getIntValue());\n\t\t    olist.pop_back();\n\t\t    olist.pop_back();\n\t\t}\n\t\telse if ((value == \"endobj\") &&\n\t\t\t (! (in_array || in_dictionary)))\n\t\t{\n\t\t    // We just saw endobj without having read\n\t\t    // anything.  Treat this as a null and do not move\n\t\t    // the input source's offset.\n\t\t    object = newNull();\n\t\t    input->seek(input->getLastOffset(), SEEK_SET);\n                    empty = true;\n\t\t}\n\t\telse\n\t\t{\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \"treating unknown token type as null while \"\n                         \"reading object\"));\n            object = newNull();\n\t    break;\n\t}\n\n\tif (in_dictionary || in_array)\n\t{\n\t    if (! done)\n\t    {\n\t\tolist.push_back(object);\n\t    }\n\t}\n\telse if (! object.isInitialized())\n\t{\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \"parse error while reading object\"));\n            object = newNull();\n\t}\n\telse\n\t{\n\t    done = true;\n\t}\n    }\n\n    if (in_array)\n    {\n\tobject = newArray(olist);\n    }\n    else if (in_dictionary)\n    {\n        // Convert list to map. Alternating elements are keys. Attempt\n        // to recover more or less gracefully from invalid\n        // dictionaries.\n        std::set<std::string> names;\n        for (std::vector<QPDFObjectHandle>::iterator iter = olist.begin();\n             iter != olist.end(); ++iter)\n        {\n            if ((! (*iter).isIndirect()) && (*iter).isName())\n            {\n                names.insert((*iter).getName());\n            }\n        }\n\n        std::map<std::string, QPDFObjectHandle> dict;\n        int next_fake_key = 1;\n        for (unsigned int i = 0; i < olist.size(); ++i)\n        {\n            QPDFObjectHandle key_obj = olist.at(i);\n            QPDFObjectHandle val;\n            if (key_obj.isIndirect() || (! key_obj.isName()))\n            {\n                bool found_fake = false;\n                std::string candidate;\n                while (! found_fake)\n                {\n                    candidate =\n                        \"/QPDFFake\" + QUtil::int_to_string(next_fake_key++);\n                    found_fake = (names.count(candidate) == 0);\n                    QTC::TC(\"qpdf\", \"QPDFObjectHandle found fake\",\n                            (found_fake ? 0 : 1));\n                }\n                warn(context,\n                     QPDFExc(\n                         qpdf_e_damaged_pdf,\n                         input->getName(), object_description, offset,\n                         \"expected dictionary key but found\"\n                         \" non-name object; inserting key \" +\n                         candidate));\n                val = key_obj;\n                key_obj = newName(candidate);\n            }\n            else if (i + 1 >= olist.size())\n            {\n                QTC::TC(\"qpdf\", \"QPDFObjectHandle no val for last key\");\n                warn(context,\n                     QPDFExc(\n                         qpdf_e_damaged_pdf,\n                         input->getName(), object_description, offset,\n                         \"dictionary ended prematurely; using null as value\"\n                         \" for last key\"));\n                val = newNull();\n            }\n            else\n            {\n                val = olist.at(++i);\n            }\n            dict[key_obj.getName()] = val;\n        }\n        object = newDictionary(dict);\n    }\n\n    return object;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "QPDFObjectHandle::parseInternal(PointerHolder<InputSource> input,\n                                std::string const& object_description,\n                                QPDFTokenizer& tokenizer, bool& empty,\n                                StringDecrypter* decrypter, QPDF* context,\n                                bool content_stream)\n{\n    // This method must take care not to resolve any objects. Don't\n    // check the type of any object without first ensuring that it is\n    // a direct object. Otherwise, doing so may have the side effect\n    // of reading the object and changing the file pointer.\n\n    empty = false;\n\n    QPDFObjectHandle object;\n\n    std::vector<std::vector<QPDFObjectHandle> > olist_stack;\n    olist_stack.push_back(std::vector<QPDFObjectHandle>());\n    enum state_e { st_top, st_start, st_stop, st_eof, st_dictionary, st_array };\n    std::vector<state_e> state_stack;\n    state_stack.push_back(st_top);\n    std::vector<qpdf_offset_t> offset_stack;\n    offset_stack.push_back(input->tell());\n    bool done = false;\n    while (! done)\n    {\n        std::vector<QPDFObjectHandle>& olist = olist_stack.back();\n        state_e state = state_stack.back();\n        qpdf_offset_t offset = offset_stack.back();\n\n\tobject = QPDFObjectHandle();\n\n\tQPDFTokenizer::Token token =\n            tokenizer.readToken(input, object_description);\n\n\tswitch (token.getType())\n\t{\n          case QPDFTokenizer::tt_eof:\n            if (content_stream)\n            {\n                state = st_eof;\n            }\n            else\n            {\n                // When not in content stream mode, EOF is tt_bad and\n                // throws an exception before we get here.\n                throw std::logic_error(\n                    \"EOF received while not in content stream mode\");\n            }\n            break;\n\n\t    QTC::TC(\"qpdf\", \"QPDFObjectHandle bad brace\");\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \"treating unexpected brace token as null\"));\n            object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_close:\n\t    if (state == st_array)\n\t    {\n                state = st_stop;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad array close\");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"treating unexpected array close token as null\"));\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_dict_close:\n\t    if (state == st_dictionary)\n\t    {\n                state = st_stop;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad dictionary close\");\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"unexpected dictionary close token\"));\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_open:\n\t  case QPDFTokenizer::tt_dict_open:\n            olist_stack.push_back(std::vector<QPDFObjectHandle>());\n            state = st_start;\n            offset_stack.push_back(input->tell());\n            state_stack.push_back(\n                (token.getType() == QPDFTokenizer::tt_array_open) ?\n                st_array : st_dictionary);\n\t    break;\n\n\t  case QPDFTokenizer::tt_bool:\n\t    object = newBool((token.getValue() == \"true\"));\n\t    break;\n\n\t  case QPDFTokenizer::tt_null:\n\t    object = newNull();\n\t    break;\n\n\t    object = newName(token.getValue());\n\t    break;\n\n\t  case QPDFTokenizer::tt_word:\n\t    {\n\t\tstd::string const& value = token.getValue();\n                if (content_stream)\n                {\n                    object = QPDFObjectHandle::newOperator(value);\n                }\n\t\telse if ((value == \"R\") && (state != st_top) &&\n                         (olist.size() >= 2) &&\n                         (! olist.at(olist.size() - 1).isIndirect()) &&\n                         (olist.at(olist.size() - 1).isInteger()) &&\n                         (! olist.at(olist.size() - 2).isIndirect()) &&\n                         (olist.at(olist.size() - 2).isInteger()))\n\t\t{\n                    if (context == 0)\n                    {\n                        QTC::TC(\"qpdf\", \"QPDFObjectHandle indirect without context\");\n                        throw std::logic_error(\n                            \"QPDFObjectHandle::parse called without context\"\n                            \" on an object with indirect references\");\n                    }\n\t\t    // Try to resolve indirect objects\n\t\t    object = newIndirect(\n\t\t\tcontext,\n\t\t\tolist.at(olist.size() - 2).getIntValue(),\n\t\t\tolist.at(olist.size() - 1).getIntValue());\n\t\t    olist.pop_back();\n\t\t    olist.pop_back();\n\t\t}\n\t\telse if ((value == \"endobj\") && (state == st_top))\n\t\t{\n\t\t    // We just saw endobj without having read\n\t\t    // anything.  Treat this as a null and do not move\n\t\t    // the input source's offset.\n\t\t    object = newNull();\n\t\t    input->seek(input->getLastOffset(), SEEK_SET);\n                    empty = true;\n\t\t}\n\t\telse\n\t\t{\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \"treating unknown token type as null while \"\n                         \"reading object\"));\n            object = newNull();\n\t    break;\n\t}\n\n        if ((! object.isInitialized()) &&\n            (! ((state == st_start) ||\n                (state == st_stop) ||\n                (state == st_eof))))\n        {\n            throw std::logic_error(\n                \"QPDFObjectHandle::parseInternal: \"\n                \"unexpected uninitialized object\");\n            object = newNull();\n        }\n\n        switch (state)\n        {\n          case st_eof:\n            if (state_stack.size() > 1)\n            {\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"parse error while reading object\"));\n            }\n            done = true;\n            // Leave object uninitialized to indicate EOF\n            break;\n\n          case st_dictionary:\n          case st_array:\n            olist.push_back(object);\n            break;\n\n          case st_top:\n            done = true;\n            break;\n\n          case st_start:\n            break;\n\n          case st_stop:\n            if ((state_stack.size() < 2) || (olist_stack.size() < 2))\n            {\n                throw std::logic_error(\n                    \"QPDFObjectHandle::parseInternal: st_stop encountered\"\n                    \" with insufficient elements in stack\");\n            }\n            state_e old_state = state_stack.back();\n            state_stack.pop_back();\n            if (old_state == st_array)\n            {\n                object = newArray(olist);\n            }\n            else if (old_state == st_dictionary)\n            {\n                // Convert list to map. Alternating elements are keys.\n                // Attempt to recover more or less gracefully from\n                // invalid dictionaries.\n                std::set<std::string> names;\n                for (std::vector<QPDFObjectHandle>::iterator iter =\n                         olist.begin();\n                     iter != olist.end(); ++iter)\n                {\n                    if ((! (*iter).isIndirect()) && (*iter).isName())\n                    {\n                        names.insert((*iter).getName());\n                    }\n                }\n\n                std::map<std::string, QPDFObjectHandle> dict;\n                int next_fake_key = 1;\n                for (unsigned int i = 0; i < olist.size(); ++i)\n                {\n                    QPDFObjectHandle key_obj = olist.at(i);\n                    QPDFObjectHandle val;\n                    if (key_obj.isIndirect() || (! key_obj.isName()))\n                    {\n                        bool found_fake = false;\n                        std::string candidate;\n                        while (! found_fake)\n                        {\n                            candidate =\n                                \"/QPDFFake\" +\n                                QUtil::int_to_string(next_fake_key++);\n                            found_fake = (names.count(candidate) == 0);\n                            QTC::TC(\"qpdf\", \"QPDFObjectHandle found fake\",\n                                    (found_fake ? 0 : 1));\n                        }\n                        warn(context,\n                             QPDFExc(\n                                 qpdf_e_damaged_pdf,\n                                 input->getName(), object_description, offset,\n                                 \"expected dictionary key but found\"\n                                 \" non-name object; inserting key \" +\n                                 candidate));\n                        val = key_obj;\n                        key_obj = newName(candidate);\n                    }\n                    else if (i + 1 >= olist.size())\n                    {\n                        QTC::TC(\"qpdf\", \"QPDFObjectHandle no val for last key\");\n                        warn(context,\n                             QPDFExc(\n                                 qpdf_e_damaged_pdf,\n                                 input->getName(), object_description, offset,\n                                 \"dictionary ended prematurely; \"\n                                 \"using null as value for last key\"));\n                        val = newNull();\n                    }\n                    else\n                    {\n                        val = olist.at(++i);\n                    }\n                    dict[key_obj.getName()] = val;\n                }\n                object = newDictionary(dict);\n            }\n            olist_stack.pop_back();\n            offset_stack.pop_back();\n            if (state_stack.back() == st_top)\n            {\n                done = true;\n            }\n            else\n            {\n                olist_stack.back().push_back(object);\n            }\n        }\n    }\n\n    return object;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t\treturn -EFAULT;\n\t\t\tbuf += sz;\n\t\t\tp += sz;\n\t\t\tcount -= sz;\n\t\t\tread += sz;\n\t\t}\n\t}\n#endif\n\n\twhile (count > 0) {\n\t\tunsigned long remaining;\n\n\t\tsz = size_inside_page(p, count);\n\n\t\tif (!range_is_allowed(p >> PAGE_SHIFT, count))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * On ia64 if a page has been mapped somewhere as uncached, then\n\t\t * it must also be accessed uncached by the kernel or data\n\t\t * corruption may occur.\n\t\t */\n\t\tptr = xlate_dev_mem_ptr(p);\n\t\tif (!ptr)\n\t\t\treturn -EFAULT;\n\n\t\tremaining = copy_to_user(buf, ptr, sz);\n\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\tif (remaining)\n\t\t\treturn -EFAULT;\n\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\tread += sz;\n\t}\n\n\t*ppos += read;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\tbuf += sz;\n\t\t\tp += sz;\n\t\t\tcount -= sz;\n\t\t\tread += sz;\n\t\t}\n\t}\n#endif\n\n\twhile (count > 0) {\n\t\tunsigned long remaining;\n\t\tint allowed;\n\n\t\tsz = size_inside_page(p, count);\n\n\t\tallowed = page_is_allowed(p >> PAGE_SHIFT);\n\t\tif (!allowed)\n\t\t\treturn -EPERM;\n\t\tif (allowed == 2) {\n\t\t\t/* Show zeros for restricted memory. */\n\t\t\tremaining = clear_user(buf, sz);\n\t\t} else {\n\t\t\t/*\n\t\t\t * On ia64 if a page has been mapped somewhere as\n\t\t\t * uncached, then it must also be accessed uncached\n\t\t\t * by the kernel or data corruption may occur.\n\t\t\t */\n\t\t\tptr = xlate_dev_mem_ptr(p);\n\t\t\tif (!ptr)\n\t\t\t\treturn -EFAULT;\n\n\t\t\tremaining = copy_to_user(buf, ptr, sz);\n\n\t\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\t}\n\n\t\tif (remaining)\n\t\t\treturn -EFAULT;\n\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\tread += sz;\n\t}\n\n\t*ppos += read;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SHORT_SEC_SIZE(h) == len);\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + CDF_SHORT_SEC_POS(h, id), len);\n\treturn len;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h);\n\tsize_t pos = CDF_SHORT_SEC_POS(h, id);\n\tassert(ss == len);\n\tif (sst->sst_len < (size_t)id) {\n\t\tDPRINTF((\"bad sector id %d > %d\\n\", id, sst->sst_len));\n\t\treturn -1;\n\t}\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + pos, len);\n\treturn len;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    if (sig == SIGSEGV || sig == SIGBUS) {\n        serverLog(LL_WARNING,\n        \"Accessing address: %p\", (void*)info->si_addr);\n    }\n    if (info->si_code == SI_USER && info->si_pid != -1) {\n        serverLog(LL_WARNING, \"Killed by PID: %ld, UID: %d\", (long) info->si_pid, info->si_uid);\n    }\n\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n    void *eip = getMcontextEip(uc);\n    if (eip != NULL) {\n        serverLog(LL_WARNING,\n        \"Crashed running the instruction at: %p\", eip);\n    }\n\n    logStackTrace(getMcontextEip(uc), 1);\n\n    logRegisters(uc);\n#endif\n\n    printCrashReport();\n\n#ifdef HAVE_BACKTRACE\n    if (eip != NULL)\n        dumpCodeAroundEIP(eip);\n#endif",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    if (sig == SIGSEGV || sig == SIGBUS) {\n        serverLog(LL_WARNING,\n        \"Accessing address: %p\", (void*)info->si_addr);\n    }\n    if (info->si_code == SI_USER && info->si_pid != -1) {\n        serverLog(LL_WARNING, \"Killed by PID: %ld, UID: %d\", (long) info->si_pid, info->si_uid);\n    }\n\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n    void *eip = getAndSetMcontextEip(uc, NULL);\n    if (eip != NULL) {\n        serverLog(LL_WARNING,\n        \"Crashed running the instruction at: %p\", eip);\n    }\n\n    if (eip == info->si_addr) {\n        /* When eip matches the bad address, it's an indication that we crashed when calling a non-mapped\n         * function pointer. In that case the call to backtrace will crash trying to access that address and we\n         * won't get a crash report logged. Set it to a valid point to avoid that crash. */\n\n        /* This trick allow to avoid compiler warning */\n        void *ptr;\n        invalidFunctionWasCalledType *ptr_ptr = (invalidFunctionWasCalledType*)&ptr;\n        *ptr_ptr = invalidFunctionWasCalled;\n        getAndSetMcontextEip(uc, ptr);\n    }\n\n    logStackTrace(eip, 1);\n\n    if (eip == info->si_addr) {\n        /* Restore old eip */\n        getAndSetMcontextEip(uc, eip);\n    }\n\n    logRegisters(uc);\n#endif\n\n    printCrashReport();\n\n#ifdef HAVE_BACKTRACE\n    if (eip != NULL)\n        dumpCodeAroundEIP(eip);\n#endif",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\treturn -EFAULT;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase IP_OPTIONS:\n\t{\n\t\tunsigned char optbuf[sizeof(struct ip_options)+40];\n\t\tstruct ip_options * opt = (struct ip_options *)optbuf;\n\t\topt->optlen = 0;\n\t\tif (inet->opt)\n\t\t\tmemcpy(optbuf, inet->opt,\n\t\t\t       sizeof(struct ip_options)+\n\t\t\t       inet->opt->optlen);\n\t\trelease_sock(sk);\n\n\t\tif (opt->optlen == 0)\n\t\t\treturn put_user(0, optlen);\n\n\t\tip_options_undo(opt);\n\n\t\tlen = min_t(unsigned int, len, opt->optlen);\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\treturn -EFAULT;\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase IP_OPTIONS:\n\t{\n\t\tunsigned char optbuf[sizeof(struct ip_options)+40];\n\t\tstruct ip_options *opt = (struct ip_options *)optbuf;\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\tinet_opt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t\t     sock_owned_by_user(sk));\n\t\topt->optlen = 0;\n\t\tif (inet_opt)\n\t\t\tmemcpy(optbuf, &inet_opt->opt,\n\t\t\t       sizeof(struct ip_options) +\n\t\t\t       inet_opt->opt.optlen);\n\t\trelease_sock(sk);\n\n\t\tif (opt->optlen == 0)\n\t\t\treturn put_user(0, optlen);\n\n\t\tip_options_undo(opt);\n\n\t\tlen = min_t(unsigned int, len, opt->optlen);\n\t\tif (put_user(len, optlen))\n\t\t\treturn -EFAULT;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void PrivateThreadPoolDatasetOp::MakeDatasetFromOptions(OpKernelContext* ctx,\n                                                        DatasetBase* input,\n                                                        int32_t num_threads,\n                                                        DatasetBase** output) {\n  OP_REQUIRES(ctx, num_threads >= 0,\n              errors::InvalidArgument(\"`num_threads` must be >= 0\"));\n  *output = new Dataset(ctx,\n                        DatasetContext(DatasetContext::Params(\n                            {PrivateThreadPoolDatasetOp::kDatasetType,\n                             PrivateThreadPoolDatasetOp::kDatasetOp})),\n                        input, num_threads);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void PrivateThreadPoolDatasetOp::MakeDatasetFromOptions(OpKernelContext* ctx,\n                                                        DatasetBase* input,\n                                                        int32_t num_threads,\n                                                        DatasetBase** output) {\n  OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads));\n  *output = new Dataset(ctx,\n                        DatasetContext(DatasetContext::Params(\n                            {PrivateThreadPoolDatasetOp::kDatasetType,\n                             PrivateThreadPoolDatasetOp::kDatasetOp})),\n                        input, num_threads);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tRSpace *space = r_spaces_current (&a->meta_spaces);\n\tRIntervalNode *node = find_node_at (a, type, space, from);\n\tRAnalMetaItem *item = node ? node->data : R_NEW0 (RAnalMetaItem);\n\tif (!item) {\n\t\treturn false;\n\t}\n\titem->type = type;\n\titem->subtype = subtype;\n\titem->space = space;\n\tfree (item->str);\n\titem->str = str ? strdup (str) : NULL;\n\tif (str && !item->str) {\n\t\tif (!node) { // If we just created this\n\t\t\tfree (item);\n\t\t}\n\t\treturn false;\n\t}\n\tR_DIRTY (a);\n\tif (!node) {\n\t\tr_interval_tree_insert (&a->meta, from, to, item);\n\t} else if (node->end != to) {\n\t\tr_interval_tree_resize (&a->meta, node, from, to);\n\t}\n\treturn true;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tRSpace *space = r_spaces_current (&a->meta_spaces);\n\tRIntervalNode *node = find_node_at (a, type, space, from);\n\tRAnalMetaItem *item = node ? node->data : R_NEW0 (RAnalMetaItem);\n\tif (!item) {\n\t\treturn false;\n\t}\n\titem->type = type;\n\titem->subtype = subtype;\n\titem->space = space;\n\tfree (item->str);\n\tif (R_STR_ISNOTEMPTY (str)) {\n\t\titem->str = strdup (str);\n\t\t// this breaks the `ecHw` command\n\t\t// (highlights word in current instruction, which uses ansi\n\t\t// r_str_ansi_strip (item->str);\n\t} else {\n\t\titem->str = NULL;\n\t}\n\tR_DIRTY (a);\n\tif (!node) {\n\t\tr_interval_tree_insert (&a->meta, from, to, item);\n\t} else if (node->end != to) {\n\t\tr_interval_tree_resize (&a->meta, node, from, to);\n\t}\n\treturn true;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "sysServices_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "sysServices_handler(snmp_varbind_t *varbind, snmp_oid_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TEST_F(NoAuthTest, calculate_checksum) {\n  auto unk = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::UNKNOWN);\n  EXPECT_TRUE(unk.empty());\n\n  auto md5 = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::MD5);\n  EXPECT_EQ(md5.size(), 32);\n  EXPECT_STRCASEEQ(md5.c_str(), \"A31557B1E39554C88C69AAE1DFAAF314\");\n\n  auto sha1 = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::SHA1);\n  EXPECT_EQ(sha1.size(), 40);\n  EXPECT_STRCASEEQ(sha1.c_str(), \"2B316F0552972605D509321F31F4274533C93161\");\n\n  auto sha256 = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::SHA256);\n  EXPECT_EQ(sha256.size(), 64);\n  EXPECT_STRCASEEQ(sha256.c_str(),\n                   \"6B7FA3E8298F33BC47F4ABB9C845930B1EACC0DAD96503CFA52D4EA18DDC89F0\");\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TEST_F(StuffingTest, verify) {\n  EXPECT_FALSE(uthenticode::verify(pe));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int ndlz4_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                     uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n\n  uint8_t *ip = (uint8_t *) input;\n  uint8_t *ip_limit = ip + input_len;\n  uint8_t *op = (uint8_t *) output;\n  uint8_t ndim;\n  uint32_t blockshape[2];\n  uint32_t eshape[2];\n  uint8_t *buffercpy;\n  uint8_t local_buffer[16];\n  uint8_t token;\n    BLOSC_TRACE_ERROR(\"This codec only works for ndim = 2\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 3) / 4) * 4;\n  eshape[1] = ((blockshape[1] + 3) / 4) * 4;\n\n  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int32_t) (blockshape[0] * blockshape[1]))) {\n    return 0;\n  }\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  uint32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / 4;\n  }\n\n  /* main loop */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int ndlz4_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                     uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n  BLOSC_ERROR_NULL(input, BLOSC2_ERROR_NULL_POINTER);\n  BLOSC_ERROR_NULL(output, BLOSC2_ERROR_NULL_POINTER);\n\n  uint8_t *ip = (uint8_t *) input;\n  uint8_t *ip_limit = ip + input_len;\n  uint8_t *op = (uint8_t *) output;\n  uint8_t ndim;\n  uint32_t blockshape[2];\n  uint32_t eshape[2];\n  uint8_t *buffercpy;\n  uint8_t local_buffer[16];\n  uint8_t token;\n    BLOSC_TRACE_ERROR(\"This codec only works for ndim = 2\");\n    return BLOSC2_ERROR_FAILURE;\n  }\n  memcpy(&blockshape[0], ip, 4);\n  ip += 4;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 3) / 4) * 4;\n  eshape[1] = ((blockshape[1] + 3) / 4) * 4;\n\n  if (NDLZ_UNEXPECT_CONDITIONAL((int64_t)output_len < (int64_t)blockshape[0] * (int64_t)blockshape[1])) {\n    return 0;\n  }\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  uint32_t i_stop[2];\n  for (int i = 0; i < 2; ++i) {\n    i_stop[i] = eshape[i] / 4;\n  }\n\n  /* main loop */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "zephyr_print(netdissect_options *ndo, const u_char *cp, int length)\n{\n    struct z_packet z;\n    const char *parse = (const char *) cp;\n    int parselen = length;\n    const char *s;\n    int lose = 0;\n\n    /* squelch compiler warnings */\n\n    z.kind = 0;\n    z.class = 0;\n    z.inst = 0;\n    z.opcode = 0;\n    z.sender = 0;\n    z.recipient = 0;\n\n#define PARSE_STRING\t\t\t\t\\\n\ts = parse_field(ndo, &parse, &parselen);\t\\\n\tif (!s) lose = 1;\n\n#define PARSE_FIELD_INT(field)\t\t\t\\\n\tPARSE_STRING\t\t\t\t\\\n\tif (!lose) field = strtol(s, 0, 16);\n\n#define PARSE_FIELD_STR(field)\t\t\t\\\n\tPARSE_STRING\t\t\t\t\\\n\tif (!lose) field = s;\n\n    PARSE_FIELD_STR(z.class);\n    PARSE_FIELD_STR(z.inst);\n    PARSE_FIELD_STR(z.opcode);\n    PARSE_FIELD_STR(z.sender);\n    PARSE_FIELD_STR(z.recipient);\n    PARSE_FIELD_STR(z.format);\n    PARSE_FIELD_INT(z.cksum);\n    PARSE_FIELD_INT(z.multi);\n    PARSE_FIELD_STR(z.multi_uid);\n\n    if (lose) {\n\tND_PRINT((ndo, \" [|zephyr] (%d)\", length));\n\treturn;\n    }\n\n    ND_PRINT((ndo, \" zephyr\"));\n    if (strncmp(z.version+4, \"0.2\", 3)) {\n\tND_PRINT((ndo, \" v%s\", z.version+4));\n\treturn;\n    }\n\n    ND_PRINT((ndo, \" %s\", tok2str(z_types, \"type %d\", z.kind)));\n    if (z.kind == Z_PACKET_SERVACK) {\n\t/* Initialization to silence warnings */\n\t    ND_PRINT((ndo, \" set-exposure %s\", str_to_lower(z.opcode)));\n\t    return;\n\t}\n    }\n\n    if (!*z.recipient)\n\tz.recipient = \"*\";\n\n    ND_PRINT((ndo, \" to %s\", z_triple(z.class, z.inst, z.recipient)));\n    if (*z.opcode)\n\tND_PRINT((ndo, \" op %s\", z.opcode));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "zephyr_print(netdissect_options *ndo, const u_char *cp, int length)\n{\n    struct z_packet z;\n    const char *parse = (const char *) cp;\n    int parselen = length;\n    const char *s;\n    int lose = 0;\n    int truncated = 0;\n\n    /* squelch compiler warnings */\n\n    z.kind = 0;\n    z.class = 0;\n    z.inst = 0;\n    z.opcode = 0;\n    z.sender = 0;\n    z.recipient = 0;\n\n#define PARSE_STRING\t\t\t\t\t\t\\\n\ts = parse_field(ndo, &parse, &parselen, &truncated);\t\\\n\tif (truncated) goto trunc;\t\t\t\t\\\n\tif (!s) lose = 1;\n\n#define PARSE_FIELD_INT(field)\t\t\t\\\n\tPARSE_STRING\t\t\t\t\\\n\tif (!lose) field = strtol(s, 0, 16);\n\n#define PARSE_FIELD_STR(field)\t\t\t\\\n\tPARSE_STRING\t\t\t\t\\\n\tif (!lose) field = s;\n\n    PARSE_FIELD_STR(z.class);\n    PARSE_FIELD_STR(z.inst);\n    PARSE_FIELD_STR(z.opcode);\n    PARSE_FIELD_STR(z.sender);\n    PARSE_FIELD_STR(z.recipient);\n    PARSE_FIELD_STR(z.format);\n    PARSE_FIELD_INT(z.cksum);\n    PARSE_FIELD_INT(z.multi);\n    PARSE_FIELD_STR(z.multi_uid);\n\n    if (lose)\n        goto trunc;\n\n    ND_PRINT((ndo, \" zephyr\"));\n    if (strncmp(z.version+4, \"0.2\", 3)) {\n\tND_PRINT((ndo, \" v%s\", z.version+4));\n\treturn;\n    }\n\n    ND_PRINT((ndo, \" %s\", tok2str(z_types, \"type %d\", z.kind)));\n    if (z.kind == Z_PACKET_SERVACK) {\n\t/* Initialization to silence warnings */\n\t    return;\n\t}\n    }\n\n    if (!*z.recipient)\n\tz.recipient = \"*\";\n\n    ND_PRINT((ndo, \" to %s\", z_triple(z.class, z.inst, z.recipient)));\n    if (*z.opcode)\n\tND_PRINT((ndo, \" op %s\", z.opcode));\n    return;\n\ntrunc:\n    ND_PRINT((ndo, \" [|zephyr] (%d)\", length));\n    return;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat)\n{\n\tND_PRINT((ndo, \"%u.%u\", (EXTRACT_16BITS(dat) >> 8),\n\t    (EXTRACT_16BITS(dat) & 0xff)));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat, u_int length)\n{\n\tif (length < 2) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tND_PRINT((ndo, \"%u.%u\", (EXTRACT_16BITS(dat) >> 8),\n\t    (EXTRACT_16BITS(dat) & 0xff)));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  model_dims.input_size = input_desc.data_size();\n  model_dims.cell_size = rnn_desc.cell_size();\n  model_dims.dir_count =\n      (rnn_desc.direction_mode() == CUDNN_BIDIRECTIONAL) ? 2 : 1;\n\n  // check parameters\n  if (!(input_h_desc.num_layers() ==\n            model_dims.num_layers * model_dims.dir_count &&\n        input_h_desc.batch_size() == model_dims.batch_size &&\n        input_h_desc.data_size() == model_dims.hidden_size)) {\n    return tsl::Status(port::error::INVALID_ARGUMENT, \"Invalid input_h shape\");\n  }\n  // The LSTM projection will be used if input_h_desc.data_size() <\n  // input_c_desc.data_size()\n  if (!(input_h_desc.num_layers() == input_c_desc.num_layers() &&\n        input_h_desc.batch_size() == input_c_desc.batch_size() &&\n        input_h_desc.data_size() <= input_c_desc.data_size())) {\n    return tsl::Status(port::error::INVALID_ARGUMENT, \"Invalid input_c shape\");\n  }\n  if (!(output_desc.max_seq_length() == model_dims.max_seq_length &&\n        output_desc.batch_size() == model_dims.batch_size &&\n        output_desc.data_size() ==\n            model_dims.hidden_size * model_dims.dir_count)) {\n    return tsl::Status(port::error::INVALID_ARGUMENT, \"Invalid output shape\");\n  }\n  if (!(input_h_desc.num_layers() == output_h_desc.num_layers() &&\n        input_h_desc.batch_size() == output_h_desc.batch_size() &&\n        input_h_desc.data_size() == output_h_desc.data_size())) {\n    return tsl::Status(port::error::INVALID_ARGUMENT, \"Invalid output_h shape\");\n  }\n  if (!(input_h_desc.num_layers() == output_c_desc.num_layers() &&\n        input_h_desc.batch_size() == output_c_desc.batch_size() &&\n        input_h_desc.data_size() <= output_c_desc.data_size())) {\n    return tsl::Status(port::error::INVALID_ARGUMENT, \"Invalid output_c shape\");\n  }\n\n  return model_dims;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  model_dims.input_size = input_desc.data_size();\n  model_dims.cell_size = rnn_desc.cell_size();\n  model_dims.dir_count =\n      (rnn_desc.direction_mode() == CUDNN_BIDIRECTIONAL) ? 2 : 1;\n\n  // check parameters\n  if (!(input_h_desc.num_layers() ==\n            model_dims.num_layers * model_dims.dir_count &&\n        input_h_desc.batch_size() == model_dims.batch_size &&\n        input_h_desc.data_size() == model_dims.hidden_size)) {\n    return tsl::Status(tsl::error::INVALID_ARGUMENT, \"Invalid input_h shape\");\n  }\n  // The LSTM projection will be used if input_h_desc.data_size() <\n  // input_c_desc.data_size()\n  if (!(input_h_desc.num_layers() == input_c_desc.num_layers() &&\n        input_h_desc.batch_size() == input_c_desc.batch_size() &&\n        input_h_desc.data_size() <= input_c_desc.data_size())) {\n    return tsl::Status(tsl::error::INVALID_ARGUMENT, \"Invalid input_c shape\");\n  }\n  if (!(output_desc.max_seq_length() == model_dims.max_seq_length &&\n        output_desc.batch_size() == model_dims.batch_size &&\n        output_desc.data_size() ==\n            model_dims.hidden_size * model_dims.dir_count)) {\n    return tsl::Status(tsl::error::INVALID_ARGUMENT, \"Invalid output shape\");\n  }\n  if (!(input_h_desc.num_layers() == output_h_desc.num_layers() &&\n        input_h_desc.batch_size() == output_h_desc.batch_size() &&\n        input_h_desc.data_size() == output_h_desc.data_size())) {\n    return tsl::Status(tsl::error::INVALID_ARGUMENT, \"Invalid output_h shape\");\n  }\n  if (!(input_h_desc.num_layers() == output_c_desc.num_layers() &&\n        input_h_desc.batch_size() == output_c_desc.batch_size() &&\n        input_h_desc.data_size() <= output_c_desc.data_size())) {\n    return tsl::Status(tsl::error::INVALID_ARGUMENT, \"Invalid output_c shape\");\n  }\n\n  return model_dims;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tif (trun->nb_samples >= trun->sample_alloc) {\n\t\ttrun->sample_alloc += 50;\n\t\tif (trun->nb_samples >= trun->sample_alloc) trun->sample_alloc = trun->nb_samples+1;\n\t\ttrun->samples = gf_realloc(trun->samples, sizeof(GF_TrunEntry)*trun->sample_alloc);\n\t\tif (!trun->samples) return GF_OUT_OF_MEM;\n\t}\n\n\t//rewrite OD frames\n\tif (traf->trex->track->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\t//this may fail if dependencies are not well done ...\n\t\tMedia_ParseODFrame(traf->trex->track->Media, sample, &od_sample);\n\t\tsample = od_sample;\n\t}\n\n\tent.size = sample->dataLength;\n\ttrun->samples[trun->nb_samples] = ent;\n\ttrun->nb_samples ++;\n\ttrun->run_size += ent.size;\n\n\tif (sample->CTS_Offset<0) {\n\t\ttrun->version = 1;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tif (trun->nb_samples >= trun->sample_alloc) {\n\t\ttrun->sample_alloc += 50;\n\t\tif (trun->nb_samples >= trun->sample_alloc) trun->sample_alloc = trun->nb_samples+1;\n\t\ttrun->samples = gf_realloc(trun->samples, sizeof(GF_TrunEntry)*trun->sample_alloc);\n\t\tif (!trun->samples) return GF_OUT_OF_MEM;\n\t}\n\n\t//rewrite OD frames\n\tif (traf->trex->track->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\t//this may fail if dependencies are not well done ...\n\t\tGF_Err e = Media_ParseODFrame(traf->trex->track->Media, sample, &od_sample);\n\t\tif (!od_sample) return e;\n\t\tsample = od_sample;\n\t}\n\n\tent.size = sample->dataLength;\n\ttrun->samples[trun->nb_samples] = ent;\n\ttrun->nb_samples ++;\n\ttrun->run_size += ent.size;\n\n\tif (sample->CTS_Offset<0) {\n\t\ttrun->version = 1;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void op_attr_bignum_free(void *attr)\n{\n\tstruct bignum **bn = attr;\n\n\tcrypto_bignum_free(*bn);\n\t*bn = NULL;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void op_attr_bignum_free(void *attr)\n{\n\tstruct bignum **bn = attr;\n\n\tcrypto_bignum_free(bn);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\t__be32 spi;\n\n\tspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, spi);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int xfrm6_tunnel_rcv(struct sk_buff *skb)\n{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\t__be32 spi;\n\n\tspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, spi) > 0 ? : 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "StreamExecutor::createRnnSequenceTensorDescriptor(int max_seq_length,\n                                                  int batch_size, int data_size,\n                                                  dnn::DataType data_type) {\n  dnn::DnnSupport* dnn_support = AsDnn();\n  if (!dnn_support) {\n    return tsl::Status(port::error::UNKNOWN,\n                       \"Fail to find the dnn implementation.\");\n  }\n  return dnn_support->createRnnSequenceTensorDescriptor(\n      max_seq_length, batch_size, data_size, data_type);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "StreamExecutor::createRnnSequenceTensorDescriptor(int max_seq_length,\n                                                  int batch_size, int data_size,\n                                                  dnn::DataType data_type) {\n  dnn::DnnSupport* dnn_support = AsDnn();\n  if (!dnn_support) {\n    return tsl::Status(tsl::error::UNKNOWN,\n                       \"Fail to find the dnn implementation.\");\n  }\n  return dnn_support->createRnnSequenceTensorDescriptor(\n      max_seq_length, batch_size, data_size, data_type);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_pli(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length)\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n\n    PJ_ASSERT_RETURN(buf, PJ_EINVAL);\n\n    if (length < 12)\n    \treturn PJ_ETOOSMALL;\n\n    /* PLI uses pt==RTCP_PSFB and FMT==1 */\n    if (hdr->pt != RTCP_PSFB || hdr->count != 1)\n\treturn PJ_ENOTFOUND;\n\n    return PJ_SUCCESS;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_pli(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length)\n{\n    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;\n\n    PJ_ASSERT_RETURN(buf, PJ_EINVAL);\n\n    if (length < 12)\n    \treturn PJ_ETOOSMALL;\n\n    /* PLI uses pt==RTCP_PSFB and FMT==1 */\n    if (hdr->rtcp_common.pt != RTCP_PSFB || hdr->rtcp_common.count != 1)\n\treturn PJ_ENOTFOUND;\n\n    return PJ_SUCCESS;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int64_t HHVM_FUNCTION(bccomp, const String& left, const String& right,\n                             int64_t scale /* = -1 */) {\n  if (scale < 0) scale = BCG(bc_precision);\n  bc_num first, second;\n  bc_init_num(&first);\n  bc_init_num(&second);\n  bc_str2num(&first, (char*)left.data(), scale);\n  bc_str2num(&second, (char*)right.data(), scale);\n  int64_t ret = bc_compare(first, second);\n  bc_free_num(&first);\n  bc_free_num(&second);\n  return ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int64_t HHVM_FUNCTION(bccomp, const String& left, const String& right,\n                             int64_t scale /* = -1 */) {\n  scale = adjust_scale(scale);\n  bc_num first, second;\n  bc_init_num(&first);\n  bc_init_num(&second);\n  bc_str2num(&first, (char*)left.data(), scale);\n  bc_str2num(&second, (char*)right.data(), scale);\n  int64_t ret = bc_compare(first, second);\n  bc_free_num(&first);\n  bc_free_num(&second);\n  return ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "trustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t *enc_len, size_t _t) {\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_dkg_secret);\n\n    SAFE_CHAR_BUF(dkg_secret, DKG_BUFER_LENGTH);\n\n    int status = gen_dkg_poly(dkg_secret, _t);\n\n    CHECK_STATUS(\"gen_dkg_poly failed\")\n\n    status = AES_encrypt(dkg_secret, encrypted_dkg_secret, 3 * BUF_LEN);\n\n    CHECK_STATUS(\"SGX AES encrypt DKG poly failed\");\n\n    *enc_len = strlen(dkg_secret) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n    SAFE_CHAR_BUF(decr_dkg_secret, DKG_BUFER_LENGTH);\n\n    status = AES_decrypt(encrypted_dkg_secret, *enc_len, decr_dkg_secret,\n                         DKG_BUFER_LENGTH);\n\n    CHECK_STATUS(\"aes decrypt dkg poly failed\");\n\n    if (strcmp(dkg_secret, decr_dkg_secret) != 0) {\n        snprintf(errString, BUF_LEN,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "trustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint64_t *enc_len, size_t _t) {\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_dkg_secret);\n\n    SAFE_CHAR_BUF(dkg_secret, DKG_BUFER_LENGTH);\n\n    int status = gen_dkg_poly(dkg_secret, _t);\n\n    CHECK_STATUS(\"gen_dkg_poly failed\")\n\n    status = AES_encrypt(dkg_secret, encrypted_dkg_secret, 3 * BUF_LEN,\n                         DKG, DECRYPTABLE, enc_len);\n\n    CHECK_STATUS(\"SGX AES encrypt DKG poly failed\");\n\n\n\n    SAFE_CHAR_BUF(decr_dkg_secret, DKG_BUFER_LENGTH);\n\n    status = AES_decrypt(encrypted_dkg_secret, *enc_len, decr_dkg_secret,\n                         DKG_BUFER_LENGTH);\n\n    CHECK_STATUS(\"aes decrypt dkg poly failed\");\n\n    if (strcmp(dkg_secret, decr_dkg_secret) != 0) {\n        snprintf(errString, BUF_LEN,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    RETURN_IF_CUDNN_ERROR(cudnnPoolingBackward(\n        cudnn.handle(), pooling_desc.handle(), alpha, dest_desc.handle(),\n        output_ptr, dest_desc.handle(), input_diff_ptr, src_desc.handle(),\n        input_ptr, beta, src_desc.handle(), output_diff_ptr));\n    return ::tsl::OkStatus();\n  };\n\n  auto splits_or =\n      GetTensorSplits(input_dimensions, output_dimensions, element_type);\n  if (!splits_or.ok()) {\n    return tsl::Status(port::error::INTERNAL, \"Cudnn pooling failed to split\");\n  }\n  auto splits = std::move(splits_or.value());\n\n  dnn::BatchDescriptor input_split = input_dimensions;\n  dnn::BatchDescriptor output_split = output_dimensions;\n  for (int i = 0; i < splits.size(); i++) {\n    // It is safe to cap the batch dimension, since it is the leading\n    // dimension and will have no effect on the computation of strides in both\n    // kBatchYXDepth and kBatchDepthYX formats.\n    input_split.set_count(splits[i].num_batches);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    RETURN_IF_CUDNN_ERROR(cudnnPoolingBackward(\n        cudnn.handle(), pooling_desc.handle(), alpha, dest_desc.handle(),\n        output_ptr, dest_desc.handle(), input_diff_ptr, src_desc.handle(),\n        input_ptr, beta, src_desc.handle(), output_diff_ptr));\n    return ::tsl::OkStatus();\n  };\n\n  auto splits_or =\n      GetTensorSplits(input_dimensions, output_dimensions, element_type);\n  if (!splits_or.ok()) {\n    return tsl::Status(tsl::error::INTERNAL, \"Cudnn pooling failed to split\");\n  }\n  auto splits = std::move(splits_or.value());\n\n  dnn::BatchDescriptor input_split = input_dimensions;\n  dnn::BatchDescriptor output_split = output_dimensions;\n  for (int i = 0; i < splits.size(); i++) {\n    // It is safe to cap the batch dimension, since it is the leading\n    // dimension and will have no effect on the computation of strides in both\n    // kBatchYXDepth and kBatchDepthYX formats.\n    input_split.set_count(splits[i].num_batches);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int hns_xgmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int hns_xgmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n\t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void sycc420_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;\n\tconst int *y, *cb, *cr, *ny;\n\tunsigned int maxw, maxh, max;\n\tint offset, upb;\n\tunsigned int i, j;\n\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\n\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n\tmax = maxw * maxh;\n\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n\n\tif(r == NULL || g == NULL || b == NULL) goto fails;\n\n\tfor(i=0U; i < (maxh & ~(unsigned int)1U); i += 2U)\n\t{\n\t\tny = y + maxw;\n\t\tnr = r + maxw; ng = g + maxw; nb = b + maxw;\n\n\t\tfor(j=0; j < (maxw & ~(unsigned int)1U); j += 2U)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb;\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n\t\t}\n\t\tif(j < maxw)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n\t\t}\n\t\ty += maxw; r += maxw; g += maxw; b += maxw;\n\t}\n\tif(i < maxh)\n\t{\n\t\tfor(j=0U; j < (maxw & ~(unsigned int)1U); j += 2U)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n\t\t\t++y; ++r; ++g; ++b; ++cb; ++cr;\n\t\t}\n\t\tif(j < maxw)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t}\n\t}\n\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\n#if defined(USE_JPWL) || defined(USE_MJ2)\n\timg->comps[1].w = maxw; img->comps[1].h = maxh;\n\timg->comps[2].w = maxw; img->comps[2].h = maxh;\n#else\n\timg->comps[1].w = (OPJ_UINT32)maxw; img->comps[1].h = (OPJ_UINT32)maxh;\n\timg->comps[2].w = (OPJ_UINT32)maxw; img->comps[2].h = (OPJ_UINT32)maxh;\n#endif\n\timg->comps[1].dx = img->comps[0].dx;\n\timg->comps[2].dx = img->comps[0].dx;\n\timg->comps[1].dy = img->comps[0].dy;\n\timg->comps[2].dy = img->comps[0].dy;\n\treturn;\n\nfails:\n\tif(r) free(r);\n\tif(g) free(g);\n\tif(b) free(b);\n\n}/* sycc420_to_rgb() */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void sycc420_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;\n\tconst int *y, *cb, *cr, *ny;\n\tsize_t maxw, maxh, max, offx, loopmaxw, offy, loopmaxh;\n\tint offset, upb;\n\tsize_t i;\n\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\n\tmaxw = (size_t)img->comps[0].w; maxh = (size_t)img->comps[0].h;\n\tmax = maxw * maxh;\n\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\n\td0 = r = (int*)malloc(sizeof(int) * max);\n\td1 = g = (int*)malloc(sizeof(int) * max);\n\td2 = b = (int*)malloc(sizeof(int) * max);\n\t\n\tif (r == NULL || g == NULL || b == NULL) goto fails;\n\t\n\t/* if img->x0 is odd, then first column shall use Cb/Cr = 0 */\n\toffx = img->x0 & 1U;\n\tloopmaxw = maxw - offx;\n\t/* if img->y0 is odd, then first line shall use Cb/Cr = 0 */\n\toffy = img->y0 & 1U;\n\tloopmaxh = maxh - offy;\n\t\n\tif (offy > 0U) {\n\t\tsize_t j;\n\t\t\n\t\tfor(j=0; j < maxw; ++j)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t}\n\t}\n\n\tfor(i=0U; i < (loopmaxh & ~(size_t)1U); i += 2U)\n\t{\n\t\tsize_t j;\n\t\t\n\t\tny = y + maxw;\n\t\tnr = r + maxw; ng = g + maxw; nb = b + maxw;\n\t\t\n\t\tif (offx > 0U) {\n\t\t\tsycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb;\n\t\t}\n\n\t\tfor(j=0; j < (loopmaxw & ~(size_t)1U); j += 2U)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb;\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n\t\t}\n\t\tif(j < loopmaxw)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n\t\t}\n\t\ty += maxw; r += maxw; g += maxw; b += maxw;\n\t}\n\tif(i < loopmaxh)\n\t{\n\t\tsize_t j;\n\t\t\n\t\tfor(j=0U; j < (maxw & ~(size_t)1U); j += 2U)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n\t\t\t++y; ++r; ++g; ++b; ++cb; ++cr;\n\t\t}\n\t\tif(j < maxw)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t}\n\t}\n\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\n\timg->comps[1].w = img->comps[2].w = img->comps[0].w;\n\timg->comps[1].h = img->comps[2].h = img->comps[0].h;\n\timg->comps[1].dx = img->comps[2].dx = img->comps[0].dx;\n\timg->comps[1].dy = img->comps[2].dy = img->comps[0].dy;\n\timg->color_space = OPJ_CLRSPC_SRGB;\n\treturn;\n\nfails:\n\tfree(r);\n\tfree(g);\n\tfree(b);\n}/* sycc420_to_rgb() */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    ret = krb5_domain_x500_decode(context,\n\t\t\t\t  tr->contents,\n\t\t\t\t  &realms,\n\t\t\t\t  &num_realms,\n\t\t\t\t  client_realm,\n\t\t\t\t  server_realm);\n    if(ret){\n\tkrb5_warn(context, ret,\n\t\t  \"Decoding transited encoding\");\n\treturn ret;\n    }\n    if(strcmp(client_realm, tgt_realm) && strcmp(server_realm, tgt_realm)) {\n\t/* not us, so add the previous realm to transited set */\n\tif (num_realms + 1 > UINT_MAX/sizeof(*realms)) {\n\t    ret = ERANGE;\n\t    goto free_realms;\n\t}\n\ttmp = realloc(realms, (num_realms + 1) * sizeof(*realms));\n\tif(tmp == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\trealms = tmp;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\t\t  tr->contents,\n\t\t\t\t  &realms,\n\t\t\t\t  &num_realms,\n\t\t\t\t  client_realm,\n\t\t\t\t  server_realm);\n    if(ret){\n\tkrb5_warn(context, ret,\n\t\t  \"Decoding transited encoding\");\n\treturn ret;\n    }\n\n    /*\n     * If the realm of the presented tgt is neither the client nor the server\n     * realm, it is a transit realm and must be added to transited set.\n     */\n    if(strcmp(client_realm, tgt_realm) && strcmp(server_realm, tgt_realm)) {\n\tif (num_realms + 1 > UINT_MAX/sizeof(*realms)) {\n\t    ret = ERANGE;\n\t    goto free_realms;\n\t}\n\ttmp = realloc(realms, (num_realms + 1) * sizeof(*realms));\n\tif(tmp == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\trealms = tmp;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int bn_gen_prime_factor(bn_t a, bn_t b, int abits, int bbits) {\n\tbn_t t;\n\tint result = RLC_OK;\n\n    if (! (bbits>abits) ) {\n\t\treturn RLC_ERR;\n    }\n\n    bn_null(t);\n\n    RLC_TRY {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int bn_gen_prime_factor(bn_t a, bn_t b, size_t abits, size_t bbits) {\n\tbn_t t;\n\tint result = RLC_OK;\n\n    if (! (bbits>abits) ) {\n\t\treturn RLC_ERR;\n    }\n\n    bn_null(t);\n\n    RLC_TRY {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\n\tif (msg->msg_namelen != 0) {\n\t\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\t\tax25_digi digi;\n\t\tax25_address src;\n\t\tconst unsigned char *mac = skb_mac_header(skb);\n\n\t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n\t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\n\t\t\t\t&digi, NULL, NULL);\n\t\tsax->sax25_family = AF_AX25;\n\t\t/* We set this correctly, even though we may not let the\n\t\t   application know the digi calls further down (because it\n\t\t   did NOT ask to know them).  This could get political... **/\n\t\tsax->sax25_ndigis = digi.ndigi;\n\t\tsax->sax25_call   = src;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\n\tif (msg->msg_name) {\n\t\tax25_digi digi;\n\t\tax25_address src;\n\t\tconst unsigned char *mac = skb_mac_header(skb);\n\t\tstruct sockaddr_ax25 *sax = msg->msg_name;\n\n\t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n\t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\n\t\t\t\t&digi, NULL, NULL);\n\t\tsax->sax25_family = AF_AX25;\n\t\t/* We set this correctly, even though we may not let the\n\t\t   application know the digi calls further down (because it\n\t\t   did NOT ask to know them).  This could get political... **/\n\t\tsax->sax25_ndigis = digi.ndigi;\n\t\tsax->sax25_call   = src;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tint ret;\n\n\tfit = map_sysmem(addr, 0);\n\tfit_uname = fit_unamep ? *fit_unamep : NULL;\n\tfit_uname_config = fit_uname_configp ? *fit_uname_configp : NULL;\n\tfit_base_uname_config = NULL;\n\tprop_name = fit_get_image_type_property(image_type);\n\tprintf(\"## Loading %s from FIT Image at %08lx ...\\n\", prop_name, addr);\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT);\n\tif (fit_check_format(fit, IMAGE_SIZE_INVAL)) {\n\t\tprintf(\"Bad FIT %s image format!\\n\", prop_name);\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_FORMAT);\n\t\treturn -ENOEXEC;\n\t}\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT_OK);\n\tif (fit_uname) {\n\t\t/* get FIT component image node offset */\n\t\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_UNIT_NAME);\n\t\tnoffset = fit_image_get_node(fit, fit_uname);\n\t} else {\n\t\t/*\n\t\t * no image node unit name, try to get config\n\t\t * node first. If config unit node name is NULL",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tint ret;\n\n\tfit = map_sysmem(addr, 0);\n\tfit_uname = fit_unamep ? *fit_unamep : NULL;\n\tfit_uname_config = fit_uname_configp ? *fit_uname_configp : NULL;\n\tfit_base_uname_config = NULL;\n\tprop_name = fit_get_image_type_property(image_type);\n\tprintf(\"## Loading %s from FIT Image at %08lx ...\\n\", prop_name, addr);\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT);\n\tret = fit_check_format(fit, IMAGE_SIZE_INVAL);\n\tif (ret) {\n\t\tprintf(\"Bad FIT %s image format! (err=%d)\\n\", prop_name, ret);\n\t\tif (CONFIG_IS_ENABLED(FIT_SIGNATURE) && ret == -EADDRNOTAVAIL)\n\t\t\tprintf(\"Signature checking prevents use of unit addresses (@) in nodes\\n\");\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_FORMAT);\n\t\treturn ret;\n\t}\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT_OK);\n\tif (fit_uname) {\n\t\t/* get FIT component image node offset */\n\t\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_UNIT_NAME);\n\t\tnoffset = fit_image_get_node(fit, fit_uname);\n\t} else {\n\t\t/*\n\t\t * no image node unit name, try to get config\n\t\t * node first. If config unit node name is NULL",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n\t//do not override PID ID if itt is set\n\tif (!ch) {\n\t\tif (read->pid)\n\t\t\tgf_filter_pid_copy_properties(pid, read->pid);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ID, &PROP_UINT(esd ? esd->ESID : item_id));\n\t}\n\n\tif (read->itemid)\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ITEM_ID, &PROP_UINT(item_id));\n\t\t\n\tif ((item_codecid==GF_CODECID_HEVC) && gf_isom_meta_item_has_ref(read->mov, GF_TRUE, 0, item_id, GF_ISOM_REF_TBAS)) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TILE_BASE, &PROP_BOOL(GF_TRUE));\n\t}\n\n\n\t//TODO: no support for LHEVC images\n\t//gf_filter_pid_set_property(pid, GF_PROP_PID_DEPENDENCY_ID, &PROP_UINT(esd->dependsOnESID));\n\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_VISUAL));\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_CODECID, &PROP_UINT(item_codecid));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n\t//do not override PID ID if itt is set\n\tif (!ch) {\n\t\tif (read->pid)\n\t\t\tgf_filter_pid_copy_properties(pid, read->pid);\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ID, &PROP_UINT(esd ? esd->ESID : item_id));\n\t}\n\n\tif (read->itemid)\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ITEM_ID, &PROP_UINT(item_id));\n\n\tif ((item_codecid==GF_CODECID_HEVC) && gf_isom_meta_item_has_ref(read->mov, GF_TRUE, 0, item_id, GF_ISOM_REF_TBAS)) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TILE_BASE, &PROP_BOOL(GF_TRUE));\n\t}\n\n\n\t//TODO: no support for LHEVC images\n\t//gf_filter_pid_set_property(pid, GF_PROP_PID_DEPENDENCY_ID, &PROP_UINT(esd->dependsOnESID));\n\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_VISUAL));\n\tgf_filter_pid_set_property(pid, GF_PROP_PID_CODECID, &PROP_UINT(item_codecid));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": " */\nint re_yyget_lineno  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    \n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    \n    return yylineno;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": " */\nint re_yyget_lineno  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    \n    return yylineno;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "iakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t output_token)\n{\n    OM_uint32 major_status = GSS_S_COMPLETE;\n\n    if (output_token != GSS_C_NO_BUFFER) {\n        output_token->length = 0;\n        output_token->value = NULL;\n    }\n\n    *minor_status = 0;\n\n    if (*context_handle != GSS_C_NO_CONTEXT) {\n        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n\n        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {\n            iakerb_release_context(iakerb_ctx);\n            *context_handle = GSS_C_NO_CONTEXT;\n        } else {\n            assert(iakerb_ctx->magic == KG_CONTEXT);\n\n            major_status = krb5_gss_delete_sec_context(minor_status,\n                                                       context_handle,\n                                                       output_token);\n        }\n    }\n\n    return major_status;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "iakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t output_token)\n{\n    iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n\n    if (output_token != GSS_C_NO_BUFFER) {\n        output_token->length = 0;\n        output_token->value = NULL;\n    }\n\n    *minor_status = 0;\n    *context_handle = GSS_C_NO_CONTEXT;\n    iakerb_release_context(iakerb_ctx);\n\n    return GSS_S_COMPLETE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t(*sample)->IsRAP = RAP;\n\t\tgf_free((*sample)->data);\n\t\t(*sample)->dataLength = shadow->dataLength;\n\t\t(*sample)->data = shadow->data;\n\t\t//set data length to 0 to keep the buffer alive...\n\t\tshadow->dataLength = 0;\n\t\tgf_isom_sample_del(&shadow);\n\t}\n\tif (static_sample && ! (*sample)->alloc_size )\n\t\t (*sample)->alloc_size =  (*sample)->dataLength;\n\t\t \n\treturn GF_OK;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t(*sample)->IsRAP = RAP;\n\t\tgf_free((*sample)->data);\n\t\t(*sample)->dataLength = shadow->dataLength;\n\t\t(*sample)->data = shadow->data;\n\t\t//set data length to 0 to keep the buffer alive...\n\t\tshadow->dataLength = 0;\n\t\tgf_isom_sample_del(&shadow);\n\t}\n\tif (static_sample && ! (*sample)->alloc_size )\n\t\t (*sample)->alloc_size =  (*sample)->dataLength;\n\n\treturn GF_OK;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "#ifdef ENABLE_DP_SERVICE\n\tcase EDP:\n\t\txml = getVarsDP(&l);\n\t\tbreak;\n#endif\n\tdefault:\n\t\txml = NULL;\n\t\tl = 0;\n\t}\n\tobj->buffersize = 1024;\n\tobj->buffer = malloc(obj->buffersize);\n\tif(!obj->buffer) {\n\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\n\t\tif(xml) {\n\t\t\tfree(xml);\n\t\t}\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n\t                       obj->sub->uuid, obj->sub->seq,\n\t                       l, xml);\n\tif(xml) {\n\t\tfree(xml);\n\t\txml = NULL;\n\t}\n\tobj->state = ESending;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "#ifdef ENABLE_DP_SERVICE\n\tcase EDP:\n\t\txml = getVarsDP(&l);\n\t\tbreak;\n#endif\n\tdefault:\n\t\txml = NULL;\n\t\tl = 0;\n\t}\n\tobj->buffersize = 1024;\n\tfor (;;) {\n\t\tobj->buffer = malloc(obj->buffersize);\n\t\tif(!obj->buffer) {\n\t\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\n\t\t\tif(xml) {\n\t\t\t\tfree(xml);\n\t\t\t}\n\t\t\tobj->state = EError;\n\t\t\treturn;\n\t\t}\n\t\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n\t\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n\t\t                       obj->sub->uuid, obj->sub->seq,\n\t\t                       l, xml);\n\t\tif (obj->tosend < 0) {\n\t\t\tsyslog(LOG_ERR, \"%s: snprintf() failed\", \"upnp_event_prepare\");\n\t\t\tif(xml) {\n\t\t\t\tfree(xml);\n\t\t\t}\n\t\t\tobj->state = EError;\n\t\t\treturn;\n\t\t} else if (obj->tosend < obj->buffersize) {\n\t\t\tbreak; /* the buffer was large enough */\n\t\t}\n\t\t/* Try again with a buffer big enough */\n\t\tfree(obj->buffer);\n\t\tobj->buffersize = obj->tosend + 1;\t/* reserve space for the final 0 */\n\t}\n\tif(xml) {\n\t\tfree(xml);\n\t\txml = NULL;\n\t}\n\tobj->state = ESending;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    int\t\tidx;\n    int\t\tskip;\n    int\t\trethrow = FALSE;\n    int\t\tpending = CSTP_NONE;\n    void\t*rettv = NULL;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (cmdmod_error(FALSE))\n\treturn;\n\n    if (cstack->cs_trylevel <= 0 || cstack->cs_idx < 0)\n\teap->errmsg = _(e_endtry_without_try);\n    else\n    {\n\t/*\n\t * Don't do something after an error, interrupt or throw in the try\n\t * block, catch clause, or finally clause preceding this \":endtry\" or\n\t * when an error or interrupt occurred after a \":continue\", \":break\",\n\t * \":return\", or \":finish\" in a try block or catch clause preceding this\n\t * \":endtry\" or when the try block never got active (because of an\n\t * inactive surrounding conditional or after an error or interrupt or\n\t * throw) or when there is a surrounding conditional and it has been\n\t * made inactive by a \":continue\", \":break\", \":return\", or \":finish\" in\n\t * the finally clause.  The latter case need not be tested since then\n\t * anything pending has already been discarded. */\n\tskip = did_emsg || got_int || did_throw\n\t\t\t     || !(cstack->cs_flags[cstack->cs_idx] & CSF_TRUE);\n\n\tif (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n\t{\n\t    eap->errmsg = get_end_emsg(cstack);\n\n\t    // Find the matching \":try\" and report what's missing.\n\t    idx = cstack->cs_idx;\n\t    do\n\t\t--idx;\n\t    while (idx > 0 && !(cstack->cs_flags[idx] & CSF_TRY));\n\t    rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,\n\t\t\t\t\t\t       &cstack->cs_looplevel);\n\t    skip = TRUE;\n\n\t    /*\n\t     * If an exception is being thrown, discard it to prevent it from\n\t     * being rethrown at the end of this function.  It would be\n\t     * discarded by the error message, anyway.  Resets did_throw.\n\t     * This does not affect the script termination due to the error\n\t     * since \"trylevel\" is decremented after emsg() has been called.\n\t     */\n\t    if (did_throw)\n\t\tdiscard_current_exception();\n\n\t    // report eap->errmsg, also when there already was an error\n\t    did_emsg = FALSE;\n\t}\n\telse\n\t{\n\t    idx = cstack->cs_idx;\n\n\t    // Check the flags only when not in a skipped block.\n\t    if (!skip && in_vim9script()\n\t\t     && (cstack->cs_flags[idx] & (CSF_CATCH|CSF_FINALLY)) == 0)\n\t    {\n\t\t// try/endtry without any catch or finally: give an error and\n\t\t// continue.\n\t\teap->errmsg = _(e_missing_catch_or_finally);\n\t    }\n\n\t    /*\n\t     * If we stopped with the exception currently being thrown at this\n\t     * try conditional since we didn't know that it doesn't have\n\t     * a finally clause, we need to rethrow it after closing the try\n\t     * conditional.\n\t     */\n\t    if (did_throw && (cstack->cs_flags[idx] & CSF_TRUE)\n\t\t    && !(cstack->cs_flags[idx] & CSF_FINALLY))\n\t\trethrow = TRUE;\n\t}\n\n\t// If there was no finally clause, show the user when debugging or\n\t// a breakpoint was encountered that the end of the try conditional has\n\t// been reached: display the debug prompt (if not already done).  Do\n\t// this on normal control flow or when an exception was thrown, but not\n\t// on an interrupt or error not converted to an exception or when\n\t// a \":break\", \":continue\", \":return\", or \":finish\" is pending.  These\n\t// actions are carried out immediately.\n\tif ((rethrow || (!skip\n\t\t\t&& !(cstack->cs_flags[idx] & CSF_FINALLY)\n\t\t\t&& !cstack->cs_pending[idx]))\n\t\t&& dbg_check_skipped(eap))\n\t{\n\t    // Handle a \">quit\" debug command as if an interrupt had occurred\n\t    // before the \":endtry\".  That is, throw an interrupt exception and\n\t    // set \"skip\" and \"rethrow\".\n\t    if (got_int)\n\t    {\n\t\tskip = TRUE;\n\t\t(void)do_intthrow(cstack);\n\t\t// The do_intthrow() call may have reset did_throw or\n\t\t// cstack->cs_pending[idx].\n\t\trethrow = FALSE;\n\t\tif (did_throw && !(cstack->cs_flags[idx] & CSF_FINALLY))\n\t\t    rethrow = TRUE;\n\t    }\n\t}\n\n\t/*\n\t * If a \":return\" is pending, we need to resume it after closing the\n\t * try conditional; remember the return value.  If there was a finally\n\t * clause making an exception pending, we need to rethrow it.  Make it\n\t * the exception currently being thrown.\n\t */\n\tif (!skip)\n\t{\n\t    pending = cstack->cs_pending[idx];\n\t    cstack->cs_pending[idx] = CSTP_NONE;\n\t    if (pending == CSTP_RETURN)\n\t\trettv = cstack->cs_rettv[idx];\n\t    else if (pending & CSTP_THROW)\n\t\tcurrent_exception = cstack->cs_exception[idx];\n\t}\n\n\t/*\n\t * Discard anything pending on an error, interrupt, or throw in the\n\t * finally clause.  If there was no \":finally\", discard a pending\n\t * \":continue\", \":break\", \":return\", or \":finish\" if an error or\n\t * interrupt occurred afterwards, but before the \":endtry\" was reached.\n\t * If an exception was caught by the last of the catch clauses and there\n\t * was no finally clause, finish the exception now.  This happens also\n\t * after errors except when this \":endtry\" is not within a \":try\".\n\t * Restore \"emsg_silent\" if it has been reset by this try conditional.\n\t */\n\t(void)cleanup_conditionals(cstack, CSF_TRY | CSF_SILENT, TRUE);\n\n\tif (cstack->cs_idx >= 0\n\t\t\t       && (cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n\t    leave_block(cstack);\n\t--cstack->cs_trylevel;\n\n\tif (!skip)\n\t{\n\t    report_resume_pending(pending,\n\t\t    (pending == CSTP_RETURN) ? rettv :\n\t\t    (pending & CSTP_THROW) ? (void *)current_exception : NULL);\n\t    switch (pending)\n\t    {\n\t\tcase CSTP_NONE:\n\t\t    break;\n\n\t\t// Reactivate a pending \":continue\", \":break\", \":return\",\n\t\t// \":finish\" from the try block or a catch clause of this try\n\t\t// conditional.  This is skipped, if there was an error in an\n\t\t// (unskipped) conditional command or an interrupt afterwards\n\t\t// or if the finally clause is present and executed a new error,\n\t\t// interrupt, throw, \":continue\", \":break\", \":return\", or\n\t\t// \":finish\".\n\t\tcase CSTP_CONTINUE:\n\t\t    ex_continue(eap);\n\t\t    break;\n\t\tcase CSTP_BREAK:\n\t\t    ex_break(eap);\n\t\t    break;\n\t\tcase CSTP_RETURN:\n\t\t    do_return(eap, FALSE, FALSE, rettv);\n\t\t    break;\n\t\tcase CSTP_FINISH:\n\t\t    do_finish(eap, FALSE);\n\t\t    break;\n\n\t\t// When the finally clause was entered due to an error,\n\t\t// interrupt or throw (as opposed to a \":continue\", \":break\",\n\t\t// \":return\", or \":finish\"), restore the pending values of\n\t\t// did_emsg, got_int, and did_throw.  This is skipped, if there\n\t\t// was a new error, interrupt, throw, \":continue\", \":break\",\n\t\t// \":return\", or \":finish\".  in the finally clause.\n\t\tdefault:\n\t\t    if (pending & CSTP_ERROR)\n\t\t\tdid_emsg = TRUE;\n\t\t    if (pending & CSTP_INTERRUPT)\n\t\t\tgot_int = TRUE;\n\t\t    if (pending & CSTP_THROW)\n\t\t\trethrow = TRUE;\n\t\t    break;\n\t    }\n\t}\n\n\tif (rethrow)\n\t    // Rethrow the current exception (within this cstack).\n\t    do_throw(cstack);\n    }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    int\t\tidx;\n    int\t\tskip;\n    int\t\trethrow = FALSE;\n    int\t\tpending = CSTP_NONE;\n    void\t*rettv = NULL;\n    cstack_T\t*cstack = eap->cstack;\n\n    if (cmdmod_error(FALSE))\n\treturn;\n\n    for (idx = cstack->cs_idx; idx >= 0; --idx)\n\tif (cstack->cs_flags[idx] & CSF_TRY)\n\t    break;\n    if (cstack->cs_trylevel <= 0 || idx < 0)\n    {\n\teap->errmsg = _(e_endtry_without_try);\n\treturn;\n    }\n\n    /*\n     * Don't do something after an error, interrupt or throw in the try\n     * block, catch clause, or finally clause preceding this \":endtry\" or\n     * when an error or interrupt occurred after a \":continue\", \":break\",\n     * \":return\", or \":finish\" in a try block or catch clause preceding this\n     * \":endtry\" or when the try block never got active (because of an\n     * inactive surrounding conditional or after an error or interrupt or\n     * throw) or when there is a surrounding conditional and it has been\n     * made inactive by a \":continue\", \":break\", \":return\", or \":finish\" in\n     * the finally clause.  The latter case need not be tested since then\n     * anything pending has already been discarded. */\n    skip = did_emsg || got_int || did_throw\n\t\t\t     || !(cstack->cs_flags[cstack->cs_idx] & CSF_TRUE);\n\n    if (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n    {\n\teap->errmsg = get_end_emsg(cstack);\n\n\t// Find the matching \":try\" and report what's missing.\n\trewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,\n\t\t\t\t\t\t\t&cstack->cs_looplevel);\n\tskip = TRUE;\n\n\t/*\n\t * If an exception is being thrown, discard it to prevent it from\n\t * being rethrown at the end of this function.  It would be\n\t * discarded by the error message, anyway.  Resets did_throw.\n\t * This does not affect the script termination due to the error\n\t * since \"trylevel\" is decremented after emsg() has been called.\n\t */\n\tif (did_throw)\n\t    discard_current_exception();\n\n\t// report eap->errmsg, also when there already was an error\n\tdid_emsg = FALSE;\n    }\n    else\n    {\n\tidx = cstack->cs_idx;\n\n\t// Check the flags only when not in a skipped block.\n\tif (!skip && in_vim9script()\n\t\t     && (cstack->cs_flags[idx] & (CSF_CATCH|CSF_FINALLY)) == 0)\n\t{\n\t    // try/endtry without any catch or finally: give an error and\n\t    // continue.\n\t    eap->errmsg = _(e_missing_catch_or_finally);\n\t}\n\n\t/*\n\t * If we stopped with the exception currently being thrown at this\n\t * try conditional since we didn't know that it doesn't have\n\t * a finally clause, we need to rethrow it after closing the try\n\t * conditional.\n\t */\n\tif (did_throw && (cstack->cs_flags[idx] & CSF_TRUE)\n\t\t&& !(cstack->cs_flags[idx] & CSF_FINALLY))\n\t    rethrow = TRUE;\n    }\n\n    // If there was no finally clause, show the user when debugging or\n    // a breakpoint was encountered that the end of the try conditional has\n    // been reached: display the debug prompt (if not already done).  Do\n    // this on normal control flow or when an exception was thrown, but not\n    // on an interrupt or error not converted to an exception or when\n    // a \":break\", \":continue\", \":return\", or \":finish\" is pending.  These\n    // actions are carried out immediately.\n    if ((rethrow || (!skip && !(cstack->cs_flags[idx] & CSF_FINALLY)\n\t\t    && !cstack->cs_pending[idx]))\n\t    && dbg_check_skipped(eap))\n    {\n\t// Handle a \">quit\" debug command as if an interrupt had occurred\n\t// before the \":endtry\".  That is, throw an interrupt exception and\n\t// set \"skip\" and \"rethrow\".\n\tif (got_int)\n\t{\n\t    skip = TRUE;\n\t    (void)do_intthrow(cstack);\n\t    // The do_intthrow() call may have reset did_throw or\n\t    // cstack->cs_pending[idx].\n\t    rethrow = FALSE;\n\t    if (did_throw && !(cstack->cs_flags[idx] & CSF_FINALLY))\n\t\trethrow = TRUE;\n\t}\n    }\n\n    /*\n     * If a \":return\" is pending, we need to resume it after closing the\n     * try conditional; remember the return value.  If there was a finally\n     * clause making an exception pending, we need to rethrow it.  Make it\n     * the exception currently being thrown.\n     */\n    if (!skip)\n    {\n\tpending = cstack->cs_pending[idx];\n\tcstack->cs_pending[idx] = CSTP_NONE;\n\tif (pending == CSTP_RETURN)\n\t    rettv = cstack->cs_rettv[idx];\n\telse if (pending & CSTP_THROW)\n\t    current_exception = cstack->cs_exception[idx];\n    }\n\n    /*\n     * Discard anything pending on an error, interrupt, or throw in the\n     * finally clause.  If there was no \":finally\", discard a pending\n     * \":continue\", \":break\", \":return\", or \":finish\" if an error or\n     * interrupt occurred afterwards, but before the \":endtry\" was reached.\n     * If an exception was caught by the last of the catch clauses and there\n     * was no finally clause, finish the exception now.  This happens also\n     * after errors except when this \":endtry\" is not within a \":try\".\n     * Restore \"emsg_silent\" if it has been reset by this try conditional.\n     */\n    (void)cleanup_conditionals(cstack, CSF_TRY | CSF_SILENT, TRUE);\n\n    if (cstack->cs_idx >= 0 && (cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n\tleave_block(cstack);\n    --cstack->cs_trylevel;\n\n    if (!skip)\n    {\n\treport_resume_pending(pending,\n\t\t    (pending == CSTP_RETURN) ? rettv :\n\t\t    (pending & CSTP_THROW) ? (void *)current_exception : NULL);\n\tswitch (pending)\n\t{\n\t    case CSTP_NONE:\n\t\tbreak;\n\n\t    // Reactivate a pending \":continue\", \":break\", \":return\",\n\t    // \":finish\" from the try block or a catch clause of this try\n\t    // conditional.  This is skipped, if there was an error in an\n\t    // (unskipped) conditional command or an interrupt afterwards\n\t    // or if the finally clause is present and executed a new error,\n\t    // interrupt, throw, \":continue\", \":break\", \":return\", or\n\t    // \":finish\".\n\t    case CSTP_CONTINUE:\n\t\tex_continue(eap);\n\t\tbreak;\n\t    case CSTP_BREAK:\n\t\tex_break(eap);\n\t\tbreak;\n\t    case CSTP_RETURN:\n\t\tdo_return(eap, FALSE, FALSE, rettv);\n\t\tbreak;\n\t    case CSTP_FINISH:\n\t\tdo_finish(eap, FALSE);\n\t\tbreak;\n\n\t    // When the finally clause was entered due to an error,\n\t    // interrupt or throw (as opposed to a \":continue\", \":break\",\n\t    // \":return\", or \":finish\"), restore the pending values of\n\t    // did_emsg, got_int, and did_throw.  This is skipped, if there\n\t    // was a new error, interrupt, throw, \":continue\", \":break\",\n\t    // \":return\", or \":finish\".  in the finally clause.\n\t    default:\n\t\tif (pending & CSTP_ERROR)\n\t\t    did_emsg = TRUE;\n\t\tif (pending & CSTP_INTERRUPT)\n\t\t    got_int = TRUE;\n\t\tif (pending & CSTP_THROW)\n\t\t    rethrow = TRUE;\n\t\tbreak;\n\t}\n    }\n\n    if (rethrow)\n\t// Rethrow the current exception (within this cstack).\n\tdo_throw(cstack);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t * sits in dst, then we temporarily need to move ptr there\n\t * to simulate dst (== 0) +/-= ptr. Needed, for example,\n\t * for cases where we use K-based arithmetic in one direction\n\t * and truncated reg-based in the other in order to explore\n\t * bad access.\n\t */\n\tif (!ptr_is_dst_reg) {\n\t\ttmp = *dst_reg;\n\t\t*dst_reg = *ptr_reg;\n\t}\n\tret = push_stack(env, env->insn_idx + 1, env->insn_idx, true);\n\tif (!ptr_is_dst_reg && ret)\n\t\t*dst_reg = tmp;\n\treturn !ret ? REASON_STACK : 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t * sits in dst, then we temporarily need to move ptr there\n\t * to simulate dst (== 0) +/-= ptr. Needed, for example,\n\t * for cases where we use K-based arithmetic in one direction\n\t * and truncated reg-based in the other in order to explore\n\t * bad access.\n\t */\n\tif (!ptr_is_dst_reg) {\n\t\ttmp = *dst_reg;\n\t\t*dst_reg = *ptr_reg;\n\t}\n\tret = sanitize_speculative_path(env, NULL, env->insn_idx + 1,\n\t\t\t\t\tenv->insn_idx);\n\tif (!ptr_is_dst_reg && ret)\n\t\t*dst_reg = tmp;\n\treturn !ret ? REASON_STACK : 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "yy_symbol_print (FILE *yyo,\n                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, void *parm)\n{\n  YYFPRINTF (yyo, \"%s %s (\",\n             yykind < YYNTOKENS ? \"token\" : \"nterm\", yysymbol_name (yykind));\n\n  YY_LOCATION_PRINT (yyo, *yylocationp);\n  YYFPRINTF (yyo, \": \");\n  yy_symbol_value_print (yyo, yykind, yyvaluep, yylocationp, parm);\n  YYFPRINTF (yyo, \")\");\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "yy_symbol_print (FILE *yyo,\n                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, void *parm)\n{\n  YYFPRINTF (yyo, \"%s %s (\",\n             yykind < YYNTOKENS ? \"token\" : \"nterm\", yysymbol_name (yykind));\n\n  YYLOCATION_PRINT (yyo, yylocationp);\n  YYFPRINTF (yyo, \": \");\n  yy_symbol_value_print (yyo, yykind, yyvaluep, yylocationp, parm);\n  YYFPRINTF (yyo, \")\");\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tconst char *jscript =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        sessionStorage.setItem('mod_auth_openidc_preserve_post_params', JSON.stringify(%s));\\n\"\n\t\t\t\t\t\"        %s\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", jmethod, json,\n\t\t\t\t\tlocation ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \"window.location='%s';\\n\",\n\t\t\t\t\t\t\t\t\tlocation) :\n\t\t\t\t\t\t\t\t\t\"\");\n\tif (location == NULL) {\n\t\tif (javascript_method)\n\t\t\t*javascript_method = apr_pstrdup(r->pool, jmethod);\n\t\tif (javascript)\n\t\t\t*javascript = apr_pstrdup(r->pool, jscript);\n\t} else {\n\t\toidc_util_html_send(r, \"Preserving...\", jscript, jmethod,\n\t\t\t\t\"<p>Preserving...</p>\", OK);\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tconst char *jscript =\n\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\"    <script type=\\\"text/javascript\\\">\\n\"\n\t\t\t\t\t\"      function %s() {\\n\"\n\t\t\t\t\t\"        sessionStorage.setItem('mod_auth_openidc_preserve_post_params', JSON.stringify(%s));\\n\"\n\t\t\t\t\t\"        %s\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    </script>\\n\", jmethod, json,\n\t\t\t\t\tlocation ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \"window.location='%s';\\n\",\n\t\t\t\t\t\t\t\t\toidc_util_javascript_escape(r->pool, location)) :\n\t\t\t\t\t\t\t\t\t\"\");\n\tif (location == NULL) {\n\t\tif (javascript_method)\n\t\t\t*javascript_method = apr_pstrdup(r->pool, jmethod);\n\t\tif (javascript)\n\t\t\t*javascript = apr_pstrdup(r->pool, jscript);\n\t} else {\n\t\toidc_util_html_send(r, \"Preserving...\", jscript, jmethod,\n\t\t\t\t\"<p>Preserving...</p>\", OK);\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getacl(xdr, rqstp, &res->acl_len);\n\nout:\n\treturn status;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n\tstatus = decode_compound_hdr(xdr, &hdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_sequence(xdr, &res->seq_res, rqstp);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getacl(xdr, rqstp, res);\n\nout:\n\treturn status;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "struct key *find_keyring_by_name(const char *name, bool skip_perm_check)\n{\n\tstruct key *keyring;\n\tint bucket;\n\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbucket = keyring_hash(name);\n\n\tread_lock(&keyring_name_lock);\n\t\t\t\t    ) {\n\t\t\tif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\n\t\t\t\tcontinue;\n\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\tcontinue;\n\n\t\t\t/* we've got a match but we might end up racing with\n\t\t\t * key_cleanup() if the keyring is currently 'dead'\n\t\t\t * (ie. it has a zero usage count) */\n\t\t\tif (!refcount_inc_not_zero(&keyring->usage))\n\t\t\t\tcontinue;\n\t\t\tkeyring->last_used_at = current_kernel_time().tv_sec;\n\t\t\tgoto out;\n\t\t}\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "struct key *find_keyring_by_name(const char *name, bool uid_keyring)\n{\n\tstruct key *keyring;\n\tint bucket;\n\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbucket = keyring_hash(name);\n\n\tread_lock(&keyring_name_lock);\n\t\t\t\t    ) {\n\t\t\tif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\n\t\t\t\tcontinue;\n\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (uid_keyring) {\n\t\t\t\tif (!test_bit(KEY_FLAG_UID_KEYRING,\n\t\t\t\t\t      &keyring->flags))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* we've got a match but we might end up racing with\n\t\t\t * key_cleanup() if the keyring is currently 'dead'\n\t\t\t * (ie. it has a zero usage count) */\n\t\t\tif (!refcount_inc_not_zero(&keyring->usage))\n\t\t\t\tcontinue;\n\t\t\tkeyring->last_used_at = current_kernel_time().tv_sec;\n\t\t\tgoto out;\n\t\t}\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int dev_get_valid_name(struct net *net,\n\t\t\t      struct net_device *dev,\n\t\t\t      const char *name)\n{\n\tBUG_ON(!net);\n\n\tif (!dev_valid_name(name))\n\t\treturn -EINVAL;\n\n\tif (strchr(name, '%'))\n\t\treturn dev_alloc_name_ns(net, dev, name);\n\telse if (__dev_get_by_name(net, name))\n\t\treturn -EEXIST;\n\telse if (dev->name != name)\n\t\tstrlcpy(dev->name, name, IFNAMSIZ);\n\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int dev_get_valid_name(struct net *net, struct net_device *dev,\n\t\t       const char *name)\n{\n\tBUG_ON(!net);\n\n\tif (!dev_valid_name(name))\n\t\treturn -EINVAL;\n\n\tif (strchr(name, '%'))\n\t\treturn dev_alloc_name_ns(net, dev, name);\n\telse if (__dev_get_by_name(net, name))\n\t\treturn -EEXIST;\n\telse if (dev->name != name)\n\t\tstrlcpy(dev->name, name, IFNAMSIZ);\n\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "          int is_entity = 0;\n          int i = obj->type - 500;\n          Dwg_Class *klass = NULL;\n\n          /* restart and read into the UNKNOWN_OBJ object */\n          /* the relative offset from type after common_entity_data */\n          // obj->common_size = bit_position(dat) - restartpos;\n          // LOG_HANDLE(\"common_size: %lu\\n\", obj->common_size); // needed for\n          // unknown\n          bit_set_position (dat, restartpos);\n\n          // obj->unknown_off = obj->unknown_pos - restartpos;\n          // LOG_TRACE(\"Unknown pos %lu, offset %lu\\n\", obj->unknown_pos,\n          // obj->unknown_off);\n\n          if (i >= 0 && i < (int)dwg->num_classes)\n            {\n              klass = &dwg->dwg_class[i];\n              is_entity = dwg_class_is_entity (klass);\n            }\n          else\n            {\n              if (i < 0)\n                {\n                  LOG_ERROR (\"Invalid class index %d <0\", i);\n                }\n              else\n                {\n                  LOG_ERROR (\"Invalid class index %d >%d\", i,\n                             (int)dwg->num_classes);\n                }\n              obj->supertype = DWG_SUPERTYPE_UNKNOWN;\n              obj->type = 0;\n              *dat = abs_dat;\n              return error | DWG_ERR_VALUEOUTOFBOUNDS;\n            }\n          // properly dwg_decode_object/_entity for eed, reactors, xdic\n          if (klass && !is_entity)\n            {\n              int err = dwg_decode_UNKNOWN_OBJ (dat, obj);\n              error |= err;\n              obj->supertype = DWG_SUPERTYPE_UNKNOWN;\n              if (!dat)\n                return error;\n              if (err >= DWG_ERR_CRITICAL)\n                *dat = abs_dat;\n            }\n          else if (klass) // is_entity\n            {\n              int err;\n#if 0 && !defined(IS_RELEASE)\n              if (strEQc(klass->dxfname, \"MULTILEADER\")) { //debug CED\n                char *mleader = bit_read_TF(dat, obj->size);\n                LOG_INSANE_TF(mleader, (int)obj->size)\n                bit_set_position(dat, restartpos);\n                free (mleader);\n              }\n#endif\n              err = dwg_decode_UNKNOWN_ENT (dat, obj);\n              error |= err;\n              obj->supertype = DWG_SUPERTYPE_UNKNOWN;\n              if (!dat)\n                return error;\n              if (err >= DWG_ERR_CRITICAL)\n                *dat = abs_dat;\n            }\n          else // not a class\n            {\n              LOG_WARN (\"Unknown object, skipping eed/reactors/xdic\");\n              SINCE (R_2000)\n              {\n                obj->bitsize = bit_read_RL (dat);\n                LOG_TRACE (\"bitsize: \" FORMAT_RL \" [RL] @%lu.%u\\n\",\n                           obj->bitsize, dat->byte-2, dat->bit);\n                if (obj->bitsize > obj->size * 8)\n                  {\n                    LOG_ERROR (\"Invalid bitsize \" FORMAT_RL \" => \" FORMAT_RL,\n                               obj->bitsize, obj->size * 8);\n                    obj->bitsize = obj->size * 8;\n                    error |= DWG_ERR_VALUEOUTOFBOUNDS;\n                  }\n              }\n              if (!bit_read_H (dat, &obj->handle))\n                {\n                  LOG_TRACE (\"handle: \" FORMAT_H \" [H 5]\\n\",\n                             ARGS_H (obj->handle));\n                }\n              restartpos = dat->byte;\n              obj->supertype = DWG_SUPERTYPE_UNKNOWN;\n              obj->tio.unknown = bit_read_TF (dat, obj->size);\n              dat->byte = restartpos;\n            }\n        }\n    }\n\n  if (obj->handle.value)\n    { // empty only with UNKNOWN\n      LOG_HANDLE (\" object_map{%lX} = %lu\\n\", obj->handle.value,\n                  (unsigned long)num);\n      hash_set (dwg->object_map, obj->handle.value, (uint32_t)num);\n    }\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "          int is_entity = 0;\n          int i = obj->type - 500;\n          Dwg_Class *klass = NULL;\n\n          /* restart and read into the UNKNOWN_OBJ object */\n          /* the relative offset from type after common_entity_data */\n          // obj->common_size = bit_position(dat) - restartpos;\n          // LOG_HANDLE(\"common_size: %lu\\n\", obj->common_size); // needed for\n          // unknown\n          bit_set_position (dat, restartpos);\n          obj->supertype = DWG_SUPERTYPE_UNKNOWN;\n\n          if (i >= 0 && i < (int)dwg->num_classes)\n            {\n              klass = &dwg->dwg_class[i];\n              is_entity = dwg_class_is_entity (klass);\n            }\n          else\n            {\n              if (i < 0)\n                {\n                  LOG_ERROR (\"Invalid class index %d <0\", i);\n                }\n              else\n                {\n                  LOG_ERROR (\"Invalid class index %d >%d\", i,\n                             (int)dwg->num_classes);\n                }\n              obj->type = 0;\n              *dat = abs_dat;\n              return error | DWG_ERR_VALUEOUTOFBOUNDS;\n            }\n          // properly dwg_decode_object/_entity for eed, reactors, xdic\n          if (is_entity)\n              error |= dwg_decode_UNKNOWN_ENT (dat, obj);\n          else\n              error |= dwg_decode_UNKNOWN_OBJ (dat, obj);\n\n          if (!dat)\n            return error;\n          if (error >= DWG_ERR_CRITICAL)\n            *dat = abs_dat;\n        }\n    }\n\n  if (obj->handle.value)\n    { // empty only with UNKNOWN\n      LOG_HANDLE (\" object_map{%lX} = %lu\\n\", obj->handle.value,\n                  (unsigned long)num);\n      hash_set (dwg->object_map, obj->handle.value, (uint32_t)num);\n    }\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tif (IP_V(ip) == 6)\n\t\tip6 = (const struct ip6_hdr *)bp2;\n\telse\n\t\tip6 = NULL;\n\tch = '\\0';\n\tif (!ND_TTEST(pgm->pgm_dport)) {\n\t\tif (ip6) {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_dst)));\n\t\t\treturn;\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tipaddr_string(ndo, &ip->ip_src),\n\t\t\t\tipaddr_string(ndo, &ip->ip_dst)));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tsport = EXTRACT_16BITS(&pgm->pgm_sport);\n\tdport = EXTRACT_16BITS(&pgm->pgm_dport);\n\n\tif (ip6) {\n\t\tif (ip6->ip6_nxt == IPPROTO_PGM) {\n\t\t\tND_PRINT((ndo, \"%s.%s > %s.%s: \",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\ttcpport_string(ndo, sport),\n\t\tbreak;\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Skip past the group, saving info along the way\n\t     * and stopping if we don't have enough.\n\t     */\n\t    bp += (2 * sizeof(uint16_t));\n\t    switch (EXTRACT_16BITS(bp)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in6_addr);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tip = (const struct ip *)bp2;\n\tif (IP_V(ip) == 6)\n\t\tip6 = (const struct ip6_hdr *)bp2;\n\telse\n\t\tip6 = NULL;\n\tch = '\\0';\n\tif (!ND_TTEST(pgm->pgm_dport)) {\n\t\tif (ip6) {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_dst)));\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tipaddr_string(ndo, &ip->ip_src),\n\t\t\t\tipaddr_string(ndo, &ip->ip_dst)));\n\t\t}\n\t\treturn;\n\t}\n\n\tsport = EXTRACT_16BITS(&pgm->pgm_sport);\n\tdport = EXTRACT_16BITS(&pgm->pgm_dport);\n\n\tif (ip6) {\n\t\tif (ip6->ip6_nxt == IPPROTO_PGM) {\n\t\t\tND_PRINT((ndo, \"%s.%s > %s.%s: \",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\ttcpport_string(ndo, sport),\n\t    default:\n\t\tgoto trunc;\n\t\tbreak;\n\t    }\n\n\t    /*\n\t     * Skip past the group, saving info along the way\n\t     * and stopping if we don't have enough.\n\t     */\n\t    bp += (2 * sizeof(uint16_t));\n\t    ND_TCHECK_16BITS(bp);\n\t    switch (EXTRACT_16BITS(bp)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in_addr);\n\t\tbreak;\n\t    case AFNUM_INET6:\n\t\tND_TCHECK2(*bp, sizeof(struct in6_addr));\n\t\taddrtostr6(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in6_addr);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "tTcpIpPacketParsingResult ParaNdis_CheckSumVerifyFlat(\n                                                PVOID pBuffer,\n                                                ULONG ulDataLength,\n                                                ULONG flags,\n                                                LPCSTR caller)\n{\n    tCompletePhysicalAddress SGBuffer;\n    SGBuffer.Virtual = pBuffer;\n    SGBuffer.size = ulDataLength;\n    return ParaNdis_CheckSumVerify(&SGBuffer, ulDataLength, 0, flags, caller);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "tTcpIpPacketParsingResult ParaNdis_CheckSumVerifyFlat(\n                                                PVOID pBuffer,\n                                                ULONG ulDataLength,\n                                                ULONG flags,\n                                                BOOLEAN verifyLength,\n                                                LPCSTR caller)\n{\n    tCompletePhysicalAddress SGBuffer;\n    SGBuffer.Virtual = pBuffer;\n    SGBuffer.size = ulDataLength;\n    return ParaNdis_CheckSumVerify(&SGBuffer, ulDataLength, 0, flags, verifyLength, caller);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tunaligned_panic(\"Kernel does fpu/atomic \"\n\t\t\t\t\"unaligned load/store.\", regs);\n\n\t\tkernel_mna_trap_fault(0);\n\t} else {\n\t\tunsigned long addr, *reg_addr;\n\t\tint err;\n\n\t\taddr = compute_effective_address(regs, insn,\n\t\t\t\t\t\t ((insn >> 25) & 0x1f));\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, addr);\n\t\tswitch (asi) {\n\t\tcase ASI_NL:\n\t\tcase ASI_AIUPL:\n\t\tcase ASI_AIUSL:\n\t\tcase ASI_PL:\n\t\tcase ASI_SL:\n\t\tcase ASI_PNFL:\n\t\tcase ASI_SNFL:\n\t\t\tasi &= ~0x08;\n\t\t\tbreak;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tunaligned_panic(\"Kernel does fpu/atomic \"\n\t\t\t\t\"unaligned load/store.\", regs);\n\n\t\tkernel_mna_trap_fault(0);\n\t} else {\n\t\tunsigned long addr, *reg_addr;\n\t\tint err;\n\n\t\taddr = compute_effective_address(regs, insn,\n\t\t\t\t\t\t ((insn >> 25) & 0x1f));\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, addr);\n\t\tswitch (asi) {\n\t\tcase ASI_NL:\n\t\tcase ASI_AIUPL:\n\t\tcase ASI_AIUSL:\n\t\tcase ASI_PL:\n\t\tcase ASI_SL:\n\t\tcase ASI_PNFL:\n\t\tcase ASI_SNFL:\n\t\t\tasi &= ~0x08;\n\t\t\tbreak;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tDeleteRunner(ReferenceHandle& that, Local<Value> key_handle) :\n\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference} {\n\t\t\tthat.CheckDisposed();\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tDeleteRunner(ReferenceHandle& that, Local<Value> key_handle) :\n\t\tAccessorRunner{that, key_handle} {}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n\tif (qp->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto out;\n\n\tipq_kill(qp);\n\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMTIMEOUT);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMFAILS);\n\n\tif ((qp->q.last_in & INET_FRAG_FIRST_IN) && qp->q.fragments != NULL) {\n\t\tstruct sk_buff *head = qp->q.fragments;\n\n\t\trcu_read_lock();\n\t\thead->dev = dev_get_by_index_rcu(net, qp->iif);\n\t\tif (!head->dev)\n\t\t\tgoto out_rcu_unlock;\n\n\t\t/*\n\t\t * Only search router table for the head fragment,\n\t\t * when defraging timeout at PRE_ROUTING HOOK.\n\t\t */\n\t\tif (qp->user == IP_DEFRAG_CONNTRACK_IN && !skb_dst(head)) {\n\t\t\tconst struct iphdr *iph = ip_hdr(head);\n\t\t\tint err = ip_route_input(head, iph->daddr, iph->saddr,\n\t\t\t\t\t\t iph->tos, head->dev);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out_rcu_unlock;\n\n\t\t\t/*\n\t\t\t * Only an end host needs to send an ICMP\n\t\t\t * \"Fragment Reassembly Timeout\" message, per RFC792.\n\t\t\t */\n\t\t\tif (skb_rtable(head)->rt_type != RTN_LOCAL)\n\t\t\t\tgoto out_rcu_unlock;\n\n\t\t}\n\n\t\t/* Send an ICMP \"Fragment Reassembly Timeout\" message. */\n\t\ticmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);\nout_rcu_unlock:\n\t\trcu_read_unlock();\n\t}\nout:\n\tspin_unlock(&qp->q.lock);\n\tipq_put(qp);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tif (qp->q.last_in & INET_FRAG_COMPLETE)\n\t\tgoto out;\n\n\tipq_kill(qp);\n\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMTIMEOUT);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMFAILS);\n\n\tif ((qp->q.last_in & INET_FRAG_FIRST_IN) && qp->q.fragments != NULL) {\n\t\tstruct sk_buff *head = qp->q.fragments;\n\t\tconst struct iphdr *iph;\n\t\tint err;\n\n\t\trcu_read_lock();\n\t\thead->dev = dev_get_by_index_rcu(net, qp->iif);\n\t\tif (!head->dev)\n\t\t\tgoto out_rcu_unlock;\n\n\t\t/* skb dst is stale, drop it, and perform route lookup again */\n\t\tskb_dst_drop(head);\n\t\tiph = ip_hdr(head);\n\t\terr = ip_route_input_noref(head, iph->daddr, iph->saddr,\n\t\t\t\t\t   iph->tos, head->dev);\n\t\tif (err)\n\t\t\tgoto out_rcu_unlock;\n\n\t\t/*\n\t\t * Only an end host needs to send an ICMP\n\t\t * \"Fragment Reassembly Timeout\" message, per RFC792.\n\t\t */\n\t\tif (qp->user == IP_DEFRAG_CONNTRACK_IN &&\n\t\t    skb_rtable(head)->rt_type != RTN_LOCAL)\n\t\t\tgoto out_rcu_unlock;\n\n\n\t\t/* Send an ICMP \"Fragment Reassembly Timeout\" message. */\n\t\ticmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);\nout_rcu_unlock:\n\t\trcu_read_unlock();\n\t}\nout:\n\tspin_unlock(&qp->q.lock);\n\tipq_put(qp);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int getnum (const char **fmt, int df) {\n  if (!isdigit(**fmt))  /* no number? */\n    return df;  /* return default value */\n  else {\n    int a = 0;\n    do {\n      a = a*10 + *((*fmt)++) - '0';\n    } while (isdigit(**fmt));\n    return a;\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int getnum (lua_State *L, const char **fmt, int df) {\n  if (!isdigit(**fmt))  /* no number? */\n    return df;  /* return default value */\n  else {\n    int a = 0;\n    do {\n      if (a > (INT_MAX / 10) || a * 10 > (INT_MAX - (**fmt - '0')))\n        luaL_error(L, \"integral size overflow\");\n      a = a*10 + *((*fmt)++) - '0';\n    } while (isdigit(**fmt));\n    return a;\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int mi_repair_by_sort(MI_CHECK *param, register MI_INFO *info,\n\t\t      const char * name, int rep_quick)\n{\n  int got_error;\n  uint i;\n  ulong length;\n  ha_rows start_records;\n  my_off_t new_header_length,del;\n  File new_file;\n  MI_SORT_PARAM sort_param;\n  MYISAM_SHARE *share=info->s;\n  HA_KEYSEG *keyseg;\n  if (&share->state.state != info->state)\n    memcpy( &share->state.state, info->state, sizeof(*info->state));\n\nerr:\n  got_error|= flush_blocks(param, share->key_cache, share->kfile);\n  (void) end_io_cache(&info->rec_cache);\n  if (!got_error)\n  {\n    /* Replace the actual file with the temporary file */\n    if (new_file >= 0)\n    {\n      mysql_file_close(new_file, MYF(0));\n      info->dfile=new_file= -1;\n      if (change_to_newfile(share->data_file_name,MI_NAME_DEXT, DATA_TMP_EXT,\n\t\t\t    (param->testflag & T_BACKUP_DATA ?\n\t\t\t     MYF(MY_REDEL_MAKE_BACKUP): MYF(0))) ||\n\t  mi_open_datafile(info,share,name,-1))\n\tgot_error=1;\n    }\n  }\n  if (got_error)\n  {\n    if (! param->error_printed)\n      mi_check_print_error(param,\"%d when fixing table\",my_errno);\n    if (new_file >= 0)\n    {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int mi_repair_by_sort(MI_CHECK *param, register MI_INFO *info,\n\t\t      const char * name, int rep_quick, my_bool no_copy_stat)\n{\n  int got_error;\n  uint i;\n  ulong length;\n  ha_rows start_records;\n  my_off_t new_header_length,del;\n  File new_file;\n  MI_SORT_PARAM sort_param;\n  MYISAM_SHARE *share=info->s;\n  HA_KEYSEG *keyseg;\n    memcpy( &share->state.state, info->state, sizeof(*info->state));\n\nerr:\n  got_error|= flush_blocks(param, share->key_cache, share->kfile);\n  (void) end_io_cache(&info->rec_cache);\n  if (!got_error)\n  {\n    /* Replace the actual file with the temporary file */\n    if (new_file >= 0)\n    {\n      myf flags= 0;\n      if (param->testflag & T_BACKUP_DATA)\n        flags |= MY_REDEL_MAKE_BACKUP;\n      if (no_copy_stat)\n        flags |= MY_REDEL_NO_COPY_STAT;\n      mysql_file_close(new_file, MYF(0));\n      info->dfile=new_file= -1;\n      if (change_to_newfile(share->data_file_name,MI_NAME_DEXT, DATA_TMP_EXT,\n                            flags) ||\n\t  mi_open_datafile(info,share,name,-1))\n\tgot_error=1;\n    }\n  }\n  if (got_error)\n  {\n    if (! param->error_printed)\n      mi_check_print_error(param,\"%d when fixing table\",my_errno);\n    if (new_file >= 0)\n    {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n    // Parse default for 'fillchars'.\n    (void)set_chars_option(curwin, &p_fcs);\n\n#ifdef FEAT_CLIPBOARD\n    // Parse default for 'clipboard'\n    (void)check_clipboard_option();\n#endif\n#ifdef FEAT_VARTABS\n    vim_free(curbuf->b_p_vsts_array);\n    tabstop_set(curbuf->b_p_vsts, &curbuf->b_p_vsts_array);\n    vim_free(curbuf->b_p_vts_array);\n    tabstop_set(curbuf->b_p_vts,  &curbuf->b_p_vts_array);\n#endif\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n    // Parse default for 'fillchars'.\n    (void)set_chars_option(curwin, &p_fcs);\n\n#ifdef FEAT_CLIPBOARD\n    // Parse default for 'clipboard'\n    (void)check_clipboard_option();\n#endif\n#ifdef FEAT_VARTABS\n    vim_free(curbuf->b_p_vsts_array);\n    (void)tabstop_set(curbuf->b_p_vsts, &curbuf->b_p_vsts_array);\n    vim_free(curbuf->b_p_vts_array);\n    (void)tabstop_set(curbuf->b_p_vts,  &curbuf->b_p_vts_array);\n#endif\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tif (acl_len > args.acl_len)\n\t\tnfs4_write_cached_acl(inode, NULL, acl_len);\n\telse\n\t\tnfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,\n\t\t\t\t      acl_len);\n\tif (buf) {\n\t\tret = -ERANGE;\n\t\tif (acl_len > buflen)\n\t\t\tgoto out_free;\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n\t\t\t\tres.acl_len);\n\t}\n\tret = acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tif (acl_len > args.acl_len)\n\t\tnfs4_write_cached_acl(inode, NULL, acl_len);\n\telse\n\t\tnfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,\n\t\t\t\t      acl_len);\n\tif (buf) {\n\t\tret = -ERANGE;\n\t\tif (acl_len > buflen)\n\t\t\tgoto out_free;\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n\t\t\t\tacl_len);\n\t}\n\tret = acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "check_restricted(void)\n{\n    if (restricted)\n    {\n\temsg(_(\"E145: Shell commands not allowed in rvim\"));\n\treturn TRUE;\n    }\n    return FALSE;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "check_restricted(void)\n{\n    if (restricted)\n    {\n\temsg(_(\"E145: Shell commands and some functionality not allowed in rvim\"));\n\treturn TRUE;\n    }\n    return FALSE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tl_step_l = l_max_res * l_step_r;\n\n\t/* set values for first packet iterator */\n\tl_current_pi = l_pi;\n\n\t/* memory allocation for include */\n\t/* prevent an integer overflow issue */\n\tl_current_pi->include = 00;\n\tif (l_step_l <= (SIZE_MAX / (l_tcp->numlayers + 1U)))\n\t{\n\t\tl_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16));\n\t}\n\n\tif\n\t\t(!l_current_pi->include)\n\t{\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\topj_pi_destroy(l_pi, l_bound);\n\t\treturn 00;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tl_step_l = l_max_res * l_step_r;\n\n\t/* set values for first packet iterator */\n\tl_current_pi = l_pi;\n\n\t/* memory allocation for include */\n\t/* prevent an integer overflow issue */\n\tl_current_pi->include = 00;\n\tif (l_step_l <= (SIZE_MAX / (l_tcp->numlayers + 1U)))\n\t{\n\t\tl_current_pi->include = (OPJ_INT16*) opj_calloc((size_t)(l_tcp->numlayers + 1U) * l_step_l, sizeof(OPJ_INT16));\n\t}\n\n\tif\n\t\t(!l_current_pi->include)\n\t{\n\t\topj_free(l_tmp_data);\n\t\topj_free(l_tmp_ptr);\n\t\topj_pi_destroy(l_pi, l_bound);\n\t\treturn 00;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "        tsize_t\n          strip_size;\n\n        unsigned char\n          *p,\n          *strip_pixels;\n\n        /*\n          Convert stripped TIFF image.\n        */\n        extent=4*MagickMax(image->columns*(samples_per_pixel+extra_samples)*\n          (image->depth+7)/8,(size_t) TIFFStripSize(tiff));\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n        stride=TIFFVStripSize(tiff,1);\n        strip_id=0;\n        p=strip_pixels;\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "        tsize_t\n          strip_size;\n\n        unsigned char\n          *p,\n          *strip_pixels;\n\n        /*\n          Convert stripped TIFF image.\n        */\n        extent=MagickMax(sizeof(uint32),(samples_per_pixel+extra_samples)*\n          (image->depth+7)/8)*image->columns*rows_per_strip;\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n        stride=TIFFVStripSize(tiff,1);\n        strip_id=0;\n        p=strip_pixels;\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int ras_validate(jas_stream_t *in)\n{\n\tuchar buf[RAS_MAGICLEN];\n\tint i;\n\tint n;\n\tuint_fast32_t magic;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= RAS_MAGICLEN);\n\n\t/* Read the validation data (i.e., the data used for detecting\n\t  the format). */\n\tif ((n = jas_stream_read(in, buf, RAS_MAGICLEN)) < 0) {\n\t\treturn -1;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int ras_validate(jas_stream_t *in)\n{\n\tjas_uchar buf[RAS_MAGICLEN];\n\tint i;\n\tint n;\n\tuint_fast32_t magic;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= RAS_MAGICLEN);\n\n\t/* Read the validation data (i.e., the data used for detecting\n\t  the format). */\n\tif ((n = jas_stream_read(in, buf, RAS_MAGICLEN)) < 0) {\n\t\treturn -1;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "                  }\n                  char* newBuffer = MsgHeaderScanner::allocateBuffer((int)size);\n                  memcpy(newBuffer,\n                         unprocessedCharPtr + contentLength,\n                         overHang);\n                  mBuffer = newBuffer;\n                  mBufferPos = 0;\n                  mBufferSize = size;\n                  \n                  DebugLog (<< \"Extra bytes after message: \" << overHang);\n                  DebugLog (<< Data(mBuffer, overHang));\n                  \n                  bytesRead = overHang;\n               }\n\n               // The message body is complete.\n               mMessage->setBody(unprocessedCharPtr, (UInt32)contentLength);\n               CongestionManager::RejectionBehavior b=mTransport->getRejectionBehaviorForIncoming();\n               if (b==CongestionManager::REJECTING_NON_ESSENTIAL\n                     || (b==CongestionManager::REJECTING_NEW_WORK\n                        && mMessage->isRequest()))\n            // .bwc. Bad Content-Length. We are hosed.\n            delete [] mBuffer;\n            mBuffer = 0;\n            delete mMessage;\n            mMessage = 0;\n            //.jacob. Shouldn't the state also be set here?\n            return false;\n         }\n\n         mBufferPos += bytesRead;\n         if (mBufferPos == contentLength)\n         {\n            mMessage->addBuffer(mBuffer);\n            mMessage->setBody(mBuffer, (UInt32)contentLength);\n            mBuffer=0;\n            // .bwc. basicCheck takes up substantial CPU. Don't bother doing it\n            // if we're overloaded.\n            CongestionManager::RejectionBehavior b=mTransport->getRejectionBehaviorForIncoming();\n            if (b==CongestionManager::REJECTING_NON_ESSENTIAL\n                  || (b==CongestionManager::REJECTING_NEW_WORK\n                     && mMessage->isRequest()))\n            {\n               UInt32 expectedWait(mTransport->getExpectedWaitForIncoming());\n               // .bwc. If this fifo is REJECTING_NEW_WORK, we will drop\n               // requests but not responses ( ?bwc? is this right for ACK?). \n            }\n            else\n            {\n               DebugLog(<< \"##ConnectionBase: \" << *this << \" received: \" << *mMessage);\n\n               Transport::stampReceived(mMessage);\n               resip_assert( mTransport );\n               mTransport->pushRxMsgUp(mMessage);\n               mMessage = 0;\n            }\n            mConnState = NewMessage;\n         }\n         else if (mBufferPos == mBufferSize)\n         {\n            // .bwc. We've filled our buffer; go ahead and make more room.\n            size_t newSize = resipMin(mBufferSize*3/2, contentLength);\n            char* newBuffer = 0;\n            try\n            {\n               newBuffer=new char[newSize];\n            }\n            catch(std::bad_alloc&)\n            {\n               ErrLog(<<\"Failed to alloc a buffer while receiving body!\");\n               return false;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "                  }\n                  char* newBuffer = MsgHeaderScanner::allocateBuffer((int)size);\n                  memcpy(newBuffer,\n                         unprocessedCharPtr + contentLength,\n                         overHang);\n                  mBuffer = newBuffer;\n                  mBufferPos = 0;\n                  mBufferSize = size;\n                  \n                  DebugLog (<< \"Extra bytes after message: \" << overHang);\n                  //DebugLog (<< Data(mBuffer, overHang));\n                  \n                  bytesRead = overHang;\n               }\n\n               // The message body is complete.\n               mMessage->setBody(unprocessedCharPtr, (UInt32)contentLength);\n               CongestionManager::RejectionBehavior b=mTransport->getRejectionBehaviorForIncoming();\n               if (b==CongestionManager::REJECTING_NON_ESSENTIAL\n                     || (b==CongestionManager::REJECTING_NEW_WORK\n                        && mMessage->isRequest()))\n            // .bwc. Bad Content-Length. We are hosed.\n            delete [] mBuffer;\n            mBuffer = 0;\n            delete mMessage;\n            mMessage = 0;\n            //.jacob. Shouldn't the state also be set here?\n            return false;\n         }\n\n         mBufferPos += bytesRead;\n         if (mBufferPos >= contentLength)\n         {\n            int overHang = mBufferPos - (int)contentLength;\n            char *overHangStart = mBuffer + contentLength;\n\n            mMessage->addBuffer(mBuffer);\n            mMessage->setBody(mBuffer, (UInt32)contentLength);\n            mConnState = NewMessage;\n            mBuffer = 0;\n\n            if (overHang > 0)\n            {\n                // The next message has been partially read.\n                size_t size = overHang * 3 / 2;\n                if (size < ConnectionBase::ChunkSize)\n                {\n                    size = ConnectionBase::ChunkSize;\n                }\n                char* newBuffer = MsgHeaderScanner::allocateBuffer((int)size);\n                memcpy(newBuffer, overHangStart, overHang);\n                mBuffer = newBuffer;\n                mBufferPos = 0;\n                mBufferSize = size;\n\n                DebugLog(<< \"Extra bytes after message: \" << overHang);\n                //DebugLog(<< Data(mBuffer, overHang));\n\n                bytesRead = overHang;\n            }\n\n            // .bwc. basicCheck takes up substantial CPU. Don't bother doing it\n            // if we're overloaded.\n            CongestionManager::RejectionBehavior b=mTransport->getRejectionBehaviorForIncoming();\n            if (b==CongestionManager::REJECTING_NON_ESSENTIAL\n                  || (b==CongestionManager::REJECTING_NEW_WORK\n                     && mMessage->isRequest()))\n            {\n               UInt32 expectedWait(mTransport->getExpectedWaitForIncoming());\n               // .bwc. If this fifo is REJECTING_NEW_WORK, we will drop\n               // requests but not responses ( ?bwc? is this right for ACK?). \n            }\n            else\n            {\n               DebugLog(<< \"##ConnectionBase: \" << *this << \" received: \" << *mMessage);\n\n               Transport::stampReceived(mMessage);\n               resip_assert( mTransport );\n               mTransport->pushRxMsgUp(mMessage);\n               mMessage = 0;\n            }\n            \n            if (overHang > 0) \n            {\n               goto start;\n            }\n         }\n         else if (mBufferPos == mBufferSize)\n         {\n            // .bwc. We've filled our buffer and haven't read contentLength bytes yet; go ahead and make more room.\n            assert(contentLength >= mBufferSize);\n            size_t newSize = resipMin(mBufferSize*3/2, contentLength);\n            char* newBuffer = 0;\n            try\n            {\n               newBuffer=new char[newSize];\n            }\n            catch(std::bad_alloc&)\n            {\n               ErrLog(<<\"Failed to alloc a buffer while receiving body!\");\n               return false;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void fp4_write_bin(uint8_t *bin, int len, const fp4_t a) {\n\tif (len != 4 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp2_write_bin(bin, 2 * RLC_FP_BYTES, a[0], 0);\n\tfp2_write_bin(bin + 2 * RLC_FP_BYTES, 2 * RLC_FP_BYTES, a[1], 0);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void fp4_write_bin(uint8_t *bin, size_t len, const fp4_t a) {\n\tif (len != 4 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp2_write_bin(bin, 2 * RLC_FP_BYTES, a[0], 0);\n\tfp2_write_bin(bin + 2 * RLC_FP_BYTES, 2 * RLC_FP_BYTES, a[1], 0);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int draw_legend(AVFilterContext *ctx, int samples)\n{\n    ShowSpectrumContext *s = ctx->priv;\n    AVFilterLink *inlink = ctx->inputs[0];\n    AVFilterLink *outlink = ctx->outputs[0];\n    int ch, y, x = 0, sz = s->orientation == VERTICAL ? s->w : s->h;\n    int multi = (s->mode == SEPARATE && s->color_mode == CHANNEL);\n    float spp = samples / (float)sz;\n    char *text;\n    uint8_t *dst;\n    char chlayout_str[128];",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int draw_legend(AVFilterContext *ctx, uint64_t samples)\n{\n    ShowSpectrumContext *s = ctx->priv;\n    AVFilterLink *inlink = ctx->inputs[0];\n    AVFilterLink *outlink = ctx->outputs[0];\n    int ch, y, x = 0, sz = s->orientation == VERTICAL ? s->w : s->h;\n    int multi = (s->mode == SEPARATE && s->color_mode == CHANNEL);\n    float spp = samples / (float)sz;\n    char *text;\n    uint8_t *dst;\n    char chlayout_str[128];",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void pdf_get_version(FILE *fp, pdf_t *pdf)\n{\n    char *header, *c;\n\n    header = get_header(fp);\n\n    /* Locate version string start and make sure we dont go past header */\n    if ((c = strstr(header, \"%PDF-\")) && \n        (c + strlen(\"%PDF-M.m\") + 2))\n    {\n        pdf->pdf_major_version = atoi(c + strlen(\"%PDF-\"));\n        pdf->pdf_minor_version = atoi(c + strlen(\"%PDF-M.\"));\n    }\n\n    free(header);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void pdf_get_version(FILE *fp, pdf_t *pdf)\n{\n    char *header = get_header(fp);\n\n    /* Locate version string start and make sure we dont go past header\n     * The format is %PDF-M.m, where 'M' is the major number and 'm' minor.\n     */\n    const char *c;\n    if ((c = strstr(header, \"%PDF-\")) && \n        ((c + 6)[0] == '.') && // Separator\n        isdigit((c + 5)[0]) && // Major number\n        isdigit((c + 7)[0]))   // Minor number\n    {\n        pdf->pdf_major_version = atoi(c + strlen(\"%PDF-\"));\n        pdf->pdf_minor_version = atoi(c + strlen(\"%PDF-M.\"));\n    }\n\n    free(header);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t    parser.inifile.setDirty();\n\telse if (value->isString () && value->asString()->value() == \"clean\")\n\t    parser.inifile.clean ();\n\tif (0 != parser.write ())\n\t    b = false;\n\tok = true;\n    }\n    else\n    {\n\tif (( parser.repeatNames () && value->isList ()) ||\n\t    (!parser.repeatNames () &&  (value->isString () || value->isInteger())) ||\n\t    path->component_str(0) == \"all\"\n\t    )\n\t    {\n\t\tok = true;\n\t\tif (parser.inifile.Write (path, value, parser.HaveRewrites ()))\n\t\t    b = false;\n\t    }\n        else if (value->isVoid ())\n\t    {\n\t\tint wb  = -1;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t    parser.inifile.setDirty();\n\telse if (value->isString () && value->asString()->value() == \"clean\")\n\t    parser.inifile.clean ();\n\tif (0 != parser.write ())\n\t    b = false;\n\tok = true;\n    }\n    else\n    {\n\tif (( parser.repeatNames () && value->isList ()) ||\n\t    (!parser.repeatNames () &&  (value->isString () || value->isBoolean() || value->isInteger())) ||\n\t    path->component_str(0) == \"all\"\n\t    )\n\t    {\n\t\tok = true;\n\t\tif (parser.inifile.Write (path, value, parser.HaveRewrites ()))\n\t\t    b = false;\n\t    }\n        else if (value->isVoid ())\n\t    {\n\t\tint wb  = -1;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "wb_prep(netdissect_options *ndo,\n        const struct pkt_prep *prep, u_int len)\n{\n\tint n;\n\tconst struct pgstate *ps;\n\tconst u_char *ep = ndo->ndo_snapend;\n\n\tND_PRINT((ndo, \" wb-prep:\"));\n\tif (len < sizeof(*prep)) {\n\t\treturn (-1);\n\t}\n\tn = EXTRACT_32BITS(&prep->pp_n);\n\tps = (const struct pgstate *)(prep + 1);\n\twhile (--n >= 0 && ND_TTEST(*ps)) {\n\t\tconst struct id_off *io, *ie;\n\t\tchar c = '<';\n\n\t\tND_PRINT((ndo, \" %u/%s:%u\",\n\t\t    EXTRACT_32BITS(&ps->slot),\n\t\t    ipaddr_string(ndo, &ps->page.p_sid),\n\t\t    EXTRACT_32BITS(&ps->page.p_uid)));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "wb_prep(netdissect_options *ndo,\n        const struct pkt_prep *prep, u_int len)\n{\n\tint n;\n\tconst struct pgstate *ps;\n\tconst u_char *ep = ndo->ndo_snapend;\n\n\tND_PRINT((ndo, \" wb-prep:\"));\n\tif (len < sizeof(*prep) || !ND_TTEST(*prep))\n\t\treturn (-1);\n\tn = EXTRACT_32BITS(&prep->pp_n);\n\tps = (const struct pgstate *)(prep + 1);\n\twhile (--n >= 0 && ND_TTEST(*ps)) {\n\t\tconst struct id_off *io, *ie;\n\t\tchar c = '<';\n\n\t\tND_PRINT((ndo, \" %u/%s:%u\",\n\t\t    EXTRACT_32BITS(&ps->slot),\n\t\t    ipaddr_string(ndo, &ps->page.p_sid),\n\t\t    EXTRACT_32BITS(&ps->page.p_uid)));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "x509stack_peek_level(struct cert_stack *stack)\n{\n\tstruct repo_level_node *repo = SLIST_FIRST(&stack->levels);\n\treturn (repo != NULL) ? repo->level : 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "x509stack_peek_level(struct cert_stack *stack)\n{\n\tstruct metadata_node *meta = SLIST_FIRST(&stack->metas);\n\treturn (meta != NULL) ? meta->level : 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "mptctl_getiocinfo (unsigned long arg, unsigned int data_size)\n{\n\tstruct mpt_ioctl_iocinfo __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_iocinfo *karg;\n\tMPT_ADAPTER\t\t*ioc;\n\tstruct pci_dev\t\t*pdev;\n\tint\t\t\tiocnum;\n\tunsigned int\t\tport;\n\tint\t\t\tcim_rev;\n\tstruct scsi_device \t*sdev;\n\tVirtDevice\t\t*vdevice;\n\n\t/* Add of PCI INFO results in unaligned access for\n\t * IA64 and Sparc. Reset long to int. Return no PCI\n\t * data for obsolete format.\n\t */\n\tif (data_size == sizeof(struct mpt_ioctl_iocinfo_rev0))\n\telse if (data_size == (sizeof(struct mpt_ioctl_iocinfo_rev0)+12))\n\t\tcim_rev = 0;\t/* obsolete */\n\telse\n\t\treturn -EFAULT;\n\n\tkarg = memdup_user(uarg, data_size);\n\tif (IS_ERR(karg)) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mpt_ioctl_iocinfo() - memdup_user returned error [%ld]\\n\",\n\t\t\t\t__FILE__, __LINE__, PTR_ERR(karg));\n\t\treturn PTR_ERR(karg);\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg->hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_getiocinfo() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\tkfree(karg);\n\t\treturn -ENODEV;\n\t}\n\n\t/* Verify the data transfer size is correct. */\n\tif (karg->hdr.maxDataSize != data_size) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_getiocinfo - \"\n\t\t\t\"Structure size mismatch. Command not completed.\\n\",\n\t\t\tioc->name, __FILE__, __LINE__);\n\t\tkfree(karg);\n\t\treturn -EFAULT;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "mptctl_getiocinfo (MPT_ADAPTER *ioc, unsigned long arg, unsigned int data_size)\n{\n\tstruct mpt_ioctl_iocinfo __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_iocinfo *karg;\n\tstruct pci_dev\t\t*pdev;\n\tunsigned int\t\tport;\n\tint\t\t\tcim_rev;\n\tstruct scsi_device \t*sdev;\n\tVirtDevice\t\t*vdevice;\n\n\t/* Add of PCI INFO results in unaligned access for\n\t * IA64 and Sparc. Reset long to int. Return no PCI\n\t * data for obsolete format.\n\t */\n\tif (data_size == sizeof(struct mpt_ioctl_iocinfo_rev0))\n\t\tcim_rev = 2;\n\telse if (data_size == (sizeof(struct mpt_ioctl_iocinfo_rev0)+12))\n\t\tcim_rev = 0;\t/* obsolete */\n\telse\n\t\treturn -EFAULT;\n\n\tkarg = memdup_user(uarg, data_size);\n\tif (IS_ERR(karg)) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mpt_ioctl_iocinfo() - memdup_user returned error [%ld]\\n\",\n\t\t\t\t__FILE__, __LINE__, PTR_ERR(karg));\n\t\treturn PTR_ERR(karg);\n\t}\n\n\t/* Verify the data transfer size is correct. */\n\tif (karg->hdr.maxDataSize != data_size) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_getiocinfo - \"\n\t\t\t\"Structure size mismatch. Command not completed.\\n\",\n\t\t\tioc->name, __FILE__, __LINE__);\n\t\tkfree(karg);\n\t\treturn -EFAULT;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain == 0) {\n\t\t\t/* 2.0.34: EOF is incorrect. We use 0 for\n\t\t\t * errors and EOF, just like fileGetbuf,\n\t\t\t * which is a simple fread() wrapper.\n\t\t\t * TBB. Original bug report: Daniel Cowgill. */\n\t\t\treturn 0; /* NOT EOF */\n\t\t}\n\n\t\trlen = remain;\n\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain <= 0) {\n\t\t\t/* 2.0.34: EOF is incorrect. We use 0 for\n\t\t\t * errors and EOF, just like fileGetbuf,\n\t\t\t * which is a simple fread() wrapper.\n\t\t\t * TBB. Original bug report: Daniel Cowgill. */\n\t\t\treturn 0; /* NOT EOF */\n\t\t}\n\n\t\trlen = remain;\n\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct oabi_flock64 user;\n\tstruct flock64 kernel;\n\tmm_segment_t fs = USER_DS; /* initialized to kill a warning */\n\tunsigned long local_arg = arg;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase F_OFD_GETLK:\n\tcase F_OFD_SETLK:\n\tcase F_OFD_SETLKW:\n\tcase F_GETLK64:\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n\t\t\t\t   sizeof(user)))\n\t\t\treturn -EFAULT;\n\t\tkernel.l_type\t= user.l_type;\n\t\tkernel.l_whence\t= user.l_whence;\n\t\tkernel.l_start\t= user.l_start;\n\t\tkernel.l_len\t= user.l_len;\n\t\tkernel.l_pid\t= user.l_pid;\n\t\tlocal_arg = (unsigned long)&kernel;\n\t\tfs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t}\n\n\tret = sys_fcntl64(fd, cmd, local_arg);\n\n\tswitch (cmd) {\n\tcase F_GETLK64:\n\t\tif (!ret) {\n\t\t\tuser.l_type\t= kernel.l_type;\n\t\t\tuser.l_whence\t= kernel.l_whence;\n\t\t\tuser.l_start\t= kernel.l_start;\n\t\t\tuser.l_len\t= kernel.l_len;\n\t\t\tuser.l_pid\t= kernel.l_pid;\n\t\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n\t\t\t\t\t &user, sizeof(user)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\tset_fs(fs);\n\t}\n\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase F_OFD_GETLK:\n\tcase F_OFD_SETLK:\n\tcase F_OFD_SETLKW:\n\tcase F_GETLK64:\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\treturn do_locks(fd, cmd, arg);\n\n\tdefault:\n\t\treturn sys_fcntl64(fd, cmd, arg);\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t    c = (struct sudo_command *)m->name;\n\t    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,\n\t\t    info, &c->digests))\n\t\tmatched = negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\tTAILQ_FOREACH_REVERSE(m, &a->members, member_list, entries) {\n\t\t    matched = cmnd_matches_all(parse_tree, m, runchroot, info);\n\t\t    if (matched != UNSPEC) {\n\t\t\tif (negated)\n\t\t\t    matched = matched == ALLOW ? DENY : ALLOW;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t    }\n\t    break;\n    }\n    debug_return_int(matched);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t    c = (struct sudo_command *)m->name;\n\t    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,\n\t\t    info, &c->digests))\n\t\tmatched = negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\tTAILQ_FOREACH_REVERSE(m, &a->members, member_list, entries) {\n\t\t    matched = cmnd_matches_all(parse_tree, m, runchroot, info);\n\t\t    if (SPECIFIED(matched)) {\n\t\t\tif (negated)\n\t\t\t    matched = matched == ALLOW ? DENY : ALLOW;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t    }\n\t    break;\n    }\n    debug_return_int(matched);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "R_API int r_socket_ready(RSocket *s, int secs, int usecs) {\n#if __UNIX__\n\t//int msecs = (1000 * secs) + (usecs / 1000);\n\tint msecs = (usecs / 1000);\n\tstruct pollfd fds[1];\n\tfds[0].fd = s->fd;\n\tfds[0].events = POLLIN | POLLPRI;\n\tfds[0].revents = POLLNVAL | POLLHUP | POLLERR;\n\treturn poll ((struct pollfd *)&fds, 1, msecs);\n#elif __WINDOWS__\n\tfd_set rfds;\n\tstruct timeval tv;\n\tif (s->fd == R_INVALID_SOCKET) {\n\t\treturn -1;\n\t}\n\tFD_ZERO (&rfds);\n\tFD_SET (s->fd, &rfds);\n\ttv.tv_sec = secs;\n\ttv.tv_usec = usecs;\n\treturn select (s->fd + 1, &rfds, NULL, NULL, &tv);\n#else\n\treturn true; /* always ready if unknown */\n#endif\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "R_API int r_socket_ready(RSocket *s, int secs, int usecs) {\n\tfd_set rfds;\n\tstruct timeval tv = {secs, usecs};\n\tif (s->fd == R_INVALID_SOCKET) {\n\t\treturn -1;\n\t}\n\tFD_ZERO (&rfds);\n\tFD_SET (s->fd, &rfds);\n\treturn select (s->fd + 1, &rfds, NULL, NULL, &tv);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void rose_start_hbtimer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tdel_timer(&rose->timer);\n\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->hb;\n\n\tadd_timer(&rose->timer);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void rose_start_hbtimer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tsk_stop_timer(sk, &rose->timer);\n\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->hb;\n\n\tsk_reset_timer(sk, &rose->timer, rose->timer.expires);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    int chunk_size;\n    unsigned char opcode;\n    int n_blocks;\n    unsigned short colorA = 0, colorB;\n    unsigned short color4[4];\n    unsigned char index, idx;\n    unsigned short ta, tb;\n    unsigned short *pixels = (unsigned short *)s->frame.data[0];\n\n    int row_ptr = 0;\n    int pixel_ptr = 0;\n    int block_ptr;\n    int pixel_x, pixel_y;\n    int total_blocks;\n\n    /* First byte is always 0xe1. Warn if it's different */\n    if (s->buf[stream_ptr] != 0xe1)\n        av_log(s->avctx, AV_LOG_ERROR, \"First chunk byte is 0x%02x instead of 0xe1\\n\",\n            s->buf[stream_ptr]);\n\n    /* Get chunk size, ingnoring first byte */\n        case 0x80:\n            while (n_blocks--) {\n              ADVANCE_BLOCK();\n            }\n            break;\n\n        /* Fill blocks with one color */\n        case 0xa0:\n            colorA = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n            while (n_blocks--) {\n                block_ptr = row_ptr + pixel_ptr;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        pixels[block_ptr] = colorA;\n                        block_ptr++;\n                    }\n                    block_ptr += row_inc;\n                }\n                ADVANCE_BLOCK();\n            }\n            break;\n\n        /* Fill blocks with 4 colors */\n        case 0xc0:\n            colorA = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n        case 0x20:\n            colorB = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n            color4[2] |= ((21 * ta + 11 * tb) >> 5) << 5;\n\n            /* blue components */\n            ta = colorA & 0x1F;\n            tb = colorB & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5);\n            color4[2] |= ((21 * ta + 11 * tb) >> 5);\n\n            if (s->size - stream_ptr < n_blocks * 4)\n                return;\n            while (n_blocks--) {\n                block_ptr = row_ptr + pixel_ptr;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    index = s->buf[stream_ptr++];\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        idx = (index >> (2 * (3 - pixel_x))) & 0x03;\n                        pixels[block_ptr] = color4[idx];\n                        block_ptr++;\n                    }\n                    block_ptr += row_inc;\n                }\n                ADVANCE_BLOCK();\n            }\n            break;\n\n        /* Fill block with 16 colors */\n        case 0x00:\n            if (s->size - stream_ptr < 16)\n                return;\n            block_ptr = row_ptr + pixel_ptr;\n            for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                    /* We already have color of upper left pixel */\n                    if ((pixel_y != 0) || (pixel_x !=0)) {\n                        colorA = AV_RB16 (&s->buf[stream_ptr]);\n                        stream_ptr += 2;\n                    }\n                    pixels[block_ptr] = colorA;\n                    block_ptr++;\n                }\n                block_ptr += row_inc;\n            }\n            ADVANCE_BLOCK();\n            break;\n\n        /* Unknown opcode */\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Unknown opcode %d in rpza chunk.\"\n                 \" Skip remaining %d bytes of chunk data.\\n\", opcode,\n                 chunk_size - stream_ptr);\n            return;\n        } /* Opcode switch */\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    int chunk_size;\n    unsigned char opcode;\n    int n_blocks;\n    unsigned short colorA = 0, colorB;\n    unsigned short color4[4];\n    unsigned char index, idx;\n    unsigned short ta, tb;\n    unsigned short *pixels = (unsigned short *)s->frame.data[0];\n\n    int row_ptr = 0;\n    int pixel_ptr = -4;\n    int block_ptr;\n    int pixel_x, pixel_y;\n    int total_blocks;\n\n    /* First byte is always 0xe1. Warn if it's different */\n    if (s->buf[stream_ptr] != 0xe1)\n        av_log(s->avctx, AV_LOG_ERROR, \"First chunk byte is 0x%02x instead of 0xe1\\n\",\n            s->buf[stream_ptr]);\n\n    /* Get chunk size, ingnoring first byte */\n            while (n_blocks--) {\n              ADVANCE_BLOCK();\n            }\n            break;\n\n        /* Fill blocks with one color */\n        case 0xa0:\n            colorA = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n            while (n_blocks--) {\n                ADVANCE_BLOCK()\n                block_ptr = row_ptr + pixel_ptr;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        pixels[block_ptr] = colorA;\n                        block_ptr++;\n                    }\n                    block_ptr += row_inc;\n                }\n            }\n            break;\n\n        /* Fill blocks with 4 colors */\n        case 0xc0:\n            colorA = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n        case 0x20:\n            colorB = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n\n            /* blue components */\n            ta = colorA & 0x1F;\n            tb = colorB & 0x1F;\n            color4[1] |= ((11 * ta + 21 * tb) >> 5);\n            color4[2] |= ((21 * ta + 11 * tb) >> 5);\n\n            if (s->size - stream_ptr < n_blocks * 4)\n                return;\n            while (n_blocks--) {\n                ADVANCE_BLOCK();\n                block_ptr = row_ptr + pixel_ptr;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    index = s->buf[stream_ptr++];\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        idx = (index >> (2 * (3 - pixel_x))) & 0x03;\n                        pixels[block_ptr] = color4[idx];\n                        block_ptr++;\n                    }\n                    block_ptr += row_inc;\n                }\n            }\n            break;\n\n        /* Fill block with 16 colors */\n        case 0x00:\n            if (s->size - stream_ptr < 16)\n                return;\n            ADVANCE_BLOCK();\n            block_ptr = row_ptr + pixel_ptr;\n            for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                    /* We already have color of upper left pixel */\n                    if ((pixel_y != 0) || (pixel_x !=0)) {\n                        colorA = AV_RB16 (&s->buf[stream_ptr]);\n                        stream_ptr += 2;\n                    }\n                    pixels[block_ptr] = colorA;\n                    block_ptr++;\n                }\n                block_ptr += row_inc;\n            }\n            break;\n\n        /* Unknown opcode */\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Unknown opcode %d in rpza chunk.\"\n                 \" Skip remaining %d bytes of chunk data.\\n\", opcode,\n                 chunk_size - stream_ptr);\n            return;\n        } /* Opcode switch */\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tint flow_controlled = 0;\n\tint nr_sig = 0;\n\n\tBUG_ON(off % RDS_FRAG_SIZE);\n\tBUG_ON(hdr_off != 0 && hdr_off != sizeof(struct rds_header));\n\n\t/* Do not send cong updates to IB loopback */\n\tif (conn->c_loopback\n\t    && rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\treturn sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;\n\t}\n\n\t/* FIXME we may overallocate here */\n\tif (be32_to_cpu(rm->m_inc.i_hdr.h_len) == 0)\n\t\ti = 1;\n\telse\n\t\ti = ceil(be32_to_cpu(rm->m_inc.i_hdr.h_len), RDS_FRAG_SIZE);\n\n\twork_alloc = rds_ib_ring_alloc(&ic->i_send_ring, i, &pos);\n\tif (work_alloc == 0) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tint flow_controlled = 0;\n\tint nr_sig = 0;\n\n\tBUG_ON(off % RDS_FRAG_SIZE);\n\tBUG_ON(hdr_off != 0 && hdr_off != sizeof(struct rds_header));\n\n\t/* Do not send cong updates to IB loopback */\n\tif (conn->c_loopback\n\t    && rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\tscat = &rm->data.op_sg[sg];\n\t\tret = sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;\n\t\tret = min_t(int, ret, scat->length - conn->c_xmit_data_off);\n\t\treturn ret;\n\t}\n\n\t/* FIXME we may overallocate here */\n\tif (be32_to_cpu(rm->m_inc.i_hdr.h_len) == 0)\n\t\ti = 1;\n\telse\n\t\ti = ceil(be32_to_cpu(rm->m_inc.i_hdr.h_len), RDS_FRAG_SIZE);\n\n\twork_alloc = rds_ib_ring_alloc(&ic->i_send_ring, i, &pos);\n\tif (work_alloc == 0) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tcase COMMAND:\n\t    c = (struct sudo_command *)m->name;\n\t    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,\n\t\t    info, &c->digests))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\trc = cmndlist_matches(parse_tree, &a->members, runchroot, info);\n\t\tif (rc != UNSPEC) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t    }\n\t    break;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tcase COMMAND:\n\t    c = (struct sudo_command *)m->name;\n\t    if (command_matches(parse_tree->ctx, c->cmnd, c->args, runchroot,\n\t\t    info, &c->digests))\n\t\tmatched = m->negated ? DENY : ALLOW;\n\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\trc = cmndlist_matches(parse_tree, &a->members, runchroot, info);\n\t\tif (SPECIFIED(rc)) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }\n\t\t}\n\t\talias_put(a);\n\t    }\n\t    break;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "escapes(cp, tp)\nconst char\t*cp;\nchar *tp;\n{\n    while (*cp) {\n\tint\tcval = 0, meta = 0;\n\n\tif (*cp == '\\\\' && cp[1] && index(\"mM\", cp[1]) && cp[2]) {\n\t\tmeta = 1;\n\t\tcp += 2;\n\t}\n\tif (*cp == '\\\\' && cp[1] && index(\"0123456789xXoO\", cp[1]) && cp[2]) {\n\t    NEARDATA const char hex[] = \"00112233445566778899aAbBcCdDeEfF\";\n\t    const char *dp;\n\t    int dcount = 0;\n\n\t    cp++;\n\t    if (*cp == 'x' || *cp == 'X')\n\t\tfor (++cp; *cp && (dp = index(hex, *cp)) && (dcount++ < 2); cp++)\n\t\t    cval = (cval * 16) + ((int)(dp - hex) / 2);\n\t    else if (*cp == 'o' || *cp == 'O')\n\t\tfor (++cp; *cp && (index(\"01234567\",*cp)) && (dcount++ < 3); cp++)\n\t\t    cval = (cval * 8) + (*cp - '0');\n\t    else\n\t\tfor (; *cp && (index(\"0123456789\",*cp)) && (dcount++ < 3); cp++)\n\t\t    cval = (cval * 10) + (*cp - '0');\n\t} else if (*cp == '\\\\' && cp[1]) {\t/* C-style character escapes */\n\t    switch (*++cp) {\n\t    case '\\\\': cval = '\\\\'; break;\n\t    case 'n': cval = '\\n'; break;\n\t    case 't': cval = '\\t'; break;\n\t    case 'b': cval = '\\b'; break;\n\t    case 'r': cval = '\\r'; break;\n\t    default: cval = *cp;\n\t    }\n\t    cp++;\n\t} else if (*cp == '^' && cp[1]) { /* expand control-character syntax */\n\t    cval = (*++cp & 0x1f);\n\t    cp++;\n\t} else\n\t    cval = *cp++;\n\n\tif (meta)\n\t    cval |= 0x80;\n\t*tp++ = cval;\n    }\n    *tp = '\\0';\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "escapes(cp, tp)\nconst char\t*cp;\nchar *tp;\n{\n    static NEARDATA const char\n\toct[] = \"01234567\", dec[] = \"0123456789\",\n\thex[] = \"00112233445566778899aAbBcCdDeEfF\";\n    const char *dp;\n    int cval, meta, dcount;\n\n    while (*cp) {\n\t/* \\M has to be followed by something to do meta conversion,\n\t   otherwise it will just be \\M which ultimately yields 'M' */\n\tmeta = (*cp == '\\\\' && (cp[1] == 'm' || cp[1] == 'M') && cp[2]);\n\tif (meta) cp += 2;\n\n\tcval = dcount = 0; /* for decimal, octal, hexadecimal cases */\n\tif ((*cp != '\\\\' && *cp != '^') || !cp[1]) {\n\t    /* simple character, or nothing left for \\ or ^ to escape */\n\t    cval = *cp++;\n\t} else if (*cp == '^') {\t/* expand control-character syntax */\n\t    cval = (*++cp & 0x1f);\n\t    ++cp;\n\t/* remaining cases are all for backslash and we know cp[1] is not \\0 */\n\t} else if (index(dec, cp[1])) {\n\t    ++cp;\t/* move past backslash to first digit */\n\t    do {\n\t\tcval = (cval * 10) + (*cp - '0');\n\t    } while (*++cp && index(dec, *cp) && ++dcount < 3);\n\t} else if ((cp[1] == 'o' || cp[1] == 'O') &&\n\t\tcp[2] && index(oct, cp[2])) {\n\t    cp += 2;\t/* move past backslash and 'O' */\n\t    do {\n\t\tcval = (cval * 8) + (*cp - '0');\n\t    } while (*++cp && index(oct, *cp) && ++dcount < 3);\n\t} else if ((cp[1] == 'x' || cp[1] == 'X') &&\n\t\tcp[2] && (dp = index(hex, cp[2])) != 0) {\n\t    cp += 2;\t/* move past backslash and 'X' */\n\t    do {\n\t\tcval = (cval * 16) + ((int)(dp - hex) / 2);\n\t    } while (*++cp && (dp = index(hex, *cp)) != 0 && ++dcount < 2);\n\t} else {\t\t\t/* C-style character escapes */\n\t    switch (*++cp) {\n\t    case '\\\\': cval = '\\\\'; break;\n\t    case 'n': cval = '\\n'; break;\n\t    case 't': cval = '\\t'; break;\n\t    case 'b': cval = '\\b'; break;\n\t    case 'r': cval = '\\r'; break;\n\t    default: cval = *cp;\n\t    }\n\t    ++cp;\n\t}\n\n\tif (meta)\n\t    cval |= 0x80;\n\t*tp++ = (char)cval;\n    }\n    *tp = '\\0';\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static BOOL update_recv_primary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBOOL rc = FALSE;\n\trdpContext* context = update->context;\n\trdpPrimaryUpdate* primary = update->primary;\n\tORDER_INFO* orderInfo = &(primary->order_info);\n\trdpSettings* settings = context->settings;\n\tconst char* orderName;\n\n\tif (flags & ORDER_TYPE_CHANGE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t}\n\n\t\tStream_Read_UINT8(s, orderInfo->orderType); /* orderType (1 byte) */\n\t}\n\n\torderName = primary_order_string(orderInfo->orderType);\n\n\tif (!check_primary_order_supported(update->log, settings, orderInfo->orderType, orderName))\n\t\treturn FALSE;\n\n\tif (!update_read_field_flags(s, &(orderInfo->fieldFlags), flags,\n\t                             PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"update_read_field_flags() failed\");\n\t\treturn FALSE;\n\t}\n\n\tif (flags & ORDER_BOUNDS)\n\t{\n\t\tif (!(flags & ORDER_ZERO_BOUNDS_DELTAS))\n\t\t{\n\t\t\tif (!update_read_bounds(s, &orderInfo->bounds))",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static BOOL update_recv_primary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBYTE field;\n\tBOOL rc = FALSE;\n\trdpContext* context = update->context;\n\trdpPrimaryUpdate* primary = update->primary;\n\tORDER_INFO* orderInfo = &(primary->order_info);\n\trdpSettings* settings = context->settings;\n\tconst char* orderName;\n\n\tif (flags & ORDER_TYPE_CHANGE)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < 1)\n\t\t}\n\n\t\tStream_Read_UINT8(s, orderInfo->orderType); /* orderType (1 byte) */\n\t}\n\n\torderName = primary_order_string(orderInfo->orderType);\n\n\tif (!check_primary_order_supported(update->log, settings, orderInfo->orderType, orderName))\n\t\treturn FALSE;\n\n\tfield = get_primary_drawing_order_field_bytes(orderInfo->orderType, &rc);\n\tif (!rc)\n\t\treturn FALSE;\n\n\tif (!update_read_field_flags(s, &(orderInfo->fieldFlags), flags, field))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"update_read_field_flags() failed\");\n\t\treturn FALSE;\n\t}\n\n\tif (flags & ORDER_BOUNDS)\n\t{\n\t\tif (!(flags & ORDER_ZERO_BOUNDS_DELTAS))\n\t\t{\n\t\t\tif (!update_read_bounds(s, &orderInfo->bounds))",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    pos = xref->end;\n    fseek(fp, pos, SEEK_SET);\n    while (ftell(fp) != 0)\n      if (SAFE_F(fp, (fgetc(fp) == '/' && fgetc(fp) == 'S')))\n        break;\n      else\n        SAFE_E(fseek(fp, --pos, SEEK_SET), 0, \"Failed seek to xref /Size.\\n\");\n\n    SAFE_E(fread(buf, 1, 21, fp), 21, \"Failed to load entry Size string.\\n\");\n    xref->n_entries = atoi(buf + strlen(\"ize \"));\n    xref->entries = calloc(1, xref->n_entries * sizeof(struct _xref_entry));\n\n    /* Load entry data */\n    obj_id = 0;\n    fseek(fp, xref->start + strlen(\"xref\"), SEEK_SET);\n    added_entries = 0;\n    for (i=0; i<xref->n_entries; i++)\n    {\n        /* Advance past newlines. */\n        c = fgetc(fp);\n        while (c == '\\n' || c == '\\r')",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    pos = xref->end;\n    fseek(fp, pos, SEEK_SET);\n    while (ftell(fp) != 0)\n      if (SAFE_F(fp, (fgetc(fp) == '/' && fgetc(fp) == 'S')))\n        break;\n      else\n        SAFE_E(fseek(fp, --pos, SEEK_SET), 0, \"Failed seek to xref /Size.\\n\");\n\n    SAFE_E(fread(buf, 1, 21, fp), 21, \"Failed to load entry Size string.\\n\");\n    xref->n_entries = atoi(buf + strlen(\"ize \"));\n    xref->entries = safe_calloc(xref->n_entries * sizeof(struct _xref_entry));\n\n    /* Load entry data */\n    obj_id = 0;\n    fseek(fp, xref->start + strlen(\"xref\"), SEEK_SET);\n    added_entries = 0;\n    for (i=0; i<xref->n_entries; i++)\n    {\n        /* Advance past newlines. */\n        c = fgetc(fp);\n        while (c == '\\n' || c == '\\r')",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int _hostsock_getsockname(\n    oe_fd_t* sock_,\n    struct oe_sockaddr* addr,\n    oe_socklen_t* addrlen)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    oe_socklen_t addrlen_in = 0;\n\n    oe_errno = 0;\n\n    if (!sock)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (addrlen)\n        addrlen_in = *addrlen;\n\n    if (oe_syscall_getsockname_ocall(\n            &ret,\n            sock->host_fd,\n            (struct oe_sockaddr*)addr,\n            addrlen_in,\n            addrlen) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    return ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int _hostsock_getsockname(\n    oe_fd_t* sock_,\n    struct oe_sockaddr* addr,\n    oe_socklen_t* addrlen)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    oe_socklen_t addrlen_in = 0;\n    oe_socklen_t addrlen_out = 0;\n\n    oe_errno = 0;\n\n    if (!sock || !addr || !addrlen)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    addrlen_in = *addrlen;\n    if (addrlen_in < 0)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_getsockname_ocall(\n            &ret, sock->host_fd, addr, addrlen_in, &addrlen_out) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /*\n     * Error out the case if the addrlen_out is greater than the size\n     * of sockaddr_storage.\n     */\n    if (addrlen_out > sizeof(struct oe_sockaddr_storage))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * Note that the returned value can still exceed the supplied one, which\n     * indicates a truncation. Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html\n     * for more detail.\n     */\n    if (addrlen_in >= addrlen_out)\n        *addrlen = addrlen_out;\n\ndone:\n\n    return ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "lldp_private_8021_print(netdissect_options *ndo,\n                        const u_char *tptr, u_int tlv_len)\n{\n    int subtype, hexdump = FALSE;\n    u_int sublen;\n    u_int tval;\n    uint8_t i;\n\n    if (tlv_len < 4) {\n        return hexdump;\n    }\n    subtype = *(tptr+3);\n\n    ND_PRINT((ndo, \"\\n\\t  %s Subtype (%u)\",\n           tok2str(lldp_8021_subtype_values, \"unknown\", subtype),\n           subtype));\n\n        }\n        /*  Length of Application Priority Table */\n        sublen=tlv_len-5;\n        if(sublen%3!=0){\n        \treturn hexdump;\n        }\n        i=0;\n        ND_PRINT((ndo, \"\\n\\t    Application Priority Table\"));\n        while(i<sublen) {\n        \ttval=*(tptr+i+5);\n        \tND_PRINT((ndo, \"\\n\\t      Priority: %d, RES: %d, Sel: %d\",\n        \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07)));\n        \tND_PRINT((ndo, \"Protocol ID: %d\", EXTRACT_16BITS(tptr + i + 5)));\n        \ti=i+3;\n        }\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_EVB:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH){\n        \treturn hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    EVB Bridge Status\"));\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t      RES: %d, BGID: %d, RRCAP: %d, RRCTR: %d\",",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "lldp_private_8021_print(netdissect_options *ndo,\n                        const u_char *tptr, u_int tlv_len)\n{\n    int subtype, hexdump = FALSE;\n    u_int sublen;\n    u_int tval;\n    u_int i;\n\n    if (tlv_len < 4) {\n        return hexdump;\n    }\n    subtype = *(tptr+3);\n\n    ND_PRINT((ndo, \"\\n\\t  %s Subtype (%u)\",\n           tok2str(lldp_8021_subtype_values, \"unknown\", subtype),\n           subtype));\n\n        }\n        /*  Length of Application Priority Table */\n        sublen=tlv_len-5;\n        if(sublen%3!=0){\n        \treturn hexdump;\n        }\n        i=0;\n        ND_PRINT((ndo, \"\\n\\t    Application Priority Table\"));\n        while(i<sublen) {\n        \ttval=*(tptr+i+5);\n        \tND_PRINT((ndo, \"\\n\\t      Priority: %u, RES: %u, Sel: %u, Protocol ID: %u\",\n        \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07),\n        \t\t EXTRACT_16BITS(tptr + i + 5)));\n        \ti=i+3;\n        }\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_EVB:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH){\n        \treturn hexdump;\n        }\n        ND_PRINT((ndo, \"\\n\\t    EVB Bridge Status\"));\n        tval=*(tptr+4);\n        ND_PRINT((ndo, \"\\n\\t      RES: %d, BGID: %d, RRCAP: %d, RRCTR: %d\",",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->MaxLen < 1)\n\t\tfields->MaxLen = fields->Len;\n\n\tStream_Write_UINT16(s, fields->Len); /* Len (2 bytes) */\n\tStream_Write_UINT16(s, fields->MaxLen); /* MaxLen (2 bytes) */\n\tStream_Write_UINT32(s, fields->BufferOffset); /* BufferOffset (4 bytes) */\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->MaxLen < 1)\n\t\tfields->MaxLen = fields->Len;\n\n\tStream_Write_UINT16(s, fields->Len); /* Len (2 bytes) */\n\tStream_Write_UINT16(s, fields->MaxLen); /* MaxLen (2 bytes) */\n\tStream_Write_UINT32(s, fields->BufferOffset); /* BufferOffset (4 bytes) */\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n\n\t\tif (dest == NULL) {\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t*charsRequired = 0;\n\t} else {\n\t\tmaxChars--;\n\t}\n\n\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tint keyRequiredChars;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tint valueRequiredChars;\n\n\t\tif ((keyLen >= INT_MAX / worstCase) || (valueLen >= INT_MAX / worstCase)) {\n\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t}\n\t\tkeyRequiredChars = worstCase * keyLen;\n\t\tvalueRequiredChars = worstCase * valueLen;\n\n\t\tif (dest == NULL) {\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);\n\n\t\t\tif (firstItem == URI_TRUE) {\n\t\t\t\tampersandLen = 1;\n\t\t\t\tfirstItem = URI_FALSE;\n\t\t\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    const GPUDevice& device = context->eigen_device<GPUDevice>();\n    const Tindex N = reverse_index_map.dimension(0);\n    const Tindex N_full = grad_values.dimension(0);\n\n    Tensor visited_t;\n    TF_RETURN_IF_ERROR(\n        context->allocate_temp(DT_BOOL, TensorShape({N_full}), &visited_t));\n    auto visited = visited_t.vec<bool>();\n    visited.device(device) = visited.constant(false);\n\n    TF_RETURN_IF_ERROR(wrap_kernel_call(\n        GatherOriginalGradValuesKernel<T, Tindex>, /*device=*/device,\n        /*size=*/N, reverse_index_map, grad_values, d_values, visited));\n\n    // Now we mask out the visited values and sum the remaining ones (which\n    // correspond to the empty rows in the forward input) to compute\n    // d_default_value.\n\n    gpuprim::CountingInputIterator<Tindex, Tindex> counting_iterator(Tindex(0));\n    ZeroMaskedValues<T, Tindex> mask_values_fn(visited.data(),\n                                               grad_values.data());\n    gpuprim::TransformInputIterator<T, decltype(mask_values_fn),\n                                    decltype(counting_iterator), Tindex>",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    const GPUDevice& device = context->eigen_device<GPUDevice>();\n    const Tindex N = reverse_index_map.dimension(0);\n    const Tindex N_full = grad_values.dimension(0);\n\n    Tensor visited_t;\n    TF_RETURN_IF_ERROR(\n        context->allocate_temp(DT_BOOL, TensorShape({N_full}), &visited_t));\n    auto visited = visited_t.vec<bool>();\n    visited.device(device) = visited.constant(false);\n\n    if (N > 0) {\n      TF_RETURN_IF_ERROR(wrap_kernel_call(\n          GatherOriginalGradValuesKernel<T, Tindex>, /*device=*/device,\n          /*size=*/N, reverse_index_map, grad_values, d_values, visited));\n    }\n\n    // Now we mask out the visited values and sum the remaining ones (which\n    // correspond to the empty rows in the forward input) to compute\n    // d_default_value.\n\n    gpuprim::CountingInputIterator<Tindex, Tindex> counting_iterator(Tindex(0));\n    ZeroMaskedValues<T, Tindex> mask_values_fn(visited.data(),\n                                               grad_values.data());\n    gpuprim::TransformInputIterator<T, decltype(mask_values_fn),\n                                    decltype(counting_iterator), Tindex>",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\treturn;\n\t\t}\n\t\tneigh->flags |= NTF_ROUTER;\n\t} else if (rt) {\n\t\trt->rt6i_flags = (rt->rt6i_flags & ~RTF_PREF_MASK) | RTF_PREF(pref);\n\t}\n\n\tif (rt)\n\t\trt6_set_expires(rt, jiffies + (HZ * lifetime));\n\tif (ra_msg->icmph.icmp6_hop_limit) {\n\t\tin6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit;\n\t\tif (rt)\n\t\t\tdst_metric_set(&rt->dst, RTAX_HOPLIMIT,\n\t\t\t\t       ra_msg->icmph.icmp6_hop_limit);\n\t}\n\nskip_defrtr:\n\n\t/*\n\t *\tUpdate Reachable Time and Retrans Timer\n\t */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\treturn;\n\t\t}\n\t\tneigh->flags |= NTF_ROUTER;\n\t} else if (rt) {\n\t\trt->rt6i_flags = (rt->rt6i_flags & ~RTF_PREF_MASK) | RTF_PREF(pref);\n\t}\n\n\tif (rt)\n\t\trt6_set_expires(rt, jiffies + (HZ * lifetime));\n\tif (ra_msg->icmph.icmp6_hop_limit) {\n\t\t/* Only set hop_limit on the interface if it is higher than\n\t\t * the current hop_limit.\n\t\t */\n\t\tif (in6_dev->cnf.hop_limit < ra_msg->icmph.icmp6_hop_limit) {\n\t\t\tin6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit;\n\t\t} else {\n\t\t\tND_PRINTK(2, warn, \"RA: Got route advertisement with lower hop_limit than current\\n\");\n\t\t}\n\t\tif (rt)\n\t\t\tdst_metric_set(&rt->dst, RTAX_HOPLIMIT,\n\t\t\t\t       ra_msg->icmph.icmp6_hop_limit);\n\t}\n\nskip_defrtr:\n\n\t/*\n\t *\tUpdate Reachable Time and Retrans Timer\n\t */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_function, void* exec_payload, lxc_attach_options_t* options, pid_t* attached_process)\n{\n\tint ret, status;\n\tpid_t init_pid, pid, attached_pid, expected;\n\tstruct lxc_proc_context_info *init_ctx;\n\tchar* cwd;\n\tchar* new_cwd;\n\tint ipc_sockets[2];\n\tint procfd;\n\tsigned long personality;\n\n\tif (!options)\n\t\toptions = &attach_static_default_options;\n\n\tinit_pid = lxc_cmd_get_init_pid(name, lxcpath);\n\tif (init_pid < 0) {\n\t\tERROR(\"failed to get the init pid\");\n\t\treturn -1;\n\t}\n\t *\n\t * IPC mechanism: (X is receiver)\n\t *   initial process        intermediate          attached\n\t *        X           <---  send pid of\n\t *                          attached proc,\n\t *                          then exit\n\t *    send 0 ------------------------------------>    X\n\t *                                              [do initialization]\n\t *        X  <------------------------------------  send 1\n\t *   [add to cgroup, ...]\n\t *    send 2 ------------------------------------>    X\n\t *   close socket                                 close socket\n\t *                                                run program\n\t */\n\tret = socketpair(PF_LOCAL, SOCK_STREAM | SOCK_CLOEXEC, 0, ipc_sockets);\n\tif (ret < 0) {\n\t\tSYSERROR(\"could not set up required IPC mechanism for attaching\");\n\t\tfree(cwd);\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\t */\n\tpid = fork();\n\n\tif (pid < 0) {\n\t\tSYSERROR(\"failed to create first subprocess\");\n\t\tfree(cwd);\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\n\tif (pid) {\n\t\tpid_t to_cleanup_pid = pid;\n\n\t\t/* initial thread, we close the socket that is for the\n\t\t * subprocesses\n\t\t */\n\t\tclose(ipc_sockets[1]);\n\t\tfree(cwd);\n\n\t\t/* attach to cgroup, if requested */\n\t\tif (options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) {\n\t\t\tif (!cgroup_attach(name, lxcpath, pid))\n\t\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* Let the child process know to go ahead */\n\t\tstatus = 0;\n\t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"error using IPC to notify attached process for initialization (0)\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* get pid from intermediate process */\n\t\tret = lxc_read_nointr_expect(ipc_sockets[0], &attached_pid, sizeof(attached_pid), NULL);\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"error using IPC to notify attached process for initialization (0)\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* wait for the attached process to finish initializing */\n\t\texpected = 1;\n\t\tret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);\n\t\tif (ret <= 0) {\n\t\t\tif (ret != 0)\n\t\t\t\tERROR(\"error using IPC to receive notification from attached process (1)\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* tell attached process we're done */\n\t\tstatus = 2;\n\t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"error using IPC to notify attached process for initialization (2)\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* now shut down communication with child, we're done */\n\t\tshutdown(ipc_sockets[0], SHUT_RDWR);\n\t\tclose(ipc_sockets[0]);\n\t\tlxc_proc_put_context_info(init_ctx);\n\n\t\t/* we're done, the child process should now execute whatever\n\t\t * it is that the user requested. The parent can now track it\n\t\t * with waitpid() or similar.\n\t\t */\n\n\t\t*attached_process = attached_pid;\n\t\treturn 0;\n\n\tcleanup_error:\n\t\t/* first shut down the socket, then wait for the pid,\n\t\t * otherwise the pid we're waiting for may never exit\n\t\t */\n\t\tshutdown(ipc_sockets[0], SHUT_RDWR);\n\t\tclose(ipc_sockets[0]);\n\t\tif (to_cleanup_pid)\n\t\t\t(void) wait_for_pid(to_cleanup_pid);\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\n\t/* first subprocess begins here, we close the socket that is for the\n\t * initial thread\n\tstatus = -1;\n\tret = lxc_read_nointr_expect(ipc_sockets[1], &status, sizeof(status), &expected);\n\tif (ret <= 0) {\n\t\tERROR(\"error communicating with child process\");\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\tif ((options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) && cgns_supported())\n\t\toptions->namespaces |= CLONE_NEWCGROUP;\n\n\tprocfd = open(\"/proc\", O_DIRECTORY | O_RDONLY);\n\tif (procfd < 0) {\n\t\tSYSERROR(\"Unable to open /proc\");\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t/* attach now, create another subprocess later, since pid namespaces\n\t * only really affect the children of the current process\n\t */\n\tret = lxc_attach_to_ns(init_pid, options->namespaces);\n\tif (ret < 0) {\n\t\tERROR(\"failed to enter the namespace\");\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\tfree(cwd);\n\n\t/* now create the real child process */\n\t{\n\t\tstruct attach_clone_payload payload = {\n\t\t\t.ipc_socket = ipc_sockets[1],\n\t\t\t.options = options,\n\t\t\t.init_ctx = init_ctx,\n\t\t\t.exec_function = exec_function,\n\t\t\t.exec_payload = exec_payload,\n\t\t\t.procfd = procfd\n\t\t};\n\t\t/* We use clone_parent here to make this subprocess a direct child of\n\t\t * the initial process. Then this intermediate process can exit and\n\t\t * the parent can directly track the attached process.\n\t\t */\n\t\tpid = lxc_clone(attach_child_main, &payload, CLONE_PARENT);\n\t}\n\n\t/* shouldn't happen, clone() should always return positive pid */\n\tif (pid <= 0) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int lxc_attach(const char* name, const char* lxcpath, lxc_attach_exec_t exec_function, void* exec_payload, lxc_attach_options_t* options, pid_t* attached_process)\n{\n\tint ret, status;\n\tpid_t init_pid, pid, attached_pid, expected;\n\tstruct lxc_proc_context_info *init_ctx;\n\tchar* cwd;\n\tchar* new_cwd;\n\tint ipc_sockets[2];\n\tsigned long personality;\n\n\tif (!options)\n\t\toptions = &attach_static_default_options;\n\n\tinit_pid = lxc_cmd_get_init_pid(name, lxcpath);\n\tif (init_pid < 0) {\n\t\tERROR(\"failed to get the init pid\");\n\t\treturn -1;\n\t}\n\t * IPC mechanism: (X is receiver)\n\t *   initial process        intermediate          attached\n\t *        X           <---  send pid of\n\t *                          attached proc,\n\t *                          then exit\n\t *    send 0 ------------------------------------>    X\n\t *                                              [do initialization]\n\t *        X  <------------------------------------  send 1\n\t *   [add to cgroup, ...]\n\t *    send 2 ------------------------------------>    X\n\t *\t\t\t\t\t\t[set LXC_ATTACH_NO_NEW_PRIVS]\n\t *        X  <------------------------------------  send 3\n\t *   [open LSM label fd]\n\t *    send 4 ------------------------------------>    X\n\t *   \t\t\t\t\t\t[set LSM label]\n\t *   close socket                                 close socket\n\t *                                                run program\n\t */\n\tret = socketpair(PF_LOCAL, SOCK_STREAM | SOCK_CLOEXEC, 0, ipc_sockets);\n\tif (ret < 0) {\n\t\tSYSERROR(\"could not set up required IPC mechanism for attaching\");\n\t\tfree(cwd);\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\tpid = fork();\n\n\tif (pid < 0) {\n\t\tSYSERROR(\"failed to create first subprocess\");\n\t\tfree(cwd);\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\n\tif (pid) {\n\t\tint procfd = -1;\n\t\tpid_t to_cleanup_pid = pid;\n\n\t\t/* initial thread, we close the socket that is for the\n\t\t * subprocesses\n\t\t */\n\t\tclose(ipc_sockets[1]);\n\t\tfree(cwd);\n\n\t\t/* attach to cgroup, if requested */\n\t\tif (options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) {\n\t\t\tif (!cgroup_attach(name, lxcpath, pid))\n\t\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* Open /proc before setns() to the containers namespace so we\n\t\t * don't rely on any information from inside the container.\n\t\t */\n\t\tprocfd = open(\"/proc\", O_DIRECTORY | O_RDONLY | O_CLOEXEC);\n\t\tif (procfd < 0) {\n\t\t\tSYSERROR(\"Unable to open /proc.\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* Let the child process know to go ahead */\n\t\tstatus = 0;\n\t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"error using IPC to notify attached process for initialization (0)\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* get pid from intermediate process */\n\t\tret = lxc_read_nointr_expect(ipc_sockets[0], &attached_pid, sizeof(attached_pid), NULL);\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"error using IPC to notify attached process for initialization (0)\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* wait for the attached process to finish initializing */\n\t\texpected = 1;\n\t\tret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);\n\t\tif (ret <= 0) {\n\t\t\tif (ret != 0)\n\t\t\t\tERROR(\"error using IPC to receive notification \"\n\t\t\t\t      \"from attached process (1)\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* tell attached process we're done */\n\t\tstatus = 2;\n\t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"Error using IPC to notify attached process for \"\n\t\t\t      \"initialization (2): %s.\", strerror(errno));\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* Wait for the (grand)child to tell us that it's ready to set\n\t\t * up its LSM labels.\n\t\t */\n\t\texpected = 3;\n\t\tret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"Error using IPC for the child to tell us to open LSM fd (3): %s.\",\n\t\t\t      strerror(errno));\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t/* Open LSM fd and send it to child. */\n\t\tif ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {\n\t\t\tint on_exec, labelfd;\n\t\t\ton_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;\n\t\t\t/* Open fd for the LSM security module. */\n\t\t\tlabelfd = lsm_openat(procfd, attached_pid, on_exec);\n\t\t\tif (labelfd < 0)\n\t\t\t\tgoto cleanup_error;\n\n\t\t\t/* Send child fd of the LSM security module to write to. */\n\t\t\tret = lxc_abstract_unix_send_fd(ipc_sockets[0], labelfd, NULL, 0);\n\t\t\tif (ret <= 0) {\n\t\t\t\tERROR(\"Error using IPC to send child LSM fd (4): %s.\",\n\t\t\t\t\t\tstrerror(errno));\n\t\t\t\tgoto cleanup_error;\n\t\t\t}\n\t\t}\n\n\t\t/* now shut down communication with child, we're done */\n\t\tshutdown(ipc_sockets[0], SHUT_RDWR);\n\t\tclose(ipc_sockets[0]);\n\t\tlxc_proc_put_context_info(init_ctx);\n\n\t\t/* we're done, the child process should now execute whatever\n\t\t * it is that the user requested. The parent can now track it\n\t\t * with waitpid() or similar.\n\t\t */\n\n\t\t*attached_process = attached_pid;\n\t\treturn 0;\n\n\tcleanup_error:\n\t\t/* first shut down the socket, then wait for the pid,\n\t\t * otherwise the pid we're waiting for may never exit\n\t\t */\n\t\tif (procfd >= 0)\n\t\t\tclose(procfd);\n\t\tshutdown(ipc_sockets[0], SHUT_RDWR);\n\t\tclose(ipc_sockets[0]);\n\t\tif (to_cleanup_pid)\n\t\t\t(void) wait_for_pid(to_cleanup_pid);\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\n\t/* first subprocess begins here, we close the socket that is for the\n\t * initial thread\n\texpected = 0;\n\tstatus = -1;\n\tret = lxc_read_nointr_expect(ipc_sockets[1], &status, sizeof(status), &expected);\n\tif (ret <= 0) {\n\t\tERROR(\"error communicating with child process\");\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\tif ((options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) && cgns_supported())\n\t\toptions->namespaces |= CLONE_NEWCGROUP;\n\n\t/* attach now, create another subprocess later, since pid namespaces\n\t * only really affect the children of the current process\n\t */\n\tret = lxc_attach_to_ns(init_pid, options->namespaces);\n\tif (ret < 0) {\n\t\tERROR(\"failed to enter the namespace\");\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\t\tWARN(\"could not change directory to '%s'\", new_cwd);\n\tfree(cwd);\n\n\t/* now create the real child process */\n\t{\n\t\tstruct attach_clone_payload payload = {\n\t\t\t.ipc_socket = ipc_sockets[1],\n\t\t\t.options = options,\n\t\t\t.init_ctx = init_ctx,\n\t\t\t.exec_function = exec_function,\n\t\t\t.exec_payload = exec_payload,\n\t\t};\n\t\t/* We use clone_parent here to make this subprocess a direct child of\n\t\t * the initial process. Then this intermediate process can exit and\n\t\t * the parent can directly track the attached process.\n\t\t */\n\t\tpid = lxc_clone(attach_child_main, &payload, CLONE_PARENT);\n\t}\n\n\t/* shouldn't happen, clone() should always return positive pid */\n\tif (pid <= 0) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "sudo_auth_cleanup(const struct sudoers_context *ctx, struct passwd *pw,\n    bool force)\n{\n    sudo_auth *auth;\n    debug_decl(sudo_auth_cleanup, SUDOERS_DEBUG_AUTH);\n\n    /* Call cleanup routines. */\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->cleanup && !IS_DISABLED(auth)) {\n\t    int status = (auth->cleanup)(ctx, pw, auth, force);\n\t    if (status == AUTH_ERROR) {\n\t\t/* Assume error msg already printed. */\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(0);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "sudo_auth_cleanup(const struct sudoers_context *ctx, struct passwd *pw,\n    bool force)\n{\n    sudo_auth *auth;\n    debug_decl(sudo_auth_cleanup, SUDOERS_DEBUG_AUTH);\n\n    /* Call cleanup routines. */\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->cleanup && !IS_DISABLED(auth)) {\n\t    int status = (auth->cleanup)(ctx, pw, auth, force);\n\t    if (status != AUTH_SUCCESS) {\n\t\t/* Assume error msg already printed. */\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }\n    debug_return_int(0);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\trbin->cb_printf (\"  Superclass        : '%s'\\n\",\n\t\t\t\t dex_class_super_name (bin, c));\n\t\trbin->cb_printf (\"  Interfaces        -\\n\");\n\t}\n\n\tif (c->interfaces_offset > 0 &&\n\t    bin->header.data_offset < c->interfaces_offset &&\n\t    c->interfaces_offset <\n\t\t    bin->header.data_offset + bin->header.data_size) {\n\t\tp = r_buf_get_at (binfile->buf, c->interfaces_offset, NULL);\n\t\tint types_list_size = r_read_le32(p);\n\t\tif (types_list_size < 0 || types_list_size >= bin->header.types_size ) {\n\t\t\treturn;\n\t\t}\n\t\tfor (z = 0; z < types_list_size; z++) {\n\t\t\tint t = r_read_le16 (p + 4 + z * 2);\n\t\t\tif (t > 0 && t < bin->header.types_size ) {\n\t\t\t\tint tid = bin->types[t].descriptor_id;\n\t\t\t\tif (dexdump) {\n\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\"    #%d              : '%s'\\n\",",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\trbin->cb_printf (\"  Superclass        : '%s'\\n\",\n\t\t\t\t dex_class_super_name (bin, c));\n\t\trbin->cb_printf (\"  Interfaces        -\\n\");\n\t}\n\n\tif (c->interfaces_offset > 0 &&\n\t    bin->header.data_offset < c->interfaces_offset &&\n\t    c->interfaces_offset <\n\t\t    bin->header.data_offset + bin->header.data_size) {\n\t\tp = r_buf_get_at (binfile->buf, c->interfaces_offset, NULL);\n\t\tint types_list_size = r_read_le32 (p);\n\t\tif (types_list_size < 0 || types_list_size >= bin->header.types_size ) {\n\t\t\treturn;\n\t\t}\n\t\tfor (z = 0; z < types_list_size; z++) {\n\t\t\tint t = r_read_le16 (p + 4 + z * 2);\n\t\t\tif (t > 0 && t < bin->header.types_size ) {\n\t\t\t\tint tid = bin->types[t].descriptor_id;\n\t\t\t\tif (dexdump) {\n\t\t\t\t\trbin->cb_printf (\n\t\t\t\t\t\t\"    #%d              : '%s'\\n\",",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void ves_icall_System_Threading_InternalThread_Thread_free_internal (MonoInternalThread *this, HANDLE thread)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tTHREAD_DEBUG (g_message (\"%s: Closing thread %p, handle %p\", __func__, this, thread));\n\n\tif (thread)\n\t\tCloseHandle (thread);\n\n\tif (this->synch_cs) {\n\t\tDeleteCriticalSection (this->synch_cs);\n\t\tg_free (this->synch_cs);\n\t\tthis->synch_cs = NULL;\n\t}\n\n\tg_free (this->name);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void ves_icall_System_Threading_InternalThread_Thread_free_internal (MonoInternalThread *this, HANDLE thread)\n{\n\tMONO_ARCH_SAVE_REGS;\n\n\tTHREAD_DEBUG (g_message (\"%s: Closing thread %p, handle %p\", __func__, this, thread));\n\n\tif (thread)\n\t\tCloseHandle (thread);\n\n\tif (this->synch_cs) {\n\t\tCRITICAL_SECTION *synch_cs = this->synch_cs;\n\t\tthis->synch_cs = NULL;\n\t\tDeleteCriticalSection (synch_cs);\n\t\tg_free (synch_cs);\n\t}\n\n\tif (this->name) {\n\t\tvoid *name = this->name;\n\t\tthis->name = NULL;\n\t\tg_free (name);\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void record_and_restart(struct perf_event *event, unsigned long val,\n\t\t\t       struct pt_regs *regs, int nmi)\n{\n\tu64 period = event->hw.sample_period;\n\ts64 prev, delta, left;\n\tint record = 0;\n\n\tif (event->hw.state & PERF_HES_STOPPED) {\n\t\twrite_pmc(event->hw.idx, 0);\n\t\treturn;\n\t}\n\n\t */\n\tif (record) {\n\t\tstruct perf_sample_data data;\n\n\t\tperf_sample_data_init(&data, ~0ULL);\n\t\tdata.period = event->hw.last_period;\n\n\t\tif (event->attr.sample_type & PERF_SAMPLE_ADDR)\n\t\t\tperf_get_data_addr(regs, &data.addr);\n\n\t\tif (perf_event_overflow(event, nmi, &data, regs))\n\t\t\tpower_pmu_stop(event, 0);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void record_and_restart(struct perf_event *event, unsigned long val,\n\t\t\t       struct pt_regs *regs)\n{\n\tu64 period = event->hw.sample_period;\n\ts64 prev, delta, left;\n\tint record = 0;\n\n\tif (event->hw.state & PERF_HES_STOPPED) {\n\t\twrite_pmc(event->hw.idx, 0);\n\t\treturn;\n\t}\n\n\t */\n\tif (record) {\n\t\tstruct perf_sample_data data;\n\n\t\tperf_sample_data_init(&data, ~0ULL);\n\t\tdata.period = event->hw.last_period;\n\n\t\tif (event->attr.sample_type & PERF_SAMPLE_ADDR)\n\t\t\tperf_get_data_addr(regs, &data.addr);\n\n\t\tif (perf_event_overflow(event, &data, regs))\n\t\t\tpower_pmu_stop(event, 0);\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n    memcpy(filename, buffer + *bufPos, length);\n    filename[length] = 0;\n    *bufPos += length;\n\n    /* Check if path contains invalid characters (prevent escaping the virtual filestore by using \"..\")\n     * TODO this may be platform dependent. Also depending of the platform there might be other evil\n     * characters.\n     */\n    if (strstr(filename, \"..\") != NULL) {\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILENAME_SYNTAX_ERROR);\n        return false;\n    }\n\n    return true;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n    memcpy(filename, buffer + *bufPos, length);\n    filename[length] = 0;\n    *bufPos += length;\n\n    /* Check if path contains invalid characters (prevent escaping the virtual filestore by using \"..\")\n     * TODO this may be platform dependent. Also depending of the platform there might be other evil\n     * characters.\n     */\n    if (strstr(filename, \"..\") != NULL) {\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        return false;\n    }\n\n    return true;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "        if (lang_string) {\n            opf->metadata->dc_meta->language[0] = strdup(lang_string);\n        } else {\n            opf->metadata->dc_meta->language[0] = strdup(\"en\");\n        }\n    }\n    /* write optional elements */\n    if (mobi_is_dictionary(m)) {\n        if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n            if (m->mh && m->mh->dict_input_lang) {\n                opf->metadata->x_meta->dictionary_in_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n                uint32_t dict_lang_in = *m->mh->dict_input_lang;\n                opf->metadata->x_meta->dictionary_in_lang[0] = strdup(mobi_get_locale_string(dict_lang_in));\n            }\n        }\n        if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n            if (m->mh && m->mh->dict_output_lang) {\n                opf->metadata->x_meta->dictionary_out_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n                uint32_t dict_lang_in = *m->mh->dict_output_lang;\n                opf->metadata->x_meta->dictionary_out_lang[0] = strdup(mobi_get_locale_string(dict_lang_in));\n            }\n        }\n        if (rawml->orth->orth_index_name) {\n            opf->metadata->x_meta->default_lookup_index = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n            if (opf->metadata->x_meta->default_lookup_index == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            opf->metadata->x_meta->default_lookup_index[0] = strdup(rawml->orth->orth_index_name);\n        }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "        if (lang_string) {\n            opf->metadata->dc_meta->language[0] = strdup(lang_string);\n        } else {\n            opf->metadata->dc_meta->language[0] = strdup(\"en\");\n        }\n    }\n    /* write optional elements */\n    if (mobi_is_dictionary(m)) {\n        if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n            if (m->mh && m->mh->dict_input_lang) {\n                uint32_t dict_lang_in = *m->mh->dict_input_lang;\n                const char *lang = mobi_get_locale_string(dict_lang_in);\n                if (lang) {\n                    opf->metadata->x_meta->dictionary_in_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                    if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n                        debug_print(\"%s\\n\", \"Memory allocation failed\");\n                        return MOBI_MALLOC_FAILED;\n                    }\n                    opf->metadata->x_meta->dictionary_in_lang[0] = strdup(lang);\n                }\n            }\n        }\n        if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n            if (m->mh && m->mh->dict_output_lang) {\n                uint32_t dict_lang_out = *m->mh->dict_output_lang;\n                const char *lang = mobi_get_locale_string(dict_lang_out);\n                if (lang) {\n                    opf->metadata->x_meta->dictionary_out_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                    if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n                        debug_print(\"%s\\n\", \"Memory allocation failed\");\n                        return MOBI_MALLOC_FAILED;\n                    }\n                    opf->metadata->x_meta->dictionary_out_lang[0] = strdup(lang);\n                }\n            }\n        }\n        if (rawml->orth->orth_index_name) {\n            opf->metadata->x_meta->default_lookup_index = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n            if (opf->metadata->x_meta->default_lookup_index == NULL) {\n                debug_print(\"%s\\n\", \"Memory allocation failed\");\n                return MOBI_MALLOC_FAILED;\n            }\n            opf->metadata->x_meta->default_lookup_index[0] = strdup(rawml->orth->orth_index_name);\n        }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tsctp_bind_addr_copy(&newsp->ep->base.bind_addr,\n\t\t\t     &oldsp->ep->base.bind_addr,\n\t\t\t     SCTP_SCOPE_GLOBAL, GFP_KERNEL, flags);\n\n\t/* Move any messages in the old socket's receive queue that are for the\n\t * peeled off association to the new socket's receive queue.\n\t */\n\tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n\t\tevent = sctp_skb2event(skb);\n\t\tif (event->asoc == assoc) {\n\t\t\tsctp_sock_rfree(skb);\n\t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n\t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r(skb, newsk);\n\t\t}\n\t}\n\n\t/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t * 1) No partial deliver;  no work.\n\t * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.\n\t * 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.\n\t */\n\tskb_queue_head_init(&newsp->pd_lobby);\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t/* Walk through the pd_lobby, looking for skbs that\n\t\t * need moved to the new socket.\n\t\t */\n\t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n\t\t\tevent = sctp_skb2event(skb);\n\t\t\tif (event->asoc == assoc) {\n\t\t\t\tsctp_sock_rfree(skb);\n\t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n\t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r(skb, newsk);\n\t\t\t}\n\t\t}\n\n\t\t/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t */\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk);\n\n\t}\n\n\t/* Set the type of socket to indicate that it is peeled off from the\n\t * original UDP-style socket or created with the accept() call on a\n\t * TCP-style socket..\n\t */\n\tnewsp->type = type;\n\n\t/* Mark the new socket \"in-use\" by the user so that any packets\n\t * that may arrive on the association after we've moved it are",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tsctp_bind_addr_copy(&newsp->ep->base.bind_addr,\n\t\t\t     &oldsp->ep->base.bind_addr,\n\t\t\t     SCTP_SCOPE_GLOBAL, GFP_KERNEL, flags);\n\n\t/* Move any messages in the old socket's receive queue that are for the\n\t * peeled off association to the new socket's receive queue.\n\t */\n\tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n\t\tevent = sctp_skb2event(skb);\n\t\tif (event->asoc == assoc) {\n\t\t\tsctp_sock_rfree_frag(skb);\n\t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n\t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t}\n\t}\n\n\t/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t * 1) No partial deliver;  no work.\n\t * 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.\n\t * 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.\n\t */\n\tskb_queue_head_init(&newsp->pd_lobby);\n\t\t\tqueue = &newsp->pd_lobby;\n\t\t} else\n\t\t\tqueue = &newsk->sk_receive_queue;\n\n\t\t/* Walk through the pd_lobby, looking for skbs that\n\t\t * need moved to the new socket.\n\t\t */\n\t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n\t\t\tevent = sctp_skb2event(skb);\n\t\t\tif (event->asoc == assoc) {\n\t\t\t\tsctp_sock_rfree_frag(skb);\n\t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n\t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t\t}\n\t\t}\n\n\t\t/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t */\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk);\n\n\t}\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.reasm, tmp) {\n\t\tsctp_sock_rfree_frag(skb);\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t}\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.lobby, tmp) {\n\t\tsctp_sock_rfree_frag(skb);\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t}\n\n\t/* Set the type of socket to indicate that it is peeled off from the\n\t * original UDP-style socket or created with the accept() call on a\n\t * TCP-style socket..\n\t */\n\tnewsp->type = type;\n\n\t/* Mark the new socket \"in-use\" by the user so that any packets\n\t * that may arrive on the association after we've moved it are",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tstruct gru_thread_state *gts;\n\tvoid *cbk;\n\tint ucbnum, cbrnum, ret = -EINVAL;\n\n\tSTAT(call_os);\n\n\t/* sanity check the cb pointer */\n\tucbnum = get_cb_number((void *)cb);\n\tif ((cb & (GRU_HANDLE_STRIDE - 1)) || ucbnum >= GRU_NUM_CB)\n\t\treturn -EINVAL;\n\n\tgts = gru_find_lock_gts(cb);\n\tif (!gts)\n\t\treturn -EINVAL;\n\tgru_dbg(grudev, \"address 0x%lx, gid %d, gts 0x%p\\n\", cb, gts->ts_gru ? gts->ts_gru->gs_gid : -1, gts);\n\n\tif (ucbnum >= gts->ts_cbr_au_count * GRU_CBR_AU_SIZE)\n\t\tgoto exit;\n\n\tgru_check_context_placement(gts);\n\n\t/*\n\t * CCH may contain stale data if ts_force_cch_reload is set.\n\t */\n\tif (gts->ts_gru && gts->ts_force_cch_reload) {\n\t\tgts->ts_force_cch_reload = 0;\n\t\tgru_update_cch(gts);\n\t}\n\n\tret = -EAGAIN;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tvoid *cbk;\n\tint ucbnum, cbrnum, ret = -EINVAL;\n\n\tSTAT(call_os);\n\n\t/* sanity check the cb pointer */\n\tucbnum = get_cb_number((void *)cb);\n\tif ((cb & (GRU_HANDLE_STRIDE - 1)) || ucbnum >= GRU_NUM_CB)\n\t\treturn -EINVAL;\n\nagain:\n\tgts = gru_find_lock_gts(cb);\n\tif (!gts)\n\t\treturn -EINVAL;\n\tgru_dbg(grudev, \"address 0x%lx, gid %d, gts 0x%p\\n\", cb, gts->ts_gru ? gts->ts_gru->gs_gid : -1, gts);\n\n\tif (ucbnum >= gts->ts_cbr_au_count * GRU_CBR_AU_SIZE)\n\t\tgoto exit;\n\n\tif (gru_check_context_placement(gts)) {\n\t\tgru_unlock_gts(gts);\n\t\tgru_unload_context(gts, 1);\n\t\tgoto again;\n\t}\n\n\t/*\n\t * CCH may contain stale data if ts_force_cch_reload is set.\n\t */\n\tif (gts->ts_gru && gts->ts_force_cch_reload) {\n\t\tgts->ts_force_cch_reload = 0;\n\t\tgru_update_cch(gts);\n\t}\n\n\tret = -EAGAIN;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n{\n\tgdImagePtr pim = 0, tim = im;\n\tint interlace, BitsPerPixel;\n\tinterlace = im->interlace;\n\tif (im->trueColor) {\n\t\t/* Expensive, but the only way that produces an\n\t\t\tacceptable result: mix down to a palette\n\t\t\tbased temporary image. */\n\t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n\t\tif (!pim) {\n\t\t\treturn;\n\t\t}\n\t\ttim = pim;\n\t}\n\tBitsPerPixel = colorstobpp(tim->colorsTotal);\n\t/* All set, let's do it. */\n\tGIFEncode(\n\t\tout, tim->sx, tim->sy, tim->interlace, 0, tim->transparent, BitsPerPixel,\n\t\ttim->red, tim->green, tim->blue, tim);\n\tif (pim) {\n\t\t/* Destroy palette based temporary image. */\n\t\tgdImageDestroy(\tpim);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n{\n\t_gdImageGifCtx(im, out);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tflags |= AOP_FLAG_NOFS;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page) {\n\t\text4_journal_stop(handle);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\t*pagep = page;\n\n\tret = block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\text4_get_block);\n\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, NULL, do_journal_get_write_access);\n\t}\n\n\tif (ret) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\t/*",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tflags |= AOP_FLAG_NOFS;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page) {\n\t\text4_journal_stop(handle);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\t*pagep = page;\n\n\tif (ext4_should_dioread_nolock(inode))\n\t\tret = block_write_begin(file, mapping, pos, len, flags, pagep,\n\t\t\t\tfsdata, ext4_get_block_write);\n\telse\n\t\tret = block_write_begin(file, mapping, pos, len, flags, pagep,\n\t\t\t\tfsdata, ext4_get_block);\n\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, NULL, do_journal_get_write_access);\n\t}\n\n\tif (ret) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\t/*",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t    break;\n\tif (sp->source_from_buf)\n\t{\n\t    if (sp->buf_lnum >= sp->buflines.ga_len)\n\t\tbreak;\t\t    // all the lines are processed\n\t    ga_concat(&ga, ((char_u **)sp->buflines.ga_data)[sp->buf_lnum]);\n\t    sp->buf_lnum++;\n\t    if (ga_grow(&ga, 1) == FAIL)\n\t\tbreak;\n\t    buf = (char_u *)ga.ga_data;\n\t    buf[ga.ga_len++] = NUL;\n\t}\n\telse\n\t{\n\t    buf = (char_u *)ga.ga_data;\n\t    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len,\n\t\t\tsp->fp) == NULL)\n\t\tbreak;\n\t}\n\tlen = ga.ga_len + (int)STRLEN(buf + ga.ga_len);\n#ifdef USE_CRNL\n\t// Ignore a trailing CTRL-Z, when in Dos mode.\tOnly recognize the\n\t// CTRL-Z by its own, or after a NL.\n\tif (\t   (len == 1 || (len >= 2 && buf[len - 2] == '\\n'))\n\t\t&& sp->fileformat == EOL_DOS\n\t\t&& buf[len - 1] == Ctrl_Z)\n\t{\n\t    buf[len - 1] = NUL;\n\t    break;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tif (sp->source_from_buf)\n\t{\n\t    if (sp->buf_lnum >= sp->buflines.ga_len)\n\t\tbreak;\t\t    // all the lines are processed\n\t    ga_concat(&ga, ((char_u **)sp->buflines.ga_data)[sp->buf_lnum]);\n\t    sp->buf_lnum++;\n\t    if (ga_grow(&ga, 1) == FAIL)\n\t\tbreak;\n\t    buf = (char_u *)ga.ga_data;\n\t    buf[ga.ga_len++] = NUL;\n\t    len = ga.ga_len;\n\t}\n\telse\n\t{\n\t    buf = (char_u *)ga.ga_data;\n\t    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len,\n\t\t\tsp->fp) == NULL)\n\t\tbreak;\n\t    len = ga.ga_len + (int)STRLEN(buf + ga.ga_len);\n\t}\n#ifdef USE_CRNL\n\t// Ignore a trailing CTRL-Z, when in Dos mode.\tOnly recognize the\n\t// CTRL-Z by its own, or after a NL.\n\tif (\t   (len == 1 || (len >= 2 && buf[len - 2] == '\\n'))\n\t\t&& sp->fileformat == EOL_DOS\n\t\t&& buf[len - 1] == Ctrl_Z)\n\t{\n\t    buf[len - 1] = NUL;\n\t    break;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "bool fastly_compute_at_edge_http_req_downstream_tls_protocol(\n    fastly_world_string_t *ret, fastly_compute_at_edge_types_error_t *err) {\n  auto default_size = 32;\n  ret->ptr = static_cast<uint8_t *>(cabi_malloc(default_size, 4));\n  auto status = fastly::req_downstream_tls_protocol(reinterpret_cast<char *>(ret->ptr),\n                                                    default_size, &ret->len);\n  if (status == FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_BUFFER_LEN) {\n    cabi_realloc(ret->ptr, default_size, 4, ret->len);\n    status = fastly::req_downstream_tls_protocol(reinterpret_cast<char *>(ret->ptr), ret->len,\n                                                 &ret->len);\n  }\n  return convert_result(status, err);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "bool fastly_compute_at_edge_http_req_downstream_tls_protocol(\n    fastly_world_string_t *ret, fastly_compute_at_edge_types_error_t *err) {\n  auto default_size = 32;\n  ret->ptr = static_cast<uint8_t *>(cabi_malloc(default_size, 4));\n  auto status = fastly::req_downstream_tls_protocol(reinterpret_cast<char *>(ret->ptr),\n                                                    default_size, &ret->len);\n  if (status == FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_BUFFER_LEN) {\n    ret->ptr = static_cast<uint8_t *>(cabi_realloc(ret->ptr, default_size, 4, ret->len));\n    status = fastly::req_downstream_tls_protocol(reinterpret_cast<char *>(ret->ptr), ret->len,\n                                                 &ret->len);\n  }\n  return convert_result(status, err);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "_ssl__SSLContext_cert_store_stats_impl(PySSLContext *self)\n/*[clinic end generated code: output=5f356f4d9cca874d input=eb40dd0f6d0e40cf]*/\n{\n    X509_STORE *store;\n    STACK_OF(X509_OBJECT) *objs;\n    X509_OBJECT *obj;\n    int x509 = 0, crl = 0, ca = 0, i;\n\n    store = SSL_CTX_get_cert_store(self->ctx);\n    objs = X509_STORE_get0_objects(store);\n    for (i = 0; i < sk_X509_OBJECT_num(objs); i++) {\n        obj = sk_X509_OBJECT_value(objs, i);\n        switch (X509_OBJECT_get_type(obj)) {\n            case X509_LU_X509:\n                x509++;\n                if (X509_check_ca(X509_OBJECT_get0_X509(obj))) {\n                    ca++;\n                }\n                break;\n            case X509_LU_CRL:\n                crl++;\n                break;\n            default:\n                /* Ignore X509_LU_FAIL, X509_LU_RETRY, X509_LU_PKEY.\n                 * As far as I can tell they are internal states and never\n                 * stored in a cert store */\n                break;\n        }\n    }\n    return Py_BuildValue(\"{sisisi}\", \"x509\", x509, \"crl\", crl,\n        \"x509_ca\", ca);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "_ssl__SSLContext_cert_store_stats_impl(PySSLContext *self)\n/*[clinic end generated code: output=5f356f4d9cca874d input=eb40dd0f6d0e40cf]*/\n{\n    X509_STORE *store;\n    STACK_OF(X509_OBJECT) *objs;\n    X509_OBJECT *obj;\n    int x509 = 0, crl = 0, ca = 0, i;\n\n    store = SSL_CTX_get_cert_store(self->ctx);\n    objs = X509_STORE_get1_objects(store);\n    if (objs == NULL) {\n        PyErr_SetString(PyExc_MemoryError, \"failed to query cert store\");\n        return NULL;\n    }\n\n    for (i = 0; i < sk_X509_OBJECT_num(objs); i++) {\n        obj = sk_X509_OBJECT_value(objs, i);\n        switch (X509_OBJECT_get_type(obj)) {\n            case X509_LU_X509:\n                x509++;\n                if (X509_check_ca(X509_OBJECT_get0_X509(obj))) {\n                    ca++;\n                }\n                break;\n            case X509_LU_CRL:\n                crl++;\n                break;\n            default:\n                /* Ignore unrecognized types. */\n                break;\n        }\n    }\n    sk_X509_OBJECT_pop_free(objs, X509_OBJECT_free);\n    return Py_BuildValue(\"{sisisi}\", \"x509\", x509, \"crl\", crl,\n        \"x509_ca\", ca);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int connect_to_db(char *host, char *user,char *passwd)\n{\n  char buff[20+FN_REFLEN];\n  DBUG_ENTER(\"connect_to_db\");\n\n  verbose_msg(\"-- Connecting to %s...\\n\", host ? host : \"localhost\");\n  mysql_init(&mysql_connection);\n  if (opt_compress)\n    mysql_options(&mysql_connection,MYSQL_OPT_COMPRESS,NullS);\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(&mysql_connection, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(&mysql_connection,MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*)&opt_ssl_verify_server_cert);\n#endif\n  if (opt_protocol)\n    mysql_options(&mysql_connection,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(&mysql_connection,MYSQL_OPT_BIND,opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(&mysql_connection,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);\n#endif\n  mysql_options(&mysql_connection, MYSQL_SET_CHARSET_NAME, default_charset);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int connect_to_db(char *host, char *user,char *passwd)\n{\n  char buff[20+FN_REFLEN];\n  DBUG_ENTER(\"connect_to_db\");\n\n  verbose_msg(\"-- Connecting to %s...\\n\", host ? host : \"localhost\");\n  mysql_init(&mysql_connection);\n  if (opt_compress)\n    mysql_options(&mysql_connection,MYSQL_OPT_COMPRESS,NullS);\n  SSL_SET_OPTIONS(&mysql_connection);\n  if (opt_protocol)\n    mysql_options(&mysql_connection,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(&mysql_connection,MYSQL_OPT_BIND,opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)\n  if (shared_memory_base_name)\n    mysql_options(&mysql_connection,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);\n#endif\n  mysql_options(&mysql_connection, MYSQL_SET_CHARSET_NAME, default_charset);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    /* The test above made sure that the next real character is a '{', but\n     * under the /x modifier, it could be separated by space (or a comment and\n     * \\n) and this is not allowed (for consistency with \\x{...} and the\n     * tokenizer handling of \\N{NAME}). */\n    if (*RExC_parse != '{') {\n\tvFAIL(\"Missing braces on \\\\N{}\");\n    }\n\n    RExC_parse++;\t/* Skip past the '{' */\n\n    endbrace = strchr(RExC_parse, '}');\n    if (! endbrace) { /* no trailing brace */\n        vFAIL2(\"Missing right brace on \\\\%c{}\", 'N');\n    }\n    else if (!(   endbrace == RExC_parse\t/* nothing between the {} */\n               || memBEGINs(RExC_parse,   /* U+ (bad hex is checked below\n                                                   for a  better error msg) */\n                                  (STRLEN) (RExC_end - RExC_parse),\n                                 \"U+\")))\n    {\n\tRExC_parse = endbrace;\t/* position msg's '<--HERE' */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    /* The test above made sure that the next real character is a '{', but\n     * under the /x modifier, it could be separated by space (or a comment and\n     * \\n) and this is not allowed (for consistency with \\x{...} and the\n     * tokenizer handling of \\N{NAME}). */\n    if (*RExC_parse != '{') {\n\tvFAIL(\"Missing braces on \\\\N{}\");\n    }\n\n    RExC_parse++;\t/* Skip past the '{' */\n\n    endbrace = (char *) memchr(RExC_parse, '}', RExC_end - RExC_parse);\n    if (! endbrace) { /* no trailing brace */\n        vFAIL2(\"Missing right brace on \\\\%c{}\", 'N');\n    }\n    else if (!(   endbrace == RExC_parse\t/* nothing between the {} */\n               || memBEGINs(RExC_parse,   /* U+ (bad hex is checked below\n                                                   for a  better error msg) */\n                                  (STRLEN) (RExC_end - RExC_parse),\n                                 \"U+\")))\n    {\n\tRExC_parse = endbrace;\t/* position msg's '<--HERE' */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "{\n\tstruct jpeg_decompress_struct cinfo;\n\tstruct jpeg_error_mgr jerr;\n\tFILE *input_file;\n\tjpg_dest_t dest_mgr_buf;\n\tjpg_dest_t *dest_mgr = &dest_mgr_buf;\n\tJDIMENSION num_scanlines;\n\tjas_image_t *image;\n\tint ret;\n\tjpg_dec_importopts_t opts;\n\tsize_t size;\n\n\tif (jpg_dec_parseopts(optstr, &opts)) {\n\t\tgoto error;\n\t}\n\n\t// In theory, the two memset calls that follow are not needed.\n\t// They are only here to make the code more predictable in the event\n\t// that the JPEG library fails to initialize a member.\n\tmemset(&cinfo, 0, sizeof(struct jpeg_decompress_struct));\n\tmemset(dest_mgr, 0, sizeof(jpg_dest_t));\n\tJAS_DBGLOG(10, (\"jpeg_read_header(%p, TRUE)\\n\", &cinfo));\n\tret = jpeg_read_header(&cinfo, TRUE);\n\tJAS_DBGLOG(10, (\"jpeg_read_header return value %d\\n\", ret));\n\tif (ret != JPEG_HEADER_OK) {\n\t\tjas_eprintf(\"jpeg_read_header did not return JPEG_HEADER_OK\\n\");\n\t}\n\tJAS_DBGLOG(10, (\n\t  \"header: image_width %d; image_height %d; num_components %d\\n\",\n\t  cinfo.image_width, cinfo.image_height, cinfo.num_components)\n\t  );\n\n\t/* Start the decompressor. */\n\tJAS_DBGLOG(10, (\"jpeg_start_decompress(%p)\\n\", &cinfo));\n\tret = jpeg_start_decompress(&cinfo);\n\tJAS_DBGLOG(10, (\"jpeg_start_decompress return value %d\\n\", ret));\n\tJAS_DBGLOG(10, (\n\t  \"header: output_width %d; output_height %d; output_components %d\\n\",\n\t  cinfo.output_width, cinfo.output_height, cinfo.output_components)\n\t  );\n\n\tif (opts.max_size) {\n\t\tif (!jas_safe_size_mul(cinfo.output_width, cinfo.output_height,\n\t\t  &size) ||\n\t\t  !jas_safe_size_mul(size, cinfo.output_components, &size)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (size > opts.max_size) {\n\t\t\tjas_eprintf(\"image is too large\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* Create an image object to hold the decoded data. */\n\tif (!(image = jpg_mkimage(&cinfo))) {\n\t\tjas_eprintf(\"jpg_mkimage failed\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Initialize the data sink object. */\n\tdest_mgr->image = image;\n\tif (!(dest_mgr->data = jas_matrix_create(1, cinfo.output_width))) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "{\n\tstruct jpeg_decompress_struct cinfo;\n\tstruct jpeg_error_mgr jerr;\n\tFILE *input_file;\n\tjpg_dest_t dest_mgr_buf;\n\tjpg_dest_t *dest_mgr = &dest_mgr_buf;\n\tJDIMENSION num_scanlines;\n\tjas_image_t *image;\n\tint ret;\n\tjpg_dec_importopts_t opts;\n\tsize_t num_samples;\n\n\tJAS_DBGLOG(100, (\"jpg_decode(%p, \\\"%s\\\")\\n\", in, optstr));\n\n\tif (jpg_dec_parseopts(optstr, &opts)) {\n\t\tgoto error;\n\t}\n\n\t// In theory, the two memset calls that follow are not needed.\n\t// They are only here to make the code more predictable in the event\n\t// that the JPEG library fails to initialize a member.\n\tmemset(&cinfo, 0, sizeof(struct jpeg_decompress_struct));\n\tmemset(dest_mgr, 0, sizeof(jpg_dest_t));\n\tret = jpeg_read_header(&cinfo, TRUE);\n\tJAS_DBGLOG(10, (\"jpeg_read_header return value %d\\n\", ret));\n\tif (ret != JPEG_HEADER_OK) {\n\t\tjas_eprintf(\"jpeg_read_header did not return JPEG_HEADER_OK\\n\");\n\t}\n\tJAS_DBGLOG(10, (\n\t  \"header: image_width %d; image_height %d; num_components %d\\n\",\n\t  cinfo.image_width, cinfo.image_height, cinfo.num_components)\n\t  );\n\n\tif (opts.max_samples > 0) {\n\t\tif (!jas_safe_size_mul3(cinfo.image_width, cinfo.image_height,\n\t\t  cinfo.num_components, &num_samples)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (num_samples > opts.max_samples) {\n\t\t\tjas_eprintf(\"image is too large (%zu > %zu)\\n\", num_samples,\n\t\t\t  opts.max_samples);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* Start the decompressor. */\n\tJAS_DBGLOG(10, (\"jpeg_start_decompress(%p)\\n\", &cinfo));\n\tret = jpeg_start_decompress(&cinfo);\n\tJAS_DBGLOG(10, (\"jpeg_start_decompress return value %d\\n\", ret));\n\tJAS_DBGLOG(10, (\n\t  \"header: output_width %d; output_height %d; output_components %d\\n\",\n\t  cinfo.output_width, cinfo.output_height, cinfo.output_components)\n\t  );\n\n\t/* Create an image object to hold the decoded data. */\n\tif (!(image = jpg_mkimage(&cinfo))) {\n\t\tjas_eprintf(\"jpg_mkimage failed\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Initialize the data sink object. */\n\tdest_mgr->image = image;\n\tif (!(dest_mgr->data = jas_matrix_create(1, cinfo.output_width))) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int bad_format_imginfo(\n    char *fmt)\n{\n    char     *ptr;\n    int       n = 0;\n\n    ptr = fmt;\n    while (*ptr != '\\0')\n        if (*ptr++ == '%') {\n\n            /* line cannot end with percent char */\n            if (*ptr == '\\0')\n                return 1;\n            /* '%%' is allowed */\n            if (*ptr == '%')\n                ptr++;\n            /* '%s', '%S' are allowed */\n            else if (*ptr == 's' || *ptr == 'S') {\n                n = 1;\n                ptr++;\n            }\n\n            /* or else '% 4lu' and such are allowed */\n            else {\n                /* optional padding character */\n                if (*ptr == ' ')\n                    ptr++;\n                /* This should take care of 'm' */\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                /* 'lu' must follow here */\n                if (*ptr++ != 'l')\n                    return 1;\n                if (*ptr == 'u')\n                    ptr++;\n                else\n                    return 1;\n                n++;\n            }\n        }\n\n    return (n != 3);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int bad_format_imginfo(char *fmt){\n    return bad_format_check(\"^\" SAFE_STRING \"%s\" SAFE_STRING \"%lu\" SAFE_STRING \"%lu\" SAFE_STRING \"$\",fmt);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* data = GetInput(context, node, kInputDataTensor);\n  const TfLiteTensor* segment_ids =\n      GetInput(context, node, kInputSegmentIdsTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE(context,\n                 data->type == kTfLiteInt32 || data->type == kTfLiteFloat32);\n  TF_LITE_ENSURE_EQ(context, segment_ids->type, kTfLiteInt32);\n\n  if (!IsConstantTensor(data) || !IsConstantTensor(segment_ids)) {\n    SetTensorToDynamic(output);\n    return kTfLiteOk;\n  }\n\n  return ResizeOutputTensor(context, data, segment_ids, output);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* data;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputDataTensor, &data));\n  const TfLiteTensor* segment_ids;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputSegmentIdsTensor,\n                                          &segment_ids));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE(context,\n                 data->type == kTfLiteInt32 || data->type == kTfLiteFloat32);\n  TF_LITE_ENSURE_EQ(context, segment_ids->type, kTfLiteInt32);\n\n  if (!IsConstantTensor(data) || !IsConstantTensor(segment_ids)) {\n    SetTensorToDynamic(output);\n    return kTfLiteOk;\n  }\n\n  return ResizeOutputTensor(context, data, segment_ids, output);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void fp48_exp_cyc_sps(fp48_t c, const fp48_t a, const int *b, int len, int sign) {\n\tint i, j, k, w = len;\n    fp48_t t, *u = RLC_ALLOCA(fp48_t, w);\n\n\tif (len == 0) {\n\t\tRLC_FREE(u);\n\t\tfp48_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp48_null(t);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void fp48_exp_cyc_sps(fp48_t c, const fp48_t a, const int *b, size_t len,\n\t\tint sign) {\n\tsize_t i, j, k, w = len;\n    fp48_t t, *u = RLC_ALLOCA(fp48_t, w);\n\n\tif (len == 0) {\n\t\tRLC_FREE(u);\n\t\tfp48_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp48_null(t);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  char *tstr;\n  int number;\n  int sum;\n  int max = 0;\n  int x;\n  int i;\n  struct log_info *loginfo;\n  int log_error;\n  FILE *file1;\n  FILE *file2;\n  int ismatch;\n\n  curfile = files;\n  \n  while (curfile) {\n    if (curfile->hasdupes) {\n      counter = 1;\n      groups++;\n\n      tmpfile = curfile->duplicates;\n      while (tmpfile) {\n\n      if (file1)\n        fclose(file1);\n    }\n    else\n    {\n      ismatch = 1;\n    }\n\n    if (ismatch) {\n      if (remove(dupelist[x]->d_name) == 0) {\n        printf(\"   [-] %s\\n\", dupelist[x]->d_name);\n\n        if (loginfo)\n          log_file_deleted(loginfo, dupelist[x]->d_name);\n      }\n      else {\n        printf(\"   [!] %s \", dupelist[x]->d_name);\n        printf(\"-- unable to delete file!\\n\");\n\n        if (loginfo)\n          log_file_remaining(loginfo, dupelist[x]->d_name);\n      }\n    }\n    else {\n      printf(\"   [!] %s\\n\", dupelist[x]->d_name);\n      printf(\" -- unable to confirm match; file not deleted!\\n\");\n\n      if (loginfo)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  int number;\n  int sum;\n  int max = 0;\n  int x;\n  int i;\n  struct log_info *loginfo;\n  int log_error;\n  FILE *file1;\n  FILE *file2;\n  int ismatch;\n  char *errorstring;\n\n  curfile = files;\n  \n  while (curfile) {\n    if (curfile->hasdupes) {\n      counter = 1;\n      groups++;\n\n      tmpfile = curfile->duplicates;\n      while (tmpfile) {\n\n      if (file1)\n        fclose(file1);\n    }\n    else\n    {\n      ismatch = 1;\n    }\n\n    if (ismatch) {\n      if (removeifnotchanged(dupelist[x], &errorstring) == 0) {\n        printf(\"   [-] %s\\n\", dupelist[x]->d_name);\n\n        if (loginfo)\n          log_file_deleted(loginfo, dupelist[x]->d_name);\n      }\n      else {\n        printf(\"   [!] %s \", dupelist[x]->d_name);\n        printf(\"-- unable to delete file: %s!\\n\", errorstring);\n\n        if (loginfo)\n          log_file_remaining(loginfo, dupelist[x]->d_name);\n      }\n    }\n    else {\n      printf(\"   [!] %s\\n\", dupelist[x]->d_name);\n      printf(\" -- unable to confirm match; file not deleted!\\n\");\n\n      if (loginfo)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n\tif (len_buf_pos < 4) {\n\t\tret = timed_read(fd, &len_buf[len_buf_pos], 4 - len_buf_pos,\n\t\t    timeout);\n\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\treturn -2;\n\n\t\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ret == 0) {\t\t/* EOF */\n\t\t\t/* Failure to read ANY length just means we're done */\n\t\t\tif (len_buf_pos == 0)\n\t\t\t\treturn 0;\n\n\t\t\t/*\n\t\t\t * Otherwise, we got EOF mid-length, and that's\n\t\t\t * a protocol error.\n\t\t\t */\n\t\t\tLOG(LOG_INFO, (\"EOF reading packet len\"));\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen_buf_pos += ret;\n\t}\n\n\t/* Not done reading the length? */\n\tif (len_buf_pos != 4)\n\t\treturn -2;\n\n\t/* We have the complete length */\n\tlen = ntohl(*(uint32_t *)len_buf);\n\n\t/*\n\t * We make sure recvd length is reasonable, allowing for some\n\t * slop in enc overhead, beyond the actual maximum number of\n\t * bytes of decrypted payload.\n\t */\n\tif (len > GSTD_MAXPACKETCONTENTS + 512) {\n\t\tLOG(LOG_ERR, (\"ridiculous length, %ld\", len));\n\t\treturn -1;\n\t}\n\n\tif (!tmpbuf) {\n\t\tif ((tmpbuf = malloc(len)) == NULL) {\n\t\t\tLOG(LOG_CRIT, (\"malloc failure, %ld bytes\", len));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);\n\tif (ret == -1) {\n\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\treturn -2;\n\n\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\treturn -1;\n\t}\n\n\tif (ret == 0) {\n\t\tLOG(LOG_ERR, (\"EOF while reading packet (len=%d)\", len));\n\t\treturn -1;\n\t}\n\n\ttmpbuf_pos += ret;\n\n\tif (tmpbuf_pos == len) {\n\t\tbuf->length = len;\n\t\tbuf->value = tmpbuf;\n\t\tlen = len_buf_pos = tmpbuf_pos = 0;\n\t\ttmpbuf = NULL;\n\n\t\tLOG(LOG_DEBUG, (\"read packet of length %d\", buf->length));\n\t\treturn 1;\n\t}\n\n\treturn -2;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n\tif (len_buf_pos < 4) {\n\t\tret = timed_read(fd, &len_buf[len_buf_pos], 4 - len_buf_pos,\n\t\t    timeout);\n\n\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\treturn -2;\n\n\t\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (ret == 0) {\t\t/* EOF */\n\t\t\t/* Failure to read ANY length just means we're done */\n\t\t\tif (len_buf_pos == 0)\n\t\t\t\treturn 0;\n\n\t\t\t/*\n\t\t\t * Otherwise, we got EOF mid-length, and that's\n\t\t\t * a protocol error.\n\t\t\t */\n\t\t\tLOG(LOG_INFO, (\"EOF reading packet len\"));\n\t\t\tgoto bail;\n\t\t}\n\n\t\tlen_buf_pos += ret;\n\t}\n\n\t/* Not done reading the length? */\n\tif (len_buf_pos != 4)\n\t\treturn -2;\n\n\t/* We have the complete length */\n\tlen = ntohl(*(uint32_t *)len_buf);\n\n\t/*\n\t * We make sure recvd length is reasonable, allowing for some\n\t * slop in enc overhead, beyond the actual maximum number of\n\t * bytes of decrypted payload.\n\t */\n\tif (len > GSTD_MAXPACKETCONTENTS + 512) {\n\t\tLOG(LOG_ERR, (\"ridiculous length, %ld\", len));\n\t\tgoto bail;\n\t}\n\n\tif (!tmpbuf) {\n\t\tif ((tmpbuf = malloc(len)) == NULL) {\n\t\t\tLOG(LOG_CRIT, (\"malloc failure, %ld bytes\", len));\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);\n\tif (ret == -1) {\n\n\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\treturn -2;\n\n\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\tgoto bail;\n\t}\n\n\tif (ret == 0) {\n\t\tLOG(LOG_ERR, (\"EOF while reading packet (len=%d)\", len));\n\t\tgoto bail;\n\t}\n\n\ttmpbuf_pos += ret;\n\n\tif (tmpbuf_pos == len) {\n\t\tbuf->length = len;\n\t\tbuf->value = tmpbuf;\n\t\tlen = len_buf_pos = tmpbuf_pos = 0;\n\t\ttmpbuf = NULL;\n\n\t\tLOG(LOG_DEBUG, (\"read packet of length %d\", buf->length));\n\t\treturn 1;\n\t}\n\n\treturn -2;\n\nbail:\n\tfree(tmpbuf);\n\ttmpbuf = NULL;\n\n\treturn -1;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int raw_cmd_copyout(int cmd, void __user *param,\n\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n\tint ret;\n\n\twhile (ptr) {\n\t\tret = copy_to_user(param, ptr, sizeof(*ptr));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&\n\t\t\t    ptr->length <= ptr->buffer_length) {\n\t\t\t\tlong length = ptr->buffer_length - ptr->length;\n\t\t\t\tret = fd_copyout(ptr->data, ptr->kernel_data,\n\t\t\t\t\t\t length);\n\t\t\t\tif (ret)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int raw_cmd_copyout(int cmd, void __user *param,\n\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n\tint ret;\n\n\twhile (ptr) {\n\t\tstruct floppy_raw_cmd cmd = *ptr;\n\t\tcmd.next = NULL;\n\t\tcmd.kernel_data = NULL;\n\t\tret = copy_to_user(param, &cmd, sizeof(cmd));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&\n\t\t\t    ptr->length <= ptr->buffer_length) {\n\t\t\t\tlong length = ptr->buffer_length - ptr->length;\n\t\t\t\tret = fd_copyout(ptr->data, ptr->kernel_data,\n\t\t\t\t\t\t length);\n\t\t\t\tif (ret)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "        std::string(request_headers.ForwardedFor()->value().getStringView()));\n  }\n  if (request_headers.RequestId() != nullptr) {\n    request_properties->set_request_id(\n        std::string(request_headers.RequestId()->value().getStringView()));\n  }\n  if (request_headers.EnvoyOriginalPath() != nullptr) {\n    request_properties->set_original_path(\n        std::string(request_headers.EnvoyOriginalPath()->value().getStringView()));\n  }\n  request_properties->set_request_headers_bytes(request_headers.byteSize());\n  request_properties->set_request_body_bytes(stream_info.bytesReceived());\n  if (request_headers.Method() != nullptr) {\n    envoy::api::v2::core::RequestMethod method =\n        envoy::api::v2::core::RequestMethod::METHOD_UNSPECIFIED;\n    envoy::api::v2::core::RequestMethod_Parse(\n        std::string(request_headers.Method()->value().getStringView()), &method);\n    request_properties->set_request_method(method);\n  }\n  if (!request_headers_to_log_.empty()) {\n    auto* logged_headers = request_properties->mutable_request_headers();\n  }\n\n  // HTTP response properties.\n  auto* response_properties = log_entry.mutable_response();\n  if (stream_info.responseCode()) {\n    response_properties->mutable_response_code()->set_value(stream_info.responseCode().value());\n  }\n  if (stream_info.responseCodeDetails()) {\n    response_properties->set_response_code_details(stream_info.responseCodeDetails().value());\n  }\n  response_properties->set_response_headers_bytes(response_headers.byteSize());\n  response_properties->set_response_body_bytes(stream_info.bytesSent());\n  if (!response_headers_to_log_.empty()) {\n    auto* logged_headers = response_properties->mutable_response_headers();\n\n    for (const auto& header : response_headers_to_log_) {\n      const Http::HeaderEntry* entry = response_headers.get(header);\n      if (entry != nullptr) {\n        logged_headers->insert({header.get(), std::string(entry->value().getStringView())});\n      }\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "        std::string(request_headers.ForwardedFor()->value().getStringView()));\n  }\n  if (request_headers.RequestId() != nullptr) {\n    request_properties->set_request_id(\n        std::string(request_headers.RequestId()->value().getStringView()));\n  }\n  if (request_headers.EnvoyOriginalPath() != nullptr) {\n    request_properties->set_original_path(\n        std::string(request_headers.EnvoyOriginalPath()->value().getStringView()));\n  }\n  request_properties->set_request_headers_bytes(request_headers.byteSize().value());\n  request_properties->set_request_body_bytes(stream_info.bytesReceived());\n  if (request_headers.Method() != nullptr) {\n    envoy::api::v2::core::RequestMethod method =\n        envoy::api::v2::core::RequestMethod::METHOD_UNSPECIFIED;\n    envoy::api::v2::core::RequestMethod_Parse(\n        std::string(request_headers.Method()->value().getStringView()), &method);\n    request_properties->set_request_method(method);\n  }\n  if (!request_headers_to_log_.empty()) {\n    auto* logged_headers = request_properties->mutable_request_headers();\n  }\n\n  // HTTP response properties.\n  auto* response_properties = log_entry.mutable_response();\n  if (stream_info.responseCode()) {\n    response_properties->mutable_response_code()->set_value(stream_info.responseCode().value());\n  }\n  if (stream_info.responseCodeDetails()) {\n    response_properties->set_response_code_details(stream_info.responseCodeDetails().value());\n  }\n  response_properties->set_response_headers_bytes(response_headers.byteSize().value());\n  response_properties->set_response_body_bytes(stream_info.bytesSent());\n  if (!response_headers_to_log_.empty()) {\n    auto* logged_headers = response_properties->mutable_response_headers();\n\n    for (const auto& header : response_headers_to_log_) {\n      const Http::HeaderEntry* entry = response_headers.get(header);\n      if (entry != nullptr) {\n        logged_headers->insert({header.get(), std::string(entry->value().getStringView())});\n      }\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    }\n\n    std::unique_ptr<GpuTimer, GpuTimerDeleter> timer;\n    const bool is_profiling = output_profile_result != nullptr;\n    if (is_profiling) {\n      timer.reset(new GpuTimer(parent_));\n      // The start and stop of the timer should be as close to the Cudnn call as\n      // possible. It is still possible for other threads to issue workload on\n      // to this stream. So it could take multiple profiling measurements.\n      if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n        return tsl::Status(port::error::INTERNAL, \"Failed to start timer\");\n      }\n    }\n\n    RETURN_IF_CUDNN_ERROR(cudnnRNNForward(\n        /*handle=*/cudnn.handle(), /*rnnDesc=*/rnn_desc.handle(),\n        /*fwdMode=*/rnn_fwd_mode,\n        /*devSeqLengths=*/\n        reinterpret_cast<const int*>(seq_lengths_data.opaque()),\n        /*xDesc=*/input_desc.data_handle(), /*x=*/input_data.opaque(),\n        /*yDesc=*/output_desc.data_handle(), /*y=*/output_data->opaque(),\n        /*cxDesc=*/input_c_desc.handle(), /*cx=*/input_c_data.opaque(),\n        /*cy=*/output_c_data->opaque(),\n        /*weightSpaceSize=*/rnn_desc.ParamsSizeInBytes(),\n        /*weightSpace=*/params.opaque(),\n        /*workSpaceSize=*/workspace.size(), /*workspace=*/workspace.opaque(),\n        /*reserveSpaceSizeInBytes=*/reserve_space.size(),\n        /*reserveSpace=*/reserve_space.opaque()));\n\n    if (is_profiling) {\n      if (!timer->Stop(AsGpuStream(stream))) {\n        return tsl::Status(port::error::INTERNAL, \"Failed to stop timer\");\n      }\n      auto algo_desc = *rnn_desc.algorithm_config().algorithm();\n      output_profile_result->set_algorithm(algo_desc);\n      output_profile_result->set_elapsed_time_in_ms(\n          timer->GetElapsedMilliseconds());\n    }\n    return tsl::OkStatus();\n  }\n#endif\n  TF_ASSIGN_OR_RETURN(DeviceMemory<uint8_t> workspace,\n  }\n\n  std::unique_ptr<GpuTimer, GpuTimerDeleter> timer;\n  const bool is_profiling = output_profile_result != nullptr;\n  if (is_profiling) {\n    timer.reset(new GpuTimer(parent_));\n    // The start and stop of the timer should be as close to the Cudnn call as\n    // possible. It is still possible for other threads to issue workload on\n    // to this stream. So it could take multiple profiling measurements.\n    if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n      return tsl::Status(port::error::INTERNAL, \"Failed to start timer\");\n    }\n  }\n\n  if (!is_training) {\n    if (input_desc.is_var_seq_lengths()) {\n      RETURN_IF_CUDNN_ERROR(cudnnRNNForwardInferenceEx(\n          /*handle=*/cudnn.handle(), /*rnnDesc=*/rnn_desc.handle(),\n          /*xDesc=*/input_desc.data_handle(), /*x=*/input_data.opaque(),\n          /*hxDesc=*/input_h_desc.handle(), /*hx=*/input_h_data.opaque(),\n          /*cxDesc=*/input_c_desc.handle(), /*cx=*/input_c_data.opaque(),\n          /*hy=*/output_h_data->opaque(), /*cyDesc=*/output_c_desc.handle(),\n          /*cy=*/output_c_data->opaque(), /*workspace=*/workspace.opaque(),\n          /*workSpaceSizeInBytes=*/workspace.size(),\n          /*reserveSpace=*/reserve_space.opaque(),\n          /*reserveSpaceSizeInBytes=*/reserve_space.size()));\n    }\n  }\n\n  if (is_profiling) {\n    if (!timer->Stop(AsGpuStream(stream))) {\n      return tsl::Status(port::error::INTERNAL, \"Failed to stop timer\");\n    }\n    auto algo_desc = *rnn_desc.algorithm_config().algorithm();\n    output_profile_result->set_algorithm(algo_desc);\n    output_profile_result->set_elapsed_time_in_ms(\n        timer->GetElapsedMilliseconds());\n  }\n\n  return ::tsl::OkStatus();\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    }\n\n    std::unique_ptr<GpuTimer, GpuTimerDeleter> timer;\n    const bool is_profiling = output_profile_result != nullptr;\n    if (is_profiling) {\n      timer.reset(new GpuTimer(parent_));\n      // The start and stop of the timer should be as close to the Cudnn call as\n      // possible. It is still possible for other threads to issue workload on\n      // to this stream. So it could take multiple profiling measurements.\n      if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n        return tsl::Status(tsl::error::INTERNAL, \"Failed to start timer\");\n      }\n    }\n\n    RETURN_IF_CUDNN_ERROR(cudnnRNNForward(\n        /*handle=*/cudnn.handle(), /*rnnDesc=*/rnn_desc.handle(),\n        /*fwdMode=*/rnn_fwd_mode,\n        /*devSeqLengths=*/\n        reinterpret_cast<const int*>(seq_lengths_data.opaque()),\n        /*xDesc=*/input_desc.data_handle(), /*x=*/input_data.opaque(),\n        /*yDesc=*/output_desc.data_handle(), /*y=*/output_data->opaque(),\n        /*cxDesc=*/input_c_desc.handle(), /*cx=*/input_c_data.opaque(),\n        /*cy=*/output_c_data->opaque(),\n        /*weightSpaceSize=*/rnn_desc.ParamsSizeInBytes(),\n        /*weightSpace=*/params.opaque(),\n        /*workSpaceSize=*/workspace.size(), /*workspace=*/workspace.opaque(),\n        /*reserveSpaceSizeInBytes=*/reserve_space.size(),\n        /*reserveSpace=*/reserve_space.opaque()));\n\n    if (is_profiling) {\n      if (!timer->Stop(AsGpuStream(stream))) {\n        return tsl::Status(tsl::error::INTERNAL, \"Failed to stop timer\");\n      }\n      auto algo_desc = *rnn_desc.algorithm_config().algorithm();\n      output_profile_result->set_algorithm(algo_desc);\n      output_profile_result->set_elapsed_time_in_ms(\n          timer->GetElapsedMilliseconds());\n    }\n    return tsl::OkStatus();\n  }\n#endif\n  TF_ASSIGN_OR_RETURN(DeviceMemory<uint8_t> workspace,\n  }\n\n  std::unique_ptr<GpuTimer, GpuTimerDeleter> timer;\n  const bool is_profiling = output_profile_result != nullptr;\n  if (is_profiling) {\n    timer.reset(new GpuTimer(parent_));\n    // The start and stop of the timer should be as close to the Cudnn call as\n    // possible. It is still possible for other threads to issue workload on\n    // to this stream. So it could take multiple profiling measurements.\n    if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n      return tsl::Status(tsl::error::INTERNAL, \"Failed to start timer\");\n    }\n  }\n\n  if (!is_training) {\n    if (input_desc.is_var_seq_lengths()) {\n      RETURN_IF_CUDNN_ERROR(cudnnRNNForwardInferenceEx(\n          /*handle=*/cudnn.handle(), /*rnnDesc=*/rnn_desc.handle(),\n          /*xDesc=*/input_desc.data_handle(), /*x=*/input_data.opaque(),\n          /*hxDesc=*/input_h_desc.handle(), /*hx=*/input_h_data.opaque(),\n          /*cxDesc=*/input_c_desc.handle(), /*cx=*/input_c_data.opaque(),\n          /*hy=*/output_h_data->opaque(), /*cyDesc=*/output_c_desc.handle(),\n          /*cy=*/output_c_data->opaque(), /*workspace=*/workspace.opaque(),\n          /*workSpaceSizeInBytes=*/workspace.size(),\n          /*reserveSpace=*/reserve_space.opaque(),\n          /*reserveSpaceSizeInBytes=*/reserve_space.size()));\n    }\n  }\n\n  if (is_profiling) {\n    if (!timer->Stop(AsGpuStream(stream))) {\n      return tsl::Status(tsl::error::INTERNAL, \"Failed to stop timer\");\n    }\n    auto algo_desc = *rnn_desc.algorithm_config().algorithm();\n    output_profile_result->set_algorithm(algo_desc);\n    output_profile_result->set_elapsed_time_in_ms(\n        timer->GetElapsedMilliseconds());\n  }\n\n  return ::tsl::OkStatus();\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tchar const* parse_int(char const* start, char const* end, char delimiter, boost::int64_t& val)\n\t{\n\t\twhile (start < end && *start != delimiter)\n\t\t{\n\t\t\tif (!is_digit(*start)) { return 0; }\n\t\t\tval *= 10;\n\t\t\tval += *start - '0';\n\t\t\t++start;\n\t\t}\n\t\treturn start;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tchar const* parse_int(char const* start, char const* end, char delimiter\n\t\t, boost::int64_t& val, bdecode_errors::error_code_enum& ec)\n\t{\n\t\twhile (start < end && *start != delimiter)\n\t\t{\n\t\t\tif (!numeric(*start))\n\t\t\t{\n\t\t\t\tec = bdecode_errors::expected_string;\n\t\t\t\treturn start;\n\t\t\t}\n\t\t\tif (val > INT64_MAX / 10)\n\t\t\t{\n\t\t\t\tec = bdecode_errors::overflow;\n\t\t\t\treturn start;\n\t\t\t}\n\t\t\tval *= 10;\n\t\t\tint digit = *start - '0';\n\t\t\tif (val > INT64_MAX - digit)\n\t\t\t{\n\t\t\t\tec = bdecode_errors::overflow;\n\t\t\t\treturn start;\n\t\t\t}\n\t\t\tval += digit;\n\t\t\t++start;\n\t\t}\n\t\tif (*start != delimiter)\n\t\t\tec = bdecode_errors::expected_colon;\n\t\treturn start;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len)\n{\n\tjas_stream_t *in;\n\tjas_iccprof_t *prof;\n\tif (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))\n\t\tgoto error;\n\tif (!(prof = jas_iccprof_load(in)))\n\t\tgoto error;\n\tjas_stream_close(in);\n\treturn prof;\nerror:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "jas_iccprof_t *jas_iccprof_createfrombuf(jas_uchar *buf, int len)\n{\n\tjas_stream_t *in;\n\tjas_iccprof_t *prof;\n\tif (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))\n\t\tgoto error;\n\tif (!(prof = jas_iccprof_load(in)))\n\t\tgoto error;\n\tjas_stream_close(in);\n\treturn prof;\nerror:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    ratt.endpoint.endpointKind = READER;\n    ratt.endpoint.multicastLocatorList = mp_builtin->m_metatrafficMulticastLocatorList;\n    ratt.endpoint.unicastLocatorList = mp_builtin->m_metatrafficUnicastLocatorList;\n    ratt.endpoint.external_unicast_locators = mp_builtin->m_att.metatraffic_external_unicast_locators;\n    ratt.endpoint.ignore_non_matching_locators = pattr.ignore_non_matching_locators;\n    ratt.endpoint.topicKind = WITH_KEY;\n    // change depending of backup mode\n    ratt.endpoint.durabilityKind = VOLATILE;\n    ratt.endpoint.reliabilityKind = BEST_EFFORT;\n\n    endpoints.stateless_listener.reset(new PDPSecurityInitiatorListener(this,\n            [this](const ParticipantProxyData& participant_data)\n            {\n                auto endpoints = static_cast<fastdds::rtps::DiscoveryServerPDPEndpoints*>(builtin_endpoints_.get());\n                std::lock_guard<fastrtps::RecursiveTimedMutex> wlock(endpoints->writer.writer_->getMutex());\n\n                CacheChange_t* change = discovery_db().cache_change_own_participant();\n                if (change != nullptr)\n                {\n                    std::vector<GUID_t> remote_readers;\n                    LocatorList locators;\n                    }\n\n                    send_announcement(change, remote_readers, locators, false);\n\n                }\n            }));\n\n    // Create PDP Reader\n    RTPSReader* reader = nullptr;\n    if (mp_RTPSParticipant->createReader(&reader, ratt, endpoints.stateless_reader.history_.get(),\n            endpoints.stateless_listener.get(), c_EntityId_SPDPReader, true, false))\n    {\n        endpoints.stateless_reader.reader_ = dynamic_cast<fastrtps::rtps::StatelessReader*>(reader);\n\n        // Enable unknown clients to reach this reader\n        reader->enableMessagesFromUnkownWriters(true);\n\n        mp_RTPSParticipant->set_endpoint_rtps_protection_supports(reader, false);\n    }\n    // Could not create PDP Reader, so return false\n    else\n    {\n        EPROSIMA_LOG_ERROR(RTPS_PDP_SERVER, \"PDPServer security initiation Reader creation failed\");\n\n        endpoints.stateless_listener.reset();\n        endpoints.stateless_reader.release();\n        return false;\n    }\n\n    return true;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    ratt.endpoint.endpointKind = READER;\n    ratt.endpoint.multicastLocatorList = mp_builtin->m_metatrafficMulticastLocatorList;\n    ratt.endpoint.unicastLocatorList = mp_builtin->m_metatrafficUnicastLocatorList;\n    ratt.endpoint.external_unicast_locators = mp_builtin->m_att.metatraffic_external_unicast_locators;\n    ratt.endpoint.ignore_non_matching_locators = pattr.ignore_non_matching_locators;\n    ratt.endpoint.topicKind = WITH_KEY;\n    // change depending of backup mode\n    ratt.endpoint.durabilityKind = VOLATILE;\n    ratt.endpoint.reliabilityKind = BEST_EFFORT;\n\n    endpoints.stateless_reader.listener_.reset(new PDPSecurityInitiatorListener(this,\n            [this](const ParticipantProxyData& participant_data)\n            {\n                auto endpoints = static_cast<fastdds::rtps::DiscoveryServerPDPEndpoints*>(builtin_endpoints_.get());\n                std::lock_guard<fastrtps::RecursiveTimedMutex> wlock(endpoints->writer.writer_->getMutex());\n\n                CacheChange_t* change = discovery_db().cache_change_own_participant();\n                if (change != nullptr)\n                {\n                    std::vector<GUID_t> remote_readers;\n                    LocatorList locators;\n                    }\n\n                    send_announcement(change, remote_readers, locators, false);\n\n                }\n            }));\n\n    // Create PDP Reader\n    RTPSReader* reader = nullptr;\n    if (mp_RTPSParticipant->createReader(&reader, ratt, endpoints.stateless_reader.history_.get(),\n            endpoints.stateless_reader.listener_.get(), c_EntityId_SPDPReader, true, false))\n    {\n        endpoints.stateless_reader.reader_ = dynamic_cast<fastrtps::rtps::StatelessReader*>(reader);\n        mp_RTPSParticipant->set_endpoint_rtps_protection_supports(reader, false);\n    }\n    // Could not create PDP Reader, so return false\n    else\n    {\n        EPROSIMA_LOG_ERROR(RTPS_PDP_SERVER, \"PDPServer security initiation Reader creation failed\");\n        endpoints.stateless_reader.release();\n        return false;\n    }\n\n    return true;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\trcu_read_lock();\n\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n\trcu_read_unlock();\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\t__ptrace_link(child, new_parent, current_cred());\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t * -EOPENSTALE.  The VFS will retry the lookup/create/open.\n\t */\n\n\tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n\n\terr = nfs_check_flags(openflags);\n\tif (err)\n\t\treturn err;\n\n\tif ((openflags & O_ACCMODE) == 3)\n\t\treturn nfs_open(inode, filp);\n\n\t/* We can't create new files here */\n\topenflags &= ~(O_CREAT|O_EXCL);\n\n\tparent = dget_parent(dentry);\n\tdir = d_inode(parent);\n\n\tctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t * -EOPENSTALE.  The VFS will retry the lookup/create/open.\n\t */\n\n\tdprintk(\"NFS: open file(%pd2)\\n\", dentry);\n\n\terr = nfs_check_flags(openflags);\n\tif (err)\n\t\treturn err;\n\n\tif ((openflags & O_ACCMODE) == 3)\n\t\topenflags--;\n\n\t/* We can't create new files here */\n\topenflags &= ~(O_CREAT|O_EXCL);\n\n\tparent = dget_parent(dentry);\n\tdir = d_inode(parent);\n\n\tctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\n\terr = PTR_ERR(ctx);\n\tif (IS_ERR(ctx))",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static XMLSharedNodeList* find_impl(xmlXPathContext* ctxt, const string& xpath)\n{\n\txmlXPathObject* result = xmlXPathEval((const xmlChar*)xpath.c_str(), ctxt);\n\n\tif (!result) {\n\t\txmlXPathFreeContext(ctxt);\n\t\txmlFreeDoc(ctxt->doc);\n\n\t\tthrow XMLException(\"Invalid XPath: \" + xpath);\n\t}\n\n\tif (result->type != XPATH_NODESET) {\n\t\txmlXPathFreeObject(result);\n\t\txmlXPathFreeContext(ctxt);\n\t\txmlFreeDoc(ctxt->doc);\n\n\t\tthrow XMLException(\"Only nodeset result types are supported.\");\n\t}\n\n\txmlNodeSet* nodeset = result->nodesetval;\n\tXMLSharedNodeList* nodes = new XMLSharedNodeList();\n\tif (nodeset) {\n\t\tfor (int i = 0; i < nodeset->nodeNr; ++i) {\n\t\t\tXMLNode* node = readnode(nodeset->nodeTab[i]);\n\t\t\tnodes->push_back(boost::shared_ptr<XMLNode>(node));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static XMLSharedNodeList* find_impl(xmlXPathContext* ctxt, const string& xpath)\n{\n\txmlXPathObject* result = xmlXPathEval((const xmlChar*)xpath.c_str(), ctxt);\n\n\tif (!result) {\n\t\txmlFreeDoc(ctxt->doc);\n\t\txmlXPathFreeContext(ctxt);\n\n\t\tthrow XMLException(\"Invalid XPath: \" + xpath);\n\t}\n\n\tif (result->type != XPATH_NODESET) {\n\t\txmlXPathFreeObject(result);\n\t\txmlFreeDoc(ctxt->doc);\n\t\txmlXPathFreeContext(ctxt);\n\n\t\tthrow XMLException(\"Only nodeset result types are supported.\");\n\t}\n\n\txmlNodeSet* nodeset = result->nodesetval;\n\tXMLSharedNodeList* nodes = new XMLSharedNodeList();\n\tif (nodeset) {\n\t\tfor (int i = 0; i < nodeset->nodeNr; ++i) {\n\t\t\tXMLNode* node = readnode(nodeset->nodeTab[i]);\n\t\t\tnodes->push_back(boost::shared_ptr<XMLNode>(node));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int util_bits_dig(dig_t a) {\n    return RLC_DIG - arch_lzcnt(a);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "size_t util_bits_dig(dig_t a) {\n    return RLC_DIG - arch_lzcnt(a);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void bn_read_bin(bn_t a, const uint8_t *bin, int len) {\n\tint i, j;\n\tdig_t d = (RLC_DIG / 8);\n\tint digs = (len % d == 0 ? len / d : len / d + 1);\n\n\tbn_grow(a, digs);\n\tbn_zero(a);\n\ta->used = digs;\n\n\tfor (i = 0; i < digs - 1; i++) {\n\t\td = 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void bn_read_bin(bn_t a, const uint8_t *bin, size_t len) {\n\tint i, j;\n\tdig_t d = (RLC_DIG / 8);\n\tint digs = (len % d == 0 ? len / d : len / d + 1);\n\n\tbn_grow(a, digs);\n\tbn_zero(a);\n\ta->used = digs;\n\n\tfor (i = 0; i < digs - 1; i++) {\n\t\td = 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "              }\n            else if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n              {\n                // sRAW and Foveon only, so extra buffer size is just 1/4\n                // Legacy converters does not supports half mode!\n                S.iwidth = S.width;\n                S.iheight= S.height;\n                IO.shrink = 0;\n\t\t\t\tS.raw_pitch = S.width*8;\n                // allocate image as temporary buffer, size \n                imgdata.rawdata.raw_alloc = calloc(S.iwidth*S.iheight,sizeof(*imgdata.image));\n                imgdata.image = (ushort (*)[4]) imgdata.rawdata.raw_alloc;\n              }\n            ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n\n\t\t\tunsigned m_save = C.maximum;\n\t\t\tif(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))\n\t\t\t\tC.maximum=65535;\n            (this->*load_raw)();\n\t\t\tif(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))\n\t\t\t\tC.maximum = m_save;\n          }\n\n        if(imgdata.rawdata.raw_image)\n          crop_masked_pixels(); // calculate black levels\n\n        // recover saved\n        if( (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY) && !imgdata.rawdata.color4_image)\n            {\n                imgdata.image = 0; \n                imgdata.rawdata.color4_image = (ushort (*)[4]) imgdata.rawdata.raw_alloc;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "              }\n            else if (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n              {\n                // sRAW and Foveon only, so extra buffer size is just 1/4\n                // Legacy converters does not supports half mode!\n                S.iwidth = S.width;\n                S.iheight= S.height;\n                IO.shrink = 0;\n\t\t\t\tS.raw_pitch = S.width*8;\n                // allocate image as temporary buffer, size \n                imgdata.rawdata.raw_alloc = 0;\n                imgdata.image = (ushort (*)[4]) calloc(S.iwidth*S.iheight,sizeof(*imgdata.image));\n              }\n            ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n\n\t\t\tunsigned m_save = C.maximum;\n\t\t\tif(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))\n\t\t\t\tC.maximum=65535;\n            (this->*load_raw)();\n\t\t\tif(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))\n\t\t\t\tC.maximum = m_save;\n\t\t\tif (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n\t\t\t{\n\t\t\t\t// successfully decoded legacy image, attach image to raw_alloc\n\t\t\t\timgdata.rawdata.raw_alloc = imgdata.image;\n\t\t\t\timgdata.image = 0; \n\t\t\t}\n          }\n\n        if(imgdata.rawdata.raw_image)\n          crop_masked_pixels(); // calculate black levels\n\n        // recover saved\n        if( (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY) && !imgdata.rawdata.color4_image)\n            {\n                imgdata.image = 0; \n                imgdata.rawdata.color4_image = (ushort (*)[4]) imgdata.rawdata.raw_alloc;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t  int noblock, int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)msg->msg_name;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (addr_len)\n\t\t*addr_len=sizeof(*sin6);\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len);\n\n\tif (np->rxpmtu && np->rxopt.bits.rxpmtu)\n\t\treturn ipv6_recv_rxpmtu(sk, msg, len);\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\tif (err)\n\t\tgoto out_free;\n\n\t/* Copy the address. */\n\tif (sin6) {\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = 0;\n\t\tsin6->sin6_addr = ipv6_hdr(skb)->saddr;\n\t\tsin6->sin6_flowinfo = 0;\n\t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t\t  IP6CB(skb)->iif);\n\t}\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\n\terr = copied;\n\tif (flags & MSG_TRUNC)\n\t\terr = skb->len;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t  struct msghdr *msg, size_t len,\n\t\t  int noblock, int flags, int *addr_len)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)msg->msg_name;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len);\n\n\tif (np->rxpmtu && np->rxopt.bits.rxpmtu)\n\t\treturn ipv6_recv_rxpmtu(sk, msg, len);\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\t\tgoto out_free;\n\n\t/* Copy the address. */\n\tif (sin6) {\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = 0;\n\t\tsin6->sin6_addr = ipv6_hdr(skb)->saddr;\n\t\tsin6->sin6_flowinfo = 0;\n\t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t\t  IP6CB(skb)->iif);\n\t\t*addr_len = sizeof(*sin6);\n\t}\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (np->rxopt.all)\n\t\tip6_datagram_recv_ctl(sk, msg, skb);\n\n\terr = copied;\n\tif (flags & MSG_TRUNC)\n\t\terr = skb->len;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static CURLcode smtp_connect(struct connectdata *conn,\n                             bool *done) /* see description above */\n{\n  CURLcode result;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  struct SessionHandle *data = conn->data;\n  struct pingpong *pp = &smtpc->pp;\n  const char *path = conn->data->state.path;\n  int len;\n  char localhost[HOSTNAME_MAX + 1];\n\n  *done = FALSE; /* default to not done yet */\n\n  /* If there already is a protocol-specific struct allocated for this\n     sessionhandle, deal with it */\n  Curl_reset_reqproto(conn);\n\n  result = smtp_init(conn);\n  if(CURLE_OK != result)\n  pp->conn = conn;\n\n  if(!*path) {\n    if(!Curl_gethostname(localhost, sizeof localhost))\n      path = localhost;\n    else\n      path = \"localhost\";\n  }\n\n  /* url decode the path and use it as domain with EHLO */\n  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n  if(!smtpc->domain)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* When we connect, we start in the state where we await the server greeting\n   */\n  state(conn, SMTP_SERVERGREET);\n\n  if(data->state.used_interface == Curl_if_multi)\n    result = smtp_multi_statemach(conn, done);\n  else {\n    result = smtp_easy_statemach(conn);\n    if(!result)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static CURLcode smtp_connect(struct connectdata *conn,\n                             bool *done) /* see description above */\n{\n  CURLcode result;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  struct SessionHandle *data = conn->data;\n  struct pingpong *pp = &smtpc->pp;\n  const char *path = conn->data->state.path;\n  char localhost[HOSTNAME_MAX + 1];\n\n  *done = FALSE; /* default to not done yet */\n\n  /* If there already is a protocol-specific struct allocated for this\n     sessionhandle, deal with it */\n  Curl_reset_reqproto(conn);\n\n  result = smtp_init(conn);\n  if(CURLE_OK != result)\n  pp->conn = conn;\n\n  if(!*path) {\n    if(!Curl_gethostname(localhost, sizeof localhost))\n      path = localhost;\n    else\n      path = \"localhost\";\n  }\n\n  /* url decode the path and use it as domain with EHLO */\n  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n  if(result)\n    return result;\n\n  /* When we connect, we start in the state where we await the server greeting\n   */\n  state(conn, SMTP_SERVERGREET);\n\n  if(data->state.used_interface == Curl_if_multi)\n    result = smtp_multi_statemach(conn, done);\n  else {\n    result = smtp_easy_statemach(conn);\n    if(!result)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t\t\t\t\tforce_dts_delta = 22;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflags |= GP_RTP_PCK_SIGNAL_RAP | GP_RTP_PCK_SIGNAL_TS;\n\t\t\t\t\t}\n\n\t\t\t\t\trequired_rate = default_rtp_rate;\n\t\t\t\t}\n\t\t\t\t/*systems streams*/\n\t\t\t\telse if (gf_isom_has_sync_shadows(file, TrackNum) || gf_isom_has_sample_dependency(file, TrackNum)) {\n\t\t\t\t\tflags |= GP_RTP_PCK_SYSTEMS_CAROUSEL;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor*)esd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\thintType = GF_RTP_PAYT_H263;\n\t\t\trequired_rate = 90000;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tOfficialPayloadID = 34;\n\t\t\t/*not 100% compliant (short header is missing) but should still work*/\n\t\t\tcodecid = GF_CODECID_MPEG4_PART2;\n\t\t\tPL_ID = 0x01;\n\t\t\tbreak;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\t\t\t\t}\n\t\t\t\t\t\tflags |= GP_RTP_PCK_SIGNAL_RAP | GP_RTP_PCK_SIGNAL_TS;\n\t\t\t\t\t}\n\n\t\t\t\t\trequired_rate = default_rtp_rate;\n\t\t\t\t}\n\t\t\t\t/*systems streams*/\n\t\t\t\telse if (gf_isom_has_sync_shadows(file, TrackNum) || gf_isom_has_sample_dependency(file, TrackNum)) {\n\t\t\t\t\tflags |= GP_RTP_PCK_SYSTEMS_CAROUSEL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (esd)\n\t\t\t\tgf_odf_desc_del((GF_Descriptor*)esd);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\thintType = GF_RTP_PAYT_H263;\n\t\t\trequired_rate = 90000;\n\t\t\tstreamType = GF_STREAM_VISUAL;\n\t\t\tOfficialPayloadID = 34;\n\t\t\t/*not 100% compliant (short header is missing) but should still work*/\n\t\t\tcodecid = GF_CODECID_MPEG4_PART2;\n\t\t\tPL_ID = 0x01;\n\t\t\tbreak;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "        auto diag_index_size = diag_index.dim_size(0);\n        OP_REQUIRES(\n            context, 0 < diag_index_size && diag_index_size <= 2,\n            errors::InvalidArgument(\n                \"diag_index must have only one or two elements, received \",\n                diag_index_size, \" elements.\"));\n        if (diag_index_size > 1) {\n          upper_diag_index = diag_index.flat<int32>()(1);\n        }\n      }\n      padding_value = context->input(2).flat<T>()(0);\n    }\n    const TensorShape& input_shape = input.shape();\n\n    // Preliminary validation of sizes.\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrixOrHigher(input_shape),\n                errors::InvalidArgument(\n                    \"input must be at least 2-dim, received shape: \",\n                    input.shape().DebugString()));\n\n    // Make sure lower_diag_index and upper_diag_index is valid.",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "        auto diag_index_size = diag_index.dim_size(0);\n        OP_REQUIRES(\n            context, 0 < diag_index_size && diag_index_size <= 2,\n            errors::InvalidArgument(\n                \"diag_index must have only one or two elements, received \",\n                diag_index_size, \" elements.\"));\n        if (diag_index_size > 1) {\n          upper_diag_index = diag_index.flat<int32>()(1);\n        }\n      }\n      const Tensor& padding_in = context->input(2);\n      OP_REQUIRES(context, padding_in.NumElements() == 1,\n                  errors::InvalidArgument(\"Padding must be scalar.\"));\n      padding_value = padding_in.flat<T>()(0);\n    }\n    const TensorShape& input_shape = input.shape();\n\n    // Preliminary validation of sizes.\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrixOrHigher(input_shape),\n                errors::InvalidArgument(\n                    \"input must be at least 2-dim, received shape: \",\n                    input.shape().DebugString()));\n\n    // Make sure lower_diag_index and upper_diag_index is valid.",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int sock_close(struct inode *inode, struct file *filp)\n{\n\tsock_release(SOCKET_I(inode));\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int sock_close(struct inode *inode, struct file *filp)\n{\n\t__sock_release(SOCKET_I(inode), inode);\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tupdate_read_synchronize(update, s);\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\nfail:\n\n\tif (!update_end_paint(update))",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\t\tWLog_ERR(TAG, \"UPDATE_TYPE_PALETTE - update_read_palette() failed\");\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\trc = IFCALLRESULT(FALSE, update->Palette, context, palette_update);\n\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tif (!update_read_synchronize(update, s))\n\t\t\t\tgoto fail;\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\nfail:\n\n\tif (!update_end_paint(update))",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct task_group *tg = cfs_rq->tg;\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg);\n\tu64 amount = 0, min_amount, expires;\n\tint expires_seq;\n\n\t/* note: this is a positive sum as runtime_remaining <= 0 */\n\tmin_amount = sched_cfs_bandwidth_slice() - cfs_rq->runtime_remaining;\n\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\tamount = min_amount;\n\telse {\n\t\tstart_cfs_bandwidth(cfs_b);\n\n\t\tif (cfs_b->runtime > 0) {\n\t\t\tamount = min(cfs_b->runtime, min_amount);\n\t\t\tcfs_b->runtime -= amount;\n\t\t\tcfs_b->idle = 0;\n\t\t}\n\t}\n\texpires_seq = cfs_b->expires_seq;\n\texpires = cfs_b->runtime_expires;\n\traw_spin_unlock(&cfs_b->lock);\n\n\tcfs_rq->runtime_remaining += amount;\n\t/*\n\t * we may have advanced our local expiration to account for allowed\n\t * spread between our sched_clock and the one on which runtime was\n\t * issued.\n\t */\n\tif (cfs_rq->expires_seq != expires_seq) {\n\t\tcfs_rq->expires_seq = expires_seq;\n\t\tcfs_rq->runtime_expires = expires;\n\t}\n\n\treturn cfs_rq->runtime_remaining > 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct task_group *tg = cfs_rq->tg;\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg);\n\tu64 amount = 0, min_amount;\n\n\t/* note: this is a positive sum as runtime_remaining <= 0 */\n\tmin_amount = sched_cfs_bandwidth_slice() - cfs_rq->runtime_remaining;\n\n\traw_spin_lock(&cfs_b->lock);\n\tif (cfs_b->quota == RUNTIME_INF)\n\t\tamount = min_amount;\n\telse {\n\t\tstart_cfs_bandwidth(cfs_b);\n\n\t\tif (cfs_b->runtime > 0) {\n\t\t\tamount = min(cfs_b->runtime, min_amount);\n\t\t\tcfs_b->runtime -= amount;\n\t\t\tcfs_b->idle = 0;\n\t\t}\n\t}\n\traw_spin_unlock(&cfs_b->lock);\n\n\tcfs_rq->runtime_remaining += amount;\n\n\treturn cfs_rq->runtime_remaining > 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void show_object_with_name(FILE *out, struct object *obj,\n\t\t\t   struct strbuf *path, const char *component)\n{\n\tchar *name = path_name(path, component);\n\tchar *p;\n\n\tfprintf(out, \"%s \", oid_to_hex(&obj->oid));\n\tfor (p = name; *p && *p != '\\n'; p++)\n\t\tfputc(*p, out);\n\tfputc('\\n', out);\n\n\tfree(name);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void show_object_with_name(FILE *out, struct object *obj, const char *name)\n{\n\tconst char *p;\n\n\tfprintf(out, \"%s \", oid_to_hex(&obj->oid));\n\tfor (p = name; *p && *p != '\\n'; p++)\n\t\tfputc(*p, out);\n\tfputc('\\n', out);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TfLiteStatus EvalQuantized(TfLiteContext* context, TfLiteNode* node,\n                           OpData* data, const RuntimeShape& lhs_shape,\n                           const TfLiteTensor* lhs,\n                           const RuntimeShape& rhs_shape,\n                           const TfLiteTensor* rhs, TfLiteTensor* output) {\n  if (lhs->type == kTfLiteFloat32) {\n    TfLiteTensor* input_quantized = GetTemporary(context, node, /*index=*/2);\n    TfLiteTensor* scaling_factors = GetTemporary(context, node, /*index=*/3);\n    TfLiteTensor* accum_scratch = GetTemporary(context, node, /*index=*/4);\n    TfLiteTensor* input_offsets = GetTemporary(context, node, /*index=*/5);\n    TfLiteTensor* row_sums = GetTemporary(context, node, /*index=*/6);\n    return EvalHybrid<kernel_type>(\n        context, node, data, lhs_shape, lhs, rhs_shape, rhs, input_quantized,\n        scaling_factors, accum_scratch, row_sums, input_offsets, output);\n  } else if (lhs->type == kTfLiteInt8) {\n    return EvalInt8<kernel_type>(context, data, lhs_shape, lhs, rhs_shape, rhs,\n                                 GetTensorShape(output), output);\n  } else {\n    TF_LITE_KERNEL_LOG(\n        context, \"Currently only hybrid and int8 quantization is supported.\\n\");\n    return kTfLiteError;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus EvalQuantized(TfLiteContext* context, TfLiteNode* node,\n                           OpData* data, const RuntimeShape& lhs_shape,\n                           const TfLiteTensor* lhs,\n                           const RuntimeShape& rhs_shape,\n                           const TfLiteTensor* rhs, TfLiteTensor* output) {\n  if (lhs->type == kTfLiteFloat32) {\n    TfLiteTensor* input_quantized;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/2,\n                                                &input_quantized));\n    TfLiteTensor* scaling_factors;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/3,\n                                                &scaling_factors));\n    TfLiteTensor* accum_scratch;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, /*index=*/4, &accum_scratch));\n    TfLiteTensor* input_offsets;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, /*index=*/5, &input_offsets));\n    TfLiteTensor* row_sums;\n    TF_LITE_ENSURE_OK(context,\n                      GetTemporarySafe(context, node, /*index=*/6, &row_sums));\n    return EvalHybrid<kernel_type>(\n        context, node, data, lhs_shape, lhs, rhs_shape, rhs, input_quantized,\n        scaling_factors, accum_scratch, row_sums, input_offsets, output);\n  } else if (lhs->type == kTfLiteInt8) {\n    return EvalInt8<kernel_type>(context, data, lhs_shape, lhs, rhs_shape, rhs,\n                                 GetTensorShape(output), output);\n  } else {\n    TF_LITE_KERNEL_LOG(\n        context, \"Currently only hybrid and int8 quantization is supported.\\n\");\n    return kTfLiteError;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tint err = -EINVAL;\n\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\tid = kcontrol->id;\n\tdown_write(&card->controls_rwsem);\n\tif (snd_ctl_find_id(card, &id)) {\n\t\tup_write(&card->controls_rwsem);\n\t\tgoto error;\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tunsigned int count;\n\tint err = -EINVAL;\n\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\tid = kcontrol->id;\n\tdown_write(&card->controls_rwsem);\n\tif (snd_ctl_find_id(card, &id)) {\n\t\tup_write(&card->controls_rwsem);\n\t}\n\tif (snd_ctl_find_hole(card, kcontrol->count) < 0) {\n\t\tup_write(&card->controls_rwsem);\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tcount = kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n\n error:\n\tsnd_ctl_free_one(kcontrol);\n\treturn err;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    cm->width = cpi->oxcf.width;\n    cm->height = cpi->oxcf.height;\n    cpi->external_resize = 1;\n  }\n\n  if (cpi->initial_width) {\n    int new_mi_size = 0;\n    vp9_set_mb_mi(cm, cm->width, cm->height);\n    new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n    if (cm->mi_alloc_size < new_mi_size) {\n      vp9_free_context_buffers(cm);\n      alloc_compressor_data(cpi);\n      realloc_segmentation_maps(cpi);\n      cpi->initial_width = cpi->initial_height = 0;\n      cpi->external_resize = 0;\n    } else if (cm->mi_alloc_size == new_mi_size &&\n               (cpi->oxcf.width > last_w || cpi->oxcf.height > last_h)) {\n      if (vp9_alloc_loop_filter(cm)) {\n        vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                           \"Failed to allocate loop filter data\");\n      }\n    }\n  }\n\n  if (cm->current_video_frame == 0 || last_w != cpi->oxcf.width ||\n      last_h != cpi->oxcf.height)\n    update_frame_size(cpi);\n\n  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n    memset(cpi->consec_zero_mv, 0,\n           cm->mi_rows * cm->mi_cols * sizeof(*cpi->consec_zero_mv));\n    if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)\n      vp9_cyclic_refresh_reset_resize(cpi);\n    rc->rc_1_frame = 0;\n    rc->rc_2_frame = 0;\n  }\n\n  if ((cpi->svc.number_temporal_layers > 1) ||\n      ((cpi->svc.number_temporal_layers > 1 ||\n        cpi->svc.number_spatial_layers > 1) &&\n       cpi->oxcf.pass != 1)) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    cm->height = cpi->oxcf.height;\n    cpi->external_resize = 1;\n  }\n\n  if (cpi->initial_width) {\n    int new_mi_size = 0;\n    vp9_set_mb_mi(cm, cm->width, cm->height);\n    new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n    if (cm->mi_alloc_size < new_mi_size) {\n      vp9_free_context_buffers(cm);\n      vp9_free_pc_tree(&cpi->td);\n      vpx_free(cpi->mbmi_ext_base);\n      alloc_compressor_data(cpi);\n      realloc_segmentation_maps(cpi);\n      cpi->initial_width = cpi->initial_height = 0;\n      cpi->external_resize = 0;\n    } else if (cm->mi_alloc_size == new_mi_size &&\n               (cpi->oxcf.width > last_w || cpi->oxcf.height > last_h)) {\n      if (vp9_alloc_loop_filter(cm)) {\n        vpx_internal_error(&cm->error, VPX_CODEC_MEM_ERROR,\n                           \"Failed to allocate loop filter data\");\n      }\n    }\n  }\n\n  if (cm->current_video_frame == 0 || last_w != cpi->oxcf.width ||\n      last_h != cpi->oxcf.height)\n    update_frame_size(cpi);\n\n  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n    vpx_free(cpi->consec_zero_mv);\n    CHECK_MEM_ERROR(\n        cm, cpi->consec_zero_mv,\n        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(*cpi->consec_zero_mv)));\n\n    vpx_free(cpi->skin_map);\n    CHECK_MEM_ERROR(\n        cm, cpi->skin_map,\n        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(cpi->skin_map[0])));\n\n    free_copy_partition_data(cpi);\n    alloc_copy_partition_data(cpi);\n    if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)\n      vp9_cyclic_refresh_reset_resize(cpi);\n    rc->rc_1_frame = 0;\n    rc->rc_2_frame = 0;\n  }\n\n  if ((cpi->svc.number_temporal_layers > 1) ||\n      ((cpi->svc.number_temporal_layers > 1 ||\n        cpi->svc.number_spatial_layers > 1) &&\n       cpi->oxcf.pass != 1)) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tif (offset >= virtio_config_size) {\n\t\t/*\n\t\t * Subtract off the standard size (including MSI-X\n\t\t * registers if enabled) and dispatch to underlying driver.\n\t\t * If that fails, fall into general code.\n\t\t */\n\t\tnewoff = (uint32_t) (offset - virtio_config_size);\n\t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize : 0x100000000;\n\t\tif ((newoff + ((unsigned) size)) > max)\n\t\t\tgoto bad;\n\t\terror = (*vc->vc_cfgread)(DEV_SOFTC(vs), ((int) newoff), size, &value);\n\t\tif (!error)\n\t\t\tgoto done;\n\t}\n\nbad:\n\tcr = vi_find_cr((int) offset);\n\tif (cr == NULL || cr->cr_size != size) {\n\t\tif (cr != NULL) {\n\t\t\t/* offset must be OK, so size must be bad */\n\t\t\tfprintf(stderr,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tif (offset >= virtio_config_size) {\n\t\t/*\n\t\t * Subtract off the standard size (including MSI-X\n\t\t * registers if enabled) and dispatch to underlying driver.\n\t\t * If that fails, fall into general code.\n\t\t */\n\t\tnewoff = (uint32_t) (offset - virtio_config_size);\n\t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize : 0x100000000;\n\t\tif ((newoff + ((unsigned) size)) > max)\n\t\t\tgoto bad;\n\t\tif (vc->vc_cfgread != NULL)\n\t\t\terror = (*vc->vc_cfgread)(DEV_SOFTC(vs), ((int) newoff), size, &value);\n\t\telse\n\t\t\terror = 0;\n\t\tif (!error)\n\t\t\tgoto done;\n\t}\n\nbad:\n\tcr = vi_find_cr((int) offset);\n\tif (cr == NULL || cr->cr_size != size) {\n\t\tif (cr != NULL) {\n\t\t\t/* offset must be OK, so size must be bad */\n\t\t\tfprintf(stderr,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tutils::run_interactively(cmdline, \"pb_controller::play_file\");\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" '\");\n\tcmdline.append(utils::replace_all(file,\"'\", \"%27\"));\n\tcmdline.append(\"'\");\n\tstfl::reset();\n\tutils::run_interactively(cmdline, \"pb_controller::play_file\");\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "compile_nested_function(exarg_T *eap, cctx_T *cctx)\n{\n    int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';\n    char_u\t*name_start = eap->arg;\n    char_u\t*name_end = to_name_end(eap->arg, TRUE);\n    char_u\t*lambda_name;\n    ufunc_T\t*ufunc;\n    int\t\tr = FAIL;\n    compiletype_T   compile_type;\n\n    if (eap->forceit)\n    {\n\temsg(_(e_cannot_use_bang_with_nested_def));\n\treturn NULL;\n    }\n\treturn NULL;\n\n    eap->arg = name_end;\n    fill_exarg_from_cctx(eap, cctx);\n\n    eap->forceit = FALSE;\n    // We use the special <Lamba>99 name, but it's not really a lambda.\n    lambda_name = vim_strsave(get_lambda_name());\n    if (lambda_name == NULL)\n\treturn NULL;\n    ufunc = define_function(eap, lambda_name);\n\n    if (ufunc == NULL)\n    {\n\tr = eap->skip ? OK : FAIL;\n\tgoto theend;\n    }\n\n    // copy over the block scope IDs before compiling\n    if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)\n    {\n\n#ifdef FEAT_PROFILE\n    // When the outer function is compiled for profiling, the nested function\n    // may be called without profiling.  Compile it here in the right context.\n    if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))\n\tcompile_def_function(ufunc, FALSE, CT_NONE, cctx);\n#endif\n\n    if (is_global)\n    {\n\tchar_u *func_name = vim_strnsave(name_start + 2,\n\t\t\t\t\t\t    name_end - name_start - 2);\n\n\tif (func_name == NULL)\n\t    r = FAIL;\n\telse\n\t{\n\t    r = generate_NEWFUNC(cctx, lambda_name, func_name);\n\t    lambda_name = NULL;\n\t}\n    }\n    else\n    {\n\t// Define a local variable for the function reference.\n\tlvar_T\t*lvar = reserve_local(cctx, name_start, name_end - name_start,\n\t\t\t\t\t\t    TRUE, ufunc->uf_func_type);\n\n\tif (lvar == NULL)\n\t    goto theend;\n\tif (generate_FUNCREF(cctx, ufunc) == FAIL)\n\t    goto theend;\n\tr = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);\n    }\n\ntheend:\n    vim_free(lambda_name);\n    return r == FAIL ? NULL : (char_u *)\"\";\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "compile_nested_function(exarg_T *eap, cctx_T *cctx, char_u **line_to_free)\n{\n    int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';\n    char_u\t*name_start = eap->arg;\n    char_u\t*name_end = to_name_end(eap->arg, TRUE);\n    int\t\toff;\n    char_u\t*func_name;\n    char_u\t*lambda_name;\n    ufunc_T\t*ufunc;\n    int\t\tr = FAIL;\n    compiletype_T   compile_type;\n\n    if (eap->forceit)\n    {\n\temsg(_(e_cannot_use_bang_with_nested_def));\n\treturn NULL;\n    }\n\treturn NULL;\n\n    eap->arg = name_end;\n    fill_exarg_from_cctx(eap, cctx);\n\n    eap->forceit = FALSE;\n    // We use the special <Lamba>99 name, but it's not really a lambda.\n    lambda_name = vim_strsave(get_lambda_name());\n    if (lambda_name == NULL)\n\treturn NULL;\n\n    // This may free the current line, make a copy of the name.\n    off = is_global ? 2 : 0;\n    func_name = vim_strnsave(name_start + off, name_end - name_start - off);\n    if (func_name == NULL)\n    {\n\tr = FAIL;\n\tgoto theend;\n    }\n\n    ufunc = define_function(eap, lambda_name, line_to_free);\n\n    if (ufunc == NULL)\n    {\n\tr = eap->skip ? OK : FAIL;\n\tgoto theend;\n    }\n\n    // copy over the block scope IDs before compiling\n    if (!is_global && cctx->ctx_ufunc->uf_block_depth > 0)\n    {\n\n#ifdef FEAT_PROFILE\n    // When the outer function is compiled for profiling, the nested function\n    // may be called without profiling.  Compile it here in the right context.\n    if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))\n\tcompile_def_function(ufunc, FALSE, CT_NONE, cctx);\n#endif\n\n    if (is_global)\n    {\n\tr = generate_NEWFUNC(cctx, lambda_name, func_name);\n\tfunc_name = NULL;\n\tlambda_name = NULL;\n    }\n    else\n    {\n\t// Define a local variable for the function reference.\n\tlvar_T\t*lvar = reserve_local(cctx, func_name, name_end - name_start,\n\t\t\t\t\t\t    TRUE, ufunc->uf_func_type);\n\n\tif (lvar == NULL)\n\t    goto theend;\n\tif (generate_FUNCREF(cctx, ufunc) == FAIL)\n\t    goto theend;\n\tr = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);\n    }\n\ntheend:\n    vim_free(lambda_name);\n    vim_free(func_name);\n    return r == FAIL ? NULL : (char_u *)\"\";\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "        {\"Author\",       \"\"},\n        {\"Subject\",      \"\"},\n        {\"Keywords\",     \"\"},\n        {\"Creator\",      \"\"},\n        {\"Producer\",     \"\"},\n        {\"CreationDate\", \"\"},\n        {\"ModDate\",      \"\"},\n        {\"Trapped\",      \"\"},\n    };\n\n    daddy = malloc(sizeof(creator_template));\n    memcpy(daddy, creator_template, sizeof(creator_template));\n\n    if (n_elements)\n      *n_elements = sizeof(creator_template) / sizeof(creator_template[0]);\n\n    return daddy;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "        {\"Author\",       \"\"},\n        {\"Subject\",      \"\"},\n        {\"Keywords\",     \"\"},\n        {\"Creator\",      \"\"},\n        {\"Producer\",     \"\"},\n        {\"CreationDate\", \"\"},\n        {\"ModDate\",      \"\"},\n        {\"Trapped\",      \"\"},\n    };\n\n    daddy = safe_calloc(sizeof(creator_template));\n    memcpy(daddy, creator_template, sizeof(creator_template));\n\n    if (n_elements)\n      *n_elements = sizeof(creator_template) / sizeof(creator_template[0]);\n\n    return daddy;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "inline void AveragePool(const PoolParams& params,\n                        const RuntimeShape& input_shape, const int8* input_data,\n                        const RuntimeShape& output_shape, int8* output_data) {\n  ruy::profiler::ScopeLabel label(\"AveragePool/8bitWith32bitAccumulator\");\n\n  // Here, and in other pooling ops, in order to maintain locality of reference,\n  // to minimize some recalculations, and to load into NEON vector registers, we\n  // use an inner loop down the depth. Since depths can be large and hence we\n  // would need arbitrarily large temporary storage, we divide the work up into\n  // depth tranches just within the batch loop.\n  static constexpr int kPoolingAccTrancheSize = 256;\n\n  TFLITE_DCHECK_LE(params.quantized_activation_min,\n                   params.quantized_activation_max);\n  TFLITE_DCHECK_EQ(input_shape.DimensionsCount(), 4);\n  TFLITE_DCHECK_EQ(output_shape.DimensionsCount(), 4);\n  const int batches = MatchingDim(input_shape, 0, output_shape, 0);\n  const int depth = MatchingDim(input_shape, 3, output_shape, 3);\n  const int input_height = input_shape.Dims(1);\n  const int input_width = input_shape.Dims(2);\n  const int output_height = output_shape.Dims(1);\n  const int output_width = output_shape.Dims(2);\n  const int stride_height = params.stride_height;\n  const int stride_width = params.stride_width;\n\n  int32 acc[kPoolingAccTrancheSize];\n  for (int batch = 0; batch < batches; ++batch) {\n    // We proceed through the depth in tranches (see comment above). The\n    // depth_base is the depth at the beginning of the tranche. The\n    // tranche_depth is the depth dimension of the tranche.\n    for (int depth_base = 0; depth_base < depth;\n         depth_base += kPoolingAccTrancheSize) {\n      const int tranche_depth =\n          std::min(depth - depth_base, kPoolingAccTrancheSize);\n      for (int out_y = 0; out_y < output_height; ++out_y) {\n        for (int out_x = 0; out_x < output_width; ++out_x) {\n          const int in_x_origin =\n              (out_x * stride_width) - params.padding_values.width;\n          const int in_y_origin =\n              (out_y * stride_height) - params.padding_values.height;\n          const int filter_x_start = std::max(0, -in_x_origin);\n          const int filter_x_end =\n              std::min(params.filter_width, input_width - in_x_origin);\n          const int filter_y_start = std::max(0, -in_y_origin);\n          const int filter_y_end =\n              std::min(params.filter_height, input_height - in_y_origin);\n          const int filter_count =\n              (filter_x_end - filter_x_start) * (filter_y_end - filter_y_start);\n          memset(acc, 0, tranche_depth * sizeof(acc[0]));\n          const int8* input_ptr =\n              input_data + depth_base +\n              depth * (in_x_origin +\n                       input_width * (in_y_origin + input_height * batch));\n          for (int fy = filter_y_start; fy < filter_y_end; fy++) {\n            const int8* input_row_ptr =\n                input_ptr + depth * (fy * input_width + filter_x_start);\n            for (int fx = filter_x_start; fx < filter_x_end; fx++) {\n              const int8* input_channel_ptr = input_row_ptr;\n              int channel = 0;\n#ifdef USE_NEON\n              for (; channel <= tranche_depth - 16; channel += 16) {\n                int16x4_t acc_reg[4];\n                int8x16_t input_reg = vld1q_s8(input_channel_ptr);\n                input_channel_ptr += 16;\n                acc_reg[0] = vget_low_s16(vmovl_s8(vget_low_s8(input_reg)));\n                acc_reg[1] = vget_high_s16(vmovl_s8(vget_low_s8(input_reg)));\n                acc_reg[2] = vget_low_s16(vmovl_s8(vget_high_s8(input_reg)));\n                acc_reg[3] = vget_high_s16(vmovl_s8(vget_high_s8(input_reg)));\n                for (int i = 0; i < 4; i++) {\n                  vst1q_s32(\n                      acc + channel + 4 * i,\n                      vaddw_s16(vld1q_s32(acc + channel + 4 * i), acc_reg[i]));\n                }\n              }\n              for (; channel <= tranche_depth - 8; channel += 8) {\n                int16x4_t acc_reg[2];\n                int16x8_t input_reg = vmovl_s8(vld1_s8(input_channel_ptr));\n                input_channel_ptr += 8;\n                acc_reg[0] = vget_low_s16(input_reg);\n                acc_reg[1] = vget_high_s16(input_reg);\n                for (int i = 0; i < 2; i++) {\n                  vst1q_s32(\n                      acc + channel + 4 * i,\n                      vaddw_s16(vld1q_s32(acc + channel + 4 * i), acc_reg[i]));\n                }\n              }\n#endif\n              for (; channel < tranche_depth; ++channel) {\n                acc[channel] += *input_channel_ptr++;\n              }\n              input_row_ptr += depth;\n            }\n          }\n          int8* output_ptr = output_data + Offset(output_shape, batch, out_y,\n                                                  out_x, depth_base);\n          int channel = 0;\n#ifdef USE_NEON\n          for (; channel <= tranche_depth - 8; channel += 8) {\n            int16 buf[8];\n            for (int i = 0; i < 8; i++) {\n              buf[i] =\n                  acc[channel + i] > 0\n                      ? (acc[channel + i] + filter_count / 2) / filter_count\n                      : (acc[channel + i] - filter_count / 2) / filter_count;\n            }\n            int8x8_t buf8 = vqmovn_s16(vld1q_s16(buf));\n            buf8 = vmin_s8(buf8, vdup_n_s8(params.quantized_activation_max));\n            buf8 = vmax_s8(buf8, vdup_n_s8(params.quantized_activation_min));\n            vst1_s8(output_ptr + channel, buf8);\n          }\n#endif\n          for (; channel < tranche_depth; ++channel) {\n            int16 a = acc[channel] > 0\n                          ? (acc[channel] + filter_count / 2) / filter_count\n                          : (acc[channel] - filter_count / 2) / filter_count;\n            a = std::max<int16>(a, params.quantized_activation_min);\n            a = std::min<int16>(a, params.quantized_activation_max);\n            output_ptr[channel] = static_cast<int8>(a);\n          }\n        }\n      }\n    }\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "inline bool AveragePool(const PoolParams& params,\n                        const RuntimeShape& input_shape, const int8* input_data,\n                        const RuntimeShape& output_shape, int8* output_data) {\n  ruy::profiler::ScopeLabel label(\"AveragePool/8bitWith32bitAccumulator\");\n\n  // Here, and in other pooling ops, in order to maintain locality of reference,\n  // to minimize some recalculations, and to load into NEON vector registers, we\n  // use an inner loop down the depth. Since depths can be large and hence we\n  // would need arbitrarily large temporary storage, we divide the work up into\n  // depth tranches just within the batch loop.\n  static constexpr int kPoolingAccTrancheSize = 256;\n\n  TFLITE_DCHECK_LE(params.quantized_activation_min,\n                   params.quantized_activation_max);\n  TFLITE_DCHECK_EQ(input_shape.DimensionsCount(), 4);\n  TFLITE_DCHECK_EQ(output_shape.DimensionsCount(), 4);\n  const int batches = MatchingDim(input_shape, 0, output_shape, 0);\n  const int depth = MatchingDim(input_shape, 3, output_shape, 3);\n  const int input_height = input_shape.Dims(1);\n  const int input_width = input_shape.Dims(2);\n  const int output_height = output_shape.Dims(1);\n  const int output_width = output_shape.Dims(2);\n  const int stride_height = params.stride_height;\n  const int stride_width = params.stride_width;\n\n  int32 acc[kPoolingAccTrancheSize];\n  for (int batch = 0; batch < batches; ++batch) {\n    // We proceed through the depth in tranches (see comment above). The\n    // depth_base is the depth at the beginning of the tranche. The\n    // tranche_depth is the depth dimension of the tranche.\n    for (int depth_base = 0; depth_base < depth;\n         depth_base += kPoolingAccTrancheSize) {\n      const int tranche_depth =\n          std::min(depth - depth_base, kPoolingAccTrancheSize);\n      for (int out_y = 0; out_y < output_height; ++out_y) {\n        for (int out_x = 0; out_x < output_width; ++out_x) {\n          const int in_x_origin =\n              (out_x * stride_width) - params.padding_values.width;\n          const int in_y_origin =\n              (out_y * stride_height) - params.padding_values.height;\n          const int filter_x_start = std::max(0, -in_x_origin);\n          const int filter_x_end =\n              std::min(params.filter_width, input_width - in_x_origin);\n          const int filter_y_start = std::max(0, -in_y_origin);\n          const int filter_y_end =\n              std::min(params.filter_height, input_height - in_y_origin);\n          const int filter_count =\n              (filter_x_end - filter_x_start) * (filter_y_end - filter_y_start);\n          if (filter_count == 0) return false;\n          memset(acc, 0, tranche_depth * sizeof(acc[0]));\n          const int8* input_ptr =\n              input_data + depth_base +\n              depth * (in_x_origin +\n                       input_width * (in_y_origin + input_height * batch));\n          for (int fy = filter_y_start; fy < filter_y_end; fy++) {\n            const int8* input_row_ptr =\n                input_ptr + depth * (fy * input_width + filter_x_start);\n            for (int fx = filter_x_start; fx < filter_x_end; fx++) {\n              const int8* input_channel_ptr = input_row_ptr;\n              int channel = 0;\n#ifdef USE_NEON\n              for (; channel <= tranche_depth - 16; channel += 16) {\n                int16x4_t acc_reg[4];\n                int8x16_t input_reg = vld1q_s8(input_channel_ptr);\n                input_channel_ptr += 16;\n                acc_reg[0] = vget_low_s16(vmovl_s8(vget_low_s8(input_reg)));\n                acc_reg[1] = vget_high_s16(vmovl_s8(vget_low_s8(input_reg)));\n                acc_reg[2] = vget_low_s16(vmovl_s8(vget_high_s8(input_reg)));\n                acc_reg[3] = vget_high_s16(vmovl_s8(vget_high_s8(input_reg)));\n                for (int i = 0; i < 4; i++) {\n                  vst1q_s32(\n                      acc + channel + 4 * i,\n                      vaddw_s16(vld1q_s32(acc + channel + 4 * i), acc_reg[i]));\n                }\n              }\n              for (; channel <= tranche_depth - 8; channel += 8) {\n                int16x4_t acc_reg[2];\n                int16x8_t input_reg = vmovl_s8(vld1_s8(input_channel_ptr));\n                input_channel_ptr += 8;\n                acc_reg[0] = vget_low_s16(input_reg);\n                acc_reg[1] = vget_high_s16(input_reg);\n                for (int i = 0; i < 2; i++) {\n                  vst1q_s32(\n                      acc + channel + 4 * i,\n                      vaddw_s16(vld1q_s32(acc + channel + 4 * i), acc_reg[i]));\n                }\n              }\n#endif\n              for (; channel < tranche_depth; ++channel) {\n                acc[channel] += *input_channel_ptr++;\n              }\n              input_row_ptr += depth;\n            }\n          }\n          int8* output_ptr = output_data + Offset(output_shape, batch, out_y,\n                                                  out_x, depth_base);\n          int channel = 0;\n#ifdef USE_NEON\n          for (; channel <= tranche_depth - 8; channel += 8) {\n            int16 buf[8];\n            for (int i = 0; i < 8; i++) {\n              buf[i] =\n                  acc[channel + i] > 0\n                      ? (acc[channel + i] + filter_count / 2) / filter_count\n                      : (acc[channel + i] - filter_count / 2) / filter_count;\n            }\n            int8x8_t buf8 = vqmovn_s16(vld1q_s16(buf));\n            buf8 = vmin_s8(buf8, vdup_n_s8(params.quantized_activation_max));\n            buf8 = vmax_s8(buf8, vdup_n_s8(params.quantized_activation_min));\n            vst1_s8(output_ptr + channel, buf8);\n          }\n#endif\n          for (; channel < tranche_depth; ++channel) {\n            int16 a = acc[channel] > 0\n                          ? (acc[channel] + filter_count / 2) / filter_count\n                          : (acc[channel] - filter_count / 2) / filter_count;\n            a = std::max<int16>(a, params.quantized_activation_min);\n            a = std::min<int16>(a, params.quantized_activation_max);\n            output_ptr[channel] = static_cast<int8>(a);\n          }\n        }\n      }\n    }\n  }\n  return true;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tport = args->args[0];\n\tidx = args->args[1];\n\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\n\t\t/* SERDES6G(0) is the only SerDes capable of QSGMII */\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\t\tmacro->port = port;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "{\n\tstruct serdes_ctrl *ctrl = dev_get_drvdata(dev);\n\tunsigned int port, idx, i;\n\n\tif (args->args_count != 2)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tport = args->args[0];\n\tidx = args->args[1];\n\n\tfor (i = 0; i < SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n\n\t\t/* SERDES6G(0) is the only SerDes capable of QSGMII */\n\t\tif (idx != SERDES6G(0) && macro->port >= 0)\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\t\tmacro->port = port;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n        nodeRename(x, ext.rename_array, ext);\n\n        if(ext.add_emoji)\n            x.Remark = addEmoji(x, ext.emoji_array, ext);\n    });\n\n    if(ext.sort_flag)\n    {\n        bool failed = true;\n        if(ext.sort_script.size())\n        {\n            std::string script = ext.sort_script;\n            if(startsWith(script, \"path:\"))\n                script = fileGet(script.substr(5), false);\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                try\n                {\n                    ctx.eval(script);\n                    auto compare = (std::function<int(const Proxy&, const Proxy&)>) ctx.eval(\"compare\");",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n        nodeRename(x, ext.rename_array, ext);\n\n        if(ext.add_emoji)\n            x.Remark = addEmoji(x, ext.emoji_array, ext);\n    });\n\n    if(ext.sort_flag)\n    {\n        bool failed = true;\n        if(ext.sort_script.size() && ext.authorized)\n        {\n            std::string script = ext.sort_script;\n            if(startsWith(script, \"path:\"))\n                script = fileGet(script.substr(5), false);\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)\n            {\n                try\n                {\n                    ctx.eval(script);\n                    auto compare = (std::function<int(const Proxy&, const Proxy&)>) ctx.eval(\"compare\");",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int rawsock_create(struct net *net, struct socket *sock,\n\t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"sock=%p\\n\", sock);\n\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &rawsock_raw_ops;\n\telse\n\t\tsock->ops = &rawsock_ops;\n\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsk->sk_protocol = nfc_proto->id;\n\tsk->sk_destruct = rawsock_destruct;\n\tsock->state = SS_UNCONNECTED;\n\tif (sock->type == SOCK_RAW)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int rawsock_create(struct net *net, struct socket *sock,\n\t\t\t  const struct nfc_protocol *nfc_proto, int kern)\n{\n\tstruct sock *sk;\n\n\tpr_debug(\"sock=%p\\n\", sock);\n\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW) {\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tsock->ops = &rawsock_raw_ops;\n\t} else {\n\t\tsock->ops = &rawsock_ops;\n\t}\n\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tsock_init_data(sock, sk);\n\tsk->sk_protocol = nfc_proto->id;\n\tsk->sk_destruct = rawsock_destruct;\n\tsock->state = SS_UNCONNECTED;\n\tif (sock->type == SOCK_RAW)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "        case YYJSON_TYPE_OBJ: {\n            usize len = unsafe_yyjson_get_len(lhs);\n            if (len != unsafe_yyjson_get_len(rhs)) return false;\n            if (len > 0) {\n                yyjson_mut_obj_iter iter;\n                yyjson_mut_obj_iter_init(rhs, &iter);\n                lhs = (yyjson_mut_val *)lhs->uni.ptr;\n                while (len-- > 0) {\n                    rhs = yyjson_mut_obj_iter_getn(&iter, lhs->uni.str,\n                                                   unsafe_yyjson_get_len(lhs));\n                    if (!rhs || !unsafe_yyjson_mut_equals(lhs->next, rhs))\n                        return false;\n                    lhs = lhs->next->next;\n                }\n            }\n            /* yyjson allows duplicate keys, so the check may be inaccurate */\n            return true;\n        }\n        \n        case YYJSON_TYPE_ARR: {\n            usize len = unsafe_yyjson_get_len(lhs);\n            if (len != unsafe_yyjson_get_len(rhs)) return false;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "        case YYJSON_TYPE_OBJ: {\n            usize len = unsafe_yyjson_get_len(lhs);\n            if (len != unsafe_yyjson_get_len(rhs)) return false;\n            if (len > 0) {\n                yyjson_mut_obj_iter iter;\n                yyjson_mut_obj_iter_init(rhs, &iter);\n                lhs = (yyjson_mut_val *)lhs->uni.ptr;\n                while (len-- > 0) {\n                    rhs = yyjson_mut_obj_iter_getn(&iter, lhs->uni.str,\n                                                   unsafe_yyjson_get_len(lhs));\n                    if (!rhs) return false;\n                    if (!unsafe_yyjson_mut_equals(lhs->next, rhs)) return false;\n                    lhs = lhs->next->next;\n                }\n            }\n            /* yyjson allows duplicate keys, so the check may be inaccurate */\n            return true;\n        }\n        \n        case YYJSON_TYPE_ARR: {\n            usize len = unsafe_yyjson_get_len(lhs);\n            if (len != unsafe_yyjson_get_len(rhs)) return false;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!start)\n\t\treturn true;\n\n\t/* Reject paths like \".git\\\" */\n\tif (path[start] == '\\\\')\n\t\treturn false;\n\n\t/* Reject paths like '.git ' or '.git.' */\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!start)\n\t\treturn true;\n\n\t/*\n\t * Reject paths that start with Windows-style directory separators\n\t * (\".git\\\") or NTFS alternate streams (\".git:\") and could be used\n\t * to write to the \".git\" directory on Windows platforms.\n\t */\n\tif (path[start] == '\\\\' || path[start] == ':')\n\t\treturn false;\n\n\t/* Reject paths like '.git ' or '.git.' */\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "add_mibfile(const char* tmpstr, const char* d_name, FILE *ip )\n{\n    FILE           *fp;\n    char            token[MAXTOKEN], token2[MAXTOKEN];\n\n    /*\n     * which module is this \n     */\n    if ((fp = fopen(tmpstr, \"r\")) == NULL) {\n        snmp_log_perror(tmpstr);\n        return 1;\n    File = tmpstr;\n    if (get_token(fp, token, MAXTOKEN) != LABEL) {\n\t    fclose(fp);\n\t    return 1;\n    }\n    /*\n     * simple test for this being a MIB \n     */\n    if (get_token(fp, token2, MAXTOKEN) == DEFINITIONS) {\n        new_module(token, tmpstr);\n        if (ip)\n            fprintf(ip, \"%s %s\\n\", token, d_name);\n        fclose(fp);\n        return 0;\n    } else {\n        fclose(fp);\n        return 1;\n    }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "add_mibfile(const char* tmpstr, const char* d_name)\n{\n    FILE           *fp;\n    char            token[MAXTOKEN], token2[MAXTOKEN];\n\n    /*\n     * which module is this \n     */\n    if ((fp = fopen(tmpstr, \"r\")) == NULL) {\n        snmp_log_perror(tmpstr);\n        return 1;\n    mibLine = 1;\n    File = tmpstr;\n    if (get_token(fp, token, MAXTOKEN) != LABEL) {\n\t    fclose(fp);\n\t    return 1;\n    }\n    /*\n     * simple test for this being a MIB \n     */\n    if (get_token(fp, token2, MAXTOKEN) == DEFINITIONS) {\n        new_module(token, tmpstr);\n        fclose(fp);\n        return 0;\n    } else {\n        fclose(fp);\n        return 1;\n    }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void ufs_mtk_init_va09_pwr_ctrl(struct ufs_hba *hba)\n{\n\tstruct ufs_mtk_host *host = ufshcd_get_variant(hba);\n\n\thost->reg_va09 = regulator_get(hba->dev, \"va09\");\n\tif (!host->reg_va09)\n\t\tdev_info(hba->dev, \"failed to get va09\");\n\telse\n\t\thost->caps |= UFS_MTK_CAP_VA09_PWR_CTRL;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void ufs_mtk_init_va09_pwr_ctrl(struct ufs_hba *hba)\n{\n\tstruct ufs_mtk_host *host = ufshcd_get_variant(hba);\n\n\thost->reg_va09 = regulator_get(hba->dev, \"va09\");\n\tif (IS_ERR(host->reg_va09))\n\t\tdev_info(hba->dev, \"failed to get va09\");\n\telse\n\t\thost->caps |= UFS_MTK_CAP_VA09_PWR_CTRL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "find_entry2modify_only_ext(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int flags,\n    back_txn *txn\n\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 1/*lock*/, txn, \n\t\t                         FE_REALLY_INTERNAL | flags ));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "find_entry2modify_only_ext(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int flags,\n    back_txn *txn,\n    int *rc\n)\n{\n\treturn(find_entry_internal(pb, be, addr, 1/*lock*/, txn, FE_REALLY_INTERNAL | flags, rc));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void scsi_free_request(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    qemu_vfree(r->iov.iov_base);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void scsi_free_request(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    if (r->iov.iov_base) {\n        qemu_vfree(r->iov.iov_base);\n    }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int masq_inet_event(struct notifier_block *this,\n\t\t\t   unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct net_device *dev = ((struct in_ifaddr *)ptr)->ifa_dev->dev;\n\tstruct netdev_notifier_info info;\n\n\tnetdev_notifier_info_init(&info, dev);\n\treturn masq_device_event(this, event, &info);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int masq_inet_event(struct notifier_block *this,\n\t\t\t   unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct in_device *idev = ((struct in_ifaddr *)ptr)->ifa_dev;\n\tstruct netdev_notifier_info info;\n\n\t/* The masq_dev_notifier will catch the case of the device going\n\t * down.  So if the inetdev is dead and being destroyed we have\n\t * no work to do.  Otherwise this is an individual address removal\n\t * and we have to perform the flush.\n\t */\n\tif (idev->dead)\n\t\treturn NOTIFY_DONE;\n\n\tnetdev_notifier_info_init(&info, idev->dev);\n\treturn masq_device_event(this, event, &info);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void usb_sg_cancel(struct usb_sg_request *io)\n{\n\tunsigned long flags;\n\tint i, retval;\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status) {\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\treturn;\n\t}\n\t/* shut everything down */\n\tio->status = -ECONNRESET;\n\tspin_unlock_irqrestore(&io->lock, flags);\n\n\tfor (i = io->entries - 1; i >= 0; --i) {\n\t\tusb_block_urb(io->urbs[i]);\n\n\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\tif (retval != -EINPROGRESS\n\t\t    && retval != -ENODEV\n\t\t    && retval != -EBUSY\n\t\t    && retval != -EIDRM)\n\t\t\tdev_warn(&io->dev->dev, \"%s, unlink --> %d\\n\",\n\t\t\t\t __func__, retval);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void usb_sg_cancel(struct usb_sg_request *io)\n{\n\tunsigned long flags;\n\tint i, retval;\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status || io->count == 0) {\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\treturn;\n\t}\n\t/* shut everything down */\n\tio->status = -ECONNRESET;\n\tio->count++;\t\t/* Keep the request alive until we're done */\n\tspin_unlock_irqrestore(&io->lock, flags);\n\n\tfor (i = io->entries - 1; i >= 0; --i) {\n\t\tusb_block_urb(io->urbs[i]);\n\n\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\tif (retval != -EINPROGRESS\n\t\t    && retval != -ENODEV\n\t\t    && retval != -EBUSY\n\t\t    && retval != -EIDRM)\n\t\t\tdev_warn(&io->dev->dev, \"%s, unlink --> %d\\n\",\n\t\t\t\t __func__, retval);\n\t}\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tio->count--;\n\tif (!io->count)\n\t\tcomplete(&io->complete);\n\tspin_unlock_irqrestore(&io->lock, flags);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "bool SecurityManager::create_participant_stateless_message_reader()\n{\n    HistoryAttributes hatt;\n    hatt.payloadMaxSize = 5000;\n    hatt.initialReservedCaches = 250;\n    hatt.maximumReservedCaches = 5000;\n    participant_stateless_message_reader_history_ = new ReaderHistory(hatt);\n    ReaderAttributes ratt;\n    ratt.endpoint.topicKind = NO_KEY;\n    ratt.endpoint.reliabilityKind = BEST_EFFORT;\n    //mp_listener = new PDPSimpleListener(this);\n\n    RTPSReader* rout = nullptr;\n    if(participant_->createReader(&rout, ratt, participant_stateless_message_reader_history_, nullptr, participant_stateless_message_reader_entity_id, true, false))\n    {\n        participant_stateless_message_reader_ = dynamic_cast<StatelessReader*>(rout);\n\n        return true;\n    }\n\n    logError(SECURITY,\"Participant Stateless Message Reader creation failed\");\n    delete(participant_stateless_message_reader_history_);\n    participant_stateless_message_reader_history_ = nullptr;\n    //delete(mp_listener);\n    //mp_listener = nullptr;\n    return false;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "bool SecurityManager::create_participant_stateless_message_reader()\n{\n    HistoryAttributes hatt;\n    hatt.payloadMaxSize = 5000;\n    hatt.initialReservedCaches = 250;\n    hatt.maximumReservedCaches = 5000;\n    participant_stateless_message_reader_history_ = new ReaderHistory(hatt);\n    ReaderAttributes ratt;\n    ratt.endpoint.topicKind = NO_KEY;\n    ratt.endpoint.reliabilityKind = BEST_EFFORT;\n\n    RTPSReader* rout = nullptr;\n    if(participant_->createReader(&rout, ratt, participant_stateless_message_reader_history_, &participant_stateless_message_listener_,\n                participant_stateless_message_reader_entity_id, true, false))\n    {\n        participant_stateless_message_reader_ = dynamic_cast<StatelessReader*>(rout);\n\n        return true;\n    }\n\n    logError(SECURITY,\"Participant Stateless Message Reader creation failed\");\n    delete(participant_stateless_message_reader_history_);\n    participant_stateless_message_reader_history_ = nullptr;\n    return false;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tint depth, len, err;\n\text4_lblk_t next;\n\tunsigned uninitialized = 0;\n\n\tBUG_ON(ext4_ext_get_actual_len(newext) == 0);\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tBUG_ON(path[depth].p_hdr == NULL);\n\n\t/* try to insert block into found extent and return */\n\tif (ex && (flag != EXT4_GET_BLOCKS_PRE_IO)\n\t\t&& ext4_can_extents_be_merged(inode, ex, newext)) {\n\t\text_debug(\"append [%d]%d block to %d:[%d]%d (from %llu)\\n\",\n\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\tle32_to_cpu(ex->ee_block),\n\t\t\t\text4_ext_is_uninitialized(ex),\n\t\t\t\text4_ext_get_actual_len(ex), ext_pblock(ex));\n\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tle16_add_cpu(&eh->eh_entries, 1);\n\tnearex = path[depth].p_ext;\n\tnearex->ee_block = newext->ee_block;\n\text4_ext_store_pblock(nearex, ext_pblock(newext));\n\tnearex->ee_len = newext->ee_len;\n\nmerge:\n\t/* try to merge extents to the right */\n\tif (flag != EXT4_GET_BLOCKS_PRE_IO)\n\t\text4_ext_try_to_merge(inode, path, nearex);\n\n\t/* try to merge extents to the left */\n\n\t/* time to correct all indexes above */\n\terr = ext4_ext_correct_indexes(handle, inode, path);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = ext4_ext_dirty(handle, inode, path + depth);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tint depth, len, err;\n\text4_lblk_t next;\n\tunsigned uninitialized = 0;\n\n\tBUG_ON(ext4_ext_get_actual_len(newext) == 0);\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tBUG_ON(path[depth].p_hdr == NULL);\n\n\t/* try to insert block into found extent and return */\n\tif (ex && !(flag & EXT4_GET_BLOCKS_PRE_IO)\n\t\t&& ext4_can_extents_be_merged(inode, ex, newext)) {\n\t\text_debug(\"append [%d]%d block to %d:[%d]%d (from %llu)\\n\",\n\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\tle32_to_cpu(ex->ee_block),\n\t\t\t\text4_ext_is_uninitialized(ex),\n\t\t\t\text4_ext_get_actual_len(ex), ext_pblock(ex));\n\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tle16_add_cpu(&eh->eh_entries, 1);\n\tnearex = path[depth].p_ext;\n\tnearex->ee_block = newext->ee_block;\n\text4_ext_store_pblock(nearex, ext_pblock(newext));\n\tnearex->ee_len = newext->ee_len;\n\nmerge:\n\t/* try to merge extents to the right */\n\tif (!(flag & EXT4_GET_BLOCKS_PRE_IO))\n\t\text4_ext_try_to_merge(inode, path, nearex);\n\n\t/* try to merge extents to the left */\n\n\t/* time to correct all indexes above */\n\terr = ext4_ext_correct_indexes(handle, inode, path);\n\tif (err)\n\t\tgoto cleanup;\n\n\terr = ext4_ext_dirty(handle, inode, path + depth);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "      if (rhs) {\n        codegen(s, rhs, VAL);\n        pop();\n      }\n      else {\n        gen_move(s, cursp(), sp, 0);\n      }\n      if (val) {\n        gen_move(s, top, cursp(), 1);\n      }\n      if (n < 14) {\n        n++;\n      }\n      else {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), 1);\n      }\n      s->sp = call;\n      if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {\n        genop_1(s, OP_SETIDX, cursp());\n      }\n      else {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "      if (rhs) {\n        codegen(s, rhs, VAL);\n        pop();\n      }\n      else {\n        gen_move(s, cursp(), sp, 0);\n      }\n      if (val) {\n        gen_move(s, top, cursp(), 1);\n      }\n      if (n < 15) {\n        n++;\n        if (n == 15) {\n          pop_n(14);\n          genop_2(s, OP_ARRAY, cursp(), 15);\n        }\n      }\n      else {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), 1);\n      }\n      s->sp = call;\n      if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) {\n        genop_1(s, OP_SETIDX, cursp());\n      }\n      else {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n\tdoi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_TAGLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n\t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter > CIPSO_V4_TAG_MAXCNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n\t\t}\n\tif (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter] = CIPSO_V4_TAG_INVALID;\n\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n\tdoi_def->doi = nla_get_u32(info->attrs[NLBL_CIPSOV4_A_DOI]);\n\n\tif (nla_validate_nested(info->attrs[NLBL_CIPSOV4_A_TAGLST],\n\t\t\t\tNLBL_CIPSOV4_A_MAX,\n\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n\t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter >= CIPSO_V4_TAG_MAXCNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n\t\t}\n\twhile (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter++] = CIPSO_V4_TAG_INVALID;\n\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    return false;\n  }\n\n  if (activation == kTfLiteActSignBit) {\n    return false;\n  }\n\n  const int kOutputShapeTensor = 0;  // Only used for TransposeConv\n  const int kWeightTensor = 1;\n  const int kBiasTensor = 2;  // Only used for non-TransposeConv\n  const TfLiteTensor* weights = GetInput(context, node, kWeightTensor);\n  const int max_kernel_size = 16384;\n  if (!IsConstantTensor(weights)) {\n    return false;\n  }\n  if (weights->dims->data[1] > max_kernel_size ||\n      weights->dims->data[2] > max_kernel_size) {\n    return false;\n  }\n  if (registration->builtin_code == kTfLiteBuiltinTransposeConv) {\n    if (!IsConstantTensor(GetInput(context, node, kOutputShapeTensor))) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    return false;\n  }\n\n  if (activation == kTfLiteActSignBit) {\n    return false;\n  }\n\n  const int kOutputShapeTensor = 0;  // Only used for TransposeConv\n  const int kWeightTensor = 1;\n  const int kBiasTensor = 2;  // Only used for non-TransposeConv\n  const TfLiteTensor* weights;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kWeightTensor, &weights));\n  const int max_kernel_size = 16384;\n  if (!IsConstantTensor(weights)) {\n    return false;\n  }\n  if (weights->dims->data[1] > max_kernel_size ||\n      weights->dims->data[2] > max_kernel_size) {\n    return false;\n  }\n  if (registration->builtin_code == kTfLiteBuiltinTransposeConv) {\n    if (!IsConstantTensor(GetInput(context, node, kOutputShapeTensor))) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\ttestFeatTable<FeatTableTestA>(testDataA, \"A\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataB, \"B\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataBunsorted, \"Bu\\n\");\n\t\ttestFeatTable<FeatTableTestC>(testDataCunsorted, \"C\\n\");\n\t\ttestFeatTable<FeatTableTestD>(testDataDunsorted, \"D\\n\");\n\t\ttestFeatTable<FeatTableTestE>(testDataE, \"E\\n\");\n\n\t\t// test a bad settings offset stradling the end of the table\n\t\tFeatureMap testFeatureMap;\n\t\tdummyFace.replace_table(TtfUtil::Tag::Feat, &testBadOffset, sizeof testBadOffset);\n\t\tface = gr_make_face_with_ops(&dummyFace, &face_handle::ops, gr_face_dumbRendering);\n\t\tbool readStatus = testFeatureMap.readFeats(*face);\n\t\ttestAssert(\"fail gracefully on bad table\", !readStatus);\n\t}\n\tcatch (std::exception & e)\n\t{\n\t\tfprintf(stderr, \"%s: %s\\n\", argv[0], e.what());\n\t\tgr_face_destroy(face);\n\t\treturn 1;\n\t}\n\n    gr_face_destroy(face);\n    return 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\ttestFeatTable<FeatTableTestA>(testDataA, \"A\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataB, \"B\\n\");\n\t\ttestFeatTable<FeatTableTestB>(testDataBunsorted, \"Bu\\n\");\n\t\ttestFeatTable<FeatTableTestC>(testDataCunsorted, \"C\\n\");\n\t\ttestFeatTable<FeatTableTestD>(testDataDunsorted, \"D\\n\");\n\t\ttestFeatTable<FeatTableTestE>(testDataE, \"E\\n\");\n\n\t\t// test a bad settings offset stradling the end of the table\n\t\tFeatureMap testFeatureMap;\n\t\tdummyFace.replace_table(TtfUtil::Tag::Feat, &testBadOffset, sizeof testBadOffset);\n\t\tface = gr_make_face_with_ops(&dummyFace, &face_handle::ops, 0);\n\t\ttestAssert(\"fail gracefully on bad table\", !face);\n\t}\n\tcatch (std::exception & e)\n\t{\n\t\tfprintf(stderr, \"%s: %s\\n\", argv[0], e.what());\n\t\tgr_face_destroy(face);\n\t\treturn 1;\n\t}\n\n    gr_face_destroy(face);\n    return 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void Context::onDone() {\n  if (wasm_->onDone_) {\n    wasm_->onDone_(this, id_);\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void Context::onDone() {\n  if (in_vm_context_created_ && wasm_->onDone_) {\n    wasm_->onDone_(this, id_);\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char buffer[3];\n\tint ret;\n\n\t/* Get a couple of the ATMega Firmware values */\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char *buffer;\n\tint ret;\n\n\tbuffer = kmalloc(3, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\t/* Get a couple of the ATMega Firmware values */\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\tif (ret >= 0) {\n\t\tatusb->fw_ver_maj = buffer[0];\n\t\tatusb->fw_ver_min = buffer[1];\n\t\tatusb->fw_hw_type = buffer[2];\n\n\t\t\t \"Firmware: major: %u, minor: %u, hardware type: %u\\n\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);\n\t}\n\tif (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\n\tkfree(buffer);\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "ast_for_suite(struct compiling *c, const node *n)\n{\n    /* suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT */\n    asdl_seq *seq;\n    stmt_ty s;\n    int i, total, num, end, pos = 0;\n    node *ch;\n\n    REQ(n, suite);\n\n    total = num_stmts(n);\n    seq = _Py_asdl_seq_new(total, c->c_arena);\n    if (!seq)\n        return NULL;\n    if (TYPE(CHILD(n, 0)) == simple_stmt) {\n        n = CHILD(n, 0);\n        /* simple_stmt always ends with a NEWLINE,\n           and may have a trailing SEMI\n        */\n        /* loop by 2 to skip semi-colons */\n        for (i = 0; i < end; i += 2) {\n            ch = CHILD(n, i);\n            s = ast_for_stmt(c, ch);\n            if (!s)\n                return NULL;\n            asdl_seq_SET(seq, pos++, s);\n        }\n    }\n    else {\n        for (i = 2; i < (NCH(n) - 1); i++) {\n            ch = CHILD(n, i);\n            REQ(ch, stmt);\n            num = num_stmts(ch);\n            if (num == 1) {\n                /* small_stmt or compound_stmt with only one child */\n                s = ast_for_stmt(c, ch);\n                if (!s)\n                    return NULL;\n                asdl_seq_SET(seq, pos++, s);\n            }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "ast_for_suite(struct compiling *c, const node *n)\n{\n    /* suite: simple_stmt | NEWLINE [TYPE_COMMENT NEWLINE] INDENT stmt+ DEDENT */\n    asdl_seq *seq;\n    stmt_ty s;\n    int i, total, num, end, pos = 0;\n    node *ch;\n\n    if (TYPE(n) != func_body_suite) {\n        REQ(n, suite);\n    }\n\n    total = num_stmts(n);\n    seq = _Py_asdl_seq_new(total, c->c_arena);\n    if (!seq)\n        return NULL;\n    if (TYPE(CHILD(n, 0)) == simple_stmt) {\n        n = CHILD(n, 0);\n        /* simple_stmt always ends with a NEWLINE,\n           and may have a trailing SEMI\n        */\n        /* loop by 2 to skip semi-colons */\n        for (i = 0; i < end; i += 2) {\n            ch = CHILD(n, i);\n            s = ast_for_stmt(c, ch);\n            if (!s)\n                return NULL;\n            asdl_seq_SET(seq, pos++, s);\n        }\n    }\n    else {\n        i = 2;\n        if (TYPE(CHILD(n, 1)) == TYPE_COMMENT) {\n            i += 2;\n            REQ(CHILD(n, 2), NEWLINE);\n        }\n\n        for (; i < (NCH(n) - 1); i++) {\n            ch = CHILD(n, i);\n            REQ(ch, stmt);\n            num = num_stmts(ch);\n            if (num == 1) {\n                /* small_stmt or compound_stmt with only one child */\n                s = ast_for_stmt(c, ch);\n                if (!s)\n                    return NULL;\n                asdl_seq_SET(seq, pos++, s);\n            }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void ep4_mul_fix_ordin(ep4_t r, const ep4_t *table, const bn_t k) {\n\tint len, i, n;\n\tint8_t naf[2 * RLC_FP_BITS + 1], *t;\n\n\tif (bn_is_zero(k)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n\t/* Compute the w-TNAF representation of k. */\n\tlen = 2 * RLC_FP_BITS + 1;\n\tbn_rec_naf(naf, &len, k, EP_DEPTH);\n\n\tt = naf + len - 1;\n\tep4_set_infty(r);\n\tfor (i = len - 1; i >= 0; i--, t--) {\n\t\tep4_dbl(r, r);\n\n\t\tn = *t;\n\t\tif (n > 0) {\n\t\t\tep4_add(r, r, table[n / 2]);\n\t\t}\n\t\tif (n < 0) {\n\t\t\tep4_sub(r, r, table[-n / 2]);\n\t\t}\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void ep4_mul_fix_ordin(ep4_t r, const ep4_t *table, const bn_t k) {\n\tint8_t naf[2 * RLC_FP_BITS + 1], *t;\n\tsize_t len;\n\tint n;\n\n\tif (bn_is_zero(k)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\n\t/* Compute the w-TNAF representation of k. */\n\tlen = 2 * RLC_FP_BITS + 1;\n\tbn_rec_naf(naf, &len, k, EP_DEPTH);\n\n\tt = naf + len - 1;\n\tep4_set_infty(r);\n\tfor (int i = len - 1; i >= 0; i--, t--) {\n\t\tep4_dbl(r, r);\n\n\t\tn = *t;\n\t\tif (n > 0) {\n\t\t\tep4_add(r, r, table[n / 2]);\n\t\t}\n\t\tif (n < 0) {\n\t\t\tep4_sub(r, r, table[-n / 2]);\n\t\t}\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n\n    if ( !in )\n    {\n        return in;\n    }\n    \n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n\n    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));\n\n    len = 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )\n{\n    SQLWCHAR *chr;\n    int len = 0;\n\n    if ( !in )\n    {\n        return NULL;\n    }\n    \n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;\n    }\n\n    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));\n\n    len = 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "check_stl_option(char_u *s)\n{\n    int\t\tgroupdepth = 0;\n    static char errbuf[80];\n\n    while (*s)\n    {\n\t// Check for valid keys after % sequences\n\twhile (*s && *s != '%')\n\t    s++;\n\tif (!*s)\n\t    break;\n\ts++;\n\tif (*s == '%' || *s == STL_TRUNCMARK || *s == STL_SEPARATE)\n\t    while (*s && VIM_ISDIGIT(*s))\n\t\ts++;\n\t}\n\tif (*s == '(')\n\t{\n\t    groupdepth++;\n\t    continue;\n\t}\n\tif (vim_strchr(STL_ALL, *s) == NULL)\n\t{\n\t    return illegal_char(errbuf, *s);\n\t}\n\tif (*s == '{')\n\t{\n\t    int reevaluate = (*++s == '%');\n\n\t    if (reevaluate && *++s == '}')\n\t\t// \"}\" is not allowed immediately after \"%{%\"\n\t\treturn illegal_char(errbuf, '}');\n\t    while ((*s != '}' || (reevaluate && s[-1] != '%')) && *s)\n\t\ts++;\n\t    if (*s != '}')\n\t\treturn e_unclosed_expression_sequence;\n\t}\n    }\n    if (groupdepth != 0)\n\treturn e_unbalanced_groups;\n    return NULL;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "check_stl_option(char_u *s)\n{\n    int\t\tgroupdepth = 0;\n    static char errbuf[ERR_BUFLEN];\n    int\t\terrbuflen = ERR_BUFLEN;\n\n    while (*s)\n    {\n\t// Check for valid keys after % sequences\n\twhile (*s && *s != '%')\n\t    s++;\n\tif (!*s)\n\t    break;\n\ts++;\n\tif (*s == '%' || *s == STL_TRUNCMARK || *s == STL_SEPARATE)\n\t    while (*s && VIM_ISDIGIT(*s))\n\t\ts++;\n\t}\n\tif (*s == '(')\n\t{\n\t    groupdepth++;\n\t    continue;\n\t}\n\tif (vim_strchr(STL_ALL, *s) == NULL)\n\t{\n\t    return illegal_char(errbuf, errbuflen, *s);\n\t}\n\tif (*s == '{')\n\t{\n\t    int reevaluate = (*++s == '%');\n\n\t    if (reevaluate && *++s == '}')\n\t\t// \"}\" is not allowed immediately after \"%{%\"\n\t\treturn illegal_char(errbuf, errbuflen, '}');\n\t    while ((*s != '}' || (reevaluate && s[-1] != '%')) && *s)\n\t\ts++;\n\t    if (*s != '}')\n\t\treturn e_unclosed_expression_sequence;\n\t}\n    }\n    if (groupdepth != 0)\n\treturn e_unbalanced_groups;\n    return NULL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t    // For soundfolded words we need to find the original\n\t\t    // words, the edit distance and then add them.\n\t\t    add_sound_suggest(su, preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\t    // Give a penalty when changing non-word char to word\n\t\t    // char, e.g., \"thes,\" -> \"these\".\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword, p);\n\t\t    if (!spell_iswordp(p, curwin))\n\t\t    {\n\t\t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p, curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\n\t\t    // Give a bonus to words seen before.\n\t\t    score = score_wordcount_adj(slang,\n\t\t\t\t\t\tsp->ts_score + newscore,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t    // For soundfolded words we need to find the original\n\t\t    // words, the edit distance and then add them.\n\t\t    add_sound_suggest(su, preword, sp->ts_score, lp);\n\t\t}\n\t\telse if (sp->ts_fidx > 0)\n\t\t{\n\t\t    // Give a penalty when changing non-word char to word\n\t\t    // char, e.g., \"thes,\" -> \"these\".\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword, p);\n\t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n\t\t    {\n\t\t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p, curwin))\n\t\t\t    newscore += SCORE_NONWORD;\n\t\t    }\n\n\t\t    // Give a bonus to words seen before.\n\t\t    score = score_wordcount_adj(slang,\n\t\t\t\t\t\tsp->ts_score + newscore,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t\tg_warning(\"SSL handshake failed: %s\", errstr != NULL ? errstr : \"unknown SSL error\");\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcert = SSL_get_peer_certificate(chan->ssl);\n\tif (cert == NULL) {\n\t\tg_warning(\"SSL server supplied no certificate\");\n\t\treturn -1;\n\t}\n\tret = !chan->verify || irssi_ssl_verify(chan->ssl, chan->ctx, cert);\n\tX509_free(cert);\n\treturn ret ? 0 : -1;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\t\tg_warning(\"SSL handshake failed: %s\", errstr != NULL ? errstr : \"unknown SSL error\");\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\tcert = SSL_get_peer_certificate(chan->ssl);\n\tif (cert == NULL) {\n\t\tg_warning(\"SSL server supplied no certificate\");\n\t\treturn -1;\n\t}\n\tret = !chan->verify || irssi_ssl_verify(chan->ssl, chan->ctx, chan->hostname, cert);\n\tX509_free(cert);\n\treturn ret ? 0 : -1;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tssize_t bufsize;\n\tsize_t offset, align, len;\n\t\n\tif (size != xph_sizeof) {\n\t\tif (file_printf(ms, \", corrupted program header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n  \tfor ( ; num; num--) {\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) == -1) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\toff += size;\n\t\tbufsize = 0;\n\t\talign = 4;\n\n\t\t/* Things we can determine before we seek */\n\t\tswitch (xph_type) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tssize_t bufsize;\n\tsize_t offset, align, len;\n\t\n\tif (size != xph_sizeof) {\n\t\tif (file_printf(ms, \", corrupted program header size\") == -1)\n\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n  \tfor ( ; num; num--) {\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) < (ssize_t)xph_sizeof) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\toff += size;\n\t\tbufsize = 0;\n\t\talign = 4;\n\n\t\t/* Things we can determine before we seek */\n\t\tswitch (xph_type) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int ncrush_decompress(NCRUSH_CONTEXT* ncrush, const BYTE* pSrcData, UINT32 SrcSize,\n                      const BYTE** ppDstData, UINT32* pDstSize, UINT32 flags)\n{\n\tUINT32 index;\n\tUINT32 bits;\n\tINT32 nbits;\n\tconst BYTE* SrcPtr;\n\tconst BYTE* SrcEnd;\n\tUINT16 Mask;\n\tBYTE Literal;\n\tUINT32 IndexLEC;\n\tUINT32 BitLength;\n\tUINT32 MaskedBits;\n\tUINT32 CopyOffset;\n\tUINT32 CopyLength;\n\tUINT32 OldCopyOffset;\n\tBYTE* CopyOffsetPtr;\n\tUINT32 LengthOfMatch;\n\tUINT32 CopyOffsetIndex;\n\tUINT32 OffsetCacheIndex;\n\tBYTE* HistoryPtr;\n\tBYTE* HistoryBuffer;\n\tBYTE* HistoryBufferEnd;\n\tUINT32 CopyOffsetBits;\n\tUINT32 CopyOffsetBase;\n\tUINT32 LengthOfMatchBits;\n\tUINT32 LengthOfMatchBase;\n\n\tWINPR_ASSERT(ncrush);\n\tWINPR_ASSERT(pSrcData);\n\tWINPR_ASSERT(ppDstData);\n\tWINPR_ASSERT(pDstSize);\n\n\tif (ncrush->HistoryEndOffset != 65535)\n\t\treturn -1001;\n\n\tHistoryBuffer = ncrush->HistoryBuffer;\n\tHistoryBufferEnd = &HistoryBuffer[ncrush->HistoryEndOffset];\n\n\tif (flags & PACKET_AT_FRONT)\n\t{\n\t\tif ((ncrush->HistoryPtr - 32768) <= HistoryBuffer)\n\t\t\treturn -1002;\n\n\t\tMoveMemory(HistoryBuffer, (ncrush->HistoryPtr - 32768), 32768);\n\t\tncrush->HistoryPtr = &(HistoryBuffer[32768]);\n\t\tZeroMemory(&HistoryBuffer[32768], 32768);\n\t}\n\n\tif (flags & PACKET_FLUSHED)\n\t{\n\t\tncrush->HistoryPtr = HistoryBuffer;\n\t\tZeroMemory(HistoryBuffer, sizeof(ncrush->HistoryBuffer));\n\t\tZeroMemory(&(ncrush->OffsetCache), sizeof(ncrush->OffsetCache));\n\t}\n\n\tHistoryPtr = ncrush->HistoryPtr;\n\n\tif (!(flags & PACKET_COMPRESSED))\n\t{\n\t\t*ppDstData = pSrcData;\n\t\t*pDstSize = SrcSize;\n\t\treturn 1;\n\t}\n\n\tSrcEnd = &pSrcData[SrcSize];\n\tnbits = 32;\n\tbits = get_dword(pSrcData);\n\tSrcPtr = pSrcData + 4;\n\n\twhile (1)\n\t{\n\t\twhile (1)\n\t\t{\n\t\t\tMask = get_word(&HuffTableMask[29]);\n\t\t\tMaskedBits = bits & Mask;\n\t\t\tIndexLEC = HuffTableLEC[MaskedBits] & 0xFFF;\n\t\t\tBitLength = HuffTableLEC[MaskedBits] >> 12;\n\t\t\tbits >>= BitLength;\n\t\t\tnbits -= BitLength;\n\n\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))\n\t\t\t\treturn -1;\n\n\t\t\tif (IndexLEC >= 256)\n\t\t\t\tbreak;\n\t\tCopyOffsetIndex = IndexLEC - 257;\n\n\t\tif (CopyOffsetIndex >= 32)\n\t\t{\n\t\t\tOffsetCacheIndex = IndexLEC - 289;\n\n\t\t\tif (OffsetCacheIndex >= 4)\n\t\t\t\treturn -1004;\n\n\t\t\tCopyOffset = ncrush->OffsetCache[OffsetCacheIndex];\n\t\t\tMask = get_word(&HuffTableMask[21]);\n\t\t\tMaskedBits = bits & Mask;\n\t\t\tLengthOfMatch = HuffTableLOM[MaskedBits] & 0xFFF;\n\t\t\tBitLength = HuffTableLOM[MaskedBits] >> 12;\n\t\t\tbits >>= BitLength;\n\t\t\tnbits -= BitLength;\n\n\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))\n\t\t\t\treturn -1;\n\n\t\t\tLengthOfMatchBits = LOMBitsLUT[LengthOfMatch];\n\t\t\tLengthOfMatchBase = LOMBaseLUT[LengthOfMatch];\n\n\t\t\tif (LengthOfMatchBits)\n\t\t\t{\n\t\t\t\tMask = get_word(&HuffTableMask[(2 * LengthOfMatchBits) + 3]);\n\t\t\t\tMaskedBits = bits & Mask;\n\t\t\t\tbits >>= LengthOfMatchBits;\n\t\t\t\tnbits -= LengthOfMatchBits;\n\t\t\t\tLengthOfMatchBase += MaskedBits;\n\n\t\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tOldCopyOffset = ncrush->OffsetCache[OffsetCacheIndex];\n\t\t\tncrush->OffsetCache[OffsetCacheIndex] = ncrush->OffsetCache[0];\n\t\t\tncrush->OffsetCache[0] = OldCopyOffset;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCopyOffsetBits = CopyOffsetBitsLUT[CopyOffsetIndex];\n\t\t\tCopyOffsetBase = CopyOffsetBaseLUT[CopyOffsetIndex];\n\t\t\tCopyOffset = CopyOffsetBase - 1;\n\n\t\t\tif (CopyOffsetBits)\n\t\t\t{\n\t\t\t\tMask = get_word(&HuffTableMask[(2 * CopyOffsetBits) + 3]);\n\t\t\t\tMaskedBits = bits & Mask;\n\t\t\t\tCopyOffset = CopyOffsetBase + MaskedBits - 1;\n\t\t\t\tbits >>= CopyOffsetBits;\n\t\t\t\tnbits -= CopyOffsetBits;\n\n\t\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tMask = get_word(&HuffTableMask[21]);\n\t\t\tMaskedBits = bits & Mask;\n\t\t\tLengthOfMatch = HuffTableLOM[MaskedBits] & 0xFFF;\n\t\t\tBitLength = HuffTableLOM[MaskedBits] >> 12;\n\t\t\tbits >>= BitLength;\n\t\t\tnbits -= BitLength;\n\n\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))\n\t\t\t\treturn -1;\n\n\t\t\tLengthOfMatchBits = LOMBitsLUT[LengthOfMatch];\n\t\t\tLengthOfMatchBase = LOMBaseLUT[LengthOfMatch];\n\n\t\t\tif (LengthOfMatchBits)\n\t\t\t{\n\t\t\t\tMask = get_word(&HuffTableMask[(2 * LengthOfMatchBits) + 3]);\n\t\t\t\tMaskedBits = bits & Mask;\n\t\t\t\tbits >>= LengthOfMatchBits;\n\t\t\t\tnbits -= LengthOfMatchBits;\n\t\t\t\tLengthOfMatchBase += MaskedBits;\n\n\t\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tncrush->OffsetCache[3] = ncrush->OffsetCache[2];\n\t\t\tncrush->OffsetCache[2] = ncrush->OffsetCache[1];",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int ncrush_decompress(NCRUSH_CONTEXT* ncrush, const BYTE* pSrcData, UINT32 SrcSize,\n                      const BYTE** ppDstData, UINT32* pDstSize, UINT32 flags)\n{\n\tUINT32 index;\n\tBYTE Literal;\n\tUINT32 IndexLEC;\n\tUINT32 BitLength;\n\tUINT32 CopyOffset;\n\tUINT32 CopyLength;\n\tUINT32 OldCopyOffset;\n\tBYTE* CopyOffsetPtr;\n\tUINT32 LengthOfMatch;\n\tUINT32 CopyOffsetIndex;\n\tUINT32 OffsetCacheIndex;\n\tUINT32 CopyOffsetBits;\n\tUINT32 CopyOffsetBase;\n\tUINT32 LengthOfMatchBits;\n\tUINT32 LengthOfMatchBase;\n\n\tWINPR_ASSERT(ncrush);\n\tWINPR_ASSERT(pSrcData);\n\tWINPR_ASSERT(ppDstData);\n\tWINPR_ASSERT(pDstSize);\n\n\tif (ncrush->HistoryEndOffset != 65535)\n\t\treturn -1001;\n\n\tBYTE* HistoryBuffer = ncrush->HistoryBuffer;\n\tconst BYTE* HistoryBufferEnd = &HistoryBuffer[ncrush->HistoryEndOffset];\n\n\tif (flags & PACKET_AT_FRONT)\n\t{\n\t\tif ((ncrush->HistoryPtr - 32768) <= HistoryBuffer)\n\t\t\treturn -1002;\n\n\t\tMoveMemory(HistoryBuffer, (ncrush->HistoryPtr - 32768), 32768);\n\t\tncrush->HistoryPtr = &(HistoryBuffer[32768]);\n\t\tZeroMemory(&HistoryBuffer[32768], 32768);\n\t}\n\n\tif (flags & PACKET_FLUSHED)\n\t{\n\t\tncrush->HistoryPtr = HistoryBuffer;\n\t\tZeroMemory(HistoryBuffer, sizeof(ncrush->HistoryBuffer));\n\t\tZeroMemory(&(ncrush->OffsetCache), sizeof(ncrush->OffsetCache));\n\t}\n\n\tBYTE* HistoryPtr = ncrush->HistoryPtr;\n\n\tif (!(flags & PACKET_COMPRESSED))\n\t{\n\t\t*ppDstData = pSrcData;\n\t\t*pDstSize = SrcSize;\n\t\treturn 1;\n\t}\n\n\tconst BYTE* SrcEnd = &pSrcData[SrcSize];\n\tconst BYTE* SrcPtr = pSrcData + 4;\n\n\tINT32 nbits = 32;\n\tUINT32 bits = get_dword(pSrcData);\n\twhile (1)\n\t{\n\t\twhile (1)\n\t\t{\n\t\t\tconst UINT16 Mask = get_word(&HuffTableMask[29]);\n\t\t\tconst UINT32 MaskedBits = bits & Mask;\n\t\t\tif (MaskedBits >= ARRAYSIZE(HuffTableLEC))\n\t\t\t\treturn -1;\n\t\t\tIndexLEC = HuffTableLEC[MaskedBits] & 0xFFF;\n\t\t\tBitLength = HuffTableLEC[MaskedBits] >> 12;\n\t\t\tbits >>= BitLength;\n\t\t\tnbits -= BitLength;\n\n\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))\n\t\t\t\treturn -1;\n\n\t\t\tif (IndexLEC >= 256)\n\t\t\t\tbreak;\n\t\tCopyOffsetIndex = IndexLEC - 257;\n\n\t\tif (CopyOffsetIndex >= 32)\n\t\t{\n\t\t\tOffsetCacheIndex = IndexLEC - 289;\n\n\t\t\tif (OffsetCacheIndex >= 4)\n\t\t\t\treturn -1004;\n\n\t\t\tCopyOffset = ncrush->OffsetCache[OffsetCacheIndex];\n\t\t\tconst UINT16 Mask = get_word(&HuffTableMask[21]);\n\t\t\tconst UINT32 MaskedBits = bits & Mask;\n\t\t\tif (MaskedBits > ARRAYSIZE(HuffTableLOM))\n\t\t\t\treturn -1;\n\t\t\tLengthOfMatch = HuffTableLOM[MaskedBits] & 0xFFF;\n\t\t\tBitLength = HuffTableLOM[MaskedBits] >> 12;\n\t\t\tbits >>= BitLength;\n\t\t\tnbits -= BitLength;\n\n\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))\n\t\t\t\treturn -1;\n\n\t\t\tif (LengthOfMatch >= ARRAYSIZE(LOMBitsLUT))\n\t\t\t\treturn -1;\n\n\t\t\tLengthOfMatchBits = LOMBitsLUT[LengthOfMatch];\n\n\t\t\tif (LengthOfMatch >= ARRAYSIZE(LOMBaseLUT))\n\t\t\t\treturn -1;\n\t\t\tLengthOfMatchBase = LOMBaseLUT[LengthOfMatch];\n\n\t\t\tif (LengthOfMatchBits)\n\t\t\t{\n\t\t\t\tconst size_t idx = (2ull * LengthOfMatchBits) + 3ull;\n\t\t\t\tif (idx >= ARRAYSIZE(HuffTableMask))\n\t\t\t\t\treturn -1;\n\n\t\t\t\tconst UINT16 Mask = get_word(&HuffTableMask[idx]);\n\t\t\t\tconst UINT32 MaskedBits = bits & Mask;\n\t\t\t\tbits >>= LengthOfMatchBits;\n\t\t\t\tnbits -= LengthOfMatchBits;\n\t\t\t\tLengthOfMatchBase += MaskedBits;\n\n\t\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tOldCopyOffset = ncrush->OffsetCache[OffsetCacheIndex];\n\t\t\tncrush->OffsetCache[OffsetCacheIndex] = ncrush->OffsetCache[0];\n\t\t\tncrush->OffsetCache[0] = OldCopyOffset;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (CopyOffsetIndex >= ARRAYSIZE(CopyOffsetBitsLUT))\n\t\t\t\treturn -1;\n\n\t\t\tCopyOffsetBits = CopyOffsetBitsLUT[CopyOffsetIndex];\n\n\t\t\tif (CopyOffsetIndex >= ARRAYSIZE(CopyOffsetBaseLUT))\n\t\t\t\treturn -1;\n\t\t\tCopyOffsetBase = CopyOffsetBaseLUT[CopyOffsetIndex];\n\t\t\tCopyOffset = CopyOffsetBase - 1;\n\n\t\t\tif (CopyOffsetBits)\n\t\t\t{\n\t\t\t\tconst size_t idx = (2ull * CopyOffsetBits) + 3ull;\n\t\t\t\tif (idx >= ARRAYSIZE(HuffTableMask))\n\t\t\t\t\treturn -1;\n\n\t\t\t\tconst UINT16 Mask = get_word(&HuffTableMask[idx]);\n\t\t\t\tconst UINT32 MaskedBits = bits & Mask;\n\t\t\t\tconst UINT32 tmp = CopyOffsetBase + MaskedBits;\n\t\t\t\tif (tmp < 1)\n\t\t\t\t\treturn -1;\n\t\t\t\tCopyOffset = tmp - 1;\n\t\t\t\tbits >>= CopyOffsetBits;\n\t\t\t\tnbits -= CopyOffsetBits;\n\n\t\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tconst UINT16 Mask = get_word(&HuffTableMask[21]);\n\t\t\tconst UINT32 MaskedBits = bits & Mask;\n\t\t\tif (MaskedBits >= ARRAYSIZE(HuffTableLOM))\n\t\t\t\treturn -1;\n\n\t\t\tLengthOfMatch = HuffTableLOM[MaskedBits] & 0xFFF;\n\t\t\tBitLength = HuffTableLOM[MaskedBits] >> 12;\n\t\t\tbits >>= BitLength;\n\t\t\tnbits -= BitLength;\n\n\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))\n\t\t\t\treturn -1;\n\n\t\t\tif (LengthOfMatch >= ARRAYSIZE(LOMBitsLUT))\n\t\t\t\treturn -1;\n\n\t\t\tLengthOfMatchBits = LOMBitsLUT[LengthOfMatch];\n\n\t\t\tif (LengthOfMatch >= ARRAYSIZE(LOMBaseLUT))\n\t\t\t\treturn -1;\n\t\t\tLengthOfMatchBase = LOMBaseLUT[LengthOfMatch];\n\n\t\t\tif (LengthOfMatchBits)\n\t\t\t{\n\t\t\t\tconst size_t idx = (2ull * LengthOfMatchBits) + 3ull;\n\t\t\t\tif (idx >= ARRAYSIZE(HuffTableMask))\n\t\t\t\t\treturn -1;\n\n\t\t\t\tconst UINT16 Mask = get_word(&HuffTableMask[idx]);\n\t\t\t\tconst UINT32 MaskedBits = bits & Mask;\n\t\t\t\tbits >>= LengthOfMatchBits;\n\t\t\t\tnbits -= LengthOfMatchBits;\n\t\t\t\tLengthOfMatchBase += MaskedBits;\n\n\t\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tncrush->OffsetCache[3] = ncrush->OffsetCache[2];\n\t\t\tncrush->OffsetCache[2] = ncrush->OffsetCache[1];",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static inline void sem_lock_and_putref(struct sem_array *sma)\n{\n\tipc_lock_by_ptr(&sma->sem_perm);\n\tipc_rcu_putref(sma);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static inline void sem_lock_and_putref(struct sem_array *sma)\n{\n\trcu_read_lock();\n\tsem_lock(sma, NULL, -1);\n\tipc_rcu_putref(sma);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "absl::Span<const std::string> ConnectionInfoImplBase::ipSansPeerCertificate() const {\n  if (!cached_ip_san_peer_certificate_.empty()) {\n    return cached_ip_san_peer_certificate_;\n  }\n\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_ip_san_peer_certificate_.empty());\n    return cached_ip_san_peer_certificate_;\n  }\n  cached_ip_san_peer_certificate_ = Utility::getSubjectAltNames(*cert, GEN_IPADD);\n  return cached_ip_san_peer_certificate_;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "absl::Span<const std::string> ConnectionInfoImplBase::ipSansPeerCertificate() const {\n  if (!cached_ip_san_peer_certificate_.empty()) {\n    return cached_ip_san_peer_certificate_;\n  }\n\n  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_ip_san_peer_certificate_.empty());\n    return cached_ip_san_peer_certificate_;\n  }\n  cached_ip_san_peer_certificate_ = Utility::getSubjectAltNames(*cert, GEN_IPADD, true);\n  return cached_ip_san_peer_certificate_;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "Jsi_RC jsi_ArgTypeCheck(Jsi_Interp *interp, int typ,  Jsi_Value *arg, const char *p1,\n    const char *p2, int index, Jsi_Func *func, bool isdefault) {\n    Jsi_RC rc = JSI_OK;\n    char idxBuf[200];\n    idxBuf[0] = 0;\n    if (func && arg->vt == JSI_VT_UNDEF && !interp->typeCheck.noundef && index>0 && !isdefault && !(typ&JSI_TT_UNDEFINED)) {\n        snprintf(idxBuf, sizeof(idxBuf), \" arg %d\", index);\n        jsi_TypeMismatch(interp);\n       \n        Jsi_DString fStr = {};\n        rc = Jsi_LogType(\"call with undefined var %s%s '%s'%s\", p1, idxBuf, p2, jsiFuncInfo(interp, &fStr, func, arg));\n        Jsi_DSFree(&fStr);\n        return rc;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "Jsi_RC jsi_ArgTypeCheck(Jsi_Interp *interp, int typ,  Jsi_Value *arg, const char *p1,\n    const char *p2, int index, Jsi_Func *func, bool isdefault) {\n    Jsi_RC rc = JSI_OK;\n    char idxBuf[JSI_MAX_NUMBER_STRING*2];\n    idxBuf[0] = 0;\n    if (func && arg->vt == JSI_VT_UNDEF && !interp->typeCheck.noundef && index>0 && !isdefault && !(typ&JSI_TT_UNDEFINED)) {\n        snprintf(idxBuf, sizeof(idxBuf), \" arg %d\", index);\n        jsi_TypeMismatch(interp);\n       \n        Jsi_DString fStr = {};\n        rc = Jsi_LogType(\"call with undefined var %s%s '%s'%s\", p1, idxBuf, p2, jsiFuncInfo(interp, &fStr, func, arg));\n        Jsi_DSFree(&fStr);\n        return rc;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor* seq_len_max_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"seq_len_max\", &seq_len_max_tensor));\n\n    const Tensor* x;\n    OP_REQUIRES_OK(ctx, ctx->input(\"x\", &x));\n    OP_REQUIRES(ctx, x->dims() == 3, errors::InvalidArgument(\"x must be 3D\"));\n    const int64_t timelen = x->dim_size(0);\n    const int64_t batch_size = x->dim_size(1);\n    const int64_t input_size = x->dim_size(2);\n\n    const Tensor* cs_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"cs_prev\", &cs_prev_tensor));\n\n    const Tensor* h_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"h_prev\", &h_prev_tensor));\n\n    const Tensor* w_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"w\", &w_tensor));\n    const int64_t cell_size = w_tensor->dim_size(1) / 4;\n    OP_REQUIRES(ctx, input_size + cell_size == w_tensor->dim_size(0),\n                errors::InvalidArgument(\n                    \"w matrix rows don't match: \", input_size + cell_size,\n                    \" vs. \", w_tensor->dim_size(0)));\n\n    const Tensor* wci_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wci\", &wci_tensor));\n\n    const Tensor* wcf_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wcf\", &wcf_tensor));\n\n    const Tensor* wco_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wco\", &wco_tensor));\n\n    const Tensor* b_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"b\", &b_tensor));\n    OP_REQUIRES(\n        ctx, cell_size == b_tensor->dim_size(0) / 4,\n        errors::InvalidArgument(\"w and b cell_size don't match: \", cell_size,\n                                \" vs. \", b_tensor->dim_size(0)));\n\n    const Tensor* i_out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"i\", &i_out));\n\n    const Tensor* cs_out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"cs\", &cs_out));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  void Compute(OpKernelContext* ctx) override {\n    const Tensor* seq_len_max_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"seq_len_max\", &seq_len_max_tensor));\n\n    const Tensor* x;\n    OP_REQUIRES_OK(ctx, ctx->input(\"x\", &x));\n    OP_REQUIRES(\n        ctx, x->dims() == 3,\n        errors::InvalidArgument(\"x must be rank 3 but is rank \", x->dims()));\n    const int64_t timelen = x->dim_size(0);\n    const int64_t batch_size = x->dim_size(1);\n    const int64_t input_size = x->dim_size(2);\n\n    const Tensor* cs_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"cs_prev\", &cs_prev_tensor));\n    OP_REQUIRES(ctx, cs_prev_tensor->dims() == 2,\n                errors::InvalidArgument(\"cs_prev must be rank 2 but is rank \",\n                                        cs_prev_tensor->dims()));\n\n    const Tensor* h_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"h_prev\", &h_prev_tensor));\n    OP_REQUIRES(ctx, h_prev_tensor->dims() == 2,\n                errors::InvalidArgument(\"h_prev must be rank 2 but is rank \",\n                                        h_prev_tensor->dims()));\n\n    const Tensor* w_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"w\", &w_tensor));\n    OP_REQUIRES(ctx, w_tensor->dims() == 2,\n                errors::InvalidArgument(\"w must be rank 2 but is rank \",\n                                        w_tensor->dims()));\n    const int64_t cell_size = w_tensor->dim_size(1) / 4;\n    OP_REQUIRES(ctx, input_size + cell_size == w_tensor->dim_size(0),\n                errors::InvalidArgument(\n                    \"w matrix rows don't match: \", input_size + cell_size,\n                    \" vs. \", w_tensor->dim_size(0)));\n\n    const Tensor* wci_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wci\", &wci_tensor));\n    OP_REQUIRES(ctx, wci_tensor->dims() == 1,\n                errors::InvalidArgument(\"wci must be rank 1 but is rank \",\n                                        wci_tensor->dims()));\n\n    const Tensor* wcf_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wcf\", &wcf_tensor));\n    OP_REQUIRES(ctx, wcf_tensor->dims() == 1,\n                errors::InvalidArgument(\"wcf must be rank 1 but is rank \",\n                                        wcf_tensor->dims()));\n\n    const Tensor* wco_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wco\", &wco_tensor));\n    OP_REQUIRES(ctx, wco_tensor->dims() == 1,\n                errors::InvalidArgument(\"wco must be rank 1 but is rank \",\n                                        wco_tensor->dims()));\n\n    const Tensor* b_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"b\", &b_tensor));\n    OP_REQUIRES(ctx, b_tensor->dims() == 1,\n                errors::InvalidArgument(\"b must be rank 1 but is rank \",\n                                        b_tensor->dims()));\n    OP_REQUIRES(\n        ctx, cell_size == b_tensor->dim_size(0) / 4,\n        errors::InvalidArgument(\"w and b cell_size don't match: \", cell_size,\n                                \" vs. \", b_tensor->dim_size(0)));\n\n    const Tensor* i_out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"i\", &i_out));\n\n    const Tensor* cs_out = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"cs\", &cs_out));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n\tif (rebase_info || main_mach0->chained_starts) {\n\t\tRIO *io = bf->rbin->iob.io;\n\t\tswizzle_io_read (obj, io);\n\t}\n\n\treturn true;\n\nbeach:\n\tr_buf_free (fbuf);\n\tobj->cache_buf = NULL;\n\tMACH0_(mach0_free) (main_mach0);\n\treturn false;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n\tif (rebase_info || main_mach0->chained_starts) {\n\t\tRIO *io = bf->rbin->iob.io;\n\t\tswizzle_io_read (obj, io);\n\t}\n\n\treturn true;\n\nbeach:\n\tr_buf_free (fbuf);\n\tif (obj) {\n\t\tobj->cache_buf = NULL;\n\t}\n\tMACH0_(mach0_free) (main_mach0);\n\treturn false;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int get_evtchn_to_irq(evtchn_port_t evtchn)\n{\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -1;\n\tif (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)\n\t\treturn -1;\n\treturn evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int get_evtchn_to_irq(evtchn_port_t evtchn)\n{\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -1;\n\tif (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)\n\t\treturn -1;\n\treturn READ_ONCE(evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)]);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    zstream.zalloc = ff_png_zalloc;\n    zstream.zfree  = ff_png_zfree;\n    zstream.opaque = NULL;\n    if (inflateInit(&zstream) != Z_OK)\n        return AVERROR_EXTERNAL;\n    zstream.next_in  = (unsigned char *)data;\n    zstream.avail_in = data_end - data;\n    av_bprint_init(bp, 0, -1);\n\n    while (zstream.avail_in > 0) {\n        av_bprint_get_buffer(bp, 1, &buf, &buf_size);\n        if (!buf_size) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n        zstream.next_out  = buf;\n        zstream.avail_out = buf_size;\n        ret = inflate(&zstream, Z_PARTIAL_FLUSH);\n        if (ret != Z_OK && ret != Z_STREAM_END) {\n            ret = AVERROR_EXTERNAL;\n            goto fail;\n        }\n        bp->len += zstream.next_out - buf;\n        if (ret == Z_STREAM_END)\n            break;\n    }\n    inflateEnd(&zstream);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    zstream.zalloc = ff_png_zalloc;\n    zstream.zfree  = ff_png_zfree;\n    zstream.opaque = NULL;\n    if (inflateInit(&zstream) != Z_OK)\n        return AVERROR_EXTERNAL;\n    zstream.next_in  = (unsigned char *)data;\n    zstream.avail_in = data_end - data;\n    av_bprint_init(bp, 0, -1);\n\n    while (zstream.avail_in > 0) {\n        av_bprint_get_buffer(bp, 2, &buf, &buf_size);\n        if (buf_size < 2) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n        zstream.next_out  = buf;\n        zstream.avail_out = buf_size - 1;\n        ret = inflate(&zstream, Z_PARTIAL_FLUSH);\n        if (ret != Z_OK && ret != Z_STREAM_END) {\n            ret = AVERROR_EXTERNAL;\n            goto fail;\n        }\n        bp->len += zstream.next_out - buf;\n        if (ret == Z_STREAM_END)\n            break;\n    }\n    inflateEnd(&zstream);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tbreak;\n\t}\n\n\tif (idstr)\n\t\tND_PRINT((ndo,\" #%d id=%s \", t.t_no, idstr));\n\telse\n\t\tND_PRINT((ndo,\" #%d id=%d \", t.t_no, t.t_id));\n\tcp = (const u_char *)(p + 1);\n\tep2 = (const u_char *)p + item_len;\n\twhile (cp < ep && cp < ep2) {\n\t\tif (map && nmap) {\n\t\t\tcp = ikev1_attrmap_print(ndo, cp, (ep < ep2) ? ep : ep2,\n\t\t\t\tmap, nmap);\n\t\t} else\n\t\t\tcp = ikev1_attr_print(ndo, cp, (ep < ep2) ? ep : ep2);\n\t}\n\tif (ep < ep2)\n\t\tND_PRINT((ndo,\"...\"));\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_T)));\n\treturn NULL;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tbreak;\n\t}\n\n\tif (idstr)\n\t\tND_PRINT((ndo,\" #%d id=%s \", t.t_no, idstr));\n\telse\n\t\tND_PRINT((ndo,\" #%d id=%d \", t.t_no, t.t_id));\n\tcp = (const u_char *)(p + 1);\n\tep2 = (const u_char *)p + item_len;\n\twhile (cp < ep && cp < ep2) {\n\t\tif (map && nmap)\n\t\t\tcp = ikev1_attrmap_print(ndo, cp, ep2, map, nmap);\n\t\telse\n\t\t\tcp = ikev1_attr_print(ndo, cp, ep2);\n\t\tif (cp == NULL)\n\t\t\tgoto trunc;\n\t}\n\tif (ep < ep2)\n\t\tND_PRINT((ndo,\"...\"));\n\treturn cp;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_T)));\n\treturn NULL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tint c;\n\tint y;\n\tint x;\n\tint v;\n\tint i;\n\tjas_matrix_t *data[3];\n\n/* Note: This function does not properly handle images with a colormap. */\n\t/* Avoid compiler warnings about unused parameters. */\n\tcmap = 0;\n\n\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\tdata[i] = jas_matrix_create(1, jas_image_width(image));\n\t\tassert(data[i]);\n\t}\n\n\tpad = RAS_ROWSIZE(hdr) - (hdr->width * hdr->depth + 7) / 8;\n\n\tfor (y = 0; y < hdr->height; y++) {\n\t\tnz = 0;\n\t\tz = 0;\n\t\tfor (x = 0; x < hdr->width; x++) {\n\t\t\twhile (nz < hdr->depth) {\n\t\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tz = (z << 8) | c;\n\t\t\t\tnz += 8;\n\t\t\t}\n\n\t\t\tv = (z >> (nz - hdr->depth)) & RAS_ONES(hdr->depth);\n\t\t\tz &= RAS_ONES(nz - hdr->depth);\n\t\t\tnz -= hdr->depth;\n\n\t\t\tif (jas_image_numcmpts(image) == 3) {\n\t\t\t\tjas_matrix_setv(data[0], x, (RAS_GETRED(v)));\n\t\t\t\tjas_matrix_setv(data[1], x, (RAS_GETGREEN(v)));\n\t\t\t\tjas_matrix_setv(data[2], x, (RAS_GETBLUE(v)));\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(data[0], x, (v));\n\t\t\t}\n\t\t}\n\t\tif (pad) {\n\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\t\tif (jas_image_writecmpt(image, i, 0, y, hdr->width, 1,\n\t\t\t  data[i])) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\tjas_matrix_destroy(data[i]);\n\t}\n\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tint y;\n\tint x;\n\tint v;\n\tint i;\n\tjas_matrix_t *data[3];\n\n/* Note: This function does not properly handle images with a colormap. */\n\t/* Avoid compiler warnings about unused parameters. */\n\tcmap = 0;\n\n\tassert(jas_image_numcmpts(image) <= 3);\n\n\tfor (i = 0; i < 3; ++i) {\n\t\tdata[i] = 0;\n\t}\n\n\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\tif (!(data[i] = jas_matrix_create(1, jas_image_width(image)))) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tpad = RAS_ROWSIZE(hdr) - (hdr->width * hdr->depth + 7) / 8;\n\n\tfor (y = 0; y < hdr->height; y++) {\n\t\tnz = 0;\n\t\tz = 0;\n\t\tfor (x = 0; x < hdr->width; x++) {\n\t\t\twhile (nz < hdr->depth) {\n\t\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tz = (z << 8) | c;\n\t\t\t\tnz += 8;\n\t\t\t}\n\n\t\t\tv = (z >> (nz - hdr->depth)) & RAS_ONES(hdr->depth);\n\t\t\tz &= RAS_ONES(nz - hdr->depth);\n\t\t\tnz -= hdr->depth;\n\n\t\t\tif (jas_image_numcmpts(image) == 3) {\n\t\t\t\tjas_matrix_setv(data[0], x, (RAS_GETRED(v)));\n\t\t\t\tjas_matrix_setv(data[1], x, (RAS_GETGREEN(v)));\n\t\t\t\tjas_matrix_setv(data[2], x, (RAS_GETBLUE(v)));\n\t\t\t} else {\n\t\t\t\tjas_matrix_setv(data[0], x, (v));\n\t\t\t}\n\t\t}\n\t\tif (pad) {\n\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\t\tif (jas_image_writecmpt(image, i, 0, y, hdr->width, 1,\n\t\t\t  data[i])) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\tjas_matrix_destroy(data[i]);\n\t\tdata[i] = 0;\n\t}\n\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < 3; ++i) {\n\t\tif (data[i]) {\n\t\t\tjas_matrix_destroy(data[i]);\n\t\t}\n\t}\n\treturn -1;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\treturn 0;\n\t}\n\n\tif (var_hash && (*p)[0] != 'R') {\n\t\tvar_push(var_hash, rval);\n\t}\n\n\tstart = cursor;\n\n\n#line 585 \"ext/standard/var_unserializer.c\"\n{\n\tYYCTYPE yych;\n\tstatic const unsigned char yybm[] = {\n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t128, 128, 128, 128, 128, 128, 128, 128, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t};\n\tif ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);\n\tyych = *YYCURSOR;\n\tswitch (yych) {\n\tcase 'C':\n\tcase 'O':\tgoto yy13;\n\tcase 'N':\tgoto yy5;\n\tcase 'R':\tgoto yy2;\n\tcase 'S':\tgoto yy10;\n\tcase 'a':\tgoto yy11;\n\tcase 'b':\tgoto yy6;\n\tcase 'd':\tgoto yy8;\n\tcase 'i':\tgoto yy7;\n\tcase 'o':\tgoto yy12;\n\tcase 'r':\tgoto yy4;\n\tcase 's':\tgoto yy9;\n\tcase '}':\tgoto yy14;\n\tdefault:\tgoto yy16;\n\t}\nyy2:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy95;\nyy3:\n#line 962 \"ext/standard/var_unserializer.re\"\n\t{ return 0; }\n#line 646 \"ext/standard/var_unserializer.c\"\nyy4:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy89;\n\tgoto yy3;\nyy5:\n\tyych = *++YYCURSOR;\n\tif (yych == ';') goto yy87;\n\tgoto yy3;\nyy6:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy83;\n\tgoto yy3;\nyy7:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy77;\n\tgoto yy3;\nyy8:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy53;\n\tgoto yy3;\nyy9:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy46;\n\tgoto yy3;\nyy10:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy39;\n\tgoto yy3;\nyy11:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy32;\n\tgoto yy3;\nyy12:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy25;\n\tgoto yy3;\nyy13:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy17;\n\tgoto yy3;\nyy14:\n\t++YYCURSOR;\n#line 956 \"ext/standard/var_unserializer.re\"\n\t{\n\t/* this is the case where we have less data than planned */\n\tphp_error_docref(NULL, E_NOTICE, \"Unexpected end of serialized data\");\n\treturn 0; /* not sure if it should be 0 or 1 here? */\n}\n#line 695 \"ext/standard/var_unserializer.c\"\nyy16:\n\tyych = *++YYCURSOR;\n\tgoto yy3;\nyy17:\n\tyych = *++YYCURSOR;\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy20;\n\t}\n\tif (yych == '+') goto yy19;\nyy18:\n\tYYCURSOR = YYMARKER;\n\tgoto yy3;\nyy19:\n\tyych = *++YYCURSOR;\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy20;\n\t}\n\tgoto yy18;\nyy20:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy20;\n\t}\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ';') goto yy18;\n\tyych = *++YYCURSOR;\n\tif (yych != '\"') goto yy18;\n\t++YYCURSOR;\n#line 804 \"ext/standard/var_unserializer.re\"\n\t{\n\tsize_t len, len2, len3, maxlen;\n\tzend_long elements;\n\tchar *str;\n\tzend_string *class_name;\n\tzend_class_entry *ce;\n\tint incomplete_class = 0;\n\n\tint custom_object = 0;\n\n\t   return 0;\n\t}\n\n\tif (incomplete_class) {\n\t\tphp_store_class_name(rval, ZSTR_VAL(class_name), len2);\n\t}\n\tzend_string_release(class_name);\n\n\treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n}\n#line 878 \"ext/standard/var_unserializer.c\"\nyy25:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy26;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy27;\n\t\tgoto yy18;\n\t}\nyy26:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy27:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy27;\n\tif (yych >= ';') goto yy18;\n\tyych = *++YYCURSOR;\n\tif (yych != '\"') goto yy18;\n\t++YYCURSOR;\n#line 793 \"ext/standard/var_unserializer.re\"\n\t{\n\tzend_long elements;\n    if (!var_hash) return 0;\n\n\telements = object_common1(UNSERIALIZE_PASSTHRU, ZEND_STANDARD_CLASS_DEF_PTR);\n\tif (elements < 0 || elements >= HT_MAX_SIZE) {\n\t\treturn 0;\n\t}\n\treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n}\n#line 914 \"ext/standard/var_unserializer.c\"\nyy32:\n\tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy33;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy34;\n\tgoto yy18;\nyy33:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy34:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy34;\n\tif (yych >= ';') goto yy18;\n\tyych = *++YYCURSOR;\n\tif (yych != '{') goto yy18;\n\t++YYCURSOR;\n#line 769 \"ext/standard/var_unserializer.re\"\n\t{\n\tzend_long elements = parse_iv(start + 2);\n\t/* use iv() not uiv() in order to check data range */\n\t*p = YYCURSOR;\n    if (!var_hash) return 0;\n\n\tif (elements < 0 || elements >= HT_MAX_SIZE) {\n\t\treturn 0;\n\t}\n\n\t\t   reference to some zvals might be keept in var_hash (to support references) */\n\t\tzend_hash_real_init(Z_ARRVAL_P(rval), 0);\n\t}\n\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_ARRVAL_P(rval), elements, 0)) {\n\t\treturn 0;\n\t}\n\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n}\n#line 959 \"ext/standard/var_unserializer.c\"\nyy39:\n\tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy40;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy41;\n\tgoto yy18;\nyy40:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy41:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy41;\n\tif (yych >= ';') goto yy18;\n\tyych = *++YYCURSOR;\n\tif (yych != '\"') goto yy18;\n\t++YYCURSOR;\n#line 735 \"ext/standard/var_unserializer.re\"\n\t{\n\tsize_t len, maxlen;\n\tzend_string *str;\n\n\tlen = parse_uiv(start + 2);\n\tmaxlen = max - YYCURSOR;\n\tif (maxlen < len) {\n\t\t*p = start + 2;\n\t\treturn 0;\n\t}\n\n\tif ((str = unserialize_str(&YYCURSOR, len, maxlen)) == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (*(YYCURSOR) != '\"') {\n\t\tzend_string_free(str);\n\t\t*p = YYCURSOR;\n\t\treturn 0;\n\t}\n\n\tif (*(YYCURSOR + 1) != ';') {\n\t\tefree(str);\n\t\t*p = YYCURSOR + 1;\n\t\treturn 0;\n\t}\n\n\tYYCURSOR += 2;\n\t*p = YYCURSOR;\n\n\tZVAL_STR(rval, str);\n\treturn 1;\n}\n#line 1014 \"ext/standard/var_unserializer.c\"\nyy46:\n\tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy47;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy48;\n\tgoto yy18;\nyy47:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy48:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy48;\n\tif (yych >= ';') goto yy18;\n\tyych = *++YYCURSOR;\n\tif (yych != '\"') goto yy18;\n\t++YYCURSOR;\n#line 703 \"ext/standard/var_unserializer.re\"\n\t{\n\tsize_t len, maxlen;\n\tchar *str;\n\n\tlen = parse_uiv(start + 2);\n\tmaxlen = max - YYCURSOR;\n\tif (maxlen < len) {\n\t\t*p = start + 2;\n\t\treturn 0;\n\t}\n\n\tstr = (char*)YYCURSOR;\n\n\tYYCURSOR += len;\n\n\tif (*(YYCURSOR) != '\"') {\n\t\t*p = YYCURSOR;\n\t\treturn 0;\n\t}\n\n\tif (*(YYCURSOR + 1) != ';') {\n\t\t*p = YYCURSOR + 1;\n\t\treturn 0;\n\t}\n\n\tYYCURSOR += 2;\n\t*p = YYCURSOR;\n\n\tZVAL_STRINGL(rval, str, len);\n\treturn 1;\n}\n#line 1067 \"ext/standard/var_unserializer.c\"\nyy53:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') {\n\t\tif (yych <= ',') {\n\t\t\tif (yych == '+') goto yy57;\n\t\t\tgoto yy18;\n\t\t} else {\n\t\t\tif (yych <= '-') goto yy55;\n\t\t\tif (yych <= '.') goto yy60;\n\t\t\tgoto yy18;\n\t\t}\n\t} else {\n\t\tif (yych <= 'I') {\n\t\t\tif (yych <= '9') goto yy58;\n\t\t\tif (yych <= 'H') goto yy18;\n\t\t\tgoto yy56;\n\t\t} else {\n\t\t\tif (yych != 'N') goto yy18;\n\t\t}\n\t}\n\tyych = *++YYCURSOR;\n\tif (yych == 'A') goto yy76;\n\tgoto yy18;\nyy55:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') {\n\t\tif (yych == '.') goto yy60;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '9') goto yy58;\n\t\tif (yych != 'I') goto yy18;\n\t}\nyy56:\n\tyych = *++YYCURSOR;\n\tif (yych == 'N') goto yy72;\n\tgoto yy18;\nyy57:\n\tyych = *++YYCURSOR;\n\tif (yych == '.') goto yy60;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy58:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n\tyych = *YYCURSOR;\n\tif (yych <= ':') {\n\t\tif (yych <= '.') {\n\t\t\tif (yych <= '-') goto yy18;\n\t\t\tgoto yy70;\n\t\t} else {\n\t\t\tif (yych <= '/') goto yy18;\n\t\t\tif (yych <= '9') goto yy58;\n\t\t\tgoto yy18;\n\t\t}\n\t} else {\n\t\tif (yych <= 'E') {\n\t\t\tif (yych <= ';') goto yy63;\n\t\t\tif (yych <= 'D') goto yy18;\n\t\t\tgoto yy65;\n\t\t} else {\n\t\t\tif (yych == 'e') goto yy65;\n\t\t\tgoto yy18;\n\t\t}\n\t}\nyy60:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy61:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n\tyych = *YYCURSOR;\n\tif (yych <= ';') {\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy61;\n\t\tif (yych <= ':') goto yy18;\n\t} else {\n\t\tif (yych <= 'E') {\n\t\t\tif (yych <= 'D') goto yy18;\n\t\t\tgoto yy65;\n\t\t} else {\n\t\t\tif (yych == 'e') goto yy65;\n\t\t\tgoto yy18;\n\t\t}\n\t}\nyy63:\n\t++YYCURSOR;\n#line 694 \"ext/standard/var_unserializer.re\"\n\t{\n#if SIZEOF_ZEND_LONG == 4\nuse_double:\n#endif\n\t*p = YYCURSOR;\n\tZVAL_DOUBLE(rval, zend_strtod((const char *)start + 2, NULL));\n\treturn 1;\n}\n#line 1164 \"ext/standard/var_unserializer.c\"\nyy65:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy66;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy67;\n\t\tgoto yy18;\n\t}\nyy66:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych == '+') goto yy69;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy69;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych >= ':') goto yy18;\n\t}\nyy67:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy67;\n\tif (yych == ';') goto yy63;\n\tgoto yy18;\nyy69:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy67;\n\tgoto yy18;\nyy70:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n\tyych = *YYCURSOR;\n\tif (yych <= ';') {\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy70;\n\t\tif (yych <= ':') goto yy18;\n\t\tgoto yy63;\n\t} else {\n\t\tif (yych <= 'E') {\n\t\t\tif (yych <= 'D') goto yy18;\n\t\t\tgoto yy65;\n\t\t} else {\n\t\t\tif (yych == 'e') goto yy65;\n\t\t\tgoto yy18;\n\t\t}\n\t}\nyy72:\n\tyych = *++YYCURSOR;\n\tif (yych != 'F') goto yy18;\nyy73:\n\tyych = *++YYCURSOR;\n\tif (yych != ';') goto yy18;\n\t++YYCURSOR;\n#line 678 \"ext/standard/var_unserializer.re\"\n\t{\n\t*p = YYCURSOR;\n\n\tif (!strncmp((char*)start + 2, \"NAN\", 3)) {\n\t\tZVAL_DOUBLE(rval, php_get_nan());\n\t} else if (!strncmp((char*)start + 2, \"INF\", 3)) {\n\t\tZVAL_DOUBLE(rval, php_get_inf());\n\t} else if (!strncmp((char*)start + 2, \"-INF\", 4)) {\n\t\tZVAL_DOUBLE(rval, -php_get_inf());\n\t} else {\n\t\tZVAL_NULL(rval);\n\t}\n\n\treturn 1;\n}\n#line 1239 \"ext/standard/var_unserializer.c\"\nyy76:\n\tyych = *++YYCURSOR;\n\tif (yych == 'N') goto yy73;\n\tgoto yy18;\nyy77:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy78;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy79;\n\t\tgoto yy18;\n\t}\nyy78:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy79:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy79;\n\tif (yych != ';') goto yy18;\n\t++YYCURSOR;\n#line 652 \"ext/standard/var_unserializer.re\"\n\t{\n#if SIZEOF_ZEND_LONG == 4\n\tint digits = YYCURSOR - start - 3;\n\n\tif (start[2] == '-' || start[2] == '+') {\n\t\tdigits--;\n\t}\n\n\t/* Use double for large zend_long values that were serialized on a 64-bit system */\n\tif (digits >= MAX_LENGTH_OF_LONG - 1) {\n\t\tif (digits == MAX_LENGTH_OF_LONG - 1) {\n\t\t\tint cmp = strncmp((char*)YYCURSOR - MAX_LENGTH_OF_LONG, long_min_digits, MAX_LENGTH_OF_LONG - 1);\n\n\t\t\tif (!(cmp < 0 || (cmp == 0 && start[2] == '-'))) {\n\t\t\t\tgoto use_double;\n\t\t\t}\n\t\t} else {\n\t\t\tgoto use_double;\n\t\t}\n\t}\n#endif\n\t*p = YYCURSOR;\n\tZVAL_LONG(rval, parse_iv(start + 2));\n\treturn 1;\n}\n#line 1292 \"ext/standard/var_unserializer.c\"\nyy83:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= '2') goto yy18;\n\tyych = *++YYCURSOR;\n\tif (yych != ';') goto yy18;\n\t++YYCURSOR;\n#line 646 \"ext/standard/var_unserializer.re\"\n\t{\n\t*p = YYCURSOR;\n\tZVAL_BOOL(rval, parse_iv(start + 2));\n\treturn 1;\n}\n#line 1306 \"ext/standard/var_unserializer.c\"\nyy87:\n\t++YYCURSOR;\n#line 640 \"ext/standard/var_unserializer.re\"\n\t{\n\t*p = YYCURSOR;\n\tZVAL_NULL(rval);\n\treturn 1;\n}\n#line 1315 \"ext/standard/var_unserializer.c\"\nyy89:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy90;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy91;\n\t\tgoto yy18;\n\t}\nyy90:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy91:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy91;\n\tif (yych != ';') goto yy18;\n\t++YYCURSOR;\n#line 615 \"ext/standard/var_unserializer.re\"\n\t{\n\tzend_long id;\n\n \t*p = YYCURSOR;\n\tif (!var_hash) return 0;\n\n\tid = parse_iv(start + 2) - 1;\n\tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (rval_ref == rval) {\n\t\treturn 0;\n\t}\n\n\tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {\n\t\tZVAL_UNDEF(rval);\n\t\treturn 1;\n\t}\n\n\tZVAL_COPY(rval, rval_ref);\n\n\treturn 1;\n}\n#line 1363 \"ext/standard/var_unserializer.c\"\nyy95:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy96;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy97;\n\t\tgoto yy18;\n\t}\nyy96:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy97:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy97;\n\tif (yych != ';') goto yy18;\n\t++YYCURSOR;\n#line 589 \"ext/standard/var_unserializer.re\"\n\t{\n\tzend_long id;\n\n \t*p = YYCURSOR;\n\tif (!var_hash) return 0;\n\n\tid = parse_iv(start + 2) - 1;\n\tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {\n\t\treturn 0;\n\t}\n\n\tzval_ptr_dtor(rval);\n\tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {\n\t\tZVAL_UNDEF(rval);\n\t\treturn 1;\n\t}\n\tif (Z_ISREF_P(rval_ref)) {\n\t\tZVAL_COPY(rval, rval_ref);\n\t} else {\n\t\tZVAL_NEW_REF(rval_ref, rval_ref);\n\t\tZVAL_COPY(rval, rval_ref);\n\t}\n\n\treturn 1;\n}\n#line 1412 \"ext/standard/var_unserializer.c\"\n}\n#line 964 \"ext/standard/var_unserializer.re\"\n\n\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\treturn 0;\n\t}\n\n\tif (var_hash && (*p)[0] != 'R') {\n\t\tvar_push(var_hash, rval);\n\t}\n\n\tstart = cursor;\n\n\n#line 576 \"ext/standard/var_unserializer.c\"\n{\n\tYYCTYPE yych;\n\tstatic const unsigned char yybm[] = {\n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t128, 128, 128, 128, 128, 128, 128, 128, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t};\n\tif ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);\n\tyych = *YYCURSOR;\n\tswitch (yych) {\n\tcase 'C':\n\tcase 'O':\tgoto yy4;\n\tcase 'N':\tgoto yy5;\n\tcase 'R':\tgoto yy6;\n\tcase 'S':\tgoto yy7;\n\tcase 'a':\tgoto yy8;\n\tcase 'b':\tgoto yy9;\n\tcase 'd':\tgoto yy10;\n\tcase 'i':\tgoto yy11;\n\tcase 'o':\tgoto yy12;\n\tcase 'r':\tgoto yy13;\n\tcase 's':\tgoto yy14;\n\tcase '}':\tgoto yy15;\n\tdefault:\tgoto yy2;\n\t}\nyy2:\n\t++YYCURSOR;\nyy3:\n#line 951 \"ext/standard/var_unserializer.re\"\n\t{ return 0; }\n#line 636 \"ext/standard/var_unserializer.c\"\nyy4:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy17;\n\tgoto yy3;\nyy5:\n\tyych = *++YYCURSOR;\n\tif (yych == ';') goto yy19;\n\tgoto yy3;\nyy6:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy21;\n\tgoto yy3;\nyy7:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy22;\n\tgoto yy3;\nyy8:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy23;\n\tgoto yy3;\nyy9:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy24;\n\tgoto yy3;\nyy10:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy25;\n\tgoto yy3;\nyy11:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy26;\n\tgoto yy3;\nyy12:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy27;\n\tgoto yy3;\nyy13:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy28;\n\tgoto yy3;\nyy14:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy29;\n\tgoto yy3;\nyy15:\n\t++YYCURSOR;\n#line 945 \"ext/standard/var_unserializer.re\"\n\t{\n\t/* this is the case where we have less data than planned */\n\tphp_error_docref(NULL, E_NOTICE, \"Unexpected end of serialized data\");\n\treturn 0; /* not sure if it should be 0 or 1 here? */\n}\n#line 689 \"ext/standard/var_unserializer.c\"\nyy17:\n\tyych = *++YYCURSOR;\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy31;\n\t}\n\tif (yych == '+') goto yy30;\nyy18:\n\tYYCURSOR = YYMARKER;\n\tgoto yy3;\nyy19:\n\t++YYCURSOR;\n#line 629 \"ext/standard/var_unserializer.re\"\n\t{\n\t*p = YYCURSOR;\n\tZVAL_NULL(rval);\n\treturn 1;\n}\n#line 707 \"ext/standard/var_unserializer.c\"\nyy21:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych == '+') goto yy33;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy33;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy34;\n\t\tgoto yy18;\n\t}\nyy22:\n\tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy36;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy37;\n\tgoto yy18;\nyy23:\n\tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy39;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy40;\n\tgoto yy18;\nyy24:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '1') goto yy42;\n\tgoto yy18;\nyy25:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') {\n\t\tif (yych <= ',') {\n\t\t\tif (yych == '+') goto yy43;\n\t\t\tgoto yy18;\n\t\t} else {\n\t\t\tif (yych <= '-') goto yy44;\n\t\t\tif (yych <= '.') goto yy45;\n\t\t\tgoto yy18;\n\t\t}\n\t} else {\n\t\tif (yych <= 'I') {\n\t\t\tif (yych <= '9') goto yy46;\n\t\t\tif (yych <= 'H') goto yy18;\n\t\t\tgoto yy48;\n\t\t} else {\n\t\t\tif (yych == 'N') goto yy49;\n\t\t\tgoto yy18;\n\t\t}\n\t}\nyy26:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych == '+') goto yy50;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy50;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy51;\n\t\tgoto yy18;\n\t}\nyy27:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych == '+') goto yy53;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy53;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy54;\n\t\tgoto yy18;\n\t}\nyy28:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych == '+') goto yy56;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy56;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy57;\n\t\tgoto yy18;\n\t}\nyy29:\n\tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy59;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy60;\n\tgoto yy18;\nyy30:\n\tyych = *++YYCURSOR;\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy31;\n\t}\n\tgoto yy18;\nyy31:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy31;\n\t}\n\tif (yych <= '/') goto yy18;\n\tif (yych <= ':') goto yy62;\n\tgoto yy18;\nyy33:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy34:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy34;\n\tif (yych == ';') goto yy63;\n\tgoto yy18;\nyy36:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy37:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy37;\n\tif (yych <= ':') goto yy65;\n\tgoto yy18;\nyy39:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy40:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy40;\n\tif (yych <= ':') goto yy66;\n\tgoto yy18;\nyy42:\n\tyych = *++YYCURSOR;\n\tif (yych == ';') goto yy67;\n\tgoto yy18;\nyy43:\n\tyych = *++YYCURSOR;\n\tif (yych == '.') goto yy45;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy46;\n\tgoto yy18;\nyy44:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') {\n\t\tif (yych != '.') goto yy18;\n\t} else {\n\t\tif (yych <= '9') goto yy46;\n\t\tif (yych == 'I') goto yy48;\n\t\tgoto yy18;\n\t}\nyy45:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy69;\n\tgoto yy18;\nyy46:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n\tyych = *YYCURSOR;\n\tif (yych <= ':') {\n\t\tif (yych <= '.') {\n\t\t\tif (yych <= '-') goto yy18;\n\t\t\tgoto yy69;\n\t\t} else {\n\t\t\tif (yych <= '/') goto yy18;\n\t\t\tif (yych <= '9') goto yy46;\n\t\t\tgoto yy18;\n\t\t}\n\t} else {\n\t\tif (yych <= 'E') {\n\t\t\tif (yych <= ';') goto yy71;\n\t\t\tif (yych <= 'D') goto yy18;\n\t\t\tgoto yy73;\n\t\t} else {\n\t\t\tif (yych == 'e') goto yy73;\n\t\t\tgoto yy18;\n\t\t}\n\t}\nyy48:\n\tyych = *++YYCURSOR;\n\tif (yych == 'N') goto yy74;\n\tgoto yy18;\nyy49:\n\tyych = *++YYCURSOR;\n\tif (yych == 'A') goto yy75;\n\tgoto yy18;\nyy50:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy51:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy51;\n\tif (yych == ';') goto yy76;\n\tgoto yy18;\nyy53:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy54:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy54;\n\tif (yych <= ':') goto yy78;\n\tgoto yy18;\nyy56:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy57:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy57;\n\tif (yych == ';') goto yy79;\n\tgoto yy18;\nyy59:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy60:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy60;\n\tif (yych <= ':') goto yy81;\n\tgoto yy18;\nyy62:\n\tyych = *++YYCURSOR;\n\tif (yych == '\"') goto yy82;\n\tgoto yy18;\nyy63:\n\t++YYCURSOR;\n#line 580 \"ext/standard/var_unserializer.re\"\n\t{\n\tzend_long id;\n\n \t*p = YYCURSOR;\n\tif (!var_hash) return 0;\n\n\tid = parse_iv(start + 2) - 1;\n\tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {\n\t\treturn 0;\n\t}\n\n\tif (Z_ISREF_P(rval_ref)) {\n\t\tZVAL_COPY(rval, rval_ref);\n\t} else {\n\t\tZVAL_NEW_REF(rval_ref, rval_ref);\n\t\tZVAL_COPY(rval, rval_ref);\n\t}\n\n\treturn 1;\n}\n#line 982 \"ext/standard/var_unserializer.c\"\nyy65:\n\tyych = *++YYCURSOR;\n\tif (yych == '\"') goto yy84;\n\tgoto yy18;\nyy66:\n\tyych = *++YYCURSOR;\n\tif (yych == '{') goto yy86;\n\tgoto yy18;\nyy67:\n\t++YYCURSOR;\n#line 635 \"ext/standard/var_unserializer.re\"\n\t{\n\t*p = YYCURSOR;\n\tZVAL_BOOL(rval, parse_iv(start + 2));\n\treturn 1;\n}\n#line 999 \"ext/standard/var_unserializer.c\"\nyy69:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n\tyych = *YYCURSOR;\n\tif (yych <= ';') {\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy69;\n\t\tif (yych <= ':') goto yy18;\n\t} else {\n\t\tif (yych <= 'E') {\n\t\t\tif (yych <= 'D') goto yy18;\n\t\t\tgoto yy73;\n\t\t} else {\n\t\t\tif (yych == 'e') goto yy73;\n\t\t\tgoto yy18;\n\t\t}\n\t}\nyy71:\n\t++YYCURSOR;\n#line 683 \"ext/standard/var_unserializer.re\"\n\t{\n#if SIZEOF_ZEND_LONG == 4\nuse_double:\n#endif\n\t*p = YYCURSOR;\n\tZVAL_DOUBLE(rval, zend_strtod((const char *)start + 2, NULL));\n\treturn 1;\n}\n#line 1028 \"ext/standard/var_unserializer.c\"\nyy73:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych == '+') goto yy88;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy88;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych <= '9') goto yy89;\n\t\tgoto yy18;\n\t}\nyy74:\n\tyych = *++YYCURSOR;\n\tif (yych == 'F') goto yy91;\n\tgoto yy18;\nyy75:\n\tyych = *++YYCURSOR;\n\tif (yych == 'N') goto yy91;\n\tgoto yy18;\nyy76:\n\t++YYCURSOR;\n#line 641 \"ext/standard/var_unserializer.re\"\n\t{\n#if SIZEOF_ZEND_LONG == 4\n\tint digits = YYCURSOR - start - 3;\n\n\tif (start[2] == '-' || start[2] == '+') {\n\t\tdigits--;\n\t}\n\n\t/* Use double for large zend_long values that were serialized on a 64-bit system */\n\tif (digits >= MAX_LENGTH_OF_LONG - 1) {\n\t\tif (digits == MAX_LENGTH_OF_LONG - 1) {\n\t\t\tint cmp = strncmp((char*)YYCURSOR - MAX_LENGTH_OF_LONG, long_min_digits, MAX_LENGTH_OF_LONG - 1);\n\n\t\t\tif (!(cmp < 0 || (cmp == 0 && start[2] == '-'))) {\n\t\t\t\tgoto use_double;\n\t\t\t}\n\t\t} else {\n\t\t\tgoto use_double;\n\t\t}\n\t}\n#endif\n\t*p = YYCURSOR;\n\tZVAL_LONG(rval, parse_iv(start + 2));\n\treturn 1;\n}\n#line 1076 \"ext/standard/var_unserializer.c\"\nyy78:\n\tyych = *++YYCURSOR;\n\tif (yych == '\"') goto yy92;\n\tgoto yy18;\nyy79:\n\t++YYCURSOR;\n#line 605 \"ext/standard/var_unserializer.re\"\n\t{\n\tzend_long id;\n\n \t*p = YYCURSOR;\n\tif (!var_hash) return 0;\n\n\tid = parse_iv(start + 2) - 1;\n\tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (rval_ref == rval) {\n\t\treturn 0;\n\t}\n\n\tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {\n\t\treturn 0;\n\t}\n\n\tZVAL_COPY(rval, rval_ref);\n\n\treturn 1;\n}\n#line 1107 \"ext/standard/var_unserializer.c\"\nyy81:\n\tyych = *++YYCURSOR;\n\tif (yych == '\"') goto yy94;\n\tgoto yy18;\nyy82:\n\t++YYCURSOR;\n#line 793 \"ext/standard/var_unserializer.re\"\n\t{\n\tsize_t len, len2, len3, maxlen;\n\tzend_long elements;\n\tchar *str;\n\tzend_string *class_name;\n\tzend_class_entry *ce;\n\tint incomplete_class = 0;\n\n\tint custom_object = 0;\n\n\t   return 0;\n\t}\n\n\tif (incomplete_class) {\n\t\tphp_store_class_name(rval, ZSTR_VAL(class_name), len2);\n\t}\n\tzend_string_release(class_name);\n\n\treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n}\n#line 1266 \"ext/standard/var_unserializer.c\"\nyy84:\n\t++YYCURSOR;\n#line 724 \"ext/standard/var_unserializer.re\"\n\t{\n\tsize_t len, maxlen;\n\tzend_string *str;\n\n\tlen = parse_uiv(start + 2);\n\tmaxlen = max - YYCURSOR;\n\tif (maxlen < len) {\n\t\t*p = start + 2;\n\t\treturn 0;\n\t}\n\n\tif ((str = unserialize_str(&YYCURSOR, len, maxlen)) == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (*(YYCURSOR) != '\"') {\n\t\tzend_string_free(str);\n\t\t*p = YYCURSOR;\n\t\treturn 0;\n\t}\n\n\tif (*(YYCURSOR + 1) != ';') {\n\t\tefree(str);\n\t\t*p = YYCURSOR + 1;\n\t\treturn 0;\n\t}\n\n\tYYCURSOR += 2;\n\t*p = YYCURSOR;\n\n\tZVAL_STR(rval, str);\n\treturn 1;\n}\n#line 1303 \"ext/standard/var_unserializer.c\"\nyy86:\n\t++YYCURSOR;\n#line 758 \"ext/standard/var_unserializer.re\"\n\t{\n\tzend_long elements = parse_iv(start + 2);\n\t/* use iv() not uiv() in order to check data range */\n\t*p = YYCURSOR;\n    if (!var_hash) return 0;\n\n\tif (elements < 0 || elements >= HT_MAX_SIZE) {\n\t\treturn 0;\n\t}\n\n\t\t   reference to some zvals might be keept in var_hash (to support references) */\n\t\tzend_hash_real_init(Z_ARRVAL_P(rval), 0);\n\t}\n\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_ARRVAL_P(rval), elements, 0)) {\n\t\treturn 0;\n\t}\n\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n}\n#line 1330 \"ext/standard/var_unserializer.c\"\nyy88:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych == '+') goto yy96;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy96;\n\t\tif (yych <= '/') goto yy18;\n\t\tif (yych >= ':') goto yy18;\n\t}\nyy89:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy89;\n\tif (yych == ';') goto yy71;\n\tgoto yy18;\nyy91:\n\tyych = *++YYCURSOR;\n\tif (yych == ';') goto yy97;\n\tgoto yy18;\nyy92:\n\t++YYCURSOR;\n#line 782 \"ext/standard/var_unserializer.re\"\n\t{\n\tzend_long elements;\n    if (!var_hash) return 0;\n\n\telements = object_common1(UNSERIALIZE_PASSTHRU, ZEND_STANDARD_CLASS_DEF_PTR);\n\tif (elements < 0 || elements >= HT_MAX_SIZE) {\n\t\treturn 0;\n\t}\n\treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n}\n#line 1366 \"ext/standard/var_unserializer.c\"\nyy94:\n\t++YYCURSOR;\n#line 692 \"ext/standard/var_unserializer.re\"\n\t{\n\tsize_t len, maxlen;\n\tchar *str;\n\n\tlen = parse_uiv(start + 2);\n\tmaxlen = max - YYCURSOR;\n\tif (maxlen < len) {\n\t\t*p = start + 2;\n\t\treturn 0;\n\t}\n\n\tstr = (char*)YYCURSOR;\n\n\tYYCURSOR += len;\n\n\tif (*(YYCURSOR) != '\"') {\n\t\t*p = YYCURSOR;\n\t\treturn 0;\n\t}\n\n\tif (*(YYCURSOR + 1) != ';') {\n\t\t*p = YYCURSOR + 1;\n\t\treturn 0;\n\t}\n\n\tYYCURSOR += 2;\n\t*p = YYCURSOR;\n\n\tZVAL_STRINGL(rval, str, len);\n\treturn 1;\n}\n#line 1401 \"ext/standard/var_unserializer.c\"\nyy96:\n\tyych = *++YYCURSOR;\n\tif (yych <= '/') goto yy18;\n\tif (yych <= '9') goto yy89;\n\tgoto yy18;\nyy97:\n\t++YYCURSOR;\n#line 667 \"ext/standard/var_unserializer.re\"\n\t{\n\t*p = YYCURSOR;\n\n\tif (!strncmp((char*)start + 2, \"NAN\", 3)) {\n\t\tZVAL_DOUBLE(rval, php_get_nan());\n\t} else if (!strncmp((char*)start + 2, \"INF\", 3)) {\n\t\tZVAL_DOUBLE(rval, php_get_inf());\n\t} else if (!strncmp((char*)start + 2, \"-INF\", 4)) {\n\t\tZVAL_DOUBLE(rval, -php_get_inf());\n\t} else {\n\t\tZVAL_NULL(rval);\n\t}\n\n\treturn 1;\n}\n#line 1425 \"ext/standard/var_unserializer.c\"\n}\n#line 953 \"ext/standard/var_unserializer.re\"\n\n\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    int\t\tdofold)\t    // also recompute the folds\n{\n    win_T\t*wp;\n    win_T\t*wp_other = NULL;\n    int\t\tused_max_fill_other = FALSE;\n    int\t\tused_max_fill_curwin = FALSE;\n    int\t\tn;\n\n    need_diff_redraw = FALSE;\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_p_diff)\n\t{\n\t    redraw_win_later(wp, SOME_VALID);\n\t    if (wp != curwin)\n\t\twp_other = wp;\n#ifdef FEAT_FOLDING\n\t    if (dofold && foldmethodIsDiff(wp))\n\t\tfoldUpdateAll(wp);\n#endif\n\t    // A change may have made filler lines invalid, need to take care\n\t    // of that for other windows.",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    int\t\tdofold)\t    // also recompute the folds\n{\n    win_T\t*wp;\n    win_T\t*wp_other = NULL;\n    int\t\tused_max_fill_other = FALSE;\n    int\t\tused_max_fill_curwin = FALSE;\n    int\t\tn;\n\n    need_diff_redraw = FALSE;\n    FOR_ALL_WINDOWS(wp)\n\t// when closing windows or wiping buffers skip invalid window\n\tif (wp->w_p_diff && buf_valid(wp->w_buffer))\n\t{\n\t    redraw_win_later(wp, SOME_VALID);\n\t    if (wp != curwin)\n\t\twp_other = wp;\n#ifdef FEAT_FOLDING\n\t    if (dofold && foldmethodIsDiff(wp))\n\t\tfoldUpdateAll(wp);\n#endif\n\t    // A change may have made filler lines invalid, need to take care\n\t    // of that for other windows.",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "                                &err);\n\n      /* abort on error or cancellation */\n      if (info == NULL)\n        {\n          g_object_unref (target_file);\n          break;\n        }\n\n      /* update progress information */\n      exo_job_info_message (EXO_JOB (job), g_file_info_get_display_name (info));\n\nretry_copy:\n      /* copy the item specified by this node (not recursively) */\n      real_target_file = thunar_transfer_job_copy_file (job, node->source_file, \n                                                        target_file, &err);\n      if (G_LIKELY (real_target_file != NULL))\n        {\n          /* node->source_file == real_target_file means to skip the file */\n          if (G_LIKELY (node->source_file != real_target_file))\n            {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "                                &err);\n\n      /* abort on error or cancellation */\n      if (info == NULL)\n        {\n          g_object_unref (target_file);\n          break;\n        }\n\n      /* update progress information */\n      exo_job_info_message (EXO_JOB (job), \"%s\", g_file_info_get_display_name (info));\n\nretry_copy:\n      /* copy the item specified by this node (not recursively) */\n      real_target_file = thunar_transfer_job_copy_file (job, node->source_file, \n                                                        target_file, &err);\n      if (G_LIKELY (real_target_file != NULL))\n        {\n          /* node->source_file == real_target_file means to skip the file */\n          if (G_LIKELY (node->source_file != real_target_file))\n            {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"</nodes>\");\n\t\t\t\tsdump->indent--;\n\t\t\t\tDUMP_IND(sdump);\n\t\t\t\tgf_fprintf(sdump->trace, \"</fieldValue>\\n\");\n\t\t\t} else {\n\t\t\t\tif (sdump->X3DDump) {\n\t\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t\t} else {\n\t\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t\t}\n\t\t\t\tif (mffield) {\n\t\t\t\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t}\n\t\t}\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\t\tif (!sdump->X3DDump) gf_fprintf(sdump->trace, \"</nodes>\");\n\t\t\t\tsdump->indent--;\n\t\t\t\tDUMP_IND(sdump);\n\t\t\t\tgf_fprintf(sdump->trace, \"</fieldValue>\\n\");\n\t\t\t} else {\n\t\t\t\tif (sdump->X3DDump) {\n\t\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t\t} else {\n\t\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t\t}\n\t\t\t\tfor (i=0; mffield && (i<mffield->count); i++) {\n\t\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_fprintf(sdump->trace, \"\\\"/>\\n\");\n\t\t\t}\n\t\t}\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int cli_scanxar(cli_ctx *ctx)\n{\n    int rc = CL_SUCCESS;\n    unsigned int cksum_fails = 0;\n    unsigned int extract_errors = 0;\n#if HAVE_LIBXML2\n    int fd = -1;\n    struct xar_header hdr;\n    fmap_t *map = *ctx->fmap;\n    long length, offset, size, at;\n    int encoding;\n    z_stream strm;\n    char *toc, *tmpname;\n    xmlTextReaderPtr reader = NULL;\n    int a_hash, e_hash;\n    unsigned char *a_cksum = NULL, *e_cksum = NULL;\n    void *a_hash_ctx = NULL, *e_hash_ctx = NULL;\n    char result[SHA1_HASH_SIZE];\n\n    memset(&strm, 0x00, sizeof(z_stream));\n        cli_dbgmsg(\"cli_scanxar:inflate error %i \\n\", rc);\n        rc = CL_EFORMAT;\n        goto exit_toc;\n    }\n    rc = inflateEnd(&strm);\n    if (rc != Z_OK) {\n        cli_dbgmsg(\"cli_scanxar:inflateEnd error %i \\n\", rc);\n        rc = CL_EFORMAT;\n        goto exit_toc;\n    }\n\n    /* cli_dbgmsg(\"cli_scanxar: TOC xml:\\n%s\\n\", toc); */\n    /* printf(\"cli_scanxar: TOC xml:\\n%s\\n\", toc); */\n    /* cli_dbgmsg(\"cli_scanxar: TOC end:\\n\"); */\n    /* printf(\"cli_scanxar: TOC end:\\n\"); */\n\n    /* scan the xml */\n    cli_dbgmsg(\"cli_scanxar: scanning xar TOC xml in memory.\\n\"); \n    rc = cli_mem_scandesc(toc, hdr.toc_length_decompressed, ctx);\n    if (rc != CL_SUCCESS) {\n        if (rc != CL_VIRUS || !SCAN_ALL)\n                goto exit_reader;\n        }\n\n        at = offset + hdr.toc_length_compressed + hdr.size;\n\n        if ((rc = cli_gentempfd(ctx->engine->tmpdir, &tmpname, &fd)) != CL_SUCCESS) {\n            cli_dbgmsg(\"cli_scanxar: Can't generate temporary file.\\n\");\n            goto exit_reader;\n        }\n\n        cli_dbgmsg(\"cli_scanxar: decompress into temp file:\\n%s, size %li,\\n\"\n                   \"from xar heap offset %li length %li\\n\",\n                   tmpname, size, offset, length);\n\n\n        a_hash_ctx = xar_hash_init(a_hash, &a_sc, &a_mc);\n        e_hash_ctx = xar_hash_init(e_hash, &e_sc, &e_mc);\n\n        switch (encoding) {\n        case CL_TYPE_GZ:\n            /* inflate gzip directly because file segments do not contain magic */\n            memset(&strm, 0, sizeof(strm));\n            }\n\n            inflateEnd(&strm);\n            break;\n        case CL_TYPE_7Z:\n#define CLI_LZMA_OBUF_SIZE 1024*1024\n#define CLI_LZMA_HDR_SIZE LZMA_PROPS_SIZE+8\n#define CLI_LZMA_IBUF_SIZE CLI_LZMA_OBUF_SIZE>>2 /* estimated compression ratio 25% */\n            {\n                struct CLI_LZMA lz;\n                unsigned long in_remaining = length;\n                unsigned long out_size = 0;\n                unsigned char * buff = __lzma_wrap_alloc(NULL, CLI_LZMA_OBUF_SIZE);\n                int lret;\n                \n                memset(&lz, 0, sizeof(lz));\n                if (buff == NULL) {\n                    cli_dbgmsg(\"cli_scanxar: memory request for lzma decompression buffer fails.\\n\");\n                    rc = CL_EMEM;\n                    goto exit_tmpfile;\n                    \n                }\n\n                blockp = (void*)fmap_need_off_once(map, at, CLI_LZMA_HDR_SIZE);\n                if (blockp == NULL) {\n                    char errbuff[128];\n                    cli_strerror(errno, errbuff, sizeof(errbuff));\n                    cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno:%s.\\n\",\n                               length, at, errbuff);\n                    rc = CL_EREAD;\n                    __lzma_wrap_free(NULL, buff);\n                    goto exit_tmpfile;\n                }\n\n                lz.next_in = blockp;\n                lz.avail_in = CLI_LZMA_HDR_SIZE;\n\n                if (a_hash_ctx != NULL)\n                    xar_hash_update(a_hash_ctx, blockp, CLI_LZMA_HDR_SIZE, a_hash);\n                    unsigned long in_consumed;\n\n                    lz.next_out = buff;\n                    lz.avail_out = CLI_LZMA_OBUF_SIZE;\n                    lz.avail_in = avail_in = MIN(CLI_LZMA_IBUF_SIZE, in_remaining);\n                    lz.next_in = next_in = (void*)fmap_need_off_once(map, at, lz.avail_in);\n                    if (lz.next_in == NULL) {\n                        char errbuff[128];\n                        cli_strerror(errno, errbuff, sizeof(errbuff));\n                        cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno: %s.\\n\",\n                                   length, at, errbuff);\n                        rc = CL_EREAD;\n                        __lzma_wrap_free(NULL, buff);\n                        cli_LzmaShutdown(&lz);\n                        goto exit_tmpfile;\n                    }\n\n                    lret = cli_LzmaDecode(&lz);\n                    if (lret != LZMA_RESULT_OK && lret != LZMA_STREAM_END) {\n                        cli_dbgmsg(\"cli_scanxar: cli_LzmaDecode() fails: %i.\\n\", lret);\n                        rc = CL_EFORMAT;\n                __lzma_wrap_free(NULL, buff);\n            }\n            break; \n        case CL_TYPE_ANY:\n        default:\n        case CL_TYPE_BZ:\n        case CL_TYPE_XZ:\n            /* for uncompressed, bzip2, xz, and unknown, just pull the file, cli_magic_scandesc does the rest */\n            do_extract_cksum = 0;\n            {\n                unsigned long write_len;\n                \n                if (ctx->engine->maxfilesize)\n                    write_len = MIN((size_t)(ctx->engine->maxfilesize), (size_t)length);\n                else\n                    write_len = length;\n                    \n                if (!(blockp = (void*)fmap_need_off_once(map, at, length))) {\n                    char errbuff[128];\n                    cli_strerror(errno, errbuff, sizeof(errbuff));\n                    cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno:%s.\\n\",\n                               length, at, errbuff);\n                    rc = CL_EREAD;\n                    goto exit_tmpfile;\n                }\n                \n                if (a_hash_ctx != NULL)\n                    xar_hash_update(a_hash_ctx, blockp, length, a_hash);\n                \n                if (cli_writen(fd, blockp, write_len) < 0) {\n                    cli_dbgmsg(\"cli_scanxar: cli_writen error %li bytes @ %li.\\n\", length, at);\n                    rc = CL_EWRITE;\n                    goto exit_tmpfile;\n                }\n                /*break;*/\n            }          \n        }\n\n        if (rc == CL_SUCCESS) {\n            if (a_hash_ctx != NULL) {\n                xar_hash_final(a_hash_ctx, result, a_hash);\n                a_hash_ctx = NULL;\n            } else {\n                cli_dbgmsg(\"cli_scanxar: archived-checksum missing.\\n\");\n                cksum_fails++;\n            }\n            if (a_cksum != NULL) {\n    xmlFreeTextReader(reader);\n\n exit_toc:\n    free(toc);\n    if (rc == CL_BREAK)\n        rc = CL_SUCCESS;\n#else\n    cli_dbgmsg(\"cli_scanxar: can't scan xar files, need libxml2.\\n\");\n#endif\n    if (cksum_fails + extract_errors != 0) {\n        cli_warnmsg(\"cli_scanxar: %u checksum errors and %u extraction errors, use --debug for more info.\\n\",\n                    cksum_fails, extract_errors);\n    }\n\n    return rc;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int cli_scanxar(cli_ctx *ctx)\n{\n    int rc = CL_SUCCESS;\n    unsigned int cksum_fails = 0;\n    unsigned int extract_errors = 0;\n#if HAVE_LIBXML2\n    int fd = -1;\n    struct xar_header hdr;\n    fmap_t *map = *ctx->fmap;\n    size_t length, offset, size, at;\n    int encoding;\n    z_stream strm;\n    char *toc, *tmpname;\n    xmlTextReaderPtr reader = NULL;\n    int a_hash, e_hash;\n    unsigned char *a_cksum = NULL, *e_cksum = NULL;\n    void *a_hash_ctx = NULL, *e_hash_ctx = NULL;\n    char result[SHA1_HASH_SIZE];\n\n    memset(&strm, 0x00, sizeof(z_stream));\n        rc = CL_EFORMAT;\n        goto exit_toc;\n    }\n    rc = inflateEnd(&strm);\n    if (rc != Z_OK) {\n        cli_dbgmsg(\"cli_scanxar:inflateEnd error %i \\n\", rc);\n        rc = CL_EFORMAT;\n        goto exit_toc;\n    }\n\n    if (hdr.toc_length_decompressed != strm.total_out) {\n        cli_dbgmsg(\"TOC decompress length %\" PRIu64 \" does not match amount decompressed %lu\\n\",\n                   hdr.toc_length_decompressed, strm.total_out);\n        toc[strm.total_out] = '\\0';\n        hdr.toc_length_decompressed = strm.total_out;\n    }\n\n    /* cli_dbgmsg(\"cli_scanxar: TOC xml:\\n%s\\n\", toc); */\n    /* printf(\"cli_scanxar: TOC xml:\\n%s\\n\", toc); */\n    /* cli_dbgmsg(\"cli_scanxar: TOC end:\\n\"); */\n    /* printf(\"cli_scanxar: TOC end:\\n\"); */\n\n    /* scan the xml */\n    cli_dbgmsg(\"cli_scanxar: scanning xar TOC xml in memory.\\n\"); \n    rc = cli_mem_scandesc(toc, hdr.toc_length_decompressed, ctx);\n    if (rc != CL_SUCCESS) {\n        if (rc != CL_VIRUS || !SCAN_ALL)\n                goto exit_reader;\n        }\n\n        at = offset + hdr.toc_length_compressed + hdr.size;\n\n        if ((rc = cli_gentempfd(ctx->engine->tmpdir, &tmpname, &fd)) != CL_SUCCESS) {\n            cli_dbgmsg(\"cli_scanxar: Can't generate temporary file.\\n\");\n            goto exit_reader;\n        }\n\n        cli_dbgmsg(\"cli_scanxar: decompress into temp file:\\n%s, size %zu,\\n\"\n                   \"from xar heap offset %zu length %zu\\n\",\n                   tmpname, size, offset, length);\n\n\n        a_hash_ctx = xar_hash_init(a_hash, &a_sc, &a_mc);\n        e_hash_ctx = xar_hash_init(e_hash, &e_sc, &e_mc);\n\n        switch (encoding) {\n        case CL_TYPE_GZ:\n            /* inflate gzip directly because file segments do not contain magic */\n            memset(&strm, 0, sizeof(strm));\n            }\n\n            inflateEnd(&strm);\n            break;\n        case CL_TYPE_7Z:\n#define CLI_LZMA_OBUF_SIZE 1024*1024\n#define CLI_LZMA_HDR_SIZE LZMA_PROPS_SIZE+8\n#define CLI_LZMA_IBUF_SIZE CLI_LZMA_OBUF_SIZE>>2 /* estimated compression ratio 25% */\n            {\n                struct CLI_LZMA lz;\n                unsigned long in_remaining = MIN(length, map->len - at);\n                unsigned long out_size = 0;\n                unsigned char * buff = __lzma_wrap_alloc(NULL, CLI_LZMA_OBUF_SIZE);\n                int lret;\n\n                if (length > in_remaining)\n                    length = in_remaining;\n\n                memset(&lz, 0, sizeof(lz));\n                if (buff == NULL) {\n                    cli_dbgmsg(\"cli_scanxar: memory request for lzma decompression buffer fails.\\n\");\n                    rc = CL_EMEM;\n                    goto exit_tmpfile;\n                    \n                }\n\n                blockp = (void*)fmap_need_off_once(map, at, CLI_LZMA_HDR_SIZE);\n                if (blockp == NULL) {\n                    char errbuff[128];\n                    cli_strerror(errno, errbuff, sizeof(errbuff));\n                    cli_dbgmsg(\"cli_scanxar: Can't read %i bytes @ %li, errno:%s.\\n\",\n                               CLI_LZMA_HDR_SIZE, at, errbuff);\n                    rc = CL_EREAD;\n                    __lzma_wrap_free(NULL, buff);\n                    goto exit_tmpfile;\n                }\n\n                lz.next_in = blockp;\n                lz.avail_in = CLI_LZMA_HDR_SIZE;\n\n                if (a_hash_ctx != NULL)\n                    xar_hash_update(a_hash_ctx, blockp, CLI_LZMA_HDR_SIZE, a_hash);\n                    unsigned long in_consumed;\n\n                    lz.next_out = buff;\n                    lz.avail_out = CLI_LZMA_OBUF_SIZE;\n                    lz.avail_in = avail_in = MIN(CLI_LZMA_IBUF_SIZE, in_remaining);\n                    lz.next_in = next_in = (void*)fmap_need_off_once(map, at, lz.avail_in);\n                    if (lz.next_in == NULL) {\n                        char errbuff[128];\n                        cli_strerror(errno, errbuff, sizeof(errbuff));\n                        cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno: %s.\\n\",\n                                   lz.avail_in, at, errbuff);\n                        rc = CL_EREAD;\n                        __lzma_wrap_free(NULL, buff);\n                        cli_LzmaShutdown(&lz);\n                        goto exit_tmpfile;\n                    }\n\n                    lret = cli_LzmaDecode(&lz);\n                    if (lret != LZMA_RESULT_OK && lret != LZMA_STREAM_END) {\n                        cli_dbgmsg(\"cli_scanxar: cli_LzmaDecode() fails: %i.\\n\", lret);\n                        rc = CL_EFORMAT;\n                __lzma_wrap_free(NULL, buff);\n            }\n            break; \n        case CL_TYPE_ANY:\n        default:\n        case CL_TYPE_BZ:\n        case CL_TYPE_XZ:\n            /* for uncompressed, bzip2, xz, and unknown, just pull the file, cli_magic_scandesc does the rest */\n            do_extract_cksum = 0;\n            {\n                size_t writelen = MIN(map->len - at, length);\n\n                if (ctx->engine->maxfilesize)\n                    writelen = MIN((size_t)(ctx->engine->maxfilesize), writelen);\n                    \n                if (!(blockp = (void*)fmap_need_off_once(map, at, writelen))) {\n                    char errbuff[128];\n                    cli_strerror(errno, errbuff, sizeof(errbuff));\n                    cli_dbgmsg(\"cli_scanxar: Can't read %zu bytes @ %zu, errno:%s.\\n\",\n                               writelen, at, errbuff);\n                    rc = CL_EREAD;\n                    goto exit_tmpfile;\n                }\n                \n                if (a_hash_ctx != NULL)\n                    xar_hash_update(a_hash_ctx, blockp, writelen, a_hash);\n                \n                if (cli_writen(fd, blockp, writelen) < 0) {\n                    cli_dbgmsg(\"cli_scanxar: cli_writen error %zu bytes @ %li.\\n\", writelen, at);\n                    rc = CL_EWRITE;\n                    goto exit_tmpfile;\n                }\n                /*break;*/\n            }          \n        } /* end of switch */\n\n        if (rc == CL_SUCCESS) {\n            if (a_hash_ctx != NULL) {\n                xar_hash_final(a_hash_ctx, result, a_hash);\n                a_hash_ctx = NULL;\n            } else {\n                cli_dbgmsg(\"cli_scanxar: archived-checksum missing.\\n\");\n                cksum_fails++;\n            }\n            if (a_cksum != NULL) {\n    xmlFreeTextReader(reader);\n\n exit_toc:\n    free(toc);\n    if (rc == CL_BREAK)\n        rc = CL_SUCCESS;\n#else\n    cli_dbgmsg(\"cli_scanxar: can't scan xar files, need libxml2.\\n\");\n#endif\n    if (cksum_fails + extract_errors != 0) {\n        cli_dbgmsg(\"cli_scanxar: %u checksum errors and %u extraction errors.\\n\",\n                    cksum_fails, extract_errors);\n    }\n\n    return rc;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    if (tss->Slices().size() > 1) {\n      // TODO(sherrym): Support multi-slice checkpoints.\n      return errors::Unimplemented(\"Sliced checkpoints are not supported\");\n    }\n\n    type = tss->type();\n    shape = tss->shape();\n    slice = tss->Slices().begin()->second.slice;\n  }\n\n  std::unique_ptr<tensorflow::Tensor> t(new tensorflow::Tensor(type, shape));\n  bool success = false;\n\n#define READER_COPY(dt)                                                  \\\n  case dt:                                                               \\\n    success = CopySliceData(name, slice,                                 \\\n                            t->flat<EnumToDataType<dt>::Type>().data()); \\\n    break;\n\n  switch (type) {\n    READER_COPY(DT_FLOAT);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    if (tss->Slices().size() > 1) {\n      // TODO(sherrym): Support multi-slice checkpoints.\n      return errors::Unimplemented(\"Sliced checkpoints are not supported\");\n    }\n\n    type = tss->type();\n    shape = tss->shape();\n    slice = tss->Slices().begin()->second.slice;\n  }\n\n  std::unique_ptr<tensorflow::Tensor> t(new tensorflow::Tensor);\n  Status s = tensorflow::Tensor::BuildTensor(type, shape, t.get());\n  if (!s.ok()) return s;\n  bool success = false;\n\n#define READER_COPY(dt)                                                  \\\n  case dt:                                                               \\\n    success = CopySliceData(name, slice,                                 \\\n                            t->flat<EnumToDataType<dt>::Type>().data()); \\\n    break;\n\n  switch (type) {\n    READER_COPY(DT_FLOAT);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t\t/* high 32 bits are known zero. */\n\t\t\t\tregs[insn->dst_reg].var_off = tnum_cast(\n\t\t\t\t\t\tregs[insn->dst_reg].var_off, 4);\n\t\t\t\t__update_reg_bounds(&regs[insn->dst_reg]);\n\t\t\t}\n\t\t} else {\n\t\t\t/* case: R = imm\n\t\t\t * remember the value we stored into this reg\n\t\t\t */\n\t\t\tregs[insn->dst_reg].type = SCALAR_VALUE;\n\t\t\t__mark_reg_known(regs + insn->dst_reg, insn->imm);\n\t\t}\n\n\t} else if (opcode > BPF_END) {\n\t\tverbose(env, \"invalid BPF_ALU opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\n\t} else {\t/* all other ALU ops: and, sub, xor, add, ... */\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\t\t/* high 32 bits are known zero. */\n\t\t\t\tregs[insn->dst_reg].var_off = tnum_cast(\n\t\t\t\t\t\tregs[insn->dst_reg].var_off, 4);\n\t\t\t\t__update_reg_bounds(&regs[insn->dst_reg]);\n\t\t\t}\n\t\t} else {\n\t\t\t/* case: R = imm\n\t\t\t * remember the value we stored into this reg\n\t\t\t */\n\t\t\tregs[insn->dst_reg].type = SCALAR_VALUE;\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t insn->imm);\n\t\t\t} else {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t (u32)insn->imm);\n\t\t\t}\n\t\t}\n\n\t} else if (opcode > BPF_END) {\n\t\tverbose(env, \"invalid BPF_ALU opcode %x\\n\", opcode);\n\t\treturn -EINVAL;\n\n\t} else {\t/* all other ALU ops: and, sub, xor, add, ... */\n\n\t\tif (BPF_SRC(insn->code) == BPF_X) {\n\t\t\tif (insn->imm != 0 || insn->off != 0) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "                return l;\n            }\n        default: {\n            char buf[128];\n\n            sprintf(buf, \"Non-statement found: %d %d\",\n                    TYPE(n), NCH(n));\n            Py_FatalError(buf);\n        }\n    }\n    assert(0);\n    return 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "                return l;\n            }\n        default: {\n            char buf[128];\n\n            sprintf(buf, \"Non-statement found: %d %d\",\n                    TYPE(n), NCH(n));\n            Py_FatalError(buf);\n        }\n    }\n    abort();\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "create_policy_2_svc(cpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n                                       arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_create_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "create_policy_2_svc(cpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_create_policy\",\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tstruct kvm_memory_slot *memslot;\n\tstruct kvm_memory_slot old, new;\n\tstruct kvm_memslots *slots, *old_memslots;\n\n\tr = -EINVAL;\n\t/* General sanity checks */\n\tif (mem->memory_size & (PAGE_SIZE - 1))\n\t\tgoto out;\n\tif (mem->guest_phys_addr & (PAGE_SIZE - 1))\n\t\tgoto out;\n\tif (user_alloc && (mem->userspace_addr & (PAGE_SIZE - 1)))\n\t\tgoto out;\n\tif (mem->slot >= KVM_MEMORY_SLOTS + KVM_PRIVATE_MEM_SLOTS)\n\t\tgoto out;\n\tif (mem->guest_phys_addr + mem->memory_size < mem->guest_phys_addr)\n\t\tgoto out;\n\n\tmemslot = &kvm->memslots->memslots[mem->slot];\n\tbase_gfn = mem->guest_phys_addr >> PAGE_SHIFT;\n\tnpages = mem->memory_size >> PAGE_SHIFT;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tstruct kvm_memory_slot *memslot;\n\tstruct kvm_memory_slot old, new;\n\tstruct kvm_memslots *slots, *old_memslots;\n\n\tr = -EINVAL;\n\t/* General sanity checks */\n\tif (mem->memory_size & (PAGE_SIZE - 1))\n\t\tgoto out;\n\tif (mem->guest_phys_addr & (PAGE_SIZE - 1))\n\t\tgoto out;\n\t/* We can read the guest memory with __xxx_user() later on. */\n\tif (user_alloc &&\n\t    ((mem->userspace_addr & (PAGE_SIZE - 1)) ||\n\t     !access_ok(VERIFY_WRITE, mem->userspace_addr, mem->memory_size)))\n\t\tgoto out;\n\tif (mem->slot >= KVM_MEMORY_SLOTS + KVM_PRIVATE_MEM_SLOTS)\n\t\tgoto out;\n\tif (mem->guest_phys_addr + mem->memory_size < mem->guest_phys_addr)\n\t\tgoto out;\n\n\tmemslot = &kvm->memslots->memslots[mem->slot];\n\tbase_gfn = mem->guest_phys_addr >> PAGE_SHIFT;\n\tnpages = mem->memory_size >> PAGE_SHIFT;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "bool ExtractUnixLink30(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName)\n{\n  char Target[NM];\n  if (IsLink(Arc.FileHead.FileAttr))\n  {\n    size_t DataSize=(size_t)Arc.FileHead.PackSize;\n    if (DataSize>ASIZE(Target)-1)\n      return false;\n    if ((size_t)DataIO.UnpRead((byte *)Target,DataSize)!=DataSize)\n      return false;\n    Target[DataSize]=0;\n\n    DataIO.UnpHash.Init(Arc.FileHead.FileHash.Type,1);\n    DataIO.UnpHash.Update(Target,strlen(Target));\n    DataIO.UnpHash.Result(&Arc.FileHead.FileHash);\n\n    // Return true in case of bad checksum, so link will be processed further\n    // and extraction routine will report the checksum error.\n    if (!DataIO.UnpHash.Cmp(&Arc.FileHead.FileHash,Arc.FileHead.UseHashKey ? Arc.FileHead.HashKey:NULL))\n      return true;\n\n    wchar TargetW[NM];\n    if (!SafeCharToWide(Target,TargetW,ASIZE(TargetW)))\n      return false;\n    // Use Arc.FileHead.FileName instead of LinkName, since LinkName\n    // can include the destination path as a prefix, which can\n    // confuse IsRelativeSymlinkSafe algorithm.\n    if (!Cmd->AbsoluteLinks && (IsFullPath(TargetW) ||\n        !IsRelativeSymlinkSafe(Cmd,Arc.FileHead.FileName,LinkName,TargetW)))\n      return false;\n    return UnixSymlink(Cmd,Target,LinkName,&Arc.FileHead.mtime,&Arc.FileHead.atime);\n  }\n  return false;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static bool ExtractUnixLink30(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,\n                              const wchar *LinkName,bool &UpLink)\n{\n  char Target[NM];\n  if (IsLink(Arc.FileHead.FileAttr))\n  {\n    size_t DataSize=(size_t)Arc.FileHead.PackSize;\n    if (DataSize>ASIZE(Target)-1)\n      return false;\n    if ((size_t)DataIO.UnpRead((byte *)Target,DataSize)!=DataSize)\n      return false;\n    Target[DataSize]=0;\n\n    DataIO.UnpHash.Init(Arc.FileHead.FileHash.Type,1);\n    DataIO.UnpHash.Update(Target,strlen(Target));\n    DataIO.UnpHash.Result(&Arc.FileHead.FileHash);\n\n    // Return true in case of bad checksum, so link will be processed further\n    // and extraction routine will report the checksum error.\n    if (!DataIO.UnpHash.Cmp(&Arc.FileHead.FileHash,Arc.FileHead.UseHashKey ? Arc.FileHead.HashKey:NULL))\n      return true;\n\n    wchar TargetW[NM];\n    if (!SafeCharToWide(Target,TargetW,ASIZE(TargetW)))\n      return false;\n    // Use Arc.FileHead.FileName instead of LinkName, since LinkName\n    // can include the destination path as a prefix, which can\n    // confuse IsRelativeSymlinkSafe algorithm.\n    if (!Cmd->AbsoluteLinks && (IsFullPath(TargetW) ||\n        !IsRelativeSymlinkSafe(Cmd,Arc.FileHead.FileName,LinkName,TargetW)))\n      return false;\n    UpLink=strstr(Target,\"..\")!=NULL;\n    return UnixSymlink(Cmd,Target,LinkName,&Arc.FileHead.mtime,&Arc.FileHead.atime);\n  }\n  return false;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    int ret = 0;\n\n    DefragInit();\n\n    dc = DefragContextNew();\n    if (dc == NULL)\n        goto end;\n\n    /* Create a fragment that would extend past the max allowable size\n     * for an IPv4 packet. */\n    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n    if (p == NULL)\n        goto end;\n\n    /* We do not expect a packet returned. */\n    if (Defrag(NULL, NULL, p, NULL) != NULL)\n        goto end;\n    if (!ENGINE_ISSET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE))\n        goto end;\n\n    /* The fragment should have been ignored so no fragments should have",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    int ret = 0;\n\n    DefragInit();\n\n    dc = DefragContextNew();\n    if (dc == NULL)\n        goto end;\n\n    /* Create a fragment that would extend past the max allowable size\n     * for an IPv4 packet. */\n    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n    if (p == NULL)\n        goto end;\n\n    /* We do not expect a packet returned. */\n    if (Defrag(NULL, NULL, p, NULL) != NULL)\n        goto end;\n    if (!ENGINE_ISSET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE))\n        goto end;\n\n    /* The fragment should have been ignored so no fragments should have",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static char *get_pid_environ_val(pid_t pid,char *val){\n  char temp[500];\n  int i=0;\n  int foundit=0;\n  FILE *fp;\n\n  sprintf(temp,\"/proc/%d/environ\",pid);\n\n  fp=fopen(temp,\"r\");\n  if(fp==NULL)\n    return NULL;\n\n  \n  for(;;){\n    temp[i]=fgetc(fp);    \n\n    if(foundit==1 && (temp[i]==0 || temp[i]=='\\0' || temp[i]==EOF)){\n      char *ret;\n      temp[i]=0;\n      ret=malloc(strlen(temp)+10);\n      sprintf(ret,\"%s\",temp);\n      fclose(fp);\n      return ret;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static char *get_pid_environ_val(pid_t pid,char *val){\n  int temp_size = 500;\n  char *temp = malloc(temp_size);\n  \n  int i=0;\n  int foundit=0;\n  FILE *fp;\n\n  sprintf(temp,\"/proc/%d/environ\",pid);\n\n  fp=fopen(temp,\"r\");\n  if(fp==NULL)\n    return NULL;\n\n  \n  for(;;){\n    \n    if (i >= temp_size) {\n      temp_size *= 2;\n      temp = realloc(temp, temp_size);\n    }\n      \n    temp[i]=fgetc(fp);    \n\n    if(foundit==1 && (temp[i]==0 || temp[i]=='\\0' || temp[i]==EOF)){\n      char *ret;\n      temp[i]=0;\n      ret=malloc(strlen(temp)+10);\n      sprintf(ret,\"%s\",temp);\n      fclose(fp);\n      return ret;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "                }\n            }\n\n            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;\n            config->num_channels = WaveHeader.NumChannels;\n            config->sample_rate = WaveHeader.SampleRate;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n            int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;\n            char *buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "                }\n            }\n\n            config->bytes_per_sample = WaveHeader.BlockAlign / WaveHeader.NumChannels;\n            config->num_channels = WaveHeader.NumChannels;\n            config->sample_rate = WaveHeader.SampleRate;\n            break;\n        }\n        else {          // just copy unknown chunks to output file\n            int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;\n            char *buff;\n\n            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);\n\n            if (!DoReadFile (infile, buff, bytes_to_copy, &bcount) ||\n                bcount != bytes_to_copy ||\n                (!(config->qmode & QMODE_NO_STORE_WRAPPER) &&\n                !WavpackAddWrapper (wpc, buff, bytes_to_copy))) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "fstring_find_literal(const char **str, const char *end, int raw,\n                     PyObject **literal, int recurse_lvl,\n                     struct compiling *c, const node *n)\n{\n    /* Get any literal string. It ends when we hit an un-doubled left\n       brace (which isn't part of a unicode name escape such as\n       \"\\N{EULER CONSTANT}\"), or the end of the string. */\n\n    const char *literal_start = *str;\n    const char *literal_end;\n    int in_named_escape = 0;\n    int result = 0;\n\n    assert(*literal == NULL);\n    for (; *str < end; (*str)++) {\n        char ch = **str;\n        if (!in_named_escape && ch == '{' && (*str)-literal_start >= 2 &&\n            *(*str-2) == '\\\\' && *(*str-1) == 'N') {\n            in_named_escape = 1;\n        } else if (in_named_escape && ch == '}') {\n            in_named_escape = 0;\n        } else if (ch == '{' || ch == '}') {\n            /* Check for doubled braces, but only at the top level. If\n               we checked at every level, then f'{0:{3}}' would fail\n               with the two closing braces. */\n            if (recurse_lvl == 0) {\n                if (*str+1 < end && *(*str+1) == ch) {\n                    /* We're going to tell the caller that the literal ends\n                       here, but that they should continue scanning. But also\n                       skip over the second brace when we resume scanning. */\n                    literal_end = *str+1;\n                    *str += 2;\n                    result = 1;\n                    goto done;\n                }\n\n                /* Where a single '{' is the start of a new expression, a\n                   single '}' is not allowed. */\n                if (ch == '}') {\n                    ast_error(c, n, \"f-string: single '}' is not allowed\");\n                    return -1;\n                }\n            }\n            /* We're either at a '{', which means we're starting another\n               expression; or a '}', which means we're at the end of this\n               f-string (for a nested format_spec). */\n            break;\n        }\n    }\n    literal_end = *str;\n    assert(*str <= end);\n    assert(*str == end || **str == '{' || **str == '}');\ndone:\n    if (literal_start != literal_end) {\n        if (raw)\n            *literal = PyUnicode_DecodeUTF8Stateful(literal_start,\n                                                    literal_end-literal_start,\n                                                    NULL, NULL);\n        else\n            *literal = decode_unicode_with_escapes(c, n, literal_start,\n                                                   literal_end-literal_start);\n        if (!*literal)\n            return -1;\n    }\n    return result;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "fstring_find_literal(const char **str, const char *end, int raw,\n                     PyObject **literal, int recurse_lvl,\n                     struct compiling *c, const node *n)\n{\n    /* Get any literal string. It ends when we hit an un-doubled left\n       brace (which isn't part of a unicode name escape such as\n       \"\\N{EULER CONSTANT}\"), or the end of the string. */\n\n    const char *s = *str;\n    const char *literal_start = s;\n    int result = 0;\n\n    assert(*literal == NULL);\n    while (s < end) {\n        char ch = *s++;\n        if (!raw && ch == '\\\\' && s < end) {\n            ch = *s++;\n            if (ch == 'N') {\n                if (s < end && *s++ == '{') {\n                    while (s < end && *s++ != '}') {\n                    }\n                    continue;\n                }\n                break;\n            }\n            if (ch == '{' && warn_invalid_escape_sequence(c, n, ch) < 0) {\n                return -1;\n            }\n        }\n        if (ch == '{' || ch == '}') {\n            /* Check for doubled braces, but only at the top level. If\n               we checked at every level, then f'{0:{3}}' would fail\n               with the two closing braces. */\n            if (recurse_lvl == 0) {\n                if (s < end && *s == ch) {\n                    /* We're going to tell the caller that the literal ends\n                       here, but that they should continue scanning. But also\n                       skip over the second brace when we resume scanning. */\n                    *str = s + 1;\n                    result = 1;\n                    goto done;\n                }\n\n                /* Where a single '{' is the start of a new expression, a\n                   single '}' is not allowed. */\n                if (ch == '}') {\n                    *str = s - 1;\n                    ast_error(c, n, \"f-string: single '}' is not allowed\");\n                    return -1;\n                }\n            }\n            /* We're either at a '{', which means we're starting another\n               expression; or a '}', which means we're at the end of this\n               f-string (for a nested format_spec). */\n            s--;\n            break;\n        }\n    }\n    *str = s;\n    assert(s <= end);\n    assert(s == end || *s == '{' || *s == '}');\ndone:\n    if (literal_start != s) {\n        if (raw)\n            *literal = PyUnicode_DecodeUTF8Stateful(literal_start,\n                                                    s - literal_start,\n                                                    NULL, NULL);\n        else\n            *literal = decode_unicode_with_escapes(c, n, literal_start,\n                                                   s - literal_start);\n        if (!*literal)\n            return -1;\n    }\n    return result;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  incXCcalls(L);\n  if (getCcalls(L) <= CSTACKERR)  /* possible stack overflow? */\n    luaE_freeCI(L);\n  luaD_call(L, func, nResults);\n  decXCcalls(L);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  incXCcalls(L);\n  if (getCcalls(L) <= CSTACKERR) {  /* possible C stack overflow? */\n    luaE_exitCcall(L);  /* to compensate decrement in next call */\n    luaE_enterCcall(L);  /* check properly */\n  }\n  luaD_call(L, func, nResults);\n  decXCcalls(L);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    }\n\n    /* Locate the index named by the INDEXED BY clause, if any. */\n    if( sqlite3IndexedByLookup(pParse, pFrom) ){\n      return WRC_Abort;\n    }\n  }\n\n  /* Process NATURAL keywords, and ON and USING clauses of joins.\n  */\n  if( db->mallocFailed || sqliteProcessJoin(pParse, p) ){\n    return WRC_Abort;\n  }\n\n  /* For every \"*\" that occurs in the column list, insert the names of\n  ** all columns in all tables.  And for every TABLE.* insert the names\n  ** of all columns in TABLE.  The parser inserted a special expression\n  ** with the TK_ASTERISK operator for each \"*\" that it found in the column\n  ** list.  The following code just has to locate the TK_ASTERISK\n  ** expressions and expand each one to the list of all columns in\n  ** all tables.",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    }\n\n    /* Locate the index named by the INDEXED BY clause, if any. */\n    if( sqlite3IndexedByLookup(pParse, pFrom) ){\n      return WRC_Abort;\n    }\n  }\n\n  /* Process NATURAL keywords, and ON and USING clauses of joins.\n  */\n  if( pParse->nErr || db->mallocFailed || sqliteProcessJoin(pParse, p) ){\n    return WRC_Abort;\n  }\n\n  /* For every \"*\" that occurs in the column list, insert the names of\n  ** all columns in all tables.  And for every TABLE.* insert the names\n  ** of all columns in TABLE.  The parser inserted a special expression\n  ** with the TK_ASTERISK operator for each \"*\" that it found in the column\n  ** list.  The following code just has to locate the TK_ASTERISK\n  ** expressions and expand each one to the list of all columns in\n  ** all tables.",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int http_enable_trace(mk_request_t *request, void *data, const char *input_name, msgpack_packer *mp_pck)\n{\n    char *buf = NULL;\n    size_t buf_size;\n    msgpack_unpacked result;\n    int ret = -1;\n    int rc = -1;\n    int i;\n    int x;\n    size_t off = 0;\n    int root_type = MSGPACK_OBJECT_ARRAY;\n    struct flb_hs *hs = data;\n    flb_sds_t prefix = NULL;\n    flb_sds_t output_name = NULL;\n    msgpack_object *key;\n    msgpack_object *val;\n    struct mk_list *props = NULL;\n    struct flb_chunk_trace_limit limit = { 0 };\n    struct flb_input_instance *input_instance;\n    \n\n    if (request->method == MK_METHOD_GET) {\n        ret = enable_trace_input(hs, input_name, \"trace.\", \"stdout\", NULL);\n        if (ret == 0) {\n                msgpack_pack_map(mp_pck, 1);\n                msgpack_pack_str_with_body(mp_pck, \"status\", strlen(\"status\"));\n                msgpack_pack_str_with_body(mp_pck, \"ok\", strlen(\"ok\"));\n                return 200;\n        }\n        else {\n            flb_error(\"unable to enable tracing for %s\", input_name);\n            goto input_error;\n        }\n    }\n\n    msgpack_unpacked_init(&result);\n    rc = flb_pack_json(request->data.data, request->data.len, &buf, &buf_size,\n                       &root_type, NULL);\n    if (rc == -1) {\n        ret = 503;\n        flb_error(\"unable to parse json parameters\");\n        goto unpack_error;\n    }\n\n    rc = msgpack_unpack_next(&result, buf, buf_size, &off);\n    if (rc != MSGPACK_UNPACK_SUCCESS) {\n        ret = 503;\n        flb_error(\"unable to unpack msgpack parameters for %s\", input_name);\n        goto unpack_error;\n    }\n\n    if (result.data.type == MSGPACK_OBJECT_MAP) {\n        for (i = 0; i < result.data.via.map.size; i++) {\n            key = &result.data.via.map.ptr[i].key;\n            val = &result.data.via.map.ptr[i].val;\n            \n            if (key->type != MSGPACK_OBJECT_STR) {\n                ret = 503;\n                flb_error(\"non string key in parameters\");\n                goto parse_error;\n            }\n\n            if (strncmp(key->via.str.ptr, \"prefix\", key->via.str.size) == 0) {\n                if (val->type != MSGPACK_OBJECT_STR) {\n                    ret = 503;\n                    flb_error(\"prefix is not a string\");\n                    flb_error(\"unknown limit type\");\n                    goto parse_error;\n                }\n            }\n        }\n\n        if (output_name == NULL) {\n            output_name = flb_sds_create(\"stdout\");\n        }\n\n        ret = enable_trace_input(hs, input_name, prefix, output_name, props);\n        if (ret != 0) {\n            flb_error(\"error when enabling tracing\");\n            goto parse_error;\n        }\n\n        if (limit.type != 0) {\n            input_instance = find_input(hs, input_name);\n            if (limit.type == FLB_CHUNK_TRACE_LIMIT_TIME) {\n                flb_chunk_trace_context_set_limit(input_instance->chunk_trace_ctxt, limit.type, limit.seconds);\n            }\n            else if (limit.type == FLB_CHUNK_TRACE_LIMIT_COUNT) {\n                flb_chunk_trace_context_set_limit(input_instance->chunk_trace_ctxt, limit.type, limit.count);\n            }\n        }\n    }\n\n    msgpack_pack_map(mp_pck, 1);\n    msgpack_pack_str_with_body(mp_pck, \"status\", strlen(\"status\"));\n    msgpack_pack_str_with_body(mp_pck, \"ok\", strlen(\"ok\"));\n\n    ret = 200;\nparse_error:\n    if (prefix) flb_sds_destroy(prefix);\n    if (output_name) flb_sds_destroy(output_name);\n    if (props != NULL) {\n        flb_kv_release(props);\n        flb_free(props);\n    }\nunpack_error:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int http_enable_trace(mk_request_t *request, void *data,\n                             const char *input_name, ssize_t input_nlen,\n                             msgpack_packer *mp_pck)\n{\n    char *buf = NULL;\n    size_t buf_size;\n    msgpack_unpacked result;\n    int ret = -1;\n    int rc = -1;\n    int i;\n    int x;\n    size_t off = 0;\n    int root_type = MSGPACK_OBJECT_ARRAY;\n    struct flb_hs *hs = data;\n    flb_sds_t prefix = NULL;\n    flb_sds_t output_name = NULL;\n    msgpack_object *key;\n    msgpack_object *val;\n    struct mk_list *props = NULL;\n    struct flb_chunk_trace_limit limit = { 0 };\n    struct flb_input_instance *input_instance;\n\n\n    if (request->method == MK_METHOD_GET) {\n        ret = enable_trace_input(hs, input_name, input_nlen, \"trace.\", \"stdout\", NULL);\n        if (ret == 0) {\n                msgpack_pack_map(mp_pck, 1);\n                msgpack_pack_str_with_body(mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n                msgpack_pack_str_with_body(mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n                return 200;\n        }\n        else {\n            flb_error(\"unable to enable tracing for %.*s\", (int)input_nlen, input_name);\n            goto input_error;\n        }\n    }\n\n    msgpack_unpacked_init(&result);\n    rc = flb_pack_json(request->data.data, request->data.len, &buf, &buf_size,\n                       &root_type, NULL);\n    if (rc == -1) {\n        ret = 503;\n        flb_error(\"unable to parse json parameters\");\n        goto unpack_error;\n    }\n\n    rc = msgpack_unpack_next(&result, buf, buf_size, &off);\n    if (rc != MSGPACK_UNPACK_SUCCESS) {\n        ret = 503;\n        flb_error(\"unable to unpack msgpack parameters for %.*s\", (int)input_nlen, input_name);\n        goto unpack_error;\n    }\n\n    if (result.data.type == MSGPACK_OBJECT_MAP) {\n        for (i = 0; i < result.data.via.map.size; i++) {\n            key = &result.data.via.map.ptr[i].key;\n            val = &result.data.via.map.ptr[i].val;\n\n            if (key->type != MSGPACK_OBJECT_STR) {\n                ret = 503;\n                flb_error(\"non string key in parameters\");\n                goto parse_error;\n            }\n\n            if (strncmp(key->via.str.ptr, \"prefix\", key->via.str.size) == 0) {\n                if (val->type != MSGPACK_OBJECT_STR) {\n                    ret = 503;\n                    flb_error(\"prefix is not a string\");\n                    flb_error(\"unknown limit type\");\n                    goto parse_error;\n                }\n            }\n        }\n\n        if (output_name == NULL) {\n            output_name = flb_sds_create(\"stdout\");\n        }\n\n        ret = enable_trace_input(hs, input_name, input_nlen, prefix, output_name, props);\n        if (ret != 0) {\n            flb_error(\"error when enabling tracing\");\n            goto parse_error;\n        }\n\n        if (limit.type != 0) {\n            input_instance = find_input(hs, input_name, input_nlen);\n            if (limit.type == FLB_CHUNK_TRACE_LIMIT_TIME) {\n                flb_chunk_trace_context_set_limit(input_instance->chunk_trace_ctxt, limit.type, limit.seconds);\n            }\n            else if (limit.type == FLB_CHUNK_TRACE_LIMIT_COUNT) {\n                flb_chunk_trace_context_set_limit(input_instance->chunk_trace_ctxt, limit.type, limit.count);\n            }\n        }\n    }\n\n    msgpack_pack_map(mp_pck, 1);\n    msgpack_pack_str_with_body(mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n    msgpack_pack_str_with_body(mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n\n    ret = 200;\nparse_error:\n    if (prefix) flb_sds_destroy(prefix);\n    if (output_name) flb_sds_destroy(output_name);\n    if (props != NULL) {\n        flb_kv_release(props);\n        flb_free(props);\n    }\nunpack_error:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n\n    switch (op_context.output->type) {\n      case kTfLiteFloat32:\n        TFLiteOperation<kernel_type, float, OpType>(context, node, op_context);\n        break;\n      case kTfLiteUInt8:\n        TFLiteOperation<kernel_type, uint8_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt8:\n        TFLiteOperation<kernel_type, int8_t, OpType>(context, node, op_context);\n        break;\n      case kTfLiteInt32:\n        TFLiteOperation<kernel_type, int32_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt64:\n        TFLiteOperation<kernel_type, int64_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt16:\n        TFLiteOperation<kernel_type, int16_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      default:\n        context->ReportError(context,\n                             \"Type %d is currently not supported by Maximum.\",\n                             op_context.output->type);\n        return kTfLiteError;\n    }\n  return kTfLiteOk;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n\n  // If inputs have no element, shortcircuit.\n  if (NumElements(op_context.input1) == 0 ||\n      NumElements(op_context.input2) == 0) {\n    return kTfLiteOk;\n  }\n\n  switch (op_context.output->type) {\n    case kTfLiteFloat32:\n      TFLiteOperation<kernel_type, float, OpType>(context, node, op_context);\n      break;\n    case kTfLiteUInt8:\n      TFLiteOperation<kernel_type, uint8_t, OpType>(context, node, op_context);\n      break;\n    case kTfLiteInt8:\n      TFLiteOperation<kernel_type, int8_t, OpType>(context, node, op_context);\n      break;\n    case kTfLiteInt32:\n      TFLiteOperation<kernel_type, int32_t, OpType>(context, node, op_context);\n      break;\n    case kTfLiteInt64:\n      TFLiteOperation<kernel_type, int64_t, OpType>(context, node, op_context);\n      break;\n    case kTfLiteInt16:\n      TFLiteOperation<kernel_type, int16_t, OpType>(context, node, op_context);\n      break;\n    default:\n      context->ReportError(context,\n                           \"Type %d is currently not supported by Maximum.\",\n                           op_context.output->type);\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int b_unpack (lua_State *L) {\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);\n  size_t ld;\n  const char *data = luaL_checklstring(L, 2, &ld);\n  size_t pos = luaL_optinteger(L, 3, 1) - 1;\n  defaultoptions(&h);\n  lua_settop(L, 2);\n  while (*fmt) {\n    int opt = *fmt++;\n    size_t size = optsize(L, opt, &fmt);\n    pos += gettoalign(pos, &h, opt, size);\n    luaL_argcheck(L, pos+size <= ld, 2, \"data string too short\");\n    luaL_checkstack(L, 1, \"too many results\");\n    switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i':  case 'I': {  /* integer types */\n        int issigned = islower(opt);\n        lua_Number res = getinteger(data+pos, h.endian, issigned, size);\n        lua_pushnumber(L, res);\n        break;\n      }\n      case 'x': {\n        break;\n      }\n      case 'f': {\n        float f;\n        memcpy(&f, data+pos, size);\n        correctbytes((char *)&f, sizeof(f), h.endian);\n        lua_pushnumber(L, f);\n        break;\n      }\n      case 'd': {\n        double d;\n        memcpy(&d, data+pos, size);\n        correctbytes((char *)&d, sizeof(d), h.endian);\n        lua_pushnumber(L, d);\n        break;\n      }\n      case 'c': {\n        if (size == 0) {\n          if (!lua_isnumber(L, -1))\n            luaL_error(L, \"format `c0' needs a previous size\");\n          size = lua_tonumber(L, -1);\n          lua_pop(L, 1);\n          luaL_argcheck(L, pos+size <= ld, 2, \"data string too short\");\n        }\n        lua_pushlstring(L, data+pos, size);\n        break;\n      }\n      case 's': {\n        const char *e = (const char *)memchr(data+pos, '\\0', ld - pos);\n        if (e == NULL)\n          luaL_error(L, \"unfinished string in data\");\n        size = (e - (data+pos)) + 1;\n        lua_pushlstring(L, data+pos, size - 1);\n        break;\n      }\n      default: controloptions(L, opt, &fmt, &h);\n    }\n    pos += size;\n  }\n  lua_pushinteger(L, pos + 1);\n  return lua_gettop(L) - 2;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int b_unpack (lua_State *L) {\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);\n  size_t ld;\n  const char *data = luaL_checklstring(L, 2, &ld);\n  size_t pos = luaL_optinteger(L, 3, 1) - 1;\n  int n = 0;  /* number of results */\n  defaultoptions(&h);\n  while (*fmt) {\n    int opt = *fmt++;\n    size_t size = optsize(L, opt, &fmt);\n    pos += gettoalign(pos, &h, opt, size);\n    luaL_argcheck(L, pos+size <= ld, 2, \"data string too short\");\n    /* stack space for item + next position */\n    luaL_checkstack(L, 2, \"too many results\");\n    switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i':  case 'I': {  /* integer types */\n        int issigned = islower(opt);\n        lua_Number res = getinteger(data+pos, h.endian, issigned, size);\n        lua_pushnumber(L, res); n++;\n        break;\n      }\n      case 'x': {\n        break;\n      }\n      case 'f': {\n        float f;\n        memcpy(&f, data+pos, size);\n        correctbytes((char *)&f, sizeof(f), h.endian);\n        lua_pushnumber(L, f); n++;\n        break;\n      }\n      case 'd': {\n        double d;\n        memcpy(&d, data+pos, size);\n        correctbytes((char *)&d, sizeof(d), h.endian);\n        lua_pushnumber(L, d); n++;\n        break;\n      }\n      case 'c': {\n        if (size == 0) {\n          if (n == 0 || !lua_isnumber(L, -1))\n            luaL_error(L, \"format 'c0' needs a previous size\");\n          size = lua_tonumber(L, -1);\n          lua_pop(L, 1); n--;\n          luaL_argcheck(L, size <= ld && pos <= ld - size,\n                           2, \"data string too short\");\n        }\n        lua_pushlstring(L, data+pos, size); n++;\n        break;\n      }\n      case 's': {\n        const char *e = (const char *)memchr(data+pos, '\\0', ld - pos);\n        if (e == NULL)\n          luaL_error(L, \"unfinished string in data\");\n        size = (e - (data+pos)) + 1;\n        lua_pushlstring(L, data+pos, size - 1); n++;\n        break;\n      }\n      default: controloptions(L, opt, &fmt, &h);\n    }\n    pos += size;\n  }\n  lua_pushinteger(L, pos + 1);  /* next position */\n  return n + 1;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "sf_open_fd\t(int fd, int mode, SF_INFO *sfinfo, int close_desc)\n{\tSF_PRIVATE \t*psf ;\n\n\tif ((SF_CONTAINER (sfinfo->format)) == SF_FORMAT_SD2)\n\t{\tsf_errno = SFE_SD2_FD_DISALLOWED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\tcopy_filename (psf, \"\") ;\n\n\tpsf->file.mode = mode ;\n\tpsf_set_file (psf, fd) ;\n\tpsf->is_pipe = psf_is_pipe (psf) ;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "sf_open_fd\t(int fd, int mode, SF_INFO *sfinfo, int close_desc)\n{\tSF_PRIVATE \t*psf ;\n\n\tif ((SF_CONTAINER (sfinfo->format)) == SF_FORMAT_SD2)\n\t{\tsf_errno = SFE_SD2_FD_DISALLOWED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tif ((psf = psf_allocate ()) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;\n\tcopy_filename (psf, \"\") ;\n\n\tpsf->file.mode = mode ;\n\tpsf_set_file (psf, fd) ;\n\tpsf->is_pipe = psf_is_pipe (psf) ;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static entity_table_opt determine_entity_table(int all, int doctype)\n{\n\tentity_table_opt retval = {NULL};\n\n\tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n\t\n\tif (all) {\n\t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n\t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n\t} else {\n\t\tretval.table = (doctype == ENT_HTML_DOC_HTML401) ?\n\t\t\tstage3_table_be_noapos_00000 : stage3_table_be_apos_00000;\n\t}\n\treturn retval;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static entity_table_opt determine_entity_table(int all, int doctype)\n{\n\tentity_table_opt retval = {NULL};\n\n\tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n\n\tif (all) {\n\t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n\t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n\t} else {\n\t\tretval.table = (doctype == ENT_HTML_DOC_HTML401) ?\n\t\t\tstage3_table_be_noapos_00000 : stage3_table_be_apos_00000;\n\t}\n\treturn retval;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n\ttlvs_len = 0;\n\n\tnla_for_each_nested(attr, info->attrs[NFC_ATTR_LLC_SDP], rem) {\n\t\trc = nla_parse_nested_deprecated(sdp_attrs, NFC_SDP_ATTR_MAX,\n\t\t\t\t\t\t attr, nfc_sdp_genl_policy,\n\t\t\t\t\t\t info->extack);\n\n\t\tif (rc != 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (!sdp_attrs[NFC_SDP_ATTR_URI])\n\t\t\tcontinue;\n\n\t\turi_len = nla_len(sdp_attrs[NFC_SDP_ATTR_URI]);\n\t\tif (uri_len == 0)\n\t\t\tcontinue;\n\n\t\turi = nla_data(sdp_attrs[NFC_SDP_ATTR_URI]);\n\t\tif (uri == NULL || *uri == 0)\n\t\t\tcontinue;\n\n\t\ttid = local->sdreq_next_tid++;\n\n\t\tsdreq = nfc_llcp_build_sdreq_tlv(tid, uri, uri_len);\n\t\tif (sdreq == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\n\t\ttlvs_len += sdreq->tlv_len;\n\n\t\thlist_add_head(&sdreq->node, &sdreq_list);\n\t}\n\n\tif (hlist_empty(&sdreq_list)) {\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\trc = nfc_llcp_send_snl_sdreq(local, &sdreq_list, tlvs_len);\nexit:\n\tdevice_unlock(&dev->dev);\n\n\tnfc_put_device(dev);\n\n\treturn rc;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n\ttlvs_len = 0;\n\n\tnla_for_each_nested(attr, info->attrs[NFC_ATTR_LLC_SDP], rem) {\n\t\trc = nla_parse_nested_deprecated(sdp_attrs, NFC_SDP_ATTR_MAX,\n\t\t\t\t\t\t attr, nfc_sdp_genl_policy,\n\t\t\t\t\t\t info->extack);\n\n\t\tif (rc != 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto put_local;\n\t\t}\n\n\t\tif (!sdp_attrs[NFC_SDP_ATTR_URI])\n\t\t\tcontinue;\n\n\t\turi_len = nla_len(sdp_attrs[NFC_SDP_ATTR_URI]);\n\t\tif (uri_len == 0)\n\t\t\tcontinue;\n\n\t\turi = nla_data(sdp_attrs[NFC_SDP_ATTR_URI]);\n\t\tif (uri == NULL || *uri == 0)\n\t\t\tcontinue;\n\n\t\ttid = local->sdreq_next_tid++;\n\n\t\tsdreq = nfc_llcp_build_sdreq_tlv(tid, uri, uri_len);\n\t\tif (sdreq == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto put_local;\n\t\t}\n\n\t\ttlvs_len += sdreq->tlv_len;\n\n\t\thlist_add_head(&sdreq->node, &sdreq_list);\n\t}\n\n\tif (hlist_empty(&sdreq_list)) {\n\t\trc = -EINVAL;\n\t\tgoto put_local;\n\t}\n\n\trc = nfc_llcp_send_snl_sdreq(local, &sdreq_list, tlvs_len);\n\nput_local:\n\tnfc_llcp_local_put(local);\n\nexit:\n\tdevice_unlock(&dev->dev);\n\n\tnfc_put_device(dev);\n\n\treturn rc;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TfLiteStatus LogSoftmaxPrepare(TfLiteContext* context, TfLiteNode* node) {\n  LogSoftmaxOpData* data = reinterpret_cast<LogSoftmaxOpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    TF_LITE_ENSURE_EQ(context, output->params.scale, 16.0 / 256);\n    static const double kBeta = 1.0;\n    if (input->type == kTfLiteUInt8) {\n      TF_LITE_ENSURE_EQ(context, output->params.zero_point, 255);\n      data->params.table = data->f_table;\n      optimized_ops::PopulateSoftmaxLookupTable(&data->params,\n                                                input->params.scale, kBeta);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus LogSoftmaxPrepare(TfLiteContext* context, TfLiteNode* node) {\n  LogSoftmaxOpData* data = reinterpret_cast<LogSoftmaxOpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    TF_LITE_ENSURE_EQ(context, output->params.scale, 16.0 / 256);\n    static const double kBeta = 1.0;\n    if (input->type == kTfLiteUInt8) {\n      TF_LITE_ENSURE_EQ(context, output->params.zero_point, 255);\n      data->params.table = data->f_table;\n      optimized_ops::PopulateSoftmaxLookupTable(&data->params,\n                                                input->params.scale, kBeta);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tpartial_begin = offset & ((1 << blkbits) - 1);\n\tpartial_end = (offset + len) & ((1 << blkbits) - 1);\n\n\tlblk = start >> blkbits;\n\tmax_blocks = (end >> blkbits);\n\tif (max_blocks < lblk)\n\t\tmax_blocks = 0;\n\telse\n\t\tmax_blocks -= lblk;\n\n\tflags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT |\n\t\tEXT4_GET_BLOCKS_CONVERT_UNWRITTEN |\n\t\tEXT4_EX_NOCACHE;\n\tif (mode & FALLOC_FL_KEEP_SIZE)\n\t\tflags |= EXT4_GET_BLOCKS_KEEP_SIZE;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * Indirect files do not support unwritten extnets\n\t */\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_mutex;\n\t}\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE) &&\n\t     offset + len > i_size_read(inode)) {\n\t\tnew_size = offset + len;\n\t\tret = inode_newsize_ok(inode, new_size);\n\t\tif (ret)\n\t\t\tgoto out_mutex;\n\t\t/*\n\t\t * If we have a partial block after EOF we have to allocate\n\t\t * the entire block.\n\t\t */\n\t\tif (partial_end)\n\t\t\tmax_blocks += 1;\n\t}\n\n\tif (max_blocks > 0) {\n\n\t\t/* Now release the pages and zero block aligned part of pages*/\n\t\ttruncate_pagecache_range(inode, start, end - 1);\n\t\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\n\t\t/* Wait all existing dio workers, newcomers will block on i_mutex */\n\t\text4_inode_block_unlocked_dio(inode);\n\t\tinode_dio_wait(inode);\n\n\t\tret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\treturn -EINVAL;\n\tpartial_begin = offset & ((1 << blkbits) - 1);\n\tpartial_end = (offset + len) & ((1 << blkbits) - 1);\n\n\tlblk = start >> blkbits;\n\tmax_blocks = (end >> blkbits);\n\tif (max_blocks < lblk)\n\t\tmax_blocks = 0;\n\telse\n\t\tmax_blocks -= lblk;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t/*\n\t * Indirect files do not support unwritten extnets\n\t */\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_mutex;\n\t}\n\n\tif (!(mode & FALLOC_FL_KEEP_SIZE) &&\n\t     offset + len > i_size_read(inode)) {\n\t\tnew_size = offset + len;\n\t\tret = inode_newsize_ok(inode, new_size);\n\t\tif (ret)\n\t\t\tgoto out_mutex;\n\t}\n\n\tflags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT;\n\tif (mode & FALLOC_FL_KEEP_SIZE)\n\t\tflags |= EXT4_GET_BLOCKS_KEEP_SIZE;\n\n\t/* Preallocate the range including the unaligned edges */\n\tif (partial_begin || partial_end) {\n\t\tret = ext4_alloc_file_blocks(file,\n\t\t\t\tround_down(offset, 1 << blkbits) >> blkbits,\n\t\t\t\t(round_up((offset + len), 1 << blkbits) -\n\t\t\t\t round_down(offset, 1 << blkbits)) >> blkbits,\n\t\t\t\tnew_size, flags, mode);\n\t\tif (ret)\n\t\t\tgoto out_mutex;\n\n\t}\n\n\t/* Zero range excluding the unaligned edges */\n\tif (max_blocks > 0) {\n\t\tflags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |\n\t\t\t  EXT4_EX_NOCACHE);\n\n\t\t/* Now release the pages and zero block aligned part of pages*/\n\t\ttruncate_pagecache_range(inode, start, end - 1);\n\t\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\n\t\t/* Wait all existing dio workers, newcomers will block on i_mutex */\n\t\text4_inode_block_unlocked_dio(inode);\n\t\tinode_dio_wait(inode);\n\n\t\tret = ext4_alloc_file_blocks(file, lblk, max_blocks, new_size,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    }\n#endif\n    else\n    {\n\tfillchar = fillchar_status(&attr, wp);\n\n\tget_trans_bufname(wp->w_buffer);\n\tp = NameBuff;\n\tlen = (int)STRLEN(p);\n\n\tif (bt_help(wp->w_buffer)\n#ifdef FEAT_QUICKFIX\n\t\t|| wp->w_p_pvw\n#endif\n\t\t|| bufIsChanged(wp->w_buffer)\n\t\t|| wp->w_buffer->b_p_ro)\n\t    *(p + len++) = ' ';\n\tif (bt_help(wp->w_buffer))\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Help]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Preview]\"));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    }\n#endif\n    else\n    {\n\tfillchar = fillchar_status(&attr, wp);\n\n\tget_trans_bufname(wp->w_buffer);\n\tp = NameBuff;\n\tlen = (int)STRLEN(p);\n\n\tif ((bt_help(wp->w_buffer)\n#ifdef FEAT_QUICKFIX\n\t\t    || wp->w_p_pvw\n#endif\n\t\t    || bufIsChanged(wp->w_buffer)\n\t\t    || wp->w_buffer->b_p_ro)\n\t\t&& len < MAXPATHL - 1)\n\t    *(p + len++) = ' ';\n\tif (bt_help(wp->w_buffer))\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Help]\"));\n\t    len += (int)STRLEN(p + len);\n\t}\n#ifdef FEAT_QUICKFIX\n\tif (wp->w_p_pvw)\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Preview]\"));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void bn_rsh(bn_t c, const bn_t a, int bits) {\n\tint digits = 0;\n\n\tbn_copy(c, a);\n\n\tif (bits <= 0) {\n\t\treturn;\n\t}\n\n\tRLC_RIP(bits, digits, bits);\n\n\tif (digits > 0) {\n\t\tdv_rshd(c->dp, a->dp, a->used, digits);\n\t}\n\tc->used = a->used - digits;\n\tc->sign = a->sign;\n\n\tif (c->used > 0 && bits > 0) {\n\t\tif (digits == 0 && c != a) {\n\t\t\tbn_rshb_low(c->dp, a->dp + digits, a->used - digits, bits);\n\t\t} else {\n\t\t\tbn_rshb_low(c->dp, c->dp, c->used, bits);\n\t\t}\n\t}\n\tbn_trim(c);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void bn_rsh(bn_t c, const bn_t a, unsigned int bits) {\n\tint digits = 0;\n\n\tbn_copy(c, a);\n\n\tRLC_RIP(bits, digits, bits);\n\n\tif (digits > 0) {\n\t\tdv_rshd(c->dp, a->dp, a->used, digits);\n\t}\n\n\tif (a->used > digits) {\n\t\tc->used = a->used - digits;\n\t} else {\n\t\tc->used = 0;\n\t}\n\tc->sign = a->sign;\n\n\tif (c->used > 0 && bits > 0) {\n\t\tif (digits == 0 && c != a) {\n\t\t\tbn_rshb_low(c->dp, a->dp + digits, a->used - digits, bits);\n\t\t} else {\n\t\t\tbn_rshb_low(c->dp, c->dp, c->used, bits);\n\t\t}\n\t}\n\tbn_trim(c);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TfLiteStatus NotEqualEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  bool requires_broadcast = !HaveSameShapes(input1, input2);\n  switch (input1->type) {\n    case kTfLiteBool:\n      Comparison<bool, reference_ops::NotEqualFn>(input1, input2, output,\n                                                  requires_broadcast);\n      break;\n    case kTfLiteFloat32:\n      Comparison<float, reference_ops::NotEqualFn>(input1, input2, output,\n                                                   requires_broadcast);\n      break;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus NotEqualEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  bool requires_broadcast = !HaveSameShapes(input1, input2);\n  switch (input1->type) {\n    case kTfLiteBool:\n      Comparison<bool, reference_ops::NotEqualFn>(input1, input2, output,\n                                                  requires_broadcast);\n      break;\n    case kTfLiteFloat32:\n      Comparison<float, reference_ops::NotEqualFn>(input1, input2, output,\n                                                   requires_broadcast);\n      break;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\n\tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n\t\t\t      indx, data, size, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmalloc(size, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n\t\t\t      indx, buf, size, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\telse if (ret <= size)\n\t\tmemcpy(data, buf, ret);\n\tkfree(buf);\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n\t      const struct isakmp_gen *ext, u_int item_len,\n\t      const u_char *ep, uint32_t phase, uint32_t doi0 _U_,\n\t      uint32_t proto0 _U_, int depth)\n{\n\tconst struct ikev1_pl_n *p;\n\tstruct ikev1_pl_n n;\n\tconst u_char *cp;\n\tconst u_char *ep2;\n\tuint32_t doi;\n\tuint32_t proto;\n\tstatic const char *notify_error_str[] = {\n\t\tNULL,\t\t\t\t\"INVALID-PAYLOAD-TYPE\",\n\t\t\"DOI-NOT-SUPPORTED\",\t\t\"SITUATION-NOT-SUPPORTED\",\n\tif (n.spi_size) {\n\t\tND_PRINT((ndo,\" spi=\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\tgoto trunc;\n\t}\n\n\tcp = (const u_char *)(p + 1) + n.spi_size;\n\tep2 = (const u_char *)p + item_len;\n\n\tif (cp < ep) {\n\t\tND_PRINT((ndo,\" orig=(\"));\n\t\tswitch (ntohs(n.type)) {\n\t\tcase IPSECDOI_NTYPE_RESPONDER_LIFETIME:\n\t\t    {\n\t\t\tconst struct attrmap *map = oakley_t_map;\n\t\t\tsize_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);\n\t\t\twhile (cp < ep && cp < ep2) {\n\t\t\t\tcp = ikev1_attrmap_print(ndo, cp,\n\t\t\t\t\t(ep < ep2) ? ep : ep2, map, nmap);\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_NTYPE_REPLAY_STATUS:\n\t\t\tND_PRINT((ndo,\"replay detection %sabled\",\n\t\t\t\t  EXTRACT_32BITS(cp) ? \"en\" : \"dis\"));\n\t\t\tbreak;\n\t\tcase ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN:\n\t\t\tif (ikev1_sub_print(ndo, ISAKMP_NPTYPE_SA,\n\t\t\t\t\t    (const struct isakmp_gen *)cp, ep, phase, doi, proto,\n\t\t\t\t\t    depth) == NULL)\n\t\t\t\treturn NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* NULL is dummy */\n\t\t\tisakmp_print(ndo, cp,\n\t\t\t\t     item_len - sizeof(*p) - n.spi_size,\n\t\t\t\t     NULL);\n\t\t}\n\t\tND_PRINT((ndo,\")\"));\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_N)));\n\treturn NULL;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n\t      const struct isakmp_gen *ext, u_int item_len,\n\t      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,\n\t      uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_n *p;\n\tstruct ikev1_pl_n n;\n\tconst u_char *cp;\n\tconst u_char *ep2;\n\tuint32_t doi;\n\tuint32_t proto;\n\tstatic const char *notify_error_str[] = {\n\t\tNULL,\t\t\t\t\"INVALID-PAYLOAD-TYPE\",\n\t\t\"DOI-NOT-SUPPORTED\",\t\t\"SITUATION-NOT-SUPPORTED\",\n\t\tND_PRINT((ndo,\" type=%s\", numstr(ntohs(n.type))));\n\tif (n.spi_size) {\n\t\tND_PRINT((ndo,\" spi=\"));\n\t\tif (!rawprint(ndo, (const uint8_t *)(p + 1), n.spi_size))\n\t\t\tgoto trunc;\n\t}\n\n\tcp = (const u_char *)(p + 1) + n.spi_size;\n\tep2 = (const u_char *)p + item_len;\n\n\tif (cp < ep) {\n\t\tswitch (ntohs(n.type)) {\n\t\tcase IPSECDOI_NTYPE_RESPONDER_LIFETIME:\n\t\t    {\n\t\t\tconst struct attrmap *map = oakley_t_map;\n\t\t\tsize_t nmap = sizeof(oakley_t_map)/sizeof(oakley_t_map[0]);\n\t\t\tND_PRINT((ndo,\" attrs=(\"));\n\t\t\twhile (cp < ep && cp < ep2) {\n\t\t\t\tcp = ikev1_attrmap_print(ndo, cp,\n\t\t\t\t\t(ep < ep2) ? ep : ep2, map, nmap);\n\t\t\t}\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_NTYPE_REPLAY_STATUS:\n\t\t\tND_PRINT((ndo,\" status=(\"));\n\t\t\tND_PRINT((ndo,\"replay detection %sabled\",\n\t\t\t\t  EXTRACT_32BITS(cp) ? \"en\" : \"dis\"));\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/*\n\t\t\t * XXX - fill in more types here; see, for example,\n\t\t\t * draft-ietf-ipsec-notifymsg-04.\n\t\t\t */\n\t\t\tif (ndo->ndo_vflag > 3) {\n\t\t\t\tND_PRINT((ndo,\" data=(\"));\n\t\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n\t\t\t\t\tgoto trunc;\n\t\t\t\tND_PRINT((ndo,\")\"));\n\t\t\t} else {\n\t\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_N)));\n\treturn NULL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"PMT on multiple sections not supported\\n\"));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\tpmt->program->pcr_pid = ((data[0] & 0x1f) << 8) | data[1];\n\n\tinfo_length = ((data[2]&0xf)<<8) | data[3];\n\tif (info_length != 0) {\n\t\t/* ...Read Descriptors ... */\n\t\tu8 tag, len;\n\t\tu32 first_loop_len = 0;\n\t\ttag = data[4];\n\t\tlen = data[5];\n\t\twhile (info_length > first_loop_len) {\n\t\t\tif (tag == GF_M2TS_MPEG4_IOD_DESCRIPTOR) {\n\t\t\t\tu32 size;\n\t\t\t\tGF_BitStream *iod_bs;\n\t\t\t\tiod_bs = gf_bs_new((char *)data+8, len-2, GF_BITSTREAM_READ);\n\t\t\t\tif (pmt->program->pmt_iod) gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);\n\t\t\t\te = gf_odf_parse_descriptor(iod_bs , (GF_Descriptor **) &pmt->program->pmt_iod, &size);\n\t\t\t\tgf_bs_del(iod_bs );\n\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t/*remember program number for service/program selection*/\n\t\t\t\t\tif (pmt->program->pmt_iod) pmt->program->pmt_iod->ServiceID = pmt->program->number;\n\t\t\t\t\t/*if empty IOD (freebox case), discard it and use dynamic declaration of object*/\n\t\t\t\t\tif (!gf_list_count(pmt->program->pmt_iod->ESDescriptors)) {\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);\n\t\t\t\t\t\tpmt->program->pmt_iod = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (tag == GF_M2TS_METADATA_POINTER_DESCRIPTOR) {\n\t\t\t\tGF_BitStream *metadatapd_bs;\n\t\t\t\tGF_M2TS_MetadataPointerDescriptor *metapd;\n\t\t\t\tmetadatapd_bs = gf_bs_new((char *)data+6, len, GF_BITSTREAM_READ);\n\t\t\t\tmetapd = gf_m2ts_read_metadata_pointer_descriptor(metadatapd_bs, len);\n\t\t\t\tgf_bs_del(metadatapd_bs);\n\t\t\t\tif (metapd->application_format_identifier == GF_M2TS_META_ID3 &&\n\t\t\t\t        metapd->format_identifier == GF_M2TS_META_ID3 &&\n\t\t\t\t        metapd->carriage_flag == METADATA_CARRIAGE_SAME_TS) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"PMT on multiple sections not supported\\n\"));\n\t}\n\n\tsection = (GF_M2TS_Section *)gf_list_get(sections, 0);\n\tdata = section->data;\n\tdata_size = section->data_size;\n\n\tpmt->program->pcr_pid = ((data[0] & 0x1f) << 8) | data[1];\n\n\tinfo_length = ((data[2]&0xf)<<8) | data[3];\n\tif (info_length + 4 > data_size) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Broken PMT first loop, %d bytes avail but first loop size %d\\n\", data_size, info_length));\n\t\treturn;\n\t} else if (info_length != 0) {\n\t\t/* ...Read Descriptors ... */\n\t\tu8 tag, len;\n\t\tu32 first_loop_len = 0;\n\t\ttag = data[4];\n\t\tlen = data[5];\n\t\twhile (info_length > first_loop_len) {\n\t\t\tif (tag == GF_M2TS_MPEG4_IOD_DESCRIPTOR) {\n\t\t\t\tif ((len>2) && (len - 2 <= info_length)) {\n\t\t\t\t\tu32 size;\n\t\t\t\t\tGF_BitStream *iod_bs;\n\t\t\t\t\tiod_bs = gf_bs_new((char *)data+8, len-2, GF_BITSTREAM_READ);\n\t\t\t\t\tif (pmt->program->pmt_iod) gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);\n\t\t\t\t\te = gf_odf_parse_descriptor(iod_bs , (GF_Descriptor **) &pmt->program->pmt_iod, &size);\n\t\t\t\t\tgf_bs_del(iod_bs );\n\t\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t\t/*remember program number for service/program selection*/\n\t\t\t\t\t\tif (pmt->program->pmt_iod) pmt->program->pmt_iod->ServiceID = pmt->program->number;\n\t\t\t\t\t\t/*if empty IOD (freebox case), discard it and use dynamic declaration of object*/\n\t\t\t\t\t\tif (!gf_list_count(pmt->program->pmt_iod->ESDescriptors)) {\n\t\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);\n\t\t\t\t\t\t\tpmt->program->pmt_iod = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Broken IOD! len %d less than 2 bytes to declare IOD\\n\", len));\n\t\t\t\t}\n\t\t\t} else if (tag == GF_M2TS_METADATA_POINTER_DESCRIPTOR) {\n\t\t\t\tGF_BitStream *metadatapd_bs;\n\t\t\t\tGF_M2TS_MetadataPointerDescriptor *metapd;\n\t\t\t\tmetadatapd_bs = gf_bs_new((char *)data+6, len, GF_BITSTREAM_READ);\n\t\t\t\tmetapd = gf_m2ts_read_metadata_pointer_descriptor(metadatapd_bs, len);\n\t\t\t\tgf_bs_del(metadatapd_bs);\n\t\t\t\tif (metapd->application_format_identifier == GF_M2TS_META_ID3 &&\n\t\t\t\t        metapd->format_identifier == GF_M2TS_META_ID3 &&\n\t\t\t\t        metapd->carriage_flag == METADATA_CARRIAGE_SAME_TS) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "                                        \") must be non-negative\"));\n    xla::XlaOp idx, updates, output;\n    xla::XlaOp input = ctx->Input(0);\n    auto input_xla_type = ctx->input_xla_type(0);\n    xla::PrimitiveType dtype = ctx->InputXlaType(\"weights\");\n    auto zero = xla::Zero(ctx->builder(), dtype);\n    auto one = xla::One(ctx->builder(), dtype);\n    StatusOr<xla::Shape> input_shape_or = ctx->builder()->GetShape(input);\n    OP_REQUIRES_OK(ctx, input_shape_or.status());\n    auto input_shape = input_shape_or.value();\n    auto size = input_shape.dimensions(0);\n\n    if (!size) {\n      output = xla::Broadcast(zero, {output_size});\n      ctx->SetOutput(0, output);\n      return;\n    }\n    auto rank = input_shape.rank();\n\n    OP_REQUIRES(ctx, rank <= 2,\n                errors::InvalidArgument(\n                    \"Shape must be at most rank 2 but is rank \", rank));\n\n    xla::XlaOp weights = ctx->Input(2);\n    StatusOr<xla::Shape> weights_shape_or = ctx->builder()->GetShape(weights);\n    OP_REQUIRES_OK(ctx, weights_shape_or.status());\n\n    auto weights_shape = weights_shape_or.value();\n    OP_REQUIRES(ctx,\n                xla::ShapeUtil::CompatibleIgnoringElementType(weights_shape,\n                                                              input_shape) ||\n                    (weights_shape.dimensions_size() > 0 &&\n                     weights_shape.dimensions(0) == 0),\n                errors::InvalidArgument(\n                    \"`weights` must be the same shape as `arr` or a length-0 \"\n                    \"`Tensor`, in which case it acts as all weights equal to \"\n                    \"1. Received \",\n                    weights_shape.DebugString()));\n\n    auto weights_size = weights_shape.dimensions(0);\n    bool has_weights = false;\n    if (weights_size) {\n      has_weights = true;\n    }\n    xla::Shape output_shape = xla::ShapeUtil::MakeShape(dtype, {output_size});\n    xla::ScatterDimensionNumbers scatter_dnums;\n    scatter_dnums.set_index_vector_dim(1);\n    scatter_dnums.add_inserted_window_dims(0);\n    scatter_dnums.add_scatter_dims_to_operand_dims(0);\n\n    if (rank == 2) {\n      output_shape = xla::ShapeUtil::MakeShape(dtype, {size, output_size});\n      scatter_dnums.add_inserted_window_dims(1);\n      scatter_dnums.add_scatter_dims_to_operand_dims(1);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "                errors::InvalidArgument(\"size (\", output_size,\n                                        \") must be non-negative\"));\n    xla::XlaOp idx, updates, output;\n    xla::XlaOp input = ctx->Input(0);\n    auto input_xla_type = ctx->input_xla_type(0);\n    xla::PrimitiveType dtype = ctx->InputXlaType(\"weights\");\n    auto zero = xla::Zero(ctx->builder(), dtype);\n    auto one = xla::One(ctx->builder(), dtype);\n    StatusOr<xla::Shape> input_shape_or = ctx->builder()->GetShape(input);\n    OP_REQUIRES_OK(ctx, input_shape_or.status());\n    auto input_shape = input_shape_or.value();\n\n    auto rank = input_shape.rank();\n\n    OP_REQUIRES(ctx, rank <= 2,\n                errors::InvalidArgument(\n                    \"Shape must be at most rank 2 but is rank \", rank));\n    xla::XlaOp weights = ctx->Input(2);\n    StatusOr<xla::Shape> weights_shape_or = ctx->builder()->GetShape(weights);\n\n    OP_REQUIRES_OK(ctx, weights_shape_or.status());\n\n    auto weights_shape = weights_shape_or.value();\n    OP_REQUIRES(ctx,\n                xla::ShapeUtil::CompatibleIgnoringElementType(weights_shape,\n                                                              input_shape) ||\n                    (weights_shape.dimensions_size() > 0 &&\n                     weights_shape.dimensions(0) == 0),\n                errors::InvalidArgument(\n                    \"`weights` must be the same shape as `arr` or a length-0 \"\n                    \"`Tensor`, in which case it acts as all weights equal to \"\n                    \"1. Received \",\n                    weights_shape.DebugString()));\n\n    auto size = input_shape.dimensions(0);\n\n    if (!size) {\n      output = xla::Broadcast(zero, {output_size});\n      ctx->SetOutput(0, output);\n      return;\n    }\n\n    auto weights_size = weights_shape.dimensions(0);\n    bool has_weights = false;\n    if (weights_size) {\n      has_weights = true;\n    }\n\n    xla::Shape output_shape = xla::ShapeUtil::MakeShape(dtype, {output_size});\n    xla::ScatterDimensionNumbers scatter_dnums;\n    scatter_dnums.set_index_vector_dim(1);\n    scatter_dnums.add_inserted_window_dims(0);\n    scatter_dnums.add_scatter_dims_to_operand_dims(0);\n\n    if (rank == 2) {\n      output_shape = xla::ShapeUtil::MakeShape(dtype, {size, output_size});\n      scatter_dnums.add_inserted_window_dims(1);\n      scatter_dnums.add_scatter_dims_to_operand_dims(1);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n\tconst char *name_1, *name_2;\n\tgchar *key_1, *key_2;\n\tgboolean sort_last_1, sort_last_2;\n\tint compare;\n\n\tname_1 = * (const char **) a;\n\tname_2 = * (const char **) b;\n\n\t#define SORT_LAST_CHAR1 '.'\n\t#define SORT_LAST_CHAR2 '#'\n\n\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\n\t#undef SORT_LAST_CHAR1\n\t#undef SORT_LAST_CHAR2\n\n\tif (sort_last_1 && !sort_last_2)\n\t{\n\t\tcompare = +1;\n\t}\n\telse if (!sort_last_1 && sort_last_2)\n\t{\n\t\tcompare = -1;\n\t} \n\telse\n\t{\n\t\tkey_1 = g_utf8_collate_key_for_filename (name_1, -1);\n\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\n\t\tcompare = strcmp (key_1, key_2);\n\n\t\tg_free (key_1);\n\t\tg_free (key_2);\n\t}\n\n\treturn compare;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n  gchar *temp1, *temp2;\n  gint ret;\n\n  temp1 = g_utf8_collate_key_for_filename (* (const char **) a, -1);\n  temp2 = g_utf8_collate_key_for_filename (* (const char **) b, -1);\n\n  ret = strcmp (temp1, temp2);\n\n  g_free (temp1);\n  g_free (temp2);\n\n  return ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n\t\t\tif (uref->field_index >= report->maxfield)\n\t\t\t\tgoto inval;\n\n\t\t\tfield = report->field[uref->field_index];\n\n\t\t\tif (cmd == HIDIOCGCOLLECTIONINDEX) {\n\t\t\t\tif (uref->usage_index >= field->maxusage)\n\t\t\t\t\tgoto inval;\n\t\t\t} else if (uref->usage_index >= field->report_count)\n\t\t\t\tgoto inval;\n\n\t\t\telse if ((cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) &&\n\t\t\t\t (uref_multi->num_values > HID_MAX_MULTI_USAGES ||\n\t\t\t\t  uref->usage_index + uref_multi->num_values > field->report_count))\n\t\t\t\tgoto inval;\n\t\t}\n\n\t\tswitch (cmd) {\n\t\tcase HIDIOCGUSAGE:\n\t\t\turef->value = field->value[uref->usage_index];\n\t\t\tif (copy_to_user(user_arg, uref, sizeof(*uref)))\n\t\t\t\tgoto fault;\n\t\t\tgoto goodreturn;\n\n\t\tcase HIDIOCSUSAGE:\n\t\t\tfield->value[uref->usage_index] = uref->value;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\tif (uref->field_index >= report->maxfield)\n\t\t\t\tgoto inval;\n\n\t\t\tfield = report->field[uref->field_index];\n\n\t\t\tif (cmd == HIDIOCGCOLLECTIONINDEX) {\n\t\t\t\tif (uref->usage_index >= field->maxusage)\n\t\t\t\t\tgoto inval;\n\t\t\t} else if (uref->usage_index >= field->report_count)\n\t\t\t\tgoto inval;\n\t\t}\n\n\t\tif ((cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) &&\n\t\t    (uref_multi->num_values > HID_MAX_MULTI_USAGES ||\n\t\t     uref->usage_index + uref_multi->num_values > field->report_count))\n\t\t\tgoto inval;\n\n\t\tswitch (cmd) {\n\t\tcase HIDIOCGUSAGE:\n\t\t\turef->value = field->value[uref->usage_index];\n\t\t\tif (copy_to_user(user_arg, uref, sizeof(*uref)))\n\t\t\t\tgoto fault;\n\t\t\tgoto goodreturn;\n\n\t\tcase HIDIOCSUSAGE:\n\t\t\tfield->value[uref->usage_index] = uref->value;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "struct import_t* MACH0_(get_imports)(struct MACH0_(obj_t)* bin) {\n\tstruct import_t *imports;\n\tint i, j, idx, stridx;\n\tconst char *symstr;\n\n\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)\n\t\treturn NULL;\n\tif (bin->dysymtab.nundefsym < 1 || bin->dysymtab.nundefsym > 0xfffff) {\n\t\treturn NULL;\n\t}\n\tif (!(imports = malloc ((bin->dysymtab.nundefsym + 1) * sizeof (struct import_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = j = 0; i < bin->dysymtab.nundefsym; i++) {\n\t\tidx = bin->dysymtab.iundefsym + i;\n\t\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\t\tbprintf (\"WARNING: Imports index out of bounds. Ignoring relocs\\n\");",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "struct import_t* MACH0_(get_imports)(struct MACH0_(obj_t)* bin) {\n\tstruct import_t *imports;\n\tint i, j, idx, stridx;\n\tconst char *symstr;\n\n\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms) {\n\t\treturn NULL;\n\t}\n\tif (bin->dysymtab.nundefsym < 1 || bin->dysymtab.nundefsym > 0xfffff) {\n\t\treturn NULL;\n\t}\n\tif (!(imports = malloc ((bin->dysymtab.nundefsym + 1) * sizeof (struct import_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = j = 0; i < bin->dysymtab.nundefsym; i++) {\n\t\tidx = bin->dysymtab.iundefsym + i;\n\t\tif (idx < 0 || idx >= bin->nsymtab) {\n\t\t\tbprintf (\"WARNING: Imports index out of bounds. Ignoring relocs\\n\");",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "snmp_ber_encode_null(unsigned char *out, uint32_t *out_len, uint8_t type)\n{\n  (*out_len)++;\n  *out-- = 0x00;\n  out = snmp_ber_encode_type(out, out_len, type);\n\n  return out;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "snmp_ber_encode_null(snmp_packet_t *snmp_packet, uint8_t type)\n{\n\n  if(snmp_packet->used == snmp_packet->max) {\n    return 0;\n  }\n\n  *snmp_packet->out-- = 0x00;\n  snmp_packet->used++;\n\n  return snmp_ber_encode_type(snmp_packet, type);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "NOEXPORT char *parse_global_option(CMD cmd, char *opt, char *arg) {\n    void *tmp;\n\n    if(cmd==CMD_PRINT_DEFAULTS || cmd==CMD_PRINT_HELP) {\n        s_log(LOG_NOTICE, \" \");\n        s_log(LOG_NOTICE, \"Global options:\");\n    }\n\n    /* chroot */\n#ifdef HAVE_CHROOT\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.chroot_dir=NULL;\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        tmp=global_options.chroot_dir;\n        global_options.chroot_dir=NULL;\n        str_free(tmp);\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"chroot\"))\n            break;\n        new_global_options.chroot_dir=str_dup(arg);\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = directory to chroot stunnel process\", \"chroot\");\n        break;\n    }\n#endif /* HAVE_CHROOT */\n\n    /* compression */\n#ifndef OPENSSL_NO_COMP\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.compression=COMP_NONE;\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"compression\"))\n            break;\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n        /* only allow compression with OpenSSL 0.9.8 or later\n         * with OpenSSL #1468 zlib memory leak fixed */\n        if(OpenSSL_version_num()<0x00908051L) /* 0.9.8e-beta1 */\n            return \"Compression unsupported due to a memory leak\";\n#endif /* OpenSSL version < 1.1.0 */\n        if(!strcasecmp(arg, \"deflate\"))\n            new_global_options.compression=COMP_DEFLATE;\n        else if(!strcasecmp(arg, \"zlib\"))\n            new_global_options.compression=COMP_ZLIB;\n        else\n            return \"Specified compression type is not available\";\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = compression type\",\n            \"compression\");\n        break;\n    }\n#endif /* !defined(OPENSSL_NO_COMP) */\n\n    /* EGD */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n#ifdef EGD_SOCKET\n        new_global_options.egd_sock=EGD_SOCKET;\n#else\n        new_global_options.egd_sock=NULL;\n#endif\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        tmp=global_options.egd_sock;\n        global_options.egd_sock=NULL;\n        str_free(tmp);\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"EGD\"))\n            break;\n        new_global_options.egd_sock=str_dup(arg);\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n#ifdef EGD_SOCKET\n        s_log(LOG_NOTICE, \"%-22s = %s\", \"EGD\", EGD_SOCKET);\n#endif\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = path to Entropy Gathering Daemon socket\", \"EGD\");\n            \"engineDefault\");\n        break;\n    }\n\n#endif /* !defined(OPENSSL_NO_ENGINE) */\n\n    /* fips */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n#ifdef USE_FIPS\n        new_global_options.option.fips=0;\n#endif /* USE_FIPS */\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"fips\"))\n            break;\n#ifdef USE_FIPS\n        if(!strcasecmp(arg, \"yes\"))\n            new_global_options.option.fips=1;\n        else if(!strcasecmp(arg, \"no\"))\n            new_global_options.option.fips=0;\n        else\n            return \"The argument needs to be either 'yes' or 'no'\";\n#else\n        if(strcasecmp(arg, \"no\"))\n            return \"FIPS support is not available\";\n#endif /* USE_FIPS */\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n#ifdef USE_FIPS\n        s_log(LOG_NOTICE, \"%-22s = yes|no FIPS 140-2 mode\",\n            \"fips\");\n#endif /* USE_FIPS */\n        break;\n    }\n\n    /* foreground */\n#ifndef USE_WIN32\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.option.foreground=0;\n        new_global_options.option.log_stderr=0;\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"foreground\"))\n            break;\n        if(!strcasecmp(arg, \"yes\")) {\n            new_global_options.option.foreground=1;\n            new_global_options.option.log_stderr=1;\n        } else if(!strcasecmp(arg, \"quiet\")) {\n            new_global_options.option.foreground=1;\n            new_global_options.option.log_stderr=0;\n        } else if(!strcasecmp(arg, \"no\")) {\n            new_global_options.option.foreground=0;\n            new_global_options.option.log_stderr=0;\n        } else\n            return \"The argument needs to be either 'yes', 'quiet' or 'no'\";\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = yes|quiet|no foreground mode (don't fork, log to stderr)\",\n            \"foreground\");\n        break;\n    }\n#endif\n\n#ifdef ICON_IMAGE\n\n    /* iconActive */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.icon[ICON_ACTIVE]=load_icon_default(ICON_ACTIVE);\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        /* FIXME: investigate if we can free it */\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"iconActive\"))\n            break;\n        if(!(new_global_options.icon[ICON_ACTIVE]=load_icon_file(arg)))\n            return \"Failed to load the specified icon\";\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = icon when connections are established\", \"iconActive\");\n        break;\n    }\n\n    /* iconError */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.icon[ICON_ERROR]=load_icon_default(ICON_ERROR);\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        /* FIXME: investigate if we can free it */\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"iconError\"))\n            break;\n        if(!(new_global_options.icon[ICON_ERROR]=load_icon_file(arg)))\n            return \"Failed to load the specified icon\";\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = icon for invalid configuration file\", \"iconError\");\n        break;\n    }\n\n    /* iconIdle */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.icon[ICON_IDLE]=load_icon_default(ICON_IDLE);\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        /* FIXME: investigate if we can free it */\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"iconIdle\"))\n            break;\n        if(!(new_global_options.icon[ICON_IDLE]=load_icon_file(arg)))\n            return \"Failed to load the specified icon\";\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = icon when no connections were established\", \"iconIdle\");\n        break;\n    }\n\n#endif /* ICON_IMAGE */\n\n    /* log */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.log_file_mode=FILE_MODE_APPEND;\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"log\"))\n            break;\n        if(!strcasecmp(arg, \"append\"))\n            new_global_options.log_file_mode=FILE_MODE_APPEND;\n        else if(!strcasecmp(arg, \"overwrite\"))\n            new_global_options.log_file_mode=FILE_MODE_OVERWRITE;\n        else\n            return \"The argument needs to be either 'append' or 'overwrite'\";\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = append|overwrite log file\",\n            \"log\");\n        break;\n    }\n\n    /* output */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.output_file=NULL;\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        tmp=global_options.output_file;\n        global_options.output_file=NULL;\n        str_free(tmp);\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"output\"))\n            break;\n        new_global_options.output_file=str_dup(arg);\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n#ifndef USE_WIN32\n        if(!new_global_options.option.foreground /* daemonize() used */ &&\n                new_global_options.output_file /* log file enabled */ &&\n                new_global_options.output_file[0]!='/' /* relative path */)\n            return \"Log file must include full path name\";\n#endif\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = file to append log messages\", \"output\");\n        break;\n    }\n\n    /* pid */\n#ifndef USE_WIN32\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.pidfile=NULL; /* do not create a pid file */\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        tmp=global_options.pidfile;\n        global_options.pidfile=NULL;\n        str_free(tmp);\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"pid\"))\n            break;\n        if(arg[0]) /* is argument not empty? */\n            new_global_options.pidfile=str_dup(arg);\n        else\n            new_global_options.pidfile=NULL; /* empty -> do not create a pid file */\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        if(!new_global_options.option.foreground /* daemonize() used */ &&\n                new_global_options.pidfile /* pid file enabled */ &&\n                new_global_options.pidfile[0]!='/' /* relative path */)\n            return \"Pid file must include full path name\";\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = pid file\", \"pid\");\n        break;\n    }\n#endif\n\n    /* RNDbytes */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.random_bytes=RANDOM_BYTES;\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"RNDbytes\"))\n            break;\n        {\n            char *tmp_str;\n            new_global_options.random_bytes=(long)strtol(arg, &tmp_str, 10);\n            if(tmp_str==arg || *tmp_str) /* not a number */\n                return \"Illegal number of bytes to read from random seed files\";\n        }\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        s_log(LOG_NOTICE, \"%-22s = %d\", \"RNDbytes\", RANDOM_BYTES);\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = bytes to read from random seed files\", \"RNDbytes\");\n        break;\n    }\n\n    /* RNDfile */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n#ifdef RANDOM_FILE\n        new_global_options.rand_file=str_dup(RANDOM_FILE);\n#else\n        new_global_options.rand_file=NULL;\n#endif\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        tmp=global_options.rand_file;\n        global_options.rand_file=NULL;\n        str_free(tmp);\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"RNDfile\"))\n            break;\n        new_global_options.rand_file=str_dup(arg);\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n#ifdef RANDOM_FILE\n        s_log(LOG_NOTICE, \"%-22s = %s\", \"RNDfile\", RANDOM_FILE);\n#endif\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = path to file with random seed data\", \"RNDfile\");\n        break;\n    }\n\n    /* RNDoverwrite */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.option.rand_write=1;\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"RNDoverwrite\"))\n            break;\n        if(!strcasecmp(arg, \"yes\"))\n            new_global_options.option.rand_write=1;\n        else if(!strcasecmp(arg, \"no\"))\n            new_global_options.option.rand_write=0;\n        else\n            return \"The argument needs to be either 'yes' or 'no'\";\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        s_log(LOG_NOTICE, \"%-22s = yes\", \"RNDoverwrite\");\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = yes|no overwrite seed datafiles with new random data\",\n            \"RNDoverwrite\");\n        break;\n    }\n\n    /* syslog */\n#ifndef USE_WIN32\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.option.log_syslog=1;\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"syslog\"))\n            break;\n        if(!strcasecmp(arg, \"yes\"))\n            new_global_options.option.log_syslog=1;\n        else if(!strcasecmp(arg, \"no\"))\n            new_global_options.option.log_syslog=0;\n        else\n            return \"The argument needs to be either 'yes' or 'no'\";\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = yes|no send logging messages to syslog\",\n            \"syslog\");\n        break;\n    }\n#endif\n\n    /* taskbar */\n#ifdef USE_WIN32\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.option.taskbar=1;\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"taskbar\"))\n            break;\n        if(!strcasecmp(arg, \"yes\"))\n            new_global_options.option.taskbar=1;\n        else if(!strcasecmp(arg, \"no\"))\n            new_global_options.option.taskbar=0;\n        else\n            return \"The argument needs to be either 'yes' or 'no'\";\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        s_log(LOG_NOTICE, \"%-22s = yes\", \"taskbar\");\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = yes|no enable the taskbar icon\", \"taskbar\");\n        break;\n    }\n#endif\n\n    /* final checks */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        break;\n    case CMD_SET_COPY:\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        return option_not_found;\n    case CMD_INITIALIZE:\n        /* FIPS needs to be initialized as early as possible */\n        if(ssl_configure(&new_global_options)) /* configure global TLS settings */\n            return \"Failed to initialize TLS\";\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        break;\n    }\n    return NULL; /* OK */\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "NOEXPORT char *parse_global_option(CMD cmd, GLOBAL_OPTIONS *options, char *opt, char *arg) {\n    void *tmp;\n\n    if(cmd==CMD_PRINT_DEFAULTS || cmd==CMD_PRINT_HELP) {\n        s_log(LOG_NOTICE, \" \");\n        s_log(LOG_NOTICE, \"Global options:\");\n    }\n\n    /* chroot */\n#ifdef HAVE_CHROOT\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->chroot_dir=NULL;\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        tmp=options->chroot_dir;\n        options->chroot_dir=NULL;\n        str_free(tmp);\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"chroot\"))\n            break;\n        options->chroot_dir=str_dup(arg);\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = directory to chroot stunnel process\", \"chroot\");\n        break;\n    }\n#endif /* HAVE_CHROOT */\n\n    /* compression */\n#ifndef OPENSSL_NO_COMP\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->compression=COMP_NONE;\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"compression\"))\n            break;\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n        /* only allow compression with OpenSSL 0.9.8 or later\n         * with OpenSSL #1468 zlib memory leak fixed */\n        if(OpenSSL_version_num()<0x00908051L) /* 0.9.8e-beta1 */\n            return \"Compression unsupported due to a memory leak\";\n#endif /* OpenSSL version < 1.1.0 */\n        if(!strcasecmp(arg, \"deflate\"))\n            options->compression=COMP_DEFLATE;\n        else if(!strcasecmp(arg, \"zlib\"))\n            options->compression=COMP_ZLIB;\n        else\n            return \"Specified compression type is not available\";\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = compression type\",\n            \"compression\");\n        break;\n    }\n#endif /* !defined(OPENSSL_NO_COMP) */\n\n    /* EGD */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n#ifdef EGD_SOCKET\n        options->egd_sock=EGD_SOCKET;\n#else\n        options->egd_sock=NULL;\n#endif\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        tmp=options->egd_sock;\n        options->egd_sock=NULL;\n        str_free(tmp);\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"EGD\"))\n            break;\n        options->egd_sock=str_dup(arg);\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n#ifdef EGD_SOCKET\n        s_log(LOG_NOTICE, \"%-22s = %s\", \"EGD\", EGD_SOCKET);\n#endif\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = path to Entropy Gathering Daemon socket\", \"EGD\");\n            \"engineDefault\");\n        break;\n    }\n\n#endif /* !defined(OPENSSL_NO_ENGINE) */\n\n    /* fips */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n#ifdef USE_FIPS\n        options->option.fips=FIPS_mode()?1:0;\n#endif /* USE_FIPS */\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"fips\"))\n            break;\n        if(!strcasecmp(arg, \"yes\")) {\n#ifdef USE_FIPS\n            options->option.fips=1;\n#else\n            return \"FIPS support is not available\";\n#endif /* USE_FIPS */\n        } else if(!strcasecmp(arg, \"no\")) {\n#ifdef USE_FIPS\n            if(FIPS_mode())\n                return \"Failed to override system-wide FIPS mode\";\n            options->option.fips=0;\n#endif /* USE_FIPS */\n        } else {\n            return \"The argument needs to be either 'yes' or 'no'\";\n        }\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n#ifdef USE_FIPS\n        s_log(LOG_NOTICE, \"%-22s = %s\", \"fips\", FIPS_mode()?\"yes\":\"no\");\n#endif /* USE_FIPS */\n        break;\n    case CMD_PRINT_HELP:\n#ifdef USE_FIPS\n        s_log(LOG_NOTICE, \"%-22s = yes|no FIPS 140-2 mode\",\n            \"fips\");\n#endif /* USE_FIPS */\n        break;\n    }\n\n    /* foreground */\n#ifndef USE_WIN32\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->option.foreground=0;\n        options->option.log_stderr=0;\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"foreground\"))\n            break;\n        if(!strcasecmp(arg, \"yes\")) {\n            options->option.foreground=1;\n            options->option.log_stderr=1;\n        } else if(!strcasecmp(arg, \"quiet\")) {\n            options->option.foreground=1;\n            options->option.log_stderr=0;\n        } else if(!strcasecmp(arg, \"no\")) {\n            options->option.foreground=0;\n            options->option.log_stderr=0;\n        } else\n            return \"The argument needs to be either 'yes', 'quiet' or 'no'\";\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = yes|quiet|no foreground mode (don't fork, log to stderr)\",\n            \"foreground\");\n        break;\n    }\n#endif\n\n#ifdef ICON_IMAGE\n\n    /* iconActive */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->icon[ICON_ACTIVE]=load_icon_default(ICON_ACTIVE);\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        /* FIXME: investigate if we can free it */\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"iconActive\"))\n            break;\n        if(!(options->icon[ICON_ACTIVE]=load_icon_file(arg)))\n            return \"Failed to load the specified icon\";\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = icon when connections are established\", \"iconActive\");\n        break;\n    }\n\n    /* iconError */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->icon[ICON_ERROR]=load_icon_default(ICON_ERROR);\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        /* FIXME: investigate if we can free it */\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"iconError\"))\n            break;\n        if(!(options->icon[ICON_ERROR]=load_icon_file(arg)))\n            return \"Failed to load the specified icon\";\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = icon for invalid configuration file\", \"iconError\");\n        break;\n    }\n\n    /* iconIdle */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->icon[ICON_IDLE]=load_icon_default(ICON_IDLE);\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        /* FIXME: investigate if we can free it */\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"iconIdle\"))\n            break;\n        if(!(options->icon[ICON_IDLE]=load_icon_file(arg)))\n            return \"Failed to load the specified icon\";\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = icon when no connections were established\", \"iconIdle\");\n        break;\n    }\n\n#endif /* ICON_IMAGE */\n\n    /* log */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->log_file_mode=FILE_MODE_APPEND;\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"log\"))\n            break;\n        if(!strcasecmp(arg, \"append\"))\n            options->log_file_mode=FILE_MODE_APPEND;\n        else if(!strcasecmp(arg, \"overwrite\"))\n            options->log_file_mode=FILE_MODE_OVERWRITE;\n        else\n            return \"The argument needs to be either 'append' or 'overwrite'\";\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = append|overwrite log file\",\n            \"log\");\n        break;\n    }\n\n    /* output */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->output_file=NULL;\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        tmp=options->output_file;\n        options->output_file=NULL;\n        str_free(tmp);\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"output\"))\n            break;\n        options->output_file=str_dup(arg);\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n#ifndef USE_WIN32\n        if(!options->option.foreground /* daemonize() used */ &&\n                options->output_file /* log file enabled */ &&\n                options->output_file[0]!='/' /* relative path */)\n            return \"Log file must include full path name\";\n#endif\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = file to append log messages\", \"output\");\n        break;\n    }\n\n    /* pid */\n#ifndef USE_WIN32\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->pidfile=NULL; /* do not create a pid file */\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        tmp=options->pidfile;\n        options->pidfile=NULL;\n        str_free(tmp);\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"pid\"))\n            break;\n        if(arg[0]) /* is argument not empty? */\n            options->pidfile=str_dup(arg);\n        else\n            options->pidfile=NULL; /* empty -> do not create a pid file */\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        if(!options->option.foreground /* daemonize() used */ &&\n                options->pidfile /* pid file enabled */ &&\n                options->pidfile[0]!='/' /* relative path */)\n            return \"Pid file must include full path name\";\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = pid file\", \"pid\");\n        break;\n    }\n#endif\n\n    /* RNDbytes */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->random_bytes=RANDOM_BYTES;\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"RNDbytes\"))\n            break;\n        {\n            char *tmp_str;\n            options->random_bytes=(long)strtol(arg, &tmp_str, 10);\n            if(tmp_str==arg || *tmp_str) /* not a number */\n                return \"Illegal number of bytes to read from random seed files\";\n        }\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        s_log(LOG_NOTICE, \"%-22s = %d\", \"RNDbytes\", RANDOM_BYTES);\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = bytes to read from random seed files\", \"RNDbytes\");\n        break;\n    }\n\n    /* RNDfile */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n#ifdef RANDOM_FILE\n        options->rand_file=str_dup(RANDOM_FILE);\n#else\n        options->rand_file=NULL;\n#endif\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        tmp=options->rand_file;\n        options->rand_file=NULL;\n        str_free(tmp);\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"RNDfile\"))\n            break;\n        options->rand_file=str_dup(arg);\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n#ifdef RANDOM_FILE\n        s_log(LOG_NOTICE, \"%-22s = %s\", \"RNDfile\", RANDOM_FILE);\n#endif\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = path to file with random seed data\", \"RNDfile\");\n        break;\n    }\n\n    /* RNDoverwrite */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->option.rand_write=1;\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"RNDoverwrite\"))\n            break;\n        if(!strcasecmp(arg, \"yes\"))\n            options->option.rand_write=1;\n        else if(!strcasecmp(arg, \"no\"))\n            options->option.rand_write=0;\n        else\n            return \"The argument needs to be either 'yes' or 'no'\";\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        s_log(LOG_NOTICE, \"%-22s = yes\", \"RNDoverwrite\");\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = yes|no overwrite seed datafiles with new random data\",\n            \"RNDoverwrite\");\n        break;\n    }\n\n    /* syslog */\n#ifndef USE_WIN32\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->option.log_syslog=1;\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"syslog\"))\n            break;\n        if(!strcasecmp(arg, \"yes\"))\n            options->option.log_syslog=1;\n        else if(!strcasecmp(arg, \"no\"))\n            options->option.log_syslog=0;\n        else\n            return \"The argument needs to be either 'yes' or 'no'\";\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = yes|no send logging messages to syslog\",\n            \"syslog\");\n        break;\n    }\n#endif\n\n    /* taskbar */\n#ifdef USE_WIN32\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->option.taskbar=1;\n        break;\n    case CMD_SET_COPY: /* not used for global options */\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"taskbar\"))\n            break;\n        if(!strcasecmp(arg, \"yes\"))\n            options->option.taskbar=1;\n        else if(!strcasecmp(arg, \"no\"))\n            options->option.taskbar=0;\n        else\n            return \"The argument needs to be either 'yes' or 'no'\";\n        return NULL; /* OK */\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        s_log(LOG_NOTICE, \"%-22s = yes\", \"taskbar\");\n        break;\n    case CMD_PRINT_HELP:\n        s_log(LOG_NOTICE, \"%-22s = yes|no enable the taskbar icon\", \"taskbar\");\n    }\n#endif\n\n    /* final checks */\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        break;\n    case CMD_SET_COPY:\n        break;\n    case CMD_FREE:\n        memset(options, 0, sizeof(GLOBAL_OPTIONS));\n        break;\n    case CMD_SET_VALUE:\n        return option_not_found;\n    case CMD_INITIALIZE:\n        /* FIPS needs to be initialized as early as possible */\n        if(ssl_configure(options)) /* configure global TLS settings */\n            return \"Failed to initialize TLS\";\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        break;\n    }\n    return NULL; /* OK */\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "        }\n\n        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,\n         * since that can make new copy of abrtd to process it,\n         * and maybe crash again...\n         * Unlike dirs, mere files are ignored by abrtd.\n         */\n        if (snprintf(path, sizeof(path), \"%s/%s-coredump\", g_settings_dump_location, last_slash) >= sizeof(path))\n            error_msg_and_die(\"Error saving '%s': truncated long file path\", path);\n\n        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);\n        off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);\n        if (core_size < 0 || fsync(abrt_core_fd) != 0)\n        {\n            unlink(path);\n            /* copyfd_eof logs the error including errno string,\n             * but it does not log file name */\n            error_msg_and_die(\"Error saving '%s'\", path);\n        }\n        log_notice(\"Saved core dump of pid %lu (%s) to %s (%llu bytes)\", (long)pid, executable, path, (long long)core_size);\n        err = 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "        }\n\n        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,\n         * since that can make new copy of abrtd to process it,\n         * and maybe crash again...\n         * Unlike dirs, mere files are ignored by abrtd.\n         */\n        if (snprintf(path, sizeof(path), \"%s/%s-coredump\", g_settings_dump_location, last_slash) >= sizeof(path))\n            error_msg_and_die(\"Error saving '%s': truncated long file path\", path);\n\n        unlink(path);\n        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);\n        off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);\n        if (core_size < 0 || fsync(abrt_core_fd) != 0)\n        {\n            unlink(path);\n            /* copyfd_eof logs the error including errno string,\n             * but it does not log file name */\n            error_msg_and_die(\"Error saving '%s'\", path);\n        }\n        log_notice(\"Saved core dump of pid %lu (%s) to %s (%llu bytes)\", (long)pid, executable, path, (long long)core_size);\n        err = 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int ceph_x_proc_ticket_reply(struct ceph_auth_client *ac,\n\t\t\t\t    struct ceph_crypto_key *secret,\n\t\t\t\t    void *buf, void *end)\n{\n\tvoid *p = buf;\n\tchar *dbuf;\n\tchar *ticket_buf;\n\tu8 reply_struct_v;\n\tu32 num;\n\tint ret;\n\n\tdbuf = kmalloc(TEMP_TICKET_BUF_LEN, GFP_NOFS);\n\tif (!dbuf)\n\t\treturn -ENOMEM;\n\n\tret = -ENOMEM;\n\tticket_buf = kmalloc(TEMP_TICKET_BUF_LEN, GFP_NOFS);\n\tif (!ticket_buf)\n\t\tgoto out_dbuf;\n\n\tceph_decode_8_safe(&p, end, reply_struct_v, bad);\n\tif (reply_struct_v != 1)\n\t\treturn -EINVAL;\n\n\tceph_decode_32_safe(&p, end, num, bad);\n\tdout(\"%d tickets\\n\", num);\n\n\twhile (num--) {\n\t\tret = process_one_ticket(ac, secret, &p, end,\n\t\t\t\t\t dbuf, ticket_buf);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tkfree(ticket_buf);\nout_dbuf:\n\tkfree(dbuf);\n\treturn ret;\n\nbad:\n\tret = -EINVAL;\n\tgoto out;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int ceph_x_proc_ticket_reply(struct ceph_auth_client *ac,\n\t\t\t\t    struct ceph_crypto_key *secret,\n\t\t\t\t    void *buf, void *end)\n{\n\tvoid *p = buf;\n\tu8 reply_struct_v;\n\tu32 num;\n\tint ret;\n\n\tceph_decode_8_safe(&p, end, reply_struct_v, bad);\n\tif (reply_struct_v != 1)\n\t\treturn -EINVAL;\n\n\tceph_decode_32_safe(&p, end, num, bad);\n\tdout(\"%d tickets\\n\", num);\n\n\twhile (num--) {\n\t\tret = process_one_ticket(ac, secret, &p, end);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n\nbad:\n\treturn -EINVAL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t * e.g.ppc44x-defconfig has CONFIG_PTE_64BIT=y and CONFIG_32BIT=y,\n\t * so READ_ONCE or ACCESS_ONCE cannot guarantee atomic accesses.\n\t * The code below just needs a consistent view for the ifs and\n\t * we later double check anyway with the ptl lock held. So here\n\t * a barrier will do.\n\t */\n\tentry = *pte;\n\tbarrier();\n\tif (!pte_present(entry)) {\n\t\tif (pte_none(entry)) {\n\t\t\tif (vma->vm_ops) {\n\t\t\t\tif (likely(vma->vm_ops->fault))\n\t\t\t\t\treturn do_fault(mm, vma, address, pte,\n\t\t\t\t\t\t\tpmd, flags, entry);\n\t\t\t}\n\t\t\treturn do_anonymous_page(mm, vma, address,\n\t\t\t\t\t\t pte, pmd, flags);\n\t\t}\n\t\treturn do_swap_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, flags, entry);\n\t}\n\n\tif (pte_protnone(entry))\n\t\treturn do_numa_page(mm, vma, address, entry, pte, pmd);\n\n\tptl = pte_lockptr(mm, pmd);\n\tspin_lock(ptl);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t * e.g.ppc44x-defconfig has CONFIG_PTE_64BIT=y and CONFIG_32BIT=y,\n\t * so READ_ONCE or ACCESS_ONCE cannot guarantee atomic accesses.\n\t * The code below just needs a consistent view for the ifs and\n\t * we later double check anyway with the ptl lock held. So here\n\t * a barrier will do.\n\t */\n\tentry = *pte;\n\tbarrier();\n\tif (!pte_present(entry)) {\n\t\tif (pte_none(entry)) {\n\t\t\tif (vma->vm_ops)\n\t\t\t\treturn do_fault(mm, vma, address, pte, pmd,\n\t\t\t\t\t\tflags, entry);\n\n\t\t\treturn do_anonymous_page(mm, vma, address, pte, pmd,\n\t\t\t\t\tflags);\n\t\t}\n\t\treturn do_swap_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, flags, entry);\n\t}\n\n\tif (pte_protnone(entry))\n\t\treturn do_numa_page(mm, vma, address, entry, pte, pmd);\n\n\tptl = pte_lockptr(mm, pmd);\n\tspin_lock(ptl);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\t/* When countermeasures are enabled, shut down the\n\t\t * card; when disabled, re-enable the card. This must\n\t\t * take effect immediately.\n\t\t *\n\t\t * TODO: Make sure that the EAPOL message is getting\n\t\t *       out before card disabled\n\t\t */\n\t\tif (param->value) {\n\t\t\tpriv->tkip_cm_active = 1;\n\t\t\tret = hermes_enable_port(hw, 0);\n\t\t} else {\n\t\t\tpriv->tkip_cm_active = 0;\n\t\t\tret = hermes_disable_port(hw, 0);\n\t\t}\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY)\n\t\t\tpriv->wep_restrict = 1;\n\t\telse if (param->value & IW_AUTH_ALG_OPEN_SYSTEM)\n\t\t\tpriv->wep_restrict = 0;\n\t\telse\n\t\t\tret = -EINVAL;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tcase IW_AUTH_TKIP_COUNTERMEASURES:\n\t\t/* When countermeasures are enabled, shut down the\n\t\t * card; when disabled, re-enable the card. This must\n\t\t * take effect immediately.\n\t\t *\n\t\t * TODO: Make sure that the EAPOL message is getting\n\t\t *       out before card disabled\n\t\t */\n\t\tif (param->value) {\n\t\t\tpriv->tkip_cm_active = 1;\n\t\t\tret = hermes_disable_port(hw, 0);\n\t\t} else {\n\t\t\tpriv->tkip_cm_active = 0;\n\t\t\tret = hermes_enable_port(hw, 0);\n\t\t}\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY)\n\t\t\tpriv->wep_restrict = 1;\n\t\telse if (param->value & IW_AUTH_ALG_OPEN_SYSTEM)\n\t\t\tpriv->wep_restrict = 0;\n\t\telse\n\t\t\tret = -EINVAL;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int snd_ctl_elem_read(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tstruct snd_ctl_elem_info info;\n\tconst u32 pattern = 0xdeadbeef;\n\tint ret;\n\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL)\n\t\treturn -ENOENT;\n\n\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\tvd = &kctl->vd[index_offset];\n\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_READ) || kctl->get == NULL)\n\t\treturn -EPERM;\n\n\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\n#ifdef CONFIG_SND_CTL_DEBUG\n\t/* info is needed only for validation */\n\tmemset(&info, 0, sizeof(info));\n\tinfo.id = control->id;\n\tret = __snd_ctl_elem_info(card, kctl, &info, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n#endif\n\n\tif (!snd_ctl_skip_validation(&info))\n\t\tfill_remaining_elem_value(control, &info, pattern);\n\tret = snd_power_ref_and_wait(card);\n\tif (!ret)\n\t\tret = kctl->get(kctl, control);\n\tsnd_power_unref(card);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!snd_ctl_skip_validation(&info) &&\n\t    sanity_check_elem_value(card, control, &info, pattern) < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"control %i:%i:%i:%s:%i: access overflow\\n\",\n\t\t\tcontrol->id.iface, control->id.device,\n\t\t\tcontrol->id.subdevice, control->id.name,\n\t\t\tcontrol->id.index);\n\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int snd_ctl_elem_read(struct snd_card *card,\n\t\t\t     struct snd_ctl_elem_value *control)\n{\n\tstruct snd_kcontrol *kctl;\n\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tstruct snd_ctl_elem_info info;\n\tconst u32 pattern = 0xdeadbeef;\n\tint ret;\n\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL) {\n\t\tret = -ENOENT;\n\t\tgoto unlock;\n\t}\n\n\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\tvd = &kctl->vd[index_offset];\n\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_READ) || kctl->get == NULL) {\n\t\tret = -EPERM;\n\t\tgoto unlock;\n\t}\n\n\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\n#ifdef CONFIG_SND_CTL_DEBUG\n\t/* info is needed only for validation */\n\tmemset(&info, 0, sizeof(info));\n\tinfo.id = control->id;\n\tret = __snd_ctl_elem_info(card, kctl, &info, NULL);\n\tif (ret < 0)\n\t\tgoto unlock;\n#endif\n\n\tif (!snd_ctl_skip_validation(&info))\n\t\tfill_remaining_elem_value(control, &info, pattern);\n\tret = snd_power_ref_and_wait(card);\n\tif (!ret)\n\t\tret = kctl->get(kctl, control);\n\tsnd_power_unref(card);\n\tif (ret < 0)\n\t\tgoto unlock;\n\tif (!snd_ctl_skip_validation(&info) &&\n\t    sanity_check_elem_value(card, control, &info, pattern) < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"control %i:%i:%i:%s:%i: access overflow\\n\",\n\t\t\tcontrol->id.iface, control->id.device,\n\t\t\tcontrol->id.subdevice, control->id.name,\n\t\t\tcontrol->id.index);\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\nunlock:\n\tup_read(&card->controls_rwsem);\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tgoto error;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\n\tnfc_llcp_sock_link(&local->raw_sockets, sk);\n\n\tsk->sk_state = LLCP_BOUND;\n\nput_dev:\n\tnfc_put_device(dev);\n\nerror:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tgoto error;\n\t}\n\n\tlocal = nfc_llcp_find_local(dev);\n\tif (local == NULL) {\n\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = local;\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\n\tnfc_llcp_sock_link(&local->raw_sockets, sk);\n\n\tsk->sk_state = LLCP_BOUND;\n\nput_dev:\n\tnfc_put_device(dev);\n\nerror:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tint error = 0;\n\n\tif (!acl)\n\t\tgoto set_acl;\n\n\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\n\t\tif (error <= 0) {\n\t\t\tacl = NULL;\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n set_acl:\n\treturn __xfs_set_acl(inode, type, acl);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tint error = 0;\n\n\tif (!acl)\n\t\tgoto set_acl;\n\n\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode;\n\n\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n set_acl:\n\treturn __xfs_set_acl(inode, type, acl);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "R_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR;\n\tattr->size = offset;\n\treturn attr;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "R_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tif (sz < 8) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR;\n\tattr->size = 6;\n\treturn attr;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "alloc_limit_failure (char *fn_name, size_t size)\n{\n    fprintf (stderr, \n             \"%s: Maximum allocation size exceeded \"\n             \"(maxsize = %lu; size = %lu).\\n\",\n             fn_name,\n             (unsigned long)alloc_limit, \n             (unsigned long)size);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "alloc_limit_failure (char *fn_name, size_t size)\n{\n    fprintf (stderr,\n             \"%s: Maximum allocation size exceeded \"\n             \"(maxsize = %lu; size = %lu).\\n\",\n             fn_name,\n             (unsigned long)alloc_limit,\n             (unsigned long)size);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void ntlm_populate_message_header(NTLM_MESSAGE_HEADER* header, UINT32 MessageType)\n{\n\tCopyMemory(header->Signature, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE));\n\theader->MessageType = MessageType;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void ntlm_populate_message_header(NTLM_MESSAGE_HEADER* header, UINT32 MessageType)\n{\n\tCopyMemory(header->Signature, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE));\n\theader->MessageType = MessageType;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "                if (e_shnum <= sh_link) {\n                    char msg[50]; snprintf(msg, sizeof(msg),\n                        \"bad SHT_DYNSYM.sh_link %#x\", sh_link);\n                }\n                sec_dynstr = &shdri[sh_link];\n            }\n\n            if (sec_strndx) {\n                unsigned const sh_name = get_te32(&sec_strndx->sh_name);\n                if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n                || (u32_t)file_size <= sh_name  // FIXME: weak\n                || (sh_name\n                  && 0!=strcmp((char const *)\".shstrtab\", &shstrtab[sh_name]))\n                ) {\n                    throwCantPack(\"bad e_shstrndx\");\n                }\n            }\n        }\n\n        Elf32_Phdr const *pload_x0(0);  // first eXecutable PT_LOAD\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "                if (e_shnum <= sh_link) {\n                    char msg[50]; snprintf(msg, sizeof(msg),\n                        \"bad SHT_DYNSYM.sh_link %#x\", sh_link);\n                }\n                sec_dynstr = &shdri[sh_link];\n            }\n\n            if (sec_strndx) {\n                unsigned const sh_name = get_te32(&sec_strndx->sh_name);\n                if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n                || (u32_t)file_size <= (sizeof(\".shstrtab\")\n                    + sh_name + (shstrtab - (const char *)&file_image[0]))\n                || (sh_name\n                  && 0!=strcmp((char const *)\".shstrtab\", &shstrtab[sh_name]))\n                ) {\n                    throwCantPack(\"bad e_shstrtab\");\n                }\n            }\n        }\n\n        Elf32_Phdr const *pload_x0(0);  // first eXecutable PT_LOAD\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,\n                          uint32_t enc_len, char *key) {\n\n    LOG_DEBUG(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(key);\n\n    *errStatus = -9;\n\n    int status = AES_decrypt_DH(encryptedPrivateKey, enc_len, key, 3072);\n\n    if (status != 0) {\n        *errStatus = status;\n        snprintf(errString, BUF_LEN, \"aes decrypt failed with status %d\", status);\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    *errStatus = -10;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,\n                          uint64_t enc_len, char *key) {\n\n    LOG_DEBUG(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(key);\n\n    *errStatus = -9;\n\n    int status = AES_decrypt(encryptedPrivateKey, enc_len, key, 3072);\n\n    if (status != 0) {\n        *errStatus = status;\n        snprintf(errString, BUF_LEN, \"aes decrypt failed with status %d\", status);\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    *errStatus = -10;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    }\n    suppressed_hdrs.cnt_trans_enc = 1;\n  }\n\n  /* To: */\n  char *to_r = nullptr;\n  int err = 0;\n  if (!to.empty()) {\n    int to_len = to.size();\n    if (to_len > 0) {\n      to_r = strndup(to.data(), to_len);\n      for (; to_len; to_len--) {\n        if (!isspace((unsigned char)to_r[to_len - 1])) {\n          break;\n        }\n        to_r[to_len - 1] = '\\0';\n      }\n      for (int i = 0; to_r[i]; i++) {\n        if (iscntrl((unsigned char)to_r[i])) {\n          /**\n           * According to RFC 822, section 3.1.1 long headers may be\n\n  mbfl_memory_device_unput(&device);\n  mbfl_memory_device_output('\\0', &device);\n\n  char *all_headers = (char *)device.buffer;\n\n  String cmd = string_escape_shell_cmd(extra_cmd.c_str());\n  bool ret = (!err && php_mail(to_r, encoded_subject.data(),\n                               encoded_message.data(),\n                               all_headers, cmd.data()));\n  mbfl_memory_device_clear(&device);\n  return ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    }\n    suppressed_hdrs.cnt_trans_enc = 1;\n  }\n\n  /* To: */\n  char *to_r = nullptr;\n  int err = 0;\n  if (!to.empty()) {\n    int to_len = to.size();\n    if (to_len > 0) {\n      to_r = req::strndup(to.data(), to_len);\n      for (; to_len; to_len--) {\n        if (!isspace((unsigned char)to_r[to_len - 1])) {\n          break;\n        }\n        to_r[to_len - 1] = '\\0';\n      }\n      for (int i = 0; to_r[i]; i++) {\n        if (iscntrl((unsigned char)to_r[i])) {\n          /**\n           * According to RFC 822, section 3.1.1 long headers may be\n  mbfl_memory_device_unput(&device);\n  mbfl_memory_device_output('\\0', &device);\n\n  char *all_headers = (char *)device.buffer;\n\n  String cmd = string_escape_shell_cmd(extra_cmd.c_str());\n  bool ret = (!err && php_mail(to_r, encoded_subject.data(),\n                               encoded_message.data(),\n                               all_headers, cmd.data()));\n  mbfl_memory_device_clear(&device);\n  if (to_r != to.data()) {\n    req::free(to_r);\n  }\n  return ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "vips_foreign_load_start( VipsImage *out, void *a, void *b )\n{\n\tVipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );\n\tVipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );\n\n\tif( !load->real ) {\n\t\tif( !(load->real = vips_foreign_load_temp( load )) )\n\t\t\treturn( NULL );\n\n#ifdef DEBUG\n\t\tprintf( \"vips_foreign_load_start: triggering ->load()\\n\" );\n#endif /*DEBUG*/\n\n\t\t/* Read the image in. This may involve a long computation and\n\t\t */\n\t\tload->real->progress_signal = load->out;\n\n\t\t/* Note the load object on the image. Loaders can use \n\t\t * this to signal invalidate if they hit a load error. See\n\t\t * vips_foreign_load_invalidate() below.\n\t\t */\n\t\tg_object_set_qdata( G_OBJECT( load->real ), \n\t\t\tvips__foreign_load_operation, load ); \n\n\t\tif( class->load( load ) ||\n\t\t\tvips_image_pio_input( load->real ) ) \n\t\t\treturn( NULL );\n\n\t\t/* ->header() read the header into @out, load has read the\n\t\t * image into @real. They must match exactly in size, bands,\n\t\t * format and coding for the copy to work.  \n\t\t *\n\t\t * Some versions of ImageMagick give different results between\n\t\t * Ping and Load for some formats, for example.\n\t\t */\n\t\tif( !vips_foreign_load_iscompat( load->real, out ) )\n\t\t\treturn( NULL );\n\n\t\t/* We have to tell vips that out depends on real. We've set\n\t\t * the demand hint below, but not given an input there.\n\t\t */\n\t\tvips_image_pipelinev( load->out, load->out->dhint, \n\t\t\tload->real, NULL );\n\t}\n\n\treturn( vips_region_new( load->real ) );\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "vips_foreign_load_start( VipsImage *out, void *a, void *b )\n{\n\tVipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );\n\tVipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );\n\n\t/* If this start has failed before in another thread, we can fail now.\n\t */\n\tif( load->error )\n\t\treturn( NULL );\n\n\tif( !load->real ) {\n\t\tif( !(load->real = vips_foreign_load_temp( load )) )\n\t\t\treturn( NULL );\n\n#ifdef DEBUG\n\t\tprintf( \"vips_foreign_load_start: triggering ->load()\\n\" );\n#endif /*DEBUG*/\n\n\t\t/* Read the image in. This may involve a long computation and\n\t\t */\n\t\tload->real->progress_signal = load->out;\n\n\t\t/* Note the load object on the image. Loaders can use \n\t\t * this to signal invalidate if they hit a load error. See\n\t\t * vips_foreign_load_invalidate() below.\n\t\t */\n\t\tg_object_set_qdata( G_OBJECT( load->real ), \n\t\t\tvips__foreign_load_operation, load ); \n\n\t\t/* Load the image and check the result.\n\t\t *\n\t\t * ->header() read the header into @out, load has read the\n\t\t * image into @real. They must match exactly in size, bands,\n\t\t * format and coding for the copy to work.  \n\t\t *\n\t\t * Some versions of ImageMagick give different results between\n\t\t * Ping and Load for some formats, for example.\n\t\t *\n\t\t * If the load fails, we need to stop\n\t\t */\n\t\tif( class->load( load ) ||\n\t\t\tvips_image_pio_input( load->real ) || \n\t\t\tvips_foreign_load_iscompat( load->real, out ) ) {\n\t\t\tvips_operation_invalidate( VIPS_OPERATION( load ) ); \n\t\t\tload->error = TRUE;\n\n\t\t\treturn( NULL );\n\t\t}\n\n\t\t/* We have to tell vips that out depends on real. We've set\n\t\t * the demand hint below, but not given an input there.\n\t\t */\n\t\tvips_image_pipelinev( load->out, load->out->dhint, \n\t\t\tload->real, NULL );\n\t}\n\n\treturn( vips_region_new( load->real ) );\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int curlen, argc, nsiz;\n    Jsi_Obj *obj, *nobj;\n    Jsi_Value *va;\n\n    obj = _this->d.obj;\n    \n    argc = Jsi_ValueGetLength(interp, args);\n    curlen = Jsi_ObjGetLength(interp, obj);\n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    Jsi_ObjListifyArray(interp, obj);\n   \n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    nsiz = obj->arrMaxSize;\n    if (nsiz<=0) nsiz = 100;\n    if (Jsi_ObjArraySizer(interp, nobj, nsiz+1) <= 0) {\n        rc = JSI_ERROR;\n        Jsi_LogError(\"index too large: %d\", nsiz+1);\n        goto bail;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int curlen, argc, nsiz;\n    Jsi_Obj *obj, *nobj;\n    Jsi_Value *va;\n\n    obj = _this->d.obj;\n    \n    argc = Jsi_ValueGetLength(interp, args);\n    curlen = jsi_SizeOfArray(interp, obj);\n    Jsi_ObjListifyArray(interp, obj);\n   \n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    nsiz = obj->arrMaxSize;\n    if (nsiz<=0) nsiz = 100;\n    if (Jsi_ObjArraySizer(interp, nobj, nsiz+1) <= 0) {\n        rc = JSI_ERROR;\n        Jsi_LogError(\"index too large: %d\", nsiz+1);\n        goto bail;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void perf_event_enable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct task_struct *task = ctx->task;\n\n\tif (!task) {\n\t\t/*\n\t\t * Enable the event on the cpu that it's on\n\t\t */\n\t\tcpu_function_call(event->cpu, __perf_event_enable, event);\n\t\treturn;\n\t}\n\n\traw_spin_lock_irq(&ctx->lock);\n\tif (event->state >= PERF_EVENT_STATE_INACTIVE)\n\t\tgoto out;\n\n\t/*\n\t * If the event is in error state, clear that first.\n\t * That way, if we see the event in error state below, we\n\t * know that it has gone back into error state, as distinct\n\t * from the task having been scheduled away before the\n\t * cross-call arrived.\n\t */\n\tif (event->state == PERF_EVENT_STATE_ERROR)\n\t\tevent->state = PERF_EVENT_STATE_OFF;\n\nretry:\n\tif (!ctx->is_active) {\n\t\t__perf_event_mark_enabled(event);\n\t\tgoto out;\n\t}\n\n\traw_spin_unlock_irq(&ctx->lock);\n\n\tif (!task_function_call(task, __perf_event_enable, event))\n\t\treturn;\n\n\traw_spin_lock_irq(&ctx->lock);\n\n\t/*\n\t * If the context is active and the event is still off,\n\t * we need to retry the cross-call.\n\t */\n\tif (ctx->is_active && event->state == PERF_EVENT_STATE_OFF) {\n\t\t/*\n\t\t * task could have been flipped by a concurrent\n\t\t * perf_event_context_sched_out()\n\t\t */\n\t\ttask = ctx->task;\n\t\tgoto retry;\n\t}\n\nout:\n\traw_spin_unlock_irq(&ctx->lock);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void perf_event_enable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx;\n\n\tctx = perf_event_ctx_lock(event);\n\t_perf_event_enable(event);\n\tperf_event_ctx_unlock(event, ctx);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, ",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, ",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* axis = GetInput(context, node, kAxis);\n  // Make sure the axis is only 1 dimension.\n  TF_LITE_ENSURE_EQ(context, NumElements(axis), 1);\n  // Make sure the axis is only either int32 or int64.\n  TF_LITE_ENSURE(context,\n                 axis->type == kTfLiteInt32 || axis->type == kTfLiteInt64);\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  auto* params = reinterpret_cast<TfLiteArgMaxParams*>(node->builtin_data);\n  switch (params->output_type) {\n    case kTfLiteInt32:\n      output->type = kTfLiteInt32;\n      break;\n    case kTfLiteInt64:\n      output->type = kTfLiteInt64;\n      break;\n    default:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  const TfLiteTensor* axis;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kAxis, &axis));\n  // Make sure the axis is only 1 dimension.\n  TF_LITE_ENSURE_EQ(context, NumElements(axis), 1);\n  // Make sure the axis is only either int32 or int64.\n  TF_LITE_ENSURE(context,\n                 axis->type == kTfLiteInt32 || axis->type == kTfLiteInt64);\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  auto* params = reinterpret_cast<TfLiteArgMaxParams*>(node->builtin_data);\n  switch (params->output_type) {\n    case kTfLiteInt32:\n      output->type = kTfLiteInt32;\n      break;\n    case kTfLiteInt64:\n      output->type = kTfLiteInt64;\n      break;\n    default:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tif (!ARCH_SUN4C && address >= TASK_SIZE)\n\t\tgoto vmalloc_fault;\n\n\t/*\n\t * If we're in an interrupt or have no user\n\t * context, we must not take the fault..\n\t */\n        if (in_atomic() || !mm)\n                goto no_context;\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n\n\tdown_read(&mm->mmap_sem);\n\n\t/*\n\t * The kernel referencing a bad kernel pointer can lock up\n\t * a sun4c machine completely, so we must attempt recovery.\n\t */\n\tif(!from_user && address >= PAGE_OFFSET)\n\t\tgoto bad_area;\n\n\tfault = handle_mm_fault(mm, vma, address, write ? FAULT_FLAG_WRITE : 0);\n\tif (unlikely(fault & VM_FAULT_ERROR)) {\n\t\tif (fault & VM_FAULT_OOM)\n\t\t\tgoto out_of_memory;\n\t\telse if (fault & VM_FAULT_SIGBUS)\n\t\t\tgoto do_sigbus;\n\t\tBUG();\n\t}\n\tif (fault & VM_FAULT_MAJOR) {\n\t\tcurrent->maj_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n\t\t\t      regs, address);\n\t} else {\n\t\tcurrent->min_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n\t\t\t      regs, address);\n\t}\n\tup_read(&mm->mmap_sem);\n\treturn;\n\n\t/*\n\t * Something tried to access memory that isn't in our memory map..\n\t * Fix it, but check if it's kernel or user first..\n\t */\nbad_area:\n\tup_read(&mm->mmap_sem);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tif (!ARCH_SUN4C && address >= TASK_SIZE)\n\t\tgoto vmalloc_fault;\n\n\t/*\n\t * If we're in an interrupt or have no user\n\t * context, we must not take the fault..\n\t */\n        if (in_atomic() || !mm)\n                goto no_context;\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n\n\tdown_read(&mm->mmap_sem);\n\n\t/*\n\t * The kernel referencing a bad kernel pointer can lock up\n\t * a sun4c machine completely, so we must attempt recovery.\n\t */\n\tif(!from_user && address >= PAGE_OFFSET)\n\t\tgoto bad_area;\n\n\tfault = handle_mm_fault(mm, vma, address, write ? FAULT_FLAG_WRITE : 0);\n\tif (unlikely(fault & VM_FAULT_ERROR)) {\n\t\tif (fault & VM_FAULT_OOM)\n\t\t\tgoto out_of_memory;\n\t\telse if (fault & VM_FAULT_SIGBUS)\n\t\t\tgoto do_sigbus;\n\t\tBUG();\n\t}\n\tif (fault & VM_FAULT_MAJOR) {\n\t\tcurrent->maj_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs, address);\n\t} else {\n\t\tcurrent->min_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs, address);\n\t}\n\tup_read(&mm->mmap_sem);\n\treturn;\n\n\t/*\n\t * Something tried to access memory that isn't in our memory map..\n\t * Fix it, but check if it's kernel or user first..\n\t */\nbad_area:\n\tup_read(&mm->mmap_sem);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\treturn (EACCES);\n\n\tif (name[0] == '\\0')\n\t\tpanic(\"tdirenter: NULL name\");\n\n\t/*\n\t * For link and rename lock the source entry and check the link count\n\t * to see if it has been removed while it was unlocked.\n\t */\n\tif (op == DE_LINK || op == DE_RENAME) {\n\t\tif (tp != dir)\n\t\t\trw_enter(&tp->tn_rwlock, RW_WRITER);\n\t\tmutex_enter(&tp->tn_tlock);\n\t\tif (tp->tn_nlink == 0) {\n\t\t\tmutex_exit(&tp->tn_tlock);\n\t\t\tif (tp != dir)\n\t\t\t\trw_exit(&tp->tn_rwlock);\n\t\t\treturn (ENOENT);\n\t\t}\n\n\t\tif (tp->tn_nlink == MAXLINK) {\n\t\t\tmutex_exit(&tp->tn_tlock);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\treturn (EACCES);\n\n\tif (name[0] == '\\0')\n\t\tpanic(\"tdirenter: NULL name\");\n\n\t/*\n\t * For link and rename lock the source entry and check the link count\n\t * to see if it has been removed while it was unlocked.\n\t */\n\tif (op == DE_LINK || op == DE_RENAME) {\n\t\tif (tp != dir) {\n\t\t\tunsigned int tries = 0;\n\n\t\t\t/*\n\t\t\t * If we are acquiring tp->tn_rwlock (for SOURCE)\n\t\t\t * inside here, we must consider the following:\n\t\t\t *\n\t\t\t * - dir->tn_rwlock (TARGET) is already HELD (see\n\t\t\t * above ASSERT()).\n\t\t\t *\n\t\t\t * - It is possible our SOURCE is a parent of our\n\t\t\t * TARGET. Yes it's unusual, but it will return an\n\t\t\t * error below via tdircheckpath().\n\t\t\t *\n\t\t\t * - It is also possible that another thread,\n\t\t\t * concurrent to this one, is performing\n\t\t\t * rmdir(TARGET), which means it will first acquire\n\t\t\t * SOURCE's lock, THEN acquire TARGET's lock, which\n\t\t\t * could result in this thread holding TARGET and\n\t\t\t * trying for SOURCE, but the other thread holding\n\t\t\t * SOURCE and trying for TARGET.  This is deadlock,\n\t\t\t * and it's inducible.\n\t\t\t *\n\t\t\t * To prevent this, we borrow some techniques from UFS\n\t\t\t * and rw_tryenter(), delaying if we fail, and\n\t\t\t * if someone tweaks the number of backoff tries to be\n\t\t\t * nonzero, return EBUSY after that number of tries.\n\t\t\t */\n\t\t\twhile (!rw_tryenter(&tp->tn_rwlock, RW_WRITER)) {\n\t\t\t\t/*\n\t\t\t\t * Sloppy, but this is a diagnostic so atomic\n\t\t\t\t * increment would be overkill.\n\t\t\t\t */\n\t\t\t\ttmpfs_rename_loops++;\n\n\t\t\t\tif (tmpfs_rename_backoff_tries != 0) {\n\t\t\t\t\tif (tries > tmpfs_rename_backoff_tries)\n\t\t\t\t\t\treturn (EBUSY);\n\t\t\t\t\ttries++;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * NOTE: We're still holding dir->tn_rwlock,\n\t\t\t\t * so drop it over the delay, so any other\n\t\t\t\t * thread can get its business done.\n\t\t\t\t *\n\t\t\t\t * No state change or state inspection happens\n\t\t\t\t * prior to here, so it is not wholly dangerous\n\t\t\t\t * to release-and-reacquire dir->tn_rwlock.\n\t\t\t\t *\n\t\t\t\t * Hold the vnode of dir in case it gets\n\t\t\t\t * released by another thread, though.\n\t\t\t\t */\n\t\t\t\tVN_HOLD(TNTOV(dir));\n\t\t\t\trw_exit(&dir->tn_rwlock);\n\t\t\t\tdelay(tmpfs_rename_backoff_delay);\n\t\t\t\trw_enter(&dir->tn_rwlock, RW_WRITER);\n\t\t\t\tVN_RELE(TNTOV(dir));\n\t\t\t}\n\t\t}\n\t\tmutex_enter(&tp->tn_tlock);\n\t\tif (tp->tn_nlink == 0) {\n\t\t\tmutex_exit(&tp->tn_tlock);\n\t\t\tif (tp != dir)\n\t\t\t\trw_exit(&tp->tn_rwlock);\n\t\t\treturn (ENOENT);\n\t\t}\n\n\t\tif (tp->tn_nlink == MAXLINK) {\n\t\t\tmutex_exit(&tp->tn_tlock);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void fb_exp_basic(fb_t c, const fb_t a, const bn_t b) {\n\tint i, l;\n\tfb_t r;\n\n\tif (bn_is_zero(b)) {\n\t\tfb_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfb_null(r);\n\n\tRLC_TRY {\n\t\tfb_new(r);\n\n\t\tl = bn_bits(b);\n\n\t\tfb_copy(r, a);\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tfb_sqr(r, r);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfb_mul(r, r, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfb_inv(c, r);\n\t\t} else {\n\t\t\tfb_copy(c, r);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void fb_exp_basic(fb_t c, const fb_t a, const bn_t b) {\n\tsize_t l;\n\tfb_t r;\n\n\tif (bn_is_zero(b)) {\n\t\tfb_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfb_null(r);\n\n\tRLC_TRY {\n\t\tfb_new(r);\n\n\t\tl = bn_bits(b);\n\n\t\tfb_copy(r, a);\n\n\t\tfor (int i = l - 2; i >= 0; i--) {\n\t\t\tfb_sqr(r, r);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfb_mul(r, r, a);\n\t\t\t}\n\t\t}\n\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfb_inv(c, r);\n\t\t} else {\n\t\t\tfb_copy(c, r);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int em_jmp_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned short sel, old_sel;\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\n\t/* Assignment of RIP may only fail in 64-bit mode */\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_sel, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\n\trc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_CALL_JMP,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = assign_eip_far(ctxt, ctxt->src.val, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\t/* assigning eip failed; restore the old cs */\n\t\tops->set_segment(ctxt, old_sel, &old_desc, 0, VCPU_SREG_CS);\n\t\treturn rc;\n\t}\n\treturn rc;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int em_jmp_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned short sel;\n\tstruct desc_struct new_desc;\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\n\trc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_CALL_JMP,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = assign_eip_far(ctxt, ctxt->src.val, &new_desc);\n\t/* Error handling is not implemented. */\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\treturn rc;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static char *stibp_state(void)\n{\n\tif (spectre_v2_in_ibrs_mode(spectre_v2_enabled))\n\t\treturn \"\";\n\n\tswitch (spectre_v2_user_stibp) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\treturn \", STIBP: disabled\";\n\tcase SPECTRE_V2_USER_STRICT:\n\t\treturn \", STIBP: forced\";\n\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n\t\treturn \", STIBP: always-on\";\n\tcase SPECTRE_V2_USER_PRCTL:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static char *stibp_state(void)\n{\n\tif (spectre_v2_in_eibrs_mode(spectre_v2_enabled))\n\t\treturn \"\";\n\n\tswitch (spectre_v2_user_stibp) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\treturn \", STIBP: disabled\";\n\tcase SPECTRE_V2_USER_STRICT:\n\t\treturn \", STIBP: forced\";\n\tcase SPECTRE_V2_USER_STRICT_PREFERRED:\n\t\treturn \", STIBP: always-on\";\n\tcase SPECTRE_V2_USER_PRCTL:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int __init sit_init(void)\n{\n\tint err;\n\n\tprintk(KERN_INFO \"IPv6 over IPv4 tunneling driver\\n\");\n\n\tif (xfrm4_tunnel_register(&sit_handler, AF_INET6) < 0) {\n\t\tprintk(KERN_INFO \"sit init: Can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\terr = register_pernet_device(&sit_net_ops);\n\tif (err < 0)\n\t\txfrm4_tunnel_deregister(&sit_handler, AF_INET6);\n\n\treturn err;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int __init sit_init(void)\n{\n\tint err;\n\n\tprintk(KERN_INFO \"IPv6 over IPv4 tunneling driver\\n\");\n\n\terr = register_pernet_device(&sit_net_ops);\n\tif (err < 0)\n\t\treturn err;\n\terr = xfrm4_tunnel_register(&sit_handler, AF_INET6);\n\tif (err < 0) {\n\t\tunregister_pernet_device(&sit_net_ops);\n\t\tprintk(KERN_INFO \"sit init: Can't add protocol\\n\");\n\t}\n\treturn err;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t}\n\t\telse\n\t\t{\n\t\t\tband1 = band2;\n\t\t}\n\t}\n\twhile (TRUE);\n\n\tif (finalNbRects != nbRects)\n\t{\n\t\tint allocSize = sizeof(REGION16_DATA) + (finalNbRects * sizeof(RECTANGLE_16));\n\t\tregion->data = realloc(region->data, allocSize);\n\n\t\tif (!region->data)\n\t\t{\n\t\t\tregion->data = &empty_region;\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tregion->data->nbRects = finalNbRects;\n\t\tregion->data->size = allocSize;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t}\n\t\telse\n\t\t{\n\t\t\tband1 = band2;\n\t\t}\n\t}\n\twhile (TRUE);\n\n\tif (finalNbRects != nbRects)\n\t{\n\t\tREGION16_DATA* data;\n\t\tsize_t allocSize = sizeof(REGION16_DATA) + (finalNbRects * sizeof(RECTANGLE_16));\n\t\tdata = realloc(region->data, allocSize);\n\t\tif (!data)\n\t\t\tfree(region->data);\n\t\tregion->data = data;\n\n\t\tif (!region->data)\n\t\t{\n\t\t\tregion->data = &empty_region;\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tregion->data->nbRects = finalNbRects;\n\t\tregion->data->size = allocSize;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int ape_decode_frame(AVCodecContext *avctx, void *data,\n                            int *got_frame_ptr, AVPacket *avpkt)\n{\n    AVFrame *frame     = data;\n    const uint8_t *buf = avpkt->data;\n    APEContext *s = avctx->priv_data;\n    uint8_t *sample8;\n    int16_t *sample16;\n    int32_t *sample24;\n    int i, ch, ret;\n    int blockstodecode;\n\n    /* this should never be negative, but bad things will happen if it is, so\n       check it just to make sure. */\n    av_assert0(s->samples >= 0);\n\n    if(!s->samples){\n        uint32_t nblocks, offset;\n        int buf_size;\n\n        if (!avpkt->size) {\n            s->ptr += offset;\n        } else {\n            if ((ret = init_get_bits8(&s->gb, s->ptr, s->data_end - s->ptr)) < 0)\n                return ret;\n            if (s->fileversion > 3800)\n                skip_bits_long(&s->gb, offset * 8);\n            else\n                skip_bits_long(&s->gb, offset);\n        }\n\n        if (!nblocks || nblocks > INT_MAX) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid sample count: %\"PRIu32\".\\n\",\n                   nblocks);\n            return AVERROR_INVALIDDATA;\n        }\n\n        /* Initialize the frame decoder */\n        if (init_frame_decoder(s) < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Error reading frame header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        return avpkt->size;\n    }\n\n    blockstodecode = FFMIN(s->blocks_per_loop, s->samples);\n    // for old files coefficients were not interleaved,\n    // so we need to decode all of them at once\n    if (s->fileversion < 3930)\n        blockstodecode = s->samples;\n\n    /* reallocate decoded sample buffer if needed */\n    av_fast_malloc(&s->decoded_buffer, &s->decoded_size,\n                   2 * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer));\n    if (!s->decoded_buffer)\n        return AVERROR(ENOMEM);\n    memset(s->decoded_buffer, 0, s->decoded_size);\n    s->decoded[0] = s->decoded_buffer;\n    s->decoded[1] = s->decoded_buffer + FFALIGN(blockstodecode, 8);\n\n    /* get output buffer */\n    frame->nb_samples = blockstodecode;\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n        return ret;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "                            int *got_frame_ptr, AVPacket *avpkt)\n{\n    AVFrame *frame     = data;\n    const uint8_t *buf = avpkt->data;\n    APEContext *s = avctx->priv_data;\n    uint8_t *sample8;\n    int16_t *sample16;\n    int32_t *sample24;\n    int i, ch, ret;\n    int blockstodecode;\n    uint64_t decoded_buffer_size;\n\n    /* this should never be negative, but bad things will happen if it is, so\n       check it just to make sure. */\n    av_assert0(s->samples >= 0);\n\n    if(!s->samples){\n        uint32_t nblocks, offset;\n        int buf_size;\n\n        if (!avpkt->size) {\n            s->ptr += offset;\n        } else {\n            if ((ret = init_get_bits8(&s->gb, s->ptr, s->data_end - s->ptr)) < 0)\n                return ret;\n            if (s->fileversion > 3800)\n                skip_bits_long(&s->gb, offset * 8);\n            else\n                skip_bits_long(&s->gb, offset);\n        }\n\n        if (!nblocks || nblocks > INT_MAX / 2 / sizeof(*s->decoded_buffer) - 8) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid sample count: %\"PRIu32\".\\n\",\n                   nblocks);\n            return AVERROR_INVALIDDATA;\n        }\n\n        /* Initialize the frame decoder */\n        if (init_frame_decoder(s) < 0) {\n            av_log(avctx, AV_LOG_ERROR, \"Error reading frame header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        return avpkt->size;\n    }\n\n    blockstodecode = FFMIN(s->blocks_per_loop, s->samples);\n    // for old files coefficients were not interleaved,\n    // so we need to decode all of them at once\n    if (s->fileversion < 3930)\n        blockstodecode = s->samples;\n\n    /* reallocate decoded sample buffer if needed */\n    decoded_buffer_size = 2LL * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer);\n    av_assert0(decoded_buffer_size <= INT_MAX);\n    av_fast_malloc(&s->decoded_buffer, &s->decoded_size, decoded_buffer_size);\n    if (!s->decoded_buffer)\n        return AVERROR(ENOMEM);\n    memset(s->decoded_buffer, 0, s->decoded_size);\n    s->decoded[0] = s->decoded_buffer;\n    s->decoded[1] = s->decoded_buffer + FFALIGN(blockstodecode, 8);\n\n    /* get output buffer */\n    frame->nb_samples = blockstodecode;\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n        return ret;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int hexagon_v6_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {\n\tHexInsn hi = {0};;\n\tut32 data = 0;\n\tdata = r_read_le32 (buf);\n\tint size = hexagon_disasm_instruction (data, &hi, (ut32) addr);\n\top->size = size;\n\tif (size <= 0) {\n\t\treturn size;\n\t}\n\n\top->addr = addr;\n\treturn hexagon_anal_instruction (&hi, op);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int hexagon_v6_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {\n\tHexInsn hi = {0};\n\tut32 data = 0;\n\tif (len < 4) {\n\t\treturn 0;\n\t}\n\tdata = r_read_le32 (buf);\n\tint size = hexagon_disasm_instruction (data, &hi, (ut32) addr);\n\top->size = size;\n\tif (size <= 0) {\n\t\treturn size;\n\t}\n\n\top->addr = addr;\n\treturn hexagon_anal_instruction (&hi, op);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int simulate_sync(struct pt_regs *regs, unsigned int opcode)\n{\n\tif ((opcode & OPCODE) == SPEC0 && (opcode & FUNC) == SYNC) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, 0, regs, 0);\n\t\treturn 0;\n\t}\n\n\treturn -1;\t\t\t/* Must be something else ... */\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int simulate_sync(struct pt_regs *regs, unsigned int opcode)\n{\n\tif ((opcode & OPCODE) == SPEC0 && (opcode & FUNC) == SYNC) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, regs, 0);\n\t\treturn 0;\n\t}\n\n\treturn -1;\t\t\t/* Must be something else ... */\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tbits = 0;\n\t\tTEST_CASE(\"different forms of assignment are consistent\") {\n\t\t\tbn_set_dig(a, (dig_t)(1) << (dig_t)bits);\n\t\t\tbn_set_2b(b, bits);\n\t\t\tbits++;\n\t\t\tbits %= (RLC_DIG);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"reading and writing a positive number are consistent\") {\n\t\t\tint len = RLC_CEIL(RLC_BN_BITS, 8);\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tfor (int j = 2; j <= 64; j++) {\n\t\t\t\tbits = bn_size_str(a, j);\n\t\t\t\tbn_write_str(str, bits, a, j);\n\t\t\t\tbn_read_str(b, str, bits, j);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t\tbn_write_bin(bin, len, a);\n\t\t\tbn_read_bin(b, bin, len);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\tTEST_CASE(\"getting the size of a positive number is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tTEST_ASSERT((bn_size_str(a, 2) - 1) == bn_bits(a), end);\n\t\t\tbits = (bn_bits(a) % 8 == 0 ? bn_bits(a) / 8 : bn_bits(a) / 8 + 1);\n\t\t\tTEST_ASSERT(bn_size_bin(a) == bits, end);\n\t\t\tTEST_ASSERT(bn_size_raw(a) == a->used, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"reading and writing a negative number are consistent\") {\n\t\t\tint len = RLC_CEIL(RLC_BN_BITS, 8);\n\t\t\tbn_rand(a, RLC_NEG, RLC_BN_BITS);\n\t\t\tfor (int j = 2; j <= 64; j++) {\n\t\t\t\tbits = bn_size_str(a, j);\n\t\t\t\tbn_write_str(str, bits, a, j);\n\t\t\t\tbn_read_str(b, str, bits, j);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t\tbn_write_bin(bin, len, a);\n\t\t\tbn_read_bin(b, bin, len);\n\t\t\tbn_neg(b, b);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tbits = 0;\n\t\tTEST_CASE(\"different forms of assignment are consistent\") {\n\t\t\tbn_set_dig(a, (dig_t)(1) << (dig_t)bits);\n\t\t\tbn_set_2b(b, bits);\n\t\t\tbits++;\n\t\t\tbits %= (RLC_DIG);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"reading and writing a positive number are consistent\") {\n\t\t\tsize_t len = RLC_CEIL(RLC_BN_BITS, 8);\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tfor (int j = 2; j <= 64; j++) {\n\t\t\t\tbits = bn_size_str(a, j);\n\t\t\t\tbn_write_str(str, bits, a, j);\n\t\t\t\tbn_read_str(b, str, bits, j);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t\tbn_write_bin(bin, len, a);\n\t\t\tbn_read_bin(b, bin, len);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\tTEST_CASE(\"getting the size of a positive number is correct\") {\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tTEST_ASSERT((bn_size_str(a, 2) - 1) == bn_bits(a), end);\n\t\t\tbits = (bn_bits(a) % 8 == 0 ? bn_bits(a) / 8 : bn_bits(a) / 8 + 1);\n\t\t\tTEST_ASSERT(bn_size_bin(a) == bits, end);\n\t\t\tTEST_ASSERT(bn_size_raw(a) == a->used, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"reading and writing a negative number are consistent\") {\n\t\t\tsize_t len = RLC_CEIL(RLC_BN_BITS, 8);\n\t\t\tbn_rand(a, RLC_NEG, RLC_BN_BITS);\n\t\t\tfor (int j = 2; j <= 64; j++) {\n\t\t\t\tbits = bn_size_str(a, j);\n\t\t\t\tbn_write_str(str, bits, a, j);\n\t\t\t\tbn_read_str(b, str, bits, j);\n\t\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t\t}\n\t\t\tbn_write_bin(bin, len, a);\n\t\t\tbn_read_bin(b, bin, len);\n\t\t\tbn_neg(b, b);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t\tif (!new) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnew->type = str_type;\n\t\t\t\tnew->length = runes;\n\t\t\t\tnew->size = needle - str_start;\n\t\t\t\tnew->ordinal = count++;\n\t\t\t\t// TODO: move into adjust_offset\n\t\t\t\tswitch (str_type) {\n\t\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst ut8 *p = buf  + str_start - 2;\n\t\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\t\tstr_start -= 2; // \\xff\\xfe\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst ut8 *p = buf  + str_start - 4;\n\t\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\t\tstr_start -= 4; // \\xff\\xfe\\x00\\x00\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnew->paddr = new->vaddr = str_start;\n\t\t\t\tnew->string = r_str_ndup ((const char *)tmp, i);\n\t\t\t\tr_list_append (list, new);\n\t\t\t} else {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\t\tif (!new) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnew->type = str_type;\n\t\t\t\tnew->length = runes;\n\t\t\t\tnew->size = needle - str_start;\n\t\t\t\tnew->ordinal = count++;\n\t\t\t\t// TODO: move into adjust_offset\n\t\t\t\tswitch (str_type) {\n\t\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\t\t\tif (str_start > 1) {\n\t\t\t\t\t\tconst ut8 *p = buf + str_start - 2;\n\t\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\t\tstr_start -= 2; // \\xff\\xfe\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\t\tif (str_start > 3) {\n\t\t\t\t\t\tconst ut8 *p = buf + str_start - 4;\n\t\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\t\tstr_start -= 4; // \\xff\\xfe\\x00\\x00\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnew->paddr = new->vaddr = str_start;\n\t\t\t\tnew->string = r_str_ndup ((const char *)tmp, i);\n\t\t\t\tr_list_append (list, new);\n\t\t\t} else {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "FdInStream::FdInStream(int fd_, int timeoutms_, int bufSize_,\n                       bool closeWhenDone_)\n  : fd(fd_), closeWhenDone(closeWhenDone_),\n    timeoutms(timeoutms_), blockCallback(0),\n    timing(false), timeWaitedIn100us(5), timedKbits(0),\n    bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)\n{\n  ptr = end = start = new U8[bufSize];\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "FdInStream::FdInStream(int fd_, int timeoutms_, size_t bufSize_,\n                       bool closeWhenDone_)\n  : fd(fd_), closeWhenDone(closeWhenDone_),\n    timeoutms(timeoutms_), blockCallback(0),\n    timing(false), timeWaitedIn100us(5), timedKbits(0),\n    bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)\n{\n  ptr = end = start = new U8[bufSize];\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "asmlinkage void do_ade(struct pt_regs *regs)\n{\n\tunsigned int __user *pc;\n\tmm_segment_t seg;\n\n\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS,\n\t\t\t1, 0, regs, regs->cp0_badvaddr);\n\t/*\n\t * Did we catch a fault trying to load an instruction?\n\t * Or are we running in MIPS16 mode?\n\t */\n\tif ((regs->cp0_badvaddr == regs->cp0_epc) || (regs->cp0_epc & 0x1))\n\t\tgoto sigbus;\n\n\tpc = (unsigned int __user *) exception_epc(regs);\n\tif (user_mode(regs) && !test_thread_flag(TIF_FIXADE))\n\t\tgoto sigbus;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "asmlinkage void do_ade(struct pt_regs *regs)\n{\n\tunsigned int __user *pc;\n\tmm_segment_t seg;\n\n\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS,\n\t\t\t1, regs, regs->cp0_badvaddr);\n\t/*\n\t * Did we catch a fault trying to load an instruction?\n\t * Or are we running in MIPS16 mode?\n\t */\n\tif ((regs->cp0_badvaddr == regs->cp0_epc) || (regs->cp0_epc & 0x1))\n\t\tgoto sigbus;\n\n\tpc = (unsigned int __user *) exception_epc(regs);\n\tif (user_mode(regs) && !test_thread_flag(TIF_FIXADE))\n\t\tgoto sigbus;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "        \"<presence to='stabber@localhost' from='buddy1@localhost/mobile'>\"\n            \"<priority>10</priority>\"\n            \"<status>On my mobile</status>\"\n        \"</presence>\"\n    );\n    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"/msg Buddy1\");\n    assert_true(prof_output_exact(\"unencrypted\"));\n\n    stbbr_send(\n        \"<message type='chat' to='stabber@localhost/profanity' from='buddy1@localhost'>\"\n            \"<received xmlns='urn:xmpp:carbons:2'>\"\n                \"<forwarded xmlns='urn:xmpp:forward:0'>\"\n                    \"<message id='prof_msg_7' xmlns='jabber:client' type='chat' lang='en' to='stabber@localhost/profanity' from='buddy1@localhost/mobile'>\"\n                        \"<body>test carbon from recipient</body>\"\n                    \"</message>\"\n                \"</forwarded>\"\n            \"</received>\"\n        \"</message>\"\n    );\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "        \"<presence to='stabber@localhost' from='buddy1@localhost/mobile'>\"\n            \"<priority>10</priority>\"\n            \"<status>On my mobile</status>\"\n        \"</presence>\"\n    );\n    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"/msg Buddy1\");\n    assert_true(prof_output_exact(\"unencrypted\"));\n\n    stbbr_send(\n        \"<message type='chat' to='stabber@localhost/profanity' from='stabber@localhost'>\"\n            \"<received xmlns='urn:xmpp:carbons:2'>\"\n                \"<forwarded xmlns='urn:xmpp:forward:0'>\"\n                    \"<message id='prof_msg_7' xmlns='jabber:client' type='chat' lang='en' to='stabber@localhost/profanity' from='buddy1@localhost/mobile'>\"\n                        \"<body>test carbon from recipient</body>\"\n                    \"</message>\"\n                \"</forwarded>\"\n            \"</received>\"\n        \"</message>\"\n    );\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "find_entry_only(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n\tback_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 0/*!lock*/, txn, FE_REALLY_INTERNAL ) );\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "find_entry_only(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    back_txn *txn,\n    int *rc\n)\n{\n\treturn(find_entry_internal(pb, be, addr, 0/*!lock*/, txn, FE_REALLY_INTERNAL, rc));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void PdfXRefStreamParserObject::parseStream(const int64_t wArray[W_ARRAY_SIZE], const vector<int64_t>& indices)\n{\n    for (int64_t lengthSum = 0, i = 0; i < W_ARRAY_SIZE; i++)\n    {\n        if (wArray[i] < 0)\n        {\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef,\n                \"Negative field length in XRef stream\");\n        }\n        if (numeric_limits<int64_t>::max() - lengthSum < wArray[i])\n        {\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef,\n                \"Invalid entry length in XRef stream\");\n        }\n        else\n        {\n            lengthSum += wArray[i];\n        }\n    }\n\n    const size_t entryLen = static_cast<size_t>(wArray[0] + wArray[1] + wArray[2]);\n\n    charbuff buffer;\n    this->GetOrCreateStream().CopyTo(buffer);\n\n    vector<int64_t>::const_iterator it = indices.begin();\n    char* cursor = buffer.data();\n    while (it != indices.end())\n    {\n        int64_t firstObj = *it++;\n        int64_t count = *it++;\n\n        m_entries->Enlarge(firstObj + count);\n        for (unsigned index = 0; index < (unsigned)count; index++)\n        {\n            if ((size_t)(cursor - buffer.data()) >= buffer.size())\n                PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid count in XRef stream\");\n\n            unsigned objIndex = (unsigned)firstObj + index;\n            auto& entry = (*m_entries)[objIndex];\n            if (objIndex < m_entries->GetSize() && !entry.Parsed)\n                readXRefStreamEntry(entry, cursor, wArray);\n\n            cursor += entryLen;\n        }\n    }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void PdfXRefStreamParserObject::parseStream(const int64_t wArray[W_ARRAY_SIZE], const vector<int64_t>& indices)\n{\n    for (int64_t lengthSum = 0, i = 0; i < W_ARRAY_SIZE; i++)\n    {\n        if (wArray[i] < 0)\n        {\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream,\n                \"Negative field length in XRef stream\");\n        }\n        if (numeric_limits<int64_t>::max() - lengthSum < wArray[i])\n        {\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream,\n                \"Invalid entry length in XRef stream\");\n        }\n        else\n        {\n            lengthSum += wArray[i];\n        }\n    }\n\n    const size_t entryLen = static_cast<size_t>(wArray[0] + wArray[1] + wArray[2]);\n\n    charbuff buffer;\n    this->GetOrCreateStream().CopyTo(buffer);\n\n    vector<int64_t>::const_iterator it = indices.begin();\n    size_t offset = 0;\n    while (it != indices.end())\n    {\n        int64_t firstObj = *it++;\n        int64_t count = *it++;\n\n        if ((offset + count * entryLen) > buffer.size())\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream, \"Invalid count in XRef stream\");\n\n        m_entries->Enlarge(firstObj + count);\n        for (unsigned index = 0; index < (unsigned)count; index++)\n        {\n            unsigned objIndex = (unsigned)firstObj + index;\n            auto& entry = (*m_entries)[objIndex];\n            if (objIndex < m_entries->GetSize() && !entry.Parsed)\n                readXRefStreamEntry(entry, buffer.data() + offset, wArray);\n\n            offset += entryLen;\n        }\n    }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (**pp == NUL)\n\t    *lenp = 0;\n\tif (has_mbyte && *lenp > 0)\n\t    // Correct the length to include all bytes of the last character.\n\t    *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (**pp == NUL)\n\t    *lenp = 0;\n\tif (*lenp > 0)\n\t{\n\t    if (has_mbyte)\n\t\t// Correct the length to include all bytes of the last\n\t\t// character.\n\t\t*lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n\t    else if ((*pp)[*lenp - 1] == NUL)\n\t\t// Do not include a trailing NUL.\n\t\t*lenp -= 1;\n\t}\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    add_option= FALSE;\n    break;\n\n  case 'k':                                     /* --version-check */\n  case 'v': /* --verbose   */\n  case 'f': /* --force     */\n  case 's':                                     /* --upgrade-system-tables */\n  case OPT_WRITE_BINLOG:                        /* --write-binlog */\n    add_option= FALSE;\n    break;\n\n  case 'h': /* --host */\n  case 'W': /* --pipe */\n  case 'P': /* --port */\n  case 'S': /* --socket */\n  case OPT_MYSQL_PROTOCOL: /* --protocol */\n  case OPT_SHARED_MEMORY_BASE_NAME: /* --shared-memory-base-name */\n  case OPT_PLUGIN_DIR:                          /* --plugin-dir */\n  case OPT_DEFAULT_AUTH:                        /* --default-auth */\n    add_one_option(&conn_args, opt, argument);\n    break;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    add_option= FALSE;\n    break;\n\n  case 'k':                                     /* --version-check */\n  case 'v': /* --verbose   */\n  case 'f': /* --force     */\n  case 's':                                     /* --upgrade-system-tables */\n  case OPT_WRITE_BINLOG:                        /* --write-binlog */\n    add_option= FALSE;\n    break;\n#include <sslopt-case.h>\n  case 'h': /* --host */\n  case 'W': /* --pipe */\n  case 'P': /* --port */\n  case 'S': /* --socket */\n  case OPT_MYSQL_PROTOCOL: /* --protocol */\n  case OPT_SHARED_MEMORY_BASE_NAME: /* --shared-memory-base-name */\n  case OPT_PLUGIN_DIR:                          /* --plugin-dir */\n  case OPT_DEFAULT_AUTH:                        /* --default-auth */\n    add_one_option(&conn_args, opt, argument);\n    break;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tbreak;\n\tcase SMB2_SET_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_set_info_req *)hdr)->BufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_set_info_req *)hdr)->BufferLength);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\t*off = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_WRITE:\n\t\tif (((struct smb2_write_req *)hdr)->DataOffset) {\n\t\t\t*off = le16_to_cpu(((struct smb2_write_req *)hdr)->DataOffset);\n\t\t\t*len = le32_to_cpu(((struct smb2_write_req *)hdr)->Length);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\t*off = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameOffset);\n\t\t*len = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameLength);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tbreak;\n\tcase SMB2_SET_INFO:\n\t\t*off = le16_to_cpu(((struct smb2_set_info_req *)hdr)->BufferOffset);\n\t\t*len = le32_to_cpu(((struct smb2_set_info_req *)hdr)->BufferLength);\n\t\tbreak;\n\tcase SMB2_READ:\n\t\t*off = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_WRITE:\n\t\tif (((struct smb2_write_req *)hdr)->DataOffset ||\n\t\t    ((struct smb2_write_req *)hdr)->Length) {\n\t\t\t*off = max_t(unsigned int,\n\t\t\t\t     le16_to_cpu(((struct smb2_write_req *)hdr)->DataOffset),\n\t\t\t\t     offsetof(struct smb2_write_req, Buffer));\n\t\t\t*len = le32_to_cpu(((struct smb2_write_req *)hdr)->Length);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_QUERY_DIRECTORY:\n\t\t*off = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameOffset);\n\t\t*len = le16_to_cpu(((struct smb2_query_directory_req *)hdr)->FileNameLength);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "          result += skip(prot, elemType);\n        }\n      } else {\n        while (prot.peekList()) {\n          result += skip(prot, elemType);\n        }\n      }\n      result += prot.readListEnd();\n      return result;\n    }\n    default:\n      return 0;\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "          result += skip(prot, elemType);\n        }\n      } else {\n        while (prot.peekList()) {\n          result += skip(prot, elemType);\n        }\n      }\n      result += prot.readListEnd();\n      return result;\n    }\n    default: {\n      TProtocolException::throwInvalidSkipType(arg_type);\n    }\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "      fi->filename = (char *) &fi[1];\n      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)\n                                     : (struct mschmd_section *) (&chm->sec1));\n      fi->offset   = offset;\n      fi->length   = length;\n      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n        /* system file */\n        if (memcmp(&name[2], &content_name[2], 31L) == 0) {\n          if (memcmp(&name[33], &content_name[33], 8L) == 0) {\n            chm->sec1.content = fi;\n          }\n          else if (memcmp(&name[33], &control_name[33], 11L) == 0) {\n            chm->sec1.control = fi;\n          }\n          else if (memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {\n            chm->sec1.spaninfo = fi;\n          }\n          else if (memcmp(&name[33], &rtable_name[33], 72L) == 0) {\n            chm->sec1.rtable = fi;\n          }\n        }\n        fi->next = chm->sysfiles;\n        chm->sysfiles = fi;\n      }\n      else {\n        /* normal file */\n        if (link) link->next = fi; else chm->files = fi;\n        link = fi;\n      }\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "      fi->filename = (char *) &fi[1];\n      fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0)\n                                     : (struct mschmd_section *) (&chm->sec1));\n      fi->offset   = offset;\n      fi->length   = length;\n      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n        /* system file */\n        if (name_len == 40 && memcmp(name, content_name, 40) == 0) {\n          chm->sec1.content = fi;\n        }\n        else if (name_len == 44 && memcmp(name, control_name, 44) == 0) {\n          chm->sec1.control = fi;\n        }\n        else if (name_len == 41 && memcmp(name, spaninfo_name, 41) == 0) {\n          chm->sec1.spaninfo = fi;\n        }\n        else if (name_len == 105 && memcmp(name, rtable_name, 105) == 0) {\n          chm->sec1.rtable = fi;\n        }\n        fi->next = chm->sysfiles;\n        chm->sysfiles = fi;\n      }\n      else {\n        /* normal file */\n        if (link) link->next = fi; else chm->files = fi;\n        link = fi;\n      }\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int bn_size_bin(const bn_t a) {\n\tdig_t d;\n\tint digits;\n\n\tdigits = (a->used - 1) * (RLC_DIG / 8);\n\td = a->dp[a->used - 1];\n\n\twhile (d != 0) {\n\t\td = d >> 8;\n\t\tdigits++;\n\t}\n\treturn digits;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "size_t bn_size_bin(const bn_t a) {\n\tdig_t d;\n\tint digits;\n\n\tdigits = (a->used - 1) * (RLC_DIG / 8);\n\td = a->dp[a->used - 1];\n\n\twhile (d != 0) {\n\t\td = d >> 8;\n\t\tdigits++;\n\t}\n\treturn digits;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "DSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,\n                                  RandomNumberGenerator& rng)\n   {\n   const BigInt& q = m_group.get_q();\n\n   BigInt i(msg, msg_len, q.bits());\n\n   while(i >= q)\n      i -= q;\n\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n   BOTAN_UNUSED(rng);\n   const BigInt k = generate_rfc6979_nonce(m_x, q, i, m_rfc6979_hash);\n#else\n   const BigInt k = BigInt::random_integer(rng, 1, q);\n#endif\n\n   BigInt s = inverse_mod(k, q);\n   const BigInt r = m_mod_q.reduce(m_group.power_g_p(k));\n\n   s = m_mod_q.multiply(s, mul_add(m_x, r, i));\n\n   // With overwhelming probability, a bug rather than actual zero r/s\n   if(r.is_zero() || s.is_zero())\n      throw Internal_Error(\"Computed zero r/s during DSA signature\");\n\n   return BigInt::encode_fixed_length_int_pair(r, s, q.bytes());\n   }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "DSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,\n                                  RandomNumberGenerator& rng)\n   {\n   const BigInt& q = m_group.get_q();\n\n   BigInt m(msg, msg_len, q.bits());\n\n   while(m >= q)\n      m -= q;\n\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n   BOTAN_UNUSED(rng);\n   const BigInt k = generate_rfc6979_nonce(m_x, q, m, m_rfc6979_hash);\n#else\n   const BigInt k = BigInt::random_integer(rng, 1, q);\n#endif\n\n   const BigInt k_inv = inverse_mod(k, q);\n\n   const BigInt r = m_mod_q.reduce(m_group.power_g_p(k));\n\n   /*\n   * Blind the input message and compute x*r+m as (x*r*b + m*b)/b\n   */\n   m_b = m_mod_q.square(m_b);\n   m_b_inv = m_mod_q.square(m_b_inv);\n\n   m = m_mod_q.multiply(m_b, m);\n   const BigInt xr = m_mod_q.multiply(m_mod_q.multiply(m_x, m_b), r);\n\n   const BigInt s = m_mod_q.multiply(m_b_inv, m_mod_q.multiply(k_inv, xr + m));\n\n   // With overwhelming probability, a bug rather than actual zero r/s\n   if(r.is_zero() || s.is_zero())\n      throw Internal_Error(\"Computed zero r/s during DSA signature\");\n\n   return BigInt::encode_fixed_length_int_pair(r, s, q.bytes());\n   }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "String string_chunk_split(const char *src, int srclen, const char *end,\n                          int endlen, int chunklen) {\n  int chunks = srclen / chunklen; // complete chunks!\n  int restlen = srclen - chunks * chunklen; /* srclen % chunklen */\n\n  int out_len = (chunks + 1) * endlen + srclen;\n  String ret(out_len, ReserveString);\n  char *dest = ret.bufferSlice().ptr;\n\n  const char *p; char *q;\n  const char *pMax = src + srclen - chunklen + 1;\n  for (p = src, q = dest; p < pMax; ) {\n    memcpy(q, p, chunklen);\n    q += chunklen;\n    memcpy(q, end, endlen);\n    q += endlen;\n    p += chunklen;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "String string_chunk_split(const char *src, int srclen, const char *end,\n                          int endlen, int chunklen) {\n  int chunks = srclen / chunklen; // complete chunks!\n  int restlen = srclen - chunks * chunklen; /* srclen % chunklen */\n\n  String ret(\n    safe_address(\n      chunks + 1,\n      endlen,\n      srclen\n    ),\n    ReserveString\n  );\n  char *dest = ret.bufferSlice().ptr;\n\n  const char *p; char *q;\n  const char *pMax = src + srclen - chunklen + 1;\n  for (p = src, q = dest; p < pMax; ) {\n    memcpy(q, p, chunklen);\n    q += chunklen;\n    memcpy(q, end, endlen);\n    q += endlen;\n    p += chunklen;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\tif (sk_hashed(sk)) {\n\t\twrite_lock_bh(&ping_table.lock);\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsk_nulls_node_init(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t\twrite_unlock_bh(&ping_table.lock);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\twrite_lock_bh(&ping_table.lock);\n\tif (sk_hashed(sk)) {\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsk_nulls_node_init(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t}\n\twrite_unlock_bh(&ping_table.lock);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "l2tp_ppp_discon_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tND_PRINT((ndo, \"%04x, \", EXTRACT_16BITS(ptr))); ptr++;\t/* Disconnect Code */\n\tND_PRINT((ndo, \"%04x \",  EXTRACT_16BITS(ptr))); ptr++;\t/* Control Protocol Number */\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_cc_direction2str,\n\t\t\t     \"Direction-#%u\", *((const u_char *)ptr++))));\n\n\tif (length > 5) {\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, (const u_char *)ptr, length-5);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "l2tp_ppp_discon_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tif (length < 5) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\t/* Disconnect Code */\n\tND_PRINT((ndo, \"%04x, \", EXTRACT_16BITS(dat)));\n\tdat += 2;\n\tlength -= 2;\n\t/* Control Protocol Number */\n\tND_PRINT((ndo, \"%04x \",  EXTRACT_16BITS(dat)));\n\tdat += 2;\n\tlength -= 2;\n\t/* Direction */\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_cc_direction2str,\n\t\t\t     \"Direction-#%u\", EXTRACT_8BITS(ptr))));\n\tptr++;\n\tlength--;\n\n\tif (length != 0) {\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, (const u_char *)ptr, length);\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    in.setFrameBuffer (ComputeBasePointer (&pixels[0][0], dw), 1, w);\n    in.readPixels (dw.min.y, dw.max.y);\n\n    //\n    // Make a preview image\n    //\n\n    previewHeight = max (int (h / (w * a) * previewWidth + .5f), 1);\n    previewPixels.resizeErase (previewHeight, previewWidth);\n\n    float fx = (previewWidth  > 0)? (float (w - 1) / (previewWidth  - 1)): 1;\n    float fy = (previewHeight > 0)? (float (h - 1) / (previewHeight - 1)): 1;\n    float m  = Math<float>::pow (2.f, IMATH_NAMESPACE::clamp (exposure + 2.47393f, -20.f, 20.f));\n\n    for (int y = 0; y < previewHeight; ++y)\n    {\n\tfor (int x = 0; x < previewWidth; ++x)\n\t{\n\t    PreviewRgba &preview = previewPixels[y][x];\n\t    const Rgba &pixel = pixels[int (y * fy + .5f)][int (x * fx + .5f)];\n\n\t    preview.r = gamma (pixel.r, m);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    in.setFrameBuffer (ComputeBasePointer (&pixels[0][0], dw), 1, w);\n    in.readPixels (dw.min.y, dw.max.y);\n\n    //\n    // Make a preview image\n    //\n\n    previewHeight = max (int (h / (w * a) * previewWidth + .5f), 1);\n    previewPixels.resizeErase (previewHeight, previewWidth);\n\n    float fx = (previewWidth  > 1)? (float (w - 1) / (previewWidth  - 1)): 1;\n    float fy = (previewHeight > 1)? (float (h - 1) / (previewHeight - 1)): 1;\n    float m  = Math<float>::pow (2.f, IMATH_NAMESPACE::clamp (exposure + 2.47393f, -20.f, 20.f));\n\n    for (int y = 0; y < previewHeight; ++y)\n    {\n\tfor (int x = 0; x < previewWidth; ++x)\n\t{\n\t    PreviewRgba &preview = previewPixels[y][x];\n\t    const Rgba &pixel = pixels[int (y * fy + .5f)][int (x * fx + .5f)];\n\n\t    preview.r = gamma (pixel.r, m);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela, ++relnum) {\n        unsigned const symnum = get_te64(&rela->r_info) >> 32;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \"__libc_start_main\")  // glibc\n        ||  0==strcmp(symnam, \"__libc_init\")  // Android\n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)\n{\n    if (!dynsym || !dynstr || !rela) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela, ++relnum) {\n        unsigned const symnum = get_te64(&rela->r_info) >> 32;\n        char const *const symnam = get_dynsym_name(symnum, relnum);\n        if (0==strcmp(symnam, \"__libc_start_main\")  // glibc\n        ||  0==strcmp(symnam, \"__libc_init\")  // Android\n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t}\n\n        /* print operation */\n        ND_PRINT((ndo, \"%s%s \",\n               ndo->ndo_vflag ? \", \" : \"\",\n               tok2str(arpop_values, \"Unknown (%u)\", op)));\n\n\tswitch (op) {\n\n\tcase ARPOP_REQUEST:\n\t\tND_PRINT((ndo, \"who-has %s\", ipaddr_string(ndo, ATMTPA(ap))));\n\t\tif (ATMTHRD_LEN(ap) != 0) {\n\t\t\tND_PRINT((ndo, \" (\"));\n\t\t\tatmarp_addr_print(ndo, ATMTHA(ap), ATMTHRD_LEN(ap),\n\t\t\t    ATMTSA(ap), ATMTSLN(ap));\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t}\n\t\tND_PRINT((ndo, \"tell %s\", ipaddr_string(ndo, ATMSPA(ap))));\n\t\tbreak;\n\n\tcase ARPOP_REPLY:\n\t\tND_PRINT((ndo, \"%s is-at \", ipaddr_string(ndo, ATMSPA(ap))));\n\t\tatmarp_addr_print(ndo, ATMSHA(ap), ATMSHRD_LEN(ap), ATMSSA(ap),\n                                  ATMSSLN(ap));\n\t\tbreak;\n\n\tcase ARPOP_INVREQUEST:\n\t\tND_PRINT((ndo, \"who-is \"));\n\t\tatmarp_addr_print(ndo, ATMTHA(ap), ATMTHRD_LEN(ap), ATMTSA(ap),\n\t\t    ATMTSLN(ap));\n\t\tND_PRINT((ndo, \" tell \"));\n\t\tatmarp_addr_print(ndo, ATMSHA(ap), ATMSHRD_LEN(ap), ATMSSA(ap),\n\t\t    ATMSSLN(ap));\n\t\tbreak;\n\n\tcase ARPOP_INVREPLY:\n\t\tatmarp_addr_print(ndo, ATMSHA(ap), ATMSHRD_LEN(ap), ATMSSA(ap),\n\t\t    ATMSSLN(ap));\n\t\tND_PRINT((ndo, \"at %s\", ipaddr_string(ndo, ATMSPA(ap))));\n\t\tbreak;\n\n\tcase ARPOP_NAK:\n\t\tND_PRINT((ndo, \"for %s\", ipaddr_string(ndo, ATMSPA(ap))));\n\t\tbreak;\n\n\tdefault:\n\t\tND_DEFAULTPRINT((const u_char *)ap, caplen);\n\t\treturn;\n\t}\n\n out:\n        ND_PRINT((ndo, \", length %u\", length));\n        return;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t}\n\n        /* print operation */\n        ND_PRINT((ndo, \"%s%s \",\n               ndo->ndo_vflag ? \", \" : \"\",\n               tok2str(arpop_values, \"Unknown (%u)\", op)));\n\n\tswitch (op) {\n\n\tcase ARPOP_REQUEST:\n\t\tND_PRINT((ndo, \"who-has \"));\n\t\tatmarp_tpaddr_print(ndo, ap, pro);\n\t\tif (ATMTHRD_LEN(ap) != 0) {\n\t\t\tND_PRINT((ndo, \" (\"));\n\t\t\tatmarp_addr_print(ndo, ATMTHA(ap), ATMTHRD_LEN(ap),\n\t\t\t    ATMTSA(ap), ATMTSLN(ap));\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t}\n\t\tND_PRINT((ndo, \" tell \"));\n\t\tatmarp_spaddr_print(ndo, ap, pro);\n\t\tbreak;\n\n\tcase ARPOP_REPLY:\n\t\tatmarp_spaddr_print(ndo, ap, pro);\n\t\tND_PRINT((ndo, \" is-at \"));\n\t\tatmarp_addr_print(ndo, ATMSHA(ap), ATMSHRD_LEN(ap), ATMSSA(ap),\n                                  ATMSSLN(ap));\n\t\tbreak;\n\n\tcase ARPOP_INVREQUEST:\n\t\tND_PRINT((ndo, \"who-is \"));\n\t\tatmarp_addr_print(ndo, ATMTHA(ap), ATMTHRD_LEN(ap), ATMTSA(ap),\n\t\t    ATMTSLN(ap));\n\t\tND_PRINT((ndo, \" tell \"));\n\t\tatmarp_addr_print(ndo, ATMSHA(ap), ATMSHRD_LEN(ap), ATMSSA(ap),\n\t\t    ATMSSLN(ap));\n\t\tbreak;\n\n\tcase ARPOP_INVREPLY:\n\t\tatmarp_addr_print(ndo, ATMSHA(ap), ATMSHRD_LEN(ap), ATMSSA(ap),\n\t\t    ATMSSLN(ap));\n\t\tND_PRINT((ndo, \"at \"));\n\t\tatmarp_spaddr_print(ndo, ap, pro);\n\t\tbreak;\n\n\tcase ARPOP_NAK:\n\t\tND_PRINT((ndo, \"for \"));\n\t\tatmarp_spaddr_print(ndo, ap, pro);\n\t\tbreak;\n\n\tdefault:\n\t\tND_DEFAULTPRINT((const u_char *)ap, caplen);\n\t\treturn;\n\t}\n\n out:\n        ND_PRINT((ndo, \", length %u\", length));\n        return;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tif ((uri.hostname != NULL)\n\t\t\t&& ((strstr(c_host, uri.hostname) == NULL)\n\t\t\t\t\t|| (strstr(uri.hostname, c_host) == NULL))) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t} else if (strstr(url, \"/\") != url) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"No hostname was parsed and it does not seem to be relative, i.e starting with '/': %s\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\n\t/* validate the URL to prevent HTTP header splitting */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tif ((uri.hostname != NULL)\n\t\t\t&& ((strstr(c_host, uri.hostname) == NULL)\n\t\t\t\t\t|| (strstr(uri.hostname, c_host) == NULL))) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Invalid Request\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t} else if ((uri.hostname == NULL) && (strstr(url, \"/\") != url)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"No hostname was parsed and it does not seem to be relative, i.e starting with '/': %s\",\n\t\t\t\t\t\turl);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t}\n\n\t/* validate the URL to prevent HTTP header splitting */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int read_header(FFV1Context *f)\n{\n    uint8_t state[CONTEXT_SIZE];\n    int i, j, context_count = -1; //-1 to avoid warning\n    RangeCoder *const c = &f->slice_context[0]->c;\n\n    memset(state, 128, sizeof(state));\n\n    if (f->version < 2) {\n        int chroma_planes, chroma_h_shift, chroma_v_shift, transparency;\n        unsigned v= get_symbol(c, state, 0);\n        if (v >= 2) {\n            av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);\n            return AVERROR_INVALIDDATA;\n        }\n        f->version = v;\n        f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);\n        if (f->ac > 1) {\n            for (i = 1; i < 256; i++)\n                f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];\n        }\n\n        f->colorspace = get_symbol(c, state, 0); //YUV cs type\n\n        if (f->version > 0)\n            f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);\n\n        chroma_planes  = get_rac(c, state);\n        chroma_h_shift = get_symbol(c, state, 0);\n        chroma_v_shift = get_symbol(c, state, 0);\n        transparency   = get_rac(c, state);\n\n        if (f->plane_count) {\n            if (   chroma_planes != f->chroma_planes\n                || chroma_h_shift!= f->chroma_h_shift\n                || chroma_v_shift!= f->chroma_v_shift\n                || transparency  != f->transparency) {\n                av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        f->chroma_planes  = chroma_planes;\n        f->chroma_h_shift = chroma_h_shift;\n        f->chroma_v_shift = chroma_v_shift;\n        f->transparency   = transparency;\n\n        f->plane_count    = 2 + f->transparency;\n    }\n\n    if (f->colorspace == 0) {\n        if (!f->transparency && !f->chroma_planes) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int read_header(FFV1Context *f)\n{\n    uint8_t state[CONTEXT_SIZE];\n    int i, j, context_count = -1; //-1 to avoid warning\n    RangeCoder *const c = &f->slice_context[0]->c;\n\n    memset(state, 128, sizeof(state));\n\n    if (f->version < 2) {\n        int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;\n        unsigned v= get_symbol(c, state, 0);\n        if (v >= 2) {\n            av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);\n            return AVERROR_INVALIDDATA;\n        }\n        f->version = v;\n        f->ac      = f->avctx->coder_type = get_symbol(c, state, 0);\n        if (f->ac > 1) {\n            for (i = 1; i < 256; i++)\n                f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];\n        }\n\n        colorspace     = get_symbol(c, state, 0); //YUV cs type\n        bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;\n        chroma_planes  = get_rac(c, state);\n        chroma_h_shift = get_symbol(c, state, 0);\n        chroma_v_shift = get_symbol(c, state, 0);\n        transparency   = get_rac(c, state);\n\n        if (f->plane_count) {\n            if (   colorspace    != f->colorspace\n                || bits_per_raw_sample != f->avctx->bits_per_raw_sample\n                || chroma_planes != f->chroma_planes\n                || chroma_h_shift!= f->chroma_h_shift\n                || chroma_v_shift!= f->chroma_v_shift\n                || transparency  != f->transparency) {\n                av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        f->colorspace     = colorspace;\n        f->avctx->bits_per_raw_sample = bits_per_raw_sample;\n        f->chroma_planes  = chroma_planes;\n        f->chroma_h_shift = chroma_h_shift;\n        f->chroma_v_shift = chroma_v_shift;\n        f->transparency   = transparency;\n\n        f->plane_count    = 2 + f->transparency;\n    }\n\n    if (f->colorspace == 0) {\n        if (!f->transparency && !f->chroma_planes) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  // header, and for http/https backends the X-Cloud-Trace-Context header.\n\n  std::string trace_context_header = cloud_trace()->ToTraceContextHeader(\n      backend_span_->trace_span()->span_id());\n\n  // Set trace context header to backend.\n  Status status = request()->AddHeaderToBackend(\n      cloud_trace()->header_type() == HeaderType::CLOUD_TRACE_CONTEXT\n          ? kCloudTraceContextHeader\n          : kGRpcTraceContextHeader,\n      trace_context_header);\n  if (!status.ok()) {\n    service_context()->env()->LogError(\n        \"Failed to set trace context header to backend.\");\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  // header, and for http/https backends the X-Cloud-Trace-Context header.\n\n  std::string trace_context_header = cloud_trace()->ToTraceContextHeader(\n      backend_span_->trace_span()->span_id());\n\n  // Set trace context header to backend.\n  Status status = request()->AddHeaderToBackend(\n      cloud_trace()->header_type() == HeaderType::CLOUD_TRACE_CONTEXT\n          ? kCloudTraceContextHeader\n          : kGRpcTraceContextHeader,\n      trace_context_header, false);\n  if (!status.ok()) {\n    service_context()->env()->LogError(\n        \"Failed to set trace context header to backend.\");\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void HTML_put_string(HTStructured * me, const char *s)\n{\n#ifdef USE_PRETTYSRC\n    char *translated_string = NULL;\n#endif\n\n    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))\n\treturn;\n#ifdef USE_PRETTYSRC\n    if (psrc_convert_string) {\n\tStrAllocCopy(translated_string, s);\n\tTRANSLATE_AND_UNESCAPE_ENTITIES(&translated_string, TRUE, FALSE);\n\ts = (const char *) translated_string;\n    }\n#endif\n\n    switch (me->sp[0].tag_number) {\n\n    case HTML_COMMENT:\n\tbreak;\t\t\t/* Do Nothing */\n\n    case HTML_TITLE:\n\tHTChunkPuts(&me->title, s);\n\tbreak;\n\n    case HTML_STYLE:\n\tHTChunkPuts(&me->style_block, s);\n\tbreak;\n\n    case HTML_SCRIPT:\n\tHTChunkPuts(&me->script, s);\n\tbreak;\n\n    case HTML_PRE:\t\t/* Formatted text */\n    case HTML_LISTING:\t\t/* Literal text */\n    case HTML_XMP:\n    case HTML_PLAINTEXT:\n\t/*\n\t * We guarantee that the style is up-to-date in begin_litteral\n\t */\n\tHText_appendText(me->text, s);\n\tbreak;\n\n    case HTML_OBJECT:\n\tHTChunkPuts(&me->object, s);\n\tbreak;\n\n    case HTML_TEXTAREA:\n\tHTChunkPuts(&me->textarea, s);\n\tbreak;\n\n    case HTML_SELECT:\n    case HTML_OPTION:\n\tHTChunkPuts(&me->option, s);\n\tbreak;\n\n    case HTML_MATH:\n\tHTChunkPuts(&me->math, s);\n\tbreak;\n\n    default:\t\t\t/* Free format text? */\n\tif (!me->sp->style->freeFormat) {\n\t    /*\n\t     * If we are within a preformatted text style not caught by the\n\t     * cases above (HTML_PRE or similar may not be the last element\n\t     * pushed on the style stack).  - kw\n\t     */\n#ifdef USE_PRETTYSRC\n\t\t     * separator, if there was one.  So we set LastChar to a\n\t\t     * generic separator.\n\t\t     */\n\t\t    HText_setLastChar(me->text, ' ');\n\t\t} else {\n\t\t    HText_setLastChar(me->text, c);\n\t\t}\n\n\t    }\t\t\t/* for */\n\t}\n    }\t\t\t\t/* end switch */\n#ifdef USE_PRETTYSRC\n    if (psrc_convert_string) {\n\tpsrc_convert_string = FALSE;\n\tFREE(translated_string);\n    }\n#endif\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void HTML_put_string(HTStructured * me, const char *s)\n{\n    HTChunk *target = NULL;\n\n#ifdef USE_PRETTYSRC\n    char *translated_string = NULL;\n#endif\n\n    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))\n\treturn;\n#ifdef USE_PRETTYSRC\n    if (psrc_convert_string) {\n\tStrAllocCopy(translated_string, s);\n\tTRANSLATE_AND_UNESCAPE_ENTITIES(&translated_string, TRUE, FALSE);\n\ts = (const char *) translated_string;\n    }\n#endif\n\n    switch (me->sp[0].tag_number) {\n\n    case HTML_COMMENT:\n\tbreak;\t\t\t/* Do Nothing */\n\n    case HTML_TITLE:\n\ttarget = &me->title;\n\tbreak;\n\n    case HTML_STYLE:\n\ttarget = &me->style_block;\n\tbreak;\n\n    case HTML_SCRIPT:\n\ttarget = &me->script;\n\tbreak;\n\n    case HTML_PRE:\t\t/* Formatted text */\n    case HTML_LISTING:\t\t/* Literal text */\n    case HTML_XMP:\n    case HTML_PLAINTEXT:\n\t/*\n\t * We guarantee that the style is up-to-date in begin_litteral\n\t */\n\tHText_appendText(me->text, s);\n\tbreak;\n\n    case HTML_OBJECT:\n\ttarget = &me->object;\n\tbreak;\n\n    case HTML_TEXTAREA:\n\ttarget = &me->textarea;\n\tbreak;\n\n    case HTML_SELECT:\n    case HTML_OPTION:\n\ttarget = &me->option;\n\tbreak;\n\n    case HTML_MATH:\n\ttarget = &me->math;\n\tbreak;\n\n    default:\t\t\t/* Free format text? */\n\tif (!me->sp->style->freeFormat) {\n\t    /*\n\t     * If we are within a preformatted text style not caught by the\n\t     * cases above (HTML_PRE or similar may not be the last element\n\t     * pushed on the style stack).  - kw\n\t     */\n#ifdef USE_PRETTYSRC\n\t\t     * generic separator.\n\t\t     */\n\t\t    HText_setLastChar(me->text, ' ');\n\t\t} else {\n\t\t    HText_setLastChar(me->text, c);\n\t\t}\n\n\t    }\t\t\t/* for */\n\t}\n    }\t\t\t\t/* end switch */\n\n    if (target != NULL) {\n\tif (target->data == s) {\n\t    CTRACE((tfp, \"BUG: appending chunk to itself: `%.*s'\\n\",\n\t\t    target->size, target->data));\n\t} else {\n\t    HTChunkPuts(target, s);\n\t}\n    }\n#ifdef USE_PRETTYSRC\n    if (psrc_convert_string) {\n\tpsrc_convert_string = FALSE;\n\tFREE(translated_string);\n    }\n#endif\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "ip_printts(netdissect_options *ndo,\n           register const u_char *cp, u_int length)\n{\n\tregister u_int ptr;\n\tregister u_int len;\n\tint hoplen;\n\tconst char *type;\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"[bad length %u]\", length));\n\t\treturn;\n\t}\n\tND_PRINT((ndo, \" TS{\"));\n\thoplen = ((cp[3]&0xF) != IPOPT_TS_TSONLY) ? 8 : 4;\n\tif ((length - 4) & (hoplen-1))\n\t\tND_PRINT((ndo, \"[bad length %u]\", length));\n\tptr = cp[2] - 1;\n\tlen = 0;\n\tif (ptr < 4 || ((ptr - 4) & (hoplen-1)) || ptr > length + 1)\n\t\tND_PRINT((ndo, \"[bad ptr %u]\", cp[2]));\n\tswitch (cp[3]&0xF) {\n\tcase IPOPT_TS_TSONLY:\n\t\tND_PRINT((ndo, \"TSONLY\"));\n\t\tbreak;\n\tcase IPOPT_TS_TSANDADDR:\n\t\tND_PRINT((ndo, \"TS+ADDR\"));\n\t\tbreak;\n\t/*\n\t * prespecified should really be 3, but some ones might send 2\n\t * instead, and the IPOPT_TS_PRESPEC constant can apparently\n\t\tND_PRINT((ndo, \"PRESPEC\"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"[bad ts type %d]\", cp[3]&0xF));\n\t\tgoto done;\n\t}\n\n\ttype = \" \";\n\tfor (len = 4; len < length; len += hoplen) {\n\t\tif (ptr == len)\n\t\t\ttype = \" ^ \";\n\t\tND_PRINT((ndo, \"%s%d@%s\", type, EXTRACT_32BITS(&cp[len+hoplen-4]),\n\t\t       hoplen!=8 ? \"\" : ipaddr_string(ndo, &cp[len])));\n\t\ttype = \" \";\n\t}\n\ndone:\n\tND_PRINT((ndo, \"%s\", ptr == len ? \" ^ \" : \"\"));\n\n\tif (cp[3]>>4)\n\t\tND_PRINT((ndo, \" [%d hops not recorded]} \", cp[3]>>4));\n\telse\n\t\tND_PRINT((ndo, \"}\"));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "ip_printts(netdissect_options *ndo,\n           register const u_char *cp, u_int length)\n{\n\tregister u_int ptr;\n\tregister u_int len;\n\tint hoplen;\n\tconst char *type;\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"[bad length %u]\", length));\n\t\treturn (0);\n\t}\n\tND_PRINT((ndo, \" TS{\"));\n\thoplen = ((cp[3]&0xF) != IPOPT_TS_TSONLY) ? 8 : 4;\n\tif ((length - 4) & (hoplen-1))\n\t\tND_PRINT((ndo, \"[bad length %u]\", length));\n\tND_TCHECK(cp[2]);\n\tptr = cp[2] - 1;\n\tlen = 0;\n\tif (ptr < 4 || ((ptr - 4) & (hoplen-1)) || ptr > length + 1)\n\t\tND_PRINT((ndo, \"[bad ptr %u]\", cp[2]));\n\tND_TCHECK(cp[3]);\n\tswitch (cp[3]&0xF) {\n\tcase IPOPT_TS_TSONLY:\n\t\tND_PRINT((ndo, \"TSONLY\"));\n\t\tbreak;\n\tcase IPOPT_TS_TSANDADDR:\n\t\tND_PRINT((ndo, \"TS+ADDR\"));\n\t\tbreak;\n\t/*\n\t * prespecified should really be 3, but some ones might send 2\n\t * instead, and the IPOPT_TS_PRESPEC constant can apparently\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \"[bad ts type %d]\", cp[3]&0xF));\n\t\tgoto done;\n\t}\n\n\ttype = \" \";\n\tfor (len = 4; len < length; len += hoplen) {\n\t\tif (ptr == len)\n\t\t\ttype = \" ^ \";\n\t\tND_TCHECK2(cp[len], hoplen);\n\t\tND_PRINT((ndo, \"%s%d@%s\", type, EXTRACT_32BITS(&cp[len+hoplen-4]),\n\t\t       hoplen!=8 ? \"\" : ipaddr_string(ndo, &cp[len])));\n\t\ttype = \" \";\n\t}\n\ndone:\n\tND_PRINT((ndo, \"%s\", ptr == len ? \" ^ \" : \"\"));\n\n\tif (cp[3]>>4)\n\t\tND_PRINT((ndo, \" [%d hops not recorded]} \", cp[3]>>4));\n\telse\n\t\tND_PRINT((ndo, \"}\"));\n\treturn (0);\n\ntrunc:\n\treturn (-1);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void ion_free(struct ion_client *client, struct ion_handle *handle)\n{\n\tbool valid_handle;\n\n\tBUG_ON(client != handle->client);\n\n\tmutex_lock(&client->lock);\n\tvalid_handle = ion_handle_validate(client, handle);\n\n\tif (!valid_handle) {\n\t\tWARN(1, \"%s: invalid handle passed to free.\\n\", __func__);\n\t\tmutex_unlock(&client->lock);\n\t\treturn;\n\t}\n\tmutex_unlock(&client->lock);\n\tion_handle_put(handle);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void ion_free(struct ion_client *client, struct ion_handle *handle)\n{\n\tBUG_ON(client != handle->client);\n\n\tmutex_lock(&client->lock);\n\tion_free_nolock(client, handle);\n\tmutex_unlock(&client->lock);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t\tif (!sps->vui.pic_struct_present_flag) {\n\t\t\t\t\tDeltaTfiDivisorIdx = 1 + (1 - ctx->avc_state->s_info.field_pic_flag);\n\t\t\t\t} else {\n\t\t\t\t\tif (!ctx->avc_state->sei.pic_timing.pic_struct)\n\t\t\t\t\t\tDeltaTfiDivisorIdx = 2;\n\t\t\t\t\telse if (ctx->avc_state->sei.pic_timing.pic_struct == 8)\n\t\t\t\t\t\tDeltaTfiDivisorIdx = 6;\n\t\t\t\t\telse\n\t\t\t\t\t\tDeltaTfiDivisorIdx = (ctx->avc_state->sei.pic_timing.pic_struct+1) / 2;\n\t\t\t\t}\n\t\t\t\tif (ctx->notime && sps->vui.time_scale && sps->vui.num_units_in_tick) {\n\t\t\t\t\tctx->cur_fps.num = 2 * sps->vui.time_scale;\n\t\t\t\t\tctx->cur_fps.den = 2 * sps->vui.num_units_in_tick * DeltaTfiDivisorIdx;\n\n\t\t\t\t\tif (!ctx->fps.num && ctx->dts==ctx->fps.den)\n\t\t\t\t\t\tctx->dts = ctx->cur_fps.den;\n\t\t\t\t}\n\t\t\t\tif (! sps->vui.fixed_frame_rate_flag)\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[%s] Possible Variable Frame Rate: VUI \\\"fixed_frame_rate_flag\\\" absent\\n\", ctx->log_name));\n\t\t\t}\n\t\t\tctx->fps = ctx->cur_fps;\n\t\t}\n\t\tfirst = GF_FALSE;\n\t\tif (is_svc) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\t\tif (!sps->vui.pic_struct_present_flag) {\n\t\t\t\t\tDeltaTfiDivisorIdx = 1 + (1 - ctx->avc_state->s_info.field_pic_flag);\n\t\t\t\t} else {\n\t\t\t\t\tif (!ctx->avc_state->sei.pic_timing.pic_struct)\n\t\t\t\t\t\tDeltaTfiDivisorIdx = 2;\n\t\t\t\t\telse if (ctx->avc_state->sei.pic_timing.pic_struct == 8)\n\t\t\t\t\t\tDeltaTfiDivisorIdx = 6;\n\t\t\t\t\telse\n\t\t\t\t\t\tDeltaTfiDivisorIdx = (ctx->avc_state->sei.pic_timing.pic_struct+1) / 2;\n\t\t\t\t}\n\t\t\t\tif (ctx->notime) {\n\t\t\t\t\tu32 fps_num = 2 * sps->vui.time_scale;\n\t\t\t\t\tu32 fps_den = 2 * sps->vui.num_units_in_tick * DeltaTfiDivisorIdx;\n\t\t\t\t\tif (fps_num && fps_den) {\n\t\t\t\t\t\tctx->cur_fps.num = fps_num;\n\t\t\t\t\t\tctx->cur_fps.den = fps_den;\n\t\t\t\t\t}\n\t\t\t\t\tif (!ctx->fps.num && ctx->dts==ctx->fps.den)\n\t\t\t\t\t\tctx->dts = ctx->cur_fps.den;\n\t\t\t\t}\n\t\t\t\tif (! sps->vui.fixed_frame_rate_flag)\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[%s] Possible Variable Frame Rate: VUI \\\"fixed_frame_rate_flag\\\" absent\\n\", ctx->log_name));\n\t\t\t}\n\t\t\tctx->fps = ctx->cur_fps;\n\t\t}\n\t\tfirst = GF_FALSE;\n\t\tif (is_svc) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "FileInformation ImageReadJPEGInfo( String const& filename ) {\n   JpegInput jpeg( filename );\n   FileInformation info = GetJPEGInfo( jpeg );\n   return info;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "FileInformation ImageReadJPEGInfo( String const& filename ) {\n   DIP__DECLARE_JPEG_EXIT( \"Error reading JPEG file\" );\n   JpegInput jpeg( filename, setjmp_buffer );\n   FileInformation info = GetJPEGInfo( jpeg );\n   return info;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  size_t ulen;\n  size_t plen;\n  size_t plainlen;\n\n  *outlen = 0;\n  *outptr = NULL;\n  ulen = strlen(userp);\n  plen = strlen(passwdp);\n\n  /* Compute binary message length. Check for overflows. */\n  if((ulen > SIZE_T_MAX/2) || (plen > (SIZE_T_MAX/2 - 2)))\n    return CURLE_OUT_OF_MEMORY;\n  plainlen = 2 * ulen + plen + 2;\n\n  plainauth = malloc(plainlen);\n  if(!plainauth)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* Calculate the reply */\n  memcpy(plainauth, userp, ulen);\n  plainauth[ulen] = '\\0';",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  size_t ulen;\n  size_t plen;\n  size_t plainlen;\n\n  *outlen = 0;\n  *outptr = NULL;\n  ulen = strlen(userp);\n  plen = strlen(passwdp);\n\n  /* Compute binary message length. Check for overflows. */\n  if((ulen > SIZE_T_MAX/4) || (plen > (SIZE_T_MAX/2 - 2)))\n    return CURLE_OUT_OF_MEMORY;\n  plainlen = 2 * ulen + plen + 2;\n\n  plainauth = malloc(plainlen);\n  if(!plainauth)\n    return CURLE_OUT_OF_MEMORY;\n\n  /* Calculate the reply */\n  memcpy(plainauth, userp, ulen);\n  plainauth[ulen] = '\\0';",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int performRtspHandshake(void) {\n    int ret;\n\n    // HACK: In order to get GFE to respect our request for a lower audio bitrate, we must\n    // fake our target address so it doesn't match any of the PC's local interfaces. It seems\n    // that the only way to get it to give you \"low quality\" stereo audio nowadays is if it\n    // thinks you are remote (target address != any local address).\n    if (OriginalVideoBitrate >= HIGH_AUDIO_BITRATE_THRESHOLD &&\n            (AudioCallbacks.capabilities & CAPABILITY_SLOW_OPUS_DECODER) == 0) {\n        addrToUrlSafeString(&RemoteAddr, urlAddr);\n    }\n    else {\n        strcpy(urlAddr, \"0.0.0.0\");\n    }\n\n    LC_ASSERT(RtspPortNumber != 0);\n\n    // Initialize global state\n    useEnet = (AppVersionQuad[0] >= 5) && (AppVersionQuad[0] <= 7) && (AppVersionQuad[2] < 404);\n    sprintf(rtspTargetUrl, \"rtsp%s://%s:%u\", useEnet ? \"ru\" : \"\", urlAddr, RtspPortNumber);\n    currentSeqNumber = 1;\n    hasSessionId = false;\n    controlStreamId = APP_VERSION_AT_LEAST(7, 1, 431) ? \"streamid=control/13/0\" : \"streamid=control/1/0\";\n    AudioEncryptionEnabled = false;\n\n    switch (AppVersionQuad[0]) {\n        case 3:\n            rtspClientVersion = 10;\n            break;\n        case 4:\n            rtspClientVersion = 11;\n            break;\n        case 5:\n            rtspClientVersion = 12;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int performRtspHandshake(PSERVER_INFORMATION serverInfo) {\n    int ret;\n\n    LC_ASSERT(RtspPortNumber != 0);\n\n    // Initialize global state\n    useEnet = (AppVersionQuad[0] >= 5) && (AppVersionQuad[0] <= 7) && (AppVersionQuad[2] < 404);\n    currentSeqNumber = 1;\n    hasSessionId = false;\n    controlStreamId = APP_VERSION_AT_LEAST(7, 1, 431) ? \"streamid=control/13/0\" : \"streamid=control/1/0\";\n    AudioEncryptionEnabled = false;\n\n    // HACK: In order to get GFE to respect our request for a lower audio bitrate, we must\n    // fake our target address so it doesn't match any of the PC's local interfaces. It seems\n    // that the only way to get it to give you \"low quality\" stereo audio nowadays is if it\n    // thinks you are remote (target address != any local address).\n    //\n    // We will enable high quality audio if the following are all true:\n    // 1. Video bitrate is higher than 15 Mbps (to ensure most bandwidth is reserved for video)\n    // 2. The audio decoder has not declared that it is slow\n    // 3. The stream is either local or not surround sound (to prevent MTU issues over the Internet)\n    LC_ASSERT(StreamConfig.streamingRemotely != STREAM_CFG_AUTO);\n    if (OriginalVideoBitrate >= HIGH_AUDIO_BITRATE_THRESHOLD &&\n            (AudioCallbacks.capabilities & CAPABILITY_SLOW_OPUS_DECODER) == 0 &&\n            (StreamConfig.streamingRemotely != STREAM_CFG_REMOTE || CHANNEL_COUNT_FROM_AUDIO_CONFIGURATION(StreamConfig.audioConfiguration) <= 2)) {\n        // If we have an RTSP URL string and it was successfully parsed, use that string\n        if (serverInfo->rtspSessionUrl != NULL && parseUrlAddrFromRtspUrlString(serverInfo->rtspSessionUrl, urlAddr)) {\n            strcpy(rtspTargetUrl, serverInfo->rtspSessionUrl);\n        }\n        else {\n            // If an RTSP URL string was not provided or failed to parse, we will construct one now as best we can.\n            //\n            // NB: If the remote address is not a LAN address, the host will likely not enable high quality\n            // audio since it only does that for local streaming normally. We can avoid this limitation,\n            // but only if the caller gave us the RTSP session URL that it received from the host during launch.\n            addrToUrlSafeString(&RemoteAddr, urlAddr);\n            sprintf(rtspTargetUrl, \"rtsp%s://%s:%u\", useEnet ? \"ru\" : \"\", urlAddr, RtspPortNumber);\n        }\n    }\n    else {\n        strcpy(urlAddr, \"0.0.0.0\");\n        sprintf(rtspTargetUrl, \"rtsp%s://%s:%u\", useEnet ? \"ru\" : \"\", urlAddr, RtspPortNumber);\n    }\n\n    switch (AppVersionQuad[0]) {\n        case 3:\n            rtspClientVersion = 10;\n            break;\n        case 4:\n            rtspClientVersion = 11;\n            break;\n        case 5:\n            rtspClientVersion = 12;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    }else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\n        /* AES */\n        key_bytes_len = pntoh16(pEAPKey->key_data_len);\n\n        /* AES keys must be at least 128 bits = 16 bytes. */\n        if (key_bytes_len < 16) {\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n    }\n\n    if (key_bytes_len < GROUP_KEY_MIN_LEN || key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY)) {\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n\n    /* Encrypted key is in the information element field of the EAPOL key packet */\n    key_data = (guint8 *)pEAPKey + sizeof(EAPOL_RSN_KEY);\n    szEncryptedKey = (guint8 *)g_memdup(key_data, key_bytes_len);\n\n    DEBUG_DUMP(\"Encrypted Broadcast key:\", szEncryptedKey, key_bytes_len);\n    DEBUG_DUMP(\"KeyIV:\", pEAPKey->key_iv, 16);\n    DEBUG_DUMP(\"decryption_key:\", decryption_key, 16);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    }else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){\n        /* AES */\n        key_bytes_len = pntoh16(pEAPKey->key_data_len);\n\n        /* AES keys must be at least 128 bits = 16 bytes. */\n        if (key_bytes_len < 16) {\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n    }\n\n    if ((key_bytes_len < GROUP_KEY_MIN_LEN) ||\n        (eapol_len < sizeof(EAPOL_RSN_KEY)) ||\n        (key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY))) {\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n\n    /* Encrypted key is in the information element field of the EAPOL key packet */\n    key_data = (guint8 *)pEAPKey + sizeof(EAPOL_RSN_KEY);\n    szEncryptedKey = (guint8 *)g_memdup(key_data, key_bytes_len);\n\n    DEBUG_DUMP(\"Encrypted Broadcast key:\", szEncryptedKey, key_bytes_len);\n    DEBUG_DUMP(\"KeyIV:\", pEAPKey->key_iv, 16);\n    DEBUG_DUMP(\"decryption_key:\", decryption_key, 16);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "          sqlite3VdbeAddOp3(v, OP_Column, iDataCur, pTab->nNVCol-1,3);\n          sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);\n        }\n        /* Verify that all NOT NULL columns really are NOT NULL */\n        for(j=0; j<pTab->nCol; j++){\n          char *zErr;\n          int jmp2;\n          if( j==pTab->iPKey ) continue;\n          if( pTab->aCol[j].notNull==0 ) continue;\n          sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);\n          sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);\n          jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);\n          zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,\n                              pTab->aCol[j].zName);\n          sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);\n          integrityCheckResultRow(v);\n          sqlite3VdbeJumpHere(v, jmp2);\n        }\n        /* Verify CHECK constraints */\n        if( pTab->pCheck && (db->flags & SQLITE_IgnoreChecks)==0 ){\n          ExprList *pCheck = sqlite3ExprListDup(db, pTab->pCheck, 0);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "          sqlite3VdbeAddOp3(v, OP_Column, iDataCur, pTab->nNVCol-1,3);\n          sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);\n        }\n        /* Verify that all NOT NULL columns really are NOT NULL */\n        for(j=0; j<pTab->nCol; j++){\n          char *zErr;\n          int jmp2;\n          if( j==pTab->iPKey ) continue;\n          if( pTab->aCol[j].notNull==0 ) continue;\n          sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);\n          if( sqlite3VdbeGetOp(v,-1)->opcode==OP_Column ){\n            sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);\n          }\n          jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);\n          zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,\n                              pTab->aCol[j].zName);\n          sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);\n          integrityCheckResultRow(v);\n          sqlite3VdbeJumpHere(v, jmp2);\n        }\n        /* Verify CHECK constraints */\n        if( pTab->pCheck && (db->flags & SQLITE_IgnoreChecks)==0 ){\n          ExprList *pCheck = sqlite3ExprListDup(db, pTab->pCheck, 0);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n\tmemset(fname, 0, sizeof(struct fscrypt_name));\n\tfname->usr_fname = iname;\n\n\tif (!dir->i_sb->s_cop->is_encrypted(dir) ||\n\t\t\t\tfscrypt_is_dot_dotdot(iname)) {\n\t\tfname->disk_name.name = (unsigned char *)iname->name;\n\t\tfname->disk_name.len = iname->len;\n\t\treturn 0;\n\t}\n\tret = fscrypt_get_crypt_info(dir);\n\tif (ret && ret != -EOPNOTSUPP)\n\t\treturn ret;\n\n\tif (dir->i_crypt_info) {\n\t\tret = fscrypt_fname_alloc_buffer(dir, iname->len,\n\t\t\t\t\t\t\t&fname->crypto_buf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = fname_encrypt(dir, iname, &fname->crypto_buf);\n\t\tif (ret)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n\tmemset(fname, 0, sizeof(struct fscrypt_name));\n\tfname->usr_fname = iname;\n\n\tif (!dir->i_sb->s_cop->is_encrypted(dir) ||\n\t\t\t\tfscrypt_is_dot_dotdot(iname)) {\n\t\tfname->disk_name.name = (unsigned char *)iname->name;\n\t\tfname->disk_name.len = iname->len;\n\t\treturn 0;\n\t}\n\tret = fscrypt_get_encryption_info(dir);\n\tif (ret && ret != -EOPNOTSUPP)\n\t\treturn ret;\n\n\tif (dir->i_crypt_info) {\n\t\tret = fscrypt_fname_alloc_buffer(dir, iname->len,\n\t\t\t\t\t\t\t&fname->crypto_buf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = fname_encrypt(dir, iname, &fname->crypto_buf);\n\t\tif (ret)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "                         unsigned int initial_h, unsigned int *w,\n                         unsigned int *h, bool flag_codec,\n                         bool smaller_width_larger_size_) {\n  *w = initial_w;\n  *h = initial_h;\n\n  if (smaller_width_larger_size_) {\n    if (frame < 30) {\n      return;\n    }\n    if (frame < 100) {\n      *w = initial_w * 7 / 10;\n      *h = initial_h * 16 / 10;\n      return;\n    }\n    return;\n  }\n  if (frame < 10) {\n    return;\n  }\n  if (frame < 20) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "                         unsigned int initial_h, unsigned int *w,\n                         unsigned int *h, bool flag_codec,\n                         bool smaller_width_larger_size_) {\n  *w = initial_w;\n  *h = initial_h;\n\n  if (smaller_width_larger_size_) {\n    if (frame < 30) {\n      return;\n    }\n    *w = initial_w * 7 / 10;\n    *h = initial_h * 16 / 10;\n    return;\n  }\n  if (frame < 10) {\n    return;\n  }\n  if (frame < 20) {\n    *w = initial_w * 3 / 4;\n    *h = initial_h * 3 / 4;\n    return;\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "            BYTE byteMain = pBuffer[lIndex];\n            if (0x00 == (byteMain & 0x80))\n            {\n                // 1 byte\n                *pUnicodeString++ = (WCHAR)byteMain;\n                ++lIndex;\n            }\n            else if (0x00 == (byteMain & 0x20))\n            {\n                // 2 byte\n                int val = (int)(((byteMain & 0x1F) << 6) |\n                    (pBuffer[lIndex + 1] & 0x3F));\n                *pUnicodeString++ = (WCHAR)(val);\n                lIndex += 2;\n            }\n            else if (0x00 == (byteMain & 0x10))\n            {\n                // 3 byte\n                int val = (int)(((byteMain & 0x0F) << 12) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 2] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 3;\n            }\n            else if (0x00 == (byteMain & 0x0F))\n            {\n                // 4 byte\n                int val = (int)(((byteMain & 0x07) << 18) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 3] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x08))\n            {\n                // 4 byte\n                int val = (int)(((byteMain & 0x07) << 18) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 3] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x04))\n            {\n                // 5 byte\n                int val = (int)(((byteMain & 0x03) << 24) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 18) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 3] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 4] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 5;\n            }\n            else\n            {\n                // 6 byte\n                int val = (int)(((byteMain & 0x01) << 30) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 24) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 18) |\n                    ((pBuffer[lIndex + 3] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 4] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 5] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 5;\n            }\n        }\n\n        *pUnicodeString++ = 0;\n\n        sOutput.append(pStart);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "            BYTE byteMain = pBuffer[lIndex];\n            if (0x00 == (byteMain & 0x80))\n            {\n                // 1 byte\n                *pUnicodeString++ = (WCHAR)byteMain;\n                ++lIndex;\n            }\n            else if (0x00 == (byteMain & 0x20))\n            {\n                // 2 byte\n                int val = 0;\n                if ((lIndex + 1) < lCount)\n                {\n                    val = (int)(((byteMain & 0x1F) << 6) |\n                                (pBuffer[lIndex + 1] & 0x3F));\n                }\n\n                *pUnicodeString++ = (WCHAR)(val);\n                lIndex += 2;\n            }\n            else if (0x00 == (byteMain & 0x10))\n            {\n                // 3 byte\n                int val = 0;\n                if ((lIndex + 2) < lCount)\n                {\n                    val = (int)(((byteMain & 0x0F) << 12) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 2] & 0x3F));\n                }\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 3;\n            }\n            else if (0x00 == (byteMain & 0x0F))\n            {\n                // 4 byte\n                int val = 0;\n                if ((lIndex + 3) < lCount)\n                {\n                    val = (int)(((byteMain & 0x07) << 18) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 3] & 0x3F));\n                }\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x08))\n            {\n                // 4 byte\n                int val = 0;\n                if ((lIndex + 3) < lCount)\n                {\n                    val = (int)(((byteMain & 0x07) << 18) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 3] & 0x3F));\n                }\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x04))\n            {\n                // 5 byte\n                int val = 0;\n                if ((lIndex + 4) < lCount)\n                {\n                    val = (int)(((byteMain & 0x03) << 24) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 18) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 3] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 4] & 0x3F));\n                }\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 5;\n            }\n            else\n            {\n                // 6 byte\n                int val = 0;\n                if ((lIndex + 5) < lCount)\n                {\n                    val = (int)(((byteMain & 0x01) << 30) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 24) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 18) |\n                                ((pBuffer[lIndex + 3] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 4] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 5] & 0x3F));\n                }\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 5;\n            }\n        }\n\n        *pUnicodeString++ = 0;\n\n        sOutput.append(pStart);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TfLiteStatus TanhPrepare(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  if (kernel_type == kFixedPointOptimized) {\n    if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n      static constexpr int kInputIntegerBits = 4;\n\n      const double input_real_multiplier =\n          input->params.scale *\n          static_cast<double>(1 << (15 - kInputIntegerBits));\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus TanhPrepare(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  if (kernel_type == kFixedPointOptimized) {\n    if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n      static constexpr int kInputIntegerBits = 4;\n\n      const double input_real_multiplier =\n          input->params.scale *\n          static_cast<double>(1 << (15 - kInputIntegerBits));\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\treturn 0;\n\tcase TIOCSCTTY:\n\t\treturn tiocsctty(real_tty, file, arg);\n\tcase TIOCGPGRP:\n\t\treturn tiocgpgrp(tty, real_tty, p);\n\tcase TIOCSPGRP:\n\t\treturn tiocspgrp(tty, real_tty, p);\n\tcase TIOCGSID:\n\t\treturn tiocgsid(tty, real_tty, p);\n\tcase TIOCGETD:\n\t\treturn put_user(tty->ldisc->ops->num, (int __user *)p);\n\tcase TIOCSETD:\n\t\treturn tiocsetd(tty, p);\n\tcase TIOCVHANGUP:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\ttty_vhangup(tty);\n\t\treturn 0;\n\tcase TIOCGDEV:\n\t{\n\t\tunsigned int ret = new_encode_dev(tty_devnum(real_tty));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\treturn 0;\n\tcase TIOCSCTTY:\n\t\treturn tiocsctty(real_tty, file, arg);\n\tcase TIOCGPGRP:\n\t\treturn tiocgpgrp(tty, real_tty, p);\n\tcase TIOCSPGRP:\n\t\treturn tiocspgrp(tty, real_tty, p);\n\tcase TIOCGSID:\n\t\treturn tiocgsid(tty, real_tty, p);\n\tcase TIOCGETD:\n\t\treturn tiocgetd(tty, p);\n\tcase TIOCSETD:\n\t\treturn tiocsetd(tty, p);\n\tcase TIOCVHANGUP:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\ttty_vhangup(tty);\n\t\treturn 0;\n\tcase TIOCGDEV:\n\t{\n\t\tunsigned int ret = new_encode_dev(tty_devnum(real_tty));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->hash_is_enabled = HASH_ENABLED;\n        dcfg->hash_enforcement = HASH_ENABLED;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->hash_is_enabled = HASH_DISABLED;\n        dcfg->hash_enforcement = HASH_DISABLED;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRuleEngine: %s\", p1);\n\n    return NULL;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    if (dcfg == NULL) return NULL;\n\n    if (strcasecmp(p1, \"on\") == 0)  {\n        dcfg->hash_is_enabled = HASH_ENABLED;\n        dcfg->hash_enforcement = HASH_ENABLED;\n    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->hash_is_enabled = HASH_DISABLED;\n        dcfg->hash_enforcement = HASH_DISABLED;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SexHashEngine: %s\", p1);\n\n    return NULL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "      !flatpak_remote_state_lookup_ref (state, flatpak_decomposed_get_ref (op->ref),\n                                        &summary_checksum, NULL, NULL, NULL, NULL) ||\n      strcmp (summary_checksum, checksum) != 0)\n    return FALSE;\n\n  /* And, we must have the actual cached data in the summary */\n  if (!flatpak_remote_state_lookup_cache (state, flatpak_decomposed_get_ref (op->ref),\n                                          &download_size, &installed_size, &metadata, NULL))\n      return FALSE;\n\n  metadata_bytes = g_bytes_new (metadata, strlen (metadata) + 1);\n\n  if (flatpak_remote_state_lookup_ref (state, flatpak_decomposed_get_ref (op->ref),\n                                       NULL, NULL, &info, NULL, NULL))\n    op->summary_metadata = var_metadata_dup_to_gvariant (var_ref_info_get_metadata (info));\n\n  op->installed_size = installed_size;\n  op->download_size = download_size;\n\n  op->token_type = state->default_token_type;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "      !flatpak_remote_state_lookup_ref (state, flatpak_decomposed_get_ref (op->ref),\n                                        &summary_checksum, NULL, NULL, NULL, NULL) ||\n      strcmp (summary_checksum, checksum) != 0)\n    return FALSE;\n\n  /* And, we must have the actual cached data in the summary */\n  if (!flatpak_remote_state_lookup_cache (state, flatpak_decomposed_get_ref (op->ref),\n                                          &download_size, &installed_size, &metadata, NULL))\n      return FALSE;\n\n  metadata_bytes = g_bytes_new (metadata, strlen (metadata));\n\n  if (flatpak_remote_state_lookup_ref (state, flatpak_decomposed_get_ref (op->ref),\n                                       NULL, NULL, &info, NULL, NULL))\n    op->summary_metadata = var_metadata_dup_to_gvariant (var_ref_info_get_metadata (info));\n\n  op->installed_size = installed_size;\n  op->download_size = download_size;\n\n  op->token_type = state->default_token_type;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "inline void StringData::setSize(int len) {\n  assertx(!isImmutable() && !hasMultipleRefs());\n  assertx(len >= 0 && len <= capacity());\n  mutableData()[len] = 0;\n  m_lenAndHash = len;\n  assertx(m_hash == 0);\n  assertx(checkSane());\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "inline void StringData::setSize(int64_t len) {\n  assertx(!isImmutable() && !hasMultipleRefs());\n  assertx(len >= 0 && len <= capacity());\n  mutableData()[len] = 0;\n  m_lenAndHash = len;\n  assertx(m_hash == 0);\n  assertx(checkSane());\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  parser->m_unknownEncodingData = NULL;\n  parser->m_parentParser = NULL;\n  parser->m_parsingStatus.parsing = XML_INITIALIZED;\n#ifdef XML_DTD\n  parser->m_isParamEntity = XML_FALSE;\n  parser->m_useForeignDTD = XML_FALSE;\n  parser->m_paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;\n#endif\n  parser->m_hash_secret_salt = 0;\n\n#ifdef XML_DTD\n  memset(&parser->m_accounting, 0, sizeof(ACCOUNTING));\n  parser->m_accounting.debugLevel = getDebugLevel(\"EXPAT_ACCOUNTING_DEBUG\", 0u);\n  parser->m_accounting.maximumAmplificationFactor\n      = EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT;\n  parser->m_accounting.activationThresholdBytes\n      = EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT;\n\n  memset(&parser->m_entity_stats, 0, sizeof(ENTITY_STATS));\n  parser->m_entity_stats.debugLevel = getDebugLevel(\"EXPAT_ENTITY_DEBUG\", 0u);\n#endif",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  parser->m_unknownEncodingData = NULL;\n  parser->m_parentParser = NULL;\n  parser->m_parsingStatus.parsing = XML_INITIALIZED;\n#ifdef XML_DTD\n  parser->m_isParamEntity = XML_FALSE;\n  parser->m_useForeignDTD = XML_FALSE;\n  parser->m_paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;\n#endif\n  parser->m_hash_secret_salt = 0;\n\n#if defined(XML_DTD) || XML_GE == 1\n  memset(&parser->m_accounting, 0, sizeof(ACCOUNTING));\n  parser->m_accounting.debugLevel = getDebugLevel(\"EXPAT_ACCOUNTING_DEBUG\", 0u);\n  parser->m_accounting.maximumAmplificationFactor\n      = EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT;\n  parser->m_accounting.activationThresholdBytes\n      = EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT;\n\n  memset(&parser->m_entity_stats, 0, sizeof(ENTITY_STATS));\n  parser->m_entity_stats.debugLevel = getDebugLevel(\"EXPAT_ENTITY_DEBUG\", 0u);\n#endif",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  unsigned int opb = bfd_octets_per_byte (ibfd, NULL);\n\n  bed = get_elf_backend_data (ibfd);\n  iehdr = elf_elfheader (ibfd);\n\n  map_first = NULL;\n  pointer_to_map = &map_first;\n\n  num_segments = elf_elfheader (ibfd)->e_phnum;\n\n  /* Returns the end address of the segment + 1.  */\n#define SEGMENT_END(segment, start)\t\t\t\t\t\\\n  (start + (segment->p_memsz > segment->p_filesz\t\t\t\\\n\t    ? segment->p_memsz : segment->p_filesz))\n\n#define SECTION_SIZE(section, segment)\t\t\t\t\t\\\n  (((section->flags & (SEC_HAS_CONTENTS | SEC_THREAD_LOCAL))\t\t\\\n    != SEC_THREAD_LOCAL || segment->p_type == PT_TLS)\t\t\t\\\n   ? section->size : 0)\n\n  /* Returns TRUE if the given section is contained within\n     the given segment.  VMA addresses are compared.  */\n#define IS_CONTAINED_BY_VMA(section, segment, opb)\t\t\t\\\n  (section->vma * (opb) >= segment->p_vaddr\t\t\t\t\\\n   && (section->vma * (opb) + SECTION_SIZE (section, segment)\t\t\\\n       <= (SEGMENT_END (segment, segment->p_vaddr))))\n\n  /* Returns TRUE if the given section is contained within\n     the given segment.  LMA addresses are compared.  */\n#define IS_CONTAINED_BY_LMA(section, segment, base, opb)\t\t\\\n  (section->lma * (opb) >= base\t\t\t\t\t\t\\\n   && (section->lma + SECTION_SIZE (section, segment) / (opb) >= section->lma) \\\n   && (section->lma * (opb) + SECTION_SIZE (section, segment)\t\t\\\n       <= SEGMENT_END (segment, base)))\n\n  /* Handle PT_NOTE segment.  */\n#define IS_NOTE(p, s)\t\t\t\t\t\t\t\\\n  (p->p_type == PT_NOTE\t\t\t\t\t\t\t\\\n   && elf_section_type (s) == SHT_NOTE\t\t\t\t\t\\\n   && (bfd_vma) s->filepos >= p->p_offset\t\t\t\t\\\n   && ((bfd_vma) s->filepos + s->size\t\t\t\t\t\\\n       <= p->p_offset + p->p_filesz))\n\n  /* Special case: corefile \"NOTE\" section containing regs, prpsinfo\n     etc.  */\n#define IS_COREFILE_NOTE(p, s)\t\t\t\t\t\t\\\n  (IS_NOTE (p, s)\t\t\t\t\t\t\t\\\n   && bfd_get_format (ibfd) == bfd_core\t\t\t\t\t\\\n   && s->vma == 0\t\t\t\t\t\t\t\\\n   && s->lma == 0)\n\n  /* The complicated case when p_vaddr is 0 is to handle the Solaris\n     linker, which generates a PT_INTERP section with p_vaddr and\n     p_memsz set to 0.  */\n#define IS_SOLARIS_PT_INTERP(p, s)\t\t\t\t\t\\\n  (p->p_vaddr == 0\t\t\t\t\t\t\t\\\n   && p->p_paddr == 0\t\t\t\t\t\t\t\\\n   && p->p_memsz == 0\t\t\t\t\t\t\t\\\n   && p->p_filesz > 0\t\t\t\t\t\t\t\\\n   && (s->flags & SEC_HAS_CONTENTS) != 0\t\t\t\t\\\n   && s->size > 0\t\t\t\t\t\t\t\\\n       2. It is an allocated section or a NOTE section in a PT_NOTE\n\t  segment.\n       3. There is an output section associated with it,\n       4. The section has not already been allocated to a previous segment.\n       5. PT_GNU_STACK segments do not include any sections.\n       6. PT_TLS segment includes only SHF_TLS sections.\n       7. SHF_TLS sections are only in PT_TLS or PT_LOAD segments.\n       8. PT_DYNAMIC should not contain empty sections at the beginning\n\t  (with the possible exception of .dynamic).  */\n#define IS_SECTION_IN_INPUT_SEGMENT(section, segment, bed, opb)\t\t\\\n  ((((segment->p_paddr\t\t\t\t\t\t\t\\\n      ? IS_CONTAINED_BY_LMA (section, segment, segment->p_paddr, opb)\t\\\n      : IS_CONTAINED_BY_VMA (section, segment, opb))\t\t\t\\\n     && (section->flags & SEC_ALLOC) != 0)\t\t\t\t\\\n    || IS_NOTE (segment, section))\t\t\t\t\t\\\n   && segment->p_type != PT_GNU_STACK\t\t\t\t\t\\\n   && (segment->p_type != PT_TLS\t\t\t\t\t\\\n       || (section->flags & SEC_THREAD_LOCAL))\t\t\t\t\\\n   && (segment->p_type == PT_LOAD\t\t\t\t\t\\\n       || segment->p_type == PT_TLS\t\t\t\t\t\\\n       || (section->flags & SEC_THREAD_LOCAL) == 0)\t\t\t\\\n   && (segment->p_type != PT_DYNAMIC\t\t\t\t\t\\\n       || SECTION_SIZE (section, segment) > 0\t\t\t\t\\\n       || (segment->p_paddr\t\t\t\t\t\t\\\n\t   ? segment->p_paddr != section->lma * (opb)\t\t\t\\\n\t   : segment->p_vaddr != section->vma * (opb))\t\t\t\\\n       || (strcmp (bfd_section_name (section), \".dynamic\") == 0))\t\\\n   && (segment->p_type != PT_LOAD || !section->segment_mark))\n\n/* If the output section of a section in the input segment is NULL,\n   it is removed from the corresponding output segment.   */\n#define INCLUDE_SECTION_IN_SEGMENT(section, segment, bed, opb)\t\t\\\n  (IS_SECTION_IN_INPUT_SEGMENT (section, segment, bed, opb)\t\t\\\n   && section->output_section != NULL)\n\n  /* Returns TRUE iff seg1 starts after the end of seg2.  */\n#define SEGMENT_AFTER_SEGMENT(seg1, seg2, field)\t\t\t\\\n  (seg1->field >= SEGMENT_END (seg2, seg2->field))\n\n  /* Returns TRUE iff seg1 and seg2 overlap. Segments overlap iff both\n     their VMA address ranges and their LMA address ranges overlap.\n     It is possible to have overlapping VMA ranges without overlapping LMA\n     ranges.  RedBoot images for example can have both .data and .bss mapped\n     to the same VMA range, but with the .data section mapped to a different\n     LMA.  */\n#define SEGMENT_OVERLAPS(seg1, seg2)\t\t\t\t\t\\\n  (   !(SEGMENT_AFTER_SEGMENT (seg1, seg2, p_vaddr)\t\t\t\\\n\t|| SEGMENT_AFTER_SEGMENT (seg2, seg1, p_vaddr))\t\t\t\\\n\n\t  if (segment2->p_type != PT_LOAD\n\t      || !SEGMENT_OVERLAPS (segment, segment2))\n\t    continue;\n\n\t  /* Merge the two segments together.  */\n\t  if (segment2->p_vaddr < segment->p_vaddr)\n\t    {\n\t      /* Extend SEGMENT2 to include SEGMENT and then delete\n\t\t SEGMENT.  */\n\t      extra_length = (SEGMENT_END (segment, segment->p_vaddr)\n\t\t\t      - SEGMENT_END (segment2, segment2->p_vaddr));\n\n\t      if (extra_length > 0)\n\t\t{\n\t\t  segment2->p_memsz += extra_length;\n\t\t  segment2->p_filesz += extra_length;\n\t\t}\n\n\t      segment->p_type = PT_NULL;\n\n\t      /* Since we have deleted P we must restart the outer loop.  */\n\t      i = 0;\n\t      segment = elf_tdata (ibfd)->phdr;\n\t      break;\n\t    }\n\t  else\n\t    {\n\t      /* Extend SEGMENT to include SEGMENT2 and then delete\n\t\t SEGMENT2.  */\n\t      extra_length = (SEGMENT_END (segment2, segment2->p_vaddr)\n\t\t\t      - SEGMENT_END (segment, segment->p_vaddr));\n\n\t      if (extra_length > 0)\n\t\t{\n\t\t  segment->p_memsz += extra_length;\n\t\t  segment->p_filesz += extra_length;\n\t\t}\n\n\t      segment2->p_type = PT_NULL;\n\t    }\n\t}\n\t\t\t\t      ? iehdr->e_ehsize : 0)\n\t\t\t\t   + (map->includes_phdrs\n\t\t\t\t      ? iehdr->e_phnum * iehdr->e_phentsize\n\t\t\t\t      : 0),\n\t\t\t\t   output_section->alignment_power * opb)\n\t\t      == (output_section->vma * opb)))\n\t\tmap->p_paddr = segment->p_vaddr;\n\n\t      /* Match up the physical address of the segment with the\n\t\t LMA address of the output section.  */\n\t      if (IS_CONTAINED_BY_LMA (output_section, segment, map->p_paddr,\n\t\t\t\t       opb)\n\t\t  || IS_COREFILE_NOTE (segment, section)\n\t\t  || (bed->want_p_paddr_set_to_zero\n\t\t      && IS_CONTAINED_BY_VMA (output_section, segment, opb)))\n\t\t{\n\t\t  if (matching_lma == NULL\n\t\t      || output_section->lma < matching_lma->lma)\n\t\t    matching_lma = output_section;\n\n\t\t  /* We assume that if the section fits within the segment\n\t\t     then it does not overlap any other section within that\n\t\t     segment.  */\n\t\t  map->sections[isec++] = output_section;\n\t\t}\n\t    {\n\t      section = sections[j];\n\n\t      if (section == NULL)\n\t\tcontinue;\n\n\t      output_section = section->output_section;\n\n\t      BFD_ASSERT (output_section != NULL);\n\n\t      if (IS_CONTAINED_BY_LMA (output_section, segment, map->p_paddr,\n\t\t\t\t       opb)\n\t\t  || IS_COREFILE_NOTE (segment, section))\n\t\t{\n\t\t  if (map->count == 0)\n\t\t    {\n\t\t      /* If the first section in a segment does not start at\n\t\t\t the beginning of the segment, then something is\n\t\t\t wrong.  */\n\t\t      if (align_power (map->p_paddr\n\t\t\t\t       + (map->includes_filehdr\n\t\t\t\t\t  ? iehdr->e_ehsize : 0)\n\t\t\t\t       + (map->includes_phdrs\n      for (map = map_first; map != NULL; map = map->next)\n\tif (map->p_type == PT_PHDR)\n\t  {\n\t    bfd_vma adjust\n\t      = phdr_adjust_seg->includes_filehdr ? iehdr->e_ehsize : 0;\n\t    map->p_paddr = phdr_adjust_seg->p_paddr + adjust;\n\t    break;\n\t  }\n    }\n\n#undef SEGMENT_END\n#undef SECTION_SIZE\n#undef IS_CONTAINED_BY_VMA\n#undef IS_CONTAINED_BY_LMA\n#undef IS_NOTE\n#undef IS_COREFILE_NOTE\n#undef IS_SOLARIS_PT_INTERP\n#undef IS_SECTION_IN_INPUT_SEGMENT\n#undef INCLUDE_SECTION_IN_SEGMENT\n#undef SEGMENT_AFTER_SEGMENT\n#undef SEGMENT_OVERLAPS\n  return true;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  const struct elf_backend_data *bed;\n  unsigned int opb = bfd_octets_per_byte (ibfd, NULL);\n\n  bed = get_elf_backend_data (ibfd);\n  iehdr = elf_elfheader (ibfd);\n\n  map_first = NULL;\n  pointer_to_map = &map_first;\n\n  num_segments = elf_elfheader (ibfd)->e_phnum;\n\n  /* The complicated case when p_vaddr is 0 is to handle the Solaris\n     linker, which generates a PT_INTERP section with p_vaddr and\n     p_memsz set to 0.  */\n#define IS_SOLARIS_PT_INTERP(p, s)\t\t\t\t\t\\\n  (p->p_vaddr == 0\t\t\t\t\t\t\t\\\n   && p->p_paddr == 0\t\t\t\t\t\t\t\\\n   && p->p_memsz == 0\t\t\t\t\t\t\t\\\n   && p->p_filesz > 0\t\t\t\t\t\t\t\\\n   && (s->flags & SEC_HAS_CONTENTS) != 0\t\t\t\t\\\n   && s->size > 0\t\t\t\t\t\t\t\\\n       2. It is an allocated section or a NOTE section in a PT_NOTE\n\t  segment.\n       3. There is an output section associated with it,\n       4. The section has not already been allocated to a previous segment.\n       5. PT_GNU_STACK segments do not include any sections.\n       6. PT_TLS segment includes only SHF_TLS sections.\n       7. SHF_TLS sections are only in PT_TLS or PT_LOAD segments.\n       8. PT_DYNAMIC should not contain empty sections at the beginning\n\t  (with the possible exception of .dynamic).  */\n#define IS_SECTION_IN_INPUT_SEGMENT(section, segment, bed, opb)\t\t\\\n  (((is_contained_by (section, segment, segment->p_paddr,\t\t\\\n\t\t      segment->p_vaddr, opb, bed)\t\t\t\\\n     && (section->flags & SEC_ALLOC) != 0)\t\t\t\t\\\n    || is_note (segment, section))\t\t\t\t\t\\\n   && segment->p_type != PT_GNU_STACK\t\t\t\t\t\\\n   && (segment->p_type != PT_TLS\t\t\t\t\t\\\n       || (section->flags & SEC_THREAD_LOCAL))\t\t\t\t\\\n   && (segment->p_type == PT_LOAD\t\t\t\t\t\\\n       || segment->p_type == PT_TLS\t\t\t\t\t\\\n       || (section->flags & SEC_THREAD_LOCAL) == 0)\t\t\t\\\n   && (segment->p_type != PT_DYNAMIC\t\t\t\t\t\\\n       || section_size (section, segment) > 0\t\t\t\t\\\n       || (segment->p_paddr\t\t\t\t\t\t\\\n\t   ? segment->p_paddr != section->lma * (opb)\t\t\t\\\n\t   : segment->p_vaddr != section->vma * (opb))\t\t\t\\\n       || (strcmp (bfd_section_name (section), \".dynamic\") == 0))\t\\\n   && (segment->p_type != PT_LOAD || !section->segment_mark))\n\n/* If the output section of a section in the input segment is NULL,\n   it is removed from the corresponding output segment.   */\n#define INCLUDE_SECTION_IN_SEGMENT(section, segment, bed, opb)\t\t\\\n  (IS_SECTION_IN_INPUT_SEGMENT (section, segment, bed, opb)\t\t\\\n   && section->output_section != NULL)\n\n  /* Returns TRUE iff seg1 starts after the end of seg2.  */\n#define SEGMENT_AFTER_SEGMENT(seg1, seg2, field)\t\t\t\\\n  (seg1->field >= segment_end (seg2, seg2->field))\n\n  /* Returns TRUE iff seg1 and seg2 overlap. Segments overlap iff both\n     their VMA address ranges and their LMA address ranges overlap.\n     It is possible to have overlapping VMA ranges without overlapping LMA\n     ranges.  RedBoot images for example can have both .data and .bss mapped\n     to the same VMA range, but with the .data section mapped to a different\n     LMA.  */\n#define SEGMENT_OVERLAPS(seg1, seg2)\t\t\t\t\t\\\n  (   !(SEGMENT_AFTER_SEGMENT (seg1, seg2, p_vaddr)\t\t\t\\\n\t|| SEGMENT_AFTER_SEGMENT (seg2, seg1, p_vaddr))\t\t\t\\\n\n\t  if (segment2->p_type != PT_LOAD\n\t      || !SEGMENT_OVERLAPS (segment, segment2))\n\t    continue;\n\n\t  /* Merge the two segments together.  */\n\t  if (segment2->p_vaddr < segment->p_vaddr)\n\t    {\n\t      /* Extend SEGMENT2 to include SEGMENT and then delete\n\t\t SEGMENT.  */\n\t      extra_length = (segment_end (segment, segment->p_vaddr)\n\t\t\t      - segment_end (segment2, segment2->p_vaddr));\n\n\t      if (extra_length > 0)\n\t\t{\n\t\t  segment2->p_memsz += extra_length;\n\t\t  segment2->p_filesz += extra_length;\n\t\t}\n\n\t      segment->p_type = PT_NULL;\n\n\t      /* Since we have deleted P we must restart the outer loop.  */\n\t      i = 0;\n\t      segment = elf_tdata (ibfd)->phdr;\n\t      break;\n\t    }\n\t  else\n\t    {\n\t      /* Extend SEGMENT to include SEGMENT2 and then delete\n\t\t SEGMENT2.  */\n\t      extra_length = (segment_end (segment2, segment2->p_vaddr)\n\t\t\t      - segment_end (segment, segment->p_vaddr));\n\n\t      if (extra_length > 0)\n\t\t{\n\t\t  segment->p_memsz += extra_length;\n\t\t  segment->p_filesz += extra_length;\n\t\t}\n\n\t      segment2->p_type = PT_NULL;\n\t    }\n\t}\n\t\t\t\t      ? iehdr->e_ehsize : 0)\n\t\t\t\t   + (map->includes_phdrs\n\t\t\t\t      ? iehdr->e_phnum * iehdr->e_phentsize\n\t\t\t\t      : 0),\n\t\t\t\t   output_section->alignment_power * opb)\n\t\t      == (output_section->vma * opb)))\n\t\tmap->p_paddr = segment->p_vaddr;\n\n\t      /* Match up the physical address of the segment with the\n\t\t LMA address of the output section.  */\n\t      if (is_contained_by (output_section, segment, map->p_paddr,\n\t\t\t\t   map->p_paddr + map->p_vaddr_offset, opb, bed)\n\t\t  || is_note (segment, section))\n\t\t{\n\t\t  if (matching_lma == NULL\n\t\t      || output_section->lma < matching_lma->lma)\n\t\t    matching_lma = output_section;\n\n\t\t  /* We assume that if the section fits within the segment\n\t\t     then it does not overlap any other section within that\n\t\t     segment.  */\n\t\t  map->sections[isec++] = output_section;\n\t\t}\n\t    {\n\t      section = sections[j];\n\n\t      if (section == NULL)\n\t\tcontinue;\n\n\t      output_section = section->output_section;\n\n\t      BFD_ASSERT (output_section != NULL);\n\n\t      if (is_contained_by (output_section, segment, map->p_paddr,\n\t\t\t\t   map->p_paddr + map->p_vaddr_offset, opb, bed)\n\t\t  || is_note (segment, section))\n\t\t{\n\t\t  if (map->count == 0)\n\t\t    {\n\t\t      /* If the first section in a segment does not start at\n\t\t\t the beginning of the segment, then something is\n\t\t\t wrong.  */\n\t\t      if (align_power (map->p_paddr\n\t\t\t\t       + (map->includes_filehdr\n\t\t\t\t\t  ? iehdr->e_ehsize : 0)\n\t\t\t\t       + (map->includes_phdrs\n\n      for (map = map_first; map != NULL; map = map->next)\n\tif (map->p_type == PT_PHDR)\n\t  {\n\t    bfd_vma adjust\n\t      = phdr_adjust_seg->includes_filehdr ? iehdr->e_ehsize : 0;\n\t    map->p_paddr = phdr_adjust_seg->p_paddr + adjust;\n\t    break;\n\t  }\n    }\n\n#undef IS_SOLARIS_PT_INTERP\n#undef IS_SECTION_IN_INPUT_SEGMENT\n#undef INCLUDE_SECTION_IN_SEGMENT\n#undef SEGMENT_AFTER_SEGMENT\n#undef SEGMENT_OVERLAPS\n  return true;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static BOOL rdp_read_font_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length > 4)\n\t\tStream_Seek_UINT16(s); /* fontSupportFlags (2 bytes) */\n\n\tif (length > 6)\n\t\tStream_Seek_UINT16(s); /* pad2Octets (2 bytes) */\n\n\treturn TRUE;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static BOOL rdp_read_font_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length > 5)\n\t\tStream_Seek_UINT16(s); /* fontSupportFlags (2 bytes) */\n\n\tif (length > 7)\n\t\tStream_Seek_UINT16(s); /* pad2Octets (2 bytes) */\n\n\treturn TRUE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tif (nLen > std::numeric_limits<DWORD>::max())\n\t\treturn false;\n\tINPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, de_Report);\n\n\tDWORD nWritten = 0;\n\t// ReSharper disable once CppLocalVariableMayBeConst",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tif (nLen > std::numeric_limits<DWORD>::max())\n\t\treturn false;\n\tINPUT_RECORD* pir = (nLen <= static_cast<int>(countof(ir))) ? ir : static_cast<INPUT_RECORD*>(calloc(nLen, sizeof(INPUT_RECORD)));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = (*pc == 0x1B || *pc >= 0x20) ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, de_Report);\n\n\tDWORD nWritten = 0;\n\t// ReSharper disable once CppLocalVariableMayBeConst",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tsmp_rmb();\n\tif (task->mm)\n\t\tdumpable = get_dumpable(task->mm);\n\trcu_read_lock();\n\tif (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\n\treturn security_ptrace_access_check(task, mode);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tif (ptrace_has_cap(tcred->user_ns, mode))\n\t\tgoto ok;\n\trcu_read_unlock();\n\treturn -EPERM;\nok:\n\trcu_read_unlock();\n\tsmp_rmb();\n\tif (task->mm)\n\t\tdumpable = get_dumpable(task->mm);\n\trcu_read_lock();\n\tif (dumpable != SUID_DUMP_USER &&\n\t    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\n\treturn security_ptrace_access_check(task, mode);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void pp_mil_k12(fp12_t r, ep2_t *t, ep2_t *q, ep_t *p, int m, bn_t a) {\n\tfp12_t l;\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep2_t *_q = RLC_ALLOCA(ep2_t, m);\n\tint i, j, len = bn_bits(a) + 1;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tif (m == 0) {\n\t\treturn;\n\t}\n\n\tfp12_null(l);\n\n\tRLC_TRY {\n\t\tfp12_new(l);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void pp_mil_k12(fp12_t r, ep2_t *t, ep2_t *q, ep_t *p, int m, bn_t a) {\n\tfp12_t l;\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep2_t *_q = RLC_ALLOCA(ep2_t, m);\n\tsize_t len = bn_bits(a) + 1;\n\tint i, j;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tif (m == 0) {\n\t\treturn;\n\t}\n\n\tfp12_null(l);\n\n\tRLC_TRY {\n\t\tfp12_new(l);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "CompileResult generateBytecodeForExecution(\n    Module &M,\n    const BytecodeGenerationOptions &genOptions) {\n  std::shared_ptr<Context> context = M.shareContext();\n  CompileResult result{Success};\n  if (cl::BytecodeFormat == cl::BytecodeFormatKind::HBC) {\n    result.bytecodeProvider = hbc::BCProviderFromSrc::createBCProviderFromSrc(\n        hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), genOptions));\n\n  } else {\n    llvm_unreachable(\"Invalid bytecode kind for execution\");\n    result = InvalidFlags;\n  }\n  return result;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "CompileResult generateBytecodeForExecution(\n    Module &M,\n    const BytecodeGenerationOptions &genOptions) {\n  std::shared_ptr<Context> context = M.shareContext();\n  CompileResult result{Success};\n  if (cl::BytecodeFormat == cl::BytecodeFormatKind::HBC) {\n    auto BM =\n        hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), genOptions);\n    if (auto N = context->getSourceErrorManager().getErrorCount()) {\n      llvh::errs() << \"Emitted \" << N << \" errors in the backend. exiting.\\n\";\n      return BackendError;\n    }\n\n    result.bytecodeProvider =\n        hbc::BCProviderFromSrc::createBCProviderFromSrc(std::move(BM));\n  } else {\n    llvm_unreachable(\"Invalid bytecode kind for execution\");\n    result = InvalidFlags;\n  }\n  return result;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "snmp_ber_encode_string_len(unsigned char *out, uint32_t *out_len, const char *str, uint32_t length)\n{\n  uint32_t i;\n\n  str += length - 1;\n  for(i = 0; i < length; ++i) {\n    (*out_len)++;\n    *out-- = (uint8_t)*str--;\n  }\n\n  out = snmp_ber_encode_length(out, out_len, length);\n  out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_OCTET_STRING);\n\n  return out;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "snmp_ber_encode_string_len(snmp_packet_t *snmp_packet, const char *str, uint32_t length)\n{\n  uint32_t i;\n\n  str += length - 1;\n  for(i = 0; i < length; ++i) {\n    if(snmp_packet->used == snmp_packet->max) {\n      return 0;\n    }\n\n    *snmp_packet->out-- = (uint8_t)*str--;\n    snmp_packet->used++;\n  }\n\n  if(!snmp_ber_encode_length(snmp_packet, length)) {\n    return 0;\n  }\n\n  if(!snmp_ber_encode_type(snmp_packet, BER_DATA_TYPE_OCTET_STRING)) {\n    return 0;\n  }\n\n  return 1;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int restrictedFile(const char *filename)\n{\n\tif (!live_dangerously && !strncasecmp(filename, \"/\", 1) &&\n\t\t strncasecmp(filename, ast_config_AST_CONFIG_DIR, strlen(ast_config_AST_CONFIG_DIR))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int restrictedFile(const char *filename)\n{\n\tchar *stripped_filename;\n\tRAII_VAR(char *, path, NULL, ast_free);\n\tRAII_VAR(char *, real_path, NULL, ast_free);\n\n\tif (live_dangerously) {\n\t\treturn 0;\n\t}\n\n\tstripped_filename = ast_strip(ast_strdupa(filename));\n\n\t/* If the file path starts with '/', don't prepend ast_config_AST_CONFIG_DIR */\n\tif (stripped_filename[0] == '/') {\n\t\treal_path = realpath(stripped_filename, NULL);\n\t} else {\n\t\tif (ast_asprintf(&path, \"%s/%s\", ast_config_AST_CONFIG_DIR, stripped_filename) == -1) {\n\t\t\treturn -1;\n\t\t}\n\t\treal_path = realpath(path, NULL);\n\t}\n\n\tif (!real_path) {\n\t\treturn -1;\n\t}\n\n\tif (!ast_begins_with(real_path, ast_config_AST_CONFIG_DIR)) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int lookup1_values(int entries, int dim)\n{\n   int r = (int) floor(exp((float) log((float) entries) / dim));\n   if ((int) floor(pow((float) r+1, dim)) <= entries)   // (int) cast for MinGW warning;\n      ++r;                                              // floor() to avoid _ftol() when non-CRT\n   assert(pow((float) r+1, dim) > entries);\n   assert((int) floor(pow((float) r, dim)) <= entries); // (int),floor() as above\n   return r;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int lookup1_values(int entries, int dim)\n{\n   int r = (int) floor(exp((float) log((float) entries) / dim));\n   if ((int) floor(pow((float) r+1, dim)) <= entries)   // (int) cast for MinGW warning;\n      ++r;                                              // floor() to avoid _ftol() when non-CRT\n   if (pow((float) r+1, dim) <= entries)\n      return -1;\n   if ((int) floor(pow((float) r, dim)) > entries)\n      return -1;\n   return r;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TEST_F(SQLiteUtilTests, test_column_type_determination) {\n  // Correct identification of text and ints\n  testTypesExpected(\"select path, inode from file where path like '%'\",\n                    TypeMap({{\"path\", TEXT_TYPE}, {\"inode\", INTEGER_TYPE}}));\n  // Correctly treating BLOBs as text\n  testTypesExpected(\"select CAST(seconds AS BLOB) as seconds FROM time\",\n                    TypeMap({{\"seconds\", TEXT_TYPE}}));\n  // Correctly treating ints cast as double as doubles\n  testTypesExpected(\"select CAST(seconds AS DOUBLE) as seconds FROM time\",\n                    TypeMap({{\"seconds\", DOUBLE_TYPE}}));\n  // Correctly treating bools as ints\n  testTypesExpected(\"select CAST(seconds AS BOOLEAN) as seconds FROM time\",\n                    TypeMap({{\"seconds\", INTEGER_TYPE}}));\n  // Correctly recognizing values from columns declared double as double, even\n  // if they happen to have integer value.  And also test multi-statement\n  // queries.\n  testTypesExpected(\n      \"CREATE TABLE test_types_table (username varchar(30) primary key, age \"\n      \"double);INSERT INTO test_types_table VALUES (\\\"mike\\\", 23); SELECT age \"\n      \"from test_types_table\",\n      TypeMap({{\"age\", DOUBLE_TYPE}}));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TEST_F(SQLiteUtilTests, test_sqlite_authorizer) {\n  auto rc = sqliteAuthorizer(\n      nullptr, SQLITE_ATTACH, nullptr, nullptr, nullptr, nullptr);\n  EXPECT_EQ(SQLITE_DENY, rc);\n\n  rc = sqliteAuthorizer(nullptr, 534, nullptr, nullptr, nullptr, nullptr);\n  EXPECT_EQ(SQLITE_DENY, rc);\n\n  rc = sqliteAuthorizer(\n      nullptr, SQLITE_SELECT, nullptr, nullptr, nullptr, nullptr);\n  EXPECT_EQ(SQLITE_OK, rc);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "{\n    unsigned long ssl_err = err;\n\n    if (err == SSL_ERROR_SSL) {\n\tssl_err = ERR_peek_error();\n    }\n\n    /* Dig for more from OpenSSL error queue */\n    SSLLogErrors(action, ret, err, len, ssock);\n\n    ssock->last_err = ssl_err;\n    return GET_STATUS_FROM_SSL_ERR(ssl_err);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "{\n    unsigned long ssl_err = err;\n\n    if (err == SSL_ERROR_SSL) {\n\tssl_err = ERR_peek_error();\n    }\n\n    /* Dig for more from OpenSSL error queue */\n    SSLLogErrors(action, ret, err, len, ssock);\n\n    if (ssock)\n\tssock->last_err = ssl_err;\n    return GET_STATUS_FROM_SSL_ERR(ssl_err);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "pickCopyFunc(TIFF* in, TIFF* out, uint16 bitspersample, uint16 samplesperpixel)\n{\n\tuint16 shortv;\n\tuint32 w, l, tw, tl;\n\tint bychunk;\n\n\t(void) TIFFGetField(in, TIFFTAG_PLANARCONFIG, &shortv);\n\tif (shortv != config && bitspersample != 8 && samplesperpixel > 1) {\n\t\tfprintf(stderr,\n\t\t    \"%s: Cannot handle different planar configuration w/ bits/sample != 8\\n\",\n\t\t    TIFFFileName(in));\n\t\treturn (NULL);\n\t}\n\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w);\n\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &l);\n\tif (!(TIFFIsTiled(out) || TIFFIsTiled(in))) {\n\t\tuint32 irps = (uint32) -1L;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "pickCopyFunc(TIFF* in, TIFF* out, uint16 bitspersample, uint16 samplesperpixel)\n{\n\tuint16 shortv;\n\tuint32 w, l, tw, tl;\n\tint bychunk;\n\n\t(void) TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &shortv);\n\tif (shortv != config && bitspersample != 8 && samplesperpixel > 1) {\n\t\tfprintf(stderr,\n\t\t    \"%s: Cannot handle different planar configuration w/ bits/sample != 8\\n\",\n\t\t    TIFFFileName(in));\n\t\treturn (NULL);\n\t}\n\tTIFFGetField(in, TIFFTAG_IMAGEWIDTH, &w);\n\tTIFFGetField(in, TIFFTAG_IMAGELENGTH, &l);\n\tif (!(TIFFIsTiled(out) || TIFFIsTiled(in))) {\n\t\tuint32 irps = (uint32) -1L;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tif (server->connrec->no_connect)\n\t\treturn;\n\n\tif (ip != NULL) {\n\t\town_ip = ip == NULL ? NULL :\n\t\t\t(IPADDR_IS_V6(ip) ? server->connrec->own_ip6 :\n\t\t\t server->connrec->own_ip4);\n\t\tport = server->connrec->proxy != NULL ?\n\t\t\tserver->connrec->proxy_port : server->connrec->port;\n\t\thandle = server->connrec->use_ssl ?\n\t\t\tnet_connect_ip_ssl(ip, port, own_ip, server->connrec->ssl_cert, server->connrec->ssl_pkey,\nserver->connrec->ssl_cafile, server->connrec->ssl_capath, server->connrec->ssl_verify) :\n\t\t\tnet_connect_ip(ip, port, own_ip);\n\t} else {\n\t\thandle = net_connect_unix(unix_socket);\n\t}\n\n\tif (handle == NULL) {\n\t\t/* failed */\n\t\terrmsg = g_strerror(errno);\n\t\terrmsg2 = NULL;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tif (server->connrec->no_connect)\n\t\treturn;\n\n\tif (ip != NULL) {\n\t\town_ip = ip == NULL ? NULL :\n\t\t\t(IPADDR_IS_V6(ip) ? server->connrec->own_ip6 :\n\t\t\t server->connrec->own_ip4);\n\t\tport = server->connrec->proxy != NULL ?\n\t\t\tserver->connrec->proxy_port : server->connrec->port;\n\t\thandle = server->connrec->use_ssl ?\n\t\t\tnet_connect_ip_ssl(ip, port, server->connrec->address, own_ip, server->connrec->ssl_cert, server->connrec->ssl_pkey,\nserver->connrec->ssl_cafile, server->connrec->ssl_capath, server->connrec->ssl_verify) :\n\t\t\tnet_connect_ip(ip, port, own_ip);\n\t} else {\n\t\thandle = net_connect_unix(unix_socket);\n\t}\n\n\tif (handle == NULL) {\n\t\t/* failed */\n\t\terrmsg = g_strerror(errno);\n\t\terrmsg2 = NULL;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\n\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n\t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n\t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\n\tif (sta_id >= IWLAGN_STATION_COUNT) {\n\t\tIWL_ERR(priv, \"invalid sta_id %u\", sta_id);\n\t\treturn -EINVAL;\n\t}\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n\t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n\t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t}\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "jiffies_to_timespec(const unsigned long jiffies, struct timespec *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &value->tv_nsec);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "jiffies_to_timespec(const unsigned long jiffies, struct timespec *value)\n{\n\t/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t */\n\tu32 rem;\n\tvalue->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,\n\t\t\t\t    NSEC_PER_SEC, &rem);\n\tvalue->tv_nsec = rem;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void follow_dotdot(struct nameidata *nd)\n{\n\tif (!nd->root.mnt)\n\t\tset_root(nd);\n\n\twhile(1) {\n\t\tstruct dentry *old = nd->path.dentry;\n\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\t/* rare case of legitimate dget_parent()... */\n\t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n\t\t\tdput(old);\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int follow_dotdot(struct nameidata *nd)\n{\n\tif (!nd->root.mnt)\n\t\tset_root(nd);\n\n\twhile(1) {\n\t\tstruct dentry *old = nd->path.dentry;\n\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\t/* rare case of legitimate dget_parent()... */\n\t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n\t\t\tdput(old);\n\t\t\tif (unlikely(!path_connected(&nd->path)))\n\t\t\t\treturn -ENOENT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\tprintf(\"[%d bytes in incomplete send packet]\\n\",\n\t\t\t       spkt.cnt);\n\t\t    if (rpkt.cnt > 0)\n\t\t\tprintf(\"[%d bytes in incomplete recv packet]\\n\",\n\t\t\t       rpkt.cnt);\n\t\t    exit(0);\n\t\tcase '~':\n\t\t    if (pkt->cnt > 0) {\n\t\t\tq = dir;\n\t\t\tif (pkt->esc) {\n\t\t\t    printf(\"%s aborted packet:\\n     \", dir);\n\t\t\t    q = \"    \";\n\t\t\t}\n\t\t\tnb = pkt->cnt;\n\t\t\tp = pkt->buf;\n\t\t\tpkt->cnt = 0;\n\t\t\tpkt->esc = 0;\n\t\t\tif (nb <= 2) {\n\t\t\t    printf(\"%s short packet [%d bytes]:\", q, nb);\n\t\t\t    for (k = 0; k < nb; ++k)\n\t\t\t\tprintf(\" %.2x\", p[k]);\n\t\t    if (!pkt->esc) {\n\t\t\tpkt->esc = 1;\n\t\t\tbreak;\n\t\t    }\n\t\t    /* else fall through */\n\t\tdefault:\n\t\t    if (pkt->esc) {\n\t\t\tc ^= 0x20;\n\t\t\tpkt->esc = 0;\n\t\t    }\n\t\t    pkt->buf[pkt->cnt++] = c;\n\t\t    break;\n\t\t}\n\t    }\n\t    break;\n\tcase 3:\n\tcase 4:\n\t    if (reverse)\n\t\tc = 7 - c;\n\t    dir = c==3? \"send\": \"recv\";\n\t    pkt = c==3? &spkt: &rpkt;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\t       spkt.cnt);\n\t\t    if (rpkt.cnt > 0)\n\t\t\tprintf(\"[%d bytes in incomplete recv packet]\\n\",\n\t\t\t       rpkt.cnt);\n\t\t    exit(0);\n\t\tcase '~':\n\t\t    if (pkt->cnt > 0) {\n\t\t\tq = dir;\n\t\t\tif (pkt->esc) {\n\t\t\t    printf(\"%s aborted packet:\\n     \", dir);\n\t\t\t    q = \"    \";\n\t\t\t}\n\t\t\tif (pkt->cnt >= sizeof(pkt->buf)) {\n\t\t\t    printf(\"%s over-long packet truncated:\\n     \", dir);\n\t\t\t    q = \"    \";\n\t\t\t}\n\t\t\tnb = pkt->cnt;\n\t\t\tp = pkt->buf;\n\t\t\tpkt->cnt = 0;\n\t\t\tpkt->esc = 0;\n\t\t\tif (nb <= 2) {\n\t\t\t    printf(\"%s short packet [%d bytes]:\", q, nb);\n\t\t\t    for (k = 0; k < nb; ++k)\n\t\t\t\tprintf(\" %.2x\", p[k]);\n\t\t    if (!pkt->esc) {\n\t\t\tpkt->esc = 1;\n\t\t\tbreak;\n\t\t    }\n\t\t    /* else fall through */\n\t\tdefault:\n\t\t    if (pkt->esc) {\n\t\t\tc ^= 0x20;\n\t\t\tpkt->esc = 0;\n\t\t    }\n\t\t    if (pkt->cnt < sizeof(pkt->buf))\n\t\t\tpkt->buf[pkt->cnt++] = c;\n\t\t    break;\n\t\t}\n\t    }\n\t    break;\n\tcase 3:\n\tcase 4:\n\t    if (reverse)\n\t\tc = 7 - c;\n\t    dir = c==3? \"send\": \"recv\";\n\t    pkt = c==3? &spkt: &rpkt;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    void resize (std::size_t new_size_) { _buf_size = new_size_; }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    void resize (std::size_t new_size_) { LIBZMQ_UNUSED (new_size_); }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static VALUE from_document(VALUE klass, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n\n  Data_Get_Struct(document, xmlDoc, doc);\n\n  /* In case someone passes us a node. ugh. */\n  doc = doc->doc;\n\n  ctx = xmlRelaxNGNewDocParserCtxt(doc);\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    xmlErrorPtr error = xmlGetLastError();\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n\n  return rb_schema;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static VALUE from_document(int argc, VALUE *argv, VALUE klass)\n{\n  VALUE document;\n  VALUE parse_options;\n  xmlDocPtr doc;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  int scanned_args = 0;\n\n  scanned_args = rb_scan_args(argc, argv, \"11\", &document, &parse_options);\n\n  Data_Get_Struct(document, xmlDoc, doc);\n  doc = doc->doc; /* In case someone passes us a node. ugh. */\n\n  if (scanned_args == 1) {\n    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n  }\n\n  ctx = xmlRelaxNGNewDocParserCtxt(doc);\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n#ifdef HAVE_XMLRELAXNGSETPARSERSTRUCTUREDERRORS\n  xmlRelaxNGSetParserStructuredErrors(\n    ctx,\n    Nokogiri_error_array_pusher,\n    if(error)\n      Nokogiri_error_raise(NULL, error);\n    else\n      rb_raise(rb_eRuntimeError, \"Could not parse document\");\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n\n  return rb_schema;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "        int          Read(void* pDestBuffer, int nSize)\n        {\n            if ( m_nPos + nSize >= m_nLen )\n                nSize = m_nLen - m_nPos - 1;\n\n            memcpy( pDestBuffer, (m_sFile + m_nPos), nSize );\n            m_nPos += nSize;\n\n            return nSize;\n        }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "        int          Read(void* pDestBuffer, unsigned int nSize)\n        {\n            if (m_nPos >= m_nLen)\n                nSize = 0;\n            else if (nSize > (m_nLen - m_nPos))\n                nSize = m_nLen - m_nPos;\n\n            memcpy( pDestBuffer, (m_sFile + m_nPos), nSize );\n            m_nPos += nSize;\n\n            return nSize;\n        }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    const uint64_t shift2  = 2 * shift;\n#define MAX_STRIDE 4096U\n#define MAX_H 8U\n    uint8_t edge_buf[(MAX_H + 1) * MAX_STRIDE];\n    int x, y;\n\n    const int dxw = (dxx - (1 << (16 + shift))) * (w - 1);\n    const int dyh = (dyy - (1 << (16 + shift))) * (h - 1);\n    const int dxh = dxy * (h - 1);\n    const int dyw = dyx * (w - 1);\n    int need_emu  =  (unsigned) ix >= width  - w ||\n                     (unsigned) iy >= height - h;\n\n    if ( // non-constant fullpel offset (3% of blocks)\n        ((ox ^ (ox + dxw)) | (ox ^ (ox + dxh)) | (ox ^ (ox + dxw + dxh)) |\n         (oy ^ (oy + dyw)) | (oy ^ (oy + dyh)) | (oy ^ (oy + dyw + dyh))) >> (16 + shift) ||\n        // uses more than 16 bits of subpel mv (only at huge resolution)\n        (dxx | dxy | dyx | dyy) & 15 ||\n        (need_emu && (h > MAX_H || stride > MAX_STRIDE))) {\n        // FIXME could still use mmx for some of the rows\n        ff_gmc_c(dst, src, stride, h, ox, oy, dxx, dxy, dyx, dyy,\n                 shift, r, width, height);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    const uint64_t shift2  = 2 * shift;\n#define MAX_STRIDE 4096U\n#define MAX_H 8U\n    uint8_t edge_buf[(MAX_H + 1) * MAX_STRIDE];\n    int x, y;\n\n    const int dxw = (dxx - (1 << (16 + shift))) * (w - 1);\n    const int dyh = (dyy - (1 << (16 + shift))) * (h - 1);\n    const int dxh = dxy * (h - 1);\n    const int dyw = dyx * (w - 1);\n    int need_emu  =  (unsigned) ix >= width  - w || width < w ||\n                     (unsigned) iy >= height - h || height< h\n                     ;\n\n    if ( // non-constant fullpel offset (3% of blocks)\n        ((ox ^ (ox + dxw)) | (ox ^ (ox + dxh)) | (ox ^ (ox + dxw + dxh)) |\n         (oy ^ (oy + dyw)) | (oy ^ (oy + dyh)) | (oy ^ (oy + dyw + dyh))) >> (16 + shift) ||\n        // uses more than 16 bits of subpel mv (only at huge resolution)\n        (dxx | dxy | dyx | dyy) & 15 ||\n        (need_emu && (h > MAX_H || stride > MAX_STRIDE))) {\n        // FIXME could still use mmx for some of the rows\n        ff_gmc_c(dst, src, stride, h, ox, oy, dxx, dxy, dyx, dyy,\n                 shift, r, width, height);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n  output->type = input->type;\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input->dims);\n  return context->ResizeTensor(context, output, output_size);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n  output->type = input->type;\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input->dims);\n  return context->ResizeTensor(context, output, output_size);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t    TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) {\n\t\tuint32 s;\n\n\t\tfprintf(fd, \"  %lu %s:\\n\",\n\t\t    (unsigned long) td->td_nstrips,\n\t\t    isTiled(tif) ? \"Tiles\" : \"Strips\");\n\t\tfor (s = 0; s < td->td_nstrips; s++)\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tfprintf(fd, \"    %3lu: [%8I64u, %8I64u]\\n\",\n\t\t\t    (unsigned long) s,\n\t\t\t    (unsigned __int64) td->td_stripoffset[s],\n\t\t\t    (unsigned __int64) td->td_stripbytecount[s]);\n#else\n\t\t\tfprintf(fd, \"    %3lu: [%8llu, %8llu]\\n\",\n\t\t\t    (unsigned long) s,\n\t\t\t    (unsigned long long) td->td_stripoffset[s],\n\t\t\t    (unsigned long long) td->td_stripbytecount[s]);\n#endif\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t    TIFFFieldSet(tif,FIELD_STRIPOFFSETS)) {\n\t\tuint32 s;\n\n\t\tfprintf(fd, \"  %lu %s:\\n\",\n\t\t    (unsigned long) td->td_nstrips,\n\t\t    isTiled(tif) ? \"Tiles\" : \"Strips\");\n\t\tfor (s = 0; s < td->td_nstrips; s++)\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tfprintf(fd, \"    %3lu: [%8I64u, %8I64u]\\n\",\n\t\t\t    (unsigned long) s,\n\t\t\t    td->td_stripoffset ? (unsigned __int64) td->td_stripoffset[s] : 0,\n\t\t\t    td->td_stripbytecount ? (unsigned __int64) td->td_stripbytecount[s] : 0);\n#else\n\t\t\tfprintf(fd, \"    %3lu: [%8llu, %8llu]\\n\",\n\t\t\t    (unsigned long) s,\n\t\t\t    td->td_stripoffset ? (unsigned long long) td->td_stripoffset[s] : 0,\n\t\t\t    td->td_stripbytecount ? (unsigned long long) td->td_stripbytecount[s] : 0);\n#endif\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "        bool selectedEffect=selectedRow && (j32+index-1>=sel1XSum && j32+index-1<=sel2XSum);\n        bool selectedEffectVal=selectedRow && (j32+index>=sel1XSum && j32+index<=sel2XSum);\n        bool cursorEffect=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index-1);\n        bool cursorEffectVal=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index);\n        \n        // effect\n        if (pat->data[i][index]==-1) {\n          sprintf(id,\"..##PE%d_%d_%d\",k,i,j);\n          ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        } else {\n          sprintf(id,\"%.2X##PE%d_%d_%d\",pat->data[i][index],k,i,j);\n          if (pat->data[i][index]<0x10) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[pat->data[i][index]]]);\n          } else if (pat->data[i][index]<0x20) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n          } else if (pat->data[i][index]<0x30) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);\n          } else if (pat->data[i][index]<0x48) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n          } else if (pat->data[i][index]<0x90) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else if (pat->data[i][index]<0xa0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);\n          } else if (pat->data[i][index]<0xc0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else if (pat->data[i][index]<0xd0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);\n          } else if (pat->data[i][index]<0xe0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[pat->data[i][index]-0xe0]]);\n          }\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffect) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  \n          ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n          ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n          ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          demandX=ImGui::GetCursorPosX();\n          ImGui::PopStyleColor(3);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "        bool selectedEffect=selectedRow && (j32+index-1>=sel1XSum && j32+index-1<=sel2XSum);\n        bool selectedEffectVal=selectedRow && (j32+index>=sel1XSum && j32+index<=sel2XSum);\n        bool cursorEffect=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index-1);\n        bool cursorEffectVal=(cursor.y==i && cursor.xCoarse==j && cursor.xFine==index);\n        \n        // effect\n        if (pat->data[i][index]==-1) {\n          sprintf(id,\"..##PE%d_%d_%d\",k,i,j);\n          ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        } else {\n          if (pat->data[i][index]>0xff) {\n            sprintf(id,\"??##PE%d_%d_%d\",k,i,j);\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else {\n            const unsigned char data=pat->data[i][index];\n            sprintf(id,\"%.2X##PE%d_%d_%d\",data,k,i,j);\n            if (data<0x10) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[data]]);\n            } else if (data<0x20) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n            } else if (data<0x30) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);\n            } else if (data<0x48) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n            } else if (data<0x90) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else if (data<0xa0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);\n            } else if (data<0xc0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else if (data<0xd0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);\n            } else if (data<0xe0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[data-0xe0]]);\n            }\n          }\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffect) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  \n          ImGui::PushStyleColor(ImGuiCol_HeaderActive,uiColors[GUI_COLOR_PATTERN_CURSOR_ACTIVE]);\n          ImGui::PushStyleColor(ImGuiCol_HeaderHovered,uiColors[GUI_COLOR_PATTERN_CURSOR_HOVER]);\n          ImGui::Selectable(id,true,ImGuiSelectableFlags_NoPadWithHalfSpacing,twoChars);\n          demandX=ImGui::GetCursorPosX();\n          ImGui::PopStyleColor(3);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint16* wp = (uint16*) cp0;\n\ttmsize_t wc = cc / 2;\n\n\tassert((cc%(2*stride))==0);\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] + (unsigned int)wp[0]) & 0xffff); wp++)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint16* wp = (uint16*) cp0;\n\ttmsize_t wc = cc / 2;\n\n    if((cc%(2*stride))!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"horAcc16\",\n                     \"%s\", \"cc%(2*stride))!=0\");\n        return 0;\n    }\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] + (unsigned int)wp[0]) & 0xffff); wp++)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n\treturn 1;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "PJ_DEF(pj_status_t) pjstun_parse_msg( void *buf, pj_size_t buf_len, \n\t\t\t\t      pjstun_msg *msg)\n{\n    pj_uint16_t msg_type, msg_len;\n    char *p_attr;\n\n    PJ_CHECK_STACK();\n\n    msg->hdr = (pjstun_msg_hdr*)buf;\n    msg_type = pj_ntohs(msg->hdr->type);\n\n    switch (msg_type) {\n    case PJSTUN_BINDING_REQUEST:\n    case PJSTUN_BINDING_RESPONSE:\n    case PJSTUN_BINDING_ERROR_RESPONSE:\n    msg_len = pj_ntohs(msg->hdr->length);\n    if (msg_len != buf_len - sizeof(pjstun_msg_hdr)) {\n\tPJ_LOG(4,(THIS_FILE, \"Error: invalid msg_len %d (expecting %d)\", \n\t\t\t     msg_len, buf_len - sizeof(pjstun_msg_hdr)));\n\treturn PJLIB_UTIL_ESTUNINMSGLEN;\n    }\n\n    msg->attr_count = 0;\n    p_attr = (char*)buf + sizeof(pjstun_msg_hdr);\n\n    while (msg_len > 0) {\n\tpjstun_attr_hdr **attr = &msg->attr[msg->attr_count];\n\tpj_uint32_t len;\n\tpj_uint16_t attr_type;\n\n\t*attr = (pjstun_attr_hdr*)p_attr;\n\tlen = pj_ntohs((pj_uint16_t) ((*attr)->length)) + sizeof(pjstun_attr_hdr);\n\tlen = (len + 3) & ~3;\n\n\tif (msg_len < len) {\n\t    PJ_LOG(4,(THIS_FILE, \"Error: length mismatch in attr %d\", \n\t    attr_type != PJSTUN_ATTR_XOR_MAPPED_ADDR)\n\t{\n\t    PJ_LOG(5,(THIS_FILE, \"Warning: unknown attr type %x in attr %d. \"\n\t\t\t\t \"Attribute was ignored.\",\n\t\t\t\t attr_type, msg->attr_count));\n\t}\n\n\tmsg_len = (pj_uint16_t)(msg_len - len);\n\tp_attr += len;\n\t++msg->attr_count;\n    }\n\n    return PJ_SUCCESS;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "PJ_DEF(pj_status_t) pjstun_parse_msg( void *buf, pj_size_t buf_len, \n\t\t\t\t      pjstun_msg *msg)\n{\n    pj_uint16_t msg_type, msg_len;\n    char *p_attr;\n    int attr_max_cnt = PJ_ARRAY_SIZE(msg->attr);\n\n    PJ_CHECK_STACK();\n\n    msg->hdr = (pjstun_msg_hdr*)buf;\n    msg_type = pj_ntohs(msg->hdr->type);\n\n    switch (msg_type) {\n    case PJSTUN_BINDING_REQUEST:\n    case PJSTUN_BINDING_RESPONSE:\n    case PJSTUN_BINDING_ERROR_RESPONSE:\n    msg_len = pj_ntohs(msg->hdr->length);\n    if (msg_len != buf_len - sizeof(pjstun_msg_hdr)) {\n\tPJ_LOG(4,(THIS_FILE, \"Error: invalid msg_len %d (expecting %d)\", \n\t\t\t     msg_len, buf_len - sizeof(pjstun_msg_hdr)));\n\treturn PJLIB_UTIL_ESTUNINMSGLEN;\n    }\n\n    msg->attr_count = 0;\n    p_attr = (char*)buf + sizeof(pjstun_msg_hdr);\n\n    while (msg_len > 0 && msg->attr_count < attr_max_cnt) {\n\tpjstun_attr_hdr **attr = &msg->attr[msg->attr_count];\n\tpj_uint32_t len;\n\tpj_uint16_t attr_type;\n\n\t*attr = (pjstun_attr_hdr*)p_attr;\n\tlen = pj_ntohs((pj_uint16_t) ((*attr)->length)) + sizeof(pjstun_attr_hdr);\n\tlen = (len + 3) & ~3;\n\n\tif (msg_len < len) {\n\t    PJ_LOG(4,(THIS_FILE, \"Error: length mismatch in attr %d\", \n\t{\n\t    PJ_LOG(5,(THIS_FILE, \"Warning: unknown attr type %x in attr %d. \"\n\t\t\t\t \"Attribute was ignored.\",\n\t\t\t\t attr_type, msg->attr_count));\n\t}\n\n\tmsg_len = (pj_uint16_t)(msg_len - len);\n\tp_attr += len;\n\t++msg->attr_count;\n    }\n    if (msg->attr_count == attr_max_cnt) {\n\tPJ_LOG(4, (THIS_FILE, \"Warning: max number attribute %d reached.\",\n\t\t   attr_max_cnt));\n    }\n\n    return PJ_SUCCESS;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "   DhcpMessage *message;\n   DhcpOption *option;\n\n   //Point to the DHCP client context\n   context = (DhcpClientContext *) param;\n\n   //Retrieve the length of the DHCP message\n   length = netBufferGetLength(buffer) - offset;\n\n   //Make sure the DHCP message is valid\n   if(length < sizeof(DhcpMessage))\n      return;\n   if(length > DHCP_MAX_MSG_SIZE)\n      return;\n\n   //Point to the beginning of the DHCP message\n   message = netBufferAt(buffer, offset);\n   //Sanity check\n   if(message == NULL)\n      return;\n\n   //Debug message\n   TRACE_DEBUG(\"\\r\\n%s: DHCP message received (%\" PRIuSIZE \" bytes)...\\r\\n\",\n      formatSystemTime(osGetSystemTime(), NULL), length);\n\n   //Dump the contents of the message for debugging purpose\n   dhcpDumpMessage(message, length);\n\n   //The DHCP server shall respond with a BOOTREPLY opcode\n   if(message->op != DHCP_OPCODE_BOOTREPLY)\n      return;\n   //Enforce hardware type\n   if(message->htype != DHCP_HARDWARE_TYPE_ETH)\n      return;\n   //Check the length of the hardware address\n   if(message->hlen != sizeof(MacAddr))\n      return;\n   //Check magic cookie\n   if(message->magicCookie != HTONL(DHCP_MAGIC_COOKIE))\n      return;\n\n   //The DHCP Message Type option must be included in every DHCP message\n   option = dhcpGetOption(message, length, DHCP_OPT_DHCP_MESSAGE_TYPE);\n\n   //Failed to retrieve the Message Type option?\n   if(option == NULL || option->length != 1)\n      return;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "   DhcpMessage *message;\n   DhcpOption *option;\n\n   //Point to the DHCP client context\n   context = (DhcpClientContext *) param;\n\n   //Retrieve the length of the DHCP message\n   length = netBufferGetLength(buffer) - offset;\n\n   //Make sure the DHCP message is valid\n   if(length < sizeof(DhcpMessage) || length > DHCP_MAX_MSG_SIZE)\n      return;\n\n   //Point to the beginning of the DHCP message\n   message = netBufferAt(buffer, offset);\n   //Sanity check\n   if(message == NULL)\n      return;\n\n   //Debug message\n   TRACE_DEBUG(\"\\r\\n%s: DHCP message received (%\" PRIuSIZE \" bytes)...\\r\\n\",\n      formatSystemTime(osGetSystemTime(), NULL), length);\n\n   //Dump the contents of the message for debugging purpose\n   dhcpDumpMessage(message, length);\n\n   //The DHCP server shall respond with a BOOTREPLY opcode\n   if(message->op != DHCP_OPCODE_BOOTREPLY)\n      return;\n\n   //Enforce hardware type\n   if(message->htype != DHCP_HARDWARE_TYPE_ETH)\n      return;\n\n   //Check the length of the hardware address\n   if(message->hlen != sizeof(MacAddr))\n      return;\n\n   //Check magic cookie\n   if(message->magicCookie != HTONL(DHCP_MAGIC_COOKIE))\n      return;\n\n   //The DHCP Message Type option must be included in every DHCP message\n   option = dhcpGetOption(message, length, DHCP_OPT_DHCP_MESSAGE_TYPE);\n\n   //Failed to retrieve the Message Type option?\n   if(option == NULL || option->length != 1)\n      return;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void bn_rec_naf(int8_t *naf, int *len, const bn_t k, int w) {\n\tint i, l;\n\tbn_t t;\n\tdig_t t0, mask;\n\tint8_t u_i;\n\n\tif (*len < (bn_bits(k) + 1)) {\n\t\t*len = 0;\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void bn_rec_naf(int8_t *naf, size_t *len, const bn_t k, size_t w) {\n\tint i, l;\n\tbn_t t;\n\tdig_t t0, mask;\n\tint8_t u_i;\n\n\tif (*len < (bn_bits(k) + 1)) {\n\t\t*len = 0;\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "            s->lookahead--;\n            s->strstart++;\n        }\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "            s->lookahead--;\n            s->strstart++;\n        }\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->sym_next)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void luaT_adjustvarargs (lua_State *L, int nfixparams, CallInfo *ci,\n                         const Proto *p) {\n  int i;\n  int actual = cast_int(L->top - ci->func) - 1;  /* number of arguments */\n  int nextra = actual - nfixparams;  /* number of extra arguments */\n  ci->u.l.nextraargs = nextra;\n  checkstackGC(L, p->maxstacksize + 1);\n  /* copy function to the top of the stack */\n  setobjs2s(L, L->top++, ci->func);\n  /* move fixed parameters to the top of the stack */\n  for (i = 1; i <= nfixparams; i++) {\n    setobjs2s(L, L->top++, ci->func + i);\n    setnilvalue(s2v(ci->func + i));  /* erase original parameter (for GC) */\n  }\n  ci->func += actual + 1;\n  ci->top += actual + 1;\n  lua_assert(L->top <= ci->top && ci->top <= L->stack_last);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void luaT_adjustvarargs (lua_State *L, int nfixparams, CallInfo *ci,\n                         const Proto *p) {\n  int i;\n  int actual = cast_int(L->top - ci->func) - 1;  /* number of arguments */\n  int nextra = actual - nfixparams;  /* number of extra arguments */\n  ci->u.l.nextraargs = nextra;\n  luaD_checkstack(L, p->maxstacksize + 1);\n  /* copy function to the top of the stack */\n  setobjs2s(L, L->top++, ci->func);\n  /* move fixed parameters to the top of the stack */\n  for (i = 1; i <= nfixparams; i++) {\n    setobjs2s(L, L->top++, ci->func + i);\n    setnilvalue(s2v(ci->func + i));  /* erase original parameter (for GC) */\n  }\n  ci->func += actual + 1;\n  ci->top += actual + 1;\n  lua_assert(L->top <= ci->top && ci->top <= L->stack_last);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tbreak;\n\t    }\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'T':\n\t  {\n\t    time_t t;\n\t    struct tm *lt;\n\t    const char *tstring;\n\t    char buffer[sizeof(\"Www Mmm dd hh:mm:ss yyyyy\\n\")];\n\t    uint32_t x;\n\n\t    switch (atoi(fmt + 1)) {\n\t    case 1:\n\t\tx = GET_LE_U_4(buf);\n\t\tif (x == 0 || x == 0xFFFFFFFF)\n\t\t    t = 0;\n\t\telse\n\t\t    t = make_unix_date(ndo, buf);\n\t\tbuf += 4;\n\t    case 3:\n\t\tND_TCHECK_8(buf);\n\t\tt = interpret_long_date(ndo, buf);\n\t\tbuf += 8;\n\t\tbreak;\n\t    default:\n\t\tt = 0;\n\t\tbreak;\n\t    }\n\t    if (t != 0) {\n\t\tlt = localtime(&t);\n\t\tif (lt != NULL) {\n\t\t    strftime(buffer, sizeof(buffer), \"%a %b %e %T %Y%n\", lt);\n\t\t    tstring = buffer;\n\t\t}\n\t\telse\n\t\t    tstring = \"(Can't convert time)\\n\";\n\t    } else\n\t\ttstring = \"NULL\\n\";\n\t    ND_PRINT(\"%s\", tstring);\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tdefault:\n\t    ND_PRINT(\"%c\", *fmt);\n\t    fmt++;\n\t    break;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tbuf += 16;\n\t\tbreak;\n\t    }\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'T':\n\t  {\n\t    time_t t;\n\t    const char *tstring;\n\t    char buffer[sizeof(\"Www Mmm dd hh:mm:ss yyyyy\")];\n\t    uint32_t x;\n\n\t    switch (atoi(fmt + 1)) {\n\t    case 1:\n\t\tx = GET_LE_U_4(buf);\n\t\tif (x == 0 || x == 0xFFFFFFFF)\n\t\t    t = 0;\n\t\telse\n\t\t    t = make_unix_date(ndo, buf);\n\t\tbuf += 4;\n\t    case 3:\n\t\tND_TCHECK_8(buf);\n\t\tt = interpret_long_date(ndo, buf);\n\t\tbuf += 8;\n\t\tbreak;\n\t    default:\n\t\tt = 0;\n\t\tbreak;\n\t    }\n\t    if (t != 0) {\n\t\t    tstring = nd_format_time(buffer, sizeof(buffer), \"%a %b %e %T %Y\",\n\t\t    localtime(&t));\n\t    } else\n\t\ttstring = \"NULL\";\n\t    ND_PRINT(\"%s\\n\", tstring);\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }\n\tdefault:\n\t    ND_PRINT(\"%c\", *fmt);\n\t    fmt++;\n\t    break;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int l2tp_recv(int fd, struct l2tp_packet_t **p, struct in_pktinfo *pkt_info,\n\t      const char *secret, size_t secret_len)\n{\n\tint n, length;\n\tuint8_t *buf;\n\tstruct l2tp_hdr_t *hdr;\n\tstruct l2tp_avp_t *avp;\n\tstruct l2tp_dict_attr_t *da;\n\tstruct l2tp_attr_t *attr, *RV = NULL;\n\tuint8_t *ptr;\n\tstruct l2tp_packet_t *pack;\n\tstruct sockaddr_in addr;\n\tsocklen_t len = sizeof(addr);\n\tstruct msghdr msg;\n\tchar msg_control[128];\n\tstruct cmsghdr *cmsg;\n\tuint16_t orig_avp_len;\n\tvoid *orig_avp_val;\n\n  *p = NULL;\n\n\tif (pkt_info) {\n\t\tmemset(&msg, 0, sizeof(msg));\n\t\tmsg.msg_control = msg_control;\n\t\tmsg.msg_controllen = 128;\n\n\t\tn = recvmsg(fd, &msg, MSG_PEEK);\n\n\t\tif (n < 0) {\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn -1;\n\t\t\tlog_error(\"l2tp: recvmsg: %s\\n\", strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\t\t\tif (cmsg->cmsg_level == IPPROTO_IP && cmsg->cmsg_type == IP_PKTINFO) {\n\t\t\t\tmemcpy(pkt_info, CMSG_DATA(cmsg), sizeof(*pkt_info));\n\t}\n\n\tbuf = mempool_alloc(buf_pool);\n\tif (!buf) {\n\t\tlog_emerg(\"l2tp: out of memory\\n\");\n\t\treturn 0;\n\t}\n\thdr = (struct l2tp_hdr_t *)buf;\n\tptr = (uint8_t *)(hdr + 1);\n\n\tn = recvfrom(fd, buf, L2TP_MAX_PACKET_SIZE, 0, &addr, &len);\n\n\tif (n < 0) {\n\t\tmempool_free(buf);\n\t\tif (errno == EAGAIN) {\n\t\t\treturn -1;\n\t\t} else if (errno == ECONNREFUSED) {\n\t\t\treturn -2;\n\t\t}\n\t\tlog_error(\"l2tp: recv: %s\\n\", strerror(errno));\n\t\treturn 0;\n\t}\n\n\tif (n < 6) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: short packet received (%i/%zu)\\n\", n, sizeof(*hdr));\n\t\tgoto out_err_hdr;\n\t}\n\n\tif (hdr->T == 0)\n\t\tgoto out_err_hdr;\n\n\tif (n < ntohs(hdr->length)) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: short packet received (%i/%i)\\n\", n, ntohs(hdr->length));\n\t\tgoto out_err_hdr;\n\t}\n\n\tif (hdr->ver == 2) {\n\t\tif (hdr->L == 0) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect message received (L=0)\\n\");\n\t\t\tif (!conf_avp_permissive)\n\t\t\t    goto out_err_hdr;\n\t\t}\n\n\t\tif (hdr->S == 0) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect message received (S=0)\\n\");\n\t\t\tif (!conf_avp_permissive)\n\t\t\t    goto out_err_hdr;\n\t\t}\n\n\t\tif (hdr->O == 1) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect message received (O=1)\\n\");\n\t\t\tif (!conf_avp_permissive)\n\t\t\t    goto out_err_hdr;\n\t\t}\n\t} else if (hdr->ver != 3) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: protocol version %i is not supported\\n\", hdr->ver);\n\t\tgoto out_err_hdr;\n\t}\n\n\tpack = mempool_alloc(pack_pool);\n\tif (!pack) {\n\t\tlog_emerg(\"l2tp: out of memory\\n\");\n\t\tgoto out_err_hdr;\n\t}\n\n\tmemset(pack, 0, sizeof(*pack));\n\tINIT_LIST_HEAD(&pack->attrs);\n\n\tmemcpy(&pack->addr, &addr, sizeof(addr));\n\tmemcpy(&pack->hdr, hdr, sizeof(*hdr));\n\tlength = ntohs(hdr->length) - sizeof(*hdr);\n\n\twhile (length) {\n\t\t*(uint16_t *)ptr = ntohs(*(uint16_t *)ptr);\n\t\tavp = (struct l2tp_avp_t *)ptr;\n\n\t\tif (avp->length > length) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect avp received (exceeds message length)\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (avp->vendor)\n\t\t\tgoto skip;\n\n\t\tda = l2tp_dict_find_attr_by_id(ntohs(avp->type));\n\t\tif (!da) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: unknown avp received (type=%i, M=%u)\\n\", ntohs(avp->type), avp->M);\n\t\t\tif (avp->M && !conf_avp_permissive)\n\t\t\t\tgoto out_err;\n\t\t} else {\n\t\t\tif (da->M != -1 && da->M != avp->M) {\n\t\t\t\tif (conf_verbose)\n\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, M=%i, must be %i)\\n\", ntohs(avp->type), avp->M, da->M);\n\t\t\t\tif (!conf_avp_permissive)\n\t\t\t\t    goto out_err;\n\t\t\t}\n\n\t\t\tif (da->H != -1 && da->H != avp->H) {\n\t\t\t\tif (conf_verbose)\n\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, H=%i, must be %i)\\n\", ntohs(avp->type), avp->H, da->H);\n\t\t\t\tif (!conf_avp_permissive)\n\t\t\t\t    goto out_err;\n\t\t\t}\n\n\t\t\tif (avp->H) {\n\t\t\t\tif (!RV) {\n\t\t\t\t\tif (conf_verbose)\n\t\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, H=1, but Random-Vector is not received)\\n\", ntohs(avp->type));\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tif (secret == NULL || secret_len == 0) {\n\t\t\t\t\tlog_error(\"l2tp: impossible to decode\"\n\t\t\t\t\t\t  \" hidden avp (type %hu): no\"\n\t\t\t\t\t\t  \" secret set)\\n\",\n\t\t\t\t\t\t  ntohs(avp->type));\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tif (decode_avp(avp, RV, secret, secret_len) < 0)\n\t\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\tattr = mempool_alloc(attr_pool);\n\t\t\tmemset(attr, 0, sizeof(*attr));\n\t\t\tlist_add_tail(&attr->entry, &pack->attrs);\n\n\t\t\tif (avp->H) {\n\t\t\t\torig_avp_len = ntohs(*(uint16_t *)avp->val) + sizeof(*avp);\n\t\t\t\torig_avp_val = avp->val + sizeof(uint16_t);\n\t\t\t} else {\n\t\t\t\torig_avp_len = avp->length;\n\t\t\t\torig_avp_val = avp->val;\n\t\t\t}\n\n\t\t\tattr->attr = da;\n\t\t\tattr->M = avp->M;\n\t\t\tattr->H = 0;\n\t\t\tattr->length = orig_avp_len - sizeof(*avp);\n\n\t\t\tif (attr->attr->id == Random_Vector)\n\t\t\t\tRV = attr;\n\n\t\t\tswitch (da->type) {\n\t\t\t\tcase ATTR_TYPE_INT16:\n\t\t\t\t\tif (orig_avp_len != sizeof(*avp) + 2)\n\t\t\t\t\t\tgoto out_err_len;\n\t\t\t\t\tattr->val.uint16 = ntohs(*(uint16_t *)orig_avp_val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\tattr->val.string = _malloc(attr->length + 1);\n\t\t\t\t\tif (!attr->val.string)\n\t\t\t\t\t\tgoto out_err_mem;\n\t\t\t\t\tmemcpy(attr->val.string, orig_avp_val, attr->length);\n\t\t\t\t\tattr->val.string[attr->length] = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nskip:\n\t\tptr += avp->length;\n\t\tlength -= avp->length;\n\t}\n\n\t*p = pack;\n\n\tmempool_free(buf);\n\n\treturn 0;\n\nout_err:\n\tl2tp_packet_free(pack);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int l2tp_recv(int fd, struct l2tp_packet_t **p, struct in_pktinfo *pkt_info,\n\t      const char *secret, size_t secret_len)\n{\n\tstruct l2tp_packet_t *pack;\n\tstruct l2tp_hdr_t *hdr;\n\tstruct l2tp_avp_t *avp;\n\tstruct l2tp_attr_t *RV = NULL;\n\tstruct sockaddr_in addr;\n\tsocklen_t addr_len;\n\tuint16_t orig_avp_len;\n\tvoid *orig_avp_val;\n\tuint8_t *buf, *ptr;\n\tint n, length;\n\n\t*p = NULL;\n\n\tif (pkt_info) {\n\t\tstruct msghdr msg;\n\t\tstruct cmsghdr *cmsg;\n\t\tchar msg_control[128];\n\n\t\tmemset(&msg, 0, sizeof(msg));\n\t\tmsg.msg_control = msg_control;\n\t\tmsg.msg_controllen = sizeof(msg_control);\n\n\t\tn = recvmsg(fd, &msg, MSG_PEEK);\n\t\tif (n < 0) {\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn -1;\n\t\t\tlog_error(\"l2tp: recvmsg: %s\\n\", strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (cmsg = CMSG_FIRSTHDR(&msg); cmsg != NULL; cmsg = CMSG_NXTHDR(&msg, cmsg)) {\n\t\t\tif (cmsg->cmsg_level == IPPROTO_IP && cmsg->cmsg_type == IP_PKTINFO) {\n\t\t\t\tmemcpy(pkt_info, CMSG_DATA(cmsg), sizeof(*pkt_info));\n\t}\n\n\tbuf = mempool_alloc(buf_pool);\n\tif (!buf) {\n\t\tlog_emerg(\"l2tp: out of memory\\n\");\n\t\treturn 0;\n\t}\n\thdr = (struct l2tp_hdr_t *)buf;\n\tptr = (uint8_t *)(hdr + 1);\n\n\taddr_len = sizeof(addr);\n\tn = recvfrom(fd, buf, L2TP_MAX_PACKET_SIZE, 0, &addr, &addr_len);\n\tif (n < 0) {\n\t\tmempool_free(buf);\n\t\tif (errno == EAGAIN) {\n\t\t\treturn -1;\n\t\t} else if (errno == ECONNREFUSED) {\n\t\t\treturn -2;\n\t\t}\n\t\tlog_error(\"l2tp: recv: %s\\n\", strerror(errno));\n\t\treturn 0;\n\t}\n\n\tif (n < sizeof(*hdr)) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: short packet received (%i/%zu)\\n\", n, sizeof(*hdr));\n\t\tgoto out_err_hdr;\n\t}\n\n\thdr->flags = ntohs(hdr->flags);\n\tif (!(hdr->flags & L2TP_FLAG_T))\n\t\tgoto out_err_hdr;\n\tif (!(hdr->flags & L2TP_FLAG_L)) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: incorrect control message received (L=0)\\n\");\n\t\tgoto out_err_hdr;\n\t}\n\tif (!(hdr->flags & L2TP_FLAG_S)) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: incorrect control message received (S=0)\\n\");\n\t\tgoto out_err_hdr;\n\t}\n\tswitch (hdr->flags & L2TP_VER_MASK) {\n\tcase 2:\n\t\tif (hdr->flags & L2TP_FLAG_O) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect control message received (O=1)\\n\");\n\t\t\tgoto out_err_hdr;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tbreak;\n\tdefault:\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: protocol version %i is not supported\\n\",\n\t\t\t\t hdr->flags & L2TP_VER_MASK);\n\t\tgoto out_err_hdr;\n\t}\n\n\tlength = ntohs(hdr->length);\n\tif (length < sizeof(*hdr)) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: short packet received (%i/%zu)\\n\", length, sizeof(*hdr));\n\t\tgoto out_err_hdr;\n\t} else if (n < length) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: short packet received (%i/%i)\\n\", n, length);\n\t\tgoto out_err_hdr;\n\t}\n\n\tpack = mempool_alloc(pack_pool);\n\tif (!pack) {\n\t\tlog_emerg(\"l2tp: out of memory\\n\");\n\t\tgoto out_err_hdr;\n\t}\n\n\tmemset(pack, 0, sizeof(*pack));\n\tINIT_LIST_HEAD(&pack->attrs);\n\n\tmemcpy(&pack->addr, &addr, sizeof(addr));\n\tmemcpy(&pack->hdr, hdr, sizeof(*hdr));\n\tlength -= sizeof(*hdr);\n\n\twhile (length > 0) {\n\t\tstruct l2tp_dict_attr_t *da;\n\t\tstruct l2tp_attr_t *attr;\n\t\tuint16_t avp_len;\n\n\t\tif (length < sizeof(*avp)) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: short avp received\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tavp = (struct l2tp_avp_t *)ptr;\n\t\tavp->flags = ntohs(avp->flags);\n\t\tavp_len = avp->flags & L2TP_AVP_LEN_MASK;\n\t\tif (avp_len < sizeof(*avp)) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: short avp received\\n\");\n\t\t\tgoto out_err;\n\t\t} else if (length < avp_len) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect avp received (exceeds message length)\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (avp->vendor)\n\t\t\tgoto skip;\n\n\t\tda = l2tp_dict_find_attr_by_id(ntohs(avp->type));\n\t\tif (!da) {\n\t\t\tif (conf_verbose) {\n\t\t\t\tlog_warn(\"l2tp: unknown avp received (type=%i, M=%u)\\n\",\n\t\t\t\t\t ntohs(avp->type), !!(avp->flags & L2TP_AVP_FLAG_M));\n\t\t\t}\n\t\t\tif ((avp->flags & L2TP_AVP_FLAG_M) && !conf_avp_permissive)\n\t\t\t\tgoto out_err;\n\t\t} else {\n\t\t\tif (da->M != -1 && !da->M != !(avp->flags & L2TP_AVP_FLAG_M)) {\n\t\t\t\tif (conf_verbose) {\n\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, M=%i, must be %i)\\n\",\n\t\t\t\t\t\t ntohs(avp->type), !!(avp->flags & L2TP_AVP_FLAG_M), da->M);\n\t\t\t\t}\n\t\t\t\tif (!conf_avp_permissive)\n\t\t\t\t    goto out_err;\n\t\t\t}\n\n\t\t\tif (da->H != -1 && !da->H != !(avp->flags & L2TP_AVP_FLAG_H)) {\n\t\t\t\tif (conf_verbose) {\n\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, H=%i, must be %i)\\n\",\n\t\t\t\t\t\t ntohs(avp->type), !!(avp->flags & L2TP_AVP_FLAG_H), da->H);\n\t\t\t\t}\n\t\t\t\tif (!conf_avp_permissive)\n\t\t\t\t    goto out_err;\n\t\t\t}\n\n\t\t\tif (avp->flags & L2TP_AVP_FLAG_H) {\n\t\t\t\tif (!RV) {\n\t\t\t\t\tif (conf_verbose)\n\t\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, H=1, but Random-Vector is not received)\\n\", ntohs(avp->type));\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tif (secret == NULL || secret_len == 0) {\n\t\t\t\t\tlog_error(\"l2tp: impossible to decode\"\n\t\t\t\t\t\t  \" hidden avp (type %hu): no\"\n\t\t\t\t\t\t  \" secret set)\\n\",\n\t\t\t\t\t\t  ntohs(avp->type));\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tif (decode_avp(avp, RV, secret, secret_len) < 0)\n\t\t\t\t\tgoto out_err;\n\n\t\t\t\torig_avp_len = ntohs(*(uint16_t *)avp->val) + sizeof(*avp);\n\t\t\t\torig_avp_val = avp->val + sizeof(uint16_t);\n\t\t\t} else {\n\t\t\t\torig_avp_len = avp_len;\n\t\t\t\torig_avp_val = avp->val;\n\t\t\t}\n\n\t\t\tattr = mempool_alloc(attr_pool);\n\t\t\tmemset(attr, 0, sizeof(*attr));\n\t\t\tattr->attr = da;\n\t\t\tattr->M = !!(avp->flags & L2TP_AVP_FLAG_M);\n\t\t\tattr->H = 0;\n\t\t\tattr->length = orig_avp_len - sizeof(*avp);\n\t\t\tlist_add_tail(&attr->entry, &pack->attrs);\n\n\t\t\tif (attr->attr->id == Random_Vector)\n\t\t\t\tRV = attr;\n\n\t\t\tswitch (da->type) {\n\t\t\t\tcase ATTR_TYPE_INT16:\n\t\t\t\t\tif (orig_avp_len != sizeof(*avp) + 2)\n\t\t\t\t\t\tgoto out_err_len;\n\t\t\t\t\tattr->val.uint16 = ntohs(*(uint16_t *)orig_avp_val);\n\t\t\t\t\tbreak;\n\t\t\t\tcase ATTR_TYPE_STRING:\n\t\t\t\t\tattr->val.string = _malloc(attr->length + 1);\n\t\t\t\t\tif (!attr->val.string)\n\t\t\t\t\t\tgoto out_err_mem;\n\t\t\t\t\tmemcpy(attr->val.string, orig_avp_val, attr->length);\n\t\t\t\t\tattr->val.string[attr->length] = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nskip:\n\t\tptr += avp_len;\n\t\tlength -= avp_len;\n\t}\n\n\t*p = pack;\n\n\tmempool_free(buf);\n\n\treturn 0;\n\nout_err:\n\tl2tp_packet_free(pack);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_realloc called with %x,%zu\\n\", ptr, size));\n\tresult = realloc(ptr, size);\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p\\n\", ptr, size, result));\n\treturn result;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_realloc(%x, %zu)\\n\", ptr, size));\n\tresult = realloc(ptr, size);\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p\\n\", ptr, size, result));\n\treturn result;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "auto ReferenceHandle::New(Local<Value> value, MaybeLocal<Object> options) -> unique_ptr<ReferenceHandle> {\n\tauto inherit = ReadOption<bool>(options, StringTable::Get().inheritUnsafe, false);\n\treturn std::make_unique<ReferenceHandle>(value, inherit);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "auto ReferenceHandle::New(Local<Value> value, MaybeLocal<Object> options) -> unique_ptr<ReferenceHandle> {\n\tauto inherit = ReadOption<bool>(options, StringTable::Get().unsafeInherit, false);\n\treturn std::make_unique<ReferenceHandle>(value, inherit);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  static void setAppend(SetType& set, const VariantType& v) {\n    auto value_type = type(v);\n    if (value_type != HPHP::serialize::Type::INT64 &&\n        value_type != HPHP::serialize::Type::STRING) {\n      throw HPHP::serialize::UnserializeError(\n          \"Unsupported keyset element of type \" +\n          folly::to<std::string>(value_type));\n    }\n    set.append(v);\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  static void setAppend(SetType& set, const VariantType& v) {\n    if (!v.isInteger() && !v.isString()) {\n      throw HPHP::serialize::UnserializeError(\n        \"Keysets can only contain integers or strings\"\n      );\n    }\n    set.append(v);\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tgoto __error;\n\n\tusb_chip[chip->index] = chip;\n\tchip->num_interfaces++;\n\tusb_set_intfdata(intf, chip);\n\tatomic_dec(&chip->active);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n\n __error:\n\tif (chip) {\n\t\tif (!chip->num_interfaces)\n\t\t\tsnd_card_free(chip->card);\n\t\tatomic_dec(&chip->active);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n\tusb_chip[chip->index] = chip;\n\tchip->num_interfaces++;\n\tusb_set_intfdata(intf, chip);\n\tatomic_dec(&chip->active);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n\n __error:\n\tif (chip) {\n\t\t/* chip->active is inside the chip->card object,\n\t\t * decrement before memory is possibly returned.\n\t\t */\n\t\tatomic_dec(&chip->active);\n\t\tif (!chip->num_interfaces)\n\t\t\tsnd_card_free(chip->card);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int on_part_data(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (at && length) {\n        SWITCH(data->part[data->num_of_part].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            size_t offset = 0;\n\n            if (data->part[data->num_of_part].content == NULL) {\n                data->part[data->num_of_part].content_length = length;\n                data->part[data->num_of_part].content =\n                    (char *)ogs_malloc(length + 1);\n                    data->part[data->num_of_part].content,\n                    data->part[data->num_of_part].content_length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            }\n            memcpy(data->part[data->num_of_part].content + offset, at, length);\n            data->part[data->num_of_part].content[\n                data->part[data->num_of_part].content_length] = 0;\n            break;\n\n        DEFAULT\n            ogs_log_hexdump(OGS_LOG_FATAL, (unsigned char *)at, length);\n            ogs_error(\"Unknown content_type [%s]\",\n                    data->part[data->num_of_part].content_type);\n        END\n    }\n    return 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int on_part_data(\n        multipart_parser *parser, const char *at, size_t length)\n{\n    multipart_parser_data_t *data = NULL;\n\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART && at && length) {\n        SWITCH(data->part[data->num_of_part].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            size_t offset = 0;\n\n            if (data->part[data->num_of_part].content == NULL) {\n                data->part[data->num_of_part].content_length = length;\n                data->part[data->num_of_part].content =\n                    (char *)ogs_malloc(length + 1);\n                data->part[data->num_of_part].content = (char *)ogs_realloc(\n                    data->part[data->num_of_part].content,\n                    data->part[data->num_of_part].content_length + 1);\n                ogs_assert(data->part[data->num_of_part].content);\n            }\n            memcpy(data->part[data->num_of_part].content + offset, at, length);\n            data->part[data->num_of_part].content[\n                data->part[data->num_of_part].content_length] = 0;\n            break;\n\n        DEFAULT\n            ogs_error(\"Unknown content_type [%s]\",\n                    data->part[data->num_of_part].content_type);\n            ogs_log_hexdump(OGS_LOG_ERROR, (unsigned char *)at, length);\n        END\n    }\n    return 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void parse_time(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t       volatile parse_context *ctx)\n{\n    pj_str_t str;\n\n    ctx->last_error = PJMEDIA_SDP_EINTIME;\n\n    /* check equal sign */\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* t= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* start time */\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->time.start = pj_strtoul(&str);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void parse_time(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t       volatile parse_context *ctx)\n{\n    pj_str_t str;\n\n    ctx->last_error = PJMEDIA_SDP_EINTIME;\n\n    /* check equal sign */\n    if (scanner->curptr+1 >= scanner->end || *(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* t= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* start time */\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->time.start = pj_strtoul(&str);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "R_API RBinJavaAttrInfo *r_bin_java_stack_map_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 offset = 0;\n\tRBinJavaStackMapFrame *stack_frame = NULL, *new_stack_frame = NULL;\n\tif (sz < 10) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tIFDBG eprintf(\"r_bin_java_stack_map_table_attr_new: New stack map allocated.\\n\");\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->info.stack_map_table_attr.stack_map_frame_entries = r_list_newf (r_bin_java_stack_frame_free);\n\t// IFDBG r_bin_java_print_source_code_file_attr_summary(attr);\n\t// Current spec does not call for variable sizes.\n\tattr->info.stack_map_table_attr.number_of_entries = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tIFDBG eprintf (\"r_bin_java_stack_map_table_attr_new: Processing stack map, summary is:\\n\");\n\tIFDBG r_bin_java_print_stack_map_table_attr_summary(attr);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "R_API RBinJavaAttrInfo *r_bin_java_stack_map_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 offset = 0;\n\tif (sz < 8) {\n\t\treturn NULL;\n\t}\n\tRBinJavaStackMapFrame *stack_frame = NULL, *new_stack_frame = NULL;\n\tif (sz < 10) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tIFDBG eprintf (\"r_bin_java_stack_map_table_attr_new: New stack map allocated.\\n\");\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->info.stack_map_table_attr.stack_map_frame_entries = r_list_newf (r_bin_java_stack_frame_free);\n\t// IFDBG r_bin_java_print_source_code_file_attr_summary(attr);\n\t// Current spec does not call for variable sizes.\n\tattr->info.stack_map_table_attr.number_of_entries = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tIFDBG eprintf (\"r_bin_java_stack_map_table_attr_new: Processing stack map, summary is:\\n\");\n\tIFDBG r_bin_java_print_stack_map_table_attr_summary(attr);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "mptctl_hp_hostinfo(unsigned long arg, unsigned int data_size)\n{\n\thp_host_info_t\t__user *uarg = (void __user *) arg;\n\tMPT_ADAPTER\t\t*ioc;\n\tstruct pci_dev\t\t*pdev;\n\tchar                    *pbuf=NULL;\n\tdma_addr_t\t\tbuf_dma;\n\thp_host_info_t\t\tkarg;\n\tCONFIGPARMS\t\tcfg;\n\tConfigPageHeader_t\thdr;\n\tint\t\t\tiocnum;\n\tint\t\t\trc, cim_rev;\n\tToolboxIstwiReadWriteRequest_t\t*IstwiRWRequest;\n\tMPT_FRAME_HDR\t\t*mf = NULL;\n\tunsigned long\t\ttimeleft;\n\tint\t\t\tretval;\n\tu32\t\t\tmsgcontext;\n\n\t/* Reset long to int. Should affect IA64 and SPARC only\n\t */\n\tif (data_size == sizeof(hp_host_info_t))\n\telse\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(&karg, uarg, sizeof(hp_host_info_t))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_hp_host_info - \"\n\t\t\t\"Unable to read in hp_host_info struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_hp_hostinfo() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \": mptctl_hp_hostinfo called.\\n\",\n\t    ioc->name));\n\n\t/* Fill in the data and return the structure to the calling\n\t * program\n\t */\n\tpdev = (struct pci_dev *) ioc->pcidev;\n\n\tkarg.vendor = pdev->vendor;\n\tkarg.device = pdev->device;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "mptctl_hp_hostinfo(MPT_ADAPTER *ioc, unsigned long arg, unsigned int data_size)\n{\n\thp_host_info_t\t__user *uarg = (void __user *) arg;\n\tstruct pci_dev\t\t*pdev;\n\tchar                    *pbuf=NULL;\n\tdma_addr_t\t\tbuf_dma;\n\thp_host_info_t\t\tkarg;\n\tCONFIGPARMS\t\tcfg;\n\tConfigPageHeader_t\thdr;\n\tint\t\t\trc, cim_rev;\n\tToolboxIstwiReadWriteRequest_t\t*IstwiRWRequest;\n\tMPT_FRAME_HDR\t\t*mf = NULL;\n\tunsigned long\t\ttimeleft;\n\tint\t\t\tretval;\n\tu32\t\t\tmsgcontext;\n\n\t/* Reset long to int. Should affect IA64 and SPARC only\n\t */\n\tif (data_size == sizeof(hp_host_info_t))\n\t\tcim_rev = 0;\t/* obsolete */\n\telse\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(&karg, uarg, sizeof(hp_host_info_t))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_hp_host_info - \"\n\t\t\t\"Unable to read in hp_host_info struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \": mptctl_hp_hostinfo called.\\n\",\n\t    ioc->name));\n\n\t/* Fill in the data and return the structure to the calling\n\t * program\n\t */\n\tpdev = (struct pci_dev *) ioc->pcidev;\n\n\tkarg.vendor = pdev->vendor;\n\tkarg.device = pdev->device;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteLocalResponseNormParams*>(node->builtin_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (output->type == kTfLiteFloat32) {\n#define TF_LITE_LOCAL_RESPONSE_NORM(type)                            \\\n  tflite::LocalResponseNormalizationParams op_params;                \\\n  op_params.range = params->radius;                                  \\\n  op_params.bias = params->bias;                                     \\\n  op_params.alpha = params->alpha;                                   \\\n  op_params.beta = params->beta;                                     \\\n  type::LocalResponseNormalization(                                  \\\n      op_params, GetTensorShape(input), GetTensorData<float>(input), \\",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteLocalResponseNormParams*>(node->builtin_data);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  if (output->type == kTfLiteFloat32) {\n#define TF_LITE_LOCAL_RESPONSE_NORM(type)                            \\\n  tflite::LocalResponseNormalizationParams op_params;                \\\n  op_params.range = params->radius;                                  \\\n  op_params.bias = params->bias;                                     \\\n  op_params.alpha = params->alpha;                                   \\\n  op_params.beta = params->beta;                                     \\\n  type::LocalResponseNormalization(                                  \\\n      op_params, GetTensorShape(input), GetTensorData<float>(input), \\",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "__global__ void UnsortedSegmentCustomKernel(const Index input_outer_dim_size,\n                                            const Index inner_dim_size,\n                                            const Index output_outer_dim_size,\n                                            const Index* segment_ids,\n                                            const T* input, T* output) {\n  const Index input_total_size = input_outer_dim_size * inner_dim_size;\n  const Index output_total_size = output_outer_dim_size * inner_dim_size;\n  for (int input_index : GpuGridRangeX(input_total_size)) {\n    const Index input_segment_index = input_index / inner_dim_size;\n    const Index segment_offset = input_index % inner_dim_size;\n    const Index output_segment_index = segment_ids[input_segment_index];\n    if (output_segment_index < 0 || output_segment_index >= output_total_size) {\n      continue;\n    }\n    const Index output_index =\n        output_segment_index * inner_dim_size + segment_offset;\n    KernelReductionFunctor()(output + output_index, ldg(input + input_index));\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "__global__ void UnsortedSegmentCustomKernel(const int64 input_outer_dim_size,\n                                            const int64 inner_dim_size,\n                                            const int64 output_outer_dim_size,\n                                            const Index* segment_ids,\n                                            const T* input, T* output) {\n  const int64 input_total_size = input_outer_dim_size * inner_dim_size;\n  for (int64 input_index : GpuGridRangeX(input_total_size)) {\n    const int64 input_segment_index = input_index / inner_dim_size;\n    const int64 segment_offset = input_index % inner_dim_size;\n    const Index output_segment_index = segment_ids[input_segment_index];\n    if (output_segment_index < 0 ||\n        output_segment_index >= output_outer_dim_size) {\n      continue;\n    }\n    const int64 output_index =\n        output_segment_index * inner_dim_size + segment_offset;\n    KernelReductionFunctor()(output + output_index, ldg(input + input_index));\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void jbd2_journal_wait_updates(journal_t *journal)\n{\n\ttransaction_t *commit_transaction = journal->j_running_transaction;\n\n\tif (!commit_transaction)\n\t\treturn;\n\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (atomic_read(&commit_transaction->t_updates)) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&commit_transaction->t_updates)) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void jbd2_journal_wait_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twhile (1) {\n\t\t/*\n\t\t * Note that the running transaction can get freed under us if\n\t\t * this transaction is getting committed in\n\t\t * jbd2_journal_commit_transaction() ->\n\t\t * jbd2_journal_free_transaction(). This can only happen when we\n\t\t * release j_state_lock -> schedule() -> acquire j_state_lock.\n\t\t * Hence we should everytime retrieve new j_running_transaction\n\t\t * value (after j_state_lock release acquire cycle), else it may\n\t\t * lead to use-after-free of old freed transaction.\n\t\t */\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tsessionid = get_sessionid(res_val);\n\tif (!sessionid)\n\t\tapplog(LOG_DEBUG, \"Failed to get sessionid in initiate_stratum\");\n\tnonce1 = json_array_string(res_val, 1);\n\tif (!nonce1) {\n\t\tapplog(LOG_INFO, \"Failed to get nonce1 in initiate_stratum\");\n\t\tfree(sessionid);\n\t\tgoto out;\n\t}\n\tn2size = json_integer_value(json_array_get(res_val, 2));\n\tif (!n2size) {\n\t\tapplog(LOG_INFO, \"Failed to get n2size in initiate_stratum\");\n\t\tfree(sessionid);\n\t\tfree(nonce1);\n\t\tgoto out;\n\t}\n\n\tcg_wlock(&pool->data_lock);\n\tpool->sessionid = sessionid;\n\tpool->nonce1 = nonce1;\n\tpool->n1_len = strlen(nonce1) / 2;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tsessionid = get_sessionid(res_val);\n\tif (!sessionid)\n\t\tapplog(LOG_DEBUG, \"Failed to get sessionid in initiate_stratum\");\n\tnonce1 = json_array_string(res_val, 1);\n\tif (!nonce1) {\n\t\tapplog(LOG_INFO, \"Failed to get nonce1 in initiate_stratum\");\n\t\tfree(sessionid);\n\t\tgoto out;\n\t}\n\tn2size = json_integer_value(json_array_get(res_val, 2));\n\tif (n2size < 1)\n\t{\n\t\tapplog(LOG_INFO, \"Failed to get n2size in initiate_stratum\");\n\t\tfree(sessionid);\n\t\tfree(nonce1);\n\t\tgoto out;\n\t}\n\n\tcg_wlock(&pool->data_lock);\n\tpool->sessionid = sessionid;\n\tpool->nonce1 = nonce1;\n\tpool->n1_len = strlen(nonce1) / 2;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void ep2_mul_sim_plain(ep2_t r, const ep2_t p, const bn_t k,\n\t\tconst ep2_t q, const bn_t m, const ep2_t *t) {\n\tint i, l, l0, l1, n0, n1, w, gen;\n\tint8_t naf0[2 * RLC_FP_BITS + 1], naf1[2 * RLC_FP_BITS + 1], *_k, *_m;\n\tep2_t t0[1 << (EP_WIDTH - 2)];\n\tep2_t t1[1 << (EP_WIDTH - 2)];\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\t\tep2_null(t0[i]);\n\t\t\t\tep2_new(t0[i]);\n\t\t\t}\n\t\t\tep2_tab(t0, p, EP_WIDTH);\n\t\t\tt = (ep2_t *)t0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void ep2_mul_sim_plain(ep2_t r, const ep2_t p, const bn_t k,\n\t\tconst ep2_t q, const bn_t m, const ep2_t *t) {\n\tint i, n0, n1, w, gen;\n\tint8_t naf0[2 * RLC_FP_BITS + 1], naf1[2 * RLC_FP_BITS + 1], *_k, *_m;\n\tep2_t t0[1 << (EP_WIDTH - 2)];\n\tep2_t t1[1 << (EP_WIDTH - 2)];\n\tsize_t l, l0, l1;\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\t\tep2_null(t0[i]);\n\t\t\t\tep2_new(t0[i]);\n\t\t\t}\n\t\t\tep2_tab(t0, p, EP_WIDTH);\n\t\t\tt = (ep2_t *)t0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\tgf_bs_read_int(ctx->bs, 1);\n\n\t\t\t//speaker config\n\t\t\tu32 speakerLayoutType = gf_bs_read_int(ctx->bs, 2);\n\t\t\tif (speakerLayoutType == 0) {\n\t\t\t\tCICPspeakerLayoutIdx = gf_bs_read_int(ctx->bs, 6);\n\t\t\t} else {\n\t\t\t\tnumSpeakers = (s32) gf_mpegh_escaped_value(ctx->bs, 5, 8, 16) + 1;\n\t\t\t\t//TODO ...\n\t\t\t}\n\n\t\t\tmhas_dmx_check_pid(filter, ctx, pl, sr, frame_len, CICPspeakerLayoutIdx, numSpeakers, start + pay_start, (u32) mhas_size);\n\n\t\t\thas_cfg = GF_TRUE;\n\t\t}\n\t\t//audio truncation\n\t\telse if (mhas_type==17) {\n\t\t\tBool isActive = gf_bs_read_int(ctx->bs, 1);\n\t\t\t/*Bool ati_reserved = */gf_bs_read_int(ctx->bs, 1);\n\t\t\ttrunc_from_begin = gf_bs_read_int(ctx->bs, 1);\n\t\t\tnb_trunc_samples = gf_bs_read_int(ctx->bs, 13);\n\t\t\tif (!isActive) {\n\t\t\t\tnb_trunc_samples = 0;\n\t\t\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\tgf_bs_read_int(ctx->bs, 1);\n\n\t\t\t//speaker config\n\t\t\tu32 speakerLayoutType = gf_bs_read_int(ctx->bs, 2);\n\t\t\tif (speakerLayoutType == 0) {\n\t\t\t\tCICPspeakerLayoutIdx = gf_bs_read_int(ctx->bs, 6);\n\t\t\t} else {\n\t\t\t\tnumSpeakers = (s32) gf_mpegh_escaped_value(ctx->bs, 5, 8, 16) + 1;\n\t\t\t\t//TODO ...\n\t\t\t}\n\t\t\tif (sr) {\n\t\t\t\tmhas_dmx_check_pid(filter, ctx, pl, sr, frame_len, CICPspeakerLayoutIdx, numSpeakers, start + pay_start, (u32) mhas_size);\n\n\t\t\t\thas_cfg = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\t//audio truncation\n\t\telse if (mhas_type==17) {\n\t\t\tBool isActive = gf_bs_read_int(ctx->bs, 1);\n\t\t\t/*Bool ati_reserved = */gf_bs_read_int(ctx->bs, 1);\n\t\t\ttrunc_from_begin = gf_bs_read_int(ctx->bs, 1);\n\t\t\tnb_trunc_samples = gf_bs_read_int(ctx->bs, 13);\n\t\t\tif (!isActive) {\n\t\t\t\tnb_trunc_samples = 0;\n\t\t\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(full_path, vol->UNC, unc_len);\n\tpos = full_path + unc_len;\n\n\tif (pplen) {\n\t\t*pos++ = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos, vol->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t*pos = '\\0'; /* add trailing null */\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tunsigned int unc_len = strnlen(vol->UNC, MAX_TREE_SIZE + 1);\n\n\tfull_path = kmalloc(unc_len + pplen + 1, GFP_KERNEL);\n\tif (full_path == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(full_path, vol->UNC, unc_len);\n\tpos = full_path + unc_len;\n\n\tif (pplen) {\n\t\t*pos = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos + 1, vol->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t*pos = '\\0'; /* add trailing null */\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));\n\tcifs_dbg(FYI, \"%s: full_path=%s\\n\", __func__, full_path);\n\treturn full_path;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void ep4_read_bin(ep4_t a, const uint8_t *bin, int len) {\n\tif (len == 1) {\n\t\tif (bin[0] == 0) {\n\t\t\tep4_set_infty(a);\n\t\t\treturn;\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t}\n\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void ep4_read_bin(ep4_t a, const uint8_t *bin, size_t len) {\n\tif (len == 1) {\n\t\tif (bin[0] == 0) {\n\t\t\tep4_set_infty(a);\n\t\t\treturn;\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t}\n\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void* chk_malloc(size_t bytes)\n{\n    char* buffer = (char*)dlmalloc(bytes + CHK_OVERHEAD_SIZE);\n    if (buffer) {\n        memset(buffer, CHK_SENTINEL_VALUE, bytes + CHK_OVERHEAD_SIZE);\n        size_t offset = dlmalloc_usable_size(buffer) - sizeof(size_t);\n        *(size_t *)(buffer + offset) = bytes;\n        buffer += CHK_SENTINEL_HEAD_SIZE;\n    }\n    return buffer;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void* chk_malloc(size_t bytes)\n{\n    size_t size = bytes + CHK_OVERHEAD_SIZE;\n    if (size < bytes) { // Overflow.\n        return NULL;\n    }\n    uint8_t* buffer = (uint8_t*) dlmalloc(size);\n    if (buffer) {\n        memset(buffer, CHK_SENTINEL_VALUE, bytes + CHK_OVERHEAD_SIZE);\n        size_t offset = dlmalloc_usable_size(buffer) - sizeof(size_t);\n        *(size_t *)(buffer + offset) = bytes;\n        buffer += CHK_SENTINEL_HEAD_SIZE;\n    }\n    return buffer;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, int len) {\n\tbn_t k;\n\tfp_t t;\n\tep_t q;\n\tint neg;\n\t/* enough space for two field elements plus extra bytes for uniformity */\n\tconst int len_per_elm = (FP_PRIME + ep_param_level() + 7) / 8;\n\n\tbn_null(k);\n\tfp_null(t);\n\tep_null(q);\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t}\n\n\t\tbn_new(k);\n\t\tfp_new(t);\n\t\tep_new(q);\n\n\t\t/* figure out which hash function to use */\n\t\tconst int abNeq0 = (ep_curve_opt_a() != RLC_ZERO) &&\n\t\t\t\t(ep_curve_opt_b() != RLC_ZERO);\n\t\tvoid (*const map_fn)(ep_t, fp_t) =(ep_curve_is_ctmap() ||\n\t\t\t\tabNeq0) ? ep_map_sswu : ep_map_svdw;\n\n#define EP_MAP_CONVERT_BYTES(IDX)                                       \\\n    do {                                                                \\\n      bn_read_bin(k, uniform_bytes + IDX * len_per_elm, len_per_elm);   \\\n      fp_prime_conv(t, k);                                              \\\n    } while (0)\n\n#define EP_MAP_APPLY_MAP(PT)                                    \\\n    do {                                                        \\\n      /* check sign of t */                                     \\\n      neg = fp_sgn0(t, k);                                      \\\n      /* convert */                                             \\\n      map_fn(PT, t);                                            \\\n      /* compare sign of y and sign of t; fix if necessary */   \\\n      neg = neg != fp_sgn0(PT->y, k);                             \\\n      fp_neg(t, PT->y);                                          \\\n      dv_copy_cond(PT->y, t, RLC_FP_DIGS, neg);                  \\\n    } while (0)\n\n\t\t/* first map invocation */\n\t\tEP_MAP_CONVERT_BYTES(0);\n\t\tEP_MAP_APPLY_MAP(p);\n\t\tTMPL_MAP_CALL_ISOMAP(ep, p);\n\n\t\t/* second map invocation */\n\t\tEP_MAP_CONVERT_BYTES(1);\n\t\tEP_MAP_APPLY_MAP(q);\n\t\tTMPL_MAP_CALL_ISOMAP(ep, q);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, size_t len) {\n\tbn_t k;\n\tfp_t t;\n\tep_t q;\n\tint neg;\n\t/* enough space for two field elements plus extra bytes for uniformity */\n\tconst int len_per_elm = (FP_PRIME + ep_param_level() + 7) / 8;\n\n\tbn_null(k);\n\tfp_null(t);\n\tep_null(q);\n\t\t\tRLC_THROW(ERR_NO_VALID);\n\t\t}\n\n\t\tbn_new(k);\n\t\tfp_new(t);\n\t\tep_new(q);\n\n\t\t/* figure out which hash function to use */\n\t\tconst int abNeq0 = (ep_curve_opt_a() != RLC_ZERO) &&\n\t\t\t\t(ep_curve_opt_b() != RLC_ZERO);\n\t\tvoid (*const map_fn)(ep_t, fp_t) = (ep_curve_is_ctmap() ||\n\t\t\t\tabNeq0) ? ep_map_sswu : ep_map_svdw;\n\n#define EP_MAP_CONVERT_BYTES(IDX)\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tbn_read_bin(k, uniform_bytes + IDX * len_per_elm, len_per_elm);\t\\\n\t\t\tfp_prime_conv(t, k);\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} while (0)\n\n#define EP_MAP_APPLY_MAP(PT)\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t/* check sign of t */\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tneg = fp_sgn0(t, k);\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t/* convert */\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tmap_fn(PT, t);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t/* compare sign of y and sign of t; fix if necessary */\t\t\t\\\n\t\t\tneg = neg != fp_sgn0(PT->y, k);\t\t\t\t\t\t\t\t\t\\\n\t\t\tfp_neg(t, PT->y);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tdv_copy_cond(PT->y, t, RLC_FP_DIGS, neg);\t\t\t\t\t\t\\\n\t\t} while (0)\n\n\t\t/* first map invocation */\n\t\tEP_MAP_CONVERT_BYTES(0);\n\t\tEP_MAP_APPLY_MAP(p);\n\t\tTMPL_MAP_CALL_ISOMAP(ep, p);\n\n\t\t/* second map invocation */\n\t\tEP_MAP_CONVERT_BYTES(1);\n\t\tEP_MAP_APPLY_MAP(q);\n\t\tTMPL_MAP_CALL_ISOMAP(ep, q);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tcl_mouseAccelStyle = Cvar_Get( \"cl_mouseAccelStyle\", \"0\", CVAR_ARCHIVE );\n\t// offset for the power function (for style 1, ignored otherwise)\n\t// this should be set to the max rate value\n\tcl_mouseAccelOffset = Cvar_Get( \"cl_mouseAccelOffset\", \"5\", CVAR_ARCHIVE );\n\tCvar_CheckRange(cl_mouseAccelOffset, 0.001f, 50000.0f, qfalse);\n\n\tcl_showMouseRate = Cvar_Get( \"cl_showmouserate\", \"0\", 0 );\n\n\tcl_allowDownload = Cvar_Get( \"cl_allowDownload\", \"0\", CVAR_ARCHIVE );\n#ifdef USE_CURL_DLOPEN\n\tcl_cURLLib = Cvar_Get(\"cl_cURLLib\", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n#endif\n\n\t// init autoswitch so the ui will have it correctly even\n\t// if the cgame hasn't been started\n\tCvar_Get( \"cg_autoswitch\", \"2\", CVAR_ARCHIVE );\n\n\t// Rafael - particle switch\n\tCvar_Get( \"cg_wolfparticles\", \"1\", CVAR_ARCHIVE );\n\t// done\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tcl_mouseAccelStyle = Cvar_Get( \"cl_mouseAccelStyle\", \"0\", CVAR_ARCHIVE );\n\t// offset for the power function (for style 1, ignored otherwise)\n\t// this should be set to the max rate value\n\tcl_mouseAccelOffset = Cvar_Get( \"cl_mouseAccelOffset\", \"5\", CVAR_ARCHIVE );\n\tCvar_CheckRange(cl_mouseAccelOffset, 0.001f, 50000.0f, qfalse);\n\n\tcl_showMouseRate = Cvar_Get( \"cl_showmouserate\", \"0\", 0 );\n\n\tcl_allowDownload = Cvar_Get( \"cl_allowDownload\", \"0\", CVAR_ARCHIVE );\n#ifdef USE_CURL_DLOPEN\n\tcl_cURLLib = Cvar_Get(\"cl_cURLLib\", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n#endif\n\n\t// init autoswitch so the ui will have it correctly even\n\t// if the cgame hasn't been started\n\tCvar_Get( \"cg_autoswitch\", \"2\", CVAR_ARCHIVE );\n\n\t// Rafael - particle switch\n\tCvar_Get( \"cg_wolfparticles\", \"1\", CVAR_ARCHIVE );\n\t// done\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\ttime_t timestamp;\n\tstruct pe_image_file_hdr file_hdr;\n\tunion {\n\t    struct pe_image_optional_hdr64 opt64;\n\t    struct pe_image_optional_hdr32 opt32;\n\t} pe_opt;\n\tstruct pe_image_section_hdr *section_hdr;\n\tchar sname[9], epbuff[4096], *tempfile;\n\tuint32_t epsize;\n\tssize_t bytes, at;\n\tunsigned int i, found, upx_success = 0, min = 0, max = 0, err, overlays = 0;\n\tunsigned int ssize = 0, dsize = 0, dll = 0, pe_plus = 0, corrupted_cur;\n\tint (*upxfn)(const char *, uint32_t, char *, uint32_t *, uint32_t, uint32_t, uint32_t) = NULL;\n\tconst char *src = NULL;\n\tchar *dest = NULL;\n\tint ndesc, ret = CL_CLEAN, upack = 0, native=0;\n\tsize_t fsize;\n\tuint32_t valign, falign, hdr_size, j;\n\tstruct cli_exe_section *exe_sections;\n\tchar timestr[32];\n\tstruct pe_image_data_dir *dirs;\n\tstruct cli_bc_ctx *bc_ctx;\n\tfmap_t *map;\n\tstruct cli_pe_hook_data pedata;\n#ifdef HAVE__INTERNAL__SHA_COLLECT\n\tint sha_collect = ctx->sha_collect;\n#endif\n    const char *archtype=NULL, *subsystem=NULL;\n\t    cli_dbgmsg(\"Found misaligned section, using 0x200\\n\");\n\t    falign = 0x200;\n\t}\n    }\n\n    hdr_size = PESALIGN(hdr_size, valign); /* Aligned headers virtual size */\n\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"NumberOfSections\", nsections);\n#endif\n\n    for(i = 0; i < nsections; i++) {\n\tstrncpy(sname, (char *) section_hdr[i].Name, 8);\n\tsname[8] = 0;\n\texe_sections[i].rva = PEALIGN(EC32(section_hdr[i].VirtualAddress), valign);\n\texe_sections[i].vsz = PESALIGN(EC32(section_hdr[i].VirtualSize), valign);\n\texe_sections[i].raw = PEALIGN(EC32(section_hdr[i].PointerToRawData), falign);\n\texe_sections[i].rsz = PESALIGN(EC32(section_hdr[i].SizeOfRawData), falign);\n\texe_sections[i].chr = EC32(section_hdr[i].Characteristics);\n\texe_sections[i].urva = EC32(section_hdr[i].VirtualAddress); /* Just in case */\n\texe_sections[i].uvsz = EC32(section_hdr[i].VirtualSize);\n\texe_sections[i].uraw = EC32(section_hdr[i].PointerToRawData);\n\texe_sections[i].ursz = EC32(section_hdr[i].SizeOfRawData);\n\n#if HAVE_JSON\n        add_section_info(ctx, &exe_sections[i]);\n\n        if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS) {\n            free(section_hdr);\n            free(exe_sections);\n            return CL_ETIMEOUT;\n        }\n#endif\n\tif (DETECT_BROKEN_PE && (!valign || (exe_sections[i].urva % valign))) { /* Bad virtual alignment */\n\t    cli_dbgmsg(\"VirtualAddress is misaligned\\n\");\n\t    cli_dbgmsg(\"------------------------------------\\n\");\n\t    cli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t    free(section_hdr);\n\t    free(exe_sections);\n\t    return CL_VIRUS;\n\t}\n\n\tif (exe_sections[i].rsz) { /* Don't bother with virtual only sections */\n\t    if (exe_sections[i].raw >= fsize) { /* really broken */\n\t      cli_dbgmsg(\"Broken PE file - Section %d starts beyond the end of file (Offset@ %lu, Total filesize %lu)\\n\", i, (unsigned long)exe_sections[i].raw, (unsigned long)fsize);\n\t      cli_dbgmsg(\"------------------------------------\\n\");\n\t\tfree(section_hdr);\n\t\tfree(exe_sections);\n\t\tif(DETECT_BROKEN_PE) {\n\t\t    cli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t\t    return CL_VIRUS;\n\t\t}\n\t\treturn CL_CLEAN; /* no ninjas to see here! move along! */\n\t    }\n\n\t    if(SCAN_ALGO && (DCONF & PE_CONF_POLIPOS) && !*sname && exe_sections[i].vsz > 40000 && exe_sections[i].vsz < 70000 && exe_sections[i].chr == 0xe0000060) polipos = i;\n\n\t    /* check hash section sigs */\n\t    if((DCONF & PE_CONF_MD5SECT) && ctx->engine->hm_mdb) {\n\t        ret = scan_pe_mdb(ctx, &exe_sections[i]);\n\t        if (ret != CL_CLEAN) {\n\t            if (ret != CL_VIRUS)\n\t                cli_errmsg(\"scan_pe: scan_pe_mdb failed: %s!\\n\", cl_strerror(ret));\n\t\t    cli_dbgmsg(\"------------------------------------\\n\");\n\t            free(section_hdr);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\ttime_t timestamp;\n\tstruct pe_image_file_hdr file_hdr;\n\tunion {\n\t    struct pe_image_optional_hdr64 opt64;\n\t    struct pe_image_optional_hdr32 opt32;\n\t} pe_opt;\n\tstruct pe_image_section_hdr *section_hdr;\n\tchar sname[9], epbuff[4096], *tempfile;\n\tuint32_t epsize;\n\tssize_t bytes, at;\n\tunsigned int i, j, found, upx_success = 0, min = 0, max = 0, err, overlays = 0, rescan = 1;\n\tunsigned int ssize = 0, dsize = 0, dll = 0, pe_plus = 0, corrupted_cur;\n\tint (*upxfn)(const char *, uint32_t, char *, uint32_t *, uint32_t, uint32_t, uint32_t) = NULL;\n\tconst char *src = NULL;\n\tchar *dest = NULL;\n\tint ndesc, ret = CL_CLEAN, upack = 0, native=0;\n\tsize_t fsize;\n\tuint32_t valign, falign, hdr_size;\n\tstruct cli_exe_section *exe_sections;\n\tchar timestr[32];\n\tstruct pe_image_data_dir *dirs;\n\tstruct cli_bc_ctx *bc_ctx;\n\tfmap_t *map;\n\tstruct cli_pe_hook_data pedata;\n#ifdef HAVE__INTERNAL__SHA_COLLECT\n\tint sha_collect = ctx->sha_collect;\n#endif\n    const char *archtype=NULL, *subsystem=NULL;\n\t    falign = 0x200;\n\t}\n    }\n\n    hdr_size = PESALIGN(hdr_size, valign); /* Aligned headers virtual size */\n\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"NumberOfSections\", nsections);\n#endif\n\n    while (rescan==1) {\n        rescan=0;\n        for (i=0; i < nsections; i++) {\n            exe_sections[i].rva = PEALIGN(EC32(section_hdr[i].VirtualAddress), valign);\n            exe_sections[i].vsz = PESALIGN(EC32(section_hdr[i].VirtualSize), valign);\n            exe_sections[i].raw = PEALIGN(EC32(section_hdr[i].PointerToRawData), falign);\n            exe_sections[i].rsz = PESALIGN(EC32(section_hdr[i].SizeOfRawData), falign);\n            exe_sections[i].chr = EC32(section_hdr[i].Characteristics);\n            exe_sections[i].urva = EC32(section_hdr[i].VirtualAddress); /* Just in case */\n            exe_sections[i].uvsz = EC32(section_hdr[i].VirtualSize);\n            exe_sections[i].uraw = EC32(section_hdr[i].PointerToRawData);\n            exe_sections[i].ursz = EC32(section_hdr[i].SizeOfRawData);\n\n            if (exe_sections[i].rsz) { /* Don't bother with virtual only sections */\n                if (!CLI_ISCONTAINED(0, fsize, exe_sections[i].uraw, exe_sections[i].ursz)\n                    || exe_sections[i].raw >= fsize) {\n                    cli_dbgmsg(\"Broken PE file - Section %d starts or exists beyond the end of file (Offset@ %lu, Total filesize %lu)\\n\", i, (unsigned long)exe_sections[i].raw, (unsigned long)fsize);\n                    if (nsections == 1) {\n                        free(section_hdr);\n                        free(exe_sections);\n\n                        if(DETECT_BROKEN_PE) {\n                            cli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n                            return CL_VIRUS;\n                        }\n\n                        return CL_CLEAN; /* no ninjas to see here! move along! */\n                    }\n\n                    for (j=i; j < nsections-1; j++)\n                        memcpy(&exe_sections[j], &exe_sections[j+1], sizeof(struct cli_exe_section));\n\n                    for (j=i; j < nsections-1; j++)\n                        memcpy(&section_hdr[j], &section_hdr[j+1], sizeof(struct pe_image_section_hdr));\n\n                    nsections--;\n                    rescan=1;\n                    break;\n                }\n            }\n        }\n    }\n\n    for(i = 0; i < nsections; i++) {\n        strncpy(sname, (char *) section_hdr[i].Name, 8);\n        sname[8] = 0;\n\n#if HAVE_JSON\n        add_section_info(ctx, &exe_sections[i]);\n\n        if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS) {\n            free(section_hdr);\n            free(exe_sections);\n            return CL_ETIMEOUT;\n        }\n#endif\n\n\tif (DETECT_BROKEN_PE && (!valign || (exe_sections[i].urva % valign))) { /* Bad virtual alignment */\n\t    cli_dbgmsg(\"VirtualAddress is misaligned\\n\");\n\t    cli_dbgmsg(\"------------------------------------\\n\");\n\t    cli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t    free(section_hdr);\n\t    free(exe_sections);\n\t    return CL_VIRUS;\n\t}\n\n\tif (exe_sections[i].rsz) { /* Don't bother with virtual only sections */\n\t    if(SCAN_ALGO && (DCONF & PE_CONF_POLIPOS) && !*sname && exe_sections[i].vsz > 40000 && exe_sections[i].vsz < 70000 && exe_sections[i].chr == 0xe0000060) polipos = i;\n\n\t    /* check hash section sigs */\n\t    if((DCONF & PE_CONF_MD5SECT) && ctx->engine->hm_mdb) {\n\t        ret = scan_pe_mdb(ctx, &exe_sections[i]);\n\t        if (ret != CL_CLEAN) {\n\t            if (ret != CL_VIRUS)\n\t                cli_errmsg(\"scan_pe: scan_pe_mdb failed: %s!\\n\", cl_strerror(ret));\n\t\t    cli_dbgmsg(\"------------------------------------\\n\");\n\t            free(section_hdr);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "zend_function *spl_filesystem_object_get_method_check(zval **object_ptr, char *method, int method_len, const struct _zend_literal *key TSRMLS_DC) /* {{{ */\n{\n\tspl_filesystem_object *fsobj = zend_object_store_get_object(*object_ptr TSRMLS_CC);\n\t\n\tif (fsobj->u.dir.entry.d_name[0] == '\\0' && fsobj->orig_path == NULL) {\n\t\tmethod = \"_bad_state_ex\";\n\t\tmethod_len = sizeof(\"_bad_state_ex\") - 1;\n\t\tkey = NULL;\n\t}\n\t\n\treturn zend_get_std_object_handlers()->get_method(object_ptr, method, method_len, key TSRMLS_CC);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "zend_function *spl_filesystem_object_get_method_check(zval **object_ptr, char *method, int method_len, const struct _zend_literal *key TSRMLS_DC) /* {{{ */\n{\n\tspl_filesystem_object *fsobj = zend_object_store_get_object(*object_ptr TSRMLS_CC);\n\n\tif (fsobj->u.dir.entry.d_name[0] == '\\0' && fsobj->orig_path == NULL) {\n\t\tmethod = \"_bad_state_ex\";\n\t\tmethod_len = sizeof(\"_bad_state_ex\") - 1;\n\t\tkey = NULL;\n\t}\n\n\treturn zend_get_std_object_handlers()->get_method(object_ptr, method, method_len, key TSRMLS_CC);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t           ret;\n    njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n    njs_frame_t         *frame, *async_frame;\n    njs_function_t      *function;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *top, *async;\n\n    ctx = vm->top_frame->function->context;\n\n    value = njs_arg(args, nargs, 1);\n    if (njs_is_error(value)) {\n        goto failed;\n    }\n\n    async_frame = ctx->await;\n    async = &async_frame->native;\n    async->previous = vm->top_frame;\n\n    function = async->function;\n\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n    top = vm->top_frame;\n    frame = vm->active_frame;\n\n    vm->levels[NJS_LEVEL_LOCAL] = async->local;\n    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(async->function);\n    vm->levels[NJS_LEVEL_TEMP] = async->temp;\n\n    vm->top_frame = async;\n    vm->active_frame = async_frame;\n\n    *njs_scope_value(vm, ctx->index) = *value;\n    vm->retval = *value;\n\n    vm->top_frame->retval = &vm->retval;\n\n    function->context = ctx->capability;\n    function->await = ctx;\n\n    ret = njs_vmcode_interpreter(vm, ctx->pc);\n\n    function->context = NULL;\n    function->await = NULL;\n\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n\n    vm->top_frame = top;\n    vm->active_frame = frame;\n\n    if (ret == NJS_OK) {\n        ret = njs_function_call(vm, njs_function(&ctx->capability->resolve),",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t           ret;\n    njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n    njs_frame_t         *frame, *async_frame;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *top, *async;\n\n    ctx = vm->top_frame->function->context;\n\n    value = njs_arg(args, nargs, 1);\n    if (njs_is_error(value)) {\n        goto failed;\n    }\n\n    async_frame = ctx->await;\n    async = &async_frame->native;\n    async->previous = vm->top_frame;\n\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n    top = vm->top_frame;\n    frame = vm->active_frame;\n\n    vm->levels[NJS_LEVEL_LOCAL] = async->local;\n    vm->levels[NJS_LEVEL_CLOSURE] = njs_function_closures(async->function);\n    vm->levels[NJS_LEVEL_TEMP] = async->temp;\n\n    vm->top_frame = async;\n    vm->active_frame = async_frame;\n\n    *njs_scope_value(vm, ctx->index) = *value;\n    vm->retval = *value;\n\n    vm->top_frame->retval = &vm->retval;\n\n    ret = njs_vmcode_interpreter(vm, ctx->pc, ctx->capability, ctx);\n\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n\n    vm->top_frame = top;\n    vm->active_frame = frame;\n\n    if (ret == NJS_OK) {\n        ret = njs_function_call(vm, njs_function(&ctx->capability->resolve),",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t}\n\tif (!udta) return GF_BAD_PARAM;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (!userData || !userDataSize || *userData) return GF_BAD_PARAM;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\n\t}\n\treturn GF_BAD_PARAM;\n\nfound:\n\tif (UserDataIndex) {\n\t\tif (UserDataIndex > gf_list_count(map->boxes) ) return GF_BAD_PARAM;\n\t\tptr = (GF_UnknownBox*)gf_list_get(map->boxes, UserDataIndex-1);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t}\n\tif (!udta) return GF_BAD_PARAM;\n\n\tif (UserDataType == GF_ISOM_BOX_TYPE_UUID) UserDataType = 0;\n\tmemset(t, 1, 16);\n\n\tif (!userData || !userDataSize || *userData) return GF_BAD_PARAM;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && UUID && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\n\t}\n\treturn GF_BAD_PARAM;\n\nfound:\n\tif (UserDataIndex) {\n\t\tif (UserDataIndex > gf_list_count(map->boxes) ) return GF_BAD_PARAM;\n\t\tptr = (GF_UnknownBox*)gf_list_get(map->boxes, UserDataIndex-1);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "_gnutls_x509_verify_certificate (const gnutls_x509_crt_t * certificate_list,\n\t\t\t\t int clist_size,\n\t\t\t\t const gnutls_x509_crt_t * trusted_cas,\n\t\t\t\t int tcas_size,\n\t\t\t\t const gnutls_x509_crl_t * CRLs,\n\t\t\t\t int crls_size, unsigned int flags)\n{\n  int i = 0, ret;\n  unsigned int status = 0, output;\n\n  if (clist_size > 1)\n    {\n      /* Check if the last certificate in the path is self signed.\n       * In that case ignore it (a certificate is trusted only if it\n       * leads to a trusted party by us, not the server's).\n       *\n       * This prevents from verifying self signed certificates against\n       * themselves. This (although not bad) caused verification\n       * failures on some root self signed certificates that use the\n  if (!(flags & GNUTLS_VERIFY_DO_NOT_ALLOW_SAME))\n    {\n      for (i = 0; i < clist_size; i++)\n\t{\n\t  int j;\n\n\t  for (j = 0; j < tcas_size; j++)\n\t    {\n\t      if (check_if_same_cert (certificate_list[i],\n\t\t\t\t      trusted_cas[j]) == 0)\n\t\t{\n\t\t  clist_size = i;\n\t\t  break;\n\t\t}\n\t    }\n\t  /* clist_size may have been changed which gets out of loop */\n\t}\n    }\n\n  if (clist_size == 0)\n    /* The certificate is already present in the trusted certificate list.\n     * Nothing to verify. */\n    return status;\n\n  /* Verify the last certificate in the certificate path\n   * against the trusted CA certificate list.\n   *\n   * If no CAs are present returns CERT_INVALID. Thus works\n   * in self signed etc certificates.\n   */\n  ret = _gnutls_verify_certificate2 (certificate_list[clist_size - 1],\n\t\t\t\t     trusted_cas, tcas_size, flags, &output);\n  if (ret == 0)\n    {\n      /* if the last certificate in the certificate\n       * list is invalid, then the certificate is not\n       * trusted.\n       */\n      gnutls_assert ();\n      status |= output;\n      status |= GNUTLS_CERT_INVALID;\n      return status;\n      ret = gnutls_x509_crt_check_revocation (certificate_list[i],\n\t\t\t\t\t      CRLs, crls_size);\n      if (ret == 1)\n\t{\t\t\t/* revoked */\n\t  status |= GNUTLS_CERT_REVOKED;\n\t  status |= GNUTLS_CERT_INVALID;\n\t  return status;\n\t}\n    }\n#endif\n\n  /* Check activation/expiration times\n   */\n  if (!(flags & GNUTLS_VERIFY_DISABLE_TIME_CHECKS))\n    {\n      time_t t, now = time (0);\n\n      for (i = 0; i < clist_size; i++)\n\t{\n\t  t = gnutls_x509_crt_get_activation_time (certificate_list[i]);\n\t  if (t == (time_t) - 1 || now < t)\n\t    {\n\t      status |= GNUTLS_CERT_NOT_ACTIVATED;\n\t      status |= GNUTLS_CERT_INVALID;\n\t      return status;\n\t    }\n\n\t  t = gnutls_x509_crt_get_expiration_time (certificate_list[i]);\n\t  if (t == (time_t) - 1 || now > t)\n\t    {\n\t      status |= GNUTLS_CERT_EXPIRED;\n\t      status |= GNUTLS_CERT_INVALID;\n\t      return status;\n\t    }\n\t}\n    }\n\n  /* Verify the certificate path (chain)\n   */\n  for (i = clist_size - 1; i > 0; i--)\n    {\n      if (i - 1 < 0)\n\tbreak;\n\n      /* note that here we disable this V1 CA flag. So that no version 1\n       * certificates can exist in a supplied chain.\n       */\n      if (!(flags & GNUTLS_VERIFY_ALLOW_ANY_X509_V1_CA_CRT))\n\tflags &= ~(GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT);\n      if ((ret =\n\t   _gnutls_verify_certificate2 (certificate_list[i - 1],\n\t\t\t\t\t&certificate_list[i], 1, flags,\n\t\t\t\t\tNULL)) == 0)\n\t{\n\t  status |= GNUTLS_CERT_INVALID;\n\t  return status;\n\t}\n    }\n\n  return 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "_gnutls_x509_verify_certificate (const gnutls_x509_crt_t * certificate_list,\n\t\t\t\t int clist_size,\n\t\t\t\t const gnutls_x509_crt_t * trusted_cas,\n\t\t\t\t int tcas_size,\n\t\t\t\t const gnutls_x509_crl_t * CRLs,\n\t\t\t\t int crls_size, unsigned int flags)\n{\n  int i = 0, ret;\n  unsigned int status = 0, output;\n  time_t now = time (0);\n  gnutls_x509_crt_t issuer = NULL;\n\n  if (clist_size > 1)\n    {\n      /* Check if the last certificate in the path is self signed.\n       * In that case ignore it (a certificate is trusted only if it\n       * leads to a trusted party by us, not the server's).\n       *\n       * This prevents from verifying self signed certificates against\n       * themselves. This (although not bad) caused verification\n       * failures on some root self signed certificates that use the\n    {\n      for (i = 0; i < clist_size; i++)\n\t{\n\t  int j;\n\n\t  for (j = 0; j < tcas_size; j++)\n\t    {\n\t      if (check_if_same_cert (certificate_list[i],\n\t\t\t\t      trusted_cas[j]) == 0)\n\t\t{\n\t\t  /* explicity time check for trusted CA that we remove from\n\t\t   * list. GNUTLS_VERIFY_DISABLE_TRUSTED_TIME_CHECKS\n\t\t   */\n\t\t  if (!(flags&GNUTLS_VERIFY_DISABLE_TRUSTED_TIME_CHECKS) && !(flags&GNUTLS_VERIFY_DISABLE_TIME_CHECKS))\n\t\t    {\n\t\t      status |= check_time(trusted_cas[j], now);\n\t\t      if (status != 0)\n\t\t        {\n\t\t          return status;\n                        }\n\t\t    }\n\t\t  clist_size = i;\n\t\t  break;\n\t\t}\n\t    }\n\t  /* clist_size may have been changed which gets out of loop */\n\t}\n    }\n\n  if (clist_size == 0)\n    /* The certificate is already present in the trusted certificate list.\n     * Nothing to verify. */\n    return status;\n\n  /* Verify the last certificate in the certificate path\n   * against the trusted CA certificate list.\n   *\n   * If no CAs are present returns CERT_INVALID. Thus works\n   * in self signed etc certificates.\n   */\n  ret = _gnutls_verify_certificate2 (certificate_list[clist_size - 1],\n\t\t\t\t     trusted_cas, tcas_size, flags, &output, &issuer);\n  if (ret == 0)\n    {\n      /* if the last certificate in the certificate\n       * list is invalid, then the certificate is not\n       * trusted.\n       */\n      gnutls_assert ();\n      status |= output;\n      status |= GNUTLS_CERT_INVALID;\n      return status;\n\t\t\t\t\t      CRLs, crls_size);\n      if (ret == 1)\n\t{\t\t\t/* revoked */\n\t  status |= GNUTLS_CERT_REVOKED;\n\t  status |= GNUTLS_CERT_INVALID;\n\t  return status;\n\t}\n    }\n#endif\n\n\n  /* Check activation/expiration times\n   */\n  if (!(flags & GNUTLS_VERIFY_DISABLE_TIME_CHECKS))\n    {\n      /* check the time of the issuer first */\n      if (!(flags&GNUTLS_VERIFY_DISABLE_TRUSTED_TIME_CHECKS))\n        {\n          if (issuer == NULL)\n            {\n              gnutls_assert();\n              return GNUTLS_E_INTERNAL_ERROR;\n            }\n\n          status |= check_time(issuer, now);\n          if (status != 0)\n            {\n              return status;\n            }\n        }\n\n      for (i = 0; i < clist_size; i++)\n\t{\n\t  status |= check_time(certificate_list[i], now);\n\t  if (status != 0)\n\t    {\n\t      return status;\n\t    }\n\t}\n    }\n\n  /* Verify the certificate path (chain)\n   */\n  for (i = clist_size - 1; i > 0; i--)\n    {\n      if (i - 1 < 0)\n\tbreak;\n\n      /* note that here we disable this V1 CA flag. So that no version 1\n       * certificates can exist in a supplied chain.\n       */\n      if (!(flags & GNUTLS_VERIFY_ALLOW_ANY_X509_V1_CA_CRT))\n\tflags &= ~(GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT);\n      if ((ret =\n\t   _gnutls_verify_certificate2 (certificate_list[i - 1],\n\t\t\t\t\t&certificate_list[i], 1, flags,\n\t\t\t\t\tNULL, NULL)) == 0)\n\t{\n\t  status |= GNUTLS_CERT_INVALID;\n\t  return status;\n\t}\n    }\n\n  return 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s\",\n                     bgp_vpn_rd_print(ndo, pptr));\n            pptr += BGP_VPN_RD_LEN;\n\n            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN: /* fall through */\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n\t    snprintf(buf + offset, buflen - offset, \", RD: %s, Source-AS %s\",\n\t\tbgp_vpn_rd_print(ndo, pptr),\n\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\tEXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));\n            pptr += BGP_VPN_RD_LEN;\n\n            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n            /*\n             * no per route-type printing yet.\n             */\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_SEG_LEAF:\n        default:\n            break;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s\",\n                     bgp_vpn_rd_print(ndo, pptr));\n            pptr += BGP_VPN_RD_LEN;\n\n            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN: /* fall through */\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN + 4);\n            offset = strlen(buf);\n\t    snprintf(buf + offset, buflen - offset, \", RD: %s, Source-AS %s\",\n\t\tbgp_vpn_rd_print(ndo, pptr),\n\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\tEXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));\n            pptr += BGP_VPN_RD_LEN + 4;\n\n            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n            /*\n             * no per route-type printing yet.\n             */\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_SEG_LEAF:\n        default:\n            break;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    void CFontFileType1::DecryptEexec(unsigned char** ppEexecBuffer, int nLen)\n    {\n        // \u0421\u043e\u0433\u043b\u0430\u0441\u043d\u043e \u0441\u043f\u0435\u0446\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u0438 Type1, \u043f\u0435\u0440\u0432\u044b\u0439 \u0431\u0430\u0439\u0442 \u043d\u0435 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c ASCII \u043f\u0440\u043e\u0431\u0435\u043b\u043e\u043c\n        // (\u043f\u0440\u043e\u0431\u0435\u043b, \u0442\u0430\u0431, \u043f\u0435\u0440\u0435\u043d\u043e\u0441 \u043a\u0430\u0440\u0435\u0442\u043a\u0438 \u0438\u043b\u0438 \u043f\u0435\u0440\u0435\u043d\u043e\u0441 \u0441\u0442\u0440\u043e\u043a\u0438).\n        unsigned char *sCur = (unsigned char*)(*ppEexecBuffer);\n        while( sCur < (unsigned char*)(*ppEexecBuffer) + nLen && ( ' ' == *sCur || '\\t' == *sCur || '\\r' == *sCur || '\\n' == *sCur ) )\n            ++sCur;\n\n        // \u0422\u0435\u043f\u0435\u0440\u044c \u043d\u0430\u043c \u043d\u0430\u0434\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u044c \u0432 \u043a\u0430\u043a\u043e\u043c \u0444\u043e\u0440\u043c\u0430\u0442\u0435 \u0443 \u043d\u0430\u0441 \u0434\u0430\u043d\u043d\u044b\u0435: ASKII \u0438\u043b\u0438 \u0431\u0438\u043d\u0430\u0440\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435.\n        // \u0415\u0441\u043b\u0438 \u043f\u0435\u0440\u0432\u044b\u0435 \u0447\u0435\u0442\u044b\u0440\u0435 \u0431\u0430\u0439\u0442\u0430 \u044f\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u0448\u0435\u0441\u0442\u043d\u0430\u0434\u0446\u0430\u0442\u0438\u0440\u0438\u0447\u043d\u044b\u043c\u0438 \u0441\u0438\u043c\u0432\u043e\u043b\u0430\u043c\u0438, \u0437\u043d\u0430\u0447\u0438\u0442, \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0430 ASCII.\n        bool bASCII = false;\n\n        if ( isxdigit( sCur[0] ) && isxdigit( sCur[1] ) && isxdigit( sCur[2] ) && isxdigit( sCur[3] ) )\n            bASCII = true;\n\n        if ( bASCII )\n            ASCIIHexDecode( &sCur, sCur + nLen, sCur, nLen );\n\n        unsigned short ushKey = 55665U;\n        EexecDecode( &sCur, *ppEexecBuffer + nLen, sCur, nLen, &ushKey );\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    void CFontFileType1::DecryptEexec(unsigned char** ppEexecBuffer, int nLen)\n    {\n        // \u0421\u043e\u0433\u043b\u0430\u0441\u043d\u043e \u0441\u043f\u0435\u0446\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u0438 Type1, \u043f\u0435\u0440\u0432\u044b\u0439 \u0431\u0430\u0439\u0442 \u043d\u0435 \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c ASCII \u043f\u0440\u043e\u0431\u0435\u043b\u043e\u043c\n        // (\u043f\u0440\u043e\u0431\u0435\u043b, \u0442\u0430\u0431, \u043f\u0435\u0440\u0435\u043d\u043e\u0441 \u043a\u0430\u0440\u0435\u0442\u043a\u0438 \u0438\u043b\u0438 \u043f\u0435\u0440\u0435\u043d\u043e\u0441 \u0441\u0442\u0440\u043e\u043a\u0438).\n        unsigned char *sCur = (unsigned char*)(*ppEexecBuffer);\n        while( sCur < (unsigned char*)(*ppEexecBuffer) + nLen && ( ' ' == *sCur || '\\t' == *sCur || '\\r' == *sCur || '\\n' == *sCur ) )\n        {\n            ++sCur;\n            --nLen;\n        }\n\n        // \u0422\u0435\u043f\u0435\u0440\u044c \u043d\u0430\u043c \u043d\u0430\u0434\u043e \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0438\u0442\u044c \u0432 \u043a\u0430\u043a\u043e\u043c \u0444\u043e\u0440\u043c\u0430\u0442\u0435 \u0443 \u043d\u0430\u0441 \u0434\u0430\u043d\u043d\u044b\u0435: ASKII \u0438\u043b\u0438 \u0431\u0438\u043d\u0430\u0440\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435.\n        // \u0415\u0441\u043b\u0438 \u043f\u0435\u0440\u0432\u044b\u0435 \u0447\u0435\u0442\u044b\u0440\u0435 \u0431\u0430\u0439\u0442\u0430 \u044f\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u0448\u0435\u0441\u0442\u043d\u0430\u0434\u0446\u0430\u0442\u0438\u0440\u0438\u0447\u043d\u044b\u043c\u0438 \u0441\u0438\u043c\u0432\u043e\u043b\u0430\u043c\u0438, \u0437\u043d\u0430\u0447\u0438\u0442, \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u043a\u0430 ASCII.\n        bool bASCII = false;\n\n        if ( nLen > 3 && isxdigit( sCur[0] ) && isxdigit( sCur[1] ) && isxdigit( sCur[2] ) && isxdigit( sCur[3] ) )\n            bASCII = true;\n\n        if ( bASCII )\n            ASCIIHexDecode( &sCur, sCur + nLen, sCur, nLen );\n\n        unsigned short ushKey = 55665U;\n        EexecDecode( &sCur, *ppEexecBuffer + nLen, sCur, nLen, &ushKey );\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tconst uni_to_enc *l = table,\n\t\t\t\t\t *h = &table[num-1],\n\t\t\t\t\t *m;\n\tunsigned short code_key;\n\n\t/* we have no mappings outside the BMP */\n\tif (code_key_a > 0xFFFFU)\n\t\treturn 0;\n\n\tcode_key = (unsigned short) code_key_a;\n\t\n\twhile (l <= h) {\n\t\tm = l + (h - l) / 2;\n\t\tif (code_key < m->un_code_point)\n\t\t\th = m - 1;\n\t\telse if (code_key > m->un_code_point)\n\t\t\tl = m + 1;\n\t\telse\n\t\t\treturn m->cs_code;\n\t}\n\treturn 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tconst uni_to_enc *l = table,\n\t\t\t\t\t *h = &table[num-1],\n\t\t\t\t\t *m;\n\tunsigned short code_key;\n\n\t/* we have no mappings outside the BMP */\n\tif (code_key_a > 0xFFFFU)\n\t\treturn 0;\n\n\tcode_key = (unsigned short) code_key_a;\n\n\twhile (l <= h) {\n\t\tm = l + (h - l) / 2;\n\t\tif (code_key < m->un_code_point)\n\t\t\th = m - 1;\n\t\telse if (code_key > m->un_code_point)\n\t\t\tl = m + 1;\n\t\telse\n\t\t\treturn m->cs_code;\n\t}\n\treturn 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n    const int64_t batch_size = input.dim_size(0);\n    const int64_t in_height = input.dim_size(1);\n    const int64_t in_width = input.dim_size(2);\n    const int64_t channels = input.dim_size(3);\n\n    const int64_t out_height = sizes(0);\n    const int64_t out_width = sizes(1);\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n            0, TensorShape({batch_size, out_height, out_width, channels}),\n            &output));\n\n    // Return if the output is empty.\n    if (output->NumElements() == 0) return;\n\n    typename TTypes<T, 4>::ConstTensor input_data(input.tensor<T, 4>());\n    typename TTypes<T, 4>::Tensor output_data(output->tensor<T, 4>());\n\n    const float height_scale =\n        CalculateResizeScale(out_height, in_height, align_corners_);\n    const float width_scale =",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n    const int64_t batch_size = input.dim_size(0);\n    const int64_t in_height = input.dim_size(1);\n    const int64_t in_width = input.dim_size(2);\n    const int64_t channels = input.dim_size(3);\n\n    const int64_t out_height = sizes(0);\n    const int64_t out_width = sizes(1);\n\n    Tensor* output = nullptr;\n    TensorShape shape;\n    OP_REQUIRES_OK(context,\n                   TensorShape::BuildTensorShape(\n                       {batch_size, out_height, out_width, channels}, &shape));\n    OP_REQUIRES_OK(context, context->allocate_output(0, shape, &output));\n\n    // Return if the output is empty.\n    if (output->NumElements() == 0) return;\n\n    typename TTypes<T, 4>::ConstTensor input_data(input.tensor<T, 4>());\n    typename TTypes<T, 4>::Tensor output_data(output->tensor<T, 4>());\n\n    const float height_scale =\n        CalculateResizeScale(out_height, in_height, align_corners_);\n    const float width_scale =",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "{\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tinode->i_ctime = ext4_current_time(inode);\n\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t\tif (env->used_maps[j] == map) {\n\t\t\t\t\tfdput(f);\n\t\t\t\t\tgoto next_insn;\n\t\t\t\t}\n\n\t\t\tif (env->used_map_cnt >= MAX_USED_MAPS) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\n\t\t\t/* remember this map */\n\t\t\tenv->used_maps[env->used_map_cnt++] = map;\n\n\t\t\t/* hold the map. If the program is rejected by verifier,\n\t\t\t * the map will be released by release_maps() or it\n\t\t\t * will be used by the valid program until it's unloaded\n\t\t\t * and all maps are released in free_bpf_prog_info()\n\t\t\t */\n\t\t\tbpf_map_inc(map, false);\n\t\t\tfdput(f);\nnext_insn:\n\t\t\tinsn++;\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* now all pseudo BPF_LD_IMM64 instructions load valid\n\t * 'struct bpf_map *' into a register instead of user map_fd.\n\t * These pointers will be used later by verifier to validate map access.",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\tfor (j = 0; j < env->used_map_cnt; j++)\n\t\t\t\tif (env->used_maps[j] == map) {\n\t\t\t\t\tfdput(f);\n\t\t\t\t\tgoto next_insn;\n\t\t\t\t}\n\n\t\t\tif (env->used_map_cnt >= MAX_USED_MAPS) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\n\t\t\t/* hold the map. If the program is rejected by verifier,\n\t\t\t * the map will be released by release_maps() or it\n\t\t\t * will be used by the valid program until it's unloaded\n\t\t\t * and all maps are released in free_bpf_prog_info()\n\t\t\t */\n\t\t\tmap = bpf_map_inc(map, false);\n\t\t\tif (IS_ERR(map)) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn PTR_ERR(map);\n\t\t\t}\n\t\t\tenv->used_maps[env->used_map_cnt++] = map;\n\n\t\t\tfdput(f);\nnext_insn:\n\t\t\tinsn++;\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/* now all pseudo BPF_LD_IMM64 instructions load valid\n\t * 'struct bpf_map *' into a register instead of user map_fd.\n\t * These pointers will be used later by verifier to validate map access.",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)\n{\n\tnsc_encode_argb_to_aycocg(context, bmpdata, rowstride);\n\n\tif (context->ChromaSubsamplingLevel)\n\t{\n\t\tnsc_encode_subsampling(context);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "BOOL nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)\n{\n\tif (!context || !bmpdata || (rowstride == 0))\n\t\treturn FALSE;\n\n\tif (!nsc_encode_argb_to_aycocg(context, bmpdata, rowstride))\n\t\treturn FALSE;\n\n\tif (context->ChromaSubsamplingLevel)\n\t{\n\t\tif (!nsc_encode_subsampling(context))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint                     result = 0;\n\tltv_t                   *pLtv;\n\tbool_t                  ltvAllocated = FALSE;\n\tENCSTRCT                sEncryption;\n\n#ifdef USE_WDS\n\thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  /* USE_WDS */\n\t/*------------------------------------------------------------------------*/\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\t\tlp->MaxSleepDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\t\t\t\t\tmemcpy((void *)lp->StationName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n\t\t\t\t\tlp->mediumDistribution  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint                     result = 0;\n\tltv_t                   *pLtv;\n\tbool_t                  ltvAllocated = FALSE;\n\tENCSTRCT                sEncryption;\n\tsize_t\t\t\tlen;\n\n#ifdef USE_WDS\n\thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  /* USE_WDS */\n\t/*------------------------------------------------------------------------*/\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(DbgInfo);\n\n\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\t\tlp->MaxSleepDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\t\t\t\t\tlen = min_t(size_t, pLtv->u.u16[0], sizeof(lp->StationName));\n\t\t\t\t\tstrlcpy(lp->StationName, &pLtv->u.u8[2], len);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n\t\t\t\t\tlp->mediumDistribution  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "ext4_xattr_cache_insert(struct mb_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext4_mb_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "ext4_xattr_cache_insert(struct mb2_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tint error;\n\n\terror = mb2_cache_entry_create(ext4_mb_cache, GFP_NOFS, hash,\n\t\t\t\t       bh->b_blocknr);\n\tif (error) {\n\t\tif (error == -EBUSY)\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t} else\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int em_jcxz(struct x86_emulate_ctxt *ctxt)\n{\n\tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0)\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\n\treturn X86EMUL_CONTINUE;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int em_jcxz(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0)\n\t\trc = jmp_rel(ctxt, ctxt->src.val);\n\n\treturn rc;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int xen_netbk_tx_check_gop(struct xen_netbk *netbk,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct gnttab_copy **gopp)\n{\n\tstruct gnttab_copy *gop = *gopp;\n\tu16 pending_idx = *((u16 *)skb->data);\n\tstruct pending_tx_info *pending_tx_info = netbk->pending_tx_info;\n\tstruct xenvif *vif = pending_tx_info[pending_idx].vif;\n\tstruct xen_netif_tx_request *txp;\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tint nr_frags = shinfo->nr_frags;\n\tint i, err, start;\n\n\t/* Check status of header. */\n\terr = gop->status;\n\tif (unlikely(err)) {\n\t\tpending_ring_idx_t index;\n\t\tindex = pending_index(netbk->pending_prod++);\n\t\ttxp = &pending_tx_info[pending_idx].req;\n\t\tmake_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);\n\t\tnetbk->pending_ring[index] = pending_idx;\n\t\txenvif_put(vif);\n\t}\n\n\t/* Skip first skb fragment if it is on same page as header fragment. */\n\tstart = (frag_get_pending_idx(&shinfo->frags[0]) == pending_idx);\n\n\tfor (i = start; i < nr_frags; i++) {\n\t\tint j, newerr;\n\t\tpending_ring_idx_t index;\n\n\t\tpending_idx = frag_get_pending_idx(&shinfo->frags[i]);\n\n\t\t/* Check error status: if okay then remember grant handle. */\n\t\tnewerr = (++gop)->status;\n\t\tif (likely(!newerr)) {\n\t\t\t/* Had a previous error? Invalidate this fragment. */\n\t\t\tif (unlikely(err))\n\t\t\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Error on this fragment: respond to client with an error. */\n\t\ttxp = &netbk->pending_tx_info[pending_idx].req;\n\t\tmake_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);\n\t\tindex = pending_index(netbk->pending_prod++);\n\t\tnetbk->pending_ring[index] = pending_idx;\n\t\txenvif_put(vif);\n\n\t\t/* Not the first error? Preceding frags already invalidated. */\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\t/* First error: invalidate header and preceding fragments. */\n\t\tpending_idx = *((u16 *)skb->data);\n\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\tfor (j = start; j < i; j++) {\n\t\t\tpending_idx = frag_get_pending_idx(&shinfo->frags[j]);\n\t\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\t}\n\n\t\t/* Remember the error: invalidate all subsequent fragments. */\n\t\terr = newerr;\n\t}\n\n\t*gopp = gop + 1;\n\treturn err;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int xen_netbk_tx_check_gop(struct xen_netbk *netbk,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct gnttab_copy **gopp)\n{\n\tstruct gnttab_copy *gop = *gopp;\n\tu16 pending_idx = *((u16 *)skb->data);\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tint nr_frags = shinfo->nr_frags;\n\tint i, err, start;\n\n\t/* Check status of header. */\n\terr = gop->status;\n\tif (unlikely(err))\n\t\txen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_ERROR);\n\n\t/* Skip first skb fragment if it is on same page as header fragment. */\n\tstart = (frag_get_pending_idx(&shinfo->frags[0]) == pending_idx);\n\n\tfor (i = start; i < nr_frags; i++) {\n\t\tint j, newerr;\n\n\t\tpending_idx = frag_get_pending_idx(&shinfo->frags[i]);\n\n\t\t/* Check error status: if okay then remember grant handle. */\n\t\tnewerr = (++gop)->status;\n\t\tif (likely(!newerr)) {\n\t\t\t/* Had a previous error? Invalidate this fragment. */\n\t\t\tif (unlikely(err))\n\t\t\t\txen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Error on this fragment: respond to client with an error. */\n\t\txen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_ERROR);\n\n\t\t/* Not the first error? Preceding frags already invalidated. */\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\t/* First error: invalidate header and preceding fragments. */\n\t\tpending_idx = *((u16 *)skb->data);\n\t\txen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);\n\t\tfor (j = start; j < i; j++) {\n\t\t\tpending_idx = frag_get_pending_idx(&shinfo->frags[j]);\n\t\t\txen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);\n\t\t}\n\n\t\t/* Remember the error: invalidate all subsequent fragments. */\n\t\terr = newerr;\n\t}\n\n\t*gopp = gop + 1;\n\treturn err;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_SYSTEM_CAP) &&\n\t\t\t    POKE_UINT16(chassis->c_cap_available) &&\n\t\t\t    POKE_UINT16(chassis->c_cap_enabled) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* Management addresses */\n\tTAILQ_FOREACH(mgmt, &chassis->c_mgmt, m_entries) {\n\t\tproto = lldpd_af_to_lldp_proto(mgmt->m_family);\n\t\tassert(proto != LLDP_MGMT_ADDR_NONE);\n\t\tif (!(\n\t\t\t  POKE_START_LLDP_TLV(LLDP_TLV_MGMT_ADDR) &&\n\t\t\t  /* Size of the address, including its type */\n\t\t\t  POKE_UINT8(mgmt->m_addrsize + 1) &&\n\t\t\t  POKE_UINT8(proto) &&\n\t\t\t  POKE_BYTES(&mgmt->m_addr, mgmt->m_addrsize)))\n\t\t\tgoto toobig;\n\n\t\t/* Interface port type, OID */\n\t\tif (mgmt->m_iface == 0) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\t    POKE_START_LLDP_TLV(LLDP_TLV_SYSTEM_CAP) &&\n\t\t\t    POKE_UINT16(chassis->c_cap_available) &&\n\t\t\t    POKE_UINT16(chassis->c_cap_enabled) &&\n\t\t\t    POKE_END_LLDP_TLV))\n\t\t\tgoto toobig;\n\t}\n\n\t/* Management addresses */\n\tTAILQ_FOREACH(mgmt, &chassis->c_mgmt, m_entries) {\n\t\tproto = lldpd_af_to_lldp_proto(mgmt->m_family);\n\t\tif (proto == LLDP_MGMT_ADDR_NONE) continue;\n\t\tif (!(\n\t\t\t  POKE_START_LLDP_TLV(LLDP_TLV_MGMT_ADDR) &&\n\t\t\t  /* Size of the address, including its type */\n\t\t\t  POKE_UINT8(mgmt->m_addrsize + 1) &&\n\t\t\t  POKE_UINT8(proto) &&\n\t\t\t  POKE_BYTES(&mgmt->m_addr, mgmt->m_addrsize)))\n\t\t\tgoto toobig;\n\n\t\t/* Interface port type, OID */\n\t\tif (mgmt->m_iface == 0) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "      return ERROR_INVALID_SYNTAX;\n   }\n\n   //Get the first parameter\n   token = osStrtok_r(NULL, \",\", &p);\n\n   //Parse the WWW-Authenticate field\n   while(token != NULL)\n   {\n      //Check whether a separator is present\n      separator = strchr(token, '=');\n\n      //Separator found?\n      if(separator != NULL)\n      {\n         //Split the string\n         *separator = '\\0';\n\n         //Get field name and value\n         name = strTrimWhitespace(token);\n         value = strTrimWhitespace(separator + 1);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "      return ERROR_INVALID_SYNTAX;\n   }\n\n   //Get the first parameter\n   token = osStrtok_r(NULL, \",\", &p);\n\n   //Parse the WWW-Authenticate field\n   while(token != NULL)\n   {\n      //Check whether a separator is present\n      separator = osStrchr(token, '=');\n\n      //Separator found?\n      if(separator != NULL)\n      {\n         //Split the string\n         *separator = '\\0';\n\n         //Get field name and value\n         name = strTrimWhitespace(token);\n         value = strTrimWhitespace(separator + 1);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n\tif(!file) return 0;\n\tstr = openmpt_module_get_instrument_name(file->mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval>=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n\t}\n\tretval = (int)tmpretval;\n\tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n\t}\n\topenmpt_free_string(str);\n\treturn retval;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tchar buf[32];\n\tif(!file) return 0;\n\tstr = openmpt_module_get_instrument_name(file->mod,qual-1);\n\tmemset(buf,0,32);\n\tif(str){\n\t\tstrncpy(buf,str,31);\n\t\topenmpt_free_string(str);\n\t}\n\tif(buff){\n\t\tstrncpy(buff,buf,32);\n\t}\n\treturn (unsigned int)strlen(buf);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void wdm_in_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc = urb->context;\n\tint status = urb->status;\n\n\tspin_lock(&desc->iuspin);\n\tclear_bit(WDM_RESPONDING, &desc->flags);\n\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdesc->rerr = status;\n\tdesc->reslength = urb->actual_length;\n\tmemmove(desc->ubuf + desc->length, desc->inbuf, desc->reslength);\n\tdesc->length += desc->reslength;\nskip_error:\n\twake_up(&desc->wait);\n\n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void wdm_in_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc = urb->context;\n\tint status = urb->status;\n\tint length = urb->actual_length;\n\n\tspin_lock(&desc->iuspin);\n\tclear_bit(WDM_RESPONDING, &desc->flags);\n\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\");\n\t\t\tgoto skip_error;\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdesc->rerr = status;\n\tif (length + desc->length > desc->wMaxCommand) {\n\t\t/* The buffer would overflow */\n\t\tset_bit(WDM_OVERFLOW, &desc->flags);\n\t} else {\n\t\t/* we may already be in overflow */\n\t\tif (!test_bit(WDM_OVERFLOW, &desc->flags)) {\n\t\t\tmemmove(desc->ubuf + desc->length, desc->inbuf, length);\n\t\t\tdesc->length += length;\n\t\t\tdesc->reslength = length;\n\t\t}\n\t}\nskip_error:\n\twake_up(&desc->wait);\n\n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t * We need to lookup the dst_entry to get the correct window size.\n\t * This is taken from tcp_v6_syn_recv_sock.  Somebody please enlighten\n\t * me if there is a preferred way.\n\t */\n\t{\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = IPPROTO_TCP;\n\t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\t\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n\t\tfl6.saddr = ireq->ir_v6_loc_addr;\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = ireq->ir_mark;\n\t\tfl6.fl6_dport = ireq->ir_rmt_port;\n\t\tfl6.fl6_sport = inet_sk(sk)->inet_sport;\n\t\tsecurity_req_classify_flow(req, flowi6_to_flowi(&fl6));\n\n\t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\t\tif (IS_ERR(dst))\n\t\t\tgoto out_free;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t * We need to lookup the dst_entry to get the correct window size.\n\t * This is taken from tcp_v6_syn_recv_sock.  Somebody please enlighten\n\t * me if there is a preferred way.\n\t */\n\t{\n\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = IPPROTO_TCP;\n\t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\t\tfinal_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);\n\t\tfl6.saddr = ireq->ir_v6_loc_addr;\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = ireq->ir_mark;\n\t\tfl6.fl6_dport = ireq->ir_rmt_port;\n\t\tfl6.fl6_sport = inet_sk(sk)->inet_sport;\n\t\tsecurity_req_classify_flow(req, flowi6_to_flowi(&fl6));\n\n\t\tdst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n\t\tif (IS_ERR(dst))\n\t\t\tgoto out_free;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "ins_compl_add_infercase(\n    char_u\t*str_arg,\n    int\t\tlen,\n    int\t\ticase,\n    char_u\t*fname,\n    int\t\tdir,\n    int\t\tcont_s_ipos)  // next ^X<> will set initial_pos\n{\n    char_u\t*str = str_arg;\n    char_u\t*p;\n    int\t\tactual_len;\t\t// Take multi-byte characters\n    int\t\tactual_compl_length;\t// into account.\n    int\t\tmin_len;\n    int\t\tflags = 0;\n\n    if (p_ic && curbuf->b_p_inf && len > 0)\n    {\n\t// Infer case of completed part.\n\n\t// Find actual length of completion.\n\tif (has_mbyte)\n\t{\n\t    p = str;\n\t    actual_len = 0;\n\t    while (*p != NUL)\n\t    {\n\t\tMB_PTR_ADV(p);\n\t\t++actual_len;\n\t    }\n\t}\n\telse\n\t    actual_len = len;\n\n\t// Find actual length of original text.\n\tif (has_mbyte)\n\t{\n\t    p = compl_orig_text;\n\t    actual_compl_length = 0;\n\t    while (*p != NUL)\n\t    {\n\t\tMB_PTR_ADV(p);\n\t\t++actual_compl_length;\n\t    }\n\t}\n\telse\n\t    actual_compl_length = compl_length;\n\n\t// \"actual_len\" may be smaller than \"actual_compl_length\" when using\n\t// thesaurus, only use the minimum when comparing.\n\tmin_len = actual_len < actual_compl_length\n\t\t\t\t\t   ? actual_len : actual_compl_length;\n\n\tstr = ins_compl_infercase_gettext(str, actual_len, actual_compl_length,\n\t\t\t\t\t\t\t\tmin_len);\n    }\n    if (cont_s_ipos)\n\tflags |= CP_CONT_S_IPOS;\n    if (icase)\n\tflags |= CP_ICASE;\n\n    return ins_compl_add(str, len, fname, NULL, NULL, dir, flags, FALSE);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "ins_compl_add_infercase(\n    char_u\t*str_arg,\n    int\t\tlen,\n    int\t\ticase,\n    char_u\t*fname,\n    int\t\tdir,\n    int\t\tcont_s_ipos)  // next ^X<> will set initial_pos\n{\n    char_u\t*str = str_arg;\n    char_u\t*p;\n    int\t\tchar_len;\t\t// count multi-byte characters\n    int\t\tcompl_char_len;\n    int\t\tmin_len;\n    int\t\tflags = 0;\n    int\t\tres;\n    char_u\t*tofree = NULL;\n\n    if (p_ic && curbuf->b_p_inf && len > 0)\n    {\n\t// Infer case of completed part.\n\n\t// Find actual length of completion.\n\tif (has_mbyte)\n\t{\n\t    p = str;\n\t    char_len = 0;\n\t    while (*p != NUL)\n\t    {\n\t\tMB_PTR_ADV(p);\n\t\t++char_len;\n\t    }\n\t}\n\telse\n\t    char_len = len;\n\n\t// Find actual length of original text.\n\tif (has_mbyte)\n\t{\n\t    p = compl_orig_text;\n\t    compl_char_len = 0;\n\t    while (*p != NUL)\n\t    {\n\t\tMB_PTR_ADV(p);\n\t\t++compl_char_len;\n\t    }\n\t}\n\telse\n\t    compl_char_len = compl_length;\n\n\t// \"char_len\" may be smaller than \"compl_char_len\" when using\n\t// thesaurus, only use the minimum when comparing.\n\tmin_len = char_len < compl_char_len ? char_len : compl_char_len;\n\n\tstr = ins_compl_infercase_gettext(str, char_len,\n\t\t\t\t\t  compl_char_len, min_len, &tofree);\n    }\n    if (cont_s_ipos)\n\tflags |= CP_CONT_S_IPOS;\n    if (icase)\n\tflags |= CP_ICASE;\n\n    res = ins_compl_add(str, len, fname, NULL, NULL, dir, flags, FALSE);\n    vim_free(tofree);\n    return res;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static pj_status_t ssl_get_srtp_material(dtls_srtp *ds, unsigned idx)\n{\n    unsigned char material[SRTP_MAX_KEY_LEN * 2];\n    SRTP_PROTECTION_PROFILE *profile;\n    int rc, i, crypto_idx = -1;\n    pjmedia_srtp_crypto *tx, *rx;\n    pj_status_t status = PJ_SUCCESS;\n\n    pj_lock_acquire(ds->ossl_lock);\n\n    if (!ds->ossl_ssl[idx]) {\n        status = PJ_EGONE;\n        goto on_return;\n    }\n\n    /* Get selected crypto-suite */\n    profile = SSL_get_selected_srtp_profile(ds->ossl_ssl[idx]);\n    if (!profile) {\n        status = PJMEDIA_SRTP_DTLS_ENOCRYPTO;\n            k2 = tx->key.ptr;\n        }\n        pj_memcpy(k1, p, key_len); p += key_len;\n        pj_memcpy(k2, p, key_len); p += key_len;\n        pj_memcpy(k1+key_len, p, salt_len); p += salt_len;\n        pj_memcpy(k2+key_len, p, salt_len);\n        ds->got_keys = PJ_TRUE;\n    }\n\non_return:\n    pj_lock_release(ds->ossl_lock);\n    return status;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static pj_status_t ssl_get_srtp_material(dtls_srtp *ds, unsigned idx)\n{\n    unsigned char material[SRTP_MAX_KEY_LEN * 2];\n    SRTP_PROTECTION_PROFILE *profile;\n    int rc, i, crypto_idx = -1;\n    pjmedia_srtp_crypto *tx, *rx;\n    pj_status_t status = PJ_SUCCESS;\n\n    DTLS_LOCK(ds);\n\n    if (!ds->ossl_ssl[idx]) {\n        status = PJ_EGONE;\n        goto on_return;\n    }\n\n    /* Get selected crypto-suite */\n    profile = SSL_get_selected_srtp_profile(ds->ossl_ssl[idx]);\n    if (!profile) {\n        status = PJMEDIA_SRTP_DTLS_ENOCRYPTO;\n            k2 = tx->key.ptr;\n        }\n        pj_memcpy(k1, p, key_len); p += key_len;\n        pj_memcpy(k2, p, key_len); p += key_len;\n        pj_memcpy(k1+key_len, p, salt_len); p += salt_len;\n        pj_memcpy(k2+key_len, p, salt_len);\n        ds->got_keys = PJ_TRUE;\n    }\n\non_return:\n    DTLS_UNLOCK(ds);\n    return status;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tif (info.index == VFIO_PCI_INTX_IRQ_INDEX)\n\t\t\tinfo.flags |= (VFIO_IRQ_INFO_MASKABLE |\n\t\t\t\t       VFIO_IRQ_INFO_AUTOMASKED);\n\t\telse\n\t\t\tinfo.flags |= VFIO_IRQ_INFO_NORESIZE;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_SET_IRQS) {\n\t\tstruct vfio_irq_set hdr;\n\t\tu8 *data = NULL;\n\t\tint ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||\n\t\t    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |\n\t\t\t\t  VFIO_IRQ_SET_ACTION_TYPE_MASK))\n\t\t\treturn -EINVAL;\n\n\t\tif (!(hdr.flags & VFIO_IRQ_SET_DATA_NONE)) {\n\t\t\tsize_t size;\n\t\t\tint max = vfio_pci_get_irq_count(vdev, hdr.index);\n\n\t\t\tif (hdr.flags & VFIO_IRQ_SET_DATA_BOOL)\n\t\t\t\tsize = sizeof(uint8_t);\n\t\t\telse if (hdr.flags & VFIO_IRQ_SET_DATA_EVENTFD)\n\t\t\t\tsize = sizeof(int32_t);\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (hdr.argsz - minsz < hdr.count * size ||\n\t\t\t    hdr.start >= max || hdr.start + hdr.count > max)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t   hdr.count * size);\n\t\t\tif (IS_ERR(data))\n\t\t\t\treturn PTR_ERR(data);\n\t\t}\n\n\t\tmutex_lock(&vdev->igate);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\tinfo.flags |= (VFIO_IRQ_INFO_MASKABLE |\n\t\t\t\t       VFIO_IRQ_INFO_AUTOMASKED);\n\t\telse\n\t\t\tinfo.flags |= VFIO_IRQ_INFO_NORESIZE;\n\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_SET_IRQS) {\n\t\tstruct vfio_irq_set hdr;\n\t\tsize_t size;\n\t\tu8 *data = NULL;\n\t\tint max, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||\n\t\t    hdr.count >= (U32_MAX - hdr.start) ||\n\t\t    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |\n\t\t\t\t  VFIO_IRQ_SET_ACTION_TYPE_MASK))\n\t\t\treturn -EINVAL;\n\n\t\tmax = vfio_pci_get_irq_count(vdev, hdr.index);\n\t\tif (hdr.start >= max || hdr.start + hdr.count > max)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (hdr.flags & VFIO_IRQ_SET_DATA_TYPE_MASK) {\n\t\tcase VFIO_IRQ_SET_DATA_NONE:\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_BOOL:\n\t\t\tsize = sizeof(uint8_t);\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_EVENTFD:\n\t\t\tsize = sizeof(int32_t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (size) {\n\t\t\tif (hdr.argsz - minsz < hdr.count * size)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t   hdr.count * size);\n\t\t\tif (IS_ERR(data))\n\t\t\t\treturn PTR_ERR(data);\n\t\t}\n\n\t\tmutex_lock(&vdev->igate);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "   if(error)\n      return ERROR_INVALID_REQUEST;\n\n   //The Request-URI is following the method token\n   token = osStrtok_r(NULL, \" \\r\\n\", &p);\n   //Unable to retrieve the Request-URI?\n   if(token == NULL)\n      return ERROR_INVALID_REQUEST;\n\n   //Check whether a query string is present\n   s = strchr(token, '?');\n\n   //Query string found?\n   if(s != NULL)\n   {\n      //Split the string\n      *s = '\\0';\n\n      //Save the Request-URI\n      error = httpDecodePercentEncodedString(token,\n         connection->request.uri, HTTP_SERVER_URI_MAX_LEN);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "   if(error)\n      return ERROR_INVALID_REQUEST;\n\n   //The Request-URI is following the method token\n   token = osStrtok_r(NULL, \" \\r\\n\", &p);\n   //Unable to retrieve the Request-URI?\n   if(token == NULL)\n      return ERROR_INVALID_REQUEST;\n\n   //Check whether a query string is present\n   s = osStrchr(token, '?');\n\n   //Query string found?\n   if(s != NULL)\n   {\n      //Split the string\n      *s = '\\0';\n\n      //Save the Request-URI\n      error = httpDecodePercentEncodedString(token,\n         connection->request.uri, HTTP_SERVER_URI_MAX_LEN);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "{\n    int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';\n    char_u\t*name_start = eap->arg;\n    char_u\t*name_end = to_name_end(eap->arg, TRUE);\n    int\t\toff;\n    char_u\t*func_name;\n    char_u\t*lambda_name;\n    ufunc_T\t*ufunc;\n    int\t\tr = FAIL;\n    compiletype_T   compile_type;\n    isn_T\t*funcref_isn = NULL;\n\n    if (eap->forceit)\n    {\n\temsg(_(e_cannot_use_bang_with_nested_def));\n\treturn NULL;\n    }\n\n    if (*name_start == '/')\n    {\n\tname_end = skip_regexp(name_start + 1, '/', TRUE);\n    // recursive call.\n    if (is_global)\n    {\n\tr = generate_NEWFUNC(cctx, lambda_name, func_name);\n\tfunc_name = NULL;\n\tlambda_name = NULL;\n    }\n    else\n    {\n\t// Define a local variable for the function reference.\n\tlvar_T\t*lvar = reserve_local(cctx, func_name, name_end - name_start,\n\t\t\t\t\t\t    TRUE, ufunc->uf_func_type);\n\n\tif (lvar == NULL)\n\t    goto theend;\n\tif (generate_FUNCREF(cctx, ufunc, &funcref_isn) == FAIL)\n\t    goto theend;\n\tr = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);\n    }\n\n    compile_type = get_compile_type(ufunc);\n#ifdef FEAT_PROFILE\n    // If the outer function is profiled, also compile the nested function for\n    // profiling.\n    if (cctx->ctx_compile_type == CT_PROFILE)\n\tcompile_type = CT_PROFILE;\n#endif\n    if (func_needs_compiling(ufunc, compile_type)\n\t    && compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)\n    {\n\tfunc_ptr_unref(ufunc);\n\tgoto theend;\n    }\n\n#ifdef FEAT_PROFILE\n    // When the outer function is compiled for profiling, the nested function\n    // may be called without profiling.  Compile it here in the right context.\n    if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))\n\tcompile_def_function(ufunc, FALSE, CT_NONE, cctx);\n#endif\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';\n    char_u\t*name_start = eap->arg;\n    char_u\t*name_end = to_name_end(eap->arg, TRUE);\n    int\t\toff;\n    char_u\t*func_name;\n    char_u\t*lambda_name;\n    ufunc_T\t*ufunc;\n    int\t\tr = FAIL;\n    compiletype_T   compile_type;\n    isn_T\t*funcref_isn = NULL;\n    lvar_T\t*lvar = NULL;\n\n    if (eap->forceit)\n    {\n\temsg(_(e_cannot_use_bang_with_nested_def));\n\treturn NULL;\n    }\n\n    if (*name_start == '/')\n    {\n\tname_end = skip_regexp(name_start + 1, '/', TRUE);\n    // recursive call.\n    if (is_global)\n    {\n\tr = generate_NEWFUNC(cctx, lambda_name, func_name);\n\tfunc_name = NULL;\n\tlambda_name = NULL;\n    }\n    else\n    {\n\t// Define a local variable for the function reference.\n\tlvar = reserve_local(cctx, func_name, name_end - name_start,\n\t\t\t\t\t\t    TRUE, ufunc->uf_func_type);\n\tif (lvar == NULL)\n\t    goto theend;\n\tif (generate_FUNCREF(cctx, ufunc, &funcref_isn) == FAIL)\n\t    goto theend;\n\tr = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);\n    }\n\n    compile_type = get_compile_type(ufunc);\n#ifdef FEAT_PROFILE\n    // If the outer function is profiled, also compile the nested function for\n    // profiling.\n    if (cctx->ctx_compile_type == CT_PROFILE)\n\tcompile_type = CT_PROFILE;\n#endif\n    if (func_needs_compiling(ufunc, compile_type)\n\t    && compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)\n    {\n\tfunc_ptr_unref(ufunc);\n\tif (lvar != NULL)\n\t    // Now the local variable can't be used.\n\t    *lvar->lv_name = '/';  // impossible value\n\tgoto theend;\n    }\n\n#ifdef FEAT_PROFILE\n    // When the outer function is compiled for profiling, the nested function\n    // may be called without profiling.  Compile it here in the right context.\n    if (compile_type == CT_PROFILE && func_needs_compiling(ufunc, CT_NONE))\n\tcompile_def_function(ufunc, FALSE, CT_NONE, cctx);\n#endif\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void CLASS foveon_load_camf()\n{\n  unsigned type, wide, high, i, j, row, col, diff;\n  ushort huff[258], vpred[2][2] = {{512,512},{512,512}}, hpred[2];\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  type = get4();  get4();  get4();\n  wide = get4();\n  high = get4();\n  if (type == 2) {\n    fread (meta_data, 1, meta_length, ifp);\n    for (i=0; i < meta_length; i++) {\n      high = (high * 1597 + 51749) % 244944;\n      wide = high * (INT64) 301593171 >> 24;\n      meta_data[i] ^= ((((high << 8) - wide) >> 1) + wide) >> 17;\n    }\n  } else if (type == 4) {\n    free (meta_data);\n    meta_data = (char *) malloc (meta_length = wide*high*3/2);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void CLASS foveon_load_camf()\n{\n  unsigned type, wide, high, i, j, row, col, diff;\n  ushort huff[1024], vpred[2][2] = {{512,512},{512,512}}, hpred[2];\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  type = get4();  get4();  get4();\n  wide = get4();\n  high = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(wide>32767 || high > 32767 || wide*high > 20000000)\n     throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  if (type == 2) {\n    fread (meta_data, 1, meta_length, ifp);\n    for (i=0; i < meta_length; i++) {\n      high = (high * 1597 + 51749) % 244944;\n      wide = high * (INT64) 301593171 >> 24;\n      meta_data[i] ^= ((((high << 8) - wide) >> 1) + wide) >> 17;\n    }\n  } else if (type == 4) {\n    free (meta_data);\n    meta_data = (char *) malloc (meta_length = wide*high*3/2);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    void reposition(int pos) { ptr = start + pos; }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    void reposition(size_t pos) { ptr = start + pos; }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void test_parser(void) {\n\tint i, retval;\n\tbzrtpPacket_t *zrtpPacket;\n\n\t/* Create zrtp Context to use H0-H3 chains and others */\n\tbzrtpContext_t *context87654321 = bzrtp_createBzrtpContext(0x87654321);\n\tbzrtpContext_t *context12345678 = bzrtp_createBzrtpContext(0x12345678);\n\n\n\t/* replace created H by the patterns one to be able to generate the correct packet */\n\tmemcpy (context12345678->channelContext[0]->selfH[0], H12345678[0], 32);\n\tmemcpy (context12345678->channelContext[0]->selfH[1], H12345678[1], 32);\n\tmemcpy (context12345678->channelContext[0]->selfH[2], H12345678[2], 32);\n\tmemcpy (context12345678->channelContext[0]->selfH[3], H12345678[3], 32);\n\tmemcpy (context87654321->channelContext[0]->selfH[0], H87654321[0], 32);\n\tmemcpy (context87654321->channelContext[0]->selfH[1], H87654321[1], 32);\n\tmemcpy (context87654321->channelContext[0]->selfH[2], H87654321[2], 32);\n\tmemcpy (context87654321->channelContext[0]->selfH[3], H87654321[3], 32);\n\n\t/* preset the key agreement algo in the contexts */\n\tcontext87654321->channelContext[0]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k;\n\tcontext12345678->channelContext[0]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k;\n\tcontext87654321->channelContext[0]->cipherAlgo = ZRTP_CIPHER_AES1;\n\tcontext12345678->channelContext[0]->cipherAlgo = ZRTP_CIPHER_AES1;\n\tcontext87654321->channelContext[0]->hashAlgo = ZRTP_HASH_S256;\n\tcontext12345678->channelContext[0]->hashAlgo = ZRTP_HASH_S256;\n\n\tupdateCryptoFunctionPointers(context87654321->channelContext[0]);\n\tupdateCryptoFunctionPointers(context12345678->channelContext[0]);\n\n\t/* set the zrtp and mac keys */\n\tcontext87654321->channelContext[0]->mackeyi = (uint8_t *)malloc(32);\n\tcontext12345678->channelContext[0]->mackeyi = (uint8_t *)malloc(32);\n\tcontext87654321->channelContext[0]->mackeyr = (uint8_t *)malloc(32);\n\tcontext12345678->channelContext[0]->mackeyr = (uint8_t *)malloc(32);\n\n\tcontext87654321->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(16);\n\tcontext12345678->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(16);\n\tcontext87654321->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(16);\n\tcontext12345678->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(16);\n\n\tmemcpy(context12345678->channelContext[0]->mackeyi, mackeyi, 32);\n\tmemcpy(context12345678->channelContext[0]->mackeyr, mackeyr, 32);\n\tmemcpy(context12345678->channelContext[0]->zrtpkeyi, zrtpkeyi, 16);\n\tmemcpy(context12345678->channelContext[0]->zrtpkeyr, zrtpkeyr, 16);\n\tmemcpy(context87654321->channelContext[0]->mackeyi, mackeyi, 32);\n\tmemcpy(context87654321->channelContext[0]->mackeyr, mackeyr, 32);\n\tmemcpy(context87654321->channelContext[0]->zrtpkeyi, zrtpkeyi, 16);\n\tmemcpy(context87654321->channelContext[0]->zrtpkeyr, zrtpkeyr, 16);\n\n\t/* set the role: 87654321 is initiator in our exchange pattern */\n\tcontext12345678->channelContext[0]->role = RESPONDER;\n\n\tfor (i=0; i<TEST_PACKET_NUMBER; i++) {\n\t\tuint8_t freePacketFlag = 1;\n\t\t/* parse a packet string from patterns */\n\t\tzrtpPacket = bzrtp_packetCheck(patternZRTPPackets[i], patternZRTPMetaData[i][0], (patternZRTPMetaData[i][1])-1, &retval);\n\t\tretval +=  bzrtp_packetParser((patternZRTPMetaData[i][2]==0x87654321)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x87654321)?context12345678->channelContext[0]:context87654321->channelContext[0], patternZRTPPackets[i], patternZRTPMetaData[i][0], zrtpPacket);\n\t\t/*printf(\"parsing Ret val is %x index is %d\\n\", retval, i);*/\n\t\t/* We must store some packets in the context if we want to be able to parse further packets */\n\t\tif (zrtpPacket->messageType==MSGTYPE_HELLO) {\n\t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n\t\t\t\tcontext12345678->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t} else {\n\t\t\t\tcontext87654321->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t}\n\t\t\tfreePacketFlag = 0;\n\t\t}\n\t\tif (zrtpPacket->messageType==MSGTYPE_COMMIT) {\n\t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n\t\t\t\tcontext12345678->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t} else {\n\t\t\t\tcontext87654321->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t}\n\t\t\tfreePacketFlag = 0;\n\t\t}\n\t\tif (zrtpPacket->messageType==MSGTYPE_DHPART1 || zrtpPacket->messageType==MSGTYPE_DHPART2) {\n\t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n\t\t\t\tcontext12345678->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t} else {\n\t\t\t\tcontext87654321->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t}\n\t\t\tfreePacketFlag = 0;\n\t\t}\n\t\t/* free the packet string as will be created again by the packetBuild function and might have been copied by packetParser */\n\t\tfree(zrtpPacket->packetString);\n\t\t/* build a packet string from the parser packet*/\n\t\tretval = bzrtp_packetBuild((patternZRTPMetaData[i][2]==0x12345678)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x12345678)?context12345678->channelContext[0]:context87654321->channelContext[0], zrtpPacket, patternZRTPMetaData[i][1]);\n\t\t/* if (retval ==0) {\n\t\t\tpacketDump(zrtpPacket, 1);\n\t\t} else {\n\t\t\tbzrtp_message(\"Ret val is %x index is %d\\n\", retval, i);\n\t\t}*/\n\n\t\t/* check they are the same */\n\t\tif (zrtpPacket->packetString != NULL) {\n\t\t\tCU_ASSERT_TRUE(memcmp(zrtpPacket->packetString, patternZRTPPackets[i], patternZRTPMetaData[i][0]) == 0);\n\t\t} else {\n\t\t\tCU_FAIL(\"Unable to build packet\");\n\t\t}\n\n\t\tif (freePacketFlag == 1) {\n\t\t\tbzrtp_freeZrtpPacket(zrtpPacket);\n\t\t}\n\t}\n\n\tbzrtp_destroyBzrtpContext(context87654321, 0x87654321);\n\tbzrtp_destroyBzrtpContext(context12345678, 0x12345678);\n\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void test_parser(void) {\n\ttest_parser_param(0);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "PlayerGeneric::~PlayerGeneric()\n{\n\tif (mixer)\n\t\tdelete mixer;\n\n\tif (player)\n\t{\n\t\tif (mixer->isActive() && !mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\tdelete player;\n\t}\n\n\tdelete[] audioDriverName;\n\t\n\tdelete listener;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "PlayerGeneric::~PlayerGeneric()\n{\n\n\tif (player)\n\t{\n\t\tif (mixer && mixer->isActive() && !mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\tdelete player;\n\t}\n\t\n\tif (mixer)\n\t\tdelete mixer;\n\n\tdelete[] audioDriverName;\n\t\n\tdelete listener;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "                return l2info.header_len;\n        }\n\n        if (l2info.direction != JUNIPER_BPF_PKT_IN && /* ether-over-1483 encaps ? */\n            (EXTRACT_32BITS(l2info.cookie) & ATM2_GAP_COUNT_MASK)) {\n            ether_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            return l2info.header_len;\n        }\n\n        if (p[0] == 0x03) { /* Cisco style NLPID encaps ? */\n            isoclns_print(ndo, p + 1, l2info.length - 1, l2info.caplen - 1);\n            /* FIXME check if frame was recognized */\n            return l2info.header_len;\n        }\n\n        if(juniper_ppp_heuristic_guess(ndo, p, l2info.length) != 0) /* PPPoA vcmux encaps ? */\n            return l2info.header_len;\n\n        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) /* last try - vcmux encaps ? */\n            return l2info.header_len;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "                return l2info.header_len;\n        }\n\n        if (l2info.direction != JUNIPER_BPF_PKT_IN && /* ether-over-1483 encaps ? */\n            (EXTRACT_32BITS(l2info.cookie) & ATM2_GAP_COUNT_MASK)) {\n            ether_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            return l2info.header_len;\n        }\n\n        if (p[0] == 0x03) { /* Cisco style NLPID encaps ? */\n            isoclns_print(ndo, p + 1, l2info.length - 1);\n            /* FIXME check if frame was recognized */\n            return l2info.header_len;\n        }\n\n        if(juniper_ppp_heuristic_guess(ndo, p, l2info.length) != 0) /* PPPoA vcmux encaps ? */\n            return l2info.header_len;\n\n        if (ip_heuristic_guess(ndo, p, l2info.length) != 0) /* last try - vcmux encaps ? */\n            return l2info.header_len;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "                NBLSetRSCInfo(pContext, pNBL, pPacketInfo, *pnCoalescedSegmentsCount);\n            }\n            else\n#endif\n            {\n                csRes = ParaNdis_CheckRxChecksum(\n                    pContext,\n                    pHeader->flags,\n                    &pBuffersDesc->PhysicalPages[PARANDIS_FIRST_RX_DATA_PAGE],\n                    pPacketInfo->dataLength,\n                    nBytesStripped);\n                if (csRes.value)\n                {\n                    NDIS_TCP_IP_CHECKSUM_NET_BUFFER_LIST_INFO qCSInfo;\n                    qCSInfo.Value = NULL;\n                    qCSInfo.Receive.IpChecksumFailed = csRes.flags.IpFailed;\n                    qCSInfo.Receive.IpChecksumSucceeded = csRes.flags.IpOK;\n                    qCSInfo.Receive.TcpChecksumFailed = csRes.flags.TcpFailed;\n                    qCSInfo.Receive.TcpChecksumSucceeded = csRes.flags.TcpOK;\n                    qCSInfo.Receive.UdpChecksumFailed = csRes.flags.UdpFailed;\n                    qCSInfo.Receive.UdpChecksumSucceeded = csRes.flags.UdpOK;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "                NBLSetRSCInfo(pContext, pNBL, pPacketInfo, *pnCoalescedSegmentsCount);\n            }\n            else\n#endif\n            {\n                csRes = ParaNdis_CheckRxChecksum(\n                    pContext,\n                    pHeader->flags,\n                    &pBuffersDesc->PhysicalPages[PARANDIS_FIRST_RX_DATA_PAGE],\n                    pPacketInfo->dataLength,\n                    nBytesStripped, TRUE);\n                if (csRes.value)\n                {\n                    NDIS_TCP_IP_CHECKSUM_NET_BUFFER_LIST_INFO qCSInfo;\n                    qCSInfo.Value = NULL;\n                    qCSInfo.Receive.IpChecksumFailed = csRes.flags.IpFailed;\n                    qCSInfo.Receive.IpChecksumSucceeded = csRes.flags.IpOK;\n                    qCSInfo.Receive.TcpChecksumFailed = csRes.flags.TcpFailed;\n                    qCSInfo.Receive.TcpChecksumSucceeded = csRes.flags.TcpOK;\n                    qCSInfo.Receive.UdpChecksumFailed = csRes.flags.UdpFailed;\n                    qCSInfo.Receive.UdpChecksumSucceeded = csRes.flags.UdpOK;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "label (const uint8_t * src, size_t srclen, uint8_t * dst, size_t * dstlen,\n       int flags)\n{\n  size_t plen;\n  uint32_t *p;\n  int rc;\n  size_t tmpl;\n\n  if (_idn2_ascii_p (src, srclen))\n    {\n      if (flags & IDN2_ALABEL_ROUNDTRIP)\n\t/* FIXME implement this MAY:\n\n\t   If the input to this procedure appears to be an A-label\n\t   (i.e., it starts in \"xn--\", interpreted\n\t   case-insensitively), the lookup application MAY attempt to\n\t   convert it to a U-label, first ensuring that the A-label is\n\t   entirely in lowercase (converting it to lowercase if\n\t   necessary), and apply the tests of Section 5.4 and the\n\t   conversion of Section 5.5 to that form. */\n\treturn IDN2_INVALID_FLAGS;\n\n      if (srclen > IDN2_LABEL_MAX_LENGTH)\n\treturn IDN2_TOO_BIG_LABEL;\n      if (srclen > *dstlen)\n\treturn IDN2_TOO_BIG_DOMAIN;\n\n      memcpy (dst, src, srclen);\n      *dstlen = srclen;\n      return IDN2_OK;\n    }\n\n  rc = _idn2_u8_to_u32_nfc (src, srclen, &p, &plen, flags & IDN2_NFC_INPUT);\n  if (rc != IDN2_OK)\n    return rc;\n\n  if (!(flags & IDN2_TRANSITIONAL))\n    {\n      rc = _idn2_label_test(\n\tTEST_NFC |\n\tTEST_2HYPHEN |\n\tTEST_LEADING_COMBINING |\n\tTEST_DISALLOWED |\n\tTEST_CONTEXTJ_RULE |\n\tTEST_CONTEXTO_WITH_RULE |\n\tTEST_UNASSIGNED | TEST_BIDI |\n\t((flags & IDN2_NONTRANSITIONAL) ? TEST_NONTRANSITIONAL : 0) |\n\t((flags & IDN2_USE_STD3_ASCII_RULES) ? 0 : TEST_ALLOW_STD3_DISALLOWED),\n\tp, plen);\n\n      if (rc != IDN2_OK)\n\t{\n\t  free(p);\n\t  return rc;\n\t}\n    }\n\n  dst[0] = 'x';\n  dst[1] = 'n';\n  dst[2] = '-';\n  dst[3] = '-';\n\n  tmpl = *dstlen - 4;\n  rc = _idn2_punycode_encode (plen, p, &tmpl, (char *) dst + 4);\n  free (p);\n  if (rc != IDN2_OK)\n    return rc;\n\n  *dstlen = 4 + tmpl;\n\n  return IDN2_OK;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "label (const uint8_t * src, size_t srclen, uint8_t * dst, size_t * dstlen,\n       int flags)\n{\n  size_t plen;\n  uint32_t *p;\n  const uint8_t *src_org = NULL;\n  uint8_t *src_allocated = NULL;\n  int rc, check_roundtrip = 0;\n  size_t tmpl, srclen_org = 0;\n  uint32_t label_u32[IDN2_LABEL_MAX_LENGTH];\n  size_t label32_len = IDN2_LABEL_MAX_LENGTH;\n\n  if (_idn2_ascii_p (src, srclen)) {\n    if (!(flags & IDN2_NO_ALABEL_ROUNDTRIP) && srclen >= 4 && memcmp (src, \"xn--\", 4) == 0) {\n      /*\n\t If the input to this procedure appears to be an A-label\n\t (i.e., it starts in \"xn--\", interpreted\n\t case-insensitively), the lookup application MAY attempt to\n\t convert it to a U-label, first ensuring that the A-label is\n\t entirely in lowercase (converting it to lowercase if\n\t necessary), and apply the tests of Section 5.4 and the\n\t conversion of Section 5.5 to that form. */\n      rc = _idn2_punycode_decode (srclen - 4, (char *) src + 4, &label32_len, label_u32);\n      if (rc)\n\treturn rc;\n\n      check_roundtrip = 1;\n      src_org = src;\n      srclen_org = srclen;\n\n      srclen = IDN2_LABEL_MAX_LENGTH;\n      src = src_allocated = u32_to_u8 (label_u32, label32_len, NULL, &srclen);\n      if (!src) {\n\tif (errno == ENOMEM)\n\t  return IDN2_MALLOC;\n\treturn IDN2_ENCODING_ERROR;\n      }\n    } else {\n      if (srclen > IDN2_LABEL_MAX_LENGTH)\n\treturn IDN2_TOO_BIG_LABEL;\n      if (srclen > *dstlen)\n\treturn IDN2_TOO_BIG_DOMAIN;\n\n      memcpy (dst, src, srclen);\n      *dstlen = srclen;\n      return IDN2_OK;\n    }\n  }\n\n  rc = _idn2_u8_to_u32_nfc (src, srclen, &p, &plen, flags & IDN2_NFC_INPUT);\n  if (rc != IDN2_OK)\n    goto out;\n\n  if (!(flags & IDN2_TRANSITIONAL))\n    {\n      rc = _idn2_label_test(\n\tTEST_NFC |\n\tTEST_2HYPHEN |\n\tTEST_LEADING_COMBINING |\n\tTEST_DISALLOWED |\n\tTEST_CONTEXTJ_RULE |\n\tTEST_CONTEXTO_WITH_RULE |\n\tTEST_UNASSIGNED | TEST_BIDI |\n\t((flags & IDN2_NONTRANSITIONAL) ? TEST_NONTRANSITIONAL : 0) |\n\t((flags & IDN2_USE_STD3_ASCII_RULES) ? 0 : TEST_ALLOW_STD3_DISALLOWED),\n\tp, plen);\n\n      if (rc != IDN2_OK)\n\t{\n\t  free (p);\n\t  goto out;\n\t}\n    }\n\n  dst[0] = 'x';\n  dst[1] = 'n';\n  dst[2] = '-';\n  dst[3] = '-';\n\n  tmpl = *dstlen - 4;\n  rc = _idn2_punycode_encode (plen, p, &tmpl, (char *) dst + 4);\n  free (p);\n  if (rc != IDN2_OK)\n    goto out;\n\n\n  *dstlen = 4 + tmpl;\n\n  if (check_roundtrip)\n    {\n      if (srclen_org != *dstlen || memcmp (src_org, dst, srclen_org))\n      {\n        rc = IDN2_ALABEL_ROUNDTRIP_FAILED;\n\tgoto out;\n      }\n    }\n\n  rc = IDN2_OK;\n\nout:\n  free (src_allocated);\n  return rc;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "QString Helper::temporaryMountDevice(const QString &device, const QString &name, bool readonly)\n{\n    QString mount_point = mountPoint(device);\n\n    if (!mount_point.isEmpty())\n        return mount_point;\n\n    mount_point = \"%1/.%2/mount/%3\";\n    const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::TempLocation);\n\n    mount_point = mount_point.arg(tmp_paths.isEmpty() ? \"/tmp\" : tmp_paths.first()).arg(qApp->applicationName()).arg(name);\n\n    if (!QDir::current().mkpath(mount_point)) {\n        dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(mount_point));\n\n        return QString();\n    }\n\n    if (!mountDevice(device, mount_point, readonly)) {\n        dCError(\"Mount the device \\\"%s\\\" to \\\"%s\\\" failed\", qPrintable(device), qPrintable(mount_point));\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "QString Helper::temporaryMountDevice(const QString &device, const QString &name, bool readonly)\n{\n    QString mount_point = mountPoint(device);\n\n    if (!mount_point.isEmpty())\n        return mount_point;\n\n    mount_point = \"%1/.%2/mount/%3\";\n    const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::RuntimeLocation);\n\n    mount_point = mount_point.arg(tmp_paths.isEmpty() ? \"/run/user/0\" : tmp_paths.first()).arg(qApp->applicationName()).arg(name);\n\n    if (!QDir::current().mkpath(mount_point)) {\n        dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(mount_point));\n\n        return QString();\n    }\n\n    if (!mountDevice(device, mount_point, readonly)) {\n        dCError(\"Mount the device \\\"%s\\\" to \\\"%s\\\" failed\", qPrintable(device), qPrintable(mount_point));\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t/*\n\t * On routine entry dst_vma is set.  If we had to drop mmap_sem and\n\t * retry, dst_vma will be set to NULL and we must lookup again.\n\t */\n\tif (!dst_vma) {\n\t\terr = -ENOENT;\n\t\tdst_vma = find_vma(dst_mm, dst_start);\n\t\tif (!dst_vma || !is_vm_hugetlb_page(dst_vma))\n\t\t\tgoto out_unlock;\n\t\t/*\n\t\t * Only allow __mcopy_atomic_hugetlb on userfaultfd\n\t\t * registered ranges.\n\t\t */\n\t\tif (!dst_vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto out_unlock;\n\n\t\tif (dst_start < dst_vma->vm_start ||\n\t\t    dst_start + len > dst_vma->vm_end)\n\t\t\tgoto out_unlock;\n\n\t\terr = -EINVAL;\n\t\tif (vma_hpagesize != vma_kernel_pagesize(dst_vma))",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t/*\n\t * On routine entry dst_vma is set.  If we had to drop mmap_sem and\n\t * retry, dst_vma will be set to NULL and we must lookup again.\n\t */\n\tif (!dst_vma) {\n\t\terr = -ENOENT;\n\t\tdst_vma = find_vma(dst_mm, dst_start);\n\t\tif (!dst_vma || !is_vm_hugetlb_page(dst_vma))\n\t\t\tgoto out_unlock;\n\t\t/*\n\t\t * Check the vma is registered in uffd, this is\n\t\t * required to enforce the VM_MAYWRITE check done at\n\t\t * uffd registration time.\n\t\t */\n\t\tif (!dst_vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto out_unlock;\n\n\t\tif (dst_start < dst_vma->vm_start ||\n\t\t    dst_start + len > dst_vma->vm_end)\n\t\t\tgoto out_unlock;\n\n\t\terr = -EINVAL;\n\t\tif (vma_hpagesize != vma_kernel_pagesize(dst_vma))",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void validate_dex_header(const dex_header* dh,\n                                size_t dexsize,\n                                int support_dex_version) {\n  bool supported = false;\n  switch (support_dex_version) {\n  case 38:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V38, sizeof(dh->magic));\n    FALLTHROUGH_INTENDED; /* intentional fallthrough to also check for v37 */\n  case 37:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V37, sizeof(dh->magic));\n    FALLTHROUGH_INTENDED; /* intentional fallthrough to also check for v35 */\n    not_reached_log(\"Unrecognized support_dex_version %d\\n\",\n                    support_dex_version);\n  }\n  always_assert_log(supported, \"Bad dex magic %s for support_dex_version %d\\n\",\n                    dh->magic, support_dex_version);\n  always_assert_log(\n      dh->file_size == dexsize,\n      \"Reported size in header (%zu) does not match file size (%u)\\n\",\n      dexsize,\n      dh->file_size);\n  auto off = (uint64_t)dh->class_defs_off;\n  auto limit = off + dh->class_defs_size * sizeof(dex_class_def);\n  always_assert_log(off < dexsize, \"class_defs_off out of range\");\n  always_assert_log(limit <= dexsize, \"invalid class_defs_size\");\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void validate_dex_header(const dex_header* dh,\n                                size_t dexsize,\n                                int support_dex_version) {\n  always_assert_log(sizeof(dex_header) <= dexsize,\n                    \"Header size (%lu) is larger than file size (%zu)\\n\",\n                    dexsize,\n                    sizeof(dex_header));\n  bool supported = false;\n  switch (support_dex_version) {\n  case 38:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V38, sizeof(dh->magic));\n    FALLTHROUGH_INTENDED; /* intentional fallthrough to also check for v37 */\n  case 37:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V37, sizeof(dh->magic));\n    FALLTHROUGH_INTENDED; /* intentional fallthrough to also check for v35 */\n    not_reached_log(\"Unrecognized support_dex_version %d\\n\",\n                    support_dex_version);\n  }\n  always_assert_log(supported, \"Bad dex magic %s for support_dex_version %d\\n\",\n                    dh->magic, support_dex_version);\n  always_assert_log(\n      dh->file_size == dexsize,\n      \"Reported size in header (%zu) does not match file size (%u)\\n\",\n      dexsize,\n      dh->file_size);\n\n  auto str_ids_off = (uint64_t)dh->string_ids_off;\n  auto str_ids_limit =\n      str_ids_off + dh->string_ids_size * sizeof(dex_string_id);\n  always_assert_log(str_ids_off < dexsize, \"string_ids_off out of range\");\n  always_assert_log(str_ids_limit <= dexsize, \"invalid string_ids_size\");\n\n  auto type_ids_off = (uint64_t)dh->type_ids_off;\n  auto type_ids_limit = type_ids_off + dh->type_ids_size * sizeof(dex_type_id);\n  always_assert_log(type_ids_off < dexsize, \"type_ids_off out of range\");\n  always_assert_log(type_ids_limit <= dexsize, \"invalid type_ids_size\");\n\n  auto proto_ids_off = (uint64_t)dh->proto_ids_off;\n  auto proto_ids_limit =\n      proto_ids_off + dh->proto_ids_size * sizeof(dex_proto_id);\n  always_assert_log(proto_ids_off < dexsize, \"proto_ids_off out of range\");\n  always_assert_log(proto_ids_limit <= dexsize, \"invalid proto_ids_size\");\n\n  auto field_ids_off = (uint64_t)dh->field_ids_off;\n  auto field_ids_limit =\n      field_ids_off + dh->field_ids_size * sizeof(dex_field_id);\n  always_assert_log(field_ids_off < dexsize, \"field_ids_off out of range\");\n  always_assert_log(field_ids_limit <= dexsize, \"invalid field_ids_size\");\n\n  auto meth_ids_off = (uint64_t)dh->method_ids_off;\n  auto meth_ids_limit =\n      meth_ids_off + dh->method_ids_size * sizeof(dex_method_id);\n  always_assert_log(meth_ids_off < dexsize, \"method_ids_off out of range\");\n  always_assert_log(meth_ids_limit <= dexsize, \"invalid method_ids_size\");\n\n  auto cls_defs_off = (uint64_t)dh->class_defs_off;\n  auto cls_defs_limit =\n      cls_defs_off + dh->class_defs_size * sizeof(dex_class_def);\n  always_assert_log(cls_defs_off < dexsize, \"class_defs_off out of range\");\n  always_assert_log(cls_defs_limit <= dexsize, \"invalid class_defs_size\");\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    }\n\n    std::unique_ptr<GpuTimer, GpuTimerDeleter> timer;\n    const bool is_profiling = output_profile_result != nullptr;\n    if (is_profiling) {\n      timer.reset(new GpuTimer(parent_));\n      // The start and stop of the timer should be as close to the Cudnn call as\n      // possible. It is still possible for other threads to issue workload on\n      // to this stream. So it could take multiple profiling measurements.\n      if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n        return tsl::Status(port::error::INTERNAL, \"Failed to start timer\");\n      }\n    }\n\n    RETURN_IF_CUDNN_ERROR(cudnnRNNBackwardData_v8(\n        /*handle=*/cudnn.handle(), /*rnnDesc=*/rnn_desc.handle(),\n        /*devSeqLengths=*/\n        reinterpret_cast<const int*>(seq_lengths_data.opaque()),\n        /*yDesc=*/output_desc.data_handle(), /*y=*/output_data.opaque(),\n        /*dy=*/output_backprop_data.opaque(),\n        /*xDesc=*/input_desc.data_handle(),\n          /*weightSpaceSize=*/rnn_desc.ParamsSizeInBytes(),\n          /*dweightSpace=*/params_backprop_data->opaque(),\n          /*workSpaceSize=*/workspace.size(),\n          /*workSpace=*/workspace.opaque(),\n          /*reserveSpaceSize=*/reserve_space_data->size(),\n          /*reserveSpace=*/reserve_space_data->opaque()));\n    }\n\n    if (is_profiling) {\n      if (!timer->Stop(AsGpuStream(stream))) {\n        return tsl::Status(port::error::INTERNAL, \"Failed to stop timer\");\n      }\n      auto algo_desc = *rnn_desc.algorithm_config().algorithm();\n      output_profile_result->set_algorithm(algo_desc);\n      output_profile_result->set_elapsed_time_in_ms(\n          timer->GetElapsedMilliseconds());\n    }\n    return tsl::OkStatus();\n  }\n#endif\n  TF_ASSIGN_OR_RETURN(DeviceMemory<uint8_t> workspace,\n                                         workspace_allocator));\n\n  std::unique_ptr<GpuTimer, GpuTimerDeleter> timer;\n  const bool is_profiling = output_profile_result != nullptr;\n  if (is_profiling) {\n    timer.reset(new GpuTimer(parent_));\n    // The start and stop of the timer should be as close to the Cudnn call as\n    // possible. It is still possible for other threads to issue workload on\n    // to this stream. So it could take multiple profiling measurements.\n    if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n      return tsl::Status(port::error::INTERNAL, \"Failed to start timer\");\n    }\n  }\n\n  if (input_desc.is_var_seq_lengths()) {\n    RETURN_IF_CUDNN_ERROR(cudnnRNNBackwardDataEx(\n        /*handle=*/cudnn.handle(), /*rnnDesc=*/rnn_desc.handle(),\n        /*yDesc=*/output_desc.data_handle(), /*y=*/output_data.opaque(),\n        /*dyDesc=*/output_desc.data_handle(),\n        /*dy=*/output_backprop_data.opaque(), nullptr, nullptr,\n        /*dhyDesc=*/output_h_desc.handle(),\n          /*workSpaceSizeInBytes=*/workspace.size(),\n          /*dwDesc=*/rnn_desc.params_handle(),\n          /*dw=*/params_backprop_data->opaque(),\n          /*reserveSpace=*/reserve_space_data->opaque(),\n          /*reserveSpaceSizeInBytes=*/reserve_space_data->size()));\n    }\n  }\n\n  if (is_profiling) {\n    if (!timer->Stop(AsGpuStream(stream))) {\n      return tsl::Status(port::error::INTERNAL, \"Failed to stop timer\");\n    }\n    auto algo_desc = *rnn_desc.algorithm_config().algorithm();\n    output_profile_result->set_algorithm(algo_desc);\n    output_profile_result->set_elapsed_time_in_ms(\n        timer->GetElapsedMilliseconds());\n  }\n\n  return ::tsl::OkStatus();\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    }\n\n    std::unique_ptr<GpuTimer, GpuTimerDeleter> timer;\n    const bool is_profiling = output_profile_result != nullptr;\n    if (is_profiling) {\n      timer.reset(new GpuTimer(parent_));\n      // The start and stop of the timer should be as close to the Cudnn call as\n      // possible. It is still possible for other threads to issue workload on\n      // to this stream. So it could take multiple profiling measurements.\n      if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n        return tsl::Status(tsl::error::INTERNAL, \"Failed to start timer\");\n      }\n    }\n\n    RETURN_IF_CUDNN_ERROR(cudnnRNNBackwardData_v8(\n        /*handle=*/cudnn.handle(), /*rnnDesc=*/rnn_desc.handle(),\n        /*devSeqLengths=*/\n        reinterpret_cast<const int*>(seq_lengths_data.opaque()),\n        /*yDesc=*/output_desc.data_handle(), /*y=*/output_data.opaque(),\n        /*dy=*/output_backprop_data.opaque(),\n        /*xDesc=*/input_desc.data_handle(),\n          /*weightSpaceSize=*/rnn_desc.ParamsSizeInBytes(),\n          /*dweightSpace=*/params_backprop_data->opaque(),\n          /*workSpaceSize=*/workspace.size(),\n          /*workSpace=*/workspace.opaque(),\n          /*reserveSpaceSize=*/reserve_space_data->size(),\n          /*reserveSpace=*/reserve_space_data->opaque()));\n    }\n\n    if (is_profiling) {\n      if (!timer->Stop(AsGpuStream(stream))) {\n        return tsl::Status(tsl::error::INTERNAL, \"Failed to stop timer\");\n      }\n      auto algo_desc = *rnn_desc.algorithm_config().algorithm();\n      output_profile_result->set_algorithm(algo_desc);\n      output_profile_result->set_elapsed_time_in_ms(\n          timer->GetElapsedMilliseconds());\n    }\n    return tsl::OkStatus();\n  }\n#endif\n  TF_ASSIGN_OR_RETURN(DeviceMemory<uint8_t> workspace,\n                                         workspace_allocator));\n\n  std::unique_ptr<GpuTimer, GpuTimerDeleter> timer;\n  const bool is_profiling = output_profile_result != nullptr;\n  if (is_profiling) {\n    timer.reset(new GpuTimer(parent_));\n    // The start and stop of the timer should be as close to the Cudnn call as\n    // possible. It is still possible for other threads to issue workload on\n    // to this stream. So it could take multiple profiling measurements.\n    if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n      return tsl::Status(tsl::error::INTERNAL, \"Failed to start timer\");\n    }\n  }\n\n  if (input_desc.is_var_seq_lengths()) {\n    RETURN_IF_CUDNN_ERROR(cudnnRNNBackwardDataEx(\n        /*handle=*/cudnn.handle(), /*rnnDesc=*/rnn_desc.handle(),\n        /*yDesc=*/output_desc.data_handle(), /*y=*/output_data.opaque(),\n        /*dyDesc=*/output_desc.data_handle(),\n        /*dy=*/output_backprop_data.opaque(), nullptr, nullptr,\n        /*dhyDesc=*/output_h_desc.handle(),\n          /*workSpaceSizeInBytes=*/workspace.size(),\n          /*dwDesc=*/rnn_desc.params_handle(),\n          /*dw=*/params_backprop_data->opaque(),\n          /*reserveSpace=*/reserve_space_data->opaque(),\n          /*reserveSpaceSizeInBytes=*/reserve_space_data->size()));\n    }\n  }\n\n  if (is_profiling) {\n    if (!timer->Stop(AsGpuStream(stream))) {\n      return tsl::Status(tsl::error::INTERNAL, \"Failed to stop timer\");\n    }\n    auto algo_desc = *rnn_desc.algorithm_config().algorithm();\n    output_profile_result->set_algorithm(algo_desc);\n    output_profile_result->set_elapsed_time_in_ms(\n        timer->GetElapsedMilliseconds());\n  }\n\n  return ::tsl::OkStatus();\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  void Compute(OpKernelContext* context) override {\n    CHECK_EQ(3, context->num_inputs());\n    const Tensor& input = context->input(0);\n    const int depth = input.dim_size(input.dims() - 1);  // last dimension size.\n    const Tensor& min = context->input(1);\n    OP_REQUIRES(context, min.dim_size(0) == depth,\n                InvalidArgument(\"min has incorrect size, expected \", depth,\n                                \" was \", min.dim_size(0)));\n    const Tensor& max = context->input(2);\n    OP_REQUIRES(context, max.dim_size(0) == depth,\n                InvalidArgument(\"max has incorrect size, expected \", depth,\n                                \" was \", max.dim_size(0)));\n\n    Tensor* output;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &output));\n\n    FakeQuantWithMinMaxVarsPerChannelFunctor<Device> functor;\n    functor(context->eigen_device<Device>(), input.flat_inner_dims<float, 2>(),",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  void Compute(OpKernelContext* context) override {\n    CHECK_EQ(3, context->num_inputs());\n    const Tensor& input = context->input(0);\n    const int depth = input.dim_size(input.dims() - 1);  // last dimension size.\n    const Tensor& min = context->input(1);\n    const Tensor& max = context->input(2);\n\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsVector(min.shape()),\n        InvalidArgument(\"`min` must be rank 1 but is rank \", min.dims()));\n    OP_REQUIRES(context, min.dim_size(0) == depth,\n                InvalidArgument(\"min has incorrect size, expected \", depth,\n                                \" was \", min.dim_size(0)));\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsVector(max.shape()),\n        InvalidArgument(\"`max` must be rank 1 but is rank \", max.dims()));\n    OP_REQUIRES(context, max.dim_size(0) == depth,\n                InvalidArgument(\"max has incorrect size, expected \", depth,\n                                \" was \", max.dim_size(0)));\n\n    Tensor* output;\n    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, input.shape(), &output));\n\n    FakeQuantWithMinMaxVarsPerChannelFunctor<Device> functor;\n    functor(context->eigen_device<Device>(), input.flat_inner_dims<float, 2>(),",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "Java_org_tensorflow_lite_InterpreterTest_getNativeHandleForDelegate(\n    JNIEnv* env, jclass clazz) {\n  // A simple op which outputs a tensor with values of 7.\n  static TfLiteRegistration registration = {\n      .init = nullptr,\n      .free = nullptr,\n      .prepare =\n          [](TfLiteContext* context, TfLiteNode* node) {\n            const TfLiteTensor* input = tflite::GetInput(context, node, 0);\n            TfLiteTensor* output = tflite::GetOutput(context, node, 0);\n            TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n            output->type = kTfLiteFloat32;\n            return context->ResizeTensor(context, output, output_dims);\n          },\n      .invoke =\n          [](TfLiteContext* context, TfLiteNode* node) {\n            TfLiteTensor* output = tflite::GetOutput(context, node, 0);\n            std::fill(output->data.f,\n                      output->data.f + tflite::NumElements(output), 7.0f);\n            return kTfLiteOk;\n          },\n      .profiling_string = nullptr,\n      .builtin_code = 0,\n      .custom_name = \"\",\n      .version = 1,\n  };\n  static TfLiteDelegate delegate = {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "Java_org_tensorflow_lite_InterpreterTest_getNativeHandleForDelegate(\n    JNIEnv* env, jclass clazz) {\n  // A simple op which outputs a tensor with values of 7.\n  static TfLiteRegistration registration = {\n      .init = nullptr,\n      .free = nullptr,\n      .prepare =\n          [](TfLiteContext* context, TfLiteNode* node) {\n            const TfLiteTensor* input;\n            TF_LITE_ENSURE_OK(context,\n                              tflite::GetInputSafe(context, node, 0, &input));\n            TfLiteTensor* output;\n            TF_LITE_ENSURE_OK(context,\n                              tflite::GetOutputSafe(context, node, 0, &output));\n            TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n            output->type = kTfLiteFloat32;\n            return context->ResizeTensor(context, output, output_dims);\n          },\n      .invoke =\n          [](TfLiteContext* context, TfLiteNode* node) {\n            TfLiteTensor* output;\n            TF_LITE_ENSURE_OK(context,\n                              tflite::GetOutputSafe(context, node, 0, &output));\n            std::fill(output->data.f,\n                      output->data.f + tflite::NumElements(output), 7.0f);\n            return kTfLiteOk;\n          },\n      .profiling_string = nullptr,\n      .builtin_code = 0,\n      .custom_name = \"\",\n      .version = 1,\n  };\n  static TfLiteDelegate delegate = {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  void Compute(OpKernelContext* context) override {\n    const Tensor& data = context->input(0);\n    const Tensor& segment_ids = context->input(1);\n    const Tensor& num_segments = context->input(2);\n    if (!UnsortedSegmentReductionDoValidation(this, context, data, segment_ids,\n                                              num_segments)) {\n      return;\n    }\n    const auto segment_flat = segment_ids.flat<Index>();\n    const Index output_rows = internal::SubtleMustCopy(static_cast<Index>(\n        num_segments.dtype() == DT_INT32 ? num_segments.scalar<int32>()()\n                                         : num_segments.scalar<int64>()()));\n    OP_REQUIRES(context, output_rows >= 0,\n                errors::InvalidArgument(\"Input num_segments == \", output_rows,\n                                        \" must not be negative.\"));\n    TensorShape output_shape;\n    output_shape.AddDim(output_rows);\n    for (int i = segment_ids.dims(); i < data.dims(); i++) {\n      output_shape.AddDim(data.dim_size(i));\n    }\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    auto output_flat = output->flat_outer_dims<T>();\n    auto data_ptr = data.template flat<T>().data();\n    reduction_functor_(context, output_rows, segment_ids.shape(), segment_flat,\n                       data.NumElements(), data_ptr, output_flat);\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  void Compute(OpKernelContext* context) override {\n    const Tensor& data = context->input(0);\n    const Tensor& segment_ids = context->input(1);\n    const Tensor& num_segments = context->input(2);\n    if (!UnsortedSegmentReductionDoValidation(this, context, data, segment_ids,\n                                              num_segments)) {\n      return;\n    }\n    const auto segment_flat = segment_ids.flat<Index>();\n    const int64 output_rows = internal::SubtleMustCopy(static_cast<int64>(\n        num_segments.dtype() == DT_INT32 ? num_segments.scalar<int32>()()\n                                         : num_segments.scalar<int64>()()));\n    OP_REQUIRES(context, output_rows >= 0,\n                errors::InvalidArgument(\"Input num_segments == \", output_rows,\n                                        \" must not be negative.\"));\n    TensorShape output_shape;\n    output_shape.AddDim(output_rows);\n    for (int i = segment_ids.dims(); i < data.dims(); i++) {\n      output_shape.AddDim(data.dim_size(i));\n    }\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    auto output_flat = output->flat_outer_dims<T>();\n    auto data_flat = data.flat_inner_outer_dims<T, 2>(segment_ids.dims() - 1);\n    reduction_functor_(context, segment_ids.shape(), segment_flat, data_flat,\n                       output_flat);\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static bool caller_is_in_ancestor(pid_t pid, const char *contrl, const char *cg, char **nextcg)\n{\n\tchar fnam[PROCLEN];\n\tFILE *f;\n\tbool answer = false;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tint ret;\n\n\tret = snprintf(fnam, PROCLEN, \"/proc/%d/cgroup\", pid);\n\tif (ret < 0 || ret >= PROCLEN)\n\t\treturn false;\n\tif (!(f = fopen(fnam, \"r\")))\n\t\treturn false;\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *c1, *c2, *linecmp;\n\t\tif (!line[0])\n\t\t\tcontinue;\n\t\tc1 = strchr(line, ':');\n\t\tif (!c1)\n\t\t\tgoto out;\n\t\tc1++;\n\t\tc2 = strchr(c1, ':');\n\t\tif (!c2)\n\t\t\tgoto out;\n\t\t*c2 = '\\0';\n\t\tif (strcmp(c1, contrl) != 0)\n\t\t\tcontinue;\n\t\tc2++;\n\t\tstripnewline(c2);\n\t\tprune_init_slice(c2);\n\t\t/*\n\t\t * callers pass in '/' for root cgroup, otherwise they pass\n\t\t * in a cgroup without leading '/'\n\t\t */\n\t\tlinecmp = *cg == '/' ? c2 : c2+1;\n\t\tif (strncmp(linecmp, cg, strlen(linecmp)) != 0) {\n\t\t\tif (nextcg)\n\t\t\t\t*nextcg = get_next_cgroup_dir(linecmp, cg);\n\t\t\tgoto out;\n\t\t}\n\t\tanswer = true;\n\t\tgoto out;\n\t}\n\nout:\n\tfclose(f);\n\tfree(line);\n\treturn answer;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static bool caller_is_in_ancestor(pid_t pid, const char *contrl, const char *cg, char **nextcg)\n{\n\tbool answer = false;\n\tchar *c2 = get_pid_cgroup(pid, contrl);\n\tchar *linecmp;\n\n\tif (!c2)\n\t\treturn false;\n\tprune_init_slice(c2);\n\n\t/*\n\t * callers pass in '/' for root cgroup, otherwise they pass\n\t * in a cgroup without leading '/'\n\t */\n\tlinecmp = *cg == '/' ? c2 : c2+1;\n\tif (strncmp(linecmp, cg, strlen(linecmp)) != 0) {\n\t\tif (nextcg) {\n\t\t\t*nextcg = get_next_cgroup_dir(linecmp, cg);\n\t\t}\n\t\tgoto out;\n\t}\n\tanswer = true;\n\nout:\n\tfree(c2);\n\treturn answer;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void HeaderMapImpl::addCopy(const LowerCaseString& key, uint64_t value) {\n  auto* entry = getExistingInline(key.get());\n  if (entry != nullptr) {\n    char buf[32];\n    StringUtil::itoa(buf, sizeof(buf), value);\n    appendToHeader(entry->value(), buf);\n    return;\n  }\n  HeaderString new_key;\n  new_key.setCopy(key.get().c_str(), key.get().size());\n  HeaderString new_value;\n  new_value.setInteger(value);\n  insertByKey(std::move(new_key), std::move(new_value));\n  ASSERT(new_key.empty());   // NOLINT(bugprone-use-after-move)\n  ASSERT(new_value.empty()); // NOLINT(bugprone-use-after-move)\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void HeaderMapImpl::addCopy(const LowerCaseString& key, uint64_t value) {\n  auto* entry = getExistingInline(key.get());\n  if (entry != nullptr) {\n    char buf[32];\n    StringUtil::itoa(buf, sizeof(buf), value);\n    const uint64_t added_size = appendToHeader(entry->value(), buf);\n    addSize(added_size);\n    return;\n  }\n  HeaderString new_key;\n  new_key.setCopy(key.get().c_str(), key.get().size());\n  HeaderString new_value;\n  new_value.setInteger(value);\n  insertByKey(std::move(new_key), std::move(new_value));\n  ASSERT(new_key.empty());   // NOLINT(bugprone-use-after-move)\n  ASSERT(new_value.empty()); // NOLINT(bugprone-use-after-move)\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\treturn err;\n\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "GF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\t\n\te = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n\tif (e) return e;\n\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, ptr->cfg.atmos_ec3_ext, 1);\n\t\tgf_bs_write_u8(bs, ptr->cfg.complexity_index_type);\n\t}\n\treturn GF_OK;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "GF_Err dac3_box_write(GF_Box *s, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tGF_AC3ConfigBox *ptr = (GF_AC3ConfigBox *)s;\n\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\n\te = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n\tif (e) return e;\n\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\tgf_bs_write_int(bs, 0, 7);\n\t\tgf_bs_write_int(bs, ptr->cfg.atmos_ec3_ext, 1);\n\t\tgf_bs_write_u8(bs, ptr->cfg.complexity_index_type);\n\t}\n\treturn GF_OK;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "BGD_DECLARE(void) gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\t/* Seek left */\n\tint leftLimit, rightLimit;\n\tint i;\n\tint restoreAlphaBleding;\n\n\tif (border < 0) {\n\t\t/* Refuse to fill to a non-solid border */\n\t\treturn;\n\t}\n\n\tleftLimit = (-1);\n\n\trestoreAlphaBleding = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "BGD_DECLARE(void) gdImageFillToBorder (gdImagePtr im, int x, int y, int border, int color)\n{\n\tint lastBorder;\n\t/* Seek left */\n\tint leftLimit, rightLimit;\n\tint i;\n\tint restoreAlphaBleding;\n\n\tif (border < 0 || color < 0) {\n\t\t/* Refuse to fill to a non-solid border */\n\t\treturn;\n\t}\n\n\tif (!im->trueColor) {\n\t\tif ((color > (im->colorsTotal - 1)) || (border > (im->colorsTotal - 1))) {\n\t\t\treturn;\n\t\t}\n    }\n\n\tleftLimit = (-1);\n\n\trestoreAlphaBleding = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;\n\n\tif (x >= im->sx) {\n\t\tx = im->sx - 1;\n\t} else if (x < 0) {\n\t\tx = 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "{\nl_int32     i, j, w, h, d, xrat, yrat;\nPIX        *pixs, *pixd, *pixc, *pixt;\nPIX        *pixr, *pixrc, *pixg, *pixgc, *pixb, *pixbc;\nPIXTILING  *pt;\n\n    PROCNAME(\"pixBlockconvTiled\");\n\n    if (!pix)\n        return (PIX *)ERROR_PTR(\"pix not defined\", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    pixGetDimensions(pix, &w, &h, &d);\n    if (w < 2 * wc + 3 || h < 2 * hc + 3) {\n        wc = L_MAX(0, L_MIN(wc, (w - 3) / 2));\n        hc = L_MAX(0, L_MIN(hc, (h - 3) / 2));\n        L_WARNING(\"kernel too large; reducing!\\n\", procName);\n        L_INFO(\"wc = %d, hc = %d\\n\", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)   /* no-op */\n        return pixCopy(NULL, pix);\n    if (nx <= 1 && ny <= 1)\n        return pixBlockconv(pix, wc, hc);\n\n        /* Test to see if the tiles are too small.  The required\n         * condition is that the tile dimensions must be at least\n         * (wc + 2) x (hc + 2). */\n    xrat = w / nx;\n    yrat = h / ny;\n    if (xrat < wc + 2) {\n        nx = w / (wc + 2);\n        L_WARNING(\"tile width too small; nx reduced to %d\\n\", procName, nx);\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "{\nl_int32     i, j, w, h, d, xrat, yrat;\nPIX        *pixs, *pixd, *pixc, *pixt;\nPIX        *pixr, *pixrc, *pixg, *pixgc, *pixb, *pixbc;\nPIXTILING  *pt;\n\n    PROCNAME(\"pixBlockconvTiled\");\n\n    if (!pix)\n        return (PIX *)ERROR_PTR(\"pix not defined\", procName, NULL);\n    if (wc <= 0 || hc <= 0)   /* no-op */\n        return pixCopy(NULL, pix);\n    if (nx <= 1 && ny <= 1)\n        return pixBlockconv(pix, wc, hc);\n    pixGetDimensions(pix, &w, &h, &d);\n    if (w < 2 * wc + 3 || h < 2 * hc + 3) {\n        L_ERROR(\"kernel is too large: w = %d, wc = %d, h = %d, hc = %d\\n\",\n                procName, w, wc, h, hc);\n        return pixCopy(NULL, pix);\n    }\n\n        /* Test to see if the tiles are too small.  The required\n         * condition is that the tile dimensions must be at least\n         * (wc + 2) x (hc + 2). */\n    xrat = w / nx;\n    yrat = h / ny;\n    if (xrat < wc + 2) {\n        nx = w / (wc + 2);\n        L_WARNING(\"tile width too small; nx reduced to %d\\n\", procName, nx);\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteDepthToSpaceParams*>(node->builtin_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 ||\n                     data_type == kTfLiteInt8 || data_type == kTfLiteInt32 ||\n                     data_type == kTfLiteInt64);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteDepthToSpaceParams*>(node->builtin_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,\n                 data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 ||\n                     data_type == kTfLiteInt8 || data_type == kTfLiteInt32 ||\n                     data_type == kTfLiteInt64);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n    str_free(thread_list);\n#endif /* USE_OS_THREADS */\n\n    unbind_ports();\n    s_poll_free(fds);\n    fds=NULL;\n#if 0\n    str_stats(); /* main thread allocation tracking */\n#endif\n    log_flush(LOG_MODE_ERROR);\n    log_close(SINK_SYSLOG|SINK_OUTFILE);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n    str_free(thread_list);\n#endif /* USE_OS_THREADS */\n\n    unbind_ports();\n    s_poll_free(fds);\n    fds=NULL;\n#if 0\n    str_stats(); /* main thread allocation tracking */\n#endif\n    log_flush(LOG_MODE_BUFFER); /* no more logs */\n    log_close(SINK_SYSLOG|SINK_OUTFILE);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) // size is in longs not bytes.\n{\n\tif (ms)\n\t{\n\t\tint32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];\n\t\tif (nestsize == 0 && ms->nest_level == 0)\n\t\t\tnestsize = ms->buffer_size_longs;\n\n\t\tif (size + 2 <= nestsize) return GPMF_OK;\n\t}\n\treturn GPMF_ERROR_BAD_STRUCTURE;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) // size is in longs not bytes.\n{\n\tif (ms)\n\t{\n\t\tuint32_t nestsize = (uint32_t)ms->nest_size[ms->nest_level];\n\t\tif (nestsize == 0 && ms->nest_level == 0)\n\t\t\tnestsize = ms->buffer_size_longs;\n\n\t\tif (size + 2 <= nestsize) return GPMF_OK;\n\t}\n\treturn GPMF_ERROR_BAD_STRUCTURE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\terr = -EMSGSIZE;\n\t\tif (msg_sys->msg_iovlen > UIO_MAXIOV)\n\t\t\tgoto out;\n\t\terr = -ENOMEM;\n\t\tiov = kmalloc(msg_sys->msg_iovlen * sizeof(struct iovec),\n\t\t\t      GFP_KERNEL);\n\t\tif (!iov)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *      Save the user-mode address (verify_iovec will change the\n\t *      kernel msghdr to use the kernel address space)\n\t */\n\n\tuaddr = (__force void __user *)msg_sys->msg_name;\n\tuaddr_len = COMPAT_NAMELEN(msg);\n\tif (MSG_CMSG_COMPAT & flags) {\n\t\terr = verify_compat_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n\t} else\n\t\terr = verify_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n\tif (err < 0)\n\t\tgoto out_freeiov;\n\ttotal_len = err;\n\n\tcmsg_ptr = (unsigned long)msg_sys->msg_control;\n\tmsg_sys->msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\terr = (nosec ? sock_recvmsg_nosec : sock_recvmsg)(sock, msg_sys,\n\t\t\t\t\t\t\t  total_len, flags);\n\tif (err < 0)\n\t\tgoto out_freeiov;\n\tlen = err;\n\n\tif (uaddr != NULL) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\terr = -EMSGSIZE;\n\t\tif (msg_sys->msg_iovlen > UIO_MAXIOV)\n\t\t\tgoto out;\n\t\terr = -ENOMEM;\n\t\tiov = kmalloc(msg_sys->msg_iovlen * sizeof(struct iovec),\n\t\t\t      GFP_KERNEL);\n\t\tif (!iov)\n\t\t\tgoto out;\n\t}\n\n\t/* Save the user-mode address (verify_iovec will change the\n\t * kernel msghdr to use the kernel address space)\n\t */\n\tuaddr = (__force void __user *)msg_sys->msg_name;\n\tuaddr_len = COMPAT_NAMELEN(msg);\n\tif (MSG_CMSG_COMPAT & flags)\n\t\terr = verify_compat_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n\telse\n\t\terr = verify_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n\tif (err < 0)\n\t\tgoto out_freeiov;\n\ttotal_len = err;\n\n\tcmsg_ptr = (unsigned long)msg_sys->msg_control;\n\tmsg_sys->msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);\n\n\t/* We assume all kernel code knows the size of sockaddr_storage */\n\tmsg_sys->msg_namelen = 0;\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\terr = (nosec ? sock_recvmsg_nosec : sock_recvmsg)(sock, msg_sys,\n\t\t\t\t\t\t\t  total_len, flags);\n\tif (err < 0)\n\t\tgoto out_freeiov;\n\tlen = err;\n\n\tif (uaddr != NULL) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static inline int fpregs_state_valid(struct fpu *fpu, unsigned int cpu)\n{\n\treturn fpu == this_cpu_read_stable(fpu_fpregs_owner_ctx) && cpu == fpu->last_cpu;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static inline int fpregs_state_valid(struct fpu *fpu, unsigned int cpu)\n{\n\treturn fpu == this_cpu_read(fpu_fpregs_owner_ctx) && cpu == fpu->last_cpu;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void ep_map(ep_t p, const uint8_t *msg, int len) {\n\tep_map_dst(p, msg, len, (const uint8_t *)\"RELIC\", 5);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void ep_map(ep_t p, const uint8_t *msg, size_t len) {\n\tep_map_dst(p, msg, len, (const uint8_t *)\"RELIC\", 5);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "unserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)\n{\n    int\t\ti;\n    u_entry_T\t*uep;\n    char_u\t**array;\n    char_u\t*line;\n    int\t\tline_len;\n\n    uep = (u_entry_T *)U_ALLOC_LINE(sizeof(u_entry_T));\n    if (uep == NULL)\n\treturn NULL;\n    vim_memset(uep, 0, sizeof(u_entry_T));\n#ifdef U_DEBUG\n    uep->ue_magic = UE_MAGIC;\n#endif\n    uep->ue_top = undo_read_4c(bi);\n    uep->ue_bot = undo_read_4c(bi);\n    uep->ue_lcount = undo_read_4c(bi);\n    uep->ue_size = undo_read_4c(bi);\n    if (uep->ue_size > 0)\n    {\n\tarray = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);\n\tif (array == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tvim_memset(array, 0, sizeof(char_u *) * uep->ue_size);\n    }\n    else\n\tarray = NULL;\n    uep->ue_array = array;\n\n    for (i = 0; i < uep->ue_size; ++i)\n    {\n\tline_len = undo_read_4c(bi);\n\tif (line_len >= 0)\n\t    line = read_string_decrypt(bi, line_len);\n\telse\n\t{\n\t    line = NULL;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "unserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)\n{\n    int\t\ti;\n    u_entry_T\t*uep;\n    char_u\t**array = NULL;\n    char_u\t*line;\n    int\t\tline_len;\n\n    uep = (u_entry_T *)U_ALLOC_LINE(sizeof(u_entry_T));\n    if (uep == NULL)\n\treturn NULL;\n    vim_memset(uep, 0, sizeof(u_entry_T));\n#ifdef U_DEBUG\n    uep->ue_magic = UE_MAGIC;\n#endif\n    uep->ue_top = undo_read_4c(bi);\n    uep->ue_bot = undo_read_4c(bi);\n    uep->ue_lcount = undo_read_4c(bi);\n    uep->ue_size = undo_read_4c(bi);\n    if (uep->ue_size > 0)\n    {\n\tif (uep->ue_size < LONG_MAX / (int)sizeof(char_u *))\n\t    array = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);\n\tif (array == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tvim_memset(array, 0, sizeof(char_u *) * uep->ue_size);\n    }\n    uep->ue_array = array;\n\n    for (i = 0; i < uep->ue_size; ++i)\n    {\n\tline_len = undo_read_4c(bi);\n\tif (line_len >= 0)\n\t    line = read_string_decrypt(bi, line_len);\n\telse\n\t{\n\t    line = NULL;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void bpf_map_inc(struct bpf_map *map, bool uref)\n{\n\tatomic_inc(&map->refcnt);\n\tif (uref)\n\t\tatomic_inc(&map->usercnt);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "struct bpf_map *bpf_map_inc(struct bpf_map *map, bool uref)\n{\n\tif (atomic_inc_return(&map->refcnt) > BPF_MAX_REFCNT) {\n\t\tatomic_dec(&map->refcnt);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\tif (uref)\n\t\tatomic_inc(&map->usercnt);\n\treturn map;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t{\n\t    top = curbuf->b_visual.vi_end;\n\t    bot = curbuf->b_visual.vi_start;\n\t}\n\tmode = curbuf->b_visual.vi_mode;\n\tcurswant = curbuf->b_visual.vi_curswant;\n    }\n    lnum = rex.lnum + rex.reg_firstlnum;\n    if (lnum < top.lnum || lnum > bot.lnum)\n\treturn FALSE;\n\n    if (mode == 'v')\n    {\n\tcol = (colnr_T)(rex.input - rex.line);\n\tif ((lnum == top.lnum && col < top.col)\n\t\t|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))\n\t    return FALSE;\n    }\n    else if (mode == Ctrl_V)\n    {\n\tgetvvcol(wp, &top, &start, NULL, &end);\n\tgetvvcol(wp, &bot, &start2, NULL, &end2);\n\tif (start2 < start)\n\t    start = start2;\n\tif (end2 > end)\n\t    end = end2;\n\tif (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)\n\t    end = MAXCOL;\n\tcols = win_linetabsize(wp, rex.line, (colnr_T)(rex.input - rex.line));\n\tif (cols < start || cols > end - (*p_sel == 'e'))\n\t    return FALSE;\n    }\n    return TRUE;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t    top = curbuf->b_visual.vi_end;\n\t    bot = curbuf->b_visual.vi_start;\n\t}\n\tmode = curbuf->b_visual.vi_mode;\n\tcurswant = curbuf->b_visual.vi_curswant;\n    }\n    lnum = rex.lnum + rex.reg_firstlnum;\n    if (lnum < top.lnum || lnum > bot.lnum)\n\treturn FALSE;\n\n    col = (colnr_T)(rex.input - rex.line);\n    if (mode == 'v')\n    {\n\tif ((lnum == top.lnum && col < top.col)\n\t\t|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))\n\t    return FALSE;\n    }\n    else if (mode == Ctrl_V)\n    {\n\tgetvvcol(wp, &top, &start, NULL, &end);\n\tgetvvcol(wp, &bot, &start2, NULL, &end2);\n\tif (start2 < start)\n\t    start = start2;\n\tif (end2 > end)\n\t    end = end2;\n\tif (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)\n\t    end = MAXCOL;\n\n\t// getvvcol() flushes rex.line, need to get it again\n\trex.line = reg_getline(rex.lnum);\n\trex.input = rex.line + col;\n\n\tcols = win_linetabsize(wp, rex.line, col);\n\tif (cols < start || cols > end - (*p_sel == 'e'))\n\t    return FALSE;\n    }\n    return TRUE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t * It is safe to convert extent to initialized via explicit\n\t * zeroout only if extent is fully insde i_size or new_size.\n\t */\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\n\tsplit_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;\n\tsplit_flag |= EXT4_EXT_MARK_UNINIT2;\n\n\tflags |= EXT4_GET_BLOCKS_PRE_IO;\n\treturn ext4_split_extent(handle, inode, path, map, split_flag, flags);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t * It is safe to convert extent to initialized via explicit\n\t * zeroout only if extent is fully insde i_size or new_size.\n\t */\n\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\n\tsplit_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;\n\tsplit_flag |= EXT4_EXT_MARK_UNINIT2;\n\tif (flags & EXT4_GET_BLOCKS_CONVERT)\n\t\tsplit_flag |= EXT4_EXT_DATA_VALID2;\n\tflags |= EXT4_GET_BLOCKS_PRE_IO;\n\treturn ext4_split_extent(handle, inode, path, map, split_flag, flags);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tlocal_irq_enable();\n\t\terror_code |= PF_USER;\n\t} else {\n\t\tif (regs->flags & X86_EFLAGS_IF)\n\t\t\tlocal_irq_enable();\n\t}\n\n\tif (unlikely(error_code & PF_RSVD))\n\t\tpgtable_bad(regs, error_code, address);\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n\n\t/*\n\t * If we're in an interrupt, have no user context or are running\n\t * in an atomic region then we must not take the fault:\n\t */\n\tif (unlikely(in_atomic() || !mm)) {\n\t\tbad_area_nosemaphore(regs, error_code, address);\n\t\treturn;\n\t}\n\n\t}\n\n\t/*\n\t * Major/minor page fault accounting is only done on the\n\t * initial attempt. If we go through a retry, it is extremely\n\t * likely that the page will be found in page cache at that point.\n\t */\n\tif (flags & FAULT_FLAG_ALLOW_RETRY) {\n\t\tif (fault & VM_FAULT_MAJOR) {\n\t\t\ttsk->maj_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n\t\t\t\t      regs, address);\n\t\t} else {\n\t\t\ttsk->min_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n\t\t\t\t      regs, address);\n\t\t}\n\t\tif (fault & VM_FAULT_RETRY) {\n\t\t\t/* Clear FAULT_FLAG_ALLOW_RETRY to avoid any risk\n\t\t\t * of starvation. */\n\t\t\tflags &= ~FAULT_FLAG_ALLOW_RETRY;\n\t\t\tgoto retry;\n\t\t}\n\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tlocal_irq_enable();\n\t\terror_code |= PF_USER;\n\t} else {\n\t\tif (regs->flags & X86_EFLAGS_IF)\n\t\t\tlocal_irq_enable();\n\t}\n\n\tif (unlikely(error_code & PF_RSVD))\n\t\tpgtable_bad(regs, error_code, address);\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n\n\t/*\n\t * If we're in an interrupt, have no user context or are running\n\t * in an atomic region then we must not take the fault:\n\t */\n\tif (unlikely(in_atomic() || !mm)) {\n\t\tbad_area_nosemaphore(regs, error_code, address);\n\t\treturn;\n\t}\n\n\t}\n\n\t/*\n\t * Major/minor page fault accounting is only done on the\n\t * initial attempt. If we go through a retry, it is extremely\n\t * likely that the page will be found in page cache at that point.\n\t */\n\tif (flags & FAULT_FLAG_ALLOW_RETRY) {\n\t\tif (fault & VM_FAULT_MAJOR) {\n\t\t\ttsk->maj_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,\n\t\t\t\t      regs, address);\n\t\t} else {\n\t\t\ttsk->min_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,\n\t\t\t\t      regs, address);\n\t\t}\n\t\tif (fault & VM_FAULT_RETRY) {\n\t\t\t/* Clear FAULT_FLAG_ALLOW_RETRY to avoid any risk\n\t\t\t * of starvation. */\n\t\t\tflags &= ~FAULT_FLAG_ALLOW_RETRY;\n\t\t\tgoto retry;\n\t\t}\n\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void enc28j60EventHandler(NetInterface *interface)\n{\n   error_t error;\n   uint16_t status;\n   uint16_t value;\n\n   //Read interrupt status register\n   status = enc28j60ReadReg(interface, ENC28J60_REG_EIR);\n\n   //Check whether the link state has changed\n   if((status & EIR_LINKIF) != 0)\n   {\n      //Clear PHY interrupts flags\n      enc28j60ReadPhyReg(interface, ENC28J60_PHY_REG_PHIR);\n      //Clear interrupt flag\n      enc28j60ClearBit(interface, ENC28J60_REG_EIR, EIR_LINKIF);\n      //Read PHY status register\n      value = enc28j60ReadPhyReg(interface, ENC28J60_PHY_REG_PHSTAT2);\n\n      //Check link state\n      if((value & PHSTAT2_LSTAT) != 0)\n      {\n         //Link speed\n         interface->linkSpeed = NIC_LINK_SPEED_10MBPS;\n\n#if (ENC28J60_FULL_DUPLEX_SUPPORT == ENABLED)\n         //Full-duplex mode\n         interface->duplexMode = NIC_FULL_DUPLEX_MODE;\n#else\n         //Half-duplex mode\n         interface->duplexMode = NIC_HALF_DUPLEX_MODE;\n      {\n         //Link is down\n         interface->linkState = FALSE;\n      }\n\n      //Process link state change event\n      nicNotifyLinkChange(interface);\n   }\n\n   //Check whether a packet has been received?\n   if((status & EIR_PKTIF) != 0)\n   {\n      //Clear interrupt flag\n      enc28j60ClearBit(interface, ENC28J60_REG_EIR, EIR_PKTIF);\n\n      //Process all pending packets\n      do\n      {\n         //Read incoming packet\n         error = enc28j60ReceivePacket(interface);\n\n         //No more data in the receive buffer?\n      } while(error != ERROR_BUFFER_EMPTY);\n   }\n\n   //Re-enable LINKIE and PKTIE interrupts\n   enc28j60SetBit(interface, ENC28J60_REG_EIE, EIE_LINKIE | EIE_PKTIE);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void enc28j60EventHandler(NetInterface *interface)\n{\n   error_t error;\n   uint16_t status;\n   uint16_t value;\n\n   //Read interrupt status register\n   status = enc28j60ReadReg(interface, ENC28J60_EIR);\n\n   //Check whether the link state has changed\n   if((status & ENC28J60_EIR_LINKIF) != 0)\n   {\n      //Clear PHY interrupts flags\n      enc28j60ReadPhyReg(interface, ENC28J60_PHIR);\n      //Clear interrupt flag\n      enc28j60ClearBit(interface, ENC28J60_EIR, ENC28J60_EIR_LINKIF);\n      //Read PHY status register\n      value = enc28j60ReadPhyReg(interface, ENC28J60_PHSTAT2);\n\n      //Check link state\n      if((value & ENC28J60_PHSTAT2_LSTAT) != 0)\n      {\n         //Link speed\n         interface->linkSpeed = NIC_LINK_SPEED_10MBPS;\n\n#if (ENC28J60_FULL_DUPLEX_SUPPORT == ENABLED)\n         //Full-duplex mode\n         interface->duplexMode = NIC_FULL_DUPLEX_MODE;\n#else\n         //Half-duplex mode\n         interface->duplexMode = NIC_HALF_DUPLEX_MODE;\n      {\n         //Link is down\n         interface->linkState = FALSE;\n      }\n\n      //Process link state change event\n      nicNotifyLinkChange(interface);\n   }\n\n   //Check whether a packet has been received?\n   if(enc28j60ReadReg(interface, ENC28J60_EPKTCNT) != 0)\n   {\n      //Clear interrupt flag\n      enc28j60ClearBit(interface, ENC28J60_EIR, ENC28J60_EIR_PKTIF);\n\n      //Process all pending packets\n      do\n      {\n         //Read incoming packet\n         error = enc28j60ReceivePacket(interface);\n\n         //No more data in the receive buffer?\n      } while(error != ERROR_BUFFER_EMPTY);\n   }\n\n   //Re-enable LINKIE and PKTIE interrupts\n   enc28j60SetBit(interface, ENC28J60_EIE, ENC28J60_EIE_LINKIE |\n      ENC28J60_EIE_PKTIE);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "   MPC.PB5PFS.BYTE = 0x12;\n\n   //Configure RMII_TXD1 (PB6)\n   PORTB.PMR.BIT.B6 = 1;\n   MPC.PB6PFS.BYTE = 0x12;\n\n   //Configure RMII_CRS_DV (PB7)\n   PORTB.PMR.BIT.B7 = 1;\n   MPC.PB7PFS.BYTE = 0x12;\n\n#elif defined(USE_RSK_RX63N)\n   //Select MII interface mode\n   MPC.PFENET.BIT.PHYMODE = 1;\n\n   //Configure ET_MDIO (P71)\n   PORT7.PMR.BIT.B1 = 1;\n   MPC.P71PFS.BYTE = 0x11;\n\n   //Configure ET_MDC (P72)\n   PORT7.PMR.BIT.B2 = 1;\n   MPC.P72PFS.BYTE = 0x11;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "   MPC.PB5PFS.BYTE = 0x12;\n\n   //Configure RMII_TXD1 (PB6)\n   PORTB.PMR.BIT.B6 = 1;\n   MPC.PB6PFS.BYTE = 0x12;\n\n   //Configure RMII_CRS_DV (PB7)\n   PORTB.PMR.BIT.B7 = 1;\n   MPC.PB7PFS.BYTE = 0x12;\n\n#elif defined(USE_RSK_RX63N) || defined(USE_RSK_RX63N_256K)\n   //Select MII interface mode\n   MPC.PFENET.BIT.PHYMODE = 1;\n\n   //Configure ET_MDIO (P71)\n   PORT7.PMR.BIT.B1 = 1;\n   MPC.P71PFS.BYTE = 0x11;\n\n   //Configure ET_MDC (P72)\n   PORT7.PMR.BIT.B2 = 1;\n   MPC.P72PFS.BYTE = 0x11;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "exif_data_load_data_content (ExifData *data, ExifIfd ifd,\n\t\t\t     const unsigned char *d,\n\t\t\t     unsigned int ds, unsigned int offset, unsigned int recursion_depth)\n{\n\tExifLong o, thumbnail_offset = 0, thumbnail_length = 0;\n\tExifShort n;\n\tExifEntry *entry;\n\tunsigned int i;\n\tExifTag tag;\n\n\tif (!data || !data->priv) \n\t\treturn;\n\n\t/* check for valid ExifIfd enum range */\n\tif ((((int)ifd) < 0) || ( ((int)ifd) >= EXIF_IFD_COUNT))\n\t  return;\n\n\tif (recursion_depth > 12) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\",\n\t\t\t  \"Deep recursion detected!\");\n\t\treturn;\n\t}\n\n\t/* Read the number of entries */\n\tif ((offset + 2 < offset) || (offset + 2 < 2) || (offset + 2 > ds)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\",\n\t\t\t  \"Tag data past end of buffer (%u > %u)\", offset+2, ds);\n\t\treturn;\n\t}\n\tn = exif_get_short (d + offset, data->priv->order);\n\t\t\t\t\t   data->priv->order);\n\t\t\t/* FIXME: IFD_POINTER tags aren't marked as being in a\n\t\t\t * specific IFD, so exif_tag_get_name_in_ifd won't work\n\t\t\t */\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Sub-IFD entry 0x%x ('%s') at %u.\", tag,\n\t\t\t\t  exif_tag_get_name(tag), o);\n\t\t\tswitch (tag) {\n\t\t\tcase EXIF_TAG_EXIF_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_EXIF);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_EXIF, d, ds, o, recursion_depth + 1);\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_GPS_INFO_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_GPS);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_GPS, d, ds, o, recursion_depth + 1);\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_INTEROPERABILITY_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_INTEROPERABILITY);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_INTEROPERABILITY, d, ds, o, recursion_depth + 1);\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\t\tthumbnail_offset = o;\n\t\t\t\tif (thumbnail_offset && thumbnail_length)\n\t\t\t\t\texif_data_load_data_thumbnail (data, d,\n\t\t\t\t\t\t\t\t       ds, thumbnail_offset,\n\t\t\t\t\t\t\t\t       thumbnail_length);\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:\n\t\t\t\tthumbnail_length = o;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "exif_data_load_data_content (ExifData *data, ExifIfd ifd,\n\t\t\t     const unsigned char *d,\n\t\t\t     unsigned int ds, unsigned int offset, unsigned int recursion_cost)\n{\n\tExifLong o, thumbnail_offset = 0, thumbnail_length = 0;\n\tExifShort n;\n\tExifEntry *entry;\n\tunsigned int i;\n\tExifTag tag;\n\n\tif (!data || !data->priv) \n\t\treturn;\n\n\t/* check for valid ExifIfd enum range */\n\tif ((((int)ifd) < 0) || ( ((int)ifd) >= EXIF_IFD_COUNT))\n\t  return;\n\n\tif (recursion_cost > 170) {\n\t\t/*\n\t\t * recursion_cost is a logarithmic-scale indicator of how expensive this\n\t\t * recursive call might end up being. It is an indicator of the depth of\n\t\t * recursion as well as the potential for worst-case future recursive\n\t\t * calls. Since it's difficult to tell ahead of time how often recursion\n\t\t * will occur, this assumes the worst by assuming every tag could end up\n\t\t * causing recursion.\n\t\t * The value of 170 was chosen to limit typical EXIF structures to a\n\t\t * recursive depth of about 6, but pathological ones (those with very\n\t\t * many tags) to only 2.\n\t\t */\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\",\n\t\t\t  \"Deep/expensive recursion detected!\");\n\t\treturn;\n\t}\n\n\t/* Read the number of entries */\n\tif ((offset + 2 < offset) || (offset + 2 < 2) || (offset + 2 > ds)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\",\n\t\t\t  \"Tag data past end of buffer (%u > %u)\", offset+2, ds);\n\t\treturn;\n\t}\n\tn = exif_get_short (d + offset, data->priv->order);\n\t\t\t\t\t   data->priv->order);\n\t\t\t/* FIXME: IFD_POINTER tags aren't marked as being in a\n\t\t\t * specific IFD, so exif_tag_get_name_in_ifd won't work\n\t\t\t */\n\t\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Sub-IFD entry 0x%x ('%s') at %u.\", tag,\n\t\t\t\t  exif_tag_get_name(tag), o);\n\t\t\tswitch (tag) {\n\t\t\tcase EXIF_TAG_EXIF_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_EXIF);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_EXIF, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_GPS_INFO_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_GPS);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_GPS, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_INTEROPERABILITY_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_INTEROPERABILITY);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_INTEROPERABILITY, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\t\tthumbnail_offset = o;\n\t\t\t\tif (thumbnail_offset && thumbnail_length)\n\t\t\t\t\texif_data_load_data_thumbnail (data, d,\n\t\t\t\t\t\t\t\t       ds, thumbnail_offset,\n\t\t\t\t\t\t\t\t       thumbnail_length);\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT_LENGTH:\n\t\t\t\tthumbnail_length = o;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t/* Do software UFO. Complete and fill in the UDP checksum as HW cannot\n\t * do checksum of UDP packets sent as multiple IP fragments.\n\t */\n\toffset = skb->csum_start - skb_headroom(skb);\n\tcsum = skb_checksum(skb, offset, skb->len- offset, 0);\n\toffset += skb->csum_offset;\n\t*(__sum16 *)(skb->data + offset) = csum_fold(csum);\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\t/* Check if there is enough headroom to insert fragment header. */\n\tif ((skb_headroom(skb) < frag_hdr_sz) &&\n\t    pskb_expand_head(skb, frag_hdr_sz, 0, GFP_ATOMIC))\n\t\tgoto out;\n\n\t/* Find the unfragmentable header and shift it left by frag_hdr_sz\n\t * bytes to insert fragment header.\n\t */\n\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\tnexthdr = *prevhdr;\n\t*prevhdr = NEXTHDR_FRAGMENT;\n\tunfrag_len = skb_network_header(skb) - skb_mac_header(skb) +",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t/* Do software UFO. Complete and fill in the UDP checksum as HW cannot\n\t * do checksum of UDP packets sent as multiple IP fragments.\n\t */\n\toffset = skb->csum_start - skb_headroom(skb);\n\tcsum = skb_checksum(skb, offset, skb->len- offset, 0);\n\toffset += skb->csum_offset;\n\t*(__sum16 *)(skb->data + offset) = csum_fold(csum);\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\t/* Check if there is enough headroom to insert fragment header. */\n\tif ((skb_mac_header(skb) < skb->head + frag_hdr_sz) &&\n\t    pskb_expand_head(skb, frag_hdr_sz, 0, GFP_ATOMIC))\n\t\tgoto out;\n\n\t/* Find the unfragmentable header and shift it left by frag_hdr_sz\n\t * bytes to insert fragment header.\n\t */\n\tunfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr);\n\tnexthdr = *prevhdr;\n\t*prevhdr = NEXTHDR_FRAGMENT;\n\tunfrag_len = skb_network_header(skb) - skb_mac_header(skb) +",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "GF_Err gf_isom_set_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const GF_SLConfig *slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig **slc;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\t//we must be sure we are not using a remote ESD\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (((GF_MPEGSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (((GF_MPEGAudioSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (((GF_MPEGVisualSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (*slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)*slc);\n\t\t*slc = NULL;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "GF_Err gf_isom_set_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const GF_SLConfig *slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig **slc;\n\tGF_ESDBox *esds;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\t//we must be sure we are not using a remote ESD\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tesds = ((GF_MPEGSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tesds = ((GF_MPEGAudioSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tesds = ((GF_MPEGVisualSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\tif (*slc) {\n\t\tgf_odf_desc_del((GF_Descriptor *)*slc);\n\t\t*slc = NULL;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int udp_push_pending_frames(struct sock *sk)\n{\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi4 *fl4 = &inet->cork.fl.u.ip4;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\n\tskb = ip_finish_skb(sk, fl4);\n\tif (!skb)\n\t\tgoto out;\n\n\terr = udp_send_skb(skb, fl4);\n\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int udp_push_pending_frames(struct sock *sk)\n{\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi4 *fl4 = &inet->cork.fl.u.ip4;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\n\tskb = ip_finish_skb(sk, fl4);\n\tif (!skb)\n\t\tgoto out;\n\n\terr = udp_send_skb(skb, fl4);\n\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n            while (wcount--) {\n                csum = (csum * 3) + csptr [0] + (csptr [1] << 8);\n                csptr += 2;\n            }\n\n            WavpackLittleEndianToNative ((WavpackHeader *) buffer, WavpackHeaderFormat);\n#endif\n\n            if (meta_bc == 4) {\n                if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff) || *dp++ != ((csum >> 16) & 0xff) || *dp++ != ((csum >> 24) & 0xff))\n                    return FALSE;\n            }\n            else {\n                csum ^= csum >> 16;\n\n                if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff))\n                    return FALSE;\n            }\n\n            checksum_passed++;\n        }\n\n        bcount -= meta_bc;\n        dp += meta_bc;\n    }\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n            while (wcount--) {\n                csum = (csum * 3) + csptr [0] + (csptr [1] << 8);\n                csptr += 2;\n            }\n\n            WavpackLittleEndianToNative ((WavpackHeader *) buffer, WavpackHeaderFormat);\n#endif\n\n            if (meta_bc == 4) {\n                if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff) || dp[2] != ((csum >> 16) & 0xff) || dp[3] != ((csum >> 24) & 0xff))\n                    return FALSE;\n            }\n            else {\n                csum ^= csum >> 16;\n\n                if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff))\n                    return FALSE;\n            }\n\n            checksum_passed++;\n        }\n\n        bcount -= meta_bc;\n        dp += meta_bc;\n    }\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    {\n\tint\tc1;\n\tint\tc2;\n\n\tc1 = PTR2CHAR(fuzpat);\n\tc2 = PTR2CHAR(str);\n\n\t// Found match\n\tif (vim_tolower(c1) == vim_tolower(c2))\n\t{\n\t    int_u\trecursiveMatches[MAX_FUZZY_MATCHES];\n\t    int\t\trecursiveScore = 0;\n\t    char_u\t*next_char;\n\n\t    // Supplied matches buffer was too short\n\t    if (nextMatch >= maxMatches)\n\t\treturn 0;\n\n\t    // \"Copy-on-Write\" srcMatches into matches\n\t    if (first_match && srcMatches)\n\t    {\n\t\tmemcpy(matches, srcMatches, nextMatch * sizeof(srcMatches[0]));\n\t\tfirst_match = FALSE;\n\t    }\n\n\t    // Recursive call that \"skips\" this match\n\t    if (has_mbyte)\n\t\tnext_char = str + (*mb_ptr2len)(str);\n\t    else\n\t\tnext_char = str + 1;\n\t    if (fuzzy_match_recursive(fuzpat, next_char, strIdx + 1,\n\t\t\t&recursiveScore, strBegin, strLen, matches,\n\t\t\trecursiveMatches,\n\t\t\tARRAY_LENGTH(recursiveMatches),\n\t\t\tnextMatch, recursionCount))\n\t    {\n\t\t// Pick best recursive score\n\t\tif (!recursiveMatch || recursiveScore > bestRecursiveScore)\n\t\t{\n\t\t    memcpy(bestRecursiveMatches, recursiveMatches,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    while (*fuzpat != NUL && *str != NUL)\n    {\n\tint\tc1;\n\tint\tc2;\n\n\tc1 = PTR2CHAR(fuzpat);\n\tc2 = PTR2CHAR(str);\n\n\t// Found match\n\tif (vim_tolower(c1) == vim_tolower(c2))\n\t{\n\t    // Supplied matches buffer was too short\n\t    if (nextMatch >= maxMatches)\n\t\treturn 0;\n\n\t    int\t\trecursiveScore = 0;\n\t    int_u\trecursiveMatches[MAX_FUZZY_MATCHES];\n\t    CLEAR_FIELD(recursiveMatches);\n\n\t    // \"Copy-on-Write\" srcMatches into matches\n\t    if (first_match && srcMatches)\n\t    {\n\t\tmemcpy(matches, srcMatches, nextMatch * sizeof(srcMatches[0]));\n\t\tfirst_match = FALSE;\n\t    }\n\n\t    // Recursive call that \"skips\" this match\n\t    char_u *next_char = str + (has_mbyte ? (*mb_ptr2len)(str) : 1);\n\t    if (fuzzy_match_recursive(fuzpat, next_char, strIdx + 1,\n\t\t\t&recursiveScore, strBegin, strLen, matches,\n\t\t\trecursiveMatches,\n\t\t\tARRAY_LENGTH(recursiveMatches),\n\t\t\tnextMatch, recursionCount))\n\t    {\n\t\t// Pick best recursive score\n\t\tif (!recursiveMatch || recursiveScore > bestRecursiveScore)\n\t\t{\n\t\t    memcpy(bestRecursiveMatches, recursiveMatches,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    }\n    if (ic == 20)\n        return 0;\n\n    fi->seek(adam_offset, SEEK_SET);\n    fi->readx(&ih, sizeof(ih));\n    // FIXME: should add more checks for the values in 'ih'\n    unsigned const imagesize = ih.imagesize;\n    unsigned const entry = ih.entry;\n    unsigned const relocsize = ih.relocsize;\n    if (!imagesize || file_size <= imagesize || file_size <= entry || file_size <= relocsize) {\n        printWarn(getName(), \"bad header; imagesize=%#x  entry=%#x  relocsize=%#x\", imagesize,\n                  entry, relocsize);\n        return 0;\n    }\n\n    return UPX_F_TMT_ADAM;\n#undef H4\n#undef H\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    }\n    if (ic == 20)\n        return 0;\n\n    fi->seek(adam_offset, SEEK_SET);\n    fi->readx(&ih, sizeof(ih));\n    // FIXME: should add more checks for the values in 'ih'\n    unsigned const imagesize = ih.imagesize;\n    unsigned const entry = ih.entry;\n    unsigned const relocsize = ih.relocsize;\n    if (imagesize < sizeof(ih) || entry < sizeof(ih) || file_size <= imagesize ||\n        file_size <= entry || file_size <= relocsize) {\n        printWarn(getName(), \"bad header; imagesize=%#x  entry=%#x  relocsize=%#x\", imagesize,\n                  entry, relocsize);\n        return 0;\n    }\n\n    return UPX_F_TMT_ADAM;\n#undef H4\n#undef H\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tchar path[MAXPATHLEN];\n\tint ret;\n\n\t/* relative to root mount point */\n\tret = snprintf(path, sizeof(path), \"%s/%s\", rootfs, mntent->mnt_dir);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tchar path[MAXPATHLEN];\n\tint ret;\n\n\t/* relative to root mount point */\n\tret = snprintf(path, sizeof(path), \"%s/%s\", rootfs, mntent->mnt_dir);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, rootfs);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "eth_addr_resolve(hashether_t *tp) {\n    ether_t      *eth;\n    hashmanuf_t *manuf_value;\n    const guint8 *addr = tp->addr;\n\n    if ( (eth = get_ethbyaddr(addr)) != NULL) {\n        (void) g_strlcpy(tp->resolved_name, eth->name, MAXNAMELEN);\n        tp->status = HASHETHER_STATUS_RESOLVED_NAME;\n        return tp;\n    } else {\n        guint         mask;\n        gchar        *name;\n        address       ether_addr;\n\n            /* Only the topmost 3 bytes participate fully */\n            if ((name = wka_name_lookup(addr, mask+24)) != NULL) {\n                snprintf(tp->resolved_name, MAXNAMELEN, \"%s_%02x:%02x:%02x\",\n                        name, addr[3] & (0xFF >> mask), addr[4], addr[5]);\n                tp->status = HASHETHER_STATUS_RESOLVED_DUMMY;\n                return tp;\n            }\n        } while (mask--);\n\n        /* Now try looking in the manufacturer table. */\n        manuf_value = manuf_name_lookup(addr);\n        if ((manuf_value != NULL) && (manuf_value->status != HASHETHER_STATUS_UNRESOLVED)) {\n            snprintf(tp->resolved_name, MAXNAMELEN, \"%s_%02x:%02x:%02x\",\n                    manuf_value->resolved_name, addr[3], addr[4], addr[5]);\n            tp->status = HASHETHER_STATUS_RESOLVED_DUMMY;\n            return tp;\n        }\n\n        /* Now try looking for it in the well-known-address\n           tables for well-known address ranges larger than 2^24. */\n        mask = 7;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "eth_addr_resolve(hashether_t *tp) {\n    ether_t      *eth;\n    hashmanuf_t *manuf_value;\n    const guint8 *addr = tp->addr;\n    size_t addr_size = sizeof(tp->addr);\n\n    if ( (eth = get_ethbyaddr(addr)) != NULL) {\n        (void) g_strlcpy(tp->resolved_name, eth->name, MAXNAMELEN);\n        tp->status = HASHETHER_STATUS_RESOLVED_NAME;\n        return tp;\n    } else {\n        guint         mask;\n        gchar        *name;\n        address       ether_addr;\n\n            /* Only the topmost 3 bytes participate fully */\n            if ((name = wka_name_lookup(addr, mask+24)) != NULL) {\n                snprintf(tp->resolved_name, MAXNAMELEN, \"%s_%02x:%02x:%02x\",\n                        name, addr[3] & (0xFF >> mask), addr[4], addr[5]);\n                tp->status = HASHETHER_STATUS_RESOLVED_DUMMY;\n                return tp;\n            }\n        } while (mask--);\n\n        /* Now try looking in the manufacturer table. */\n        manuf_value = manuf_name_lookup(addr, addr_size);\n        if ((manuf_value != NULL) && (manuf_value->status != HASHETHER_STATUS_UNRESOLVED)) {\n            snprintf(tp->resolved_name, MAXNAMELEN, \"%s_%02x:%02x:%02x\",\n                    manuf_value->resolved_name, addr[3], addr[4], addr[5]);\n            tp->status = HASHETHER_STATUS_RESOLVED_DUMMY;\n            return tp;\n        }\n\n        /* Now try looking for it in the well-known-address\n           tables for well-known address ranges larger than 2^24. */\n        mask = 7;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "{\n    char_u\t*start = *arg;\n    int\t\tlen;\n    int\t\tret;\n    char_u\t*name;\n\n    ++*arg;\n    len = get_env_len(arg);\n    if (len == 0)\n    {\n\tsemsg(_(e_syntax_error_at_str), start - 1);\n\treturn FAIL;\n    }\n\n    // include the '$' in the name, eval_env_var() expects it.\n    name = vim_strnsave(start, len + 1);\n    ret = generate_LOAD(cctx, ISN_LOADENV, 0, name, &t_string);\n    vim_free(name);\n    return ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "{\n    char_u\t*start = *arg;\n    int\t\tlen;\n    int\t\tret;\n    char_u\t*name;\n\n    ++*arg;\n    len = get_env_len(arg);\n    if (len == 0)\n    {\n\tsemsg(_(e_syntax_error_at_str), start);\n\treturn FAIL;\n    }\n\n    // include the '$' in the name, eval_env_var() expects it.\n    name = vim_strnsave(start, len + 1);\n    ret = generate_LOAD(cctx, ISN_LOADENV, 0, name, &t_string);\n    vim_free(name);\n    return ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "                (reslevel->coord[0][0] >> reslevel->log2_prec_width);\n\n        if (reslevel->coord[1][1] == reslevel->coord[1][0])\n            reslevel->num_precincts_y = 0;\n        else\n            reslevel->num_precincts_y =\n                ff_jpeg2000_ceildivpow2(reslevel->coord[1][1],\n                                        reslevel->log2_prec_height) -\n                (reslevel->coord[1][0] >> reslevel->log2_prec_height);\n\n        reslevel->band = av_malloc_array(reslevel->nbands, sizeof(*reslevel->band));\n        if (!reslevel->band)\n            return AVERROR(ENOMEM);\n\n        for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) {\n            Jpeg2000Band *band = reslevel->band + bandno;\n            int cblkno, precno;\n            int nb_precincts;\n\n            /* TODO: Implementation of quantization step not finished,\n             * see ISO/IEC 15444-1:2002 E.1 and A.6.4. */\n\n                log2_band_prec_width  = reslevel->log2_prec_width  - 1;\n                log2_band_prec_height = reslevel->log2_prec_height - 1;\n            }\n\n            for (j = 0; j < 2; j++)\n                band->coord[0][j] = ff_jpeg2000_ceildiv(band->coord[0][j], dx);\n            for (j = 0; j < 2; j++)\n                band->coord[1][j] = ff_jpeg2000_ceildiv(band->coord[1][j], dy);\n\n            band->prec = av_malloc_array(reslevel->num_precincts_x *\n                                         (uint64_t)reslevel->num_precincts_y,\n                                         sizeof(*band->prec));\n            if (!band->prec)\n                return AVERROR(ENOMEM);\n\n            nb_precincts = reslevel->num_precincts_x * reslevel->num_precincts_y;\n\n            for (precno = 0; precno < nb_precincts; precno++) {\n                Jpeg2000Prec *prec = band->prec + precno;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "                (reslevel->coord[0][0] >> reslevel->log2_prec_width);\n\n        if (reslevel->coord[1][1] == reslevel->coord[1][0])\n            reslevel->num_precincts_y = 0;\n        else\n            reslevel->num_precincts_y =\n                ff_jpeg2000_ceildivpow2(reslevel->coord[1][1],\n                                        reslevel->log2_prec_height) -\n                (reslevel->coord[1][0] >> reslevel->log2_prec_height);\n\n        reslevel->band = av_calloc(reslevel->nbands, sizeof(*reslevel->band));\n        if (!reslevel->band)\n            return AVERROR(ENOMEM);\n\n        for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) {\n            Jpeg2000Band *band = reslevel->band + bandno;\n            int cblkno, precno;\n            int nb_precincts;\n\n            /* TODO: Implementation of quantization step not finished,\n             * see ISO/IEC 15444-1:2002 E.1 and A.6.4. */\n\n                log2_band_prec_width  = reslevel->log2_prec_width  - 1;\n                log2_band_prec_height = reslevel->log2_prec_height - 1;\n            }\n\n            for (j = 0; j < 2; j++)\n                band->coord[0][j] = ff_jpeg2000_ceildiv(band->coord[0][j], dx);\n            for (j = 0; j < 2; j++)\n                band->coord[1][j] = ff_jpeg2000_ceildiv(band->coord[1][j], dy);\n\n            band->prec = av_calloc(reslevel->num_precincts_x *\n                                         (uint64_t)reslevel->num_precincts_y,\n                                         sizeof(*band->prec));\n            if (!band->prec)\n                return AVERROR(ENOMEM);\n\n            nb_precincts = reslevel->num_precincts_x * reslevel->num_precincts_y;\n\n            for (precno = 0; precno < nb_precincts; precno++) {\n                Jpeg2000Prec *prec = band->prec + precno;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n{\n\tonig_free(*pre);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void php_mb_regex_free_cache(php_mb_regex_t **pre)\n{\n\tonig_free(*pre);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void eb_read_bin(eb_t a, const uint8_t *bin, int len) {\n\tif (len == 1) {\n\t\tif (bin[0] == 0) {\n\t\t\teb_set_infty(a);\n\t\t\treturn;\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t}\n\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void eb_read_bin(eb_t a, const uint8_t *bin, size_t len) {\n\tif (len == 1) {\n\t\tif (bin[0] == 0) {\n\t\t\teb_set_infty(a);\n\t\t\treturn;\n\t\t} else {\n\t\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\t\treturn;\n\t\t}\n\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void jas_matrix_divpow2(jas_matrix_t *matrix, int n)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t*data = (*data >= 0) ? ((*data) >> n) :",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void jas_matrix_divpow2(jas_matrix_t *matrix, int n)\n{\n\tjas_matind_t i;\n\tjas_matind_t j;\n\tjas_seqent_t *rowstart;\n\tjas_matind_t rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);\n\t\tfor (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,\n\t\t  rowstart += rowstep) {\n\t\t\tfor (j = matrix->numcols_, data = rowstart; j > 0; --j,\n\t\t\t  ++data) {\n\t\t\t\t*data = (*data >= 0) ? ((*data) >> n) :",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n\tif (err)\n\t\tgoto errout_free;\n\n\tif (rtm->rtm_flags & RTM_F_NOTIFY)\n\t\trt->rt_flags |= RTCF_NOTIFY;\n\n\tif (rtm->rtm_flags & RTM_F_LOOKUP_TABLE)\n\t\ttable_id = rt->rt_table_id;\n\n\tif (rtm->rtm_flags & RTM_F_FIB_MATCH)\n\t\terr = fib_dump_info(skb, NETLINK_CB(in_skb).portid,\n\t\t\t\t    nlh->nlmsg_seq, RTM_NEWROUTE, table_id,\n\t\t\t\t    rt->rt_type, res.prefix, res.prefixlen,\n\t\t\t\t    fl4.flowi4_tos, res.fi, 0);\n\telse\n\t\terr = rt_fill_info(net, dst, src, table_id, &fl4, skb,\n\t\t\t\t   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq);\n\tif (err < 0)\n\t\tgoto errout_free;\n\n\trcu_read_unlock();\n\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\treturn err;\n\nerrout_free:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n\tif (err)\n\t\tgoto errout_free;\n\n\tif (rtm->rtm_flags & RTM_F_NOTIFY)\n\t\trt->rt_flags |= RTCF_NOTIFY;\n\n\tif (rtm->rtm_flags & RTM_F_LOOKUP_TABLE)\n\t\ttable_id = rt->rt_table_id;\n\n\tif (rtm->rtm_flags & RTM_F_FIB_MATCH) {\n\t\tif (!res.fi) {\n\t\t\terr = fib_props[res.type].error;\n\t\t\tif (!err)\n\t\t\t\terr = -EHOSTUNREACH;\n\t\t\tgoto errout_free;\n\t\t}\n\t\terr = fib_dump_info(skb, NETLINK_CB(in_skb).portid,\n\t\t\t\t    nlh->nlmsg_seq, RTM_NEWROUTE, table_id,\n\t\t\t\t    rt->rt_type, res.prefix, res.prefixlen,\n\t\t\t\t    fl4.flowi4_tos, res.fi, 0);\n\t} else {\n\t\terr = rt_fill_info(net, dst, src, table_id, &fl4, skb,\n\t\t\t\t   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq);\n\t}\n\tif (err < 0)\n\t\tgoto errout_free;\n\n\trcu_read_unlock();\n\n\terr = rtnl_unicast(skb, net, NETLINK_CB(in_skb).portid);\nerrout:\n\treturn err;\n\nerrout_free:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tchar *driver_override, *old = pdev->driver_override, *cp;\n\n\tif (count > PATH_MAX)\n\t\treturn -EINVAL;\n\n\tdriver_override = kstrndup(buf, count, GFP_KERNEL);\n\tif (!driver_override)\n\t\treturn -ENOMEM;\n\n\tcp = strchr(driver_override, '\\n');\n\tif (cp)\n\t\t*cp = '\\0';\n\n\tif (strlen(driver_override)) {\n\t\tpdev->driver_override = driver_override;\n\t} else {\n\t\tkfree(driver_override);\n\t\tpdev->driver_override = NULL;\n\t}\n\n\tkfree(old);\n\n\treturn count;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tchar *driver_override, *old, *cp;\n\n\tif (count > PATH_MAX)\n\t\treturn -EINVAL;\n\n\tdriver_override = kstrndup(buf, count, GFP_KERNEL);\n\tif (!driver_override)\n\t\treturn -ENOMEM;\n\n\tcp = strchr(driver_override, '\\n');\n\tif (cp)\n\t\t*cp = '\\0';\n\n\tdevice_lock(dev);\n\told = pdev->driver_override;\n\tif (strlen(driver_override)) {\n\t\tpdev->driver_override = driver_override;\n\t} else {\n\t\tkfree(driver_override);\n\t\tpdev->driver_override = NULL;\n\t}\n\tdevice_unlock(dev);\n\n\tkfree(old);\n\n\treturn count;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tif (ret < 0)\n\t\tgoto bail;\n\n\ttmp_sdma_rht = kzalloc(sizeof(*tmp_sdma_rht), GFP_KERNEL);\n\tif (!tmp_sdma_rht) {\n\t\tret = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tret = rhashtable_init(tmp_sdma_rht, &sdma_rht_params);\n\tif (ret < 0)\n\t\tgoto bail;\n\tdd->sdma_rht = tmp_sdma_rht;\n\n\tdd_dev_info(dd, \"SDMA num_sdma: %u\\n\", dd->num_sdma);\n\treturn 0;\n\nbail:\n\tsdma_clean(dd, num_engines);\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tif (ret < 0)\n\t\tgoto bail;\n\n\ttmp_sdma_rht = kzalloc(sizeof(*tmp_sdma_rht), GFP_KERNEL);\n\tif (!tmp_sdma_rht) {\n\t\tret = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tret = rhashtable_init(tmp_sdma_rht, &sdma_rht_params);\n\tif (ret < 0) {\n\t\tkfree(tmp_sdma_rht);\n\t\tgoto bail;\n\t}\n\n\tdd->sdma_rht = tmp_sdma_rht;\n\n\tdd_dev_info(dd, \"SDMA num_sdma: %u\\n\", dd->num_sdma);\n\treturn 0;\n\nbail:\n\tsdma_clean(dd, num_engines);\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "        _tr_tally_lit (s, s->window[s->strstart], bflush);\n        s->lookahead--;\n        s->strstart++;\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "        _tr_tally_lit (s, s->window[s->strstart], bflush);\n        s->lookahead--;\n        s->strstart++;\n        if (bflush) FLUSH_BLOCK(s, 0);\n    }\n    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->sym_next)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "comics_document_render_pixbuf (EvDocument      *document,\n\t\t\t       EvRenderContext *rc)\n{\n\tGdkPixbufLoader *loader;\n\tGdkPixbuf *rotated_pixbuf, *tmp_pixbuf;\n\tchar **argv;\n\tguchar buf[4096];\n\tgboolean success;\n\tgint outpipe = -1;\n\tGPid child_pid;\n\tgssize bytes;\n\tgint width, height;\n\tgchar *filename;\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\t\n\tif (!comics_document->decompress_tmp) {\n\t\targv = extract_argv (document, rc->page->index);\n\t\tsuccess = g_spawn_async_with_pipes (NULL, argv, NULL,\n\t\t\t\t\t\t    G_SPAWN_SEARCH_PATH | \n\t\t\t\t\t\t    G_SPAWN_STDERR_TO_DEV_NULL,\n\t\t\t\t\t\t    NULL, NULL,\n\t\t\t\t\t\t    &child_pid,\n\t\t\t\t\t\t    NULL, &outpipe, NULL, NULL);\n\t\tg_strfreev (argv);\n\t\tg_return_val_if_fail (success == TRUE, NULL);\n\n\t\tloader = gdk_pixbuf_loader_new ();\n\t\tg_signal_connect (loader, \"size-prepared\",\n\t\t\t\t  G_CALLBACK (render_pixbuf_size_prepared_cb), \n\t\t\t\t  &rc->scale);\n\n\t\twhile (outpipe >= 0) {\n\t\t\tbytes = read (outpipe, buf, 4096);\n\n\t\t\tif (bytes > 0) {\n\t\t\t\tgdk_pixbuf_loader_write (loader, buf, bytes, \n\t\t\t\tNULL);\n\t\t\t} else if (bytes <= 0) {\n\t\t\t\tclose (outpipe);\n\t\t\t\tgdk_pixbuf_loader_close (loader, NULL);\n\t\t\t\toutpipe = -1;\n\t\t\t}\n\t\t}\n\t\ttmp_pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);\n\t\trotated_pixbuf =\n\t\t\tgdk_pixbuf_rotate_simple (tmp_pixbuf,\n\t\t\t\t\t\t  360 - rc->rotation);\n\t\tg_spawn_close_pid (child_pid);\n\t\tg_object_unref (loader);\n\t} else {\n\t\tfilename = \n\t\t\tg_build_filename (comics_document->dir,\n                                          (char *) comics_document->page_names->pdata[rc->page->index],\n\t\t\t\t\t  NULL);\n\n\t\tgdk_pixbuf_get_file_info (filename, &width, &height);\n\n\t\ttmp_pixbuf =\n\t\t\tgdk_pixbuf_new_from_file_at_size (\n\t\t\t\t    filename, width * (rc->scale) + 0.5,\n\t\t\t\t    height * (rc->scale) + 0.5, NULL);\n\t\trotated_pixbuf =\n\t\t\tgdk_pixbuf_rotate_simple (tmp_pixbuf,\n\t\t\t\t\t\t  360 - rc->rotation);\n\t\tg_free (filename);\n\t\tg_object_unref (tmp_pixbuf);\n\t}\n\treturn rotated_pixbuf;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "comics_document_render_pixbuf (EvDocument      *document,\n\t\t\t       EvRenderContext *rc)\n{\n\tGdkPixbufLoader *loader;\n\tGdkPixbuf *tmp_pixbuf;\n\tGdkPixbuf *rotated_pixbuf = NULL;\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\tconst char *page_path;\n\tGError *error = NULL;\n\n\tpage_path = g_ptr_array_index (comics_document->page_names, rc->page->index);\n\n\tif (!archive_reopen_if_needed (comics_document, page_path, &error)) {\n\t\tg_warning (\"Fatal error opening archive: %s\", error->message);\n\t\tg_error_free (error);\n\t\treturn NULL;\n\t}\n\n\tloader = gdk_pixbuf_loader_new ();\n\tg_signal_connect (loader, \"size-prepared\",\n\t\t\t  G_CALLBACK (render_pixbuf_size_prepared_cb),\n\t\t\t  rc);\n\n\twhile (1) {\n\t\tconst char *name;\n\n\t\tif (!ev_archive_read_next_header (comics_document->archive, &error)) {\n\t\t\tif (error != NULL) {\n\t\t\t\tg_warning (\"Fatal error handling archive (%s): %s\", G_STRFUNC, error->message);\n\t\t\t\tg_error_free (error);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tname = ev_archive_get_entry_pathname (comics_document->archive);\n\t\tif (g_strcmp0 (name, page_path) == 0) {\n\t\t\tsize_t size = ev_archive_get_entry_size (comics_document->archive);\n\t\t\tchar *buf;\n\t\t\tssize_t read;\n\n\t\t\tbuf = g_malloc (size);\n\t\t\tread = ev_archive_read_data (comics_document->archive, buf, size, &error);\n\t\t\tif (read <= 0) {\n\t\t\t\tif (read < 0) {\n\t\t\t\t\tg_warning (\"Fatal error reading '%s' in archive: %s\", name, error->message);\n\t\t\t\t\tg_error_free (error);\n\t\t\t\t} else {\n\t\t\t\t\tg_warning (\"Read an empty file from the archive\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgdk_pixbuf_loader_write (loader, (guchar *) buf, size, NULL);\n\t\t\t}\n\t\t\tg_free (buf);\n\t\t\tgdk_pixbuf_loader_close (loader, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttmp_pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);\n\tif (tmp_pixbuf) {\n\t\tif ((rc->rotation % 360) == 0)\n\t\t\trotated_pixbuf = g_object_ref (tmp_pixbuf);\n\t\telse\n\t\t\trotated_pixbuf = gdk_pixbuf_rotate_simple (tmp_pixbuf,\n\t\t\t\t\t\t\t\t   360 - rc->rotation);\n\t}\n\tg_object_unref (loader);\n\n\treturn rotated_pixbuf;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "perf_sw_event(u32 event_id, u64 nr, int nmi, struct pt_regs *regs, u64 addr)\n{\n\tstruct pt_regs hot_regs;\n\n\tif (static_branch(&perf_swevent_enabled[event_id])) {\n\t\tif (!regs) {\n\t\t\tperf_fetch_caller_regs(&hot_regs);\n\t\t\tregs = &hot_regs;\n\t\t}\n\t\t__perf_sw_event(event_id, nr, nmi, regs, addr);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)\n{\n\tstruct pt_regs hot_regs;\n\n\tif (static_branch(&perf_swevent_enabled[event_id])) {\n\t\tif (!regs) {\n\t\t\tperf_fetch_caller_regs(&hot_regs);\n\t\t\tregs = &hot_regs;\n\t\t}\n\t\t__perf_sw_event(event_id, nr, regs, addr);\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t\tchassis->c_name = b;\n\t\t\telse chassis->c_descr = b;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_SYSTEM_CAP:\n\t\t\tCHECK_TLV_SIZE(4, \"System capabilities\");\n\t\t\tchassis->c_cap_available = PEEK_UINT16;\n\t\t\tchassis->c_cap_enabled = PEEK_UINT16;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_MGMT_ADDR:\n\t\t\tCHECK_TLV_SIZE(1, \"Management address\");\n\t\t\taddr_str_length = PEEK_UINT8;\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length, \"Management address\");\n\t\t\tPEEK_BYTES(addr_str_buffer, addr_str_length);\n\t\t\taddr_length = addr_str_length - 1;\n\t\t\taddr_family = addr_str_buffer[0];\n\t\t\taddr_ptr = &addr_str_buffer[1];\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length + 5, \"Management address\");\n\t\t\tiface_subtype = PEEK_UINT8;\n\t\t\tiface_number = PEEK_UINT32;\n\t\t\t\n\t\t\taf = lldpd_af_from_lldp_proto(addr_family);\n\t\t\tif (af == LLDPD_AF_UNSPEC)\n\t\t\t\tbreak;\n\t\t\tif (iface_subtype == LLDP_MGMT_IFACE_IFINDEX)\n\t\t\t\tiface = iface_number;\n\t\t\telse\n\t\t\t\tiface = 0;\n\t\t\tmgmt = lldpd_alloc_mgmt(af, addr_ptr, addr_length, iface);\n\t\t\tif (mgmt == NULL) {\n\t\t\t\tassert(errno == ENOMEM);\n\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory \"\n\t\t\t\t\t\t\t\"for management address\");\n\t\t\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\tbreak;\n\t\tcase LLDP_TLV_ORG:\n\t\t\tCHECK_TLV_SIZE(4, \"Organisational\");\n\t\t\tPEEK_BYTES(orgid, sizeof(orgid));\n\t\t\ttlv_subtype = PEEK_UINT8;\n\t\t\tif (memcmp(dot1, orgid, sizeof(orgid)) == 0) {\n#ifndef ENABLE_DOT1\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\t/* Dot1 */\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_DOT1_VLANNAME:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"VLAN\");",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\telse chassis->c_descr = b;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_SYSTEM_CAP:\n\t\t\tCHECK_TLV_SIZE(4, \"System capabilities\");\n\t\t\tchassis->c_cap_available = PEEK_UINT16;\n\t\t\tchassis->c_cap_enabled = PEEK_UINT16;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_MGMT_ADDR:\n\t\t\tCHECK_TLV_SIZE(1, \"Management address\");\n\t\t\taddr_str_length = PEEK_UINT8;\n\t\t\tif (addr_str_length > sizeof(addr_str_buffer)) {\n\t\t\t\tlog_warnx(\"lldp\", \"too large management address on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length, \"Management address\");\n\t\t\tPEEK_BYTES(addr_str_buffer, addr_str_length);\n\t\t\taddr_length = addr_str_length - 1;\n\t\t\taddr_family = addr_str_buffer[0];\n\t\t\taddr_ptr = &addr_str_buffer[1];\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length + 5, \"Management address\");\n\t\t\tiface_subtype = PEEK_UINT8;\n\t\t\tiface_number = PEEK_UINT32;\n\n\t\t\taf = lldpd_af_from_lldp_proto(addr_family);\n\t\t\tif (af == LLDPD_AF_UNSPEC)\n\t\t\t\tbreak;\n\t\t\tif (iface_subtype == LLDP_MGMT_IFACE_IFINDEX)\n\t\t\t\tiface = iface_number;\n\t\t\telse\n\t\t\t\tiface = 0;\n\t\t\tmgmt = lldpd_alloc_mgmt(af, addr_ptr, addr_length, iface);\n\t\t\tif (mgmt == NULL) {\n\t\t\t\tassert(errno == ENOMEM);\n\t\t\t\tlog_warn(\"lldp\", \"unable to allocate memory \"\n\t\t\t\t\t\t\t\"for management address\");\n\t\t\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\tbreak;\n\t\tcase LLDP_TLV_ORG:\n\t\t\tCHECK_TLV_SIZE(1 + (int)sizeof(orgid), \"Organisational\");\n\t\t\tPEEK_BYTES(orgid, sizeof(orgid));\n\t\t\ttlv_subtype = PEEK_UINT8;\n\t\t\tif (memcmp(dot1, orgid, sizeof(orgid)) == 0) {\n#ifndef ENABLE_DOT1\n\t\t\t\thardware->h_rx_unrecognized_cnt++;\n#else\n\t\t\t\t/* Dot1 */\n\t\t\t\tswitch (tlv_subtype) {\n\t\t\t\tcase LLDP_TLV_DOT1_VLANNAME:\n\t\t\t\t\tCHECK_TLV_SIZE(7, \"VLAN\");",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "decode_rt_routing_info(netdissect_options *ndo,\n                       const u_char *pptr, char *buf, u_int buflen)\n{\n\tuint8_t route_target[8];\n\tu_int plen;\n\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   /* get prefix length */\n\n\tif (0 == plen) {\n\t\tsnprintf(buf, buflen, \"default route target\");\n\t\treturn 1;\n\t}\n\n\tif (32 > plen)\n\t\treturn -1;\n\n        plen-=32; /* adjust prefix length */\n\n\tif (64 < plen)\n\t\treturn -1;\n\n\tmemset(&route_target, 0, sizeof(route_target));\n\tND_TCHECK2(pptr[1], (plen + 7) / 8);\n\tmemcpy(&route_target, &pptr[1], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\t((u_char *)&route_target)[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"origin AS: %s, route target %s\",\n\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+1)),\n\t    bgp_vpn_rd_print(ndo, (u_char *)&route_target));\n\n\treturn 5 + (plen + 7) / 8;\n\ntrunc:\n\treturn -2;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "decode_rt_routing_info(netdissect_options *ndo,\n                       const u_char *pptr, char *buf, u_int buflen)\n{\n\tuint8_t route_target[8];\n\tu_int plen;\n\tchar asbuf[sizeof(astostr)]; /* bgp_vpn_rd_print() overwrites astostr */\n\n\t/* NLRI \"prefix length\" from RFC 2858 Section 4. */\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   /* get prefix length */\n\n\t/* NLRI \"prefix\" (ibid), valid lengths are { 0, 32, 33, ..., 96 } bits.\n\t * RFC 4684 Section 4 defines the layout of \"origin AS\" and \"route\n\t * target\" fields inside the \"prefix\" depending on its length.\n\t */\n\tif (0 == plen) {\n\t\t/* Without \"origin AS\", without \"route target\". */\n\t\tsnprintf(buf, buflen, \"default route target\");\n\t\treturn 1;\n\t}\n\n\tif (32 > plen)\n\t\treturn -1;\n\n\t/* With at least \"origin AS\", possibly with \"route target\". */\n\tND_TCHECK_32BITS(pptr + 1);\n\tas_printf(ndo, asbuf, sizeof(asbuf), EXTRACT_32BITS(pptr + 1));\n\n        plen-=32; /* adjust prefix length */\n\n\tif (64 < plen)\n\t\treturn -1;\n\n\t/* From now on (plen + 7) / 8 evaluates to { 0, 1, 2, ..., 8 }\n\t * and gives the number of octets in the variable-length \"route\n\t * target\" field inside this NLRI \"prefix\". Look for it.\n\t */\n\tmemset(&route_target, 0, sizeof(route_target));\n\tND_TCHECK2(pptr[5], (plen + 7) / 8);\n\tmemcpy(&route_target, &pptr[5], (plen + 7) / 8);\n\t/* Which specification says to do this? */\n\tif (plen % 8) {\n\t\t((u_char *)&route_target)[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"origin AS: %s, route target %s\",\n\t    asbuf,\n\t    bgp_vpn_rd_print(ndo, (u_char *)&route_target));\n\n\treturn 5 + (plen + 7) / 8;\n\ntrunc:\n\treturn -2;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t    }\n\t}\n\n\tif (has_mbyte && spaces > 0)\n\t{\n\t    int off;\n\n\t    // Avoid starting halfway a multi-byte character.\n\t    if (b_insert)\n\t    {\n\t\toff = (*mb_head_off)(oldp, oldp + offset + spaces);\n\t    }\n\t    else\n\t    {\n\t\toff = (*mb_off_next)(oldp, oldp + offset);\n\t\toffset += off;\n\t    }\n\t    spaces -= off;\n\t    count -= off;\n\t}\n\tif (spaces < 0)  // can happen when the cursor was moved\n\t    spaces = 0;\n\n\tnewp = alloc(STRLEN(oldp) + s_len + count + 1);\n\tif (newp == NULL)\n\t    continue;\n\n\t// copy up to shifted part\n\tmch_memmove(newp, oldp, (size_t)(offset));\n\toldp += offset;\n\n\t// insert pre-padding\n\tvim_memset(newp + offset, ' ', (size_t)spaces);\n\tstartcol = offset + spaces;\n\n\t// copy the new text\n\tmch_memmove(newp + startcol, s, (size_t)s_len);\n\toffset += s_len;\n\n\tif (spaces && !bdp->is_short)\n\t{\n\t    // insert post-padding\n\t    vim_memset(newp + offset + spaces, ' ', (size_t)(ts_val - spaces));\n\t    // We're splitting a TAB, don't copy it.\n\t    oldp++;\n\t    // We allowed for that TAB, remember this now\n\t    count++;\n\t}\n\n\tif (spaces > 0)\n\t    offset += count;\n\tSTRMOVE(newp + offset, oldp);\n\n\tml_replace(lnum, newp, FALSE);\n\n\tif (b_insert)\n\t    // correct any text properties",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t}\n\n\tif (has_mbyte && spaces > 0)\n\t{\n\t    int off;\n\n\t    // Avoid starting halfway a multi-byte character.\n\t    if (b_insert)\n\t    {\n\t\toff = (*mb_head_off)(oldp, oldp + offset + spaces);\n\t\tspaces -= off;\n\t\tcount -= off;\n\t    }\n\t    else\n\t    {\n\t\t// spaces fill the gap, the character that's at the edge moves\n\t\t// right\n\t\toff = (*mb_head_off)(oldp, oldp + offset);\n\t\toffset -= off;\n\t    }\n\t}\n\tif (spaces < 0)  // can happen when the cursor was moved\n\t    spaces = 0;\n\n\t// Make sure the allocated size matches what is actually copied below.\n\tnewp = alloc(STRLEN(oldp) + spaces + s_len\n\t\t    + (spaces > 0 && !bdp->is_short ? ts_val - spaces : 0)\n\t\t\t\t\t\t\t\t  + count + 1);\n\tif (newp == NULL)\n\t    continue;\n\n\t// copy up to shifted part\n\tmch_memmove(newp, oldp, (size_t)offset);\n\toldp += offset;\n\n\t// insert pre-padding\n\tvim_memset(newp + offset, ' ', (size_t)spaces);\n\tstartcol = offset + spaces;\n\n\t// copy the new text\n\tmch_memmove(newp + startcol, s, (size_t)s_len);\n\toffset += s_len;\n\n\tif (spaces > 0 && !bdp->is_short)\n\t{\n\t    if (*oldp == TAB)\n\t    {\n\t\t// insert post-padding\n\t\tvim_memset(newp + offset + spaces, ' ',\n\t\t\t\t\t\t    (size_t)(ts_val - spaces));\n\t\t// we're splitting a TAB, don't copy it\n\t\toldp++;\n\t\t// We allowed for that TAB, remember this now\n\t\tcount++;\n\t    }\n\t    else\n\t\t// Not a TAB, no extra spaces\n\t\tcount = spaces;\n\t}\n\n\tif (spaces > 0)\n\t    offset += count;\n\tSTRMOVE(newp + offset, oldp);\n\n\tml_replace(lnum, newp, FALSE);\n\n\tif (b_insert)\n\t    // correct any text properties",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {\n\tRList *bins = r_list_newf ((RListFree)free_bin);\n\tif (!bins) {\n\t\treturn NULL;\n\t}\n\n\tchar *target_libs = NULL;\n\tRList *target_lib_names = NULL;\n\tint *deps = NULL;\n\ttarget_libs = r_sys_getenv (\"R_DYLDCACHE_FILTER\");\n\tif (target_libs) {\n\t\ttarget_lib_names = r_str_split_list (target_libs, \":\", 0);\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\tut32 maps_index = cache->maps_index[i];\n\t\tcache_img_t *img = read_cache_images (cache->buf, hdr, hdr_offset);\n\t\tif (!img) {\n\t\t\tgoto next;\n\t\t}\n\n\t\tut32 j;\n\t\tut16 *depArray = NULL;\n\t\tcache_imgxtr_t *extras = NULL;\n\t\tif (target_libs) {\n\t\t\tHtPU *path_to_idx = NULL;\n\t\t\tif (cache->accel) {\n\t\t\t\tdepArray = R_NEWS0 (ut16, cache->accel->depListCount);\n\t\t\t\tif (!depArray) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tif (r_buf_fread_at (cache->buf, cache->accel->depListOffset, (ut8*) depArray, \"s\", cache->accel->depListCount) != cache->accel->depListCount * 2) {\n\t\t\t\t\tgoto next;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {\n\tRList *bins = r_list_newf ((RListFree)free_bin);\n\tut16 *depArray = NULL;\n\tcache_imgxtr_t *extras = NULL;\n\tif (!bins) {\n\t\treturn NULL;\n\t}\n\n\tchar *target_libs = NULL;\n\tRList *target_lib_names = NULL;\n\tint *deps = NULL;\n\ttarget_libs = r_sys_getenv (\"R_DYLDCACHE_FILTER\");\n\tif (target_libs) {\n\t\ttarget_lib_names = r_str_split_list (target_libs, \":\", 0);\n\tut32 i;\n\tfor (i = 0; i < cache->n_hdr; i++) {\n\t\tcache_hdr_t *hdr = &cache->hdr[i];\n\t\tut64 hdr_offset = cache->hdr_offset[i];\n\t\tut32 maps_index = cache->maps_index[i];\n\t\tcache_img_t *img = read_cache_images (cache->buf, hdr, hdr_offset);\n\t\tif (!img) {\n\t\t\tgoto next;\n\t\t}\n\n\t\tut32 j;\n\t\tif (target_libs) {\n\t\t\tHtPU *path_to_idx = NULL;\n\t\t\tif (cache->accel) {\n\t\t\t\tdepArray = R_NEWS0 (ut16, cache->accel->depListCount);\n\t\t\t\tif (!depArray) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tif (r_buf_fread_at (cache->buf, cache->accel->depListOffset, (ut8*) depArray, \"s\", cache->accel->depListCount) != cache->accel->depListCount * 2) {\n\t\t\t\t\tgoto next;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\tintern->_path = estrndup(intern->_path, intern->_path_len);\n\t\t}\n\t\tbreak;\n\tcase SPL_FS_FILE:\n\t\tce = ce ? ce : source->file_class;\n\n\t\tzend_update_class_constants(ce TSRMLS_CC);\n\n\t\treturn_value->value.obj = spl_filesystem_object_new_ex(ce, &intern TSRMLS_CC);\n\t\tZ_TYPE_P(return_value) = IS_OBJECT;\n\t\n\t\tspl_filesystem_object_get_file_name(source TSRMLS_CC);\n\n\t\tif (ce->constructor->common.scope != spl_ce_SplFileObject) {\n\t\t\tMAKE_STD_ZVAL(arg1);\n\t\t\tMAKE_STD_ZVAL(arg2);\n\t\t\tZVAL_STRINGL(arg1, source->file_name, source->file_name_len, 1);\n\t\t\tZVAL_STRINGL(arg2, \"r\", 1, 1);\n\t\t\tzend_call_method_with_2_params(&return_value, ce, &ce->constructor, \"__construct\", NULL, arg1, arg2);\n\t\t\tzval_ptr_dtor(&arg1);\n\t\t\tzval_ptr_dtor(&arg2);\n\t\t} else {\n\t\t\tintern->file_name = source->file_name;\n\t\t\tintern->file_name_len = source->file_name_len;\n\t\t\tintern->_path = spl_filesystem_object_get_path(source, &intern->_path_len TSRMLS_CC);\n\t\t\tintern->_path = estrndup(intern->_path, intern->_path_len);\n\t\t\n\t\t\tintern->u.file.open_mode = \"r\";\n\t\t\tintern->u.file.open_mode_len = 1;\n\t\t\n\t\t\tif (ht && zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|sbr\", \n\t\t\t\t\t&intern->u.file.open_mode, &intern->u.file.open_mode_len, \n\t\t\t\t\t&use_include_path, &intern->u.file.zcontext) == FAILURE) {\n\t\t\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\t\t\tintern->u.file.open_mode = NULL;\n\t\t\t\tintern->file_name = NULL;\n\t\t\t\tzval_dtor(return_value);\n\t\t\t\tZ_TYPE_P(return_value) = IS_NULL;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\n\t\t\tif (spl_filesystem_file_open(intern, use_include_path, 0 TSRMLS_CC) == FAILURE) {\n\t\t\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\t\t\tzval_dtor(return_value);\n\t\t\t\tZ_TYPE_P(return_value) = IS_NULL;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SPL_FS_DIR:\t\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Operation not supported\");\n\t\treturn NULL;\n\t}\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\treturn NULL;\n} /* }}} */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\tintern->_path = estrndup(intern->_path, intern->_path_len);\n\t\t}\n\t\tbreak;\n\tcase SPL_FS_FILE:\n\t\tce = ce ? ce : source->file_class;\n\n\t\tzend_update_class_constants(ce TSRMLS_CC);\n\n\t\treturn_value->value.obj = spl_filesystem_object_new_ex(ce, &intern TSRMLS_CC);\n\t\tZ_TYPE_P(return_value) = IS_OBJECT;\n\n\t\tspl_filesystem_object_get_file_name(source TSRMLS_CC);\n\n\t\tif (ce->constructor->common.scope != spl_ce_SplFileObject) {\n\t\t\tMAKE_STD_ZVAL(arg1);\n\t\t\tMAKE_STD_ZVAL(arg2);\n\t\t\tZVAL_STRINGL(arg1, source->file_name, source->file_name_len, 1);\n\t\t\tZVAL_STRINGL(arg2, \"r\", 1, 1);\n\t\t\tzend_call_method_with_2_params(&return_value, ce, &ce->constructor, \"__construct\", NULL, arg1, arg2);\n\t\t\tzval_ptr_dtor(&arg1);\n\t\t\tzval_ptr_dtor(&arg2);\n\t\t} else {\n\t\t\tintern->file_name = source->file_name;\n\t\t\tintern->file_name_len = source->file_name_len;\n\t\t\tintern->_path = spl_filesystem_object_get_path(source, &intern->_path_len TSRMLS_CC);\n\t\t\tintern->_path = estrndup(intern->_path, intern->_path_len);\n\n\t\t\tintern->u.file.open_mode = \"r\";\n\t\t\tintern->u.file.open_mode_len = 1;\n\n\t\t\tif (ht && zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|sbr\",\n\t\t\t\t\t&intern->u.file.open_mode, &intern->u.file.open_mode_len,\n\t\t\t\t\t&use_include_path, &intern->u.file.zcontext) == FAILURE) {\n\t\t\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\t\t\tintern->u.file.open_mode = NULL;\n\t\t\t\tintern->file_name = NULL;\n\t\t\t\tzval_dtor(return_value);\n\t\t\t\tZ_TYPE_P(return_value) = IS_NULL;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tif (spl_filesystem_file_open(intern, use_include_path, 0 TSRMLS_CC) == FAILURE) {\n\t\t\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\t\t\tzval_dtor(return_value);\n\t\t\t\tZ_TYPE_P(return_value) = IS_NULL;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SPL_FS_DIR:\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Operation not supported\");\n\t\treturn NULL;\n\t}\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\treturn NULL;\n} /* }}} */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n\n    float input_min = context->input(1).flat<float>()(0);\n    float input_max = context->input(2).flat<float>()(0);\n    float input_scale = (input_max - input_min) / 255.0f;\n\n    OP_REQUIRES(context, input_min < input_max,\n                errors::InvalidArgument(\n                    \"input_min must be less than input_max : \", input_min,\n                    \" >= \", input_max));\n\n    auto input_tensor = input.tensor<quint8, 4>();\n    auto N = input_tensor.dimension(0);\n    auto H = input_tensor.dimension(1);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n\n    const Tensor& x_min = context->input(1);\n    const Tensor& x_max = context->input(2);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(x_min.shape()),\n                errors::InvalidArgument(\"`x_min` must be rank 0 but is rank \",\n                                        x_min.dims()));\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(x_max.shape()),\n                errors::InvalidArgument(\"`x_max` must be rank 0 but is rank \",\n                                        x_max.dims()));\n    float input_min = x_min.scalar<float>()();\n    float input_max = x_max.scalar<float>()();\n    float input_scale = (input_max - input_min) / 255.0f;\n\n    OP_REQUIRES(context, input_min < input_max,\n                errors::InvalidArgument(\n                    \"input_min must be less than input_max : \", input_min,\n                    \" >= \", input_max));\n\n    auto input_tensor = input.tensor<quint8, 4>();\n    auto N = input_tensor.dimension(0);\n    auto H = input_tensor.dimension(1);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n\t/* FIXME: skip headers if necessary ?! */\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (saddr) {\n\t\tsaddr->family = AF_IEEE802154;\n\t\tsaddr->addr = mac_cb(skb)->sa;\n\t}\n\tif (addr_len)\n\t\t*addr_len = sizeof(*saddr);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;\n\treturn copied;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t/* FIXME: skip headers if necessary ?! */\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (saddr) {\n\t\tsaddr->family = AF_IEEE802154;\n\t\tsaddr->addr = mac_cb(skb)->sa;\n\t\t*addr_len = sizeof(*saddr);\n\t}\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;\n\treturn copied;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n\t\t     int flen)\n{\n\tstruct ustr *filename, *unifilename;\n\tint len = 0;\n\n\tfilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!filename)\n\t\treturn 0;\n\n\tunifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!unifilename)\n\t\tgoto out1;\n\n\tif (udf_build_ustr_exact(unifilename, sname, flen))\n\t\tgoto out2;\n\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tif (!udf_CS0toUTF8(filename, unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tif (!udf_CS0toNLS(UDF_SB(sb)->s_nls_map, filename,\n\t\t\t\t  unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else\n\t\tgoto out2;\n\n\tlen = udf_translate_to_linux(dname, filename->u_name, filename->u_len,\n\t\t\t\t     unifilename->u_name, unifilename->u_len);\nout2:\n\tkfree(unifilename);\nout1:\n\tkfree(filename);\n\treturn len;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,\n\t\t     uint8_t *dname, int dlen)\n{\n\tstruct ustr *filename, *unifilename;\n\tint len = 0;\n\n\tfilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!filename)\n\t\treturn 0;\n\n\tunifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!unifilename)\n\t\tgoto out1;\n\n\tif (udf_build_ustr_exact(unifilename, sname, slen))\n\t\tgoto out2;\n\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tif (!udf_CS0toUTF8(filename, unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else if (UDF_QUERY_FLAG(sb, UDF_FLAG_NLS_MAP)) {\n\t\tif (!udf_CS0toNLS(UDF_SB(sb)->s_nls_map, filename,\n\t\t\t\t  unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\t\t  sname);\n\t\t\tgoto out2;\n\t\t}\n\t} else\n\t\tgoto out2;\n\n\tlen = udf_translate_to_linux(dname, dlen,\n\t\t\t\t     filename->u_name, filename->u_len,\n\t\t\t\t     unifilename->u_name, unifilename->u_len);\nout2:\n\tkfree(unifilename);\nout1:\n\tkfree(filename);\n\treturn len;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    // parse the payload\n    m_ConfigurationVersion = payload[0];\n    m_Profile              = payload[1];\n    m_ProfileCompatibility = payload[2];\n    m_Level                = payload[3];\n    m_NaluLengthSize       = 1+(payload[4]&3);\n    AP4_UI08 num_seq_params = payload[5]&31;\n    m_SequenceParameters.EnsureCapacity(num_seq_params);\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        m_SequenceParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_SequenceParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n    AP4_UI08 num_pic_params = payload[cursor++];\n    m_PictureParameters.EnsureCapacity(num_pic_params);\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        m_PictureParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_PictureParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    // parse the payload\n    m_ConfigurationVersion = payload[0];\n    m_Profile              = payload[1];\n    m_ProfileCompatibility = payload[2];\n    m_Level                = payload[3];\n    m_NaluLengthSize       = 1+(payload[4]&3);\n    AP4_UI08 num_seq_params = payload[5]&31;\n    m_SequenceParameters.EnsureCapacity(num_seq_params);\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        if (cursor+2 <= payload_size) {\n            AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n            cursor += 2;\n            if (cursor + param_length < payload_size) {\n                m_SequenceParameters.Append(AP4_DataBuffer());\n                m_SequenceParameters[i].SetData(&payload[cursor], param_length);\n                cursor += param_length;\n            }\n        }\n    }\n    AP4_UI08 num_pic_params = payload[cursor++];\n    m_PictureParameters.EnsureCapacity(num_pic_params);\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        if (cursor+2 <= payload_size) {\n            AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n            cursor += 2;\n            if (cursor + param_length < payload_size) {\n                m_PictureParameters.Append(AP4_DataBuffer());\n                m_PictureParameters[i].SetData(&payload[cursor], param_length);\n                cursor += param_length;\n            }\n        }\n    }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tthread->cpu_context.r4 = stk_sz;\n\t\tthread->cpu_context.r5 = stack_start;\n\t\tchildregs->ARM_cpsr = SVC_MODE;\n\t}\n\tthread->cpu_context.pc = (unsigned long)ret_from_fork;\n\tthread->cpu_context.sp = (unsigned long)childregs;\n\n\tclear_ptrace_hw_breakpoint(p);\n\n\tif (clone_flags & CLONE_SETTLS)\n\t\tthread->tp_value = childregs->ARM_r3;\n\n\tthread_notify(THREAD_NOTIFY_COPY, thread);\n\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tthread->cpu_context.r4 = stk_sz;\n\t\tthread->cpu_context.r5 = stack_start;\n\t\tchildregs->ARM_cpsr = SVC_MODE;\n\t}\n\tthread->cpu_context.pc = (unsigned long)ret_from_fork;\n\tthread->cpu_context.sp = (unsigned long)childregs;\n\n\tclear_ptrace_hw_breakpoint(p);\n\n\tif (clone_flags & CLONE_SETTLS)\n\t\tthread->tp_value[0] = childregs->ARM_r3;\n\tthread->tp_value[1] = get_tpuser();\n\n\tthread_notify(THREAD_NOTIFY_COPY, thread);\n\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "      return {num_groups, tensor.dim_size(0), tensor.dim_size(1),\n              tensor.dim_size(2), tensor.dim_size(3) / num_groups};\n    };\n\n    auto& device = ctx->eigen_device<CPUDevice>();\n\n    absl::BlockingCounter shuffles_completed(2);\n    auto on_shuffled = [&]() { shuffles_completed.DecrementCount(); };\n\n    // Shuffle input into temporary tensor.\n    Tensor input_shuffled(input.dtype(), TensorShape(post_shuffle(input)));\n    input_shuffled.tensor<T, 5>().device(device, on_shuffled) =\n        input.shaped<T, 5>(pre_shuffle(input)).shuffle(shuffle);\n\n    // Shuffle filter into temporary tensor.\n    Tensor filter_shuffled(filter.dtype(), TensorShape(post_shuffle(filter)));\n    filter_shuffled.tensor<T, 5>().device(device, on_shuffled) =\n        filter.shaped<T, 5>(pre_shuffle(filter)).shuffle(shuffle);\n\n    // Wait for the completion of input/filter shuffles.\n    shuffles_completed.Wait();\n\n    // Write group convolution results into temporary output tensor.\n    Tensor output_shuffled(output->dtype(), TensorShape(post_shuffle(*output)));\n\n    for (int64_t i = 0; i < num_groups; ++i) {\n      // TODO(ezhulenev): Run this loop using `parallelFor` (regular parallelFor\n      // will lead to deadlock, SpatialConvolution has to use async Eigen\n      // assignment). This requires small changes to Eigen to support async\n      // exeuction for tensor chipping operation.\n\n      // TODO(ezhulenev): Grouped convolution should also support 1x1 filter\n      // optimization.\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "      return {num_groups, tensor.dim_size(0), tensor.dim_size(1),\n              tensor.dim_size(2), tensor.dim_size(3) / num_groups};\n    };\n\n    auto& device = ctx->eigen_device<CPUDevice>();\n\n    absl::BlockingCounter shuffles_completed(2);\n    auto on_shuffled = [&]() { shuffles_completed.DecrementCount(); };\n\n    // Shuffle input into temporary tensor.\n    Tensor input_shuffled;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_temp(input.dtype(), TensorShape(post_shuffle(input)),\n                                &input_shuffled));\n    input_shuffled.tensor<T, 5>().device(device, on_shuffled) =\n        input.shaped<T, 5>(pre_shuffle(input)).shuffle(shuffle);\n\n    // Shuffle filter into temporary tensor.\n    Tensor filter_shuffled;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(filter.dtype(),\n                                           TensorShape(post_shuffle(filter)),\n                                           &filter_shuffled));\n    filter_shuffled.tensor<T, 5>().device(device, on_shuffled) =\n        filter.shaped<T, 5>(pre_shuffle(filter)).shuffle(shuffle);\n\n    // Wait for the completion of input/filter shuffles.\n    shuffles_completed.Wait();\n\n    // Write group convolution results into temporary output tensor.\n    Tensor output_shuffled;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(output->dtype(),\n                                           TensorShape(post_shuffle(*output)),\n                                           &output_shuffled));\n\n    for (int64_t i = 0; i < num_groups; ++i) {\n      // TODO(ezhulenev): Run this loop using `parallelFor` (regular parallelFor\n      // will lead to deadlock, SpatialConvolution has to use async Eigen\n      // assignment). This requires small changes to Eigen to support async\n      // exeuction for tensor chipping operation.\n\n      // TODO(ezhulenev): Grouped convolution should also support 1x1 filter\n      // optimization.\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteResizeBilinearParams*>(node->builtin_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  const TfLiteTensor* size = GetInput(context, node, kSizeTensor);\n\n  if (IsDynamicTensor(output)) {\n    TF_LITE_ENSURE_OK(context,\n                      ResizeOutputTensor(context, input, size, output));\n  }\n\n  if (output->type == kTfLiteFloat32) {\n#define TF_LITE_RESIZE_BILINEAR(type, datatype)                              \\\n  tflite::ResizeBilinearParams op_params;                                    \\\n  op_params.align_corners = params->align_corners;                           \\",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteResizeBilinearParams*>(node->builtin_data);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  const TfLiteTensor* size;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kSizeTensor, &size));\n\n  if (IsDynamicTensor(output)) {\n    TF_LITE_ENSURE_OK(context,\n                      ResizeOutputTensor(context, input, size, output));\n  }\n\n  if (output->type == kTfLiteFloat32) {\n#define TF_LITE_RESIZE_BILINEAR(type, datatype)                              \\\n  tflite::ResizeBilinearParams op_params;                                    \\\n  op_params.align_corners = params->align_corners;                           \\",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tif (msg->u.confconn.turnc > 0) {\n\t\t\terr = zapi_iceservers_encode(jobj,\n\t\t\t\t\t\t     msg->u.confconn.turnv,\n\t\t\t\t\t\t     msg->u.confconn.turnc);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tjzon_add_bool(jobj, \"update\",\n\t\t\t      msg->u.confconn.update);\n\t\tjzon_add_str(jobj, \"tool\",\n\t\t\t      msg->u.confconn.tool);\n\t\tjzon_add_str(jobj, \"toolver\",\n\t\t\t      msg->u.confconn.toolver);\n\t\tjzon_add_int(jobj, \"status\",\n\t\t\t      msg->u.confconn.status);\n\t\tjzon_add_bool(jobj, \"selective_audio\",\n\t\t\t      msg->u.confconn.selective_audio);\n\t\tjzon_add_bool(jobj, \"selective_video\",\n\t\t\t      msg->u.confconn.selective_video);\n\t\tjzon_add_int(jobj, \"vstreams\",\n\t\t\t      msg->u.confconn.vstreams);\n\t\tbreak;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tif (msg->u.confconn.turnc > 0) {\n\t\t\terr = zapi_iceservers_encode(jobj,\n\t\t\t\t\t\t     msg->u.confconn.turnv,\n\t\t\t\t\t\t     msg->u.confconn.turnc);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tjzon_add_bool(jobj, \"update\",\n\t\t\t      msg->u.confconn.update);\n\t\tjzon_add_str(jobj, \"tool\", \n\t\t\t     \"%s\", msg->u.confconn.tool);\n\t\tjzon_add_str(jobj, \"toolver\",\n\t\t\t     \"%s\", msg->u.confconn.toolver);\n\t\tjzon_add_int(jobj, \"status\",\n\t\t\t      msg->u.confconn.status);\n\t\tjzon_add_bool(jobj, \"selective_audio\",\n\t\t\t      msg->u.confconn.selective_audio);\n\t\tjzon_add_bool(jobj, \"selective_video\",\n\t\t\t      msg->u.confconn.selective_video);\n\t\tjzon_add_int(jobj, \"vstreams\",\n\t\t\t      msg->u.confconn.vstreams);\n\t\tbreak;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "pci_vtrnd_notify(void *vsc, struct vqueue_info *vq)\n{\n\tstruct iovec iov;\n\tstruct pci_vtrnd_softc *sc;\n\tint len;\n\tuint16_t idx;\n\n\tsc = vsc;\n\n\tif (sc->vrsc_fd < 0) {\n\t\tvq_endchains(vq, 0);\n\t\treturn;\n\t}\n\n\twhile (vq_has_descs(vq)) {\n\t\tvq_getchain(vq, &idx, &iov, 1, NULL);\n\n\t\tlen = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);\n\n\t\tDPRINTF((\"vtrnd: vtrnd_notify(): %d\\r\\n\", len));\n\n\t\t/* Catastrophe if unable to read from /dev/random */\n\t\tassert(len > 0);\n\n\t\t/*\n\t\t * Release this chain and handle more",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "pci_vtrnd_notify(void *vsc, struct vqueue_info *vq)\n{\n\tstruct iovec iov;\n\tstruct pci_vtrnd_softc *sc;\n\tint len, n;\n\tuint16_t idx;\n\n\tsc = vsc;\n\n\tif (sc->vrsc_fd < 0) {\n\t\tvq_endchains(vq, 0);\n\t\treturn;\n\t}\n\n\twhile (vq_has_descs(vq)) {\n\t\tn = vq_getchain(vq, &idx, &iov, 1, NULL);\n\t\tif (n < 0) {\n\t\t\tfprintf(stderr, \"vtrnd: vtrnd_notify(): n %d\\r\\n\", n);\n\t\t\treturn;\n\t\t}\n\n\t\tlen = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);\n\n\t\tDPRINTF((\"vtrnd: vtrnd_notify(): %d\\r\\n\", len));\n\n\t\t/* Catastrophe if unable to read from /dev/random */\n\t\tassert(len > 0);\n\n\t\t/*\n\t\t * Release this chain and handle more",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0, reasonLen=0;\n    char *reason=NULL;\n\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n\n    authResult = rfbClientSwap32IfLE(authResult);\n\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        /* we have an error following */\n        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;\n        reasonLen = rfbClientSwap32IfLE(reasonLen);\n        reason = malloc((uint64_t)reasonLen+1);\n        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }\n        reason[reasonLen]=0;\n        rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n        free(reason);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0;\n\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n\n    authResult = rfbClientSwap32IfLE(authResult);\n\n    switch (authResult) {\n    case rfbVncAuthOK:\n      rfbClientLog(\"VNC authentication succeeded\\n\");\n      return TRUE;\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        /* we have an error following */\n        ReadReason(client);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:\n      rfbClientLog(\"VNC authentication failed - too many tries\\n\");\n      return FALSE;\n    }\n\n    rfbClientLog(\"Unknown VNC authentication result: %d\\n\",",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void *bpf_any_get(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tatomic_inc(&((struct bpf_prog *)raw)->aux->refcnt);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_inc(raw, true);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn raw;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void *bpf_any_get(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\traw = bpf_prog_inc(raw);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\traw = bpf_map_inc(raw, true);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n\n\treturn raw;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    kadm5_policy_ent_rec    pol;\n    krb5_boolean            have_pol = FALSE;\n    krb5_db_entry           *kdb;\n    krb5_tl_data            *tl_data_orig;\n    osa_princ_ent_rec       adb;\n    kadm5_server_handle_t handle = server_handle;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if((mask & KADM5_PRINCIPAL) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_KEY_DATA) || (mask & KADM5_LAST_SUCCESS) ||\n       (mask & KADM5_LAST_FAILED))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if(entry == (kadm5_principal_ent_t) NULL)\n        return EINVAL;\n    if (mask & KADM5_TL_DATA) {\n        tl_data_orig = entry->tl_data;\n        while (tl_data_orig) {\n            if (tl_data_orig->tl_data_type < 256)\n                return KADM5_BAD_TL_TYPE;\n            tl_data_orig = tl_data_orig->tl_data_next;\n        }\n    }\n\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    krb5_boolean            have_pol = FALSE;\n    krb5_db_entry           *kdb;\n    krb5_tl_data            *tl_data_orig;\n    osa_princ_ent_rec       adb;\n    kadm5_server_handle_t handle = server_handle;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if(entry == NULL)\n        return EINVAL;\n    if((mask & KADM5_PRINCIPAL) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_KEY_DATA) || (mask & KADM5_LAST_SUCCESS) ||\n       (mask & KADM5_LAST_FAILED))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && entry->policy == NULL)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if (mask & KADM5_TL_DATA) {\n        tl_data_orig = entry->tl_data;\n        while (tl_data_orig) {\n            if (tl_data_orig->tl_data_type < 256)\n                return KADM5_BAD_TL_TYPE;\n            tl_data_orig = tl_data_orig->tl_data_next;\n        }\n    }\n\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "cdf_read_short_sector_chain(const cdf_header_t *h,\n    const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SEC_SIZE(h), i, j;\n\tscn->sst_len = cdf_count_chain(ssat, sid, CDF_SEC_SIZE(h));\n\tscn->sst_dirlen = len;\n\n\tif (sst->sst_tab == NULL || scn->sst_len == (size_t)-1)\n\t\treturn -1;\n\n\tscn->sst_tab = calloc(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn -1;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "cdf_read_short_sector_chain(const cdf_header_t *h,\n    const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h), i, j;\n\tscn->sst_len = cdf_count_chain(ssat, sid, CDF_SEC_SIZE(h));\n\tscn->sst_dirlen = len;\n\n\tif (sst->sst_tab == NULL || scn->sst_len == (size_t)-1)\n\t\treturn -1;\n\n\tscn->sst_tab = calloc(scn->sst_len, ss);\n\tif (scn->sst_tab == NULL)\n\t\treturn -1;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "Network::FilterStatus Context::onUpstreamData(int data_length, bool end_of_stream) {\n  if (!wasm_->onUpstreamData_) {\n    return Network::FilterStatus::Continue;\n  }\n  auto result = wasm_->onUpstreamData_(this, id_, static_cast<uint32_t>(data_length),\n                                       static_cast<uint32_t>(end_of_stream));\n  // TODO(PiotrSikora): pull Proxy-WASM's FilterStatus values.\n  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "Network::FilterStatus Context::onUpstreamData(int data_length, bool end_of_stream) {\n  if (!in_vm_context_created_ || !wasm_->onUpstreamData_) {\n    return Network::FilterStatus::Continue;\n  }\n  auto result = wasm_->onUpstreamData_(this, id_, static_cast<uint32_t>(data_length),\n                                       static_cast<uint32_t>(end_of_stream));\n  // TODO(PiotrSikora): pull Proxy-WASM's FilterStatus values.\n  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "nft_meta_get_eval_time(enum nft_meta_keys key,\n\t\t       u32 *dest)\n{\n\tswitch (key) {\n\tcase NFT_META_TIME_NS:\n\t\tnft_reg_store64(dest, ktime_get_real_ns());\n\t\tbreak;\n\tcase NFT_META_TIME_DAY:\n\t\tnft_reg_store8(dest, nft_meta_weekday());\n\t\tbreak;\n\tcase NFT_META_TIME_HOUR:\n\t\t*dest = nft_meta_hour(ktime_get_real_seconds());\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "nft_meta_get_eval_time(enum nft_meta_keys key,\n\t\t       u32 *dest)\n{\n\tswitch (key) {\n\tcase NFT_META_TIME_NS:\n\t\tnft_reg_store64((u64 *)dest, ktime_get_real_ns());\n\t\tbreak;\n\tcase NFT_META_TIME_DAY:\n\t\tnft_reg_store8(dest, nft_meta_weekday());\n\t\tbreak;\n\tcase NFT_META_TIME_HOUR:\n\t\t*dest = nft_meta_hour(ktime_get_real_seconds());\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void send(node_t *node, node_t *child, byte *fout) {\n\tif (node->parent) {\n\t\tsend(node->parent, node, fout);\n\t}\n\tif (child) {\n\t\tif (node->right == child) {\n\t\t\tadd_bit(1, fout);\n\t\t} else {\n\t\t\tadd_bit(0, fout);\n\t\t}\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void send(node_t *node, node_t *child, byte *fout, int maxoffset) {\n\tif (node->parent) {\n\t\tsend(node->parent, node, fout, maxoffset);\n\t}\n\tif (child) {\n\t\tif (bloc >= maxoffset) {\n\t\t\tbloc = maxoffset + 1;\n\t\t\treturn;\n\t\t}\n\t\tif (node->right == child) {\n\t\t\tadd_bit(1, fout);\n\t\t} else {\n\t\t\tadd_bit(0, fout);\n\t\t}\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_skcipher(name, type, mask);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\tstruct skcipher_tfm *tfm;\n\tstruct crypto_skcipher *skcipher;\n\n\ttfm = kzalloc(sizeof(*tfm), GFP_KERNEL);\n\tif (!tfm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tskcipher = crypto_alloc_skcipher(name, type, mask);\n\tif (IS_ERR(skcipher)) {\n\t\tkfree(tfm);\n\t\treturn ERR_CAST(skcipher);\n\t}\n\n\ttfm->skcipher = skcipher;\n\n\treturn tfm;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "_dl_dst_count (const char *name, int is_path)\n{\n  size_t cnt = 0;\n\n  do\n    {\n      size_t len = 1;\n\n      /* $ORIGIN is not expanded for SUID/GUID programs.  */\n      if ((((!__libc_enable_secure\n\t     && strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t    || (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t   && (name[len] == '\\0' || name[len] == '/'\n\t       || (is_path && name[len] == ':')))\n\t  || (name[1] == '{'\n\t      && ((!__libc_enable_secure\n\t\t   && strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t  || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t      && (len = 11) != 0))))\n\t++cnt;\n\n      name = strchr (name + len, '$');\n    }\n  while (name != NULL);\n\n  return cnt;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "_dl_dst_count (const char *name, int is_path)\n{\n  const char *const start = name;\n  size_t cnt = 0;\n\n  do\n    {\n      size_t len = 1;\n\n      /* $ORIGIN is not expanded for SUID/GUID programs.\n\n\t Note that it is no bug that the strings in the first two `strncmp'\n\t calls are longer than the sequence which is actually tested.  */\n      if ((((strncmp (&name[1], \"ORIGIN}\", 6) == 0\n\t     && (!__libc_enable_secure\n\t\t || ((name[7] == '\\0' || (is_path && name[7] == ':'))\n\t\t     && (name == start || (is_path && name[-1] == ':'))))\n\t     && (len = 7) != 0)\n\t    || (strncmp (&name[1], \"PLATFORM}\", 8) == 0 && (len = 9) != 0))\n\t   && (name[len] == '\\0' || name[len] == '/'\n\t       || (is_path && name[len] == ':')))\n\t  || (name[1] == '{'\n\t      && ((strncmp (&name[2], \"ORIGIN}\", 7) == 0\n\t\t   && (!__libc_enable_secure\n\t\t       || ((name[9] == '\\0' || (is_path && name[9] == ':'))\n\t\t\t   && (name == start || (is_path && name[-1] == ':'))))\n\t\t   && (len = 9) != 0)\n\t\t  || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t      && (len = 11) != 0))))\n\t++cnt;\n\n      name = strchr (name + len, '$');\n    }\n  while (name != NULL);\n\n  return cnt;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t/* Update high watermark before we lower rss */\n\tupdate_hiwater_rss(mm);\n\n\tfor (; address < end; pte++, address += PAGE_SIZE) {\n\t\tif (!pte_present(*pte))\n\t\t\tcontinue;\n\t\tpage = vm_normal_page(vma, address, *pte);\n\t\tBUG_ON(!page || PageAnon(page));\n\n\t\tif (locked_vma) {\n\t\t\tmlock_vma_page(page);   /* no-op if already mlocked */\n\t\t\tif (page == check_page)\n\t\t\t\tret = SWAP_MLOCK;\n\t\t\tcontinue;\t/* don't unmap */\n\t\t}\n\n\t\tif (ptep_clear_flush_young_notify(vma, address, pte))\n\t\t\tcontinue;\n\n\t\t/* Nuke the page table entry. */\n\t\tflush_cache_page(vma, address, pte_pfn(*pte));\n\t\tpteval = ptep_clear_flush(vma, address, pte);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t/* Update high watermark before we lower rss */\n\tupdate_hiwater_rss(mm);\n\n\tfor (; address < end; pte++, address += PAGE_SIZE) {\n\t\tif (!pte_present(*pte))\n\t\t\tcontinue;\n\t\tpage = vm_normal_page(vma, address, *pte);\n\t\tBUG_ON(!page || PageAnon(page));\n\n\t\tif (locked_vma) {\n\t\t\tif (page == check_page) {\n\t\t\t\t/* we know we have check_page locked */\n\t\t\t\tmlock_vma_page(page);\n\t\t\t\tret = SWAP_MLOCK;\n\t\t\t} else if (trylock_page(page)) {\n\t\t\t\t/*\n\t\t\t\t * If we can lock the page, perform mlock.\n\t\t\t\t * Otherwise leave the page alone, it will be\n\t\t\t\t * eventually encountered again later.\n\t\t\t\t */\n\t\t\t\tmlock_vma_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t}\n\t\t\tcontinue;\t/* don't unmap */\n\t\t}\n\n\t\tif (ptep_clear_flush_young_notify(vma, address, pte))\n\t\t\tcontinue;\n\n\t\t/* Nuke the page table entry. */\n\t\tflush_cache_page(vma, address, pte_pfn(*pte));\n\t\tpteval = ptep_clear_flush(vma, address, pte);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  if (ret != MEMCACHED_SUCCESS) {\n    return Array();\n  }\n\n  int server_count = memcached_server_count(&data->m_memcache);\n\n  Array return_val;\n\n  for (int server_id = 0; server_id < server_count; server_id++) {\n    memcached_stat_st *stat;\n    char stats_key[30] = {0};\n    size_t key_len;\n\n    LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n      memcached_server_instance_by_position(&data->m_memcache, server_id);\n    const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n    in_port_t port = LMCD_SERVER_PORT(instance);\n\n    stat = stats + server_id;\n\n    Array server_stats = memcache_build_stats(&data->m_memcache, stat, &ret);\n    if (ret != MEMCACHED_SUCCESS) {\n      continue;\n    }\n\n    key_len = snprintf(stats_key, sizeof(stats_key), \"%s:%d\", hostname, port);\n\n    return_val.set(String(stats_key, key_len, CopyString), server_stats);\n  }\n\n  free(stats);\n  return return_val;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  stats = memcached_stat(&data->m_memcache, nullptr, &ret);\n  if (ret != MEMCACHED_SUCCESS) {\n    return Array();\n  }\n\n  int server_count = memcached_server_count(&data->m_memcache);\n\n  Array return_val;\n\n  for (int server_id = 0; server_id < server_count; server_id++) {\n    memcached_stat_st *stat;\n    LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n      memcached_server_instance_by_position(&data->m_memcache, server_id);\n    const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n    in_port_t port = LMCD_SERVER_PORT(instance);\n\n    stat = stats + server_id;\n\n    Array server_stats = memcache_build_stats(&data->m_memcache, stat, &ret);\n    if (ret != MEMCACHED_SUCCESS) {\n      continue;\n    }\n\n    auto const port_str = folly::to<std::string>(port);\n    auto const key_len = strlen(hostname) + 1 + port_str.length();\n    auto key = String(key_len, ReserveString);\n    key += hostname;\n    key += \":\";\n    key += port_str;\n    return_val.set(key, server_stats);\n  }\n\n  free(stats);\n  return return_val;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    const int batch_size = image.dimension(0);\n    const int image_height = image.dimension(1);\n    const int image_width = image.dimension(2);\n\n    const int num_boxes = crops.dimension(0);\n    const int crop_height = crops.dimension(1);\n    const int crop_width = crops.dimension(2);\n    const int depth = crops.dimension(3);\n\n    // Sharding across boxes.\n    auto CropAndResizePerBox = [&](int start_box, int limit_box) {\n      for (int b = start_box; b < limit_box; ++b) {\n        const float y1 = boxes(b, 0);\n        const float x1 = boxes(b, 1);\n        const float y2 = boxes(b, 2);\n        const float x2 = boxes(b, 3);\n\n        const int32 b_in = box_index(b);\n        if (!FastBoundsCheck(b_in, batch_size)) {\n          continue;\n        }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    const int batch_size = image.dimension(0);\n    const int image_height = image.dimension(1);\n    const int image_width = image.dimension(2);\n\n    const int num_boxes = crops.dimension(0);\n    const int crop_height = crops.dimension(1);\n    const int crop_width = crops.dimension(2);\n    const int depth = crops.dimension(3);\n\n    // Sharding across boxes.\n    auto CropAndResizePerBox = [&](int64 start_box, int64 limit_box) {\n      for (int b = start_box; b < limit_box; ++b) {\n        const float y1 = boxes(b, 0);\n        const float x1 = boxes(b, 1);\n        const float y2 = boxes(b, 2);\n        const float x2 = boxes(b, 3);\n\n        const int32 b_in = box_index(b);\n        if (!FastBoundsCheck(b_in, batch_size)) {\n          continue;\n        }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si)\n{\n\ts32 pps_id;\n\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id > 255))\n\t\treturn -1;\n\tsi->pps = &avc->pps[pps_id];\n\tsi->pps->id = pps_id;\n\tif (!si->pps->slice_group_count)\n\t\treturn -2;\n\tsi->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT];\n\tif (!si->sps->log2_max_frame_num)\n\t\treturn -2;\n\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si)\n{\n\ts32 pps_id;\n\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id >= 255))\n\t\treturn -1;\n\tsi->pps = &avc->pps[pps_id];\n\tsi->pps->id = pps_id;\n\tif (!si->pps->slice_group_count)\n\t\treturn -2;\n\tsi->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT];\n\tif (!si->sps->log2_max_frame_num)\n\t\treturn -2;\n\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "create_pty_only(term_T *term, jobopt_T *options)\n{\n    HANDLE\t    hPipeIn = INVALID_HANDLE_VALUE;\n    HANDLE\t    hPipeOut = INVALID_HANDLE_VALUE;\n    char\t    in_name[80], out_name[80];\n    channel_T\t    *channel = NULL;\n\n    create_vterm(term, term->tl_rows, term->tl_cols);\n\n    vim_snprintf(in_name, sizeof(in_name), \"\\\\\\\\.\\\\pipe\\\\vim-%d-in-%d\",\n\t    GetCurrentProcessId(),\n\t    curbuf->b_fnum);\n    hPipeIn = CreateNamedPipe(in_name, PIPE_ACCESS_OUTBOUND,\n\t    PIPE_TYPE_MESSAGE | PIPE_NOWAIT,\n\t    PIPE_UNLIMITED_INSTANCES,\n\t    0, 0, NMPWAIT_NOWAIT, NULL);\n    if (hPipeIn == INVALID_HANDLE_VALUE)\n\tgoto failed;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "create_pty_only(term_T *term, jobopt_T *options)\n{\n    HANDLE\t    hPipeIn = INVALID_HANDLE_VALUE;\n    HANDLE\t    hPipeOut = INVALID_HANDLE_VALUE;\n    char\t    in_name[80], out_name[80];\n    channel_T\t    *channel = NULL;\n\n    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n\treturn FAIL;\n\n    vim_snprintf(in_name, sizeof(in_name), \"\\\\\\\\.\\\\pipe\\\\vim-%d-in-%d\",\n\t    GetCurrentProcessId(),\n\t    curbuf->b_fnum);\n    hPipeIn = CreateNamedPipe(in_name, PIPE_ACCESS_OUTBOUND,\n\t    PIPE_TYPE_MESSAGE | PIPE_NOWAIT,\n\t    PIPE_UNLIMITED_INSTANCES,\n\t    0, 0, NMPWAIT_NOWAIT, NULL);\n    if (hPipeIn == INVALID_HANDLE_VALUE)\n\tgoto failed;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\n\tvar->szKey = (ut16*) malloc (UT16_ALIGN (TRANSLATION_UTF_16_LEN));  //L\"Translation\"\n\tif (!var->szKey) {\n\t\tpe_printf (\"Warning: malloc (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {\n\t\tpe_printf (\"Warning: read (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += TRANSLATION_UTF_16_LEN;\n\tif (memcmp (var->szKey, TRANSLATION_UTF_16, TRANSLATION_UTF_16_LEN)) {\n\t\tpe_printf (\"Warning: check (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\n\tvar->szKey = (ut16*) malloc (UT16_ALIGN (TRANSLATION_UTF_16_LEN));  //L\"Translation\"\n\tif (!var->szKey) {\n\t\tpe_printf (\"Warning: malloc (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) != TRANSLATION_UTF_16_LEN) {\n\t\tpe_printf (\"Warning: read (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += TRANSLATION_UTF_16_LEN;\n\tif (memcmp (var->szKey, TRANSLATION_UTF_16, TRANSLATION_UTF_16_LEN)) {\n\t\tpe_printf (\"Warning: check (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "ByteVector ByteVector::mid(uint index, uint length) const\n{\n  ByteVector v;\n\n  if(index > size())\n    return v;\n\n  ConstIterator endIt;\n\n  if(length < 0xffffffff && length + index < size())\n    endIt = d->data.begin() + index + length;\n  else\n    endIt = d->data.end();\n\n  v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt);\n  v.d->size = v.d->data.size();\n\n  return v;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "ByteVector ByteVector::mid(uint index, uint length) const\n{\n  ByteVector v;\n\n  if(index > size())\n    return v;\n\n  ConstIterator endIt;\n\n  if(length < size() - index)\n    endIt = d->data.begin() + index + length;\n  else\n    endIt = d->data.end();\n\n  v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt);\n  v.d->size = v.d->data.size();\n\n  return v;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n\tpcd_init_units();\n\n\tif (pcd_detect())\n\t\treturn -ENODEV;\n\n\t/* get the atapi capabilities page */\n\tpcd_probe_capabilities();\n\n\tif (register_blkdev(major, name)) {\n\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)\n\t\t\tput_disk(cd->disk);\n\t\treturn -EBUSY;\n\t}\n\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (cd->present) {\n\t\t\tregister_cdrom(&cd->info);\n\t\t\tcd->disk->private_data = cd;\n\t\t\tadd_disk(cd->disk);\n\t\t}\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n\tpcd_init_units();\n\n\tif (pcd_detect())\n\t\treturn -ENODEV;\n\n\t/* get the atapi capabilities page */\n\tpcd_probe_capabilities();\n\n\tif (register_blkdev(major, name)) {\n\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\t\tif (!cd->disk)\n\t\t\t\tcontinue;\n\n\t\t\tblk_cleanup_queue(cd->disk->queue);\n\t\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\t\tput_disk(cd->disk);\n\t\t}\n\t\treturn -EBUSY;\n\t}\n\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (cd->present) {\n\t\t\tregister_cdrom(&cd->info);\n\t\t\tcd->disk->private_data = cd;\n\t\t\tadd_disk(cd->disk);\n\t\t}\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n\tfor (lpc = 500; lpc < max; lpc++) {\n\t\tlpc++;\n\t\tfor(i = 0; i < max; i++) {\n\t\t\tbuffer[i] = 'a' + (i % 10);\n\t\t}\n\t\tbuffer[lpc%600] = 0;\n\t\tqb_log(LOG_INFO, \"Message %d %d - %s\", lpc, lpc%600, buffer);\n\t}\n\n        qb_log_blackbox_write_to_file(\"blackbox.dump\");\n        qb_log_blackbox_print_from_file(\"blackbox.dump\");\n\tunlink(\"blackbox.dump\");\n\tqb_log_fini();\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n\tfor (lpc = 500; lpc < max; lpc++) {\n\t\tlpc++;\n\t\tfor(i = 0; i < max; i++) {\n\t\t\tbuffer[i] = 'a' + (i % 10);\n\t\t}\n\t\tbuffer[lpc%600] = 0;\n\t\tqb_log(LOG_INFO, \"Message %d %d - %s\", lpc, lpc%600, buffer);\n\t}\n\n        rc = qb_log_blackbox_write_to_file(\"blackbox.dump\");\n\tck_assert_int_gt(rc, 0);\n        rc = qb_log_blackbox_print_from_file(\"blackbox.dump\");\n\tck_assert_int_le(rc, 0);\n\tunlink(\"blackbox.dump\");\n\tqb_log_fini();\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int TLSInStream::overrun(int itemSize, int nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"TLSInStream overrun: max itemSize exceeded\");\n\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n\n  while (end < start + itemSize) {\n    int n = readTLS((U8*) end, start + bufSize - end, wait);\n    if (!wait && n == 0)\n      return 0;\n    end += n;\n  }\n\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "size_t TLSInStream::overrun(size_t itemSize, size_t nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"TLSInStream overrun: max itemSize exceeded\");\n\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n\n  while (end < start + itemSize) {\n    size_t n = readTLS((U8*) end, start + bufSize - end, wait);\n    if (!wait && n == 0)\n      return 0;\n    end += n;\n  }\n\n  if (itemSize * nItems > (size_t)(end - ptr))\n    nItems = (end - ptr) / itemSize;\n\n  return nItems;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TEST_P(ResizeRealtimeTest, DISABLED_TestExternalResizeSmallerWidthBiggerSize) {\n  ResizingVideoSource video;\n  video.flag_codec_ = true;\n  video.smaller_width_larger_size_ = true;\n  DefaultConfig();\n  // Disable internal resize for this test.\n  cfg_.rc_resize_allowed = 0;\n  change_bitrate_ = false;\n  mismatch_psnr_ = 0.0;\n  mismatch_nframes_ = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TEST_P(ResizeRealtimeTest, TestExternalResizeSmallerWidthBiggerSize) {\n  ResizingVideoSource video;\n  video.flag_codec_ = true;\n  video.smaller_width_larger_size_ = true;\n  DefaultConfig();\n  // Disable internal resize for this test.\n  cfg_.rc_resize_allowed = 0;\n  change_bitrate_ = false;\n  mismatch_psnr_ = 0.0;\n  mismatch_nframes_ = 0;\n  ASSERT_NO_FATAL_FAILURE(RunLoop(&video));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "        length = (Py_ssize_t) slen;\n        if (start < 0) {\n            start += length;\n            if (start < 0)\n                start = 0;\n        }\n        if (stop < 0)\n            stop += length;\n    }\n    if (unlikely(stop <= start))\n        return PyUnicode_FromUnicode(NULL, 0);\n    length = stop - start;\n    cstring += start;\n    if (decode_func) {\n        return decode_func(cstring, length, errors);\n    } else {\n        return PyUnicode_Decode(cstring, length, encoding, errors);\n    }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "        length = (Py_ssize_t) slen;\n        if (start < 0) {\n            start += length;\n            if (start < 0)\n                start = 0;\n        }\n        if (stop < 0)\n            stop += length;\n    }\n    if (unlikely(stop <= start))\n        return __Pyx_NewRef(__pyx_empty_unicode);\n    length = stop - start;\n    cstring += start;\n    if (decode_func) {\n        return decode_func(cstring, length, errors);\n    } else {\n        return PyUnicode_Decode(cstring, length, encoding, errors);\n    }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tset_segment_selector(ctxt, tss->cs, VCPU_SREG_CS);\n\tset_segment_selector(ctxt, tss->ss, VCPU_SREG_SS);\n\tset_segment_selector(ctxt, tss->ds, VCPU_SREG_DS);\n\n\tcpl = tss->cs & 3;\n\n\t/*\n\t * Now load segment descriptors. If fault happens at this stage\n\t * it is handled in a context of new task\n\t */\n\tret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl, true);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl, true);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl, true);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl, true);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl, true);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\treturn X86EMUL_CONTINUE;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tset_segment_selector(ctxt, tss->cs, VCPU_SREG_CS);\n\tset_segment_selector(ctxt, tss->ss, VCPU_SREG_SS);\n\tset_segment_selector(ctxt, tss->ds, VCPU_SREG_DS);\n\n\tcpl = tss->cs & 3;\n\n\t/*\n\t * Now load segment descriptors. If fault happens at this stage\n\t * it is handled in a context of new task\n\t */\n\tret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl,\n\t\t\t\t\ttrue, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,\n\t\t\t\t\ttrue, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,\n\t\t\t\t\ttrue, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,\n\t\t\t\t\ttrue, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,\n\t\t\t\t\ttrue, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\treturn X86EMUL_CONTINUE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_READ)) {\n            return;\n        }\n    }\n\n    DPRINTF(\"Data ready tag=0x%x len=%zd\\n\", r->req.tag, r->iov.iov_len);\n\n    n = r->iov.iov_len / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    scsi_req_data(&r->req, r->iov.iov_len);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "        r->req.aiocb = NULL;\n        bdrv_acct_done(s->bs, &r->acct);\n    }\n\n    if (ret) {\n        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_READ)) {\n            return;\n        }\n    }\n\n    DPRINTF(\"Data ready tag=0x%x len=%zd\\n\", r->req.tag, r->qiov.size);\n\n    n = r->qiov.size / 512;\n    r->sector += n;\n    r->sector_count -= n;\n    scsi_req_data(&r->req, r->qiov.size);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t    else\n\t\tcrlf = 2;\n\t    *last++ = '\\n';\n\t} else if (c != EOF)\n\t    *last++ = c;\n\n\t*last = 0;\n\n\t/* now that we have the line, handle it */\n\tif (blocktyp == PFA_ASCII) {\n\t    if (strncmp(line, \"currentfile eexec\", 17) == 0 && isspace(line[17])) {\n\t\tchar saved_p;\n\t\t/* assert(line == buffer); */\n\t\tfor (line += 18; isspace(*line); line++)\n\t\t    /* nada */;\n\t\tsaved_p = *line;\n\t\t*line = 0;\n\t\tfr->output_ascii(buffer, line - buffer);\n\t\t*line = saved_p;\n\t\tblocktyp = PFA_EEXEC_TEST;\n\t\tif (!*line)\n\t\t    continue;\n\t    } else {\n\t\tfr->output_ascii(line, last - line);\n\t\tcontinue;\n\t    }\n\t}\n\n\t/* check immediately after \"currentfile eexec\" for ASCII or binary */\n\tif (blocktyp == PFA_EEXEC_TEST) {\n\t    /* 8.Feb.2004: fix bug if first character in a binary eexec block\n\t       is 0, reported by Werner Lemberg */\n\t    for (; line < last && isspace(*line); line++)\n\t\t/* nada */;\n\t    if (line == last)\n\t\tcontinue;\n\t    else if (last >= line + 4 && isxdigit(line[0]) && isxdigit(line[1])\n\t\t     && isxdigit(line[2]) && isxdigit(line[3]))\n\t\tblocktyp = PFA_HEX;\n\t    else\n\t\tblocktyp = PFA_BINARY;\n\t    memmove(buffer, line, last - line + 1);\n\t    last = buffer + (last - line);\n\t    line = buffer;\n\t    /* patch up crlf fix */\n\t    if (blocktyp == PFA_BINARY && crlf) {\n\t\tlast[-1] = '\\r';\n\t\tif (crlf == 2)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t    else\n\t\tcrlf = 2;\n\t    *last++ = '\\n';\n\t} else if (c != EOF)\n\t    *last++ = c;\n\n\t*last = 0;\n\n\t/* now that we have the line, handle it */\n\tif (blocktyp == PFA_ASCII) {\n\t    if (strncmp(line, \"currentfile eexec\", 17) == 0 && isspace((unsigned char) line[17])) {\n\t\tchar saved_p;\n\t\t/* assert(line == buffer); */\n\t\tfor (line += 18; isspace((unsigned char) *line); line++)\n\t\t    /* nada */;\n\t\tsaved_p = *line;\n\t\t*line = 0;\n\t\tfr->output_ascii(buffer, line - buffer);\n\t\t*line = saved_p;\n\t\tblocktyp = PFA_EEXEC_TEST;\n\t\tif (!*line)\n\t\t    continue;\n\t    } else {\n\t\tfr->output_ascii(line, last - line);\n\t\tcontinue;\n\t    }\n\t}\n\n\t/* check immediately after \"currentfile eexec\" for ASCII or binary */\n\tif (blocktyp == PFA_EEXEC_TEST) {\n\t    /* 8.Feb.2004: fix bug if first character in a binary eexec block\n\t       is 0, reported by Werner Lemberg */\n\t    for (; line < last && isspace((unsigned char) *line); line++)\n\t\t/* nada */;\n\t    if (line == last)\n\t\tcontinue;\n\t    else if (last >= line + 4 && isxdigit((unsigned char) line[0])\n                     && isxdigit((unsigned char) line[1])\n\t\t     && isxdigit((unsigned char) line[2])\n                     && isxdigit((unsigned char) line[3]))\n\t\tblocktyp = PFA_HEX;\n\t    else\n\t\tblocktyp = PFA_BINARY;\n\t    memmove(buffer, line, last - line + 1);\n\t    last = buffer + (last - line);\n\t    line = buffer;\n\t    /* patch up crlf fix */\n\t    if (blocktyp == PFA_BINARY && crlf) {\n\t\tlast[-1] = '\\r';\n\t\tif (crlf == 2)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void ConnPoolImplBase::checkForIdleAndCloseIdleConnsIfDraining() {\n  if (is_draining_for_deletion_) {\n    closeIdleConnectionsForDrainingPool();\n  }\n\n  if (isIdleImpl()) {\n    ENVOY_LOG(debug, \"invoking idle callbacks - is_draining_for_deletion_={}\",\n              is_draining_for_deletion_);\n    for (const Instance::IdleCb& cb : idle_callbacks_) {\n      cb();\n    }\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void ConnPoolImplBase::checkForIdleAndCloseIdleConnsIfDraining() {\n  if (is_draining_for_deletion_) {\n    closeIdleConnectionsForDrainingPool();\n  }\n\n  checkForIdleAndNotify();\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "tsl::StatusOr<Platform*> MultiPlatformManagerImpl::InitializePlatformWithName(\n    absl::string_view target,\n    const std::map<std::string, std::string>& options) {\n  absl::MutexLock lock(&mu_);\n\n  TF_ASSIGN_OR_RETURN(Platform * platform, LookupByNameLocked(target));\n  if (platform->Initialized()) {\n    return tsl::Status(\n        port::error::FAILED_PRECONDITION,\n        absl::StrCat(\"platform \\\"\", target, \"\\\" is already initialized\"));\n  }\n\n  TF_RETURN_IF_ERROR(platform->Initialize(options));\n\n  return platform;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "tsl::StatusOr<Platform*> MultiPlatformManagerImpl::InitializePlatformWithName(\n    absl::string_view target,\n    const std::map<std::string, std::string>& options) {\n  absl::MutexLock lock(&mu_);\n\n  TF_ASSIGN_OR_RETURN(Platform * platform, LookupByNameLocked(target));\n  if (platform->Initialized()) {\n    return tsl::Status(\n        tsl::error::FAILED_PRECONDITION,\n        absl::StrCat(\"platform \\\"\", target, \"\\\" is already initialized\"));\n  }\n\n  TF_RETURN_IF_ERROR(platform->Initialize(options));\n\n  return platform;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tint r;\n\n\tif (alt->desc.bInterfaceNumber)\n\t\treturn -ENODEV;\n\n\tar2 = kzalloc(sizeof (struct ati_remote2), GFP_KERNEL);\n\tif (!ar2)\n\t\treturn -ENOMEM;\n\n\tar2->udev = udev;\n\n\tar2->intf[0] = interface;\n\tar2->ep[0] = &alt->endpoint[0].desc;\n\n\tar2->intf[1] = usb_ifnum_to_if(udev, 1);\n\tr = usb_driver_claim_interface(&ati_remote2_driver, ar2->intf[1], ar2);\n\tif (r)\n\t\tgoto fail1;\n\talt = ar2->intf[1]->cur_altsetting;\n\tar2->ep[1] = &alt->endpoint[0].desc;\n\n\tr = ati_remote2_urb_init(ar2);\n\tif (r)\n\t\tgoto fail2;\n\n\tar2->channel_mask = channel_mask;\n\tar2->mode_mask = mode_mask;\n\n\tr = ati_remote2_setup(ar2, ar2->channel_mask);\n\tif (r)\n\t\tgoto fail2;\n\n\tusb_make_path(udev, ar2->phys, sizeof(ar2->phys));\n\tstrlcat(ar2->phys, \"/input0\", sizeof(ar2->phys));\n\n\tstrlcat(ar2->name, \"ATI Remote Wonder II\", sizeof(ar2->name));\n\n\tr = sysfs_create_group(&udev->dev.kobj, &ati_remote2_attr_group);\n\tif (r)\n\t\tgoto fail2;\n\n\tr = ati_remote2_input_init(ar2);\n\tif (r)\n\t\tgoto fail3;\n\n\tusb_set_intfdata(interface, ar2);\n\n\tinterface->needs_remote_wakeup = 1;\n\n\treturn 0;\n\n fail3:\n\tsysfs_remove_group(&udev->dev.kobj, &ati_remote2_attr_group);\n fail2:\n\tati_remote2_urb_cleanup(ar2);\n\tusb_driver_release_interface(&ati_remote2_driver, ar2->intf[1]);\n fail1:\n\tkfree(ar2);\n\n\treturn r;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n\tif (alt->desc.bInterfaceNumber)\n\t\treturn -ENODEV;\n\n\tar2 = kzalloc(sizeof (struct ati_remote2), GFP_KERNEL);\n\tif (!ar2)\n\t\treturn -ENOMEM;\n\n\tar2->udev = udev;\n\n\t/* Sanity check, first interface must have an endpoint */\n\tif (alt->desc.bNumEndpoints < 1 || !alt->endpoint) {\n\t\tdev_err(&interface->dev,\n\t\t\t\"%s(): interface 0 must have an endpoint\\n\", __func__);\n\t\tr = -ENODEV;\n\t\tgoto fail1;\n\t}\n\tar2->intf[0] = interface;\n\tar2->ep[0] = &alt->endpoint[0].desc;\n\n\t/* Sanity check, the device must have two interfaces */\n\tar2->intf[1] = usb_ifnum_to_if(udev, 1);\n\tif ((udev->actconfig->desc.bNumInterfaces < 2) || !ar2->intf[1]) {\n\t\tdev_err(&interface->dev, \"%s(): need 2 interfaces, found %d\\n\",\n\t\t\t__func__, udev->actconfig->desc.bNumInterfaces);\n\t\tr = -ENODEV;\n\t\tgoto fail1;\n\t}\n\n\tr = usb_driver_claim_interface(&ati_remote2_driver, ar2->intf[1], ar2);\n\tif (r)\n\t\tgoto fail1;\n\n\t/* Sanity check, second interface must have an endpoint */\n\talt = ar2->intf[1]->cur_altsetting;\n\tif (alt->desc.bNumEndpoints < 1 || !alt->endpoint) {\n\t\tdev_err(&interface->dev,\n\t\t\t\"%s(): interface 1 must have an endpoint\\n\", __func__);\n\t\tr = -ENODEV;\n\t\tgoto fail2;\n\t}\n\tar2->ep[1] = &alt->endpoint[0].desc;\n\n\tr = ati_remote2_urb_init(ar2);\n\tif (r)\n\t\tgoto fail3;\n\n\tar2->channel_mask = channel_mask;\n\tar2->mode_mask = mode_mask;\n\n\tr = ati_remote2_setup(ar2, ar2->channel_mask);\n\tif (r)\n\t\tgoto fail3;\n\n\tusb_make_path(udev, ar2->phys, sizeof(ar2->phys));\n\tstrlcat(ar2->phys, \"/input0\", sizeof(ar2->phys));\n\n\tstrlcat(ar2->name, \"ATI Remote Wonder II\", sizeof(ar2->name));\n\n\tr = sysfs_create_group(&udev->dev.kobj, &ati_remote2_attr_group);\n\tif (r)\n\t\tgoto fail3;\n\n\tr = ati_remote2_input_init(ar2);\n\tif (r)\n\t\tgoto fail4;\n\n\tusb_set_intfdata(interface, ar2);\n\n\tinterface->needs_remote_wakeup = 1;\n\n\treturn 0;\n\n fail4:\n\tsysfs_remove_group(&udev->dev.kobj, &ati_remote2_attr_group);\n fail3:\n\tati_remote2_urb_cleanup(ar2);\n fail2:\n\tusb_driver_release_interface(&ati_remote2_driver, ar2->intf[1]);\n fail1:\n\tkfree(ar2);\n\n\treturn r;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "inline bool CDRMessage::addBinaryPropertySeq(CDRMessage_t* msg, const BinaryPropertySeq& binary_properties, const std::string& property_limit)\n{\n    bool returnedValue = false;\n\n    if(msg->pos + 4 <  msg->max_size)\n    {\n        uint32_t position = 0;\n        uint32_t number_to_serialize = 0;\n        for(auto it = binary_properties.begin(); it != binary_properties.end() &&\n                it->name().compare(property_limit) != 0; ++it)\n        {\n            if(it->propagate())\n                ++number_to_serialize;\n            ++position;\n        }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "inline bool CDRMessage::addBinaryPropertySeq(CDRMessage_t* msg, const BinaryPropertySeq& binary_properties, const std::string& property_limit)\n{\n    assert(msg);\n\n    bool returnedValue = false;\n\n    if(msg->pos + 4 <=  msg->max_size)\n    {\n        uint32_t position = 0;\n        uint32_t number_to_serialize = 0;\n        for(auto it = binary_properties.begin(); it != binary_properties.end() &&\n                it->name().compare(property_limit) != 0; ++it)\n        {\n            if(it->propagate())\n                ++number_to_serialize;\n            ++position;\n        }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  void readDataAvailable(size_t len) noexcept override {\n    std::cerr << \"readDataAvailable, len \" << len << std::endl;\n\n    currentBuffer.length = len;\n\n    wcb_->setSocket(socket_);\n\n    // Write back the same data.\n    socket_->write(wcb_, currentBuffer.buffer, len, writeFlags);\n\n    buffers.push_back(currentBuffer);\n    currentBuffer.reset();\n    state = STATE_SUCCEEDED;\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  void readDataAvailable(size_t len) noexcept override {\n    std::cerr << \"readDataAvailable, len \" << len << std::endl;\n\n    currentBuffer.length = len;\n\n    if (wcb_) {\n      wcb_->setSocket(socket_);\n    }\n\n    // Write back the same data.\n    socket_->write(wcb_, currentBuffer.buffer, len, writeFlags);\n\n    buffers.push_back(currentBuffer);\n    currentBuffer.reset();\n    state = STATE_SUCCEEDED;\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tint isum = 0;\n\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j)\n\t\tverdef->vd_flags = READ16 (dfs, j)\n\t\tverdef->vd_ndx = READ16 (dfs, j)\n\t\tverdef->vd_cnt = READ16 (dfs, j)\n\t\tverdef->vd_hash = READ32 (dfs, j)\n\t\tverdef->vd_aux = READ32 (dfs, j)\n\t\tverdef->vd_next = READ32 (dfs, j)\n\t\tvstart += verdef->vd_aux;\n\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j)\n\t\taux.vda_next = READ32 (vstart, j)\n\n\t\tisum = i + verdef->vd_aux;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tint isum = 0;\n\n\t\tr_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef)));\n\t\tverdef->vd_version = READ16 (dfs, j)\n\t\tverdef->vd_flags = READ16 (dfs, j)\n\t\tverdef->vd_ndx = READ16 (dfs, j)\n\t\tverdef->vd_cnt = READ16 (dfs, j)\n\t\tverdef->vd_hash = READ32 (dfs, j)\n\t\tverdef->vd_aux = READ32 (dfs, j)\n\t\tverdef->vd_next = READ32 (dfs, j)\n\t\tint vdaux = verdef->vd_aux;\n\t\tif (vdaux < 1) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tvstart += vdaux;\n\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tj = 0;\n\t\taux.vda_name = READ32 (vstart, j)\n\t\taux.vda_next = READ32 (vstart, j)\n\n\t\tisum = i + verdef->vd_aux;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  // TODO(b/137042749): TFLite infrastructure (converter, delegate) doesn't\n  // fully support 0-output ops yet. Currently it works if we manually crfat\n  // a TFLite graph that contains variable ops. Note:\n  // * The TFLite Converter need to be changed to be able to produce an op\n  //   with 0 output.\n  // * The delegation code need to be changed to handle 0 output ops. However\n  //   everything still works fine when variable ops aren't used.\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 0);\n\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputVariableId);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumElements(input_resource_id_tensor), 1);\n\n  return kTfLiteOk;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  // TODO(b/137042749): TFLite infrastructure (converter, delegate) doesn't\n  // fully support 0-output ops yet. Currently it works if we manually crfat\n  // a TFLite graph that contains variable ops. Note:\n  // * The TFLite Converter need to be changed to be able to produce an op\n  //   with 0 output.\n  // * The delegation code need to be changed to handle 0 output ops. However\n  //   everything still works fine when variable ops aren't used.\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 0);\n\n  const TfLiteTensor* input_resource_id_tensor;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputVariableId,\n                                          &input_resource_id_tensor));\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumElements(input_resource_id_tensor), 1);\n\n  return kTfLiteOk;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "jp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\treturn box;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "jp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tif (!(box = jp2_box_create0())) {\n\t\treturn 0;\n\t}\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}\n\tbox->info = boxinfo;\n\tbox->ops = &boxinfo->ops;\n\treturn box;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "mp_capable_print(netdissect_options *ndo,\n                 const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_capable *mpc = (const struct mp_capable *) opt;\n\n        if (!(opt_len == 12 && flags & TH_SYN) &&\n            !(opt_len == 20 && (flags & (TH_SYN | TH_ACK)) == TH_ACK))\n                return 0;\n\n        if (MP_CAPABLE_OPT_VERSION(mpc->sub_ver) != 0) {\n                ND_PRINT((ndo, \" Unknown Version (%d)\", MP_CAPABLE_OPT_VERSION(mpc->sub_ver)));\n                return 1;\n        }\n\n        if (mpc->flags & MP_CAPABLE_C)\n                ND_PRINT((ndo, \" csum\"));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "mp_capable_print(netdissect_options *ndo,\n                 const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_capable *mpc = (const struct mp_capable *) opt;\n\n        if (!(opt_len == 12 && (flags & TH_SYN)) &&\n            !(opt_len == 20 && (flags & (TH_SYN | TH_ACK)) == TH_ACK))\n                return 0;\n\n        if (MP_CAPABLE_OPT_VERSION(mpc->sub_ver) != 0) {\n                ND_PRINT((ndo, \" Unknown Version (%d)\", MP_CAPABLE_OPT_VERSION(mpc->sub_ver)));\n                return 1;\n        }\n\n        if (mpc->flags & MP_CAPABLE_C)\n                ND_PRINT((ndo, \" csum\"));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "Ta3AST_FromNodeObject(const node *n, PyCompilerFlags *flags,\n                     PyObject *filename, int feature_version,\n                     PyArena *arena)\n{\n    int i, j, k, num;\n    asdl_seq *stmts = NULL;\n    asdl_seq *type_ignores = NULL;\n    stmt_ty s;\n    node *ch;\n    struct compiling c;\n    mod_ty res = NULL;\n    asdl_seq *argtypes = NULL;\n    expr_ty ret, arg;\n\n    c.c_arena = arena;\n    /* borrowed reference */\n    c.c_filename = filename;\n    c.c_normalize = NULL;\n    c.c_normalize_args = NULL;\n    c.c_feature_version = feature_version;\n\n    if (TYPE(n) == encoding_decl)\n        n = CHILD(n, 0);\n\n    k = 0;\n    switch (TYPE(n)) {\n        case file_input:\n            stmts = _Ta3_asdl_seq_new(num_stmts(n), arena);\n            if (!stmts)\n            ch = CHILD(n, NCH(n) - 1);\n            REQ(ch, ENDMARKER);\n            num = NCH(ch);\n            type_ignores = _Ta3_asdl_seq_new(num, arena);\n            if (!type_ignores)\n                goto out;\n\n            for (i = 0; i < num; i++) {\n                type_ignore_ty ti = TypeIgnore(LINENO(CHILD(ch, i)), arena);\n                if (!ti)\n                    goto out;\n                asdl_seq_SET(type_ignores, i, ti);\n            }\n\n            res = Module(stmts, type_ignores, arena);\n            break;\n        case eval_input: {\n            expr_ty testlist_ast;\n\n            /* XXX Why not comp_for here? */\n            testlist_ast = ast_for_testlist(&c, CHILD(n, 0));\n            if (!testlist_ast)\n            res = FunctionType(argtypes, ret, arena);\n            break;\n        default:\n            PyErr_Format(PyExc_SystemError,\n                         \"invalid node %d for Ta3AST_FromNode\", TYPE(n));\n            goto out;\n    }\n out:\n    if (c.c_normalize) {\n        Py_DECREF(c.c_normalize);\n        PyTuple_SET_ITEM(c.c_normalize_args, 1, NULL);\n        Py_DECREF(c.c_normalize_args);\n    }\n    return res;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "Ta3AST_FromNodeObject(const node *n, PyCompilerFlags *flags,\n                      PyObject *filename, int feature_version,\n                      PyArena *arena)\n{\n    int i, j, k, num;\n    asdl_seq *stmts = NULL;\n    asdl_seq *type_ignores = NULL;\n    stmt_ty s;\n    node *ch;\n    struct compiling c;\n    mod_ty res = NULL;\n    asdl_seq *argtypes = NULL;\n    expr_ty ret, arg;\n\n    c.c_arena = arena;\n    /* borrowed reference */\n    c.c_filename = filename;\n    c.c_normalize = NULL;\n    c.c_feature_version = feature_version;\n\n    if (TYPE(n) == encoding_decl)\n        n = CHILD(n, 0);\n\n    k = 0;\n    switch (TYPE(n)) {\n        case file_input:\n            stmts = _Ta3_asdl_seq_new(num_stmts(n), arena);\n            if (!stmts)\n            ch = CHILD(n, NCH(n) - 1);\n            REQ(ch, ENDMARKER);\n            num = NCH(ch);\n            type_ignores = _Ta3_asdl_seq_new(num, arena);\n            if (!type_ignores)\n                goto out;\n\n            for (i = 0; i < num; i++) {\n                type_ignore_ty ti = TypeIgnore(LINENO(CHILD(ch, i)), arena);\n                if (!ti)\n                   goto out;\n               asdl_seq_SET(type_ignores, i, ti);\n            }\n\n            res = Module(stmts, type_ignores, arena);\n            break;\n        case eval_input: {\n            expr_ty testlist_ast;\n\n            /* XXX Why not comp_for here? */\n            testlist_ast = ast_for_testlist(&c, CHILD(n, 0));\n            if (!testlist_ast)\n                goto out;\n            res = FunctionType(argtypes, ret, arena);\n            break;\n        default:\n            PyErr_Format(PyExc_SystemError,\n                         \"invalid node %d for Ta3AST_FromNode\", TYPE(n));\n            goto out;\n    }\n out:\n    if (c.c_normalize) {\n        Py_DECREF(c.c_normalize);\n    }\n    return res;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  OpContext op_context(context, node);\n  TF_LITE_ENSURE_OK(context, InitializeTemporaries(context, node, &op_context));\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n\n  bool adj_x = op_context.params->adj_x;\n  bool adj_y = op_context.params->adj_y;\n\n  const TfLiteTensor* lhs_data = GetInput(context, node, kInputLHSTensor);\n  const TfLiteTensor* rhs_data = GetInput(context, node, kInputRHSTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  // Note that quantized inference requires that all tensors have their\n  // parameters set. This is usually done during quantized training.\n  if (lhs_data->type == kTfLiteInt8) {\n    double real_multiplier = 0.0;\n    TF_LITE_ENSURE_STATUS(GetQuantizedConvolutionMultipler(\n        context, lhs_data, rhs_data, output, &real_multiplier));\n    int exponent;\n    QuantizeMultiplier(real_multiplier, &op_data->output_multiplier, &exponent);\n    op_data->output_shift = exponent;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  OpContext op_context(context, node);\n  TF_LITE_ENSURE_OK(context, InitializeTemporaries(context, node, &op_context));\n  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n\n  bool adj_x = op_context.params->adj_x;\n  bool adj_y = op_context.params->adj_y;\n\n  const TfLiteTensor* lhs_data;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputLHSTensor, &lhs_data));\n  const TfLiteTensor* rhs_data;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputRHSTensor, &rhs_data));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  // Note that quantized inference requires that all tensors have their\n  // parameters set. This is usually done during quantized training.\n  if (lhs_data->type == kTfLiteInt8) {\n    double real_multiplier = 0.0;\n    TF_LITE_ENSURE_STATUS(GetQuantizedConvolutionMultipler(\n        context, lhs_data, rhs_data, output, &real_multiplier));\n    int exponent;\n    QuantizeMultiplier(real_multiplier, &op_data->output_multiplier, &exponent);\n    op_data->output_shift = exponent;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tif (er < 0) {\n\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\n\tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(*sax));\n\t\tsax->sax25_family = AF_NETROM;\n\t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n\t\t\t      AX25_ADDR_LEN);\n\t}\n\n\tmsg->msg_namelen = sizeof(*sax);\n\n\tskb_free_datagram(sk, skb);\n\n\trelease_sock(sk);\n\treturn copied;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tskb_free_datagram(sk, skb);\n\t\trelease_sock(sk);\n\t\treturn er;\n\t}\n\n\tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(*sax));\n\t\tsax->sax25_family = AF_NETROM;\n\t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n\t\t\t      AX25_ADDR_LEN);\n\t\tmsg->msg_namelen = sizeof(*sax);\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\trelease_sock(sk);\n\treturn copied;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "tvb_get_manuf_name_if_known(tvbuff_t *tvb, gint offset)\n{\n    return get_manuf_name_if_known(tvb_get_ptr(tvb, offset, 3));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "tvb_get_manuf_name_if_known(tvbuff_t *tvb, gint offset)\n{\n    guint8 buf[6] = { 0 };\n    tvb_memcpy(tvb, buf, offset, 3);\n    return get_manuf_name_if_known(buf, sizeof(buf));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.time_page) {\n\t\tkvm_release_page_dirty(vcpu->arch.time_page);\n\t\tvcpu->arch.time_page = NULL;\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.pv_time_enabled = false;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  const float filter_max = 9.0f;\n  Tensor filter_float(DT_FLOAT,\n                      {filter_size, filter_size, depth, filter_count});\n  test::FillValues<float>(&filter_float, {1, 4, 7, 2, 5, 8, 3, 6, 9});\n  Tensor filter_quantized =\n      FloatTensorToQuantized<quint8>(filter_float, filter_min, filter_max);\n  AddInputFromArray<quint8>(image_quantized.shape(),\n                            image_quantized.flat<quint8>());\n  AddInputFromArray<quint8>(filter_quantized.shape(),\n                            filter_quantized.flat<quint8>());\n  AddInputFromArray<float>(TensorShape({1}), {image_min});\n  AddInputFromArray<float>(TensorShape({1}), {image_max});\n  AddInputFromArray<float>(TensorShape({1}), {filter_min});\n  AddInputFromArray<float>(TensorShape({1}), {filter_max});\n  TF_ASSERT_OK(RunOpKernel());\n  const int expected_width = image_width;\n  const int expected_height = image_height * filter_count;\n  Tensor expected_float(\n      DT_FLOAT, TensorShape({image_batch_count, expected_height, expected_width,\n                             filter_count}));\n  test::FillValues<float>(&expected_float, {105, 150, 183, 95, 235, 312, 357,\n                                            178, 187, 234, 261, 121});\n  const Tensor& output_quantized = *GetOutput(0);\n  const float output_min = GetOutput(1)->flat<float>()(0);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  const float filter_max = 9.0f;\n  Tensor filter_float(DT_FLOAT,\n                      {filter_size, filter_size, depth, filter_count});\n  test::FillValues<float>(&filter_float, {1, 4, 7, 2, 5, 8, 3, 6, 9});\n  Tensor filter_quantized =\n      FloatTensorToQuantized<quint8>(filter_float, filter_min, filter_max);\n  AddInputFromArray<quint8>(image_quantized.shape(),\n                            image_quantized.flat<quint8>());\n  AddInputFromArray<quint8>(filter_quantized.shape(),\n                            filter_quantized.flat<quint8>());\n  AddInputFromArray<float>(TensorShape({}), {image_min});\n  AddInputFromArray<float>(TensorShape({}), {image_max});\n  AddInputFromArray<float>(TensorShape({}), {filter_min});\n  AddInputFromArray<float>(TensorShape({}), {filter_max});\n  TF_ASSERT_OK(RunOpKernel());\n  const int expected_width = image_width;\n  const int expected_height = image_height * filter_count;\n  Tensor expected_float(\n      DT_FLOAT, TensorShape({image_batch_count, expected_height, expected_width,\n                             filter_count}));\n  test::FillValues<float>(&expected_float, {105, 150, 183, 95, 235, 312, 357,\n                                            178, 187, 234, 261, 121});\n  const Tensor& output_quantized = *GetOutput(0);\n  const float output_min = GetOutput(1)->flat<float>()(0);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void ed_mul_sim_plain(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\t\tconst bn_t m, const ed_t *t) {\n\tint i, l, l0, l1, n0, n1, w, gen;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;\n\ted_t t0[1 << (ED_WIDTH - 2)];\n\ted_t t1[1 << (ED_WIDTH - 2)];\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (ED_WIDTH - 2)); i++) {\n\t\t\t\ted_null(t0[i]);\n\t\t\t\ted_new(t0[i]);\n\t\t\t}\n\t\t\ted_tab(t0, p, ED_WIDTH);\n\t\t\tt = (const ed_t *)t0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void ed_mul_sim_plain(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\t\tconst bn_t m, const ed_t *t) {\n\tint i, n0, n1, w, gen;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;\n\ted_t t0[1 << (ED_WIDTH - 2)];\n\ted_t t1[1 << (ED_WIDTH - 2)];\n\tsize_t l, l0, l1;\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (ED_WIDTH - 2)); i++) {\n\t\t\t\ted_null(t0[i]);\n\t\t\t\ted_new(t0[i]);\n\t\t\t}\n\t\t\ted_tab(t0, p, ED_WIDTH);\n\t\t\tt = (const ed_t *)t0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\treplacement = (const unsigned char*)\"\\xEF\\xBF\\xBD\";\n\t\t\treplacement_len = sizeof(\"\\xEF\\xBF\\xBD\") - 1;\n\t\t} else {\n\t\t\treplacement = (const unsigned char*)\"&#xFFFD;\";\n\t\t\treplacement_len = sizeof(\"&#xFFFD;\") - 1;\n\t\t}\n\t}\n\n\t/* initial estimate */\n\tif (oldlen < 64) {\n\t\tmaxlen = 128;\t\n\t} else {\n\t\tmaxlen = 2 * oldlen;\n\t\tif (maxlen < oldlen) {\n\t\t\tzend_error_noreturn(E_ERROR, \"Input string is too long\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treplaced = emalloc(maxlen + 1); /* adding 1 is safe: maxlen is even */\n\tlen = 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\treplacement = (const unsigned char*)\"\\xEF\\xBF\\xBD\";\n\t\t\treplacement_len = sizeof(\"\\xEF\\xBF\\xBD\") - 1;\n\t\t} else {\n\t\t\treplacement = (const unsigned char*)\"&#xFFFD;\";\n\t\t\treplacement_len = sizeof(\"&#xFFFD;\") - 1;\n\t\t}\n\t}\n\n\t/* initial estimate */\n\tif (oldlen < 64) {\n\t\tmaxlen = 128;\n\t} else {\n\t\tmaxlen = 2 * oldlen;\n\t\tif (maxlen < oldlen) {\n\t\t\tzend_error_noreturn(E_ERROR, \"Input string is too long\");\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treplaced = emalloc(maxlen + 1); /* adding 1 is safe: maxlen is even */\n\tlen = 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "        /*Codes_SRS_HTTPAPI_COMPACT_21_060: [ If the optionName is NULL, the HTTPAPI_SetOption shall return HTTPAPI_INVALID_ARG. ]*/\n        /*Codes_SRS_HTTPAPI_COMPACT_21_061: [ If the value is NULL, the HTTPAPI_SetOption shall return HTTPAPI_INVALID_ARG. ]*/\n        result = HTTPAPI_INVALID_ARG;\n    }\n    else if (strcmp(OPTION_TRUSTED_CERT, optionName) == 0)\n    {\n#ifdef DO_NOT_COPY_TRUSTED_CERTS_STRING\n        result = HTTPAPI_OK;\n        http_instance->certificate = (char*)value;\n#else\n        int len;\n\n        if (http_instance->certificate)\n        {\n            free(http_instance->certificate);\n        }\n\n        len = (int)strlen((char*)value);\n        http_instance->certificate = (char*)malloc((len + 1) * sizeof(char));\n        if (http_instance->certificate == NULL)\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_062: [ If any memory allocation get fail, the HTTPAPI_SetOption shall return HTTPAPI_ALLOC_FAILED. ]*/\n            result = HTTPAPI_ALLOC_FAILED;\n            LogInfo(\"unable to allocate memory for the certificate in HTTPAPI_SetOption\");\n        }\n        else\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_064: [ If the HTTPAPI_SetOption get success setting the option, it shall return HTTPAPI_OK. ]*/\n            (void)strcpy(http_instance->certificate, (const char*)value);\n            result = HTTPAPI_OK;\n        }\n#endif // DO_NOT_COPY_TRUSTED_CERTS_STRING\n    }\n    else if (strcmp(SU_OPTION_X509_CERT, optionName) == 0 || strcmp(OPTION_X509_ECC_CERT, optionName) == 0)\n    {\n        int len;\n        if (http_instance->x509ClientCertificate)\n        {\n            free(http_instance->x509ClientCertificate);\n        }\n\n        len = (int)strlen((char*)value);\n        http_instance->x509ClientCertificate = (char*)malloc((len + 1) * sizeof(char));\n        if (http_instance->x509ClientCertificate == NULL)\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_062: [ If any memory allocation get fail, the HTTPAPI_SetOption shall return HTTPAPI_ALLOC_FAILED. ]*/\n            result = HTTPAPI_ALLOC_FAILED;\n            LogInfo(\"unable to allocate memory for the client certificate in HTTPAPI_SetOption\");\n        }\n        else\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_064: [ If the HTTPAPI_SetOption get success setting the option, it shall return HTTPAPI_OK. ]*/\n            (void)strcpy(http_instance->x509ClientCertificate, (const char*)value);\n            result = HTTPAPI_OK;\n        }\n    }\n    else if (strcmp(SU_OPTION_X509_PRIVATE_KEY, optionName) == 0 || strcmp(OPTION_X509_ECC_KEY, optionName) == 0)\n    {\n        int len;\n        if (http_instance->x509ClientPrivateKey)\n        {\n            free(http_instance->x509ClientPrivateKey);\n        }\n\n        len = (int)strlen((char*)value);\n        http_instance->x509ClientPrivateKey = (char*)malloc((len + 1) * sizeof(char));\n        if (http_instance->x509ClientPrivateKey == NULL)\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_062: [ If any memory allocation get fail, the HTTPAPI_SetOption shall return HTTPAPI_ALLOC_FAILED. ]*/\n            result = HTTPAPI_ALLOC_FAILED;\n            LogInfo(\"unable to allocate memory for the client private key in HTTPAPI_SetOption\");\n        }\n        else\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_064: [ If the HTTPAPI_SetOption get success setting the option, it shall return HTTPAPI_OK. ]*/\n            (void)strcpy(http_instance->x509ClientPrivateKey, (const char*)value);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "        /*Codes_SRS_HTTPAPI_COMPACT_21_059: [ If the handle is NULL, the HTTPAPI_SetOption shall return HTTPAPI_INVALID_ARG. ]*/\n        /*Codes_SRS_HTTPAPI_COMPACT_21_060: [ If the optionName is NULL, the HTTPAPI_SetOption shall return HTTPAPI_INVALID_ARG. ]*/\n        /*Codes_SRS_HTTPAPI_COMPACT_21_061: [ If the value is NULL, the HTTPAPI_SetOption shall return HTTPAPI_INVALID_ARG. ]*/\n        result = HTTPAPI_INVALID_ARG;\n    }\n    else if (strcmp(OPTION_TRUSTED_CERT, optionName) == 0)\n    {\n#ifdef DO_NOT_COPY_TRUSTED_CERTS_STRING\n        result = HTTPAPI_OK;\n        http_instance->certificate = (char*)value;\n#else\n\n        if (http_instance->certificate)\n        {\n            free(http_instance->certificate);\n        }\n\n        size_t len = strlen((char*)value);\n        size_t malloc_size = safe_add_size_t(len, 1);\n        malloc_size = safe_multiply_size_t(malloc_size, sizeof(char));\n        if (malloc_size == SIZE_MAX)\n        {\n            LogError(\"Invalid malloc size\");\n            http_instance->certificate = NULL;\n        }\n        else\n        {\n            http_instance->certificate = (char*)malloc(malloc_size);\n        }\n\n        if (http_instance->certificate == NULL)\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_062: [ If any memory allocation get fail, the HTTPAPI_SetOption shall return HTTPAPI_ALLOC_FAILED. ]*/\n            result = HTTPAPI_ALLOC_FAILED;\n            LogInfo(\"unable to allocate memory for the certificate in HTTPAPI_SetOption\");\n        }\n        else\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_064: [ If the HTTPAPI_SetOption get success setting the option, it shall return HTTPAPI_OK. ]*/\n            (void)strcpy(http_instance->certificate, (const char*)value);\n            result = HTTPAPI_OK;\n        }\n#endif // DO_NOT_COPY_TRUSTED_CERTS_STRING\n    }\n    else if (strcmp(SU_OPTION_X509_CERT, optionName) == 0 || strcmp(OPTION_X509_ECC_CERT, optionName) == 0)\n    {\n        if (http_instance->x509ClientCertificate)\n        {\n            free(http_instance->x509ClientCertificate);\n        }\n\n        size_t len = strlen((char*)value);\n        size_t malloc_size = safe_add_size_t(len, 1);\n        malloc_size = safe_multiply_size_t(malloc_size, sizeof(char));\n        if (malloc_size == SIZE_MAX)\n        {\n            LogError(\"Invalid malloc size\");\n            http_instance->x509ClientCertificate = NULL;\n        }\n        else\n        {\n            http_instance->x509ClientCertificate = (char*)malloc(malloc_size);\n        }\n\n        if (http_instance->x509ClientCertificate == NULL)\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_062: [ If any memory allocation get fail, the HTTPAPI_SetOption shall return HTTPAPI_ALLOC_FAILED. ]*/\n            result = HTTPAPI_ALLOC_FAILED;\n            LogInfo(\"unable to allocate memory for the client certificate in HTTPAPI_SetOption\");\n        }\n        else\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_064: [ If the HTTPAPI_SetOption get success setting the option, it shall return HTTPAPI_OK. ]*/\n            (void)strcpy(http_instance->x509ClientCertificate, (const char*)value);\n            result = HTTPAPI_OK;\n        }\n    }\n    else if (strcmp(SU_OPTION_X509_PRIVATE_KEY, optionName) == 0 || strcmp(OPTION_X509_ECC_KEY, optionName) == 0)\n    {\n        if (http_instance->x509ClientPrivateKey)\n        {\n            free(http_instance->x509ClientPrivateKey);\n        }\n\n        size_t len = strlen((char*)value);\n        size_t malloc_size = safe_add_size_t(len, 1);\n        malloc_size = safe_multiply_size_t(malloc_size, sizeof(char));\n        if (malloc_size == SIZE_MAX)\n        {\n            LogError(\"Invalid malloc size\");\n            http_instance->x509ClientPrivateKey = NULL;\n        }\n        else\n        {\n            http_instance->x509ClientPrivateKey = (char*)malloc(malloc_size);\n        }\n\n        if (http_instance->x509ClientPrivateKey == NULL)\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_062: [ If any memory allocation get fail, the HTTPAPI_SetOption shall return HTTPAPI_ALLOC_FAILED. ]*/\n            result = HTTPAPI_ALLOC_FAILED;\n            LogInfo(\"unable to allocate memory for the client private key in HTTPAPI_SetOption\");\n        }\n        else\n        {\n            /*Codes_SRS_HTTPAPI_COMPACT_21_064: [ If the HTTPAPI_SetOption get success setting the option, it shall return HTTPAPI_OK. ]*/\n            (void)strcpy(http_instance->x509ClientPrivateKey, (const char*)value);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "flatpak_proxy_client_init (FlatpakProxyClient *client)\n{\n  init_side (client, &client->client_side);\n  init_side (client, &client->bus_side);\n\n  client->auth_end_offset = AUTH_END_INIT_OFFSET;\n  client->rewrite_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);\n  client->get_owner_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);\n  client->unique_id_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "flatpak_proxy_client_init (FlatpakProxyClient *client)\n{\n  init_side (client, &client->client_side);\n  init_side (client, &client->bus_side);\n\n  client->auth_buffer = g_byte_array_new ();\n  client->rewrite_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);\n  client->get_owner_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);\n  client->unique_id_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    // http-parser should filter for this\n    // (https://tools.ietf.org/html/rfc7230#section-3.2.6), but it doesn't today. HeaderStrings\n    // have an invariant that they must not contain embedded zero characters\n    // (NUL, ASCII 0x0).\n    throw CodecProtocolException(\"http/1.1 protocol error: header value contains NUL\");\n  }\n\n  header_parsing_state_ = HeaderParsingState::Value;\n  current_header_value_.append(data, length);\n\n  const uint32_t total =\n      current_header_field_.size() + current_header_value_.size() + current_header_map_->byteSize();\n  if (total > (max_request_headers_kb_ * 1024)) {\n    error_code_ = Http::Code::RequestHeaderFieldsTooLarge;\n    sendProtocolError();\n    throw CodecProtocolException(\"headers size exceeds limit\");\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    // http-parser should filter for this\n    // (https://tools.ietf.org/html/rfc7230#section-3.2.6), but it doesn't today. HeaderStrings\n    // have an invariant that they must not contain embedded zero characters\n    // (NUL, ASCII 0x0).\n    throw CodecProtocolException(\"http/1.1 protocol error: header value contains NUL\");\n  }\n\n  header_parsing_state_ = HeaderParsingState::Value;\n  current_header_value_.append(data, length);\n\n  // Verify that the cached value in byte size exists.\n  ASSERT(current_header_map_->byteSize().has_value());\n  const uint32_t total = current_header_field_.size() + current_header_value_.size() +\n                         current_header_map_->byteSize().value();\n  if (total > (max_request_headers_kb_ * 1024)) {\n    error_code_ = Http::Code::RequestHeaderFieldsTooLarge;\n    sendProtocolError();\n    throw CodecProtocolException(\"headers size exceeds limit\");\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "GF_Err gf_isom_get_text_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex, GF_TextSampleDescriptor **out_desc)\n{\n\tGF_TrackBox *trak;\n\tu32 i;\n\tBool is_qt_text = GF_FALSE;\n\tGF_Tx3gSampleEntryBox *txt;\n\n\tif (!descriptionIndex || !out_desc) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, descriptionIndex - 1);\n\tif (!txt) return GF_BAD_PARAM;\n\tswitch (txt->type) {\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tis_qt_text = GF_TRUE;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t(*out_desc) = (GF_TextSampleDescriptor *) gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\tif (! (*out_desc) ) return GF_OUT_OF_MEM;\n\t(*out_desc)->back_color = txt->back_color;\n\t(*out_desc)->default_pos = txt->default_box;\n\t(*out_desc)->default_style = txt->default_style;\n\t(*out_desc)->displayFlags = txt->displayFlags;\n\t(*out_desc)->vert_justif = txt->vertical_justification;\n\t(*out_desc)->horiz_justif = txt->horizontal_justification;\n\tif (is_qt_text) {\n\t\tGF_TextSampleEntryBox *qt_txt = (GF_TextSampleEntryBox *) txt;\n\t\tif (qt_txt->textName) {\n\t\t\t(*out_desc)->font_count = 1;\n\t\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord));\n\t\t\t(*out_desc)->fonts[0].fontName = gf_strdup(qt_txt->textName);\n\t\t}\n\t} else {\n\t\t(*out_desc)->font_count = txt->font_table->entry_count;\n\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * txt->font_table->entry_count);\n\t\tfor (i=0; i<txt->font_table->entry_count; i++) {\n\t\t\t(*out_desc)->fonts[i].fontID = txt->font_table->fonts[i].fontID;\n\t\t\tif (txt->font_table->fonts[i].fontName)\n\t\t\t\t(*out_desc)->fonts[i].fontName = gf_strdup(txt->font_table->fonts[i].fontName);\n\t\t}\n\t}\n\treturn GF_OK;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "GF_Err gf_isom_get_text_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex, GF_TextSampleDescriptor **out_desc)\n{\n\tGF_TrackBox *trak;\n\tu32 i;\n\tGF_Tx3gSampleEntryBox *txt = NULL;\n\tGF_TextSampleEntryBox *qt_txt = NULL;\n\tif (!descriptionIndex || !out_desc) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tswitch (trak->Media->handler->handlerType) {\n\tcase GF_ISOM_MEDIA_TEXT:\n\tcase GF_ISOM_MEDIA_SUBT:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\ttxt = (GF_Tx3gSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, descriptionIndex - 1);\n\tif (!txt) return GF_BAD_PARAM;\n\tswitch (txt->type) {\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tqt_txt = (GF_TextSampleEntryBox *)txt;\n\t\ttxt = NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t(*out_desc) = (GF_TextSampleDescriptor *) gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\tif (! (*out_desc) ) return GF_OUT_OF_MEM;\n\n\tif (qt_txt) {\n\t\t(*out_desc)->back_color = rgb_48_to_32(qt_txt->background_color);\n\t\t(*out_desc)->default_pos = qt_txt->default_box;\n\t\t(*out_desc)->default_style.style_flags = qt_txt->fontFace;\n\t\t(*out_desc)->default_style.text_color = rgb_48_to_32(qt_txt->foreground_color);\n\t\t(*out_desc)->displayFlags = qt_txt->displayFlags;\n\t\t(*out_desc)->vert_justif = -1;\n\t\t(*out_desc)->horiz_justif = qt_txt->textJustification;\n\t\tif (qt_txt->textName) {\n\t\t\t(*out_desc)->font_count = 1;\n\t\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord));\n\t\t\t(*out_desc)->fonts[0].fontName = gf_strdup(qt_txt->textName);\n\t\t}\n\t} else {\n\t\t(*out_desc)->back_color = txt->back_color;\n\t\t(*out_desc)->default_pos = txt->default_box;\n\t\t(*out_desc)->default_style = txt->default_style;\n\t\t(*out_desc)->displayFlags = txt->displayFlags;\n\t\t(*out_desc)->vert_justif = txt->vertical_justification;\n\t\t(*out_desc)->horiz_justif = txt->horizontal_justification;\n\t\t(*out_desc)->font_count = txt->font_table->entry_count;\n\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * txt->font_table->entry_count);\n\t\tfor (i=0; i<txt->font_table->entry_count; i++) {\n\t\t\t(*out_desc)->fonts[i].fontID = txt->font_table->fonts[i].fontID;\n\t\t\tif (txt->font_table->fonts[i].fontName)\n\t\t\t\t(*out_desc)->fonts[i].fontName = gf_strdup(txt->font_table->fonts[i].fontName);\n\t\t}\n\t}\n\treturn GF_OK;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    memset(ticket_reply.enc_part.ciphertext.data, 0,\n           ticket_reply.enc_part.ciphertext.length);\n    free(ticket_reply.enc_part.ciphertext.data);\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(reply.enc_part.ciphertext.data, 0,\n           reply.enc_part.ciphertext.length);\n    free(reply.enc_part.ciphertext.data);\n\ncleanup:\n    assert(status != NULL);\n    if (reply_key)\n        krb5_free_keyblock(kdc_context, reply_key);\n    if (errcode)\n        emsg = krb5_get_error_message (kdc_context, errcode);\n\n    au_state->status = status;\n    if (!errcode)\n        au_state->reply = &reply;\n    kau_tgs_req(kdc_context, errcode ? FALSE : TRUE, au_state);\n    kau_free_kdc_req(au_state);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    memset(ticket_reply.enc_part.ciphertext.data, 0,\n           ticket_reply.enc_part.ciphertext.length);\n    free(ticket_reply.enc_part.ciphertext.data);\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(reply.enc_part.ciphertext.data, 0,\n           reply.enc_part.ciphertext.length);\n    free(reply.enc_part.ciphertext.data);\n\ncleanup:\n    if (status == NULL)\n        status = \"UNKNOWN_REASON\";\n    if (reply_key)\n        krb5_free_keyblock(kdc_context, reply_key);\n    if (errcode)\n        emsg = krb5_get_error_message (kdc_context, errcode);\n\n    au_state->status = status;\n    if (!errcode)\n        au_state->reply = &reply;\n    kau_tgs_req(kdc_context, errcode ? FALSE : TRUE, au_state);\n    kau_free_kdc_req(au_state);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void CNativeControlEmbed::CreateObjectInContext(const std::string& name, JSSmart<CJSContext> context)\n{\n    v8::Isolate* current = CV8Worker::GetCurrent();\n    context->m_internal->m_global->Set(current, name.c_str(), v8::FunctionTemplate::New(current, NSNativeControl::CreateNativeObject));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void CNativeControlEmbed::CreateObjectInContext(const std::string& name, JSSmart<CJSContext> context)\n{\n\tv8::Isolate* current = CV8Worker::GetCurrent();\n\tcontext->m_internal->m_global->Set(current, name.c_str(), v8::FunctionTemplate::New(current, NSNativeControl::CreateNativeObject));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "                    throw std::runtime_error(\"CQL frame uncompressed length is negative: \" + std::to_string(uncomp_len));\n                }\n                buf.remove_prefix(4);\n                auto in = input_buffer.get_linearized_view(fragmented_temporary_buffer::view(buf));\n                auto uncomp = output_buffer.make_fragmented_temporary_buffer(uncomp_len, fragmented_temporary_buffer::default_fragment_size, [&] (bytes_mutable_view out) {\n                    auto ret = LZ4_decompress_safe(reinterpret_cast<const char*>(in.data()), reinterpret_cast<char*>(out.data()),\n                                                   in.size(), out.size());\n                    if (ret < 0) {\n                        throw std::runtime_error(\"CQL frame LZ4 uncompression failure\");\n                    }\n                    return out.size();\n                });\n                on_compression_buffer_use();\n                return uncomp;\n            });\n        } else if (_compression == cql_compression::snappy) {\n            return _buffer_reader.read_exactly(_read_buf, length).then([this] (fragmented_temporary_buffer buf) {\n                auto in = input_buffer.get_linearized_view(fragmented_temporary_buffer::view(buf));\n                size_t uncomp_len;\n                if (snappy_uncompressed_length(reinterpret_cast<const char*>(in.data()), in.size(), &uncomp_len) != SNAPPY_OK) {\n                    throw std::runtime_error(\"CQL frame Snappy uncompressed size is unknown\");",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "                    throw std::runtime_error(\"CQL frame uncompressed length is negative: \" + std::to_string(uncomp_len));\n                }\n                buf.remove_prefix(4);\n                auto in = input_buffer.get_linearized_view(fragmented_temporary_buffer::view(buf));\n                auto uncomp = output_buffer.make_fragmented_temporary_buffer(uncomp_len, fragmented_temporary_buffer::default_fragment_size, [&] (bytes_mutable_view out) {\n                    auto ret = LZ4_decompress_safe(reinterpret_cast<const char*>(in.data()), reinterpret_cast<char*>(out.data()),\n                                                   in.size(), out.size());\n                    if (ret < 0) {\n                        throw std::runtime_error(\"CQL frame LZ4 uncompression failure\");\n                    }\n                    if (ret != out.size()) {\n                        throw std::runtime_error(\"Malformed CQL frame - provided uncompressed size different than real uncompressed size\");\n                    }\n                    return static_cast<size_t>(ret);\n                });\n                on_compression_buffer_use();\n                return uncomp;\n            });\n        } else if (_compression == cql_compression::snappy) {\n            return _buffer_reader.read_exactly(_read_buf, length).then([this] (fragmented_temporary_buffer buf) {\n                auto in = input_buffer.get_linearized_view(fragmented_temporary_buffer::view(buf));\n                size_t uncomp_len;\n                if (snappy_uncompressed_length(reinterpret_cast<const char*>(in.data()), in.size(), &uncomp_len) != SNAPPY_OK) {\n                    throw std::runtime_error(\"CQL frame Snappy uncompressed size is unknown\");",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static mongo_message *mongo_message_create( int len , int id , int responseTo , int op ) {\n    mongo_message *mm = ( mongo_message * )bson_malloc( len );\n\n    if ( !id )\n        id = rand();\n\n    /* native endian (converted on send) */\n    mm->head.len = len;\n    mm->head.id = id;\n    mm->head.responseTo = responseTo;\n    mm->head.op = op;\n\n    return mm;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static mongo_message *mongo_message_create( size_t len , int id , int responseTo , int op ) {\n    mongo_message *mm = ( mongo_message * )bson_malloc( len );\n\n    if ( !id )\n        id = rand();\n\n    /* native endian (converted on send) */\n    mm->head.len = ( int )len;\n    mm->head.id = id;\n    mm->head.responseTo = responseTo;\n    mm->head.op = op;\n\n    return mm;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n\n    /* Collect section files and check for duplicates. */\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \"More than one %s section in keymap file; \"\n                    \"All sections after the first ignored\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    bool ok;\n    XkbFile *files[LAST_KEYMAP_FILE_TYPE + 1] = { NULL };\n    enum xkb_file_type type;\n    struct xkb_context *ctx = keymap->ctx;\n\n    /* Collect section files and check for duplicates. */\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            if (file->file_type == FILE_TYPE_GEOMETRY) {\n                log_vrb(ctx, 1,\n                        \"Geometry sections are not supported; ignoring\\n\");\n            } else {\n                log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                        xkb_file_type_to_string(file->file_type));\n            }\n            continue;\n        }\n\n        if (files[file->file_type]) {\n            log_err(ctx,\n                    \"More than one %s section in keymap file; \"\n                    \"All sections after the first ignored\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\tgoto no_page;\n\t\tentry = pte_to_swp_entry(pte);\n\t\tif (!is_migration_entry(entry))\n\t\t\tgoto no_page;\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tmigration_entry_wait(mm, pmd, address);\n\t\tgoto retry;\n\t}\n\tif ((flags & FOLL_NUMA) && pte_protnone(pte))\n\t\tgoto no_page;\n\tif ((flags & FOLL_WRITE) && !pte_write(pte)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\treturn NULL;\n\t}\n\n\tpage = vm_normal_page(vma, address, pte);\n\tif (!page && pte_devmap(pte) && (flags & FOLL_GET)) {\n\t\t/*\n\t\t * Only return device mapping pages in the FOLL_GET case since\n\t\t * they are only valid while holding the pgmap reference.\n\t\t */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\tgoto no_page;\n\t\tentry = pte_to_swp_entry(pte);\n\t\tif (!is_migration_entry(entry))\n\t\t\tgoto no_page;\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\tmigration_entry_wait(mm, pmd, address);\n\t\tgoto retry;\n\t}\n\tif ((flags & FOLL_NUMA) && pte_protnone(pte))\n\t\tgoto no_page;\n\tif ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\treturn NULL;\n\t}\n\n\tpage = vm_normal_page(vma, address, pte);\n\tif (!page && pte_devmap(pte) && (flags & FOLL_GET)) {\n\t\t/*\n\t\t * Only return device mapping pages in the FOLL_GET case since\n\t\t * they are only valid while holding the pgmap reference.\n\t\t */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void ep2_mul_basic(ep2_t r, const ep2_t p, const bn_t k) {\n\tint i, l;\n\tep2_t t;\n\n\tep2_null(t);\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tep2_new(t);\n\t\tl = bn_bits(k);\n\n\t\tif (bn_get_bit(k, l - 1)) {\n\t\t\tep2_copy(t, p);\n\t\t} else {\n\t\t\tep2_set_infty(t);\n\t\t}\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tep2_dbl(t, t);\n\t\t\tif (bn_get_bit(k, i)) {\n\t\t\t\tep2_add(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\tep2_copy(r, t);\n\t\tep2_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void ep2_mul_basic(ep2_t r, const ep2_t p, const bn_t k) {\n\tsize_t l;\n\tep2_t t;\n\n\tep2_null(t);\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tep2_new(t);\n\t\tl = bn_bits(k);\n\n\t\tif (bn_get_bit(k, l - 1)) {\n\t\t\tep2_copy(t, p);\n\t\t} else {\n\t\t\tep2_set_infty(t);\n\t\t}\n\n\t\tfor (int i = l - 2; i >= 0; i--) {\n\t\t\tep2_dbl(t, t);\n\t\t\tif (bn_get_bit(k, i)) {\n\t\t\t\tep2_add(t, t, p);\n\t\t\t}\n\t\t}\n\n\t\tep2_copy(r, t);\n\t\tep2_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "Ta3AST_FromNode(const node *n, PyCompilerFlags *flags, const char *filename_str,\n               int feature_version, PyArena *arena)\n{\n    mod_ty mod;\n    PyObject *filename;\n    filename = PyUnicode_DecodeFSDefault(filename_str);\n    if (filename == NULL)\n        return NULL;\n    mod = Ta3AST_FromNodeObject(n, flags, filename, feature_version, arena);\n    Py_DECREF(filename);\n    return mod;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "Ta3AST_FromNode(const node *n, PyCompilerFlags *flags, const char *filename_str,\n                int feature_version, PyArena *arena)\n{\n    mod_ty mod;\n    PyObject *filename;\n    filename = PyUnicode_DecodeFSDefault(filename_str);\n    if (filename == NULL)\n        return NULL;\n    mod = Ta3AST_FromNodeObject(n, flags, filename, feature_version, arena);\n    Py_DECREF(filename);\n    return mod;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t}\n\n\tif (!err) {\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;\n\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n\tint signo = 0;\n\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;\n\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t}\n\n\t/* An IHDR box must be present. */\n\tif (!dec->ihdr) {\n\t\tjas_eprintf(\"error: missing IHDR box\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Does the number of components indicated in the IHDR box match\n\t  the value specified in the code stream? */\n\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(uint,\n\t  jas_image_numcmpts(dec->image))) {\n\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t}\n\n\t/* At least one component must be present. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Determine if all components have the same data type. */\n\tsamedtype = true;\n\tdtype = jas_image_cmptdtype(dec->image, 0);\n\tfor (i = 1; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {\n\t\t\tsamedtype = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Is the component data type indicated in the IHDR box consistent\n\t  with the data in the code stream? */\n\tif ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||\n\t  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {\n\n\t/* Is the compression type supported? */\n\tif (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {\n\t\tjas_eprintf(\"error: unsupported compression type\\n\");\n\t\tgoto error;\n\t}\n\n\tif (dec->bpcc) {\n\t\t/* Is the number of components indicated in the BPCC box\n\t\t  consistent with the code stream data? */\n\t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(uint, jas_image_numcmpts(\n\t\t  dec->image))) {\n\t\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t\t}\n\t\t/* Is the component data type information indicated in the BPCC\n\t\t  box consistent with the code stream data? */\n\t\tif (!samedtype) {\n\t\t\tfor (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image));\n\t\t\t  ++i) {\n\t\t\t\tif (jas_image_cmptdtype(dec->image, i) !=\n\t\t\t\t  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {\n\t\t\t\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tjas_eprintf(\"warning: superfluous BPCC box\\n\");\n\t\t}\n\t}\n\t/* If a CMAP box is not present, a PCLR box must not be present. */\n\tif (!dec->cmap && dec->pclr) {\n\t\tjas_eprintf(\"warning: missing CMAP box or superfluous PCLR box\\n\");\n\t\tjp2_box_destroy(dec->pclr);\n\t\tdec->pclr = 0;\n\t}\n\n\t/* Determine the number of channels (which is essentially the number\n\t  of components after any palette mappings have been applied). */\n\tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :\n\t  JAS_CAST(uint, jas_image_numcmpts(dec->image));\n\n\t/* Perform a basic sanity check on the CMAP box if present. */\n\tif (dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the component number reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(uint,\n\t\t\t  jas_image_numcmpts(dec->image))) {\n\t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Is the LUT index reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].pcol >=\n\t\t\t  dec->pclr->data.pclr.numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid CMAP LUT index\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t\t} else {\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Mark all components as being of unknown type. */\n\n\tfor (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n\t}\n\n\t/* Determine the type of each component. */\n\tif (dec->cdef) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the channel number reasonable? */\n\t\t\tif (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid channel number in CDEF box\\n\");\n\t\t\t\tgoto error;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t}\n\n\t/* An IHDR box must be present. */\n\tif (!dec->ihdr) {\n\t\tjas_eprintf(\"error: missing IHDR box\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Does the number of components indicated in the IHDR box match\n\t  the value specified in the code stream? */\n\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(jas_uint,\n\t  jas_image_numcmpts(dec->image))) {\n\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t}\n\n\t/* At least one component must be present. */\n\tif (!jas_image_numcmpts(dec->image)) {\n\t\tjas_eprintf(\"error: no components\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Determine if all components have the same data type. */\n\tsamedtype = true;\n\tdtype = jas_image_cmptdtype(dec->image, 0);\n\tfor (i = 1; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {\n\t\t\tsamedtype = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Is the component data type indicated in the IHDR box consistent\n\t  with the data in the code stream? */\n\tif ((samedtype && dec->ihdr->data.ihdr.bpc != JP2_DTYPETOBPC(dtype)) ||\n\t  (!samedtype && dec->ihdr->data.ihdr.bpc != JP2_IHDR_BPCNULL)) {\n\n\t/* Is the compression type supported? */\n\tif (dec->ihdr->data.ihdr.comptype != JP2_IHDR_COMPTYPE) {\n\t\tjas_eprintf(\"error: unsupported compression type\\n\");\n\t\tgoto error;\n\t}\n\n\tif (dec->bpcc) {\n\t\t/* Is the number of components indicated in the BPCC box\n\t\t  consistent with the code stream data? */\n\t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(jas_uint, jas_image_numcmpts(\n\t\t  dec->image))) {\n\t\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t\t}\n\t\t/* Is the component data type information indicated in the BPCC\n\t\t  box consistent with the code stream data? */\n\t\tif (!samedtype) {\n\t\t\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\t\t\t  ++i) {\n\t\t\t\tif (jas_image_cmptdtype(dec->image, i) !=\n\t\t\t\t  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {\n\t\t\t\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tjas_eprintf(\"warning: superfluous BPCC box\\n\");\n\t\t}\n\t}\n\t/* If a CMAP box is not present, a PCLR box must not be present. */\n\tif (!dec->cmap && dec->pclr) {\n\t\tjas_eprintf(\"warning: missing CMAP box or superfluous PCLR box\\n\");\n\t\tjp2_box_destroy(dec->pclr);\n\t\tdec->pclr = 0;\n\t}\n\n\t/* Determine the number of channels (which is essentially the number\n\t  of components after any palette mappings have been applied). */\n\tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :\n\t  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\n\t/* Perform a basic sanity check on the CMAP box if present. */\n\tif (dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the component number reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(jas_uint,\n\t\t\t  jas_image_numcmpts(dec->image))) {\n\t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t/* Is the LUT index reasonable? */\n\t\t\tif (dec->cmap->data.cmap.ents[i].pcol >=\n\t\t\t  dec->pclr->data.pclr.numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid CMAP LUT index\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t\t} else {\n\t\t\t\tjas_image_setcmpttype(dec->image, newcmptno, jp2_getct(jas_image_clrspc(dec->image), 0, channo + 1));\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Mark all components as being of unknown type. */\n\n\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n\t}\n\n\t/* Determine the type of each component. */\n\tif (dec->cdef) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t/* Is the channel number reasonable? */\n\t\t\tif (dec->cdef->data.cdef.ents[i].channo >= dec->numchans) {\n\t\t\t\tjas_eprintf(\"error: invalid channel number in CDEF box\\n\");\n\t\t\t\tgoto error;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void Huff_offsetReceive (node_t *node, int *ch, byte *fin, int *offset) {\n\tbloc = *offset;\n\twhile (node && node->symbol == INTERNAL_NODE) {\n\t\tif (get_bit(fin)) {\n\t\t\tnode = node->right;\n\t\t} else {\n\t\t\tnode = node->left;\n\t\t}\n\t}\n\tif (!node) {\n\t\t*ch = 0;\n\t\treturn;\n//\t\tCom_Error(ERR_DROP, \"Illegal tree!\");",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void Huff_offsetReceive (node_t *node, int *ch, byte *fin, int *offset, int maxoffset) {\n\tbloc = *offset;\n\twhile (node && node->symbol == INTERNAL_NODE) {\n\t\tif (bloc >= maxoffset) {\n\t\t\t*ch = 0;\n\t\t\t*offset = maxoffset + 1;\n\t\t\treturn;\n\t\t}\n\t\tif (get_bit(fin)) {\n\t\t\tnode = node->right;\n\t\t} else {\n\t\t\tnode = node->left;\n\t\t}\n\t}\n\tif (!node) {\n\t\t*ch = 0;\n\t\treturn;\n//\t\tCom_Error(ERR_DROP, \"Illegal tree!\");",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    ret = (xmlRefPtr) xmlMalloc(sizeof(xmlRef));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n        return(NULL);\n    }\n\n    /*\n     * fill the structure.\n     */\n    ret->value = xmlStrdup(value);\n    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n\t/*\n\t * Operating in streaming mode, attr is gonna disappear\n\t */\n\tret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->name = NULL;\n\tret->attr = attr;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    ret = (xmlRefPtr) xmlMalloc(sizeof(xmlRef));\n    if (ret == NULL) {\n\txmlVErrMemory(ctxt, \"malloc failed\");\n        return(NULL);\n    }\n\n    /*\n     * fill the structure.\n     */\n    ret->value = xmlStrdup(value);\n    if (xmlIsStreaming(ctxt)) {\n\t/*\n\t * Operating in streaming mode, attr is gonna disappear\n\t */\n\tret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;\n    } else {\n\tret->name = NULL;\n\tret->attr = attr;\n    }\n    ret->lineno = xmlGetLineNo(attr->parent);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void _ltc_ecc_free_public_key(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void _ltc_ecc_free_public_key(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\n\tcrypto_bignum_free(&s->x);\n\tcrypto_bignum_free(&s->y);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint iskew = imagew - tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t\tfor (col = 0; col < imagewidth && colb < imagew; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );\n\t\t\t} else\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0);\n\t\t\tcolb += tilew;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "DECLAREreadFunc(readContigTilesIntoBuffer)\n{\n\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint64 iskew = (int64)imagew - (int64)tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\n\t(void) spp;\n\ttilebuf = _TIFFmalloc(tilesize);\n\tif (tilebuf == 0)\n\t\treturn 0;\n\t_TIFFmemset(tilebuf, 0, tilesize);\n\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n\t\tfor (col = 0; col < imagewidth && colb < imagew; col += tw) {\n\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n\t\t\t    && !ignore) {\n\t\t\t\tTIFFError(TIFFFileName(in),\n\t\t\t\t    \"Error, can't read tile at %lu %lu\",\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb > iskew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );\n\t\t\t} else\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, tilew,\n\t\t\t\t    iskew, 0);\n\t\t\tcolb += tilew;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "{\n\text3_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t/* Default location */\n\toptions += 3;\n\t/*todo: use simple_strtoll with >32bit ext3 */\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\text3_msg(sb, \"error: invalid sb specification: %s\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "{\n\text3_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t/* Default location */\n\toptions += 3;\n\t/*todo: use simple_strtoll with >32bit ext3 */\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\text3_msg(sb, KERN_ERR, \"error: invalid sb specification: %s\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "hostlist_matches_int(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const char *lhost, const char *shost,\n    const struct member_list *list)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(hostlist_matches, SUDOERS_DEBUG_MATCH);\n\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = host_matches(parse_tree, pw, lhost, shost, m);\n\tif (matched != UNSPEC)\n\t    break;\n    }\n    debug_return_int(matched);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "hostlist_matches_int(const struct sudoers_parse_tree *parse_tree,\n    const struct passwd *pw, const char *lhost, const char *shost,\n    const struct member_list *list)\n{\n    struct member *m;\n    int matched = UNSPEC;\n    debug_decl(hostlist_matches, SUDOERS_DEBUG_MATCH);\n\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = host_matches(parse_tree, pw, lhost, shost, m);\n\tif (SPECIFIED(matched))\n\t    break;\n    }\n    debug_return_int(matched);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n\n    FreeStmt((ParseCommon *) &append);\n\n    return expr;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "ExprAppendMultiKeysymList(ExprDef *expr, ExprDef *append)\n{\n    unsigned nSyms = darray_size(expr->keysym_list.syms);\n    unsigned numEntries = darray_size(append->keysym_list.syms);\n\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n\n    FreeStmt((ParseCommon *) append);\n\n    return expr;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n\tclt = kzalloc(sizeof(*clt), GFP_KERNEL);\n\tif (!clt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclt->pcpu_path = alloc_percpu(typeof(*clt->pcpu_path));\n\tif (!clt->pcpu_path) {\n\t\tkfree(clt);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tuuid_gen(&clt->paths_uuid);\n\tINIT_LIST_HEAD_RCU(&clt->paths_list);\n\tclt->paths_num = paths_num;\n\tclt->paths_up = MAX_PATHS_NUM;\n\tclt->port = port;\n\tclt->pdu_sz = pdu_sz;\n\tclt->max_segments = RTRS_MAX_SEGMENTS;\n\tclt->reconnect_delay_sec = reconnect_delay_sec;\n\tclt->max_reconnect_attempts = max_reconnect_attempts;\n\tclt->priv = priv;\n\tclt->link_ev = link_ev;\n\tclt->mp_policy = MP_POLICY_MIN_INFLIGHT;\n\tstrscpy(clt->sessname, sessname, sizeof(clt->sessname));\n\tinit_waitqueue_head(&clt->permits_wait);\n\tmutex_init(&clt->paths_ev_mutex);\n\tmutex_init(&clt->paths_mutex);\n\n\tclt->dev.class = rtrs_clt_dev_class;\n\tclt->dev.release = rtrs_clt_dev_release;\n\terr = dev_set_name(&clt->dev, \"%s\", sessname);\n\tif (err)\n\t\tgoto err;\n\t/*\n\t * Suppress user space notification until\n\t * sysfs files are created\n\t */\n\tdev_set_uevent_suppress(&clt->dev, true);\n\terr = device_register(&clt->dev);\n\tif (err) {\n\t\tput_device(&clt->dev);\n\t\tgoto err;\n\t}\n\n\tclt->kobj_paths = kobject_create_and_add(\"paths\", &clt->dev.kobj);\n\tif (!clt->kobj_paths) {\n\t\terr = -ENOMEM;\n\t\tgoto err_dev;\n\t}\n\terr = rtrs_clt_create_sysfs_root_files(clt);\n\tif (err) {\n\t\tkobject_del(clt->kobj_paths);\n\t\tkobject_put(clt->kobj_paths);\n\t\tgoto err_dev;\n\t}\n\tdev_set_uevent_suppress(&clt->dev, false);\n\tkobject_uevent(&clt->dev.kobj, KOBJ_ADD);\n\n\treturn clt;\nerr_dev:\n\tdevice_unregister(&clt->dev);\nerr:\n\tfree_percpu(clt->pcpu_path);\n\tkfree(clt);\n\treturn ERR_PTR(err);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tclt = kzalloc(sizeof(*clt), GFP_KERNEL);\n\tif (!clt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclt->pcpu_path = alloc_percpu(typeof(*clt->pcpu_path));\n\tif (!clt->pcpu_path) {\n\t\tkfree(clt);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tclt->dev.class = rtrs_clt_dev_class;\n\tclt->dev.release = rtrs_clt_dev_release;\n\tuuid_gen(&clt->paths_uuid);\n\tINIT_LIST_HEAD_RCU(&clt->paths_list);\n\tclt->paths_num = paths_num;\n\tclt->paths_up = MAX_PATHS_NUM;\n\tclt->port = port;\n\tclt->pdu_sz = pdu_sz;\n\tclt->max_segments = RTRS_MAX_SEGMENTS;\n\tclt->reconnect_delay_sec = reconnect_delay_sec;\n\tclt->max_reconnect_attempts = max_reconnect_attempts;\n\tclt->priv = priv;\n\tclt->link_ev = link_ev;\n\tclt->mp_policy = MP_POLICY_MIN_INFLIGHT;\n\tstrscpy(clt->sessname, sessname, sizeof(clt->sessname));\n\tinit_waitqueue_head(&clt->permits_wait);\n\tmutex_init(&clt->paths_ev_mutex);\n\tmutex_init(&clt->paths_mutex);\n\tdevice_initialize(&clt->dev);\n\n\terr = dev_set_name(&clt->dev, \"%s\", sessname);\n\tif (err)\n\t\tgoto err_put;\n\n\t/*\n\t * Suppress user space notification until\n\t * sysfs files are created\n\t */\n\tdev_set_uevent_suppress(&clt->dev, true);\n\terr = device_add(&clt->dev);\n\tif (err)\n\t\tgoto err_put;\n\n\tclt->kobj_paths = kobject_create_and_add(\"paths\", &clt->dev.kobj);\n\tif (!clt->kobj_paths) {\n\t\terr = -ENOMEM;\n\t\tgoto err_del;\n\t}\n\terr = rtrs_clt_create_sysfs_root_files(clt);\n\tif (err) {\n\t\tkobject_del(clt->kobj_paths);\n\t\tkobject_put(clt->kobj_paths);\n\t\tgoto err_del;\n\t}\n\tdev_set_uevent_suppress(&clt->dev, false);\n\tkobject_uevent(&clt->dev.kobj, KOBJ_ADD);\n\n\treturn clt;\nerr_del:\n\tdevice_del(&clt->dev);\nerr_put:\n\tfree_percpu(clt->pcpu_path);\n\tput_device(&clt->dev);\n\treturn ERR_PTR(err);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\t\t\t      u32 result)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_FW_DOWNLOAD);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_string(msg, NFC_ATTR_FIRMWARE_NAME, firmware_name) ||\n\t    nla_put_u32(msg, NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS, result) ||\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int nfc_genl_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n\t\t\t      u32 result)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_FW_DOWNLOAD);\n\tif (!hdr)\n\t\tgoto free_msg;\n\n\tif (nla_put_string(msg, NFC_ATTR_FIRMWARE_NAME, firmware_name) ||\n\t    nla_put_u32(msg, NFC_ATTR_FIRMWARE_DOWNLOAD_STATUS, result) ||\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:\n\tnlmsg_free(msg);\n\treturn -EMSGSIZE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tdisconnect = !IS_MNT_LOCKED_AND_LAZY(p);\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\t/* Don't forget about p */\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tdisconnect = !(((how & UMOUNT_CONNECTED) &&\n\t\t\t\tmnt_has_parent(p) &&\n\t\t\t\t(p->mnt_parent->mnt.mnt_flags & MNT_UMOUNT)) ||\n\t\t\t       IS_MNT_LOCKED_AND_LAZY(p));\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\t/* Don't forget about p */\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "{\n    char        *p;\n    size_t      length;\n    njs_bool_t  trail;\n    char        src[NJS_MAX_PATH + 1];\n\n    trail = 0;\n    length = info->name.length;\n\n    if (dir != NULL) {\n        length = dir->length;\n\n        if (length == 0) {\n            return NJS_DECLINED;\n        }\n\n        trail = (dir->start[dir->length - 1] != '/');\n\n        if (trail) {\n            length++;\n        }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "{\n    char        *p;\n    size_t      length;\n    njs_bool_t  trail;\n    char        src[NJS_MAX_PATH + 1];\n\n    trail = 0;\n    length = info->name.length;\n\n    if (dir != NULL) {\n        length += dir->length;\n\n        if (length == 0) {\n            return NJS_DECLINED;\n        }\n\n        trail = (dir->start[dir->length - 1] != '/');\n\n        if (trail) {\n            length++;\n        }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "l2tp_proxy_auth_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_authentype2str,\n\t\t\t     \"AuthType-#%u\", EXTRACT_16BITS(ptr))));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "l2tp_proxy_auth_type_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tif (length < 2) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_authentype2str,\n\t\t\t     \"AuthType-#%u\", EXTRACT_16BITS(ptr))));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void labeljumps(JF, js_JumpList *jump, int baddr, int caddr)\n{\n\twhile (jump) {\n\t\tif (jump->type == STM_BREAK)\n\t\t\tlabelto(J, F, jump->inst, baddr);\n\t\tif (jump->type == STM_CONTINUE)\n\t\t\tlabelto(J, F, jump->inst, caddr);\n\t\tjump = jump->next;\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void labeljumps(JF, js_Ast *stm, int baddr, int caddr)\n{\n\tjs_JumpList *jump = stm->jumps;\n\twhile (jump) {\n\t\tjs_JumpList *next = jump->next;\n\t\tif (jump->type == STM_BREAK)\n\t\t\tlabelto(J, F, jump->inst, baddr);\n\t\tif (jump->type == STM_CONTINUE)\n\t\t\tlabelto(J, F, jump->inst, caddr);\n\t\tjs_free(J, jump);\n\t\tjump = next;\n\t}\n\tstm->jumps = NULL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static inline void xen_evtchn_handle_events(unsigned cpu)\n{\n\treturn evtchn_ops->handle_events(cpu);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static inline void xen_evtchn_handle_events(unsigned cpu,\n\t\t\t\t\t    struct evtchn_loop_ctrl *ctrl)\n{\n\treturn evtchn_ops->handle_events(cpu, ctrl);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "                dt_offsets[n_off] = get_te64(&dynp0[-1+ dt_table[k]].d_val);\n            }\n        }\n        else {\n            if (file_image) { // why is this guard necessary?\n                dt_offsets[n_off] = elf_unsigned_dynamic(k);  // zero if not found\n            }\n        }\n        if (file_size <= dt_offsets[n_off]) {\n            char msg[60]; snprintf(msg, sizeof(msg), \"bad DT_{%#x} = %#x (beyond EOF)\",\n                dt_names[k], dt_offsets[n_off]);\n                throwCantPack(msg);\n        }\n        n_off += !!dt_offsets[n_off];\n    }\n    dt_offsets[n_off++] = file_size;  // sentinel\n    qsort(dt_offsets, n_off, sizeof(dt_offsets[0]), qcmp_unsigned);\n\n    unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n    if (v_hsh && file_image) {\n        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "                dt_offsets[n_off] = get_te64(&dynp0[-1+ dt_table[k]].d_val);\n            }\n        }\n        else {\n            if (file_image) { // why is this guard necessary?\n                dt_offsets[n_off] = elf_unsigned_dynamic(k);  // zero if not found\n            }\n        }\n        if (file_size <= dt_offsets[n_off]) {\n            char msg[60]; snprintf(msg, sizeof(msg), \"bad DT_{%#x} = %#x (beyond EOF)\",\n                k, dt_offsets[n_off]);\n                throwCantPack(msg);\n        }\n        n_off += !!dt_offsets[n_off];\n    }\n    dt_offsets[n_off++] = file_size;  // sentinel\n    qsort(dt_offsets, n_off, sizeof(dt_offsets[0]), qcmp_unsigned);\n\n    unsigned const v_hsh = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n    if (v_hsh && file_image) {\n        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static INLINE UINT16 ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair)\n{\n\tUINT16 AvId;\n\n\tData_Read_UINT16(&pAvPair->AvId, AvId);\n\n\treturn AvId;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static INLINE BOOL ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair, size_t size, UINT16* pair)\n{\n\tUINT16 AvId;\n\tif (!pAvPair || !pair)\n\t\treturn FALSE;\n\n\tif (size < sizeof(NTLM_AV_PAIR))\n\t\treturn FALSE;\n\n\tData_Read_UINT16(&pAvPair->AvId, AvId);\n\n\t*pair = AvId;\n\treturn TRUE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t   struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sk_buff\t\t*skb;\n\tstruct sock\t\t*sk = sock->sk;\n\tstruct sockaddr_mISDN\t*maddr;\n\n\tint\t\tcopied, err;\n\n\tif (*debug & DEBUG_SOCKET)\n\t\tprintk(KERN_DEBUG \"%s: len %d, flags %x ch.nr %d, proto %x\\n\",\n\t\t       __func__, (int)len, flags, _pms(sk)->ch.nr,\n\t\t       sk->sk_protocol);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tif (sk->sk_state == MISDN_CLOSED)\n\t\treturn 0;\n\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tif (msg->msg_namelen >= sizeof(struct sockaddr_mISDN)) {\n\t\tmsg->msg_namelen = sizeof(struct sockaddr_mISDN);\n\t\tmaddr = (struct sockaddr_mISDN *)msg->msg_name;\n\t\tmaddr->family = AF_ISDN;\n\t\tmaddr->dev = _pms(sk)->dev->id;\n\t\tif ((sk->sk_protocol == ISDN_P_LAPD_TE) ||\n\t\t    (sk->sk_protocol == ISDN_P_LAPD_NT)) {\n\t\t\tmaddr->channel = (mISDN_HEAD_ID(skb) >> 16) & 0xff;\n\t\t\tmaddr->tei =  (mISDN_HEAD_ID(skb) >> 8) & 0xff;\n\t\t\tmaddr->sapi = mISDN_HEAD_ID(skb) & 0xff;\n\t\t} else {\n\t\t\tmaddr->channel = _pms(sk)->ch.nr;\n\t\t\tmaddr->sapi = _pms(sk)->ch.addr & 0xFF;\n\t\t\tmaddr->tei =  (_pms(sk)->ch.addr >> 8) & 0xFF;\n\t\t}\n\t} else {\n\t\tif (msg->msg_namelen)\n\t\t\tprintk(KERN_WARNING \"%s: too small namelen %d\\n\",\n\t\t\t       __func__, msg->msg_namelen);\n\t\tmsg->msg_namelen = 0;\n\t}\n\n\tcopied = skb->len + MISDN_HEADER_LEN;\n\tif (len < copied) {\n\t\tif (flags & MSG_PEEK)\n\t\t\tatomic_dec(&skb->users);\n\t\telse\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\treturn -ENOSPC;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t   struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sk_buff\t\t*skb;\n\tstruct sock\t\t*sk = sock->sk;\n\n\tint\t\tcopied, err;\n\n\tif (*debug & DEBUG_SOCKET)\n\t\tprintk(KERN_DEBUG \"%s: len %d, flags %x ch.nr %d, proto %x\\n\",\n\t\t       __func__, (int)len, flags, _pms(sk)->ch.nr,\n\t\t       sk->sk_protocol);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\n\tif (sk->sk_state == MISDN_CLOSED)\n\t\treturn 0;\n\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_mISDN *maddr = msg->msg_name;\n\n\t\tmaddr->family = AF_ISDN;\n\t\tmaddr->dev = _pms(sk)->dev->id;\n\t\tif ((sk->sk_protocol == ISDN_P_LAPD_TE) ||\n\t\t    (sk->sk_protocol == ISDN_P_LAPD_NT)) {\n\t\t\tmaddr->channel = (mISDN_HEAD_ID(skb) >> 16) & 0xff;\n\t\t\tmaddr->tei =  (mISDN_HEAD_ID(skb) >> 8) & 0xff;\n\t\t\tmaddr->sapi = mISDN_HEAD_ID(skb) & 0xff;\n\t\t} else {\n\t\t\tmaddr->channel = _pms(sk)->ch.nr;\n\t\t\tmaddr->sapi = _pms(sk)->ch.addr & 0xFF;\n\t\t\tmaddr->tei =  (_pms(sk)->ch.addr >> 8) & 0xFF;\n\t\t}\n\t\tmsg->msg_namelen = sizeof(*maddr);\n\t}\n\n\tcopied = skb->len + MISDN_HEADER_LEN;\n\tif (len < copied) {\n\t\tif (flags & MSG_PEEK)\n\t\t\tatomic_dec(&skb->users);\n\t\telse\n\t\t\tskb_queue_head(&sk->sk_receive_queue, skb);\n\t\treturn -ENOSPC;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "        spb = (s->samples / (spf * sz)) * spf;\n\n        fin = ff_get_audio_buffer(inlink, spf);\n        if (!fin)\n            return AVERROR(ENOMEM);\n\n        while (x < sz) {\n            int acc_samples = 0;\n            int dst_offset = 0;\n\n            while (nb_frame <= s->nb_frames) {\n                AVFrame *cur_frame = s->frames[nb_frame];\n                int cur_frame_samples = cur_frame->nb_samples;\n                int nb_samples = 0;\n\n                if (acc_samples < spf) {\n                    nb_samples = FFMIN(spf - acc_samples, cur_frame_samples - src_offset);\n                    acc_samples += nb_samples;\n                    av_samples_copy(fin->extended_data, cur_frame->extended_data,\n                                    dst_offset, src_offset, nb_samples,\n                                    cur_frame->ch_layout.nb_channels, AV_SAMPLE_FMT_FLTP);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "        spb = (s->samples / (spf * sz)) * spf;\n\n        fin = ff_get_audio_buffer(inlink, spf);\n        if (!fin)\n            return AVERROR(ENOMEM);\n\n        while (x < sz) {\n            int acc_samples = 0;\n            int dst_offset = 0;\n\n            while (nb_frame < s->nb_frames) {\n                AVFrame *cur_frame = s->frames[nb_frame];\n                int cur_frame_samples = cur_frame->nb_samples;\n                int nb_samples = 0;\n\n                if (acc_samples < spf) {\n                    nb_samples = FFMIN(spf - acc_samples, cur_frame_samples - src_offset);\n                    acc_samples += nb_samples;\n                    av_samples_copy(fin->extended_data, cur_frame->extended_data,\n                                    dst_offset, src_offset, nb_samples,\n                                    cur_frame->ch_layout.nb_channels, AV_SAMPLE_FMT_FLTP);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t  int fromlen, unsigned char *to, int tolen)\n{\n\tstruct pathComponent *pc;\n\tint elen = 0;\n\tint comp_len;\n\tunsigned char *p = to;\n\n\t/* Reserve one byte for terminating \\0 */\n\ttolen--;\n\twhile (elen < fromlen) {\n\t\tpc = (struct pathComponent *)(from + elen);\n\t\tswitch (pc->componentType) {\n\t\tcase 1:\n\t\t\t/*\n\t\t\t * Symlink points to some place which should be agreed\n \t\t\t * upon between originator and receiver of the media. Ignore.\n\t\t\t */\n\t\t\tif (pc->lengthComponentIdent > 0)\n\t\t\t\tbreak;\n\t\t\t/* Fall through */\n\t\tcase 2:\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tp = to;\n\t\t\t*p++ = '/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (tolen < 3)\n\t\t\ttolen -= 3;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (tolen < 2)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"./\", 2);\n\t\t\tp += 2;\n\t\t\ttolen -= 2;\n\t\t\t/* that would be . - just ignore */\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n\t\t\t\t\t\t    pc->lengthComponentIdent,\n\t\t\t\t\t\t    p, tolen);\n\t\t\tp += comp_len;\n\t\t\ttolen -= comp_len;\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\t*p++ = '/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\t}\n\t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n\t}\n\tif (p > to + 1)\n\t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "{\n\tstruct pathComponent *pc;\n\tint elen = 0;\n\tint comp_len;\n\tunsigned char *p = to;\n\n\t/* Reserve one byte for terminating \\0 */\n\ttolen--;\n\twhile (elen < fromlen) {\n\t\tpc = (struct pathComponent *)(from + elen);\n\t\telen += sizeof(struct pathComponent);\n\t\tswitch (pc->componentType) {\n\t\tcase 1:\n\t\t\t/*\n\t\t\t * Symlink points to some place which should be agreed\n \t\t\t * upon between originator and receiver of the media. Ignore.\n\t\t\t */\n\t\t\tif (pc->lengthComponentIdent > 0) {\n\t\t\t\telen += pc->lengthComponentIdent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Fall through */\n\t\tcase 2:\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tp = to;\n\t\t\t*p++ = '/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (tolen < 3)\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (tolen < 2)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tmemcpy(p, \"./\", 2);\n\t\t\tp += 2;\n\t\t\ttolen -= 2;\n\t\t\t/* that would be . - just ignore */\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\telen += pc->lengthComponentIdent;\n\t\t\tif (elen > fromlen)\n\t\t\t\treturn -EIO;\n\t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n\t\t\t\t\t\t    pc->lengthComponentIdent,\n\t\t\t\t\t\t    p, tolen);\n\t\t\tp += comp_len;\n\t\t\ttolen -= comp_len;\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\t*p++ = '/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (p > to + 1)\n\t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n  }\n  *eventPP = s;\n\n  for (;;) {\n    const char *next = s; /* XmlContentTok doesn't always set the last arg */\n    int tok = XmlContentTok(enc, s, end, &next);\n#ifdef XML_DTD\n    const char *accountAfter\n        = ((tok == XML_TOK_TRAILING_RSQB) || (tok == XML_TOK_TRAILING_CR))\n              ? (haveMore ? s /* i.e. 0 bytes */ : end)\n              : next;\n    if (! accountingDiffTolerated(parser, tok, s, accountAfter, __LINE__,\n                                  account)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_ENTITY_REF: {\n      const XML_Char *name;\n      ENTITY *entity;\n      XML_Char ch = (XML_Char)XmlPredefinedEntityName(\n          enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);\n      if (ch) {\n#ifdef XML_DTD\n        /* NOTE: We are replacing 4-6 characters original input for 1 character\n         *       so there is no amplification and hence recording without\n         *       protection. */\n        accountingDiffTolerated(parser, tok, (char *)&ch,\n                                ((char *)&ch) + sizeof(XML_Char), __LINE__,\n                                XML_ACCOUNT_ENTITY_EXPANSION);\n#endif /* XML_DTD */\n        if (parser->m_characterDataHandler)\n          parser->m_characterDataHandler(parser->m_handlerArg, &ch, 1);\n        else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        break;\n      }\n      name = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,\n                             next - enc->minBytesPerChar);\n      if (! name)\n        return XML_ERROR_NO_MEMORY;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n  }\n  *eventPP = s;\n\n  for (;;) {\n    const char *next = s; /* XmlContentTok doesn't always set the last arg */\n    int tok = XmlContentTok(enc, s, end, &next);\n#if defined(XML_DTD) || XML_GE == 1\n    const char *accountAfter\n        = ((tok == XML_TOK_TRAILING_RSQB) || (tok == XML_TOK_TRAILING_CR))\n              ? (haveMore ? s /* i.e. 0 bytes */ : end)\n              : next;\n    if (! accountingDiffTolerated(parser, tok, s, accountAfter, __LINE__,\n                                  account)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_ENTITY_REF: {\n      const XML_Char *name;\n      ENTITY *entity;\n      XML_Char ch = (XML_Char)XmlPredefinedEntityName(\n          enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);\n      if (ch) {\n#if defined(XML_DTD) || XML_GE == 1\n        /* NOTE: We are replacing 4-6 characters original input for 1 character\n         *       so there is no amplification and hence recording without\n         *       protection. */\n        accountingDiffTolerated(parser, tok, (char *)&ch,\n                                ((char *)&ch) + sizeof(XML_Char), __LINE__,\n                                XML_ACCOUNT_ENTITY_EXPANSION);\n#endif /* defined(XML_DTD) || XML_GE == 1 */\n        if (parser->m_characterDataHandler)\n          parser->m_characterDataHandler(parser->m_handlerArg, &ch, 1);\n        else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        break;\n      }\n      name = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,\n                             next - enc->minBytesPerChar);\n      if (! name)\n        return XML_ERROR_NO_MEMORY;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t * one. According to mount(2) manpage, MS_BIND honors MS_RDONLY from\n\t\t * kernel 2.6.26 onwards. However, this apparently does not work on\n\t\t * kernel 3.8. Unfortunately, on that very same kernel, doing the\n\t\t * same trick as above doesn't seem to work either, there one needs\n\t\t * to ALSO specify MS_BIND for the remount, otherwise the entire\n\t\t * fs is remounted read-only or the mount fails because it's busy...\n\t\t * MS_REMOUNT|MS_BIND|MS_RDONLY seems to work for kernels as low as\n\t\t * 2.6.32...\n\t\t */\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/net\",                  NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys\",                                       \"%r/proc/sys\",                  NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sys\",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/net\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sysrq-trigger\",                             \"%r/proc/sysrq-trigger\",        NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sysrq-trigger\",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RW,     \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    0,                              NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RO,     \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    MS_RDONLY,                      NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"%r/sys\",                                            \"%r/sys\",                       NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                \"%r/sys\",                       NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"sysfs\",                                             \"%r/sys/devices/virtual/net\",   \"sysfs\",    0,                              NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"%r/sys/devices/virtual/net/devices/virtual/net\",    \"%r/sys/devices/virtual/net\",   NULL,       MS_BIND,                        NULL },\n\t\t\t\tif (!destination) {\n\t\t\t\t\tsaved_errno = errno;\n\t\t\t\t\tSYSERROR(\"memory allocation error\");\n\t\t\t\t\tfree(source);\n\t\t\t\t\terrno = saved_errno;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmflags = add_required_remount_flags(source, destination,\n\t\t\t\t\tdefault_mounts[i].flags);\n\t\t\tr = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);\n\t\t\tsaved_errno = errno;\n\t\t\tif (r < 0 && errno == ENOENT) {\n\t\t\t\tINFO(\"Mount source or target for %s on %s doesn't exist. Skipping.\", source, destination);\n\t\t\t\tr = 0;\n\t\t\t}\n\t\t\telse if (r < 0)\n\t\t\t\tSYSERROR(\"error mounting %s on %s flags %lu\", source, destination, mflags);\n\n\t\t\tfree(source);\n\t\t\tfree(destination);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t * one. According to mount(2) manpage, MS_BIND honors MS_RDONLY from\n\t\t * kernel 2.6.26 onwards. However, this apparently does not work on\n\t\t * kernel 3.8. Unfortunately, on that very same kernel, doing the\n\t\t * same trick as above doesn't seem to work either, there one needs\n\t\t * to ALSO specify MS_BIND for the remount, otherwise the entire\n\t\t * fs is remounted read-only or the mount fails because it's busy...\n\t\t * MS_REMOUNT|MS_BIND|MS_RDONLY seems to work for kernels as low as\n\t\t * 2.6.32...\n\t\t */\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/tty\",                  NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys\",                                       \"%r/proc/sys\",                  NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sys\",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/tty\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sysrq-trigger\",                             \"%r/proc/sysrq-trigger\",        NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sysrq-trigger\",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RW,     \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    0,                              NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RO,     \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    MS_RDONLY,                      NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"%r/sys\",                                            \"%r/sys\",                       NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                \"%r/sys\",                       NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"sysfs\",                                             \"%r/sys/devices/virtual/net\",   \"sysfs\",    0,                              NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"%r/sys/devices/virtual/net/devices/virtual/net\",    \"%r/sys/devices/virtual/net\",   NULL,       MS_BIND,                        NULL },\n\t\t\t\tif (!destination) {\n\t\t\t\t\tsaved_errno = errno;\n\t\t\t\t\tSYSERROR(\"memory allocation error\");\n\t\t\t\t\tfree(source);\n\t\t\t\t\terrno = saved_errno;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmflags = add_required_remount_flags(source, destination,\n\t\t\t\t\tdefault_mounts[i].flags);\n\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n\t\t\tsaved_errno = errno;\n\t\t\tif (r < 0 && errno == ENOENT) {\n\t\t\t\tINFO(\"Mount source or target for %s on %s doesn't exist. Skipping.\", source, destination);\n\t\t\t\tr = 0;\n\t\t\t}\n\t\t\telse if (r < 0)\n\t\t\t\tSYSERROR(\"error mounting %s on %s flags %lu\", source, destination, mflags);\n\n\t\t\tfree(source);\n\t\t\tfree(destination);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n{\n\tconst char *b = (const char *)sst->sst_tab;\n\tconst char *e = ((const char *)p) + tail;\n\t(void)&line;\n\tif (e >= b && (size_t)(e - b) <= CDF_SEC_SIZE(h) * sst->sst_len)\n\t\treturn 0;\n\tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n\t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n\t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n\t    CDF_SEC_SIZE(h) * sst->sst_len, CDF_SEC_SIZE(h), sst->sst_len));\n\terrno = EFTYPE;\n\treturn -1;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n{\n\tconst char *b = (const char *)sst->sst_tab;\n\tconst char *e = ((const char *)p) + tail;\n\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n\t(void)&line;\n\tif (e >= b && (size_t)(e - b) <= ss * sst->sst_len)\n\t\treturn 0;\n\tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n\t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n\t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n\t    ss * sst->sst_len, ss, sst->sst_len));\n\terrno = EFTYPE;\n\treturn -1;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "{\n\ttime_t now_t, tdiff;\n\tchar localeptr[] = \"./\", *eptr; /* for environment */\n\tsize_t len;\n\n\tmemset(control, 0, sizeof(rzip_control));\n\tcontrol->msgout = stderr;\n\tcontrol->msgerr = stderr;\n\tregister_outputfile(control, control->msgout);\n\tcontrol->flags = FLAG_SHOW_PROGRESS | FLAG_KEEP_FILES | FLAG_THRESHOLD;\n\tcontrol->suffix = \".lrz\";\n\tcontrol->compression_level = 7;\n\tcontrol->ramsize = get_ram(control);\n\tif (unlikely(control->ramsize == -1))\n\t\treturn false;\n\t/* for testing single CPU */\n\tcontrol->threads = PROCESSORS;\t/* get CPUs for LZMA */\n\tcontrol->page_size = PAGE_SIZE;\n\tcontrol->nice_val = 19;\n\n\t/* The first 5 bytes of the salt is the time in seconds.",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "{\n\ttime_t now_t, tdiff;\n\tchar localeptr[] = \"./\", *eptr; /* for environment */\n\tsize_t len;\n\n\tmemset(control, 0, sizeof(rzip_control));\n\tcontrol->msgout = stderr;\n\tcontrol->msgerr = stderr;\n\tregister_outputfile(control, control->msgout);\n\tcontrol->flags = FLAG_SHOW_PROGRESS | FLAG_KEEP_FILES | FLAG_THRESHOLD;\n\tcontrol->suffix = strdup(\".lrz\");\n\tcontrol->compression_level = 7;\n\tcontrol->ramsize = get_ram(control);\n\tif (unlikely(control->ramsize == -1))\n\t\treturn false;\n\t/* for testing single CPU */\n\tcontrol->threads = PROCESSORS;\t/* get CPUs for LZMA */\n\tcontrol->page_size = PAGE_SIZE;\n\tcontrol->nice_val = 19;\n\n\t/* The first 5 bytes of the salt is the time in seconds.",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "chrand_principal3_2_svc(chrand3_arg *arg, struct svc_req *rqstp)\n{\n    static chrand_ret           ret;\n    krb5_keyblock               *k;\n    int                         nkeys;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name,\n        service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_chrand_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n    if(ret.code != KADM5_AUTH_CHANGEPW) {\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "chrand_principal3_2_svc(chrand3_arg *arg, struct svc_req *rqstp)\n{\n    static chrand_ret           ret;\n    krb5_keyblock               *k;\n    int                         nkeys;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_chrand_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(funcname, prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int jas_iccgetuint16(jas_stream_t *in, jas_iccuint16_t *val)\n{\n\tulonglong tmp;\n\tif (jas_iccgetuint(in, 2, &tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int jas_iccgetuint16(jas_stream_t *in, jas_iccuint16_t *val)\n{\n\tjas_ulonglong tmp;\n\tif (jas_iccgetuint(in, 2, &tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "        } else {\n            av_log(ctx, AV_LOG_WARNING, \"Discarding initial frame(s) with no \"\n                   \"timestamp.\\n\");\n            av_frame_free(&buf);\n            s->drop++;\n        }\n        return 0;\n    }\n\n    /* now wait for the next timestamp */\n    if (buf->pts == AV_NOPTS_VALUE) {\n        return write_to_fifo(s->fifo, buf);\n    }\n\n    /* number of output frames */\n    delta = av_rescale_q_rnd(buf->pts - s->pts, inlink->time_base,\n                             outlink->time_base, s->rounding);\n\n    if (delta < 1) {\n        /* drop the frame and everything buffered except the first */\n        AVFrame *tmp;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "        } else {\n            av_log(ctx, AV_LOG_WARNING, \"Discarding initial frame(s) with no \"\n                   \"timestamp.\\n\");\n            av_frame_free(&buf);\n            s->drop++;\n        }\n        return 0;\n    }\n\n    /* now wait for the next timestamp */\n    if (buf->pts == AV_NOPTS_VALUE || av_fifo_size(s->fifo) <= 0) {\n        return write_to_fifo(s->fifo, buf);\n    }\n\n    /* number of output frames */\n    delta = av_rescale_q_rnd(buf->pts - s->pts, inlink->time_base,\n                             outlink->time_base, s->rounding);\n\n    if (delta < 1) {\n        /* drop the frame and everything buffered except the first */\n        AVFrame *tmp;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static char *clean_path(char *path)\n{\n\tchar *ch;\n\tchar *ch2;\n\tchar *str;\n\tstr = xmalloc(strlen(path));\n\tch = path;\n\tch2 = str;\n\twhile (true) {\n\t\t*ch2 = *ch;\n\t\tch++;\n\t\tch2++;\n\t\tif (!*(ch-1))\n\t\t\tbreak;\n\t\twhile (*(ch - 1) == '/' && *ch == '/')\n\t\t\tch++;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static char *clean_path(char *path)\n{\n\tchar *ch;\n\tchar *ch2;\n\tchar *str;\n\tstr = xmalloc(strlen(path) + 1);\n\tch = path;\n\tch2 = str;\n\twhile (true) {\n\t\t*ch2 = *ch;\n\t\tch++;\n\t\tch2++;\n\t\tif (!*(ch-1))\n\t\t\tbreak;\n\t\twhile (*(ch - 1) == '/' && *ch == '/')\n\t\t\tch++;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  readState.readStructBegin(iprot);\n\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    readState.fieldId = 0;\n    readState.readFieldBegin(iprot);\n    if (readState.atStop()) {\n      structInfo.unionExt->clear(object);\n      readState.readStructEnd(iprot);\n      return;\n    }\n    const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo);\n    // Found it.\n    if (fieldInfo) {\n      void* unionVal = getMember(*fieldInfo, object);\n      // Default construct and placement new into the member union.\n      structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](\n          unionVal);\n      read(iprot, *fieldInfo->typeInfo, readState, unionVal);\n      const_cast<FieldID&>(activeUnionMemberId(\n          object, structInfo.unionExt->unionTypeOffset)) = fieldInfo->id;\n    } else {\n      skip(iprot, readState);\n    }\n    readState.readFieldEnd(iprot);\n    readState.readFieldBegin(iprot);\n    if (UNLIKELY(!readState.atStop())) {\n      TProtocolException::throwUnionMissingStop();\n    }\n    readState.readStructEnd(iprot);\n    return;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  readState.readStructBegin(iprot);\n\n  if (UNLIKELY(structInfo.unionExt != nullptr)) {\n    readState.fieldId = 0;\n    readState.readFieldBegin(iprot);\n    if (readState.atStop()) {\n      structInfo.unionExt->clear(object);\n      readState.readStructEnd(iprot);\n      return;\n    }\n    if (const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo)) {\n      auto& activeId = const_cast<int&>(getActiveId(object, structInfo));\n      if (activeId != 0) {\n        structInfo.unionExt->clear(object);\n      }\n      void* value = getMember(*fieldInfo, object);\n      structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](value);\n      read(iprot, *fieldInfo->typeInfo, readState, value);\n      activeId = fieldInfo->id;\n    } else {\n      skip(iprot, readState);\n    }\n    readState.readFieldEnd(iprot);\n    readState.readFieldBegin(iprot);\n    if (UNLIKELY(!readState.atStop())) {\n      TProtocolException::throwUnionMissingStop();\n    }\n    readState.readStructEnd(iprot);\n    return;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static CYTHON_SMALL_CODE int __pyx_pymod_exec_bufferedreader(PyObject *__pyx_pyinit_module)\n#endif\n#endif\n{\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannyDeclarations\n  #if CYTHON_PEP489_MULTI_PHASE_INIT\n  if (__pyx_m) {\n    if (__pyx_m == __pyx_pyinit_module) return 0;\n    PyErr_SetString(PyExc_RuntimeError, \"Module 'bufferedreader' has already been imported. Re-initialisation is not supported.\");\n    return -1;\n  }\n  #elif PY_MAJOR_VERSION >= 3\n  if (__pyx_m) return __Pyx_NewRef(__pyx_m);\n  #endif\n  }\n  #if PY_MAJOR_VERSION >= 3\n  {\n    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)\n    if (!PyDict_GetItemString(modules, \"clickhouse_driver.bufferedreader\")) {\n      if (unlikely(PyDict_SetItemString(modules, \"clickhouse_driver.bufferedreader\", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)\n    }\n  }\n  #endif\n  /*--- Builtin init code ---*/\n  if (__Pyx_InitCachedBuiltins() < 0) goto __pyx_L1_error;\n  /*--- Constants init code ---*/\n  if (__Pyx_InitCachedConstants() < 0) goto __pyx_L1_error;\n  /*--- Global type/function init code ---*/\n  (void)__Pyx_modinit_global_init_code();\n  (void)__Pyx_modinit_variable_export_code();\n  (void)__Pyx_modinit_function_export_code();\n  if (unlikely(__Pyx_modinit_type_init_code() != 0)) goto __pyx_L1_error;\n  if (unlikely(__Pyx_modinit_type_import_code() != 0)) goto __pyx_L1_error;\n  (void)__Pyx_modinit_variable_import_code();\n  (void)__Pyx_modinit_function_import_code();\n  /*--- Execution code ---*/\n  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)\n  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n\n  /* \"(tree fragment)\":1\n * def __pyx_unpickle_BufferedReader(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<\n *     cdef object __pyx_PickleError",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static CYTHON_SMALL_CODE int __pyx_pymod_exec_bufferedreader(PyObject *__pyx_pyinit_module)\n#endif\n#endif\n{\n  PyObject *__pyx_t_1 = NULL;\n  int __pyx_lineno = 0;\n  const char *__pyx_filename = NULL;\n  int __pyx_clineno = 0;\n  __Pyx_RefNannyDeclarations\n  #if CYTHON_PEP489_MULTI_PHASE_INIT\n  if (__pyx_m) {\n    if (__pyx_m == __pyx_pyinit_module) return 0;\n    PyErr_SetString(PyExc_RuntimeError, \"Module 'bufferedreader' has already been imported. Re-initialisation is not supported.\");\n    return -1;\n  }\n  #elif PY_MAJOR_VERSION >= 3\n  if (__pyx_m) return __Pyx_NewRef(__pyx_m);\n  #endif\n  }\n  #if PY_MAJOR_VERSION >= 3\n  {\n    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)\n    if (!PyDict_GetItemString(modules, \"clickhouse_driver.bufferedreader\")) {\n      if (unlikely(PyDict_SetItemString(modules, \"clickhouse_driver.bufferedreader\", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)\n    }\n  }\n  #endif\n  /*--- Builtin init code ---*/\n  if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  /*--- Constants init code ---*/\n  if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  /*--- Global type/function init code ---*/\n  (void)__Pyx_modinit_global_init_code();\n  (void)__Pyx_modinit_variable_export_code();\n  (void)__Pyx_modinit_function_export_code();\n  if (unlikely(__Pyx_modinit_type_init_code() < 0)) __PYX_ERR(0, 1, __pyx_L1_error)\n  if (unlikely(__Pyx_modinit_type_import_code() < 0)) __PYX_ERR(0, 1, __pyx_L1_error)\n  (void)__Pyx_modinit_variable_import_code();\n  (void)__Pyx_modinit_function_import_code();\n  /*--- Execution code ---*/\n  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)\n  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  #endif\n\n  /* \"(tree fragment)\":1\n * def __pyx_unpickle_BufferedReader(__pyx_type, long __pyx_checksum, __pyx_state):             # <<<<<<<<<<<<<<\n *     cdef object __pyx_PickleError",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "PLT_HttpServer::ServeFile(const NPT_HttpRequest&        request, \n                          const NPT_HttpRequestContext& context,\n                          NPT_HttpResponse&             response,\n                          NPT_String                    file_path) \n{\n    NPT_InputStreamReference stream;\n    NPT_File                 file(file_path);\n    NPT_FileInfo             file_info;\n    \n    // prevent hackers from accessing files outside of our root\n    if ((file_path.Find(\"/..\") >= 0) || (file_path.Find(\"\\\\..\") >= 0) ||\n        NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n    // check for range requests\n    const NPT_String* range_spec = request.GetHeaders().GetHeaderValue(NPT_HTTP_HEADER_RANGE);\n    \n    // handle potential 304 only if range header not set\n    NPT_DateTime  date;\n    NPT_TimeStamp timestamp;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "PLT_HttpServer::ServeFile(const NPT_HttpRequest&        request, \n                          const NPT_HttpRequestContext& context,\n                          NPT_HttpResponse&             response,\n                          NPT_String                    file_path) \n{\n    NPT_InputStreamReference stream;\n    NPT_File                 file(file_path);\n    NPT_FileInfo             file_info;\n    \n    // prevent hackers from accessing files outside of our root\n    if ((file_path.Find(\"../\") >= 0) || (file_path.Find(\"..\\\\\") >= 0) ||\n        NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n    // check for range requests\n    const NPT_String* range_spec = request.GetHeaders().GetHeaderValue(NPT_HTTP_HEADER_RANGE);\n    \n    // handle potential 304 only if range header not set\n    NPT_DateTime  date;\n    NPT_TimeStamp timestamp;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n\t\t\t   iov_count);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t    return (GSS_S_NO_CONTEXT);\n\n    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n\t\t\t   iov_count);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "header_gets (SF_PRIVATE *psf, char *ptr, int bufsize)\n{\tint\t\tk ;\n\n\tfor (k = 0 ; k < bufsize - 1 ; k++)\n\t{\tif (psf->headindex < psf->headend)\n\t\t{\tptr [k] = psf->header [psf->headindex] ;\n\t\t\tpsf->headindex ++ ;\n\t\t\t}\n\t\telse\n\t\t{\tpsf->headend += psf_fread (psf->header + psf->headend, 1, 1, psf) ;\n\t\t\tptr [k] = psf->header [psf->headindex] ;\n\t\t\tpsf->headindex = psf->headend ;\n\t\t\t} ;\n\n\t\tif (ptr [k] == '\\n')\n\t\t\tbreak ;\n\t\t} ;\n\n\tptr [k] = 0 ;\n\n\treturn k ;\n} /* header_gets */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "header_gets (SF_PRIVATE *psf, char *ptr, int bufsize)\n{\tint\t\tk ;\n\n\tif (psf->header.indx + bufsize >= psf->header.len && psf_bump_header_allocation (psf, bufsize))\n\t\treturn 0 ;\n\n\tfor (k = 0 ; k < bufsize - 1 ; k++)\n\t{\tif (psf->header.indx < psf->header.end)\n\t\t{\tptr [k] = psf->header.ptr [psf->header.indx] ;\n\t\t\tpsf->header.indx ++ ;\n\t\t\t}\n\t\telse\n\t\t{\tpsf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, 1, psf) ;\n\t\t\tptr [k] = psf->header.ptr [psf->header.indx] ;\n\t\t\tpsf->header.indx = psf->header.end ;\n\t\t\t} ;\n\n\t\tif (ptr [k] == '\\n')\n\t\t\tbreak ;\n\t\t} ;\n\n\tptr [k] = 0 ;\n\n\treturn k ;\n} /* header_gets */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static bool read_header_from_file(zckCtx *zck) {\n    /* Verify that lead_size and header_length have been set */\n    if(zck->lead_size == 0 || zck->header_length == 0) {\n        set_error(zck, \"Lead and header sizes are both 0.  Have you run zck_read_lead() yet?\");\n        return false;\n    }\n\n    /* Allocate header and store any extra bytes at beginning of header */\n    zck->header = zrealloc(zck->header, zck->lead_size + zck->header_length);\n    if (!zck->header) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    zck->lead_string = zck->header;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static bool read_header_from_file(zckCtx *zck) {\n    /* Verify that lead_size and header_length have been set and are legit */\n    if(zck->lead_size == 0 || zck->header_length == 0) {\n        set_error(zck, \"Lead and header sizes are both 0.  Have you run zck_read_lead() yet?\");\n        return false;\n    }\n    if((zck->lead_size > zck->lead_size + zck->header_length) ||\n       (zck->header_length > zck->lead_size + zck->header_length)) {\n        zck_log(ZCK_LOG_ERROR, \"Integer overflow when reading header\");\n        return false;\n    }\n\n    /* Allocate header and store any extra bytes at beginning of header */\n    zck->header = zrealloc(zck->header, zck->lead_size + zck->header_length);\n    if (!zck->header) {\n        zck_log(ZCK_LOG_ERROR, \"OOM in %s\", __func__);\n        return false;\n    }\n    zck->lead_string = zck->header;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "         *     nsExtendStorage which is fixed as either 'permanent'\n         *     (if read from a config file) or 'volatile' (if set via SNMP)\n         *   The string-based settings of a 'permanent' entry cannot \n         *     be changed - neither can the execution or run type.\n         *   Such entries can be (temporarily) marked as inactive,\n         *     and the cache timeout adjusted, but these changes are\n         *     not persistent.\n         *\n         **********/\n\n#ifndef NETSNMP_NO_WRITE_SUPPORT\n        case MODE_SET_RESERVE1:\n            /*\n             * Validate the new assignments\n             */\n            switch (table_info->colnum) {\n            case COLUMN_EXTCFG_COMMAND:\n                if (request->requestvb->type != ASN_OCTET_STR) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGTYPE);\n                    return SNMP_ERR_WRONGTYPE;\n                    extension->flags &= ~NS_EXTEND_FLAGS_ACTIVE;\n                    break;\n                case RS_DESTROY:\n                    eptr = _find_extension_block( request->requestvb->name,\n                                                  request->requestvb->name_length );\n                    _free_extension( extension, eptr );\n                    break;\n                }\n            }\n            break;\n#endif /* !NETSNMP_NO_WRITE_SUPPORT */ \n\n        default:\n            netsnmp_set_request_error(reqinfo, request, SNMP_ERR_GENERR);\n            return SNMP_ERR_GENERR;\n        }\n    }\n\n#ifndef NETSNMP_NO_WRITE_SUPPORT\n    /*\n     * If we're marking a given row as active,\n     *  then we need to check that it's ready.\n     */\n    if (need_to_validate) {\n        for ( request=requests; request; request=request->next ) {\n            if (request->processed)\n                continue;\n            table_info = netsnmp_extract_table_info( request );\n            extension  = (netsnmp_extend*)netsnmp_extract_table_row_data( request );\n                    !(extension && extension->command &&\n                      extension->command[0] == '/' /* &&\n                      is_executable(extension->command) */)) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_INCONSISTENTVALUE);\n                    return SNMP_ERR_INCONSISTENTVALUE;\n                }\n            }\n        }\n    }\n#endif /* !NETSNMP_NO_WRITE_SUPPORT */\n    \n    return SNMP_ERR_NOERROR;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "         *     nsExtendStorage which is fixed as either 'permanent'\n         *     (if read from a config file) or 'volatile' (if set via SNMP)\n         *   The string-based settings of a 'permanent' entry cannot \n         *     be changed - neither can the execution or run type.\n         *   Such entries can be (temporarily) marked as inactive,\n         *     and the cache timeout adjusted, but these changes are\n         *     not persistent.\n         *\n         **********/\n\n#if !defined(NETSNMP_NO_WRITE_SUPPORT) && ENABLE_EXTEND_WRITE_ACCESS\n        case MODE_SET_RESERVE1:\n            /*\n             * Validate the new assignments\n             */\n            switch (table_info->colnum) {\n            case COLUMN_EXTCFG_COMMAND:\n                if (request->requestvb->type != ASN_OCTET_STR) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_WRONGTYPE);\n                    return SNMP_ERR_WRONGTYPE;\n                    extension->flags &= ~NS_EXTEND_FLAGS_ACTIVE;\n                    break;\n                case RS_DESTROY:\n                    eptr = _find_extension_block( request->requestvb->name,\n                                                  request->requestvb->name_length );\n                    _free_extension( extension, eptr );\n                    break;\n                }\n            }\n            break;\n#endif /* !NETSNMP_NO_WRITE_SUPPORT and ENABLE_EXTEND_WRITE_ACCESS */\n\n        default:\n            netsnmp_set_request_error(reqinfo, request, SNMP_ERR_GENERR);\n            return SNMP_ERR_GENERR;\n        }\n    }\n\n#if !defined(NETSNMP_NO_WRITE_SUPPORT) && ENABLE_EXTEND_WRITE_ACCESS\n    /*\n     * If we're marking a given row as active,\n     *  then we need to check that it's ready.\n     */\n    if (need_to_validate) {\n        for ( request=requests; request; request=request->next ) {\n            if (request->processed)\n                continue;\n            table_info = netsnmp_extract_table_info( request );\n            extension  = (netsnmp_extend*)netsnmp_extract_table_row_data( request );\n                    !(extension && extension->command &&\n                      extension->command[0] == '/' /* &&\n                      is_executable(extension->command) */)) {\n                    netsnmp_set_request_error(reqinfo, request,\n                                              SNMP_ERR_INCONSISTENTVALUE);\n                    return SNMP_ERR_INCONSISTENTVALUE;\n                }\n            }\n        }\n    }\n#endif /* !NETSNMP_NO_WRITE_SUPPORT && ENABLE_EXTEND_WRITE_ACCESS */\n    \n    return SNMP_ERR_NOERROR;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "max3421_select_and_start_urb(struct usb_hcd *hcd)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct urb *urb, *curr_urb = NULL;\n\tstruct max3421_ep *max3421_ep;\n\tint epnum, force_toggles = 0;\n\tstruct usb_host_endpoint *ep;\n\tstruct list_head *pos;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\tfor (;\n\t     max3421_hcd->sched_pass < SCHED_PASS_DONE;\n\t     ++max3421_hcd->sched_pass)\n\t\tlist_for_each(pos, &max3421_hcd->ep_list) {\n\telse {\n\t\t/* start USB transaction: */\n\t\tif (usb_endpoint_xfer_control(&ep->desc)) {\n\t\t\t/*\n\t\t\t * See USB 2.0 spec section 8.6.1\n\t\t\t * Initialization via SETUP Token:\n\t\t\t */\n\t\t\tusb_settoggle(urb->dev, epnum, 0, 1);\n\t\t\tusb_settoggle(urb->dev, epnum, 1, 1);\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_SETUP;\n\t\t\tforce_toggles = 1;\n\t\t} else\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_TRANSFER;\n\t}\n\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\n\tmax3421_ep->last_active = max3421_hcd->frame_number;\n\tmax3421_set_address(hcd, urb->dev, epnum, force_toggles);\n\tmax3421_set_speed(hcd, urb->dev);\n\tmax3421_next_transfer(hcd, 0);\n\treturn 1;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "max3421_select_and_start_urb(struct usb_hcd *hcd)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct urb *urb, *curr_urb = NULL;\n\tstruct max3421_ep *max3421_ep;\n\tint epnum;\n\tstruct usb_host_endpoint *ep;\n\tstruct list_head *pos;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\tfor (;\n\t     max3421_hcd->sched_pass < SCHED_PASS_DONE;\n\t     ++max3421_hcd->sched_pass)\n\t\tlist_for_each(pos, &max3421_hcd->ep_list) {\n\t\tmax3421_ep->retransmit = 0;\n\telse {\n\t\t/* start USB transaction: */\n\t\tif (usb_endpoint_xfer_control(&ep->desc)) {\n\t\t\t/*\n\t\t\t * See USB 2.0 spec section 8.6.1\n\t\t\t * Initialization via SETUP Token:\n\t\t\t */\n\t\t\tusb_settoggle(urb->dev, epnum, 0, 1);\n\t\t\tusb_settoggle(urb->dev, epnum, 1, 1);\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_SETUP;\n\t\t} else\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_TRANSFER;\n\t}\n\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\n\tmax3421_ep->last_active = max3421_hcd->frame_number;\n\tmax3421_set_address(hcd, urb->dev, epnum);\n\tmax3421_set_speed(hcd, urb->dev);\n\tmax3421_next_transfer(hcd, 0);\n\treturn 1;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, ",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, ",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\tlen = ntohs(mte->len);\n\t\t\tcallno = ntohs(mte->callno);\n\t\t\ttrunked_ts = 0;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown meta trunk cmd from '%s:%d': dropping\\n\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\tbreak;\n\t\t}\n\t\t/* Stop if we don't have enough data */\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL */\n\t\t/* Process as a mini frame */\n\t\tmemset(&f, 0, sizeof(f));\n\t\tf.frametype = AST_FRAME_VOICE;\n\t\tif (!iaxs[fr->callno]) {\n\t\t\t/* drop it */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\tlen = ntohs(mte->len);\n\t\t\tcallno = ntohs(mte->callno);\n\t\t\ttrunked_ts = 0;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown meta trunk cmd from '%s:%d': dropping\\n\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\tbreak;\n\t\t}\n\t\t/* Stop if we don't have enough data */\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL */\n\t\t/* Process as a mini frame */\n\t\tmemset(&f, 0, sizeof(f));\n\t\tf.frametype = AST_FRAME_VOICE;\n\t\tif (!iaxs[fr->callno]) {\n\t\t\t/* drop it */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void eb_mul_sim_kbltz(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m, const eb_t *t) {\n\tint i, l, l0, l1, n0, n1, w, g;\n\tint8_t u, tnaf0[RLC_FB_BITS + 8], tnaf1[RLC_FB_BITS + 8], *_k, *_m;\n\teb_t t0[1 << (EB_WIDTH - 2)];\n\teb_t t1[1 << (EB_WIDTH - 2)];\n\n\tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\teb_null(t0[i]);\n\t\teb_null(t1[i]);\n\t}\n\n\tRLC_TRY {\n\t\t/* Compute the w-TNAF representation of k. */\n\t\tif (eb_curve_opt_a() == RLC_ZERO) {\n\t\t\tu = -1;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void eb_mul_sim_kbltz(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m, const eb_t *t) {\n\tint i, n0, n1, w, g;\n\tint8_t u, tnaf0[RLC_FB_BITS + 8], tnaf1[RLC_FB_BITS + 8], *_k, *_m;\n\teb_t t0[1 << (EB_WIDTH - 2)];\n\teb_t t1[1 << (EB_WIDTH - 2)];\n\tsize_t l, l0, l1;\n\n\tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\teb_null(t0[i]);\n\t\teb_null(t1[i]);\n\t}\n\n\tRLC_TRY {\n\t\t/* Compute the w-TNAF representation of k. */\n\t\tif (eb_curve_opt_a() == RLC_ZERO) {\n\t\t\tu = -1;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int performRtspHandshake(void) {\n    char urlAddr[URLSAFESTRING_LEN];\n    int ret;\n\n    // Initialize global state\n    addrToUrlSafeString(&RemoteAddr, urlAddr);\n    sprintf(rtspTargetUrl, \"rtsp://%s\", urlAddr);\n    currentSeqNumber = 1;\n    hasSessionId = 0;\n\n    switch (ServerMajorVersion) {\n        case 3:\n            rtspClientVersion = 10;\n            break;\n        case 4:\n            rtspClientVersion = 11;\n            break;\n        case 5:\n            rtspClientVersion = 12;\n            break;\n        case 6:\n            // Gen 6 has never been seen in the wild\n            rtspClientVersion = 13;\n            break;\n        case 7:\n        default:\n            rtspClientVersion = 14;\n            break;\n    }\n    \n    // Gen 5 servers use ENet to do the RTSP handshake\n    if (ServerMajorVersion >= 5) {\n        ENetAddress address;\n        ENetEvent event;\n        \n        enet_address_set_address(&address, (struct sockaddr *)&RemoteAddr, RemoteAddrLen);\n        enet_address_set_port(&address, 48010);\n        \n        // Create a client that can use 1 outgoing connection and 1 channel\n        client = enet_host_create(address.address.ss_family, NULL, 1, 1, 0, 0);\n        if (client == NULL) {\n            return -1;\n\n        freeMessage(&response);\n    }\n\n    {\n        RTSP_MESSAGE response;\n        char* sessionId;\n        int error = -1;\n\n        if (!setupStream(&response,\n                         ServerMajorVersion >= 5 ? \"streamid=audio/0/0\" : \"streamid=audio\",\n                         &error)) {\n            Limelog(\"RTSP SETUP streamid=audio request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n\n        if (response.message.response.statusCode != 200) {\n            Limelog(\"RTSP SETUP streamid=audio request failed: %d\\n\",\n                response.message.response.statusCode);\n            ret = response.message.response.statusCode;\n        hasSessionId = 1;\n\n        freeMessage(&response);\n    }\n\n    {\n        RTSP_MESSAGE response;\n        int error = -1;\n\n        if (!setupStream(&response,\n                         ServerMajorVersion >= 5 ? \"streamid=video/0/0\" : \"streamid=video\",\n                         &error)) {\n            Limelog(\"RTSP SETUP streamid=video request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n\n        if (response.message.response.statusCode != 200) {\n            Limelog(\"RTSP SETUP streamid=video request failed: %d\\n\",\n                response.message.response.statusCode);\n            ret = response.message.response.statusCode;\n            goto Exit;\n        }\n\n        freeMessage(&response);\n    }\n    \n    if (ServerMajorVersion >= 5) {\n        RTSP_MESSAGE response;\n        int error = -1;\n\n        if (!setupStream(&response, \"streamid=control/1/0\", &error)) {\n            Limelog(\"RTSP SETUP streamid=control request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n\n        if (response.message.response.statusCode != 200) {\n            goto Exit;\n        }\n\n        freeMessage(&response);\n    }\n    \n    ret = 0;\n    \nExit:\n    // Cleanup the ENet stuff\n    if (ServerMajorVersion >= 5) {\n        if (peer != NULL) {\n            enet_peer_disconnect_now(peer, 0);\n            peer = NULL;\n        }\n        \n        if (client != NULL) {\n            enet_host_destroy(client);\n            client = NULL;\n        }\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int performRtspHandshake(void) {\n    char urlAddr[URLSAFESTRING_LEN];\n    int ret;\n\n    // Initialize global state\n    addrToUrlSafeString(&RemoteAddr, urlAddr);\n    sprintf(rtspTargetUrl, \"rtsp://%s\", urlAddr);\n    currentSeqNumber = 1;\n    hasSessionId = 0;\n\n    switch (AppVersionQuad[0]) {\n        case 3:\n            rtspClientVersion = 10;\n            break;\n        case 4:\n            rtspClientVersion = 11;\n            break;\n        case 5:\n            rtspClientVersion = 12;\n            break;\n        case 6:\n            // Gen 6 has never been seen in the wild\n            rtspClientVersion = 13;\n            break;\n        case 7:\n        default:\n            rtspClientVersion = 14;\n            break;\n    }\n    \n    // Gen 5 servers use ENet to do the RTSP handshake\n    if (AppVersionQuad[0] >= 5) {\n        ENetAddress address;\n        ENetEvent event;\n        \n        enet_address_set_address(&address, (struct sockaddr *)&RemoteAddr, RemoteAddrLen);\n        enet_address_set_port(&address, 48010);\n        \n        // Create a client that can use 1 outgoing connection and 1 channel\n        client = enet_host_create(address.address.ss_family, NULL, 1, 1, 0, 0);\n        if (client == NULL) {\n            return -1;\n\n        freeMessage(&response);\n    }\n\n    {\n        RTSP_MESSAGE response;\n        char* sessionId;\n        int error = -1;\n\n        if (!setupStream(&response,\n                         AppVersionQuad[0] >= 5 ? \"streamid=audio/0/0\" : \"streamid=audio\",\n                         &error)) {\n            Limelog(\"RTSP SETUP streamid=audio request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n\n        if (response.message.response.statusCode != 200) {\n            Limelog(\"RTSP SETUP streamid=audio request failed: %d\\n\",\n                response.message.response.statusCode);\n            ret = response.message.response.statusCode;\n        hasSessionId = 1;\n\n        freeMessage(&response);\n    }\n\n    {\n        RTSP_MESSAGE response;\n        int error = -1;\n\n        if (!setupStream(&response,\n                         AppVersionQuad[0] >= 5 ? \"streamid=video/0/0\" : \"streamid=video\",\n                         &error)) {\n            Limelog(\"RTSP SETUP streamid=video request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n\n        if (response.message.response.statusCode != 200) {\n            Limelog(\"RTSP SETUP streamid=video request failed: %d\\n\",\n                response.message.response.statusCode);\n            ret = response.message.response.statusCode;\n            goto Exit;\n        }\n\n        freeMessage(&response);\n    }\n    \n    if (AppVersionQuad[0] >= 5) {\n        RTSP_MESSAGE response;\n        int error = -1;\n\n        if (!setupStream(&response, \"streamid=control/1/0\", &error)) {\n            Limelog(\"RTSP SETUP streamid=control request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n\n        if (response.message.response.statusCode != 200) {\n            goto Exit;\n        }\n\n        freeMessage(&response);\n    }\n    \n    ret = 0;\n    \nExit:\n    // Cleanup the ENet stuff\n    if (AppVersionQuad[0] >= 5) {\n        if (peer != NULL) {\n            enet_peer_disconnect_now(peer, 0);\n            peer = NULL;\n        }\n        \n        if (client != NULL) {\n            enet_host_destroy(client);\n            client = NULL;\n        }\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "      // Ensemble was empty. Output the very first node.\n      output_node_ids.setZero();\n      output_tree_ids = cached_tree_ids;\n      // All the predictions are zeros.\n      output_partial_logits.setZero();\n    } else {\n      output_tree_ids.setConstant(latest_tree);\n      auto do_work = [&resource, &bucketized_features, &cached_tree_ids,\n                      &cached_node_ids, &output_partial_logits,\n                      &output_node_ids, latest_tree,\n                      this](int32 start, int32 end) {\n        for (int32 i = start; i < end; ++i) {\n          int32 tree_id = cached_tree_ids(i);\n          int32 node_id = cached_node_ids(i);\n          std::vector<float> partial_tree_logits(logits_dimension_, 0.0);\n\n          if (node_id >= 0) {\n            // If the tree was pruned, returns the node id into which the\n            // current_node_id was pruned, as well the correction of the cached\n            // logit prediction.\n            resource->GetPostPruneCorrection(tree_id, node_id, &node_id,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "      // Ensemble was empty. Output the very first node.\n      output_node_ids.setZero();\n      output_tree_ids = cached_tree_ids;\n      // All the predictions are zeros.\n      output_partial_logits.setZero();\n    } else {\n      output_tree_ids.setConstant(latest_tree);\n      auto do_work = [&resource, &bucketized_features, &cached_tree_ids,\n                      &cached_node_ids, &output_partial_logits,\n                      &output_node_ids, latest_tree,\n                      this](int64 start, int64 end) {\n        for (int32 i = start; i < end; ++i) {\n          int32 tree_id = cached_tree_ids(i);\n          int32 node_id = cached_node_ids(i);\n          std::vector<float> partial_tree_logits(logits_dimension_, 0.0);\n\n          if (node_id >= 0) {\n            // If the tree was pruned, returns the node id into which the\n            // current_node_id was pruned, as well the correction of the cached\n            // logit prediction.\n            resource->GetPostPruneCorrection(tree_id, node_id, &node_id,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive inet socket %p\\n\", sk);\n\t\treturn;\n\t}\n\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\tWARN_ON(sk->sk_wmem_queued);\n\tWARN_ON(sk->sk_forward_alloc);\n\n\tkfree(inet->opt);\n\tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\n\tsk_refcnt_debug_dec(sk);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tif (!sock_flag(sk, SOCK_DEAD)) {\n\t\tpr_err(\"Attempt to release alive inet socket %p\\n\", sk);\n\t\treturn;\n\t}\n\n\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\tWARN_ON(sk->sk_wmem_queued);\n\tWARN_ON(sk->sk_forward_alloc);\n\n\tkfree(rcu_dereference_protected(inet->inet_opt, 1));\n\tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\n\tsk_refcnt_debug_dec(sk);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tgf_list_add(ptr->profile_tier_levels, ptl);\n\t}\n\tcount = gf_bs_read_u16(bs);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op;\n\t\tGF_SAFEALLOC(op, LHEVC_OperatingPoint);\n\t\tif (!op) return GF_OUT_OF_MEM;\n\t\top->output_layer_set_idx = gf_bs_read_u16(bs);\n\t\top->max_temporal_id = gf_bs_read_u8(bs);\n\t\top->layer_count = gf_bs_read_u8(bs);\n\t\tif (op->layer_count > GF_ARRAY_LENGTH(op->layers_info))\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\tfor (j = 0; j < op->layer_count; j++) {\n\t\t\top->layers_info[j].ptl_idx = gf_bs_read_u8(bs);\n\t\t\top->layers_info[j].layer_id = gf_bs_read_int(bs, 6);\n\t\t\top->layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t\top->layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t}\n\t\top->minPicWidth = gf_bs_read_u16(bs);\n\t\top->minPicHeight = gf_bs_read_u16(bs);\n\t\top->maxPicWidth = gf_bs_read_u16(bs);\n\t\top->maxPicHeight = gf_bs_read_u16(bs);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tgf_list_add(ptr->profile_tier_levels, ptl);\n\t}\n\tcount = gf_bs_read_u16(bs);\n\tfor (i = 0; i < count; i++) {\n\t\tLHEVC_OperatingPoint *op;\n\t\tGF_SAFEALLOC(op, LHEVC_OperatingPoint);\n\t\tif (!op) return GF_OUT_OF_MEM;\n\t\top->output_layer_set_idx = gf_bs_read_u16(bs);\n\t\top->max_temporal_id = gf_bs_read_u8(bs);\n\t\top->layer_count = gf_bs_read_u8(bs);\n\t\tif (op->layer_count > GF_ARRAY_LENGTH(op->layers_info)) {\n\t\t\tgf_free(op);\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tfor (j = 0; j < op->layer_count; j++) {\n\t\t\top->layers_info[j].ptl_idx = gf_bs_read_u8(bs);\n\t\t\top->layers_info[j].layer_id = gf_bs_read_int(bs, 6);\n\t\t\top->layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t\top->layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t}\n\t\top->minPicWidth = gf_bs_read_u16(bs);\n\t\top->minPicHeight = gf_bs_read_u16(bs);\n\t\top->maxPicWidth = gf_bs_read_u16(bs);\n\t\top->maxPicHeight = gf_bs_read_u16(bs);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t/* Assign public information to the rpmsg_device */\n\trpdev_ctrl = &vch->rpdev;\n\trpdev_ctrl->ops = &virtio_rpmsg_ops;\n\n\trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\tkfree(vch);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn rpdev_ctrl;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t/* Assign public information to the rpmsg_device */\n\trpdev_ctrl = &vch->rpdev;\n\trpdev_ctrl->ops = &virtio_rpmsg_ops;\n\n\trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\t/* vch will be free in virtio_rpmsg_release_device() */\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn rpdev_ctrl;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n\t\tu32 flags = gf_bs_read_u32(bs);\n\t\tu32 prop_size = gf_bs_read_u32(bs);\n\t\ttag_size-=8;\n\n\t\tif (prop_size>4) {\n\t\t\ttag_size-=2;\n\t\t\tprop_type = gf_bs_read_u16(bs);\n\t\t\tprop_size -= 6;\n\t\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)\n\t\t\t//add 2 extra bytes for UTF16 case string dump\n\t\t\tdata2 = gf_malloc(sizeof(char) * (prop_size+2));\n\t\t\tgf_bs_read_data(bs, data2, prop_size);\n\t\t\tdata2[prop_size] = 0;\n\t\t\tdata2[prop_size+1] = 0;\n\t\t\ttag_size-=prop_size;\n\t\t} else {\n\t\t\tprop_size = 0;\n\t\t}\n\t\tGF_SAFEALLOC(tag, GF_XtraTag)\n\t\ttag->flags = flags;\n\t\ttag->name = data;\n\t\ttag->prop_size = prop_size;\n\t\ttag->prop_value = data2;\n\t\ttag->prop_type = prop_type;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n\t\tu32 flags = gf_bs_read_u32(bs);\n\t\tu32 prop_size = gf_bs_read_u32(bs);\n\t\ttag_size-=8;\n\n\t\tif (prop_size>4) {\n\t\t\ttag_size-=2;\n\t\t\tprop_type = gf_bs_read_u16(bs);\n\t\t\tprop_size -= 6;\n\t\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)\n\t\t\t//add 3 extra bytes for UTF16 case string dump (3 because we need 0-aligned short value)\n\t\t\tdata2 = gf_malloc(sizeof(char) * (prop_size+3));\n\t\t\tgf_bs_read_data(bs, data2, prop_size);\n\t\t\tdata2[prop_size] = 0;\n\t\t\tdata2[prop_size+1] = 0;\n\t\t\tdata2[prop_size+2] = 0;\n\t\t\ttag_size-=prop_size;\n\t\t} else {\n\t\t\tprop_size = 0;\n\t\t}\n\t\tGF_SAFEALLOC(tag, GF_XtraTag)\n\t\ttag->flags = flags;\n\t\ttag->name = data;\n\t\ttag->prop_size = prop_size;\n\t\ttag->prop_value = data2;\n\t\ttag->prop_type = prop_type;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  void Compute(OpKernelContext* ctx) override {\n    // This call processes inputs 1 and 2 to write output 0.\n    ReshapeOp::Compute(ctx);\n\n    const float input_min_float = ctx->input(2).flat<float>()(0);\n    const float input_max_float = ctx->input(3).flat<float>()(0);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));\n    output_min->flat<float>()(0) = input_min_float;\n\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(2, TensorShape({}), &output_max));\n    output_max->flat<float>()(0) = input_max_float;\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  void Compute(OpKernelContext* ctx) override {\n    // This call processes inputs 1 and 2 to write output 0.\n    ReshapeOp::Compute(ctx);\n    if (!ctx->status().ok()) {\n      return;\n    }\n\n    const auto& input_min_float_tensor = ctx->input(2);\n    const auto& input_min_float_shape = input_min_float_tensor.shape();\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsScalar(input_min_float_shape) ||\n                    (TensorShapeUtils::IsVector(input_min_float_shape) &&\n                     (input_min_float_shape.dim_size(0) == 1)),\n                errors::InvalidArgument(\n                    \"input_min must be a scalar or a vector of 1 element\"));\n    const float input_min_float = input_min_float_tensor.flat<float>()(0);\n    const auto& input_max_float_tensor = ctx->input(3);\n    const auto& input_max_float_shape = input_max_float_tensor.shape();\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsScalar(input_max_float_shape) ||\n                    (TensorShapeUtils::IsVector(input_max_float_shape) &&\n                     (input_max_float_shape.dim_size(0) == 1)),\n                errors::InvalidArgument(\n                    \"input_max must be a scalar or a vector of 1 element\"));\n    const float input_max_float = input_max_float_tensor.flat<float>()(0);\n\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));\n    output_min->flat<float>()(0) = input_min_float;\n\n    Tensor* output_max = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(2, TensorShape({}), &output_max));\n    output_max->flat<float>()(0) = input_max_float;\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    }\n\n    // Notify the server of any packet losses\n    if (streamPacketIndex != (int)(lastPacketInStream + 1)) {\n        // Packets were lost so report this to the server\n        connectionLostPackets(lastPacketInStream, streamPacketIndex);\n    }\n    lastPacketInStream = streamPacketIndex;\n\n    // If this is the first packet, skip the frame header (if one exists)\n    if (firstPacket && ServerMajorVersion >= 5) {\n        currentPos.offset += 8;\n        currentPos.length -= 8;\n    }\n\n    if (firstPacket && isIdrFrameStart(&currentPos))\n    {\n        // SPS and PPS prefix is padded between NALs, so we must decode it with the slow path\n        processRtpPayloadSlow(videoPacket, &currentPos);\n    }\n    else",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    }\n\n    // Notify the server of any packet losses\n    if (streamPacketIndex != (int)(lastPacketInStream + 1)) {\n        // Packets were lost so report this to the server\n        connectionLostPackets(lastPacketInStream, streamPacketIndex);\n    }\n    lastPacketInStream = streamPacketIndex;\n\n    // If this is the first packet, skip the frame header (if one exists)\n    if (firstPacket && AppVersionQuad[0] >= 5) {\n        currentPos.offset += 8;\n        currentPos.length -= 8;\n    }\n\n    if (firstPacket && isIdrFrameStart(&currentPos))\n    {\n        // SPS and PPS prefix is padded between NALs, so we must decode it with the slow path\n        processRtpPayloadSlow(videoPacket, &currentPos);\n    }\n    else",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void AverageEvalQuantizedUint8(TfLiteContext* context, TfLiteNode* node,\n                               TfLitePoolParams* params, OpData* data,\n                               const TfLiteTensor* input,\n                               TfLiteTensor* output) {\n  int32_t activation_min;\n  int32_t activation_max;\n  (void)CalculateActivationRangeQuantized(context, params->activation, output,\n                                          &activation_min, &activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                         \\\n  tflite::PoolParams op_params;                                            \\\n  op_params.stride_height = params->stride_height;                         \\\n  op_params.stride_width = params->stride_width;                           \\\n  op_params.filter_height = params->filter_height;                         \\\n  op_params.filter_width = params->filter_width;                           \\\n  op_params.padding_values.height = data->padding.height;                  \\\n  op_params.padding_values.width = data->padding.width;                    \\\n  op_params.quantized_activation_min = activation_min;                     \\\n  op_params.quantized_activation_max = activation_max;                     \\\n  type::AveragePool(op_params, GetTensorShape(input),                      \\\n                    GetTensorData<uint8_t>(input), GetTensorShape(output), \\\n                    GetTensorData<uint8_t>(output))\n  if (kernel_type == kReference) {\n    TF_LITE_AVERAGE_POOL(reference_ops);\n  } else {\n    TF_LITE_AVERAGE_POOL(optimized_ops);\n  }\n#undef TF_LITE_AVERAGE_POOL\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus AverageEvalQuantizedUint8(TfLiteContext* context, TfLiteNode* node,\n                                       TfLitePoolParams* params, OpData* data,\n                                       const TfLiteTensor* input,\n                                       TfLiteTensor* output) {\n  int32_t activation_min;\n  int32_t activation_max;\n  (void)CalculateActivationRangeQuantized(context, params->activation, output,\n                                          &activation_min, &activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                            \\\n  tflite::PoolParams op_params;                                               \\\n  op_params.stride_height = params->stride_height;                            \\\n  op_params.stride_width = params->stride_width;                              \\\n  op_params.filter_height = params->filter_height;                            \\\n  op_params.filter_width = params->filter_width;                              \\\n  op_params.padding_values.height = data->padding.height;                     \\\n  op_params.padding_values.width = data->padding.width;                       \\\n  op_params.quantized_activation_min = activation_min;                        \\\n  op_params.quantized_activation_max = activation_max;                        \\\n  TF_LITE_ENSURE(context, type::AveragePool(op_params, GetTensorShape(input), \\\n                                            GetTensorData<uint8_t>(input),    \\\n                                            GetTensorShape(output),           \\\n                                            GetTensorData<uint8_t>(output)))\n  if (kernel_type == kReference) {\n    TF_LITE_AVERAGE_POOL(reference_ops);\n  } else {\n    TF_LITE_AVERAGE_POOL(optimized_ops);\n  }\n#undef TF_LITE_AVERAGE_POOL\n  return kTfLiteOk;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void ep2_mul_naf_imp(ep2_t r, const ep2_t p, const bn_t k) {\n\tint l, i, n;\n\tint8_t naf[RLC_FP_BITS + 1];\n\tep2_t t[1 << (EP_WIDTH - 2)];\n\n\tRLC_TRY {\n\t\t/* Prepare the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep2_null(t[i]);\n\t\t\tep2_new(t[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\tep2_tab(t, p, EP_WIDTH);\n\n\t\t/* Compute the w-NAF representation of k. */\n\t\tl = sizeof(naf);\n\t\tbn_rec_naf(naf, &l, k, EP_WIDTH);\n\n\t\tep2_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tep2_dbl(r, r);\n\n\t\t\tn = naf[i];\n\t\t\tif (n > 0) {\n\t\t\t\tep2_add(r, r, t[n / 2]);\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\tep2_sub(r, r, t[-n / 2]);\n\t\t\t}\n\t\t}\n\t\tep2_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation table. */\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep2_free(t[i]);\n\t\t}\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void ep2_mul_naf_imp(ep2_t r, const ep2_t p, const bn_t k) {\n\tsize_t l, n;\n\tint8_t naf[RLC_FP_BITS + 1];\n\tep2_t t[1 << (EP_WIDTH - 2)];\n\n\tRLC_TRY {\n\t\t/* Prepare the precomputation table. */\n\t\tfor (int i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep2_null(t[i]);\n\t\t\tep2_new(t[i]);\n\t\t}\n\t\t/* Compute the precomputation table. */\n\t\tep2_tab(t, p, EP_WIDTH);\n\n\t\t/* Compute the w-NAF representation of k. */\n\t\tl = sizeof(naf);\n\t\tbn_rec_naf(naf, &l, k, EP_WIDTH);\n\n\t\tep2_set_infty(r);\n\t\tfor (int i = l - 1; i >= 0; i--) {\n\t\t\tep2_dbl(r, r);\n\n\t\t\tn = naf[i];\n\t\t\tif (n > 0) {\n\t\t\t\tep2_add(r, r, t[n / 2]);\n\t\t\t}\n\t\t\tif (n < 0) {\n\t\t\t\tep2_sub(r, r, t[-n / 2]);\n\t\t\t}\n\t\t}\n\t\tep2_norm(r, r);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t/* Free the precomputation table. */\n\t\tfor (int i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep2_free(t[i]);\n\t\t}\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tctxt->ops->put_fpu(ctxt);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (ctxt->ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR)\n\t\tsize = offsetof(struct fxregs_state, xmm_space[8 * 16/4]);\n\telse\n\t\tsize = offsetof(struct fxregs_state, xmm_space[0]);\n\n\treturn segmented_write(ctxt, ctxt->memop.addr.mem, &fx_state, size);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tctxt->ops->put_fpu(ctxt);\n\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\tif (ctxt->ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR)\n\t\tsize = offsetof(struct fxregs_state, xmm_space[8 * 16/4]);\n\telse\n\t\tsize = offsetof(struct fxregs_state, xmm_space[0]);\n\n\treturn segmented_write_std(ctxt, ctxt->memop.addr.mem, &fx_state, size);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static pj_status_t respond_digest( pj_pool_t *pool,\n\t\t\t\t   pjsip_digest_credential *cred,\n\t\t\t\t   const pjsip_digest_challenge *chal,\n\t\t\t\t   const pj_str_t *uri,\n\t\t\t\t   const pjsip_cred_info *cred_info,\n\t\t\t\t   const pj_str_t *cnonce,\n\t\t\t\t   pj_uint32_t nc,\n\t\t\t\t   const pj_str_t *method)\n{\n    const pj_str_t pjsip_AKAv1_MD5_STR = { \"AKAv1-MD5\", 9 };\n    pj_bool_t algo_sha256 = PJ_FALSE;\n\n    /* Check if algo is sha256 */\n#if PJSIP_AUTH_HAS_DIGEST_SHA256\n    algo_sha256 = (pj_stricmp(&chal->algorithm, &pjsip_SHA256_STR)==0);\n#endif\n\n    /* Check algorithm is supported. We support MD5, AKAv1-MD5, and SHA256. */\n    if (chal->algorithm.slen==0 ||\n        (algo_sha256 ||\n\t pj_stricmp(&chal->algorithm, &pjsip_MD5_STR)==0 ||\n\t/* Server doesn't require quality of protection. */\n\n\tif ((cred_info->data_type & EXT_MASK) == PJSIP_CRED_DATA_EXT_AKA) {\n\t    /* Call application callback to create the response digest */\n\t    return (*cred_info->ext.aka.cb)(pool, chal, cred_info,\n\t\t\t\t\t    method, cred);\n\t}\n\telse {\n\t    /* Convert digest to string and store in chal->response. */\n\t    if (algo_sha256) {\n\t\tpjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &cred->response, &cred->nonce, NULL,\n\t\t\t\t\t  NULL,  NULL, uri, &chal->realm,\n\t\t\t\t\t  cred_info, method);\n\t    } else {\n\t\tpjsip_auth_create_digest( &cred->response, &cred->nonce, NULL,\n\t\t\t\t\t  NULL,  NULL, uri, &chal->realm,\n\t\t\t\t\t  cred_info, method);\n\t    }\n\t}\n\n    } else if (has_auth_qop(pool, &chal->qop)) {\n\t/* Server requires quality of protection.\n\t * We respond with selecting \"qop=auth\" protection.\n\t */\n\tcred->qop = pjsip_AUTH_STR;\n\tcred->nc.ptr = (char*) pj_pool_alloc(pool, 16);\n\tcred->nc.slen = pj_ansi_snprintf(cred->nc.ptr, 16, \"%08u\", nc);\n\t}\n\n\tif ((cred_info->data_type & EXT_MASK) == PJSIP_CRED_DATA_EXT_AKA) {\n\t    /* Call application callback to create the response digest */\n\t    return (*cred_info->ext.aka.cb)(pool, chal, cred_info,\n\t\t\t\t\t    method, cred);\n\t}\n\telse {\n\t    /* Convert digest to string and store in chal->response. */\n\t    if (algo_sha256) {\n\t\tpjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &cred->response, &cred->nonce,\n\t\t\t\t\t  &cred->nc, &cred->cnonce,\n\t\t\t\t\t  &pjsip_AUTH_STR, uri,\n\t\t\t\t\t  &chal->realm, cred_info,\n\t\t\t\t\t  method);\n\t    } else {\n\t\tpjsip_auth_create_digest( &cred->response, &cred->nonce,\n\t\t\t\t\t  &cred->nc, &cred->cnonce,\n\t\t\t\t\t  &pjsip_AUTH_STR, uri,\n\t\t\t\t\t  &chal->realm, cred_info,\n\t\t\t\t\t  method);\n\t    }\n\t}\n\n    } else {\n\t/* Server requires quality protection that we don't support. */\n\tPJ_LOG(4,(THIS_FILE, \"Unsupported qop offer %.*s\",\n\t\t  chal->qop.slen, chal->qop.ptr));\n\treturn PJSIP_EINVALIDQOP;\n    }\n\n    return PJ_SUCCESS;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\t\t   pjsip_digest_credential *cred,\n\t\t\t\t   const pjsip_digest_challenge *chal,\n\t\t\t\t   const pj_str_t *uri,\n\t\t\t\t   const pjsip_cred_info *cred_info,\n\t\t\t\t   const pj_str_t *cnonce,\n\t\t\t\t   pj_uint32_t nc,\n\t\t\t\t   const pj_str_t *method)\n{\n    const pj_str_t pjsip_AKAv1_MD5_STR = { \"AKAv1-MD5\", 9 };\n    pj_bool_t algo_sha256 = PJ_FALSE;\n    pj_status_t status = PJ_SUCCESS;\n\n    /* Check if algo is sha256 */\n#if PJSIP_AUTH_HAS_DIGEST_SHA256\n    algo_sha256 = (pj_stricmp(&chal->algorithm, &pjsip_SHA256_STR)==0);\n#endif\n\n    /* Check algorithm is supported. We support MD5, AKAv1-MD5, and SHA256. */\n    if (chal->algorithm.slen==0 ||\n        (algo_sha256 ||\n\t pj_stricmp(&chal->algorithm, &pjsip_MD5_STR)==0 ||\n\t/* Server doesn't require quality of protection. */\n\n\tif ((cred_info->data_type & EXT_MASK) == PJSIP_CRED_DATA_EXT_AKA) {\n\t    /* Call application callback to create the response digest */\n\t    return (*cred_info->ext.aka.cb)(pool, chal, cred_info,\n\t\t\t\t\t    method, cred);\n\t}\n\telse {\n\t    /* Convert digest to string and store in chal->response. */\n\t    if (algo_sha256) {\n\t\tstatus = pjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &cred->response, &cred->nonce, NULL,\n\t\t\t\t\t  NULL,  NULL, uri, &chal->realm,\n\t\t\t\t\t  cred_info, method);\n\t    } else {\n\t\tstatus = pjsip_auth_create_digest( &cred->response, \n\t\t\t\t\t  &cred->nonce, NULL, NULL, NULL, uri, \n\t\t\t\t\t  &chal->realm, cred_info, method);\n\t    }\n\t}\n\n    } else if (has_auth_qop(pool, &chal->qop)) {\n\t/* Server requires quality of protection.\n\t * We respond with selecting \"qop=auth\" protection.\n\t */\n\tcred->qop = pjsip_AUTH_STR;\n\tcred->nc.ptr = (char*) pj_pool_alloc(pool, 16);\n\tcred->nc.slen = pj_ansi_snprintf(cred->nc.ptr, 16, \"%08u\", nc);\n\t}\n\n\tif ((cred_info->data_type & EXT_MASK) == PJSIP_CRED_DATA_EXT_AKA) {\n\t    /* Call application callback to create the response digest */\n\t    return (*cred_info->ext.aka.cb)(pool, chal, cred_info,\n\t\t\t\t\t    method, cred);\n\t}\n\telse {\n\t    /* Convert digest to string and store in chal->response. */\n\t    if (algo_sha256) {\n\t\tstatus = pjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &cred->response, &cred->nonce,\n\t\t\t\t\t  &cred->nc, &cred->cnonce,\n\t\t\t\t\t  &pjsip_AUTH_STR, uri,\n\t\t\t\t\t  &chal->realm, cred_info,\n\t\t\t\t\t  method);\n\t    } else {\n\t\tstatus = pjsip_auth_create_digest( &cred->response, \n\t\t\t\t\t  &cred->nonce, &cred->nc, \n\t\t\t\t          &cred->cnonce, &pjsip_AUTH_STR, \n\t\t\t\t\t  uri, &chal->realm, \n\t\t\t\t\t  cred_info, method);\n\t    }\n\t}\n\n    } else {\n\t/* Server requires quality protection that we don't support. */\n\tPJ_LOG(4,(THIS_FILE, \"Unsupported qop offer %.*s\",\n\t\t  chal->qop.slen, chal->qop.ptr));\n\treturn PJSIP_EINVALIDQOP;\n    }\n\n    return status;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t\t      IPSTATS_MIB_FRAGFAILS);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t__skb_pull(skb, hlen);\n\t\tfh = (struct frag_hdr*)__skb_push(skb, sizeof(struct frag_hdr));\n\t\t__skb_push(skb, hlen);\n\t\tskb_reset_network_header(skb);\n\t\tmemcpy(skb_network_header(skb), tmp_hdr, hlen);\n\n\t\tipv6_select_ident(fh);\n\t\tfh->nexthdr = nexthdr;\n\t\tfh->reserved = 0;\n\t\tfh->frag_off = htons(IP6_MF);\n\t\tfrag_id = fh->identification;\n\n\t\tfirst_len = skb_pagelen(skb);\n\t\tskb->data_len = first_len - skb_headlen(skb);\n\t\tskb->len = first_len;\n\t\tipv6_hdr(skb)->payload_len = htons(first_len -\n\t\t\t\t\t\t   sizeof(struct ipv6hdr));\n\t\t *\tCopy the packet header into the new buffer.\n\t\t */\n\t\tskb_copy_from_linear_data(skb, skb_network_header(frag), hlen);\n\n\t\t/*\n\t\t *\tBuild fragment header.\n\t\t */\n\t\tfh->nexthdr = nexthdr;\n\t\tfh->reserved = 0;\n\t\tif (!frag_id) {\n\t\t\tipv6_select_ident(fh);\n\t\t\tfrag_id = fh->identification;\n\t\t} else\n\t\t\tfh->identification = frag_id;\n\n\t\t/*\n\t\t *\tCopy a block of the IP datagram.\n\t\t */\n\t\tif (skb_copy_bits(skb, ptr, skb_transport_header(frag), len))\n\t\t\tBUG();\n\t\tleft -= len;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\t\t      IPSTATS_MIB_FRAGFAILS);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t__skb_pull(skb, hlen);\n\t\tfh = (struct frag_hdr*)__skb_push(skb, sizeof(struct frag_hdr));\n\t\t__skb_push(skb, hlen);\n\t\tskb_reset_network_header(skb);\n\t\tmemcpy(skb_network_header(skb), tmp_hdr, hlen);\n\n\t\tipv6_select_ident(fh, rt);\n\t\tfh->nexthdr = nexthdr;\n\t\tfh->reserved = 0;\n\t\tfh->frag_off = htons(IP6_MF);\n\t\tfrag_id = fh->identification;\n\n\t\tfirst_len = skb_pagelen(skb);\n\t\tskb->data_len = first_len - skb_headlen(skb);\n\t\tskb->len = first_len;\n\t\tipv6_hdr(skb)->payload_len = htons(first_len -\n\t\t\t\t\t\t   sizeof(struct ipv6hdr));\n\t\t *\tCopy the packet header into the new buffer.\n\t\t */\n\t\tskb_copy_from_linear_data(skb, skb_network_header(frag), hlen);\n\n\t\t/*\n\t\t *\tBuild fragment header.\n\t\t */\n\t\tfh->nexthdr = nexthdr;\n\t\tfh->reserved = 0;\n\t\tif (!frag_id) {\n\t\t\tipv6_select_ident(fh, rt);\n\t\t\tfrag_id = fh->identification;\n\t\t} else\n\t\t\tfh->identification = frag_id;\n\n\t\t/*\n\t\t *\tCopy a block of the IP datagram.\n\t\t */\n\t\tif (skb_copy_bits(skb, ptr, skb_transport_header(frag), len))\n\t\t\tBUG();\n\t\tleft -= len;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int persistent_prepare_exception(struct dm_exception_store *store,\n\t\t\t\t\tstruct dm_exception *e)\n{\n\tstruct pstore *ps = get_info(store);\n\tuint32_t stride;\n\tchunk_t next_free;\n\tsector_t size = get_dev_size(dm_snap_cow(store->snap)->bdev);\n\n\t/* Is there enough room ? */\n\tif (size < ((ps->next_free + 1) * store->chunk_size))\n\t\treturn -ENOSPC;\n\n\te->new_chunk = ps->next_free;\n\n\t/*\n\t * Move onto the next free pending, making sure to take\n\t * into account the location of the metadata chunks.\n\t */\n\tstride = (ps->exceptions_per_area + 1);\n\tnext_free = ++ps->next_free;\n\tif (sector_div(next_free, stride) == 1)\n\t\tps->next_free++;\n\n\tatomic_inc(&ps->pending_count);\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int persistent_prepare_exception(struct dm_exception_store *store,\n\t\t\t\t\tstruct dm_exception *e)\n{\n\tstruct pstore *ps = get_info(store);\n\tsector_t size = get_dev_size(dm_snap_cow(store->snap)->bdev);\n\n\t/* Is there enough room ? */\n\tif (size < ((ps->next_free + 1) * store->chunk_size))\n\t\treturn -ENOSPC;\n\n\te->new_chunk = ps->next_free;\n\n\t/*\n\t * Move onto the next free pending, making sure to take\n\t * into account the location of the metadata chunks.\n\t */\n\tps->next_free++;\n\tskip_metadata(ps);\n\n\tatomic_inc(&ps->pending_count);\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "{\n\tBYTE c;\n\tBYTE flags;\n\tUINT32 extra = 0;\n\tint opIndex;\n\tint haveBits;\n\tint inPrefix;\n\tUINT32 count;\n\tUINT32 distance;\n\tBYTE* pbSegment;\n\tsize_t cbSegment = segmentSize - 1;\n\n\tif ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1))\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(stream, flags); /* header (1 byte) */\n\tzgfx->OutputCount = 0;\n\tpbSegment = Stream_Pointer(stream);\n\tStream_Seek(stream, cbSegment);\n\n\tif (!(flags & PACKET_COMPRESSED))\n\t{\n\t\tzgfx_history_buffer_ring_write(zgfx, pbSegment, cbSegment);\n\t\tCopyMemory(zgfx->OutputBuffer, pbSegment, cbSegment);\n\t\tzgfx->OutputCount = cbSegment;\n\t\treturn TRUE;\n\t}\n\n\tzgfx->pbInputCurrent = pbSegment;\n\tzgfx->pbInputEnd = &pbSegment[cbSegment - 1];\n\t/* NumberOfBitsToDecode = ((NumberOfBytesToDecode - 1) * 8) - ValueOfLastByte */\n\tzgfx->cBitsRemaining = 8 * (cbSegment - 1) - *zgfx->pbInputEnd;\n\tzgfx->cBitsCurrent = 0;\n\t\t\t{\n\t\t\t\tif (ZGFX_TOKEN_TABLE[opIndex].tokenType == 0)\n\t\t\t\t{\n\t\t\t\t\t/* Literal */\n\t\t\t\t\tzgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);\n\t\t\t\t\tc = (BYTE)(ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits);\n\t\t\t\t\tzgfx->HistoryBuffer[zgfx->HistoryIndex] = c;\n\n\t\t\t\t\tif (++zgfx->HistoryIndex == zgfx->HistoryBufferSize)\n\t\t\t\t\t\tzgfx->HistoryIndex = 0;\n\n\t\t\t\t\tzgfx->OutputBuffer[zgfx->OutputCount++] = c;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tzgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);\n\t\t\t\t\tdistance = ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits;\n\n\t\t\t\t\tif (distance != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Match */\n\t\t\t\t\t\t\twhile (zgfx->bits == 1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcount *= 2;\n\t\t\t\t\t\t\t\textra++;\n\t\t\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tzgfx_GetBits(zgfx, extra);\n\t\t\t\t\t\t\tcount += zgfx->bits;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tzgfx_history_buffer_ring_read(zgfx, distance, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);\n\t\t\t\t\t\tzgfx_history_buffer_ring_write(zgfx, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);\n\t\t\t\t\t\tzgfx->OutputCount += count;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Unencoded */\n\t\t\t\t\t\tzgfx_GetBits(zgfx, 15);\n\t\t\t\t\t\tcount = zgfx->bits;\n\t\t\t\t\t\tzgfx->cBitsRemaining -= zgfx->cBitsCurrent;\n\t\t\t\t\t\tzgfx->cBitsCurrent = 0;\n\t\t\t\t\t\tzgfx->BitsCurrent = 0;\n\t\t\t\t\t\tCopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]), zgfx->pbInputCurrent, count);\n\t\t\t\t\t\tzgfx_history_buffer_ring_write(zgfx, zgfx->pbInputCurrent, count);\n\t\t\t\t\t\tzgfx->pbInputCurrent += count;\n\t\t\t\t\t\tzgfx->cBitsRemaining -= (8 * count);\n\t\t\t\t\t\tzgfx->OutputCount += count;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "{\n\tBYTE c;\n\tBYTE flags;\n\tUINT32 extra = 0;\n\tint opIndex;\n\tint haveBits;\n\tint inPrefix;\n\tUINT32 count;\n\tUINT32 distance;\n\tBYTE* pbSegment;\n\tsize_t cbSegment;\n\n\tif (!zgfx || !stream)\n\t\treturn FALSE;\n\n\tcbSegment = segmentSize - 1;\n\n\tif ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1) ||\n\t    (segmentSize > UINT32_MAX))\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(stream, flags); /* header (1 byte) */\n\tzgfx->OutputCount = 0;\n\tpbSegment = Stream_Pointer(stream);\n\tStream_Seek(stream, cbSegment);\n\n\tif (!(flags & PACKET_COMPRESSED))\n\t{\n\t\tzgfx_history_buffer_ring_write(zgfx, pbSegment, cbSegment);\n\n\t\tif (cbSegment > sizeof(zgfx->OutputBuffer))\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(zgfx->OutputBuffer, pbSegment, cbSegment);\n\t\tzgfx->OutputCount = cbSegment;\n\t\treturn TRUE;\n\t}\n\n\tzgfx->pbInputCurrent = pbSegment;\n\tzgfx->pbInputEnd = &pbSegment[cbSegment - 1];\n\t/* NumberOfBitsToDecode = ((NumberOfBytesToDecode - 1) * 8) - ValueOfLastByte */\n\tzgfx->cBitsRemaining = 8 * (cbSegment - 1) - *zgfx->pbInputEnd;\n\tzgfx->cBitsCurrent = 0;\n\t\t\t\tif (ZGFX_TOKEN_TABLE[opIndex].tokenType == 0)\n\t\t\t\t{\n\t\t\t\t\t/* Literal */\n\t\t\t\t\tzgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);\n\t\t\t\t\tc = (BYTE)(ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits);\n\t\t\t\t\tzgfx->HistoryBuffer[zgfx->HistoryIndex] = c;\n\n\t\t\t\t\tif (++zgfx->HistoryIndex == zgfx->HistoryBufferSize)\n\t\t\t\t\t\tzgfx->HistoryIndex = 0;\n\n\t\t\t\t\tif (zgfx->OutputCount >= sizeof(zgfx->OutputBuffer))\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tzgfx->OutputBuffer[zgfx->OutputCount++] = c;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tzgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);\n\t\t\t\t\tdistance = ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits;\n\n\t\t\t\t\tif (distance != 0)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Match */\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcount *= 2;\n\t\t\t\t\t\t\t\textra++;\n\t\t\t\t\t\t\t\tzgfx_GetBits(zgfx, 1);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tzgfx_GetBits(zgfx, extra);\n\t\t\t\t\t\t\tcount += zgfx->bits;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tzgfx_history_buffer_ring_read(zgfx, distance, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);\n\t\t\t\t\t\tzgfx_history_buffer_ring_write(zgfx, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);\n\t\t\t\t\t\tzgfx->OutputCount += count;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t/* Unencoded */\n\t\t\t\t\t\tzgfx_GetBits(zgfx, 15);\n\t\t\t\t\t\tcount = zgfx->bits;\n\t\t\t\t\t\tzgfx->cBitsRemaining -= zgfx->cBitsCurrent;\n\t\t\t\t\t\tzgfx->cBitsCurrent = 0;\n\t\t\t\t\t\tzgfx->BitsCurrent = 0;\n\n\t\t\t\t\t\tif (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tCopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]), zgfx->pbInputCurrent, count);\n\t\t\t\t\t\tzgfx_history_buffer_ring_write(zgfx, zgfx->pbInputCurrent, count);\n\t\t\t\t\t\tzgfx->pbInputCurrent += count;\n\t\t\t\t\t\tzgfx->cBitsRemaining -= (8 * count);\n\t\t\t\t\t\tzgfx->OutputCount += count;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Obj *obj = _this->d.obj;\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    if (!seq) {\n        goto bail;\n    }\n    \n    n = Jsi_ObjGetLength(interp, obj);    \n    if (n == 0) {\n        goto bail;\n    }\n    Jsi_Number nstart;\n    if (op == 2) {\n        istart = n-1;\n    }\n    if (start && Jsi_GetNumberFromValue(interp,start, &nstart)==JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1);\n    Jsi_Obj *obj = _this->d.obj;\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    if (!seq) {\n        goto bail;\n    }\n    \n    n = jsi_SizeOfArray(interp, obj);    \n    if (n == 0) {\n        goto bail;\n    }\n    Jsi_Number nstart;\n    if (op == 2) {\n        istart = n-1;\n    }\n    if (start && Jsi_GetNumberFromValue(interp,start, &nstart)==JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tret = -EINVAL;\n\t\tgoto out_mutex;\n\t}\n\n\t/* Currently just for extent based files */\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_mutex;\n\t}\n\n\ttruncate_pagecache(inode, ioffset);\n\n\t/* Wait for existing dio to complete */\n\text4_inode_block_unlocked_dio(inode);\n\tinode_dio_wait(inode);\n\n\tcredits = ext4_writepage_trans_blocks(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out_dio;\n\t}\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\tret = ext4_es_remove_extent(inode, punch_start,\n\t\t\t\t    EXT_MAX_BLOCKS - punch_start);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\tEXT4_I(inode)->i_disksize = new_size;\n\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\nout_stop:\n\text4_journal_stop(handle);\nout_dio:\n\text4_inode_resume_unlocked_dio(inode);\nout_mutex:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tif (offset + len >= i_size_read(inode)) {\n\t\tret = -EINVAL;\n\t\tgoto out_mutex;\n\t}\n\n\t/* Currently just for extent based files */\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_mutex;\n\t}\n\n\t/* Wait for existing dio to complete */\n\text4_inode_block_unlocked_dio(inode);\n\tinode_dio_wait(inode);\n\n\t/*\n\t * Prevent page faults from reinstantiating pages we have released from\n\t * page cache.\n\t */\n\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\ttruncate_pagecache(inode, ioffset);\n\n\tcredits = ext4_writepage_trans_blocks(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out_mmap;\n\t}\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\tret = ext4_es_remove_extent(inode, punch_start,\n\t\t\t\t    EXT_MAX_BLOCKS - punch_start);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\tEXT4_I(inode)->i_disksize = new_size;\n\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\nout_stop:\n\text4_journal_stop(handle);\nout_mmap:\n\tup_write(&EXT4_I(inode)->i_mmap_sem);\n\text4_inode_resume_unlocked_dio(inode);\nout_mutex:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void controloptions (lua_State *L, int opt, const char **fmt,\n                            Header *h) {\n  switch (opt) {\n    case  ' ': return;  /* ignore white spaces */\n    case '>': h->endian = BIG; return;\n    case '<': h->endian = LITTLE; return;\n    case '!': {\n      int a = getnum(L, fmt, MAXALIGN);\n      if (!isp2(a))\n        luaL_error(L, \"alignment %d is not a power of 2\", a);\n      h->align = a;\n      return;\n    }\n    default: {\n      const char *msg = lua_pushfstring(L, \"invalid format option '%c'\", opt);\n      luaL_argerror(L, 1, msg);\n    }\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void controloptions (lua_State *L, int opt, const char **fmt,\n                            Header *h) {\n  switch (opt) {\n    case  ' ': return;  /* ignore white spaces */\n    case '>': h->endian = BIG; return;\n    case '<': h->endian = LITTLE; return;\n    case '!': {\n      int a = getnum(fmt, MAXALIGN);\n      if (!isp2(a))\n        luaL_error(L, \"alignment %d is not a power of 2\", a);\n      h->align = a;\n      return;\n    }\n    default: {\n      const char *msg = lua_pushfstring(L, \"invalid format option '%c'\", opt);\n      luaL_argerror(L, 1, msg);\n    }\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TfLiteStatus GreaterEqualEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  bool requires_broadcast = !HaveSameShapes(input1, input2);\n  switch (input1->type) {\n    case kTfLiteFloat32:\n      Comparison<float, reference_ops::GreaterEqualFn>(input1, input2, output,\n                                                       requires_broadcast);\n      break;\n    case kTfLiteInt32:\n      Comparison<int32_t, reference_ops::GreaterEqualFn>(input1, input2, output,\n                                                         requires_broadcast);\n      break;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus GreaterEqualEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  bool requires_broadcast = !HaveSameShapes(input1, input2);\n  switch (input1->type) {\n    case kTfLiteFloat32:\n      Comparison<float, reference_ops::GreaterEqualFn>(input1, input2, output,\n                                                       requires_broadcast);\n      break;\n    case kTfLiteInt32:\n      Comparison<int32_t, reference_ops::GreaterEqualFn>(input1, input2, output,\n                                                         requires_broadcast);\n      break;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void decodingXOR(char* extractedString, char* keyString, char* xoredString, int bufferLength)\n{\n\tint i;\n\n\tif(isCodingInverted){\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n\t\t}\n\t}else{\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n\t\t}\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void decodingXOR(char* extractedString, char* keyString, char* xoredString, int bufferLength)\n{\n\tint i;\n\tchar* tablenumber;\n\n\tif(usingKeyFile){\n\t\ttablenumber = scramblingTablesOrder;\n\t}else{\n\t\ttablenumber = keyString;\n\t}\n\n\tif(isCodingInverted){\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[tablenumber[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n\t\t}\n\t}else{\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[tablenumber[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n\t\t}\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "                                  int *got_frame, uint8_t *data_start,\n                                  unsigned int data_size)\n{\n    WebPContext *s = avctx->priv_data;\n    AVPacket pkt;\n    int ret;\n\n    if (!s->initialized) {\n        ff_vp8_decode_init(avctx);\n        s->initialized = 1;\n        if (s->has_alpha)\n            avctx->pix_fmt = AV_PIX_FMT_YUVA420P;\n    }\n    s->lossless = 0;\n\n    if (data_size > INT_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    av_init_packet(&pkt);\n    pkt.data = data_start;\n    pkt.size = data_size;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int vp8_lossy_decode_frame(AVCodecContext *avctx, AVFrame *p,\n                                  int *got_frame, uint8_t *data_start,\n                                  unsigned int data_size)\n{\n    WebPContext *s = avctx->priv_data;\n    AVPacket pkt;\n    int ret;\n\n    if (!s->initialized) {\n        ff_vp8_decode_init(avctx);\n        s->initialized = 1;\n    }\n    avctx->pix_fmt = s->has_alpha ? AV_PIX_FMT_YUVA420P : AV_PIX_FMT_YUV420P;\n    s->lossless = 0;\n\n    if (data_size > INT_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    av_init_packet(&pkt);\n    pkt.data = data_start;\n    pkt.size = data_size;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( strlen( params ) ) { // add a space between each param\n\t\t\t\t\tQ_strcat( params, sizeof( params ), \" \" );\n\t\t\t\t}\n\t\t\t\tQ_strcat( params, sizeof( params ), token );\n\t\t\t}\n\n\t\t\tif ( strlen( params ) ) { // copy the params into the event\n\t\t\t\tcurEvent->params = G_Alloc( strlen( params ) + 1 );\n\t\t\t\tQ_strncpyz( curEvent->params, params, strlen( params ) + 1 );\n\t\t\t}\n\n\t\t\t// parse the actions for this event\n\t\t\twhile ( ( token = COM_Parse( &pScript ) ) && ( token[0] != '}' ) )\n\t\t\t{\n\t\t\t\tif ( !token[0] ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t\t}\n\n\t\t\t\t\tQ_strcat( params, sizeof( params ), token );\n\n\t\t\t\t\tif ( strrchr( token,' ' ) ) { // need to wrap this param in quotes since it has more than one word\n\t\t\t\t\t\tQ_strcat( params, sizeof( params ), \"\\\"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\ttoken = COM_ParseExt( &pScript, qfalse );\n\t\t\t\t}\n\n\t\t\t\tif ( strlen( params ) ) { // copy the params into the event\n\t\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].params = G_Alloc( strlen( params ) + 1 );\n\t\t\t\t\tQ_strncpyz( curEvent->stack.items[curEvent->stack.numItems].params, params, strlen( params ) + 1 );\n\t\t\t\t}\n\n\t\t\t\tcurEvent->stack.numItems++;\n\n\t\t\t\tif ( curEvent->stack.numItems >= AICAST_MAX_SCRIPT_STACK_ITEMS ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(): script exceeded MAX_SCRIPT_ITEMS (%d), line %d\\n\", AICAST_MAX_SCRIPT_STACK_ITEMS, COM_GetCurrentParseLine() );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\t\tif ( !--bracketLevel ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// alloc and copy the events into the cast_state_t for this cast\n\tif ( numEventItems > 0 ) {\n\t\tcs->castScriptEvents = G_Alloc( sizeof( cast_script_event_t ) * numEventItems );\n\t\tmemcpy( cs->castScriptEvents, cast_temp_events, sizeof( cast_script_event_t ) * numEventItems );\n\t\tcs->numCastScriptEvents = numEventItems;\n\n\t\tcs->castScriptStatus.castScriptEventIndex = -1;\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( strlen( params ) ) { // add a space between each param\n\t\t\t\t\tQ_strcat( params, sizeof( params ), \" \" );\n\t\t\t\t}\n\t\t\t\tQ_strcat( params, sizeof( params ), token );\n\t\t\t}\n\n\t\t\tif ( strlen( params ) ) { // copy the params into the event\n\t\t\t\tcurEvent->params = trap_Alloc( strlen( params ) + 1 );\n\t\t\t\tQ_strncpyz( curEvent->params, params, strlen( params ) + 1 );\n\t\t\t}\n\n\t\t\t// parse the actions for this event\n\t\t\twhile ( ( token = COM_Parse( &pScript ) ) && ( token[0] != '}' ) )\n\t\t\t{\n\t\t\t\tif ( !token[0] ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\\n\", COM_GetCurrentParseLine() );\n\t\t\t\t}\n\n\t\t\t\t\tQ_strcat( params, sizeof( params ), token );\n\n\t\t\t\t\tif ( strrchr( token,' ' ) ) { // need to wrap this param in quotes since it has more than one word\n\t\t\t\t\t\tQ_strcat( params, sizeof( params ), \"\\\"\" );\n\t\t\t\t\t}\n\n\t\t\t\t\ttoken = COM_ParseExt( &pScript, qfalse );\n\t\t\t\t}\n\n\t\t\t\tif ( strlen( params ) ) { // copy the params into the event\n\t\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].params = trap_Alloc( strlen( params ) + 1 );\n\t\t\t\t\tQ_strncpyz( curEvent->stack.items[curEvent->stack.numItems].params, params, strlen( params ) + 1 );\n\t\t\t\t}\n\n\t\t\t\tcurEvent->stack.numItems++;\n\n\t\t\t\tif ( curEvent->stack.numItems >= AICAST_MAX_SCRIPT_STACK_ITEMS ) {\n\t\t\t\t\tG_Error( \"AICast_ScriptParse(): script exceeded MAX_SCRIPT_ITEMS (%d), line %d\\n\", AICAST_MAX_SCRIPT_STACK_ITEMS, COM_GetCurrentParseLine() );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\t\tif ( !--bracketLevel ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// alloc and copy the events into the cast_state_t for this cast\n\tif ( numEventItems > 0 ) {\n\t\tcs->castScriptEvents = trap_Alloc( sizeof( cast_script_event_t ) * numEventItems );\n\t\tmemcpy( cs->castScriptEvents, cast_temp_events, sizeof( cast_script_event_t ) * numEventItems );\n\t\tcs->numCastScriptEvents = numEventItems;\n\n\t\tcs->castScriptStatus.castScriptEventIndex = -1;\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int nfs4_intent_set_file(struct nameidata *nd, struct path *path, struct nfs4_state *state)\n{\n\tstruct file *filp;\n\tint ret;\n\n\t/* If the open_intent is for execute, we have an extra check to make */\n\tif (nd->intent.open.flags & FMODE_EXEC) {\n\t\tret = nfs_may_open(state->inode,\n\t\t\t\tstate->owner->so_cred,\n\t\t\t\tnd->intent.open.flags);\n\t\tif (ret < 0)\n\t\t\tgoto out_close;\n\t}\n\tfilp = lookup_instantiate_filp(nd, path->dentry, NULL);\n\tif (!IS_ERR(filp)) {\n\t\tstruct nfs_open_context *ctx;\n\t\tctx = nfs_file_open_context(filp);\n\t\tctx->state = state;\n\t\treturn 0;\n\t}\n\tret = PTR_ERR(filp);\nout_close:\n\tnfs4_close_sync(path, state, nd->intent.open.flags);\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int nfs4_intent_set_file(struct nameidata *nd, struct path *path, struct nfs4_state *state, fmode_t fmode)\n{\n\tstruct file *filp;\n\tint ret;\n\n\t/* If the open_intent is for execute, we have an extra check to make */\n\tif (fmode & FMODE_EXEC) {\n\t\tret = nfs_may_open(state->inode,\n\t\t\t\tstate->owner->so_cred,\n\t\t\t\tnd->intent.open.flags);\n\t\tif (ret < 0)\n\t\t\tgoto out_close;\n\t}\n\tfilp = lookup_instantiate_filp(nd, path->dentry, NULL);\n\tif (!IS_ERR(filp)) {\n\t\tstruct nfs_open_context *ctx;\n\t\tctx = nfs_file_open_context(filp);\n\t\tctx->state = state;\n\t\treturn 0;\n\t}\n\tret = PTR_ERR(filp);\nout_close:\n\tnfs4_close_sync(path, state, fmode & (FMODE_READ|FMODE_WRITE));\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);\n\n\t\t\treturn_len = block_size;\n\t\t\tif (padding) {\n\t\t\t\t/* check padding */\n\t\t\t\tuint8_t i, pad_byte = *(priv->sym_plain_buffer + block_size - 1);\n\n\t\t\t\tsc_log(ctx, \"Found padding byte %02x\", pad_byte);\n\t\t\t\tif (pad_byte == 0 || pad_byte > block_size)\n\t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);\n\t\t\t\tsdata = priv->sym_plain_buffer + block_size - pad_byte;\n\t\t\t\tfor (i = 0; i < pad_byte; i++)\n\t\t\t\t\tif (sdata[i] != pad_byte)\n\t\t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);\n\t\t\t\treturn_len = block_size - pad_byte;\n\t\t\t}\n\t\t\t*outlen = return_len;\n\t\t\t/* application can request buffer size or actual buffer size is too small */\n\t\t\tif (out == NULL)\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t\t\tif (return_len > *outlen)\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);\n\t\t\tmemcpy(out, priv->sym_plain_buffer, return_len);\n\t\t\tsc_log(ctx, \"C_DecryptFinal %zu bytes\", *outlen);\n\t\t\treturn SC_SUCCESS;\n\t\t} else {\n\t\t\t/* C_EncryptFinalize */\n\t\t\tif (padding) {\n\t\t\t\tuint8_t pad_byte = block_size - rest_len;\n\t\t\t\tsc_log(ctx, \"Generating padding, padding byte: %d\", pad_byte);\n\t\t\t\tsdata = priv->sym_crypt_buffer + rest_len;\n\t\t\t\tmemset(sdata, pad_byte, pad_byte);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_LENGTH);\n\n\t\t\treturn_len = block_size;\n\t\t\tif (padding) {\n\t\t\t\t/* check padding */\n\t\t\t\tuint8_t i, pad_byte = *(priv->sym_plain_buffer + block_size - 1);\n\n\t\t\t\tsc_log(ctx, \"Found padding byte %02x\", pad_byte);\n\t\t\t\tif (pad_byte == 0 || pad_byte > block_size)\n\t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);\n\t\t\t\tsdata = priv->sym_plain_buffer + block_size;\n\t\t\t\tfor (i = 0; i < pad_byte; i++)\n\t\t\t\t\tif (*(--sdata) != pad_byte)\n\t\t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);\n\t\t\t\treturn_len = block_size - pad_byte;\n\t\t\t}\n\t\t\t/* application can request buffer size or actual buffer size is too small */\n\t\t\tif (out == NULL) {\n\t\t\t\t*outlen = return_len;\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t\t\t}\n\t\t\tif (return_len > *outlen)\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);\n\t\t\t*outlen = return_len;\n\t\t\tmemcpy(out, priv->sym_plain_buffer, return_len);\n\t\t\tsc_log(ctx, \"C_DecryptFinal %zu bytes\", *outlen);\n\t\t\treturn SC_SUCCESS;\n\t\t} else {\n\t\t\t/* C_EncryptFinalize */\n\t\t\tif (padding) {\n\t\t\t\tuint8_t pad_byte = block_size - rest_len;\n\t\t\t\tsc_log(ctx, \"Generating padding, padding byte: %d\", pad_byte);\n\t\t\t\tsdata = priv->sym_crypt_buffer + rest_len;\n\t\t\t\tmemset(sdata, pad_byte, pad_byte);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "path_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPATH\t   *path;\n\tint\t\t\tisopen;\n\tchar\t   *s;\n\tint\t\t\tnpts;\n\tint\t\t\tsize;\n\tint\t\t\tdepth = 0;\n\n\tif ((npts = pair_count(str, ',')) <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));\n\n\ts = str;\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\n\t/* skip single leading paren */\n\tif ((*s == LDELIM) && (strrchr(s, LDELIM) == s))\n\t{\n\t\ts++;\n\t\tdepth++;\n\t}\n\n\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;\n\tpath = (PATH *) palloc(size);\n\n\tSET_VARSIZE(path, size);\n\tpath->npts = npts;\n\n\tif ((!path_decode(TRUE, npts, s, &isopen, &s, &(path->p[0])))\n\t&& (!((depth == 0) && (*s == '\\0'))) && !((depth >= 1) && (*s == RDELIM)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "path_in(PG_FUNCTION_ARGS)\n{\n\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPATH\t   *path;\n\tint\t\t\tisopen;\n\tchar\t   *s;\n\tint\t\t\tnpts;\n\tint\t\t\tsize;\n\tint\t\t\tbase_size;\n\tint\t\t\tdepth = 0;\n\n\tif ((npts = pair_count(str, ',')) <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));\n\n\ts = str;\n\twhile (isspace((unsigned char) *s))\n\t\ts++;\n\n\t/* skip single leading paren */\n\tif ((*s == LDELIM) && (strrchr(s, LDELIM) == s))\n\t{\n\t\ts++;\n\t\tdepth++;\n\t}\n\n\tbase_size = sizeof(path->p[0]) * npts;\n\tsize = offsetof(PATH, p[0]) + base_size;\n\n\t/* Check for integer overflow */\n\tif (base_size / npts != sizeof(path->p[0]) || size <= base_size)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"too many points requested\")));\n\n\tpath = (PATH *) palloc(size);\n\n\tSET_VARSIZE(path, size);\n\tpath->npts = npts;\n\n\tif ((!path_decode(TRUE, npts, s, &isopen, &s, &(path->p[0])))\n\t&& (!((depth == 0) && (*s == '\\0'))) && !((depth >= 1) && (*s == RDELIM)))\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t\t\t\t errmsg(\"invalid input syntax for type path: \\\"%s\\\"\", str)));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const auto* params = static_cast<TfLiteLSTMParams*>(node->builtin_data);\n  OpData* op_data = static_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n\n  const TfLiteTensor* input_to_input_weights =\n      GetOptionalInputTensor(context, node, kInputToInputWeightsTensor);\n  const TfLiteTensor* input_to_forget_weights =\n      GetInput(context, node, kInputToForgetWeightsTensor);\n  const TfLiteTensor* input_to_cell_weights =\n      GetInput(context, node, kInputToCellWeightsTensor);\n  const TfLiteTensor* input_to_output_weights =\n      GetInput(context, node, kInputToOutputWeightsTensor);\n\n  const TfLiteTensor* recurrent_to_input_weights =\n      GetOptionalInputTensor(context, node, kRecurrentToInputWeightsTensor);\n  const TfLiteTensor* recurrent_to_forget_weights =\n      GetInput(context, node, kRecurrentToForgetWeightsTensor);\n  const TfLiteTensor* recurrent_to_cell_weights =\n      GetInput(context, node, kRecurrentToCellWeightsTensor);\n  const TfLiteTensor* recurrent_to_output_weights =\n      GetInput(context, node, kRecurrentToOutputWeightsTensor);\n\n  const TfLiteTensor* cell_to_input_weights =\n      GetOptionalInputTensor(context, node, kCellToInputWeightsTensor);\n  const TfLiteTensor* cell_to_forget_weights =\n      GetOptionalInputTensor(context, node, kCellToForgetWeightsTensor);\n  const TfLiteTensor* cell_to_output_weights =\n      GetOptionalInputTensor(context, node, kCellToOutputWeightsTensor);\n\n  const TfLiteTensor* input_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kInputLayerNormCoefficientsTensor);\n  const TfLiteTensor* forget_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kForgetLayerNormCoefficientsTensor);\n  const TfLiteTensor* cell_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kCellLayerNormCoefficientsTensor);\n  const TfLiteTensor* output_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kOutputLayerNormCoefficientsTensor);\n\n  const TfLiteTensor* input_gate_bias =\n      GetOptionalInputTensor(context, node, kInputGateBiasTensor);\n  const TfLiteTensor* forget_gate_bias =\n      GetInput(context, node, kForgetGateBiasTensor);\n  const TfLiteTensor* cell_gate_bias =\n      GetInput(context, node, kCellGateBiasTensor);\n  const TfLiteTensor* output_gate_bias =\n      GetInput(context, node, kOutputGateBiasTensor);\n\n  const TfLiteTensor* projection_weights =\n      GetOptionalInputTensor(context, node, kProjectionWeightsTensor);\n  const TfLiteTensor* projection_bias =\n      GetOptionalInputTensor(context, node, kProjectionBiasTensor);\n\n  TfLiteTensor* output_state =\n      GetVariableInput(context, node, kOutputStateTensor);\n  TF_LITE_ENSURE(context, output_state != nullptr);\n  TfLiteTensor* cell_state = GetVariableInput(context, node, kCellStateTensor);\n  TF_LITE_ENSURE(context, cell_state != nullptr);\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  switch (input_to_output_weights->type) {\n    case kTfLiteFloat32: {\n      // Index the scratch buffers pointers to the global scratch buffer.\n      TfLiteTensor* scratch_buffer = GetTemporary(context, node, 0);\n      return lstm_eval::EvalFloat(\n          input, input_to_input_weights, input_to_forget_weights,\n          input_to_cell_weights, input_to_output_weights,\n          recurrent_to_input_weights, recurrent_to_forget_weights,\n          recurrent_to_cell_weights, recurrent_to_output_weights,\n          cell_to_input_weights, cell_to_forget_weights, cell_to_output_weights,\n          input_layer_norm_coefficients, forget_layer_norm_coefficients,\n          cell_layer_norm_coefficients, output_layer_norm_coefficients,\n          /*aux_input=*/nullptr,\n          /*aux_input_to_input_weights=*/nullptr,\n          /*forward_sequence=*/true,\n          /*time_major=*/true,\n          /*output_offset=*/0, scratch_buffer, output_state, cell_state,\n          output);\n    }\n    case kTfLiteUInt8:\n    case kTfLiteInt8: {\n      const bool is_hybrid = (input->type == kTfLiteFloat32);\n      const bool is_sparse = input_to_output_weights->sparsity != nullptr;\n      if (is_hybrid) {\n        TfLiteTensor* row_sums = GetTemporary(context, node, kRowSums);\n        const int row_sums_size = row_sums->dims->data[0];\n        if (is_sparse) {\n          TfLiteTensor* input_to_input_weights_ledger =\n              &context->tensors[op_data->ledger_index +\n                                kInputToInputWeightsLedgerOffset];\n          TfLiteTensor* input_to_forget_weights_ledger =\n              &context->tensors[op_data->ledger_index +\n                                kInputToForgetWeightsLedgerOffset];\n          TfLiteTensor* input_to_cell_weights_ledger =\n              &context->tensors[op_data->ledger_index +\n            GetTemporary(context, node, kCellStateQuantized), output_state,\n            cell_state, GetTemporary(context, node, kAccumScratch), output,\n            GetTemporary(context, node, kInputZeroPoints),\n            /*aux_input_zp=*/nullptr,\n            GetTemporary(context, node, kOutputStateZeroPoints), row_sums,\n            row_sums_size, &op_data->compute_row_sums,\n            CpuBackendContext::GetFromContext(context));\n      } else {\n        const int num_intermediate_tensors = node->intermediates->size;\n        if (num_intermediate_tensors == 5) {\n          TfLiteTensor* scratch0 = GetTemporary(context, node, 0);\n          TfLiteTensor* scratch1 = GetTemporary(context, node, 1);\n          TfLiteTensor* scratch2 = GetTemporary(context, node, 2);\n          TfLiteTensor* scratch3 = GetTemporary(context, node, 3);\n          TfLiteTensor* scratch4 = GetTemporary(context, node, 4);\n          TfLiteTensor* scratch5 = GetTemporary(context, node, 5);\n          return lstm_eval::EvalInteger8x8_16(\n              input, input_to_input_weights, input_to_forget_weights,\n              input_to_cell_weights, input_to_output_weights,\n              recurrent_to_input_weights, recurrent_to_forget_weights,\n              recurrent_to_cell_weights, recurrent_to_output_weights,\n              cell_to_input_weights, cell_to_forget_weights,\n              cell_to_output_weights, input_layer_norm_coefficients,\n              forget_layer_norm_coefficients, cell_layer_norm_coefficients,\n              output_layer_norm_coefficients, input_gate_bias, forget_gate_bias,\n              cell_gate_bias, output_gate_bias, projection_weights,\n              projection_bias, params, &op_data->integer_lstm_param,\n              output_state, cell_state, output, scratch0, scratch1, scratch2,\n              scratch3, scratch4, scratch5,\n              CpuBackendContext::GetFromContext(context));\n        } else {\n          TfLiteTensor* scratch0 = GetTemporary(context, node, 0);\n          TfLiteTensor* scratch1 = GetTemporary(context, node, 1);\n          TfLiteTensor* scratch2 = GetTemporary(context, node, 2);\n          TfLiteTensor* scratch3 = GetTemporary(context, node, 3);\n          TfLiteTensor* scratch4 = GetTemporary(context, node, 4);\n          TfLiteTensor* scratch5 = GetTemporary(context, node, 5);\n          TfLiteTensor* scratch6 = GetTemporary(context, node, 6);\n          TfLiteTensor* scratch7 = GetTemporary(context, node, 7);\n          return lstm_eval::EvalInteger8x8_8(\n              input, input_to_input_weights, input_to_forget_weights,\n              input_to_cell_weights, input_to_output_weights,\n              recurrent_to_input_weights, recurrent_to_forget_weights,\n              recurrent_to_cell_weights, recurrent_to_output_weights,\n              cell_to_input_weights, cell_to_forget_weights,\n              cell_to_output_weights, input_layer_norm_coefficients,\n              forget_layer_norm_coefficients, cell_layer_norm_coefficients,\n              output_layer_norm_coefficients, input_gate_bias, forget_gate_bias,\n              cell_gate_bias, output_gate_bias, projection_weights,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const auto* params = static_cast<TfLiteLSTMParams*>(node->builtin_data);\n  OpData* op_data = static_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n\n  const TfLiteTensor* input_to_input_weights =\n      GetOptionalInputTensor(context, node, kInputToInputWeightsTensor);\n  const TfLiteTensor* input_to_forget_weights;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputToForgetWeightsTensor,\n                                 &input_to_forget_weights));\n  const TfLiteTensor* input_to_cell_weights;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputToCellWeightsTensor,\n                                 &input_to_cell_weights));\n  const TfLiteTensor* input_to_output_weights;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputToOutputWeightsTensor,\n                                 &input_to_output_weights));\n\n  const TfLiteTensor* recurrent_to_input_weights =\n      GetOptionalInputTensor(context, node, kRecurrentToInputWeightsTensor);\n  const TfLiteTensor* recurrent_to_forget_weights;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kRecurrentToForgetWeightsTensor,\n                                 &recurrent_to_forget_weights));\n  const TfLiteTensor* recurrent_to_cell_weights;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kRecurrentToCellWeightsTensor,\n                                 &recurrent_to_cell_weights));\n  const TfLiteTensor* recurrent_to_output_weights;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kRecurrentToOutputWeightsTensor,\n                                 &recurrent_to_output_weights));\n\n  const TfLiteTensor* cell_to_input_weights =\n      GetOptionalInputTensor(context, node, kCellToInputWeightsTensor);\n  const TfLiteTensor* cell_to_forget_weights =\n      GetOptionalInputTensor(context, node, kCellToForgetWeightsTensor);\n  const TfLiteTensor* cell_to_output_weights =\n      GetOptionalInputTensor(context, node, kCellToOutputWeightsTensor);\n\n  const TfLiteTensor* input_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kInputLayerNormCoefficientsTensor);\n  const TfLiteTensor* forget_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kForgetLayerNormCoefficientsTensor);\n  const TfLiteTensor* cell_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kCellLayerNormCoefficientsTensor);\n  const TfLiteTensor* output_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kOutputLayerNormCoefficientsTensor);\n\n  const TfLiteTensor* input_gate_bias =\n      GetOptionalInputTensor(context, node, kInputGateBiasTensor);\n  const TfLiteTensor* forget_gate_bias;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kForgetGateBiasTensor,\n                                          &forget_gate_bias));\n  const TfLiteTensor* cell_gate_bias;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kCellGateBiasTensor,\n                                          &cell_gate_bias));\n  const TfLiteTensor* output_gate_bias;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kOutputGateBiasTensor,\n                                          &output_gate_bias));\n\n  const TfLiteTensor* projection_weights =\n      GetOptionalInputTensor(context, node, kProjectionWeightsTensor);\n  const TfLiteTensor* projection_bias =\n      GetOptionalInputTensor(context, node, kProjectionBiasTensor);\n\n  TfLiteTensor* output_state =\n      GetVariableInput(context, node, kOutputStateTensor);\n  TFLITE_DCHECK(output_state != nullptr);\n  TfLiteTensor* cell_state = GetVariableInput(context, node, kCellStateTensor);\n  TFLITE_DCHECK(cell_state != nullptr);\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  switch (input_to_output_weights->type) {\n    case kTfLiteFloat32: {\n      // Index the scratch buffers pointers to the global scratch buffer.\n      TfLiteTensor* scratch_buffer;\n      TF_LITE_ENSURE_OK(context,\n                        GetTemporarySafe(context, node, 0, &scratch_buffer));\n      return lstm_eval::EvalFloat(\n          input, input_to_input_weights, input_to_forget_weights,\n          input_to_cell_weights, input_to_output_weights,\n          recurrent_to_input_weights, recurrent_to_forget_weights,\n          recurrent_to_cell_weights, recurrent_to_output_weights,\n          cell_to_input_weights, cell_to_forget_weights, cell_to_output_weights,\n          input_layer_norm_coefficients, forget_layer_norm_coefficients,\n          cell_layer_norm_coefficients, output_layer_norm_coefficients,\n          /*aux_input=*/nullptr,\n          /*aux_input_to_input_weights=*/nullptr,\n          /*forward_sequence=*/true,\n          /*time_major=*/true,\n          /*output_offset=*/0, scratch_buffer, output_state, cell_state,\n          output);\n    }\n    case kTfLiteUInt8:\n    case kTfLiteInt8: {\n      const bool is_hybrid = (input->type == kTfLiteFloat32);\n      const bool is_sparse = input_to_output_weights->sparsity != nullptr;\n      if (is_hybrid) {\n        TfLiteTensor* row_sums;\n        TF_LITE_ENSURE_OK(context,\n                          GetTemporarySafe(context, node, kRowSums, &row_sums));\n        const int row_sums_size = row_sums->dims->data[0];\n        if (is_sparse) {\n          TfLiteTensor* input_to_input_weights_ledger =\n              &context->tensors[op_data->ledger_index +\n                                kInputToInputWeightsLedgerOffset];\n          TfLiteTensor* input_to_forget_weights_ledger =\n              &context->tensors[op_data->ledger_index +\n                                kInputToForgetWeightsLedgerOffset];\n          TfLiteTensor* input_to_cell_weights_ledger =\n              &context->tensors[op_data->ledger_index +\n            GetTemporary(context, node, kCellStateQuantized), output_state,\n            cell_state, GetTemporary(context, node, kAccumScratch), output,\n            GetTemporary(context, node, kInputZeroPoints),\n            /*aux_input_zp=*/nullptr,\n            GetTemporary(context, node, kOutputStateZeroPoints), row_sums,\n            row_sums_size, &op_data->compute_row_sums,\n            CpuBackendContext::GetFromContext(context));\n      } else {\n        const int num_intermediate_tensors = node->intermediates->size;\n        if (num_intermediate_tensors == 5) {\n          TfLiteTensor* scratch0;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 0, &scratch0));\n          TfLiteTensor* scratch1;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 1, &scratch1));\n          TfLiteTensor* scratch2;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 2, &scratch2));\n          TfLiteTensor* scratch3;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 3, &scratch3));\n          TfLiteTensor* scratch4;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 4, &scratch4));\n          TfLiteTensor* scratch5;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 5, &scratch5));\n          return lstm_eval::EvalInteger8x8_16(\n              input, input_to_input_weights, input_to_forget_weights,\n              input_to_cell_weights, input_to_output_weights,\n              recurrent_to_input_weights, recurrent_to_forget_weights,\n              recurrent_to_cell_weights, recurrent_to_output_weights,\n              cell_to_input_weights, cell_to_forget_weights,\n              cell_to_output_weights, input_layer_norm_coefficients,\n              forget_layer_norm_coefficients, cell_layer_norm_coefficients,\n              output_layer_norm_coefficients, input_gate_bias, forget_gate_bias,\n              cell_gate_bias, output_gate_bias, projection_weights,\n              projection_bias, params, &op_data->integer_lstm_param,\n              output_state, cell_state, output, scratch0, scratch1, scratch2,\n              scratch3, scratch4, scratch5,\n              CpuBackendContext::GetFromContext(context));\n        } else {\n          TfLiteTensor* scratch0;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 0, &scratch0));\n          TfLiteTensor* scratch1;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 1, &scratch1));\n          TfLiteTensor* scratch2;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 2, &scratch2));\n          TfLiteTensor* scratch3;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 3, &scratch3));\n          TfLiteTensor* scratch4;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 4, &scratch4));\n          TfLiteTensor* scratch5;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 5, &scratch5));\n          TfLiteTensor* scratch6;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 6, &scratch6));\n          TfLiteTensor* scratch7;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 7, &scratch7));\n          return lstm_eval::EvalInteger8x8_8(\n              input, input_to_input_weights, input_to_forget_weights,\n              input_to_cell_weights, input_to_output_weights,\n              recurrent_to_input_weights, recurrent_to_forget_weights,\n              recurrent_to_cell_weights, recurrent_to_output_weights,\n              cell_to_input_weights, cell_to_forget_weights,\n              cell_to_output_weights, input_layer_norm_coefficients,\n              forget_layer_norm_coefficients, cell_layer_norm_coefficients,\n              output_layer_norm_coefficients, input_gate_bias, forget_gate_bias,\n              cell_gate_bias, output_gate_bias, projection_weights,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    krb5_gss_ctx_id_rec *ctx;\n    unsigned char *ptr;\n    unsigned int bodysize;\n    int err;\n    int toktype2;\n    int vfyflags = 0;\n    OM_uint32 ret;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    /* parse the token, leave the data in message_buffer, setting conf_state */\n\n    /* verify the header */\n\n    ptr = (unsigned char *) input_token_buffer->value;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    krb5_gss_ctx_id_rec *ctx;\n    unsigned char *ptr;\n    unsigned int bodysize;\n    int err;\n    int toktype2;\n    int vfyflags = 0;\n    OM_uint32 ret;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (ctx->terminated || !ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    /* parse the token, leave the data in message_buffer, setting conf_state */\n\n    /* verify the header */\n\n    ptr = (unsigned char *) input_token_buffer->value;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int perf_trace_event_perm(struct ftrace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\t/* The ftrace function trace is allowed only for root. */\n\tif (ftrace_event_is_function(tp_event) &&\n\t    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* No tracing, just counting, so no obvious leak */\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;\n\n\t/* Some events are ok to be traced by non-root users... */\n\tif (p_event->attach_state == PERF_ATTACH_TASK) {\n\t\tif (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)\n\t\t\treturn 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int perf_trace_event_perm(struct ftrace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\t/* The ftrace function trace is allowed only for root. */\n\tif (ftrace_event_is_function(tp_event) &&\n\t    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/* No tracing, just counting, so no obvious leak */\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;\n\n\t/* Some events are ok to be traced by non-root users... */\n\tif (p_event->attach_state == PERF_ATTACH_TASK) {\n\t\tif (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)\n\t\t\treturn 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "bool ConstantFolding::SimplifyReshape(const GraphProperties& properties,\n                                      bool use_shape_info, NodeDef* node) {\n  if (!use_shape_info || node->attr().count(\"T\") == 0 ||\n      !IsSimplifiableReshape(*node, properties)) {\n    return false;\n  }\n  DataType output_type = node->attr().at(\"T\").type();\n  node->set_op(\"Identity\");\n  EraseRegularNodeAttributes(node);\n  (*node->mutable_attr())[\"T\"].set_type(output_type);\n  *node->mutable_input(1) = AsControlDependency(node->input(1));\n  return true;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "bool ConstantFolding::SimplifyReshape(const GraphProperties& properties,\n                                      bool use_shape_info, NodeDef* node) {\n  if (!use_shape_info || node->attr().count(\"T\") == 0 ||\n      !IsSimplifiableReshape(*node, properties).ok()) {\n    return false;\n  }\n  DataType output_type = node->attr().at(\"T\").type();\n  node->set_op(\"Identity\");\n  EraseRegularNodeAttributes(node);\n  (*node->mutable_attr())[\"T\"].set_type(output_type);\n  *node->mutable_input(1) = AsControlDependency(node->input(1));\n  return true;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tdisconnect = !IS_MNT_LOCKED_AND_LAZY(p);\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\t/* Don't forget about p */\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tdebug2_f(\"entering\");\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\tif (parse_key_constraints(e->request, NULL, &death, &seconds, &confirm,\n\t    NULL, &dest_constraints, &ndest_constraints) != 0) {\n\t\terror_f(\"failed to parse constraints\");\n\t\tgoto send;\n\t}\n\tif (e->nsession_ids != 0 && !remote_add_provider) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": remote addition of \"\n\t\t    \"providers is disabled\", provider);\n\t\tgoto send;\n\t}\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\t\t\tkeys[i] = NULL; /* transferred */\n\t\t\tid->provider = xstrdup(canonical_provider);\n\t\t\tif (*comments[i] != '\\0') {\n\t\t\t\tid->comment = comments[i];\n\t\t\t\tcomments[i] = NULL; /* transferred */\n\t\t\t} else {\n\t\t\t\tid->comment = xstrdup(canonical_provider);\n\t\t\t}\n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tid->dest_constraints = dest_constraints;\n\t\t\tid->ndest_constraints = ndest_constraints;\n\t\t\tdest_constraints = NULL; /* transferred */\n\t\t\tndest_constraints = 0;\n\t\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t\tidtab->nentries++;\n\t\t\tsuccess = 1;\n\t\t}\n\t\t/* XXX update constraints for existing keys */\n\t\tsshkey_free(keys[i]);\n\t\tfree(comments[i]);\n\t}\nsend:\n\tfree(pin);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) {\n\t\terror_fr(r, \"parse\");\n\t\tgoto send;\n\t}\n\tif (parse_key_constraints(e->request, NULL, &death, &seconds, &confirm,\n\t    NULL, &dest_constraints, &ndest_constraints) != 0) {\n\t\terror_f(\"failed to parse constraints\");\n\t\tgoto send;\n\t}\n\tdump_dest_constraints(__func__, dest_constraints, ndest_constraints);\n\tif (e->nsession_ids != 0 && !remote_add_provider) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": remote addition of \"\n\t\t    \"providers is disabled\", provider);\n\t\tgoto send;\n\t}\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\t\t\tkeys[i] = NULL; /* transferred */\n\t\t\tid->provider = xstrdup(canonical_provider);\n\t\t\tif (*comments[i] != '\\0') {\n\t\t\t\tid->comment = comments[i];\n\t\t\t\tcomments[i] = NULL; /* transferred */\n\t\t\t} else {\n\t\t\t\tid->comment = xstrdup(canonical_provider);\n\t\t\t}\n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tid->dest_constraints = dup_dest_constraints(\n\t\t\t    dest_constraints, ndest_constraints);\n\t\t\tid->ndest_constraints = ndest_constraints;\n\t\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t\tidtab->nentries++;\n\t\t\tsuccess = 1;\n\t\t}\n\t\t/* XXX update constraints for existing keys */\n\t\tsshkey_free(keys[i]);\n\t\tfree(comments[i]);\n\t}\nsend:\n\tfree(pin);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void tokenadd(struct jv_parser* p, char c) {\n  assert(p->tokenpos <= p->tokenlen);\n  if (p->tokenpos == p->tokenlen) {\n    p->tokenlen = p->tokenlen*2 + 256;\n    p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);\n  }\n  assert(p->tokenpos < p->tokenlen);\n  p->tokenbuf[p->tokenpos++] = c;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void tokenadd(struct jv_parser* p, char c) {\n  assert(p->tokenpos <= p->tokenlen);\n  if (p->tokenpos >= (p->tokenlen - 1)) {\n    p->tokenlen = p->tokenlen*2 + 256;\n    p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);\n  }\n  assert(p->tokenpos < p->tokenlen);\n  p->tokenbuf[p->tokenpos++] = c;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int sss_certmap_get_search_filter(struct sss_certmap_ctx *ctx,\n                                  const uint8_t *der_cert, size_t der_size,\n                                  char **_filter, char ***_domains)\n{\n    int ret;\n    struct match_map_rule *r;\n    struct priority_list *p;\n    struct sss_cert_content *cert_content = NULL;\n    char *filter = NULL;\n    char **domains = NULL;\n    size_t c;\n\n    if (_filter == NULL || _domains == NULL) {\n        return EINVAL;\n    }\n\n    ret = sss_cert_get_content(ctx, der_cert, der_size, &cert_content);\n    if (ret != 0) {\n        CM_DEBUG(ctx, \"Failed to get certificate content [%d].\", ret);\n        return ret;\n    }\n\n    if (ctx->prio_list == NULL) {\n        if (ctx->default_mapping_rule == NULL) {\n            CM_DEBUG(ctx, \"No matching or mapping rules available.\");\n            return EINVAL;\n        }\n\n        ret = get_filter(ctx, ctx->default_mapping_rule, cert_content, &filter);\n        goto done;\n    }\n\n    for (p = ctx->prio_list; p != NULL; p = p->next) {\n        for (r = p->rule_list; r != NULL; r = r->next) {\n            ret = do_match(ctx, r->parsed_match_rule, cert_content);\n            if (ret == 0) {\n                /* match */\n                ret = get_filter(ctx, r->parsed_mapping_rule, cert_content,\n                                 &filter);\n                if (ret != 0) {\n                    CM_DEBUG(ctx, \"Failed to get filter\");\n                    goto done;\n                }\n\n                if (r->domains != NULL) {\n                    for (c = 0; r->domains[c] != NULL; c++);\n                    domains = talloc_zero_array(ctx, char *, c + 1);\n                    if (domains == NULL) {\n                        ret = ENOMEM;\n                        goto done;\n                    }\n\n                    for (c = 0; r->domains[c] != NULL; c++) {\n                        domains[c] = talloc_strdup(domains, r->domains[c]);\n                        if (domains[c] == NULL) {\n                            ret = ENOMEM;\n                            goto done;\n                        }\n                    }\n                }\n\n                ret = 0;\n                goto done;\n            }\n        }\n    }\n\n    ret = ENOENT;\n\ndone:\n    talloc_free(cert_content);\n    if (ret == 0) {\n        *_filter = filter;\n        *_domains = domains;\n    } else {\n        talloc_free(filter);\n        talloc_free(domains);\n    }\n\n    return ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int sss_certmap_get_search_filter(struct sss_certmap_ctx *ctx,\n                                  const uint8_t *der_cert, size_t der_size,\n                                  char **_filter, char ***_domains)\n{\n    return expand_mapping_rule_ex(ctx, der_cert, der_size, true,\n                                  _filter, _domains);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "_rsvg_io_get_file_path (const gchar * filename,\n                        const gchar * base_uri)\n{\n    gchar *absolute_filename;\n\n    if (g_file_test (filename, G_FILE_TEST_EXISTS) || g_path_is_absolute (filename)) {\n        absolute_filename = g_strdup (filename);\n    } else {\n        gchar *tmpcdir;\n        gchar *base_filename;\n\n        if (base_uri) {\n            base_filename = g_filename_from_uri (base_uri, NULL, NULL);\n            if (base_filename != NULL) {\n                tmpcdir = g_path_get_dirname (base_filename);\n                g_free (base_filename);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "_rsvg_io_get_file_path (const gchar * filename,\n                        const gchar * base_uri)\n{\n    gchar *absolute_filename;\n\n    if (g_path_is_absolute (filename)) {\n        absolute_filename = g_strdup (filename);\n    } else {\n        gchar *tmpcdir;\n        gchar *base_filename;\n\n        if (base_uri) {\n            base_filename = g_filename_from_uri (base_uri, NULL, NULL);\n            if (base_filename != NULL) {\n                tmpcdir = g_path_get_dirname (base_filename);\n                g_free (base_filename);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)\n\t{\n\tDTLS1_RECORD_DATA *rdata;\n\tpitem *item;\n\n\t/* Limit the size of the queue to prevent DOS attacks */\n\tif (pqueue_size(queue->q) >= 100)\n\t\treturn 0;\n\t\t\n\trdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));\n\titem = pitem_new(priority, rdata);\n\tif (rdata == NULL || item == NULL)\n\t\t{\n\t\tif (rdata != NULL) OPENSSL_free(rdata);\n\t\tif (item != NULL) pitem_free(item);\n\t\t\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\treturn(0);\n\t\t}\n\t}\n#endif\n\n\ts->packet = NULL;\n\ts->packet_length = 0;\n\tmemset(&(s->s3->rbuf), 0, sizeof(SSL3_BUFFER));\n\tmemset(&(s->s3->rrec), 0, sizeof(SSL3_RECORD));\n\t\n\tif (!ssl3_setup_buffers(s))\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(0);\n\t\t}\n\n\t/* insert should not fail, since duplicates are dropped */\n\tif (pqueue_insert(queue->q, item) == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(0);\n\t\t}\n\n\treturn(1);\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "dtls1_buffer_record(SSL *s, record_pqueue *queue, unsigned char *priority)\n\t{\n\tDTLS1_RECORD_DATA *rdata;\n\tpitem *item;\n\n\t/* Limit the size of the queue to prevent DOS attacks */\n\tif (pqueue_size(queue->q) >= 100)\n\t\treturn 0;\n\n\trdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));\n\titem = pitem_new(priority, rdata);\n\tif (rdata == NULL || item == NULL)\n\t\t{\n\t\tif (rdata != NULL) OPENSSL_free(rdata);\n\t\tif (item != NULL) pitem_free(item);\n\t\t\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\treturn(0);\n\t\t}\n#endif\n\n\ts->packet = NULL;\n\ts->packet_length = 0;\n\tmemset(&(s->s3->rbuf), 0, sizeof(SSL3_BUFFER));\n\tmemset(&(s->s3->rrec), 0, sizeof(SSL3_RECORD));\n\t\n\tif (!ssl3_setup_buffers(s))\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tif (rdata->rbuf.buf != NULL)\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(-1);\n\t\t}\n\n\t/* insert should not fail, since duplicates are dropped */\n\tif (pqueue_insert(queue->q, item) == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tif (rdata->rbuf.buf != NULL)\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(-1);\n\t\t}\n\n\treturn(1);\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "                mpls_print(ndo, p, length);\n\t\tbreak;\n        case ETHERTYPE_ISO:\n                /* is the fudge byte set ? lets verify by spotting ISO headers */\n                if (length < 2)\n                    goto trunc;\n                ND_TCHECK_16BITS(p);\n                if (*(p+1) == 0x81 ||\n                    *(p+1) == 0x82 ||\n                    *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1, ndo->ndo_snapend - p - 1);\n                else\n                    isoclns_print(ndo, p, length, ndo->ndo_snapend - p);\n                break;\n\tdefault:\n                if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;\n\t}\n\n\treturn (CHDLC_HDRLEN);\n\ntrunc:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "                mpls_print(ndo, p, length);\n\t\tbreak;\n        case ETHERTYPE_ISO:\n                /* is the fudge byte set ? lets verify by spotting ISO headers */\n                if (length < 2)\n                    goto trunc;\n                ND_TCHECK_16BITS(p);\n                if (*(p+1) == 0x81 ||\n                    *(p+1) == 0x82 ||\n                    *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1);\n                else\n                    isoclns_print(ndo, p, length);\n                break;\n\tdefault:\n                if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;\n\t}\n\n\treturn (CHDLC_HDRLEN);\n\ntrunc:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "gplotAddPlot(GPLOT       *gplot,\n             NUMA        *nax,\n             NUMA        *nay,\n             l_int32      plotstyle,\n             const char  *plottitle)\n{\nchar       buf[L_BUF_SIZE];\nchar       emptystring[] = \"\";\nchar      *datastr, *title;\nl_int32    n, i;\nl_float32  valx, valy, startx, delx;\nSARRAY    *sa;\n\n    PROCNAME(\"gplotAddPlot\");\n\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n    numaAddNumber(gplot->plotstyles, plotstyle);\n    if (plottitle) {\n        title = stringNew(plottitle);\n        sarrayAddString(gplot->plottitles, title, L_INSERT);\n    } else {\n        sarrayAddString(gplot->plottitles, emptystring, L_COPY);\n    }\n\n        /* Generate and save data filename */\n    gplot->nplots++;\n    snprintf(buf, L_BUF_SIZE, \"%s.data.%d\", gplot->rootname, gplot->nplots);\n    sarrayAddString(gplot->datanames, buf, L_COPY);\n\n        /* Generate data and save as a string */\n    sa = sarrayCreate(n);\n    for (i = 0; i < n; i++) {\n        if (nax)\n            numaGetFValue(nax, i, &valx);\n        else\n            valx = startx + i * delx;\n        numaGetFValue(nay, i, &valy);\n        snprintf(buf, L_BUF_SIZE, \"%f %f\\n\", valx, valy);\n        sarrayAddString(sa, buf, L_COPY);\n    }\n    datastr = sarrayToString(sa, 0);\n    sarrayAddString(gplot->plotdata, datastr, L_INSERT);\n    sarrayDestroy(&sa);\n\n    return 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "gplotAddPlot(GPLOT       *gplot,\n             NUMA        *nax,\n             NUMA        *nay,\n             l_int32      plotstyle,\n             const char  *plottitle)\n{\nchar       buf[L_BUFSIZE];\nchar       emptystring[] = \"\";\nchar      *datastr, *title;\nl_int32    n, i;\nl_float32  valx, valy, startx, delx;\nSARRAY    *sa;\n\n    PROCNAME(\"gplotAddPlot\");\n\n    if (!gplot)\n        return ERROR_INT(\"gplot not defined\", procName, 1);\n    numaAddNumber(gplot->plotstyles, plotstyle);\n    if (plottitle) {\n        title = stringNew(plottitle);\n        sarrayAddString(gplot->plottitles, title, L_INSERT);\n    } else {\n        sarrayAddString(gplot->plottitles, emptystring, L_COPY);\n    }\n\n        /* Generate and save data filename */\n    gplot->nplots++;\n    snprintf(buf, L_BUFSIZE, \"%s.data.%d\", gplot->rootname, gplot->nplots);\n    sarrayAddString(gplot->datanames, buf, L_COPY);\n\n        /* Generate data and save as a string */\n    sa = sarrayCreate(n);\n    for (i = 0; i < n; i++) {\n        if (nax)\n            numaGetFValue(nax, i, &valx);\n        else\n            valx = startx + i * delx;\n        numaGetFValue(nay, i, &valy);\n        snprintf(buf, L_BUFSIZE, \"%f %f\\n\", valx, valy);\n        sarrayAddString(sa, buf, L_COPY);\n    }\n    datastr = sarrayToString(sa, 0);\n    sarrayAddString(gplot->plotdata, datastr, L_INSERT);\n    sarrayDestroy(&sa);\n\n    return 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void pp_mil_k24(fp24_t r, ep4_t *t, ep4_t *q, ep_t *p, int m, bn_t a) {\n\tfp24_t l;\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep4_t *_q = RLC_ALLOCA(ep4_t, m);\n\tint i, j, len = bn_bits(a) + 1;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tif (m == 0) {\n\t\treturn;\n\t}\n\n\tfp24_null(l);\n\n\tRLC_TRY {\n\t\tfp24_new(l);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void pp_mil_k24(fp24_t r, ep4_t *t, ep4_t *q, ep_t *p, int m, bn_t a) {\n\tfp24_t l;\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep4_t *_q = RLC_ALLOCA(ep4_t, m);\n\tsize_t len = bn_bits(a) + 1;\n\tint i, j;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tif (m == 0) {\n\t\treturn;\n\t}\n\n\tfp24_null(l);\n\n\tRLC_TRY {\n\t\tfp24_new(l);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t\t\t  unsigned long flags)\n{\n\tstruct key_user *user;\n\tstruct key *key;\n\tint ret;\n\n\tkenter(\"\");\n\n\tif (ctx->index_key.type == &key_type_keyring)\n\t\treturn ERR_PTR(-EPERM);\n\n\tuser = key_user_lookup(current_fsuid());\n\tif (!user)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconstruct_get_dest_keyring(&dest_keyring);\n\n\tret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);\n\tkey_user_put(user);\n\n\tif (ret == 0) {\n\t\tret = construct_key(key, callout_info, callout_len, aux,\n\t\t\t\t    dest_keyring);\n\t\tif (ret < 0) {\n\t\t\tkdebug(\"cons failed\");\n\t\t\tgoto construction_failed;\n\t\t}\n\t} else if (ret == -EINPROGRESS) {\n\t\tret = 0;\n\t} else {\n\t\tgoto couldnt_alloc_key;\n\t}\n\n\tkey_put(dest_keyring);\n\tkleave(\" = key %d\", key_serial(key));\n\treturn key;\n\nconstruction_failed:\n\tkey_negate_and_link(key, key_negative_timeout, NULL, NULL);\n\tkey_put(key);\ncouldnt_alloc_key:\n\tkey_put(dest_keyring);\n\tkleave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "{\n\tstruct key_user *user;\n\tstruct key *key;\n\tint ret;\n\n\tkenter(\"\");\n\n\tif (ctx->index_key.type == &key_type_keyring)\n\t\treturn ERR_PTR(-EPERM);\n\n\tret = construct_get_dest_keyring(&dest_keyring);\n\tif (ret)\n\t\tgoto error;\n\n\tuser = key_user_lookup(current_fsuid());\n\tif (!user) {\n\t\tret = -ENOMEM;\n\t\tgoto error_put_dest_keyring;\n\t}\n\n\tret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);\n\tkey_user_put(user);\n\n\tif (ret == 0) {\n\t\tret = construct_key(key, callout_info, callout_len, aux,\n\t\t\t\t    dest_keyring);\n\t\tif (ret < 0) {\n\t\t\tkdebug(\"cons failed\");\n\t\t\tgoto construction_failed;\n\t\t}\n\t} else if (ret == -EINPROGRESS) {\n\t\tret = 0;\n\t} else {\n\t\tgoto error_put_dest_keyring;\n\t}\n\n\tkey_put(dest_keyring);\n\tkleave(\" = key %d\", key_serial(key));\n\treturn key;\n\nconstruction_failed:\n\tkey_negate_and_link(key, key_negative_timeout, NULL, NULL);\n\tkey_put(key);\nerror_put_dest_keyring:\n\tkey_put(dest_keyring);\nerror:\n\tkleave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "        /*\n          Convert stripped TIFF image.\n        */\n        extent=TIFFStripSize(tiff);\n#if defined(TIFF_VERSION_BIG)\n        extent+=image->columns*sizeof(uint64);\n#else\n        extent+=image->columns*sizeof(uint32);\n#endif\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n        stride=TIFFVStripSize(tiff,1);\n        strip_id=0;\n        p=strip_pixels;\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          size_t\n            rows_remaining;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "        /*\n          Convert stripped TIFF image.\n        */\n        extent=TIFFStripSize(tiff);\n#if defined(TIFF_VERSION_BIG)\n        extent+=image->columns*sizeof(uint64);\n#else\n        extent+=image->columns*sizeof(uint32);\n#endif\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          2*sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n        stride=TIFFVStripSize(tiff,1);\n        strip_id=0;\n        p=strip_pixels;\n        for (i=0; i < (ssize_t) samples_per_pixel; i++)\n        {\n          size_t\n            rows_remaining;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  struct utsname uname_data;\n  char dirpath_tmp[256];\n\n  if (uname(&uname_data))\n    return -errno;\n\n  snprintf(dirpath_tmp, 256, \"%s/kheaders-%s\", get_tmp_dir(),\n           uname_data.release);\n  dirpath = std::string(dirpath_tmp);\n\n  if (file_exists(dirpath_tmp))\n    return 0;\n\n  // First time so extract it\n  return extract_kheaders(dirpath, uname_data);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  struct utsname uname_data;\n  char dirpath_tmp[256];\n\n  if (uname(&uname_data))\n    return -errno;\n\n  snprintf(dirpath_tmp, 256, \"%s/kheaders-%s\", get_tmp_dir(),\n           uname_data.release);\n  dirpath = std::string(dirpath_tmp);\n\n  if (file_exists_and_ownedby(dirpath_tmp, 0))\n    return 0;\n\n  // First time so extract it\n  return extract_kheaders(dirpath, uname_data);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "        }\n\n        m_auth->insertEnvironment(env);\n\n        m_auth->setUser(user);\n        if (existingSessionId.isNull()) {\n            m_auth->setSession(session.exec());\n        } else {\n            //we only want to unlock the session if we can lock in, so we want to go via PAM auth, but not start a new session\n            //by not setting the session and the helper will emit authentication and then quit\n            connect(m_auth, &Auth::authentication, this, [=](){\n                qDebug() << \"activating existing seat\";\n                OrgFreedesktopLogin1ManagerInterface manager(Logind::serviceName(), Logind::managerPath(), QDBusConnection::systemBus());\n                manager.UnlockSession(existingSessionId);\n                manager.ActivateSession(existingSessionId);\n            });\n        }\n        m_auth->start();\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "        }\n\n        m_auth->insertEnvironment(env);\n\n        m_auth->setUser(user);\n        if (existingSessionId.isNull()) {\n            m_auth->setSession(session.exec());\n        } else {\n            //we only want to unlock the session if we can lock in, so we want to go via PAM auth, but not start a new session\n            //by not setting the session and the helper will emit authentication and then quit\n            connect(m_auth, &Auth::authentication, this, [=](const QString &, bool success){\n                if(!success)\n                    return;\n                qDebug() << \"activating existing seat\";\n                OrgFreedesktopLogin1ManagerInterface manager(Logind::serviceName(), Logind::managerPath(), QDBusConnection::systemBus());\n                manager.UnlockSession(existingSessionId);\n                manager.ActivateSession(existingSessionId);\n            });\n        }\n        m_auth->start();\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "                return log_debug_errno(SYNTHETIC_ERRNO(EADDRNOTAVAIL),\n                                       \"Device %s does not expose keys or switches relevant to us, ignoring.\",\n                                       p);\n\n        if (ioctl(b->fd, EVIOCGNAME(sizeof(name)), name) < 0) {\n                r = log_error_errno(errno, \"Failed to get input name: %m\");\n                goto fail;\n        }\n\n        (void) button_set_mask(b);\n\n        r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to add button event: %m\");\n                goto fail;\n        }\n\n        log_info(\"Watching system buttons on /dev/input/%s (%s)\", b->name, name);\n\n        return 0;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "                return log_debug_errno(SYNTHETIC_ERRNO(EADDRNOTAVAIL),\n                                       \"Device %s does not expose keys or switches relevant to us, ignoring.\",\n                                       p);\n\n        if (ioctl(b->fd, EVIOCGNAME(sizeof(name)), name) < 0) {\n                r = log_error_errno(errno, \"Failed to get input name: %m\");\n                goto fail;\n        }\n\n        (void) button_set_mask(b);\n        \n        b->io_event_source = sd_event_source_unref(b->io_event_source);\n        r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to add button event: %m\");\n                goto fail;\n        }\n\n        log_info(\"Watching system buttons on /dev/input/%s (%s)\", b->name, name);\n\n        return 0;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t}\n\n\tstart += orderLength + 7;\n\tend = Stream_GetPosition(s);\n\tif (start > end)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes too much\",\n\t\t           name, end - start);\n\t\treturn FALSE;\n\t}\n\tdiff = start - end;\n\tif (diff > 0)\n\t{\n\t\tWLog_Print(update->log, WLOG_DEBUG,\n\t\t           \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes short, skipping\", name, diff);\n\t\tStream_Seek(s, diff);\n\t}\n\treturn rc;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t}\n\n\tstart += orderLength + 7;\n\tend = Stream_GetPosition(s);\n\tif (start > end)\n\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes too much\",\n\t\t           name, end - start);\n\t\treturn FALSE;\n\t}\n\tdiff = end - start;\n\tif (diff > 0)\n\t{\n\t\tWLog_Print(update->log, WLOG_DEBUG,\n\t\t           \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes short, skipping\", name, diff);\n\t\tif (!Stream_SafeSeek(s, diff))\n\t\t\treturn FALSE;\n\t}\n\treturn rc;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    CHECK_STATE(errStatus);\n    CHECK_STATE(err_string);\n    CHECK_STATE(_key);\n    auto keyArray = make_shared<vector<char>>(BUF_LEN, 0);\n    auto encryptedKey = make_shared<vector<uint8_t>>(BUF_LEN, 0);\n\n    vector<char> errMsg(BUF_LEN, 0);\n\n    strncpy(keyArray->data(), _key, BUF_LEN);\n    *errStatus = 0;\n    unsigned int encryptedLen = 0;\n\n    sgx_status_t status = trustedEncryptKeyAES(eid, errStatus, errMsg.data(), keyArray->data(), encryptedKey->data(), &encryptedLen);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, *errStatus, errMsg.data());\n\n    SAFE_CHAR_BUF(resultBuf, 2 * BUF_LEN + 1);\n\n    carray2Hex(encryptedKey->data(), encryptedLen, resultBuf, 2 * BUF_LEN + 1);\n\n    return string(resultBuf);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    CHECK_STATE(errStatus);\n    CHECK_STATE(err_string);\n    CHECK_STATE(_key);\n    auto keyArray = make_shared<vector<char>>(BUF_LEN, 0);\n    auto encryptedKey = make_shared<vector<uint8_t>>(BUF_LEN, 0);\n\n    vector<char> errMsg(BUF_LEN, 0);\n\n    strncpy(keyArray->data(), _key, BUF_LEN);\n    *errStatus = 0;\n\n    uint64_t encryptedLen = 0;\n\n    sgx_status_t status = trustedEncryptKeyAES(eid, errStatus, errMsg.data(), keyArray->data(), encryptedKey->data(), &encryptedLen);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, *errStatus, errMsg.data());\n\n    SAFE_CHAR_BUF(resultBuf, 2 * BUF_LEN + 1);\n\n    carray2Hex(encryptedKey->data(), encryptedLen, resultBuf, 2 * BUF_LEN + 1);\n\n    return string(resultBuf);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "PackLinuxElf64::PackLinuxElf64help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64\n    || sizeof(Elf64_Phdr) != e_phentsize\n    || (Elf64_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf64_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "PackLinuxElf64::PackLinuxElf64help1(InputFile *f)\n{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (memcmp((char const *)&ehdri, \"\\x7f\\x45\\x4c\\x46\", 4)  // \"\\177ELF\"\n    || ehdri.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64\n    || sizeof(Elf64_Phdr) != e_phentsize\n    || (Elf64_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf64_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {\n        e_phoff = 0;\n        e_shoff = 0;\n        sz_phdrs = 0;\n        return;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES];\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tvoid *resp_buf;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tstruct page *localpage = NULL;\n\tint ret;\n\n\tif (buflen < PAGE_SIZE) {\n\t\t/* As long as we're doing a round trip to the server anyway,\n\t\t * let's be prepared for a page of acl data. */\n\t\tlocalpage = alloc_page(GFP_KERNEL);\n\t\tresp_buf = page_address(localpage);\n\t\tif (localpage == NULL)\n\t\t\treturn -ENOMEM;\n\t\targs.acl_pages[0] = localpage;\n\t\targs.acl_pgbase = 0;\n\t\targs.acl_len = PAGE_SIZE;\n\t} else {\n\t\tresp_buf = buf;\n\t\tbuf_to_pages(buf, buflen, args.acl_pages, &args.acl_pgbase);\n\t}\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\tif (res.acl_len > args.acl_len)\n\t\tnfs4_write_cached_acl(inode, NULL, res.acl_len);\n\telse\n\t\tnfs4_write_cached_acl(inode, resp_buf, res.acl_len);\n\tif (buf) {\n\t\tret = -ERANGE;\n\t\tif (res.acl_len > buflen)\n\t\t\tgoto out_free;\n\t\tif (localpage)\n\t\t\tmemcpy(buf, resp_buf, res.acl_len);\n\t}\n\tret = res.acl_len;\nout_free:\n\tif (localpage)\n\t\t__free_page(localpage);\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tvoid *resp_buf;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint ret = -ENOMEM, npages, i, acl_len = 0;\n\n\tnpages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\tif (npages > 1) {\n\t\t/* for decoding across pages */\n\t\targs.acl_scratch = alloc_page(GFP_KERNEL);\n\t\tif (!args.acl_scratch)\n\t\t\tgoto out_free;\n\t}\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\t/* Let decode_getfacl know not to fail if the ACL data is larger than\n\t * the page we send as a guess */\n\tif (buf == NULL)\n\t\tres.acl_flags |= NFS4_ACL_LEN_REQUEST;\n\tresp_buf = page_address(pages[0]);\n\n\tdprintk(\"%s  buf %p buflen %ld npages %d args.acl_len %ld\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\tacl_len = res.acl_len - res.acl_data_offset;\n\tif (acl_len > args.acl_len)\n\t\tnfs4_write_cached_acl(inode, NULL, acl_len);\n\telse\n\t\tnfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,\n\t\t\t\t      acl_len);\n\tif (buf) {\n\t\tret = -ERANGE;\n\t\tif (acl_len > buflen)\n\t\t\tgoto out_free;\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n\t\t\t\tres.acl_len);\n\t}\n\tret = acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (args.acl_scratch)\n\t\t__free_page(args.acl_scratch);\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "MONGO_EXPORT bson_type bson_iterator_next( bson_iterator *i ) {\n    int ds;\n\n    if ( i->first ) {\n        i->first = 0;\n        return ( bson_type )( *i->cur );\n    }\n\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_EOO:\n        return BSON_EOO; /* don't advance */\n    case BSON_UNDEFINED:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "MONGO_EXPORT bson_type bson_iterator_next( bson_iterator *i ) {\n    size_t ds;\n\n    if ( i->first ) {\n        i->first = 0;\n        return ( bson_type )( *i->cur );\n    }\n\n    switch ( bson_iterator_type( i ) ) {\n    case BSON_EOO:\n        return BSON_EOO; /* don't advance */\n    case BSON_UNDEFINED:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void ModifiablePixelBuffer::fillRect(const Rect& r, const void* pix)\n{\n  int stride;\n  U8 *buf;\n  int w, h, b;\n\n  w = r.width();\n  h = r.height();\n  b = format.bpp/8;\n\n  if (h == 0)\n    return;\n\n  buf = getBufferRW(r, &stride);\n\n  if (b == 1) {\n    while (h--) {\n      memset(buf, *(const U8*)pix, w);\n      buf += stride * b;\n    }\n  } else {\n    U8 *start;\n    int w1;\n\n    }\n    buf += (stride - w) * b;\n    h--;\n\n    while (h--) {\n      memcpy(buf, start, w * b);\n      buf += stride * b;\n    }\n  }\n\n  commitBufferRW(r);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void ModifiablePixelBuffer::fillRect(const Rect& r, const void* pix)\n{\n  int stride;\n  U8 *buf;\n  int w, h, b;\n  Rect drect;\n\n  drect = r;\n  if (!drect.enclosed_by(getRect())) {\n    vlog.error(\"Destination rect %dx%d at %d,%d exceeds framebuffer %dx%d\",\n               drect.width(), drect.height(), drect.tl.x, drect.tl.y, width_, height_);\n    drect = drect.intersect(getRect());\n  }\n\n  if (drect.is_empty())\n    return;\n\n  w = drect.width();\n  h = drect.height();\n  b = format.bpp/8;\n\n  if (h == 0)\n    return;\n\n  buf = getBufferRW(drect, &stride);\n\n  if (b == 1) {\n    while (h--) {\n      memset(buf, *(const U8*)pix, w);\n      buf += stride * b;\n    }\n  } else {\n    U8 *start;\n    int w1;\n\n    }\n    buf += (stride - w) * b;\n    h--;\n\n    while (h--) {\n      memcpy(buf, start, w * b);\n      buf += stride * b;\n    }\n  }\n\n  commitBufferRW(drect);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static Jsi_RC NumberToPrecisionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<=0) return JSI_ERROR;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf),\"%.*\" JSI_NUMFFMT, prec, num);\n    if (num<0)\n        prec++;\n    buf[prec+1] = 0;\n    if (buf[prec] == '.')\n        buf[prec] = 0;\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static Jsi_RC NumberToPrecisionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[JSI_MAX_NUMBER_STRING*2];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<=0 || prec>JSI_MAX_NUMBER_STRING) return Jsi_LogError(\"precision must be between 1 and %d\", JSI_MAX_NUMBER_STRING);\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf),\"%.*\" JSI_NUMFFMT, prec, num);\n    if (num<0)\n        prec++;\n    buf[prec+1] = 0;\n    if (buf[prec] == '.')\n        buf[prec] = 0;\n    Jsi_ValueMakeStringDup(interp, ret, buf);\n    return JSI_OK;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int em_loop(struct x86_emulate_ctxt *ctxt)\n{\n\tregister_address_increment(ctxt, reg_rmw(ctxt, VCPU_REGS_RCX), -1);\n\tif ((address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) != 0) &&\n\t    (ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\n\treturn X86EMUL_CONTINUE;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int em_loop(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\tregister_address_increment(ctxt, reg_rmw(ctxt, VCPU_REGS_RCX), -1);\n\tif ((address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) != 0) &&\n\t    (ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))\n\t\trc = jmp_rel(ctxt, ctxt->src.val);\n\n\treturn rc;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "         //Calculate the corresponding index in the table\n         k = crc & 0x3F;\n         //Update hash table contents\n         hashTable[k / 8] |= (1 << (k % 8));\n      }\n   }\n\n   //Write the hash table to the DM9000 controller\n   for(i = 0; i < 8; i++)\n   {\n      dm9000WriteReg(DM9000_REG_MAR0 + i, hashTable[i]);\n   }\n\n   //Debug message\n   TRACE_DEBUG(\"  MAR = %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" \"\n      \"%02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \"\\r\\n\",\n      dm9000ReadReg(DM9000_REG_MAR0), dm9000ReadReg(DM9000_REG_MAR1),\n      dm9000ReadReg(DM9000_REG_MAR2), dm9000ReadReg(DM9000_REG_MAR3),\n      dm9000ReadReg(DM9000_REG_MAR4), dm9000ReadReg(DM9000_REG_MAR5),\n      dm9000ReadReg(DM9000_REG_MAR6), dm9000ReadReg(DM9000_REG_MAR7));\n\n   //Successful processing\n   return NO_ERROR;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "         //Calculate the corresponding index in the table\n         k = crc & 0x3F;\n         //Update hash table contents\n         hashTable[k / 8] |= (1 << (k % 8));\n      }\n   }\n\n   //Write the hash table to the DM9000 controller\n   for(i = 0; i < 8; i++)\n   {\n      dm9000WriteReg(DM9000_MAR0 + i, hashTable[i]);\n   }\n\n   //Debug message\n   TRACE_DEBUG(\"  MAR = %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" \"\n      \"%02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \"\\r\\n\",\n      dm9000ReadReg(DM9000_MAR0), dm9000ReadReg(DM9000_MAR1),\n      dm9000ReadReg(DM9000_MAR2), dm9000ReadReg(DM9000_MAR3),\n      dm9000ReadReg(DM9000_MAR4), dm9000ReadReg(DM9000_MAR5),\n      dm9000ReadReg(DM9000_MAR6), dm9000ReadReg(DM9000_MAR7));\n\n   //Successful processing\n   return NO_ERROR;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tif (retval < 0)\n\t\tgoto _error;\n\tbprm->argc++;\n\n\t/* add the interp as argv[0] */\n\tretval = copy_strings_kernel (1, &iname_addr, bprm);\n\tif (retval < 0)\n\t\tgoto _error;\n\tbprm->argc ++;\n\n\tbprm->interp = iname;\t/* for binfmt_script */\n\n\tinterp_file = open_exec (iname);\n\tretval = PTR_ERR (interp_file);\n\tif (IS_ERR (interp_file))\n\t\tgoto _error;\n\n\tbprm->file = interp_file;\n\tif (fmt->flags & MISC_FMT_CREDENTIALS) {\n\t\t/*\n\t\t * No need to call prepare_binprm(), it's already been",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tif (retval < 0)\n\t\tgoto _error;\n\tbprm->argc++;\n\n\t/* add the interp as argv[0] */\n\tretval = copy_strings_kernel (1, &iname_addr, bprm);\n\tif (retval < 0)\n\t\tgoto _error;\n\tbprm->argc ++;\n\n\t/* Update interp in case binfmt_script needs it. */\n\tretval = bprm_change_interp(iname, bprm);\n\tif (retval < 0)\n\t\tgoto _error;\n\n\tinterp_file = open_exec (iname);\n\tretval = PTR_ERR (interp_file);\n\tif (IS_ERR (interp_file))\n\t\tgoto _error;\n\n\tbprm->file = interp_file;\n\tif (fmt->flags & MISC_FMT_CREDENTIALS) {\n\t\t/*\n\t\t * No need to call prepare_binprm(), it's already been",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void Curl_detach_connnection(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  if(conn)\n    Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);\n  data->conn = NULL;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void Curl_detach_connnection(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  if(conn) {\n    Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);\n    Curl_ssl_detach_conn(data, conn);\n  }\n  data->conn = NULL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void RegKey::setBinary(const TCHAR* valname, const void* value, int length) const {\n  LONG result = RegSetValueEx(key, valname, 0, REG_BINARY, (const BYTE*)value, length);\n  if (result != ERROR_SUCCESS) throw rdr::SystemException(\"setBinary\", result);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void RegKey::setBinary(const TCHAR* valname, const void* value, size_t length) const {\n  LONG result = RegSetValueEx(key, valname, 0, REG_BINARY, (const BYTE*)value, length);\n  if (result != ERROR_SUCCESS) throw rdr::SystemException(\"setBinary\", result);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static ssize_t _hostfs_pread(\n    oe_fd_t* desc,\n    void* buf,\n    size_t count,\n    oe_off_t offset)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_pread_ocall(&ret, file->host_fd, buf, count, offset) !=\n        OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static ssize_t _hostfs_pread(\n    oe_fd_t* desc,\n    void* buf,\n    size_t count,\n    oe_off_t offset)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    /*\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/pread.html for\n     * for more detail.\n     */\n    if (!file || count > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_pread_ocall(&ret, file->host_fd, buf, count, offset) !=\n        OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed count.\n     */\n    if (ret > (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t/* For each character of field, search if it appears in the list\n\t * of illegal characters. */\n\tfor (cp = field; '\\0' != *cp; cp++) {\n\t\tif (strchr (illegal, *cp) != NULL) {\n\t\t\terr = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (0 == err) {\n\t\t/* Search if there are some non-printable characters */\n\t\tfor (cp = field; '\\0' != *cp; cp++) {\n\t\t\tif (!isprint (*cp)) {\n\t\t\t\terr = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn err;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t/* For each character of field, search if it appears in the list\n\t * of illegal characters. */\n\tfor (cp = field; '\\0' != *cp; cp++) {\n\t\tif (strchr (illegal, *cp) != NULL) {\n\t\t\terr = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (0 == err) {\n\t\t/* Search if there are non-printable or control characters */\n\t\tfor (cp = field; '\\0' != *cp; cp++) {\n\t\t\tif (!isprint (*cp)) {\n\t\t\t\terr = 1;\n\t\t\t}\n\t\t\tif (!iscntrl (*cp)) {\n\t\t\t\terr = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn err;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int parse_config(char *filename, bridge_t **bridges)\n{\n    dictionary *ubridge_config = NULL;\n    const char *value;\n    const char *bridge_name;\n    int i, nsec;\n\n    if ((ubridge_config = iniparser_load(filename)) == NULL) {\n       return FALSE;\n    }\n\n    nsec = iniparser_getnsec(ubridge_config);\n    for (i = 0; i < nsec; i++) {\n        bridge_t *bridge;\n        nio_t *source_nio = NULL;\n        nio_t *destination_nio = NULL;\n\n        bridge_name = iniparser_getsecname(ubridge_config, i);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int parse_config(char *filename, bridge_t **bridges)\n{\n    dictionary *ubridge_config = NULL;\n    const char *value;\n    const char *bridge_name;\n    int i, nsec;\n\n    if ((ubridge_config = iniparser_load(filename, HIDE_ERRORED_LINE_CONTENT)) == NULL) {\n       return FALSE;\n    }\n\n    nsec = iniparser_getnsec(ubridge_config);\n    for (i = 0; i < nsec; i++) {\n        bridge_t *bridge;\n        nio_t *source_nio = NULL;\n        nio_t *destination_nio = NULL;\n\n        bridge_name = iniparser_getsecname(ubridge_config, i);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static u64 __skb_get_nlattr_nest(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n\n\tif (skb_is_nonlinear(skb))\n\t\treturn 0;\n\n\tif (A > skb->len - sizeof(struct nlattr))\n\t\treturn 0;\n\n\tnla = (struct nlattr *) &skb->data[A];\n\tif (nla->nla_len > A - skb->len)\n\t\treturn 0;\n\n\tnla = nla_find_nested(nla, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static u64 __skb_get_nlattr_nest(u64 ctx, u64 A, u64 X, u64 r4, u64 r5)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n\n\tif (skb_is_nonlinear(skb))\n\t\treturn 0;\n\n\tif (skb->len < sizeof(struct nlattr))\n\t\treturn 0;\n\n\tif (A > skb->len - sizeof(struct nlattr))\n\t\treturn 0;\n\n\tnla = (struct nlattr *) &skb->data[A];\n\tif (nla->nla_len > skb->len - A)\n\t\treturn 0;\n\n\tnla = nla_find_nested(nla, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;\n\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int rand_check(uint8_t *buf, int size) {\n\tint count = 0;\n\n\tfor (int i = 1; i < size; i++) {\n\t\tif (buf[i] == buf[i - 1]) {\n\t\t\tcount++;\n\t\t} else {\n\t\t\tcount = 0;\n\t\t}\n\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int rand_check(uint8_t *buf, size_t size) {\n\tint count = 0;\n\n\tfor (int i = 1; i < size; i++) {\n\t\tif (buf[i] == buf[i - 1]) {\n\t\t\tcount++;\n\t\t} else {\n\t\t\tcount = 0;\n\t\t}\n\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n\tuint_fast16_t numcmpts;\n\tlong n;\n\n\tif (optstr) {\n\t\tjas_eprintf(\"warning: ignoring BMP decoder options\\n\");\n\t}\n\n\tjas_eprintf(\n\t  \"THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\"\n\t  \"THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\"\n\t  \"IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\"\n\t  \"TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\"\n\t  );\n\n\t/* Read the bitmap header. */\n\tif (bmp_gethdr(in, &hdr)) {\n\t\tjas_eprintf(\"cannot get header\\n\");\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(1, (\n\t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n\t  ));\n\n\t/* Read the bitmap information. */\n\tif (!(info = bmp_getinfo(in))) {\n\t\tjas_eprintf(\"cannot get info\\n\");\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(1,\n\t  (\"BMP information: len %d; width %d; height %d; numplanes %d; \"\n\t  \"depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \"\n\t  \"mincolors %d\\n\", info->len, info->width, info->height, info->numplanes,\n\t  info->depth, info->enctype, info->siz, info->hres, info->vres,\n\t  info->numcolors, info->mincolors));\n\n\t/* Ensure that we support this type of BMP file. */\n\tif (!bmp_issupported(&hdr, info)) {\n\t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\t/* Skip over any useless data between the end of the palette\n\t  and start of the bitmap data. */\n\tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n\t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");\n\t\treturn 0;\n\t}\n\tif (n > 0) {\n\t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");\n\t\tif (bmp_gobble(in, n)) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n\t/* Create image object. */\n\tif (!(image = jas_image_create(numcmpts, cmptparms,\n\t  JAS_CLRSPC_UNKNOWN))) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Read the bitmap data. */\n\tif (bmp_getdata(in, info, image)) {\n\t\tbmp_info_destroy(info);\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n\t}\n\n\tbmp_info_destroy(info);\n\n\treturn image;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)\n{\n\tjas_image_t *image;\n\tbmp_hdr_t hdr;\n\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n\tuint_fast16_t numcmpts;\n\tlong n;\n\n\timage = 0;\n\tinfo = 0;\n\n\tif (optstr) {\n\t\tjas_eprintf(\"warning: ignoring BMP decoder options\\n\");\n\t}\n\n\tjas_eprintf(\n\t  \"THE BMP FORMAT IS NOT FULLY SUPPORTED!\\n\"\n\t  \"THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\\n\"\n\t  \"IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\\n\"\n\t  \"TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\\n\"\n\t  );\n\n\t/* Read the bitmap header. */\n\tif (bmp_gethdr(in, &hdr)) {\n\t\tjas_eprintf(\"cannot get header\\n\");\n\t\tgoto error;\n\t\t//return 0;\n\t}\n\tJAS_DBGLOG(1, (\n\t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n\t  ));\n\n\t/* Read the bitmap information. */\n\tif (!(info = bmp_getinfo(in))) {\n\t\tjas_eprintf(\"cannot get info\\n\");\n\t\t//return 0;\n\t\tgoto error;\n\t}\n\tJAS_DBGLOG(1,\n\t  (\"BMP information: len %ld; width %ld; height %ld; numplanes %d; \"\n\t  \"depth %d; enctype %ld; siz %ld; hres %ld; vres %ld; numcolors %ld; \"\n\t  \"mincolors %ld\\n\", JAS_CAST(long, info->len),\n\t  JAS_CAST(long, info->width), JAS_CAST(long, info->height),\n\t  JAS_CAST(long, info->numplanes), JAS_CAST(long, info->depth),\n\t  JAS_CAST(long, info->enctype), JAS_CAST(long, info->siz),\n\t  JAS_CAST(long, info->hres), JAS_CAST(long, info->vres),\n\t  JAS_CAST(long, info->numcolors), JAS_CAST(long, info->mincolors)));\n\n\tif (info->width < 0 || info->height < 0 || info->numplanes < 0 ||\n\t  info->depth < 0 || info->siz < 0 || info->hres < 0 || info->vres < 0) {\n\t\tjas_eprintf(\"corrupt bit stream\\n\");\n\t\tgoto error;\n\t}\n\n\t/* Ensure that we support this type of BMP file. */\n\tif (!bmp_issupported(&hdr, info)) {\n\t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");\n\t\t//bmp_info_destroy(info);\n\t\t//return 0;\n\t\tgoto error;\n\t}\n\n\t/* Skip over any useless data between the end of the palette\n\t  and start of the bitmap data. */\n\tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n\t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");\n\t\tgoto error;\n\t\t//return 0;\n\t}\n\tif (n > 0) {\n\t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");\n\t\tif (bmp_gobble(in, n)) {\n\t\t\t//bmp_info_destroy(info);\n\t\t\t//return 0;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* Get the number of components. */\n\tnumcmpts = bmp_numcmpts(info);\n\n\tfor (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,\n\t  ++cmptparm) {\n\t\tcmptparm->tlx = 0;\n\t\tcmptparm->tly = 0;\n\t\tcmptparm->vstep = 1;\n\t\tcmptparm->width = info->width;\n\t\tcmptparm->height = info->height;\n\t\tcmptparm->prec = 8;\n\t\tcmptparm->sgnd = false;\n\t}\n\n\t/* Create image object. */\n\tif (!(image = jas_image_create(numcmpts, cmptparms,\n\t  JAS_CLRSPC_UNKNOWN))) {\n\t\t//bmp_info_destroy(info);\n\t\t//return 0;\n\t\tgoto error;\n\t}\n\n\tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));\n\t\tjas_image_setcmpttype(image, 1,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));\n\t\tjas_image_setcmpttype(image, 2,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));\n\t} else {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SGRAY);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t/* Read the bitmap data. */\n\tif (bmp_getdata(in, info, image)) {\n\t\t//bmp_info_destroy(info);\n\t\t//jas_image_destroy(image);\n\t\t//return 0;\n\t\tgoto error;\n\t}\n\n\tbmp_info_destroy(info);\n\n\treturn image;\n\nerror:\n\tif (info) {\n\t\tbmp_info_destroy(info);\n\t}\n\tif (image) {\n\t\tjas_image_destroy(image);\n\t}\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteMulParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n\n  const bool requires_broadcast = !HaveSameShapes(input1, input2);\n\n  TfLiteIntArray* output_size = nullptr;\n  if (requires_broadcast) {\n    TF_LITE_ENSURE_OK(context, CalculateShapeForBroadcast(\n                                   context, input1, input2, &output_size));\n  } else {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteMulParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n\n  const bool requires_broadcast = !HaveSameShapes(input1, input2);\n\n  TfLiteIntArray* output_size = nullptr;\n  if (requires_broadcast) {\n    TF_LITE_ENSURE_OK(context, CalculateShapeForBroadcast(\n                                   context, input1, input2, &output_size));\n  } else {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "Jsi_Value *Jsi_ValueArrayIndex(Jsi_Interp *interp, Jsi_Value *args, int index)\n{\n    Jsi_Obj *obj = args->d.obj;\n    Jsi_Value *v;\n    assert(args->vt == JSI_VT_OBJECT);\n    if (obj->isarrlist && obj->arr)\n        return ((index < 0 || (uint)index >= obj->arrCnt) ? NULL : obj->arr[index]);\n    char unibuf[100];\n    Jsi_NumberItoA10(index, unibuf, sizeof(unibuf));\n    v = Jsi_TreeObjGetValue(args->d.obj, unibuf, 0);\n    return v;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "Jsi_Value *Jsi_ValueArrayIndex(Jsi_Interp *interp, Jsi_Value *args, int index)\n{\n    Jsi_Obj *obj = args->d.obj;\n    Jsi_Value *v;\n    assert(args->vt == JSI_VT_OBJECT);\n    if (obj->isarrlist && obj->arr)\n        return ((index < 0 || (uint)index >= obj->arrCnt) ? NULL : obj->arr[index]);\n    char unibuf[JSI_MAX_NUMBER_STRING];\n    Jsi_NumberItoA10(index, unibuf, sizeof(unibuf));\n    v = Jsi_TreeObjGetValue(args->d.obj, unibuf, 0);\n    return v;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tset_desc_limit(&seg_desc, 0xffff);\n\t\tseg_desc.type = 3;\n\t\tseg_desc.p = 1;\n\t\tseg_desc.s = 1;\n\t\tseg_desc.dpl = 3;\n\t\tgoto load;\n\t}\n\n\trpl = selector & 3;\n\n\t/* NULL selector is not valid for TR, CS and SS (except for long mode) */\n\tif ((seg == VCPU_SREG_CS\n\t     || (seg == VCPU_SREG_SS\n\t\t && (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))\n\t     || seg == VCPU_SREG_TR)\n\t    && null_selector)\n\t\tgoto exception;\n\n\t/* TR should be in GDT only */\n\tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n\t\tgoto exception;\n\n\tif (null_selector) /* for NULL selector skip all following checks */\n\t\tgoto load;\n\n\tret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\terr_code = selector & 0xfffc;\n\terr_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :\n\t\t\t\t\t\t\t   GP_VECTOR;\n\n\t/* can't load system descriptor into segment selector */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tset_desc_base(&seg_desc, selector << 4);\n\t\tset_desc_limit(&seg_desc, 0xffff);\n\t\tseg_desc.type = 3;\n\t\tseg_desc.p = 1;\n\t\tseg_desc.s = 1;\n\t\tseg_desc.dpl = 3;\n\t\tgoto load;\n\t}\n\n\trpl = selector & 3;\n\n\t/* TR should be in GDT only */\n\tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n\t\tgoto exception;\n\n\t/* NULL selector is not valid for TR, CS and (except for long mode) SS */\n\tif (null_selector) {\n\t\tif (seg == VCPU_SREG_CS || seg == VCPU_SREG_TR)\n\t\t\tgoto exception;\n\n\t\tif (seg == VCPU_SREG_SS) {\n\t\t\tif (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl)\n\t\t\t\tgoto exception;\n\n\t\t\t/*\n\t\t\t * ctxt->ops->set_segment expects the CPL to be in\n\t\t\t * SS.DPL, so fake an expand-up 32-bit data segment.\n\t\t\t */\n\t\t\tseg_desc.type = 3;\n\t\t\tseg_desc.p = 1;\n\t\t\tseg_desc.s = 1;\n\t\t\tseg_desc.dpl = cpl;\n\t\t\tseg_desc.d = 1;\n\t\t\tseg_desc.g = 1;\n\t\t}\n\n\t\t/* Skip all following checks */\n\t\tgoto load;\n\t}\n\n\tret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\terr_code = selector & 0xfffc;\n\terr_vec = (transfer == X86_TRANSFER_TASK_SWITCH) ? TS_VECTOR :\n\t\t\t\t\t\t\t   GP_VECTOR;\n\n\t/* can't load system descriptor into segment selector */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  int i;\n  int count;\n\n  assert(index >= 0);\n  assert(object->type == OBJECT_TYPE_ARRAY);\n\n  array = object_as_array(object);\n\n  if (array->items == NULL)\n  {\n    count = yr_max(64, (index + 1) * 2);\n\n    array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));\n\n    array->items->count = count;\n  }\n  else if (index >= array->items->count)\n  {\n    count = array->items->count * 2;\n    array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n        array->items,\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    for (i = array->items->count; i < count; i++)\n      array->items->objects[i] = NULL;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  int i;\n  int count;\n\n  assert(index >= 0);\n  assert(object->type == OBJECT_TYPE_ARRAY);\n\n  array = object_as_array(object);\n\n  if (array->items == NULL)\n  {\n    count = 64;\n\n    while (count <= index)\n      count *= 2;\n\n    array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    memset(array->items->objects, 0, count * sizeof(YR_OBJECT*));\n\n    array->items->count = count;\n  }\n  else if (index >= array->items->count)\n  {\n    count = array->items->count * 2;\n\n    while (count <= index)\n      count *= 2;\n\n    array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n        array->items,\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n      return ERROR_INSUFFICIENT_MEMORY;\n\n    for (i = array->items->count; i < count; i++)\n      array->items->objects[i] = NULL;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  void AddBatchOffsets(Tensor* indices, const Tensor& params) {\n    int64_t batch_size = 1;  // The size of all batch dimensions.\n    for (int idx = 0; idx < batch_dims_; ++idx) {\n      batch_size *= params.dim_size(idx);\n    }\n\n    auto indices_flat = indices->flat<Index>();\n    int64_t const index_inner_size = indices->NumElements() / batch_size;\n    int64_t const batch_offset = params.dim_size(batch_dims_);\n    for (int64_t batch_idx = 0, dest_idx = 0; batch_idx < batch_size;\n         ++batch_idx) {\n      for (int64_t idx = 0; idx < index_inner_size; ++idx) {\n        indices_flat(dest_idx++) += batch_offset * batch_idx;\n      }\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  void AddBatchOffsets(OpKernelContext* ctx, Tensor* indices,\n                       const Tensor& params) {\n    int64_t batch_size = 1;  // The size of all batch dimensions.\n    for (int idx = 0; idx < batch_dims_; ++idx) {\n      batch_size *= params.dim_size(idx);\n    }\n    OP_REQUIRES(\n        ctx, batch_size != 0,\n        errors::InvalidArgument(\n            \"Inner size of indices would result in batch_size of 0 and a \",\n            \"division by 0 in the implementation. This is illegal\"));\n\n    auto indices_flat = indices->flat<Index>();\n    int64_t const index_inner_size = indices->NumElements() / batch_size;\n    int64_t const batch_offset = params.dim_size(batch_dims_);\n    for (int64_t batch_idx = 0, dest_idx = 0; batch_idx < batch_size;\n         ++batch_idx) {\n      for (int64_t idx = 0; idx < index_inner_size; ++idx) {\n        indices_flat(dest_idx++) += batch_offset * batch_idx;\n      }\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n    holder = malloc(sizeof(*holder));\n    if (holder == NULL) {\n        return -1;\n    }\n\n    holder->packetLength = sizeof(NV_SCROLL_PACKET);\n    holder->packet.scroll.header.packetType = htonl(PACKET_TYPE_SCROLL);\n    holder->packet.scroll.magicA = MAGIC_A;\n    // On Gen 5 servers, the header code is incremented by one\n    if (ServerMajorVersion >= 5) {\n        holder->packet.scroll.magicA++;\n    }\n    holder->packet.scroll.zero1 = 0;\n    holder->packet.scroll.zero2 = 0;\n    holder->packet.scroll.scrollAmt1 = htons(scrollClicks * 120);\n    holder->packet.scroll.scrollAmt2 = holder->packet.scroll.scrollAmt1;\n    holder->packet.scroll.zero3 = 0;\n\n    err = LbqOfferQueueItem(&packetQueue, holder, &holder->entry);\n    if (err != LBQ_SUCCESS) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n    holder = malloc(sizeof(*holder));\n    if (holder == NULL) {\n        return -1;\n    }\n\n    holder->packetLength = sizeof(NV_SCROLL_PACKET);\n    holder->packet.scroll.header.packetType = htonl(PACKET_TYPE_SCROLL);\n    holder->packet.scroll.magicA = MAGIC_A;\n    // On Gen 5 servers, the header code is incremented by one\n    if (AppVersionQuad[0] >= 5) {\n        holder->packet.scroll.magicA++;\n    }\n    holder->packet.scroll.zero1 = 0;\n    holder->packet.scroll.zero2 = 0;\n    holder->packet.scroll.scrollAmt1 = htons(scrollClicks * 120);\n    holder->packet.scroll.scrollAmt2 = holder->packet.scroll.scrollAmt1;\n    holder->packet.scroll.zero3 = 0;\n\n    err = LbqOfferQueueItem(&packetQueue, holder, &holder->entry);\n    if (err != LBQ_SUCCESS) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t}\n\n\taddr_type = ipv6_addr_type(&hdr->saddr);\n\n\t/*\n\t *\tSource addr check\n\t */\n\n\tif (__ipv6_addr_needs_scope_id(addr_type))\n\t\tiif = skb->dev->ifindex;\n\telse\n\t\tiif = l3mdev_master_ifindex(skb_dst(skb)->dev);\n\n\t/*\n\t *\tMust not send error if the source does not uniquely\n\t *\tidentify a single node (RFC2463 Section 2.4).\n\t *\tWe check unspecified / multicast addresses here,\n\t *\tand anycast addresses will be checked later.\n\t */\n\tif ((addr_type == IPV6_ADDR_ANY) || (addr_type & IPV6_ADDR_MULTICAST)) {\n\t\tnet_dbg_ratelimited(\"icmp6_send: addr_any/mcast source [%pI6c > %pI6c]\\n\",\n\t\t\t\t    &hdr->saddr, &hdr->daddr);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t}\n\n\taddr_type = ipv6_addr_type(&hdr->saddr);\n\n\t/*\n\t *\tSource addr check\n\t */\n\n\tif (__ipv6_addr_needs_scope_id(addr_type))\n\t\tiif = skb->dev->ifindex;\n\telse {\n\t\tdst = skb_dst(skb);\n\t\tiif = l3mdev_master_ifindex(dst ? dst->dev : skb->dev);\n\t}\n\n\t/*\n\t *\tMust not send error if the source does not uniquely\n\t *\tidentify a single node (RFC2463 Section 2.4).\n\t *\tWe check unspecified / multicast addresses here,\n\t *\tand anycast addresses will be checked later.\n\t */\n\tif ((addr_type == IPV6_ADDR_ANY) || (addr_type & IPV6_ADDR_MULTICAST)) {\n\t\tnet_dbg_ratelimited(\"icmp6_send: addr_any/mcast source [%pI6c > %pI6c]\\n\",\n\t\t\t\t    &hdr->saddr, &hdr->daddr);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "find_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n{\n\tunsigned int hash = hash_link_ref(name, length);\n\tstruct link_ref *ref = NULL;\n\n\tref = references[hash % REF_TABLE_SIZE];\n\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash)\n\t\t\treturn ref;\n\n\t\tref = ref->next;\n\t}\n\n\treturn NULL;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "find_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n{\n\tunsigned int hash = hash_link_ref(name, length);\n\tstruct link_ref *ref = NULL;\n\n\tref = references[hash % REF_TABLE_SIZE];\n\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash && ref->label->size == length) {\n\t\t\tif (strncasecmp((char *)ref->label->data, (char *) name, length) == 0) {\n\t\t\t\treturn ref;\n\t\t\t}\n\t\t}\n\n\t\tref = ref->next;\n\t}\n\n\treturn NULL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "          break;\n        }\n        Data data;\n        if (!zone.readString(text)) {\n          STOFF_DEBUG_MSG((\"StarWriterStruct::DatabaseName::read: can not read a table name string\\n\"));\n          f << \"###dbDataName\";\n          break;\n        }\n        data.m_name=libstoff::getString(text);\n        int positions[2];\n        for (int j=0; j<2; ++j) positions[i]=int(input->readULong(4));\n        data.m_selection=STOFFVec2i(positions[0],positions[1]);\n        m_dataList.push_back(data);\n      }\n    }\n  }\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarDatabaseName\");\n  return true;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "          break;\n        }\n        Data data;\n        if (!zone.readString(text)) {\n          STOFF_DEBUG_MSG((\"StarWriterStruct::DatabaseName::read: can not read a table name string\\n\"));\n          f << \"###dbDataName\";\n          break;\n        }\n        data.m_name=libstoff::getString(text);\n        int positions[2];\n        for (int j=0; j<2; ++j) positions[j]=int(input->readULong(4));\n        data.m_selection=STOFFVec2i(positions[0],positions[1]);\n        m_dataList.push_back(data);\n      }\n    }\n  }\n  f << *this;\n  ascFile.addPos(pos);\n  ascFile.addNote(f.str().c_str());\n  zone.closeSWRecord(type, \"StarDatabaseName\");\n  return true;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  void Compute(OpKernelContext* ctx) override {\n    try {\n      const Tensor& input = ctx->input(kInputTensorIndex);\n      const Tensor& input_min_vec = ctx->input(kInputMinVecIndex);\n      float* input_min_vec_data = (float*)const_cast<void*>(\n          static_cast<const void*>(input_min_vec.flat<float>().data()));\n      const Tensor& input_max_vec = ctx->input(kInputMaxVecIndex);\n      float* input_max_vec_data = (float*)const_cast<void*>(\n          static_cast<const void*>(input_max_vec.flat<float>().data()));\n\n      const Tensor& input_requested_min = ctx->input(this->kRequestMinIndex);\n      const float input_requested_min_float =\n          input_requested_min.flat<float>()(0);\n      const Tensor& input_requested_max = ctx->input(this->kRequestMaxIndex);\n      const float input_requested_max_float =\n          input_requested_max.flat<float>()(0);\n\n      size_t depth = input_min_vec.NumElements();\n      OP_REQUIRES(\n          ctx, input.dims() == 4,\n          errors::InvalidArgument(\"Current RequantizePerChannel operator\"\n                                  \"supports 4D tensors only.\"));\n      OP_REQUIRES(\n          ctx, input_min_vec.dim_size(0) == depth,\n          errors::InvalidArgument(\"input_min has incorrect size, expected \",\n                                  depth, \" was \", input_min_vec.dim_size(0)));\n      OP_REQUIRES(\n          ctx, input_max_vec.dim_size(0) == depth,\n          errors::InvalidArgument(\"input_max has incorrect size, expected \",\n                                  depth, \" was \", input_max_vec.dim_size(0)));\n\n      if (out_type_ == DT_QINT8) DCHECK(input_requested_min_float < 0.0f);\n\n      const float factor = (out_type_ == DT_QINT8) ? 127.0f : 255.0f;\n      const float requested_min_max =\n          std::max(std::abs(input_requested_min_float),\n                   std::abs(input_requested_max_float));\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(kOutputTensorIndex,\n                                               input.shape(), &output));\n\n      std::vector<float> scales(depth);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  void Compute(OpKernelContext* ctx) override {\n    try {\n      const Tensor& input = ctx->input(kInputTensorIndex);\n      OP_REQUIRES(\n          ctx, input.dims() == 4,\n          errors::InvalidArgument(\"Current RequantizePerChannel operator\"\n                                  \"supports 4D tensors only.\"));\n\n      const Tensor& input_min_vec = ctx->input(kInputMinVecIndex);\n      size_t depth = input_min_vec.NumElements();\n      float* input_min_vec_data = (float*)const_cast<void*>(\n          static_cast<const void*>(input_min_vec.flat<float>().data()));\n\n      const Tensor& input_max_vec = ctx->input(kInputMaxVecIndex);\n      OP_REQUIRES(\n          ctx, input_max_vec.NumElements() == depth,\n          errors::InvalidArgument(\"input_max has incorrect size, expected \",\n                                  depth, \" was \", input_max_vec.NumElements()));\n      float* input_max_vec_data = (float*)const_cast<void*>(\n          static_cast<const void*>(input_max_vec.flat<float>().data()));\n\n      const Tensor& input_requested_min = ctx->input(this->kRequestMinIndex);\n      OP_REQUIRES(\n          ctx, input_requested_min.NumElements() == 1,\n          errors::InvalidArgument(\"requested_output_min must be a scalar\"));\n      const float input_requested_min_float =\n          input_requested_min.flat<float>()(0);\n\n      const Tensor& input_requested_max = ctx->input(this->kRequestMaxIndex);\n      OP_REQUIRES(\n          ctx, input_requested_min.NumElements() == 1,\n          errors::InvalidArgument(\"requested_output_max must be a scalar\"));\n      const float input_requested_max_float =\n          input_requested_max.flat<float>()(0);\n\n      if (out_type_ == DT_QINT8) {\n        OP_REQUIRES(ctx, input_requested_min_float < 0.0f,\n                    errors::InvalidArgument(\n                        \"If out_type is QINT8, requested_output_max must be \"\n                        \"non negative, got \",\n                        input_requested_min_float));\n      }\n\n      const float factor = (out_type_ == DT_QINT8) ? 127.0f : 255.0f;\n      const float requested_min_max =\n          std::max(std::abs(input_requested_min_float),\n                   std::abs(input_requested_max_float));\n      Tensor* output = nullptr;\n      OP_REQUIRES_OK(ctx, ctx->allocate_output(kOutputTensorIndex,\n                                               input.shape(), &output));\n\n      std::vector<float> scales(depth);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void nft_dynset_activate(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\n\tpriv->set->use++;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void nft_dynset_activate(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\n\tnf_tables_activate_set(ctx, priv->set);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t} else if (send_token != NO_TOKEN_SEND) {\n\t\tif (make_spnego_tokenTarg_msg(negState, GSS_C_NO_OID,\n\t\t\t\t\t      &mechtok_out, mechListMIC_out,\n\t\t\t\t\t      send_token,\n\t\t\t\t\t      output_token) < 0) {\n\t\t\tret = GSS_S_FAILURE;\n\t\t}\n\t}\n\tgss_release_buffer(&tmpmin, &mechtok_out);\n\tif (ret == GSS_S_COMPLETE) {\n\t\t/*\n\t\t * Now, switch the output context to refer to the\n\t\t * negotiated mechanism's context.\n\t\t */\n\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n\t\tif (actual_mech != NULL)\n\t\t\t*actual_mech = spnego_ctx->actual_mech;\n\t\tif (ret_flags != NULL)\n\t\t\t*ret_flags = spnego_ctx->ctx_flags;\n\t\trelease_spnego_ctx(&spnego_ctx);\n\t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n\t\tif (spnego_ctx != NULL) {\n\t\t\tgss_delete_sec_context(&tmpmin,\n\t\t\t\t\t       &spnego_ctx->ctx_handle,\n\t\t\t\t\t       GSS_C_NO_BUFFER);\n\t\t\trelease_spnego_ctx(&spnego_ctx);\n\t\t}\n\t\t*context_handle = GSS_C_NO_CONTEXT;\n\t}\n\tif (mechtok_in != GSS_C_NO_BUFFER) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t} else if (send_token != NO_TOKEN_SEND) {\n\t\tif (make_spnego_tokenTarg_msg(negState, GSS_C_NO_OID,\n\t\t\t\t\t      &mechtok_out, mechListMIC_out,\n\t\t\t\t\t      send_token,\n\t\t\t\t\t      output_token) < 0) {\n\t\t\tret = GSS_S_FAILURE;\n\t\t}\n\t}\n\tgss_release_buffer(&tmpmin, &mechtok_out);\n\tif (ret == GSS_S_COMPLETE) {\n\t\tspnego_ctx->opened = 1;\n\t\tif (actual_mech != NULL)\n\t\t\t*actual_mech = spnego_ctx->actual_mech;\n\t\tif (ret_flags != NULL)\n\t\t\t*ret_flags = spnego_ctx->ctx_flags;\n\t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n\t\tif (spnego_ctx != NULL) {\n\t\t\tgss_delete_sec_context(&tmpmin,\n\t\t\t\t\t       &spnego_ctx->ctx_handle,\n\t\t\t\t\t       GSS_C_NO_BUFFER);\n\t\t\trelease_spnego_ctx(&spnego_ctx);\n\t\t}\n\t\t*context_handle = GSS_C_NO_CONTEXT;\n\t}\n\tif (mechtok_in != GSS_C_NO_BUFFER) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int netlink_dump(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct netlink_callback *cb;\n\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tint len, err = -ENOBUFS;\n\tint alloc_min_size;\n\tint alloc_size;\n\n\tmutex_lock(nlk->cb_mutex);\n\tif (!nlk->cb_running) {\n\t\terr = -EINVAL;\n\t\tgoto errout_skb;\n\t}\n\n\tmemcpy(nlmsg_data(nlh), &len, sizeof(len));\n\n\tif (sk_filter(sk, skb))\n\t\tkfree_skb(skb);\n\telse\n\t\t__netlink_sendskb(sk, skb);\n\n\tif (cb->done)\n\t\tcb->done(cb);\n\n\tnlk->cb_running = false;\n\tmutex_unlock(nlk->cb_mutex);\n\tmodule_put(cb->module);\n\tconsume_skb(cb->skb);\n\treturn 0;\n\nerrout_skb:\n\tmutex_unlock(nlk->cb_mutex);\n\tkfree_skb(skb);\n\treturn err;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int netlink_dump(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct netlink_callback *cb;\n\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tstruct module *module;\n\tint len, err = -ENOBUFS;\n\tint alloc_min_size;\n\tint alloc_size;\n\n\tmutex_lock(nlk->cb_mutex);\n\tif (!nlk->cb_running) {\n\t\terr = -EINVAL;\n\t\tgoto errout_skb;\n\t}\n\n\n\tif (sk_filter(sk, skb))\n\t\tkfree_skb(skb);\n\telse\n\t\t__netlink_sendskb(sk, skb);\n\n\tif (cb->done)\n\t\tcb->done(cb);\n\n\tnlk->cb_running = false;\n\tmodule = cb->module;\n\tskb = cb->skb;\n\tmutex_unlock(nlk->cb_mutex);\n\tmodule_put(module);\n\tconsume_skb(skb);\n\treturn 0;\n\nerrout_skb:\n\tmutex_unlock(nlk->cb_mutex);\n\tkfree_skb(skb);\n\treturn err;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void md_map_sh256(uint8_t *hash, const uint8_t *msg, int len) {\n\tSHA256Context ctx;\n\n\tif (SHA256Reset(&ctx) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\tif (SHA256Input(&ctx, msg, len) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void md_map_sh256(uint8_t *hash, const uint8_t *msg, size_t len) {\n\tSHA256Context ctx;\n\n\tif (SHA256Reset(&ctx) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}\n\tif (SHA256Input(&ctx, msg, len) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tINPUT_RECORD ir[16] = {};\n\tint nLen = lstrlen(asRet);\n\tINPUT_RECORD* pir = (nLen <= (int)countof(ir)) ? ir : (INPUT_RECORD*)calloc(nLen,sizeof(INPUT_RECORD));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (int i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, SrvAnsi::de_Report);\n\n\tDWORD nWritten = 0;\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tINPUT_RECORD ir[16] = {};\n\tint nLen = lstrlen(asRet);\n\tINPUT_RECORD* pir = (nLen <= (int)countof(ir)) ? ir : (INPUT_RECORD*)calloc(nLen,sizeof(INPUT_RECORD));\n\tif (!pir)\n\t\treturn FALSE;\n\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (int i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = (*pc == 0x1B || *pc >= 0x20) ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}\n\n\tDumpKnownEscape(asRet, nLen, SrvAnsi::de_Report);\n\n\tDWORD nWritten = 0;\n\tHANDLE hIn = GetStdHandle(STD_INPUT_HANDLE);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tSetRunner(\n\t\t\tReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tLocal<Value> val_handle,\n\t\t\tMaybeLocal<Object> maybe_options\n\t\t) :\n\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n\t\t\t\tval{TransferOut(val_handle, TransferOptions{maybe_options})},\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference} {\n\t\t\tthat.CheckDisposed();\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tSetRunner(\n\t\t\tReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tLocal<Value> val_handle,\n\t\t\tMaybeLocal<Object> maybe_options\n\t\t) :\n\t\tAccessorRunner{that, key_handle},\n\t\tval{TransferOut(val_handle, TransferOptions{maybe_options})} {}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int fit_image_verify(const void *fit, int image_noffset)\n{\n\tconst void\t*data;\n\tsize_t\t\tsize;\n\tint\t\tnoffset = 0;\n\tchar\t\t*err_msg = \"\";\n\n\t/* Get image data and data length */\n\tif (fit_image_get_data_and_size(fit, image_noffset, &data, &size)) {\n\t\terr_msg = \"Can't get image data/size\";\n\t\tprintf(\"error!\\n%s for '%s' hash node in '%s' image node\\n\",\n\t\t       err_msg, fit_get_name(fit, noffset, NULL),\n\t\t       fit_get_name(fit, image_noffset, NULL));\n\t\treturn 0;\n\t}\n\n\treturn fit_image_verify_with_data(fit, image_noffset, data, size);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int fit_image_verify(const void *fit, int image_noffset)\n{\n\tconst char *name = fit_get_name(fit, image_noffset, NULL);\n\tconst void\t*data;\n\tsize_t\t\tsize;\n\tchar\t\t*err_msg = \"\";\n\n\tif (strchr(name, '@')) {\n\t\t/*\n\t\t * We don't support this since libfdt considers names with the\n\t\t * name root but different @ suffix to be equal\n\t\t */\n\t\terr_msg = \"Node name contains @\";\n\t\tgoto err;\n\t}\n\t/* Get image data and data length */\n\tif (fit_image_get_data_and_size(fit, image_noffset, &data, &size)) {\n\t\terr_msg = \"Can't get image data/size\";\n\t\tgoto err;\n\t}\n\n\treturn fit_image_verify_with_data(fit, image_noffset, data, size);\n\nerr:\n\tprintf(\"error!\\n%s in '%s' image node\\n\", err_msg,\n\t       fit_get_name(fit, image_noffset, NULL));\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void i8042_stop(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\tport->exists = false;\n\n\t/*\n\t * We synchronize with both AUX and KBD IRQs because there is\n\t * a (very unlikely) chance that AUX IRQ is raised for KBD port\n\t * and vice versa.\n\t */\n\tsynchronize_irq(I8042_AUX_IRQ);\n\tsynchronize_irq(I8042_KBD_IRQ);\n\tport->serio = NULL;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void i8042_stop(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\tspin_lock_irq(&i8042_lock);\n\tport->exists = false;\n\tport->serio = NULL;\n\tspin_unlock_irq(&i8042_lock);\n\n\t/*\n\t * We need to make sure that interrupt handler finishes using\n\t * our serio port before we return from this function.\n\t * We synchronize with both AUX and KBD IRQs because there is\n\t * a (very unlikely) chance that AUX IRQ is raised for KBD port\n\t * and vice versa.\n\t */\n\tsynchronize_irq(I8042_AUX_IRQ);\n\tsynchronize_irq(I8042_KBD_IRQ);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "l2tp_call_errors_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tuint16_t val_h, val_l;\n\n\tptr++;\t\t/* skip \"Reserved\" */\n\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"CRCErr=%u \", (val_h<<16) + val_l));\n\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"FrameErr=%u \", (val_h<<16) + val_l));\n\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"HardOver=%u \", (val_h<<16) + val_l));\n\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"BufOver=%u \", (val_h<<16) + val_l));\n\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"Timeout=%u \", (val_h<<16) + val_l));\n\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"AlignErr=%u \", (val_h<<16) + val_l));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "l2tp_call_errors_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tuint16_t val_h, val_l;\n\n\tif (length < 2) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tptr++;\t\t/* skip \"Reserved\" */\n\tlength -= 2;\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tND_PRINT((ndo, \"CRCErr=%u \", (val_h<<16) + val_l));\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tND_PRINT((ndo, \"FrameErr=%u \", (val_h<<16) + val_l));\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tND_PRINT((ndo, \"HardOver=%u \", (val_h<<16) + val_l));\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tND_PRINT((ndo, \"BufOver=%u \", (val_h<<16) + val_l));\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tND_PRINT((ndo, \"Timeout=%u \", (val_h<<16) + val_l));\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"AlignErr=%u \", (val_h<<16) + val_l));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tenum ndp_msg_type msg_type;\n\tsize_t len;\n\tint err;\n\n\tmsg = ndp_msg_alloc();\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tlen = ndp_msg_payload_maxlen(msg);\n\terr = myrecvfrom6(ndp->sock, msg->buf, &len, 0,\n\t\t\t  &msg->addrto, &msg->ifindex);\n\tif (err) {\n\t\terr(ndp, \"Failed to receive message\");\n\t\tgoto free_msg;\n\t}\n\tdbg(ndp, \"rcvd from: %s, ifindex: %u\",\n\t\t str_in6_addr(&msg->addrto), msg->ifindex);\n\n\tif (len < sizeof(*msg->icmp6_hdr)) {\n\t\twarn(ndp, \"rcvd icmp6 packet too short (%luB)\", len);\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\terr = ndp_msg_type_by_raw_type(&msg_type, msg->icmp6_hdr->icmp6_type);\n\tif (err) {\n\t\terr = 0;\n\t\tgoto free_msg;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tenum ndp_msg_type msg_type;\n\tsize_t len;\n\tint err;\n\n\tmsg = ndp_msg_alloc();\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tlen = ndp_msg_payload_maxlen(msg);\n\terr = myrecvfrom6(ndp->sock, msg->buf, &len, 0,\n\t\t\t  &msg->addrto, &msg->ifindex, &msg->hoplimit);\n\tif (err) {\n\t\terr(ndp, \"Failed to receive message\");\n\t\tgoto free_msg;\n\t}\n\tdbg(ndp, \"rcvd from: %s, ifindex: %u, hoplimit: %d\",\n\t\t str_in6_addr(&msg->addrto), msg->ifindex, msg->hoplimit);\n\n\tif (msg->hoplimit != 255) {\n\t\twarn(ndp, \"ignoring packet with bad hop limit (%d)\", msg->hoplimit);\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\n\tif (len < sizeof(*msg->icmp6_hdr)) {\n\t\twarn(ndp, \"rcvd icmp6 packet too short (%luB)\", len);\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\terr = ndp_msg_type_by_raw_type(&msg_type, msg->icmp6_hdr->icmp6_type);\n\tif (err) {\n\t\terr = 0;\n\t\tgoto free_msg;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static PyObject *__pyx_f_17clickhouse_driver_14bufferedwriter_14BufferedWriter_write(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter *__pyx_v_self, PyObject *__pyx_v_data, int __pyx_skip_dispatch) {\n  Py_ssize_t __pyx_v_written;\n  Py_ssize_t __pyx_v_size;\n  Py_ssize_t __pyx_v_data_len;\n  char *__pyx_v_c_data;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  Py_ssize_t __pyx_t_5;\n  char *__pyx_t_6;\n  int __pyx_t_7;\n  Py_ssize_t __pyx_t_8;\n  Py_ssize_t __pyx_t_9;\n  __Pyx_RefNannySetupContext(\"write\", 0);\n  /* Check if called by wrapper */\n  if (unlikely(__pyx_skip_dispatch)) ;\n  /* Check if overridden in Python */\n  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {\n    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS\n    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;\n    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {\n      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));\n      #endif\n      #endif\n      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS\n    }\n    #endif\n  }\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":29\n * \n *     cpdef write(self, data):\n *         cdef Py_ssize_t written = 0             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t to_write, size\n *         cdef Py_ssize_t data_len = len(data)\n */\n  __pyx_v_written = 0;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":31\n *         cdef Py_ssize_t written = 0\n *         cdef Py_ssize_t to_write, size\n *         cdef Py_ssize_t data_len = len(data)             # <<<<<<<<<<<<<<\n *         cdef char* c_data\n * \n */\n  __pyx_t_5 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(0, 31, __pyx_L1_error)\n  __pyx_v_data_len = __pyx_t_5;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":34\n *         cdef char* c_data\n * \n *         c_data = PyBytes_AsString(data)             # <<<<<<<<<<<<<<\n    __pyx_t_7 = ((__pyx_v_written < __pyx_v_data_len) != 0);\n    if (!__pyx_t_7) break;\n\n    /* \"clickhouse_driver/bufferedwriter.pyx\":37\n * \n *         while written < data_len:\n *             size = min(data_len - written, self.buffer_size - self.position)             # <<<<<<<<<<<<<<\n *             memcpy(&self.buffer[self.position], &c_data[written], size)\n * \n */\n    __pyx_t_5 = (__pyx_v_self->buffer_size - __pyx_v_self->position);\n    __pyx_t_8 = (__pyx_v_data_len - __pyx_v_written);\n    if (((__pyx_t_5 < __pyx_t_8) != 0)) {\n      __pyx_t_9 = __pyx_t_5;\n    } else {\n      __pyx_t_9 = __pyx_t_8;\n    }\n    __pyx_v_size = __pyx_t_9;\n\n    /* \"clickhouse_driver/bufferedwriter.pyx\":38\n *         while written < data_len:\n *             size = min(data_len - written, self.buffer_size - self.position)\n *             memcpy(&self.buffer[self.position], &c_data[written], size)             # <<<<<<<<<<<<<<\n * \n *             if self.position == self.buffer_size:\n */\n    (void)(memcpy((&(__pyx_v_self->buffer[__pyx_v_self->position])), (&(__pyx_v_c_data[__pyx_v_written])), __pyx_v_size));\n\n * \n *     def flush(self):\n */\n    __pyx_v_written = (__pyx_v_written + __pyx_v_size);\n  }\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":28\n *         raise NotImplementedError\n * \n *     cpdef write(self, data):             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t written = 0\n *         cdef Py_ssize_t to_write, size\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static PyObject *__pyx_f_17clickhouse_driver_14bufferedwriter_14BufferedWriter_write(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter *__pyx_v_self, PyObject *__pyx_v_data, int __pyx_skip_dispatch) {\n  unsigned PY_LONG_LONG __pyx_v_written;\n  unsigned PY_LONG_LONG __pyx_v_size;\n  unsigned PY_LONG_LONG __pyx_v_data_len;\n  char *__pyx_v_c_data;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  Py_ssize_t __pyx_t_5;\n  char *__pyx_t_6;\n  int __pyx_t_7;\n  unsigned PY_LONG_LONG __pyx_t_8;\n  unsigned PY_LONG_LONG __pyx_t_9;\n  unsigned PY_LONG_LONG __pyx_t_10;\n  int __pyx_lineno = 0;\n  const char *__pyx_filename = NULL;\n  int __pyx_clineno = 0;\n  __Pyx_RefNannySetupContext(\"write\", 0);\n  /* Check if called by wrapper */\n  if (unlikely(__pyx_skip_dispatch)) ;\n  /* Check if overridden in Python */\n  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {\n    #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS\n    static PY_UINT64_T __pyx_tp_dict_version = __PYX_DICT_VERSION_INIT, __pyx_obj_dict_version = __PYX_DICT_VERSION_INIT;\n    if (unlikely(!__Pyx_object_dict_version_matches(((PyObject *)__pyx_v_self), __pyx_tp_dict_version, __pyx_obj_dict_version))) {\n      PY_UINT64_T __pyx_type_dict_guard = __Pyx_get_tp_dict_version(((PyObject *)__pyx_v_self));\n      #endif\n      #endif\n      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n      #if CYTHON_USE_DICT_VERSIONS && CYTHON_USE_PYTYPE_LOOKUP && CYTHON_USE_TYPE_SLOTS\n    }\n    #endif\n  }\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":29\n * \n *     cpdef write(self, data):\n *         cdef unsigned long long written = 0             # <<<<<<<<<<<<<<\n *         cdef unsigned long long to_write, size\n *         cdef unsigned long long data_len = len(data)\n */\n  __pyx_v_written = 0;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":31\n *         cdef unsigned long long written = 0\n *         cdef unsigned long long to_write, size\n *         cdef unsigned long long data_len = len(data)             # <<<<<<<<<<<<<<\n *         cdef char* c_data\n * \n */\n  __pyx_t_5 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(0, 31, __pyx_L1_error)\n  __pyx_v_data_len = __pyx_t_5;\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":34\n *         cdef char* c_data\n * \n *         c_data = PyBytes_AsString(data)             # <<<<<<<<<<<<<<\n    __pyx_t_7 = ((__pyx_v_written < __pyx_v_data_len) != 0);\n    if (!__pyx_t_7) break;\n\n    /* \"clickhouse_driver/bufferedwriter.pyx\":37\n * \n *         while written < data_len:\n *             size = min(data_len - written, self.buffer_size - self.position)             # <<<<<<<<<<<<<<\n *             memcpy(&self.buffer[self.position], &c_data[written], size)\n * \n */\n    __pyx_t_8 = (__pyx_v_self->buffer_size - __pyx_v_self->position);\n    __pyx_t_9 = (__pyx_v_data_len - __pyx_v_written);\n    if (((__pyx_t_8 < __pyx_t_9) != 0)) {\n      __pyx_t_10 = __pyx_t_8;\n    } else {\n      __pyx_t_10 = __pyx_t_9;\n    }\n    __pyx_v_size = __pyx_t_10;\n\n    /* \"clickhouse_driver/bufferedwriter.pyx\":38\n *         while written < data_len:\n *             size = min(data_len - written, self.buffer_size - self.position)\n *             memcpy(&self.buffer[self.position], &c_data[written], size)             # <<<<<<<<<<<<<<\n * \n *             if self.position == self.buffer_size:\n */\n    (void)(memcpy((&(__pyx_v_self->buffer[__pyx_v_self->position])), (&(__pyx_v_c_data[__pyx_v_written])), __pyx_v_size));\n\n * \n *     def flush(self):\n */\n    __pyx_v_written = (__pyx_v_written + __pyx_v_size);\n  }\n\n  /* \"clickhouse_driver/bufferedwriter.pyx\":28\n *         raise NotImplementedError\n * \n *     cpdef write(self, data):             # <<<<<<<<<<<<<<\n *         cdef unsigned long long written = 0\n *         cdef unsigned long long to_write, size\n */\n\n  /* function exit code */\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_2);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void __exit ipgre_fini(void)\n{\n\trtnl_link_unregister(&ipgre_tap_ops);\n\trtnl_link_unregister(&ipgre_link_ops);\n\tunregister_pernet_device(&ipgre_net_ops);\n\tif (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)\n\t\tprintk(KERN_INFO \"ipgre close: can't remove protocol\\n\");\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void __exit ipgre_fini(void)\n{\n\trtnl_link_unregister(&ipgre_tap_ops);\n\trtnl_link_unregister(&ipgre_link_ops);\n\tif (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)\n\t\tprintk(KERN_INFO \"ipgre close: can't remove protocol\\n\");\n\tunregister_pernet_device(&ipgre_net_ops);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n    if (a->resource == \"root\") {\n      return Principal::tenant(std::move(a->account));\n    }\n\n    static const char rx_str[] = \"([^/]*)/(.*)\";\n    static const regex rx(rx_str, sizeof(rx_str) - 1,\n\t\t\t  ECMAScript | optimize);\n    smatch match;\n    if (regex_match(a->resource, match, rx)) {\n      ceph_assert(match.size() == 3);\n\n      if (match[1] == \"user\") {\n\treturn Principal::user(std::move(a->account),\n\t\t\t       match[2]);\n      }\n\n      if (match[1] == \"role\") {\n\treturn Principal::role(std::move(a->account),\n\t\t\t       match[2]);\n      }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n    if (a->resource == \"root\") {\n      return Principal::tenant(std::move(a->account));\n    }\n\n    static const char rx_str[] = \"([^/]*)/(.*)\";\n    static const regex rx(rx_str, sizeof(rx_str) - 1,\n\t\t\t  ECMAScript | optimize);\n    smatch match;\n    if (regex_match(a->resource, match, rx)) {\n      if (match.size() != 3) {\n\treturn boost::none;\n      }\n\n      if (match[1] == \"user\") {\n\treturn Principal::user(std::move(a->account),\n\t\t\t       match[2]);\n      }\n\n      if (match[1] == \"role\") {\n\treturn Principal::role(std::move(a->account),\n\t\t\t       match[2]);\n      }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"blkcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_blkcipher.geniv ?: \"<default>\");\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_blkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_blkcipher.ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tstrncpy(rblkcipher.type, \"blkcipher\", sizeof(rblkcipher.type));\n\tstrncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: \"<default>\",\n\t\tsizeof(rblkcipher.geniv));\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_blkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_blkcipher.ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tstruct inode *inode = dentry->d_inode;\n\tstruct evm_ima_xattr_data xattr_data;\n\tint rc = 0;\n\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n\t\t\t\t\t   &xattr_data,\n\t\t\t\t\t   sizeof(xattr_data), 0);\n\t}\n\telse if (rc == -ENODATA)\n\t\trc = inode->i_op->removexattr(dentry, XATTR_NAME_EVM);\n\treturn rc;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tstruct evm_ima_xattr_data xattr_data;\n\tint rc = 0;\n\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n\t\t\t\t\t   &xattr_data,\n\t\t\t\t\t   sizeof(xattr_data), 0);\n\t} else if (rc == -ENODATA && inode->i_op->removexattr) {\n\t\trc = inode->i_op->removexattr(dentry, XATTR_NAME_EVM);\n\t}\n\treturn rc;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\t_kdc_set_e_text(r, \"Reply packet too large\");\n    }\n\nout:\n    free_AS_REP(&rep);\n\n    /*\n     * In case of a non proxy error, build an error message.\n     */\n    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t ret, r->e_text,\n\t\t\t\t r->server_princ,\n\t\t\t\t &r->client_princ->name,\n\t\t\t\t &r->client_princ->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tif (ret)\n\t    goto out2;\n    }\nout2:\n    free_EncTicketPart(&r->et);\n    free_EncKDCRepPart(&r->ek);\n    free_KDCFastState(&r->fast);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tret = KRB5KRB_ERR_RESPONSE_TOO_BIG;\n\t_kdc_set_e_text(r, \"Reply packet too large\");\n    }\n\nout:\n    free_AS_REP(&rep);\n\n    /*\n     * In case of a non proxy error, build an error message.\n     */\n    if (ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t ret, r->e_text,\n\t\t\t\t r->server_princ,\n\t\t\t\t r->client_princ ?\n                                     &r->client_princ->name : NULL,\n\t\t\t\t r->client_princ ?\n                                     &r->client_princ->realm : NULL,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tif (ret)\n\t    goto out2;\n    }\nout2:\n    free_EncTicketPart(&r->et);\n    free_EncKDCRepPart(&r->ek);\n    free_KDCFastState(&r->fast);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t\t__FILE__, __LINE__);\n\t\treturn -EFAULT;\n\t}\n\n\t/* Handle those commands that are just returning\n\t * information stored in the driver.\n\t * These commands should never time out and are unaffected\n\t * by TM and FW reloads.\n\t */\n\tif ((cmd & ~IOCSIZE_MASK) == (MPTIOCINFO & ~IOCSIZE_MASK)) {\n\t\treturn mptctl_getiocinfo(arg, _IOC_SIZE(cmd));\n\t} else if (cmd == MPTTARGETINFO) {\n\t\treturn mptctl_gettargetinfo(arg);\n\t} else if (cmd == MPTTEST) {\n\t\treturn mptctl_readtest(arg);\n\t} else if (cmd == MPTEVENTQUERY) {\n\t\treturn mptctl_eventquery(arg);\n\t} else if (cmd == MPTEVENTENABLE) {\n\t\treturn mptctl_eventenable(arg);\n\t} else if (cmd == MPTEVENTREPORT) {\n\t\treturn mptctl_eventreport(arg);\n\t} else if (cmd == MPTFWREPLACE) {\n\t\treturn mptctl_replace_fw(arg);\n\t}\n\n\t/* All of these commands require an interrupt or\n\t * are unknown/illegal.\n\t */\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\n\tif (cmd == MPTFWDOWNLOAD)\n\t\tret = mptctl_fw_download(arg);\n\telse if (cmd == MPTCOMMAND)\n\t\tret = mptctl_mpt_command(arg);\n\telse if (cmd == MPTHARDRESET)\n\t\tret = mptctl_do_reset(arg);\n\telse if ((cmd & ~IOCSIZE_MASK) == (HP_GETHOSTINFO & ~IOCSIZE_MASK))\n\t\tret = mptctl_hp_hostinfo(arg, _IOC_SIZE(cmd));\n\telse if (cmd == HP_GETTARGETINFO)\n\t\tret = mptctl_hp_targetinfo(arg);\n\telse\n\t\tret = -EINVAL;\n\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\t\t__FILE__, __LINE__);\n\t\treturn -EFAULT;\n\t}\n\n\t/* Handle those commands that are just returning\n\t * information stored in the driver.\n\t * These commands should never time out and are unaffected\n\t * by TM and FW reloads.\n\t */\n\tif ((cmd & ~IOCSIZE_MASK) == (MPTIOCINFO & ~IOCSIZE_MASK)) {\n\t\treturn mptctl_getiocinfo(iocp, arg, _IOC_SIZE(cmd));\n\t} else if (cmd == MPTTARGETINFO) {\n\t\treturn mptctl_gettargetinfo(iocp, arg);\n\t} else if (cmd == MPTTEST) {\n\t\treturn mptctl_readtest(iocp, arg);\n\t} else if (cmd == MPTEVENTQUERY) {\n\t\treturn mptctl_eventquery(iocp, arg);\n\t} else if (cmd == MPTEVENTENABLE) {\n\t\treturn mptctl_eventenable(iocp, arg);\n\t} else if (cmd == MPTEVENTREPORT) {\n\t\treturn mptctl_eventreport(iocp, arg);\n\t} else if (cmd == MPTFWREPLACE) {\n\t\treturn mptctl_replace_fw(iocp, arg);\n\t}\n\n\t/* All of these commands require an interrupt or\n\t * are unknown/illegal.\n\t */\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\n\tif (cmd == MPTFWDOWNLOAD)\n\t\tret = mptctl_fw_download(iocp, arg);\n\telse if (cmd == MPTCOMMAND)\n\t\tret = mptctl_mpt_command(iocp, arg);\n\telse if (cmd == MPTHARDRESET)\n\t\tret = mptctl_do_reset(iocp, arg);\n\telse if ((cmd & ~IOCSIZE_MASK) == (HP_GETHOSTINFO & ~IOCSIZE_MASK))\n\t\tret = mptctl_hp_hostinfo(iocp, arg, _IOC_SIZE(cmd));\n\telse if (cmd == HP_GETTARGETINFO)\n\t\tret = mptctl_hp_targetinfo(iocp, arg);\n\telse\n\t\tret = -EINVAL;\n\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "print_arrays_for(char *set)\n{\n  FILE *f;\n\n  sprintf(buf, \"%s.conf\", set);\n\n  if ((f = fopen(buf, \"r\")) == NULL) {\n    fprintf(stderr, \"%s: can't read conf file for charset %s\\n\", prog, set);\n    exit(EXIT_FAILURE);\n  }\n\n  printf(\"\\\n/* The %s character set.  Generated automatically by configure and\\n\\\n * the %s program\\n\\\n */\\n\\n\",",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "print_arrays_for(char *set)\n{\n  FILE *f;\n\n  snprintf(buf, sizeof(buf), \"%s.conf\", set);\n\n  if ((f = fopen(buf, \"r\")) == NULL) {\n    fprintf(stderr, \"%s: can't read conf file for charset %s\\n\", prog, set);\n    exit(EXIT_FAILURE);\n  }\n\n  printf(\"\\\n/* The %s character set.  Generated automatically by configure and\\n\\\n * the %s program\\n\\\n */\\n\\n\",",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "      explicit JpegOutput( String const& filename ) {\n         // Open the file for writing\n         if( FileHasExtension( filename )) {\n            outfile_ = std::fopen(filename.c_str(), \"wb\");\n         } else {\n            outfile_ = std::fopen( FileAddExtension( filename, \"jpg\" ).c_str(), \"wb\" );\n         }\n         if( outfile_ == nullptr ) {\n            DIP_THROW_RUNTIME( \"Could not open file for writing\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         if( setjmp( jerr_.setjmp_buffer )) {\n            // If we get here, the JPEG code has signaled an error.\n            DIP_THROW_RUNTIME( \"Error writing JPEG file.\" );\n         }\n         jpeg_create_compress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_dest( &cinfo_, outfile_ );\n      }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "      explicit JpegOutput( String const& filename, std::jmp_buf const& setjmp_buffer ) {\n         // Open the file for writing\n         if( FileHasExtension( filename )) {\n            outfile_ = std::fopen(filename.c_str(), \"wb\");\n         } else {\n            outfile_ = std::fopen( FileAddExtension( filename, \"jpg\" ).c_str(), \"wb\" );\n         }\n         if( outfile_ == nullptr ) {\n            DIP_THROW_RUNTIME( \"Could not open file for writing\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         std::memcpy( jerr_.setjmp_buffer, setjmp_buffer, sizeof( setjmp_buffer ));\n         jpeg_create_compress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_dest( &cinfo_, outfile_ );\n      }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    // the selection without inserting anything.  When\n    // compl_enter_selects is set the Enter key does the same.\n    if ((c == Ctrl_Y || (compl_enter_selects\n\t\t    && (c == CAR || c == K_KENTER || c == NL)))\n\t    && pum_visible())\n\tretval = TRUE;\n\n    // CTRL-E means completion is Ended, go back to the typed text.\n    // but only do this, if the Popup is still visible\n    if (c == Ctrl_E)\n    {\n\tins_compl_delete();\n\tif (compl_leader != NULL)\n\t    ins_bytes(compl_leader + get_compl_len());\n\telse if (compl_first_match != NULL)\n\t    ins_bytes(compl_orig_text + get_compl_len());\n\tretval = TRUE;\n    }\n\n    auto_format(FALSE, TRUE);\n\n    // Trigger the CompleteDonePre event to give scripts a chance to\n    // act upon the completion before clearing the info, and restore\n    // ctrl_x_mode, so that complete_info() can be used.\n    ctrl_x_mode = prev_mode;\n    ins_apply_autocmds(EVENT_COMPLETEDONEPRE);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    // compl_enter_selects is set the Enter key does the same.\n    if ((c == Ctrl_Y || (compl_enter_selects\n\t\t    && (c == CAR || c == K_KENTER || c == NL)))\n\t    && pum_visible())\n\tretval = TRUE;\n\n    // CTRL-E means completion is Ended, go back to the typed text.\n    // but only do this, if the Popup is still visible\n    if (c == Ctrl_E)\n    {\n\tchar_u *p = NULL;\n\n\tins_compl_delete();\n\tif (compl_leader != NULL)\n\t    p = compl_leader;\n\telse if (compl_first_match != NULL)\n\t    p = compl_orig_text;\n\tif (p != NULL)\n\t{\n\t    int\t    compl_len = get_compl_len();\n\t    int\t    len = (int)STRLEN(p);\n\n\t    if (len > compl_len)\n\t\tins_bytes_len(p + compl_len, len - compl_len);\n\t}\n\tretval = TRUE;\n    }\n\n    auto_format(FALSE, TRUE);\n\n    // Trigger the CompleteDonePre event to give scripts a chance to\n    // act upon the completion before clearing the info, and restore\n    // ctrl_x_mode, so that complete_info() can be used.\n    ctrl_x_mode = prev_mode;\n    ins_apply_autocmds(EVENT_COMPLETEDONEPRE);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tif (error == -EIO)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tASSERT(blkno == 0);\n\terror = xfs_attr3_leaf_create(args, blkno, &bp);\n\tif (error) {\n\t\terror = xfs_da_shrink_inode(args, 0, bp);\n\t\tbp = NULL;\n\t\tif (error)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.dp = dp;\n\tnargs.geo = args->geo;\n\tnargs.firstblock = args->firstblock;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tif (error == -EIO)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tASSERT(blkno == 0);\n\terror = xfs_attr3_leaf_create(args, blkno, &bp);\n\tif (error) {\n\t\t/* xfs_attr3_leaf_create may not have instantiated a block */\n\t\tif (bp && (xfs_da_shrink_inode(args, 0, bp) != 0))\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t/* try to put */\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t/* it back */\n\t\tgoto out;\n\t}\n\n\tmemset((char *)&nargs, 0, sizeof(nargs));\n\tnargs.dp = dp;\n\tnargs.geo = args->geo;\n\tnargs.firstblock = args->firstblock;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "For(expr_ty target, expr_ty iter, asdl_seq * body, asdl_seq * orelse, int\n    lineno, int col_offset, int end_lineno, int end_col_offset, PyArena *arena)\n{\n    stmt_ty p;\n    if (!target) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field target is required for For\");\n        return NULL;\n    }\n    if (!iter) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field iter is required for For\");\n        return NULL;\n    }\n    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = For_kind;\n    p->v.For.target = target;\n    p->v.For.iter = iter;\n    p->v.For.body = body;\n    p->v.For.orelse = orelse;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "For(expr_ty target, expr_ty iter, asdl_seq * body, asdl_seq * orelse, string\n    type_comment, int lineno, int col_offset, int end_lineno, int\n    end_col_offset, PyArena *arena)\n{\n    stmt_ty p;\n    if (!target) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field target is required for For\");\n        return NULL;\n    }\n    if (!iter) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field iter is required for For\");\n        return NULL;\n    }\n    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = For_kind;\n    p->v.For.target = target;\n    p->v.For.iter = iter;\n    p->v.For.body = body;\n    p->v.For.orelse = orelse;\n    p->v.For.type_comment = type_comment;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void fp8_write_bin(uint8_t *bin, int len, const fp8_t a) {\n\tif (len != 8 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp4_write_bin(bin, 4 * RLC_FP_BYTES, a[0]);\n\tfp4_write_bin(bin + 4 * RLC_FP_BYTES, 4 * RLC_FP_BYTES, a[1]);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void fp8_write_bin(uint8_t *bin, size_t len, const fp8_t a) {\n\tif (len != 8 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp4_write_bin(bin, 4 * RLC_FP_BYTES, a[0]);\n\tfp4_write_bin(bin + 4 * RLC_FP_BYTES, 4 * RLC_FP_BYTES, a[1]);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteAddParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n  output->type = input2->type;\n\n  const bool requires_broadcast = !HaveSameShapes(input1, input2);\n\n  TfLiteIntArray* output_size = nullptr;\n  if (requires_broadcast) {\n    TF_LITE_ENSURE_OK(context, CalculateShapeForBroadcast(\n                                   context, input1, input2, &output_size));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLiteAddParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n  output->type = input2->type;\n\n  const bool requires_broadcast = !HaveSameShapes(input1, input2);\n\n  TfLiteIntArray* output_size = nullptr;\n  if (requires_broadcast) {\n    TF_LITE_ENSURE_OK(context, CalculateShapeForBroadcast(\n                                   context, input1, input2, &output_size));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\ts->x = crypto_bignum_allocate(key_size_bits);\n\tif (!s->x)\n\t\tgoto err;\n\ts->y = crypto_bignum_allocate(key_size_bits);\n\tif (!s->y)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->x);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\ts->x = crypto_bignum_allocate(key_size_bits);\n\tif (!s->x)\n\t\tgoto err;\n\ts->y = crypto_bignum_allocate(key_size_bits);\n\tif (!s->y)\n\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tcrypto_bignum_free(&s->d);\n\tcrypto_bignum_free(&s->x);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "MONGO_EXPORT int bson_append_code_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_CODE );\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "MONGO_EXPORT int bson_append_code_n( bson *b, const char *name, const char *value, size_t len ) {\n    return bson_append_string_base( b, name, value, len, BSON_CODE );\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  ushort(*rgb)[TS][TS][3], (*rix)[3], (*pix)[4];\n  short(*lab)[TS][3], (*lix)[3];\n  float(*drv)[TS][TS], diff[6], tr;\n  char(*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"%d-pass X-Trans interpolation...\\n\"), passes);\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n/* Check against right pattern */\n  for (row = 0; row < 6; row++)\n\t  for (col = 0; col < 6; col++)\n\t\t  cstat[fcol(row,col)]++;\n\n  if(cstat[0] < 6 || cstat[0]>10 || cstat[1]< 16\n    || cstat[1]>24 || cstat[2]< 6 || cstat[2]>10 || cstat[3])\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  cielab(0, 0);\n  ndir = 4 << (passes > 1);\n  buffer = (char *)malloc(TS * TS * (ndir * 11 + 6));\n  merror(buffer, \"xtrans_interpolate()\");\n  rgb = (ushort(*)[TS][TS][3])buffer;\n  lab = (short(*)[TS][3])(buffer + TS * TS * (ndir * 6));\n  drv = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 6 + 6));\n  homo = (char(*)[TS][TS])(buffer + TS * TS * (ndir * 10 + 6));\n\n  /* Map a green hexagon around each non-green pixel and vice versa:\t*/\n  for (row = 0; row < 3; row++)\n    for (col = 0; col < 3; col++)\n      for (ng = d = 0; d < 10; d += 2)\n      {\n        g = fcol(row, col) == 1;\n        if (fcol(row + orth[d], col + orth[d + 2]) == 1)\n          ng = 0;\n        else\n          ng++;\n        if (ng == 4)\n        {\n          sgrow = row;\n          sgcol = col;\n        }\n        if (ng == g + 1)\n          FORC(8)\n          {\n            v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];\n            h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];\n            allhex[row][col][0][c ^ (g * 2 & d)] = h + v * width;\n            allhex[row][col][1][c ^ (g * 2 & d)] = h + v * TS;\n          }\n      }\n\n  /* Set green1 and green3 to the minimum and maximum allowed values:\t*/\n  for (row = 2; row < height - 2; row++)\n    for (min = ~(max = 0), col = 2; col < width - 2; col++)\n    {\n      if (fcol(row, col) == 1 && (min = ~(max = 0)))\n        continue;\n      pix = image + row * width + col;\n      hex = allhex[row % 3][col % 3][0];\n      if (!max)\n        FORC(6)\n      {\n      case 1:\n        if (row < height - 3)\n        {\n          row++;\n          col--;\n        }\n        break;\n      case 2:\n        if ((min = ~(max = 0)) && (col += 2) < width - 3 && row > 2)\n          row--;\n      }\n    }\n\n  for (top = 3; top < height - 19; top += TS - 16)\n    for (left = 3; left < width - 19; left += TS - 16)\n    {\n      mrow = MIN(top + TS, height - 3);\n      mcol = MIN(left + TS, width - 3);\n      for (row = top; row < mrow; row++)\n        for (col = left; col < mcol; col++)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  short(*lab)[TS][3], (*lix)[3];\n  float(*drv)[TS][TS], diff[6], tr;\n  char(*homo)[TS][TS], *buffer;\n\n#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"%d-pass X-Trans interpolation...\\n\"), passes);\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(width < TS || height < TS)\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT; // too small image\n/* Check against right pattern */\n  for (row = 0; row < 6; row++)\n\t  for (col = 0; col < 6; col++)\n\t\t  cstat[fcol(row,col)]++;\n\n  if(cstat[0] < 6 || cstat[0]>10 || cstat[1]< 16\n    || cstat[1]>24 || cstat[2]< 6 || cstat[2]>10 || cstat[3])\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n // Init allhex table to unreasonable values\n for(int i = 0; i < 3; i++)\n  for(int j = 0; j < 3; j++)\n   for(int k = 0; k < 2; k++)\n    for(int l = 0; l < 8; l++)\n     allhex[i][j][k][l]=32700;\n#endif\n  cielab(0, 0);\n  ndir = 4 << (passes > 1);\n  buffer = (char *)malloc(TS * TS * (ndir * 11 + 6));\n  merror(buffer, \"xtrans_interpolate()\");\n  rgb = (ushort(*)[TS][TS][3])buffer;\n  lab = (short(*)[TS][3])(buffer + TS * TS * (ndir * 6));\n  drv = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 6 + 6));\n  homo = (char(*)[TS][TS])(buffer + TS * TS * (ndir * 10 + 6));\n\n  int minv=0,maxv=0,minh=0,maxh=0;\n  /* Map a green hexagon around each non-green pixel and vice versa:\t*/\n  for (row = 0; row < 3; row++)\n    for (col = 0; col < 3; col++)\n      for (ng = d = 0; d < 10; d += 2)\n      {\n        g = fcol(row, col) == 1;\n        if (fcol(row + orth[d], col + orth[d + 2]) == 1)\n          ng = 0;\n        else\n          ng++;\n        if (ng == 4)\n        {\n          sgrow = row;\n          sgcol = col;\n        }\n        if (ng == g + 1)\n          FORC(8)\n          {\n            v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];\n            h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];\n\t    minv=MIN(v,minv);\n\t    maxv=MAX(v,maxv);\n\t    minh=MIN(v,minh);\n   \t    maxh=MAX(v,maxh);\n            allhex[row][col][0][c ^ (g * 2 & d)] = h + v * width;\n            allhex[row][col][1][c ^ (g * 2 & d)] = h + v * TS;\n          }\n      }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n   // Check allhex table initialization\n  for(int i = 0; i < 3; i++)\n    for(int j = 0; j < 3; j++)\n      for(int k = 0; k < 2; k++)\n        for(int l = 0; l < 8; l++)\n\t  if(allhex[i][j][k][l]>maxh+maxv*width+1 || allhex[i][j][k][l]<minh+minv*width-1)\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  int retrycount = 0;\n#endif\n  /* Set green1 and green3 to the minimum and maximum allowed values:\t*/\n  for (row = 2; row < height - 2; row++)\n    for (min = ~(max = 0), col = 2; col < width - 2; col++)\n    {\n      if (fcol(row, col) == 1 && (min = ~(max = 0)))\n        continue;\n      pix = image + row * width + col;\n      hex = allhex[row % 3][col % 3][0];\n      if (!max)\n        FORC(6)\n      {\n      case 1:\n        if (row < height - 3)\n        {\n          row++;\n          col--;\n        }\n        break;\n      case 2:\n        if ((min = ~(max = 0)) && (col += 2) < width - 3 && row > 2)\n\t{\n           row--;\n#ifdef LIBRAW_LIBRARY_BUILD\n\t  if(retrycount++ > width*height)\n\t  \tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\t}\n      }\n    }\n\n  for (top = 3; top < height - 19; top += TS - 16)\n    for (left = 3; left < width - 19; left += TS - 16)\n    {\n      mrow = MIN(top + TS, height - 3);\n      mcol = MIN(left + TS, width - 3);\n      for (row = top; row < mrow; row++)\n        for (col = left; col < mcol; col++)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "ast2obj_withitem(void* _o)\n{\n    withitem_ty o = (withitem_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    result = PyType_GenericNew(withitem_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_expr(o->context_expr);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_context_expr, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_expr(o->optional_vars);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "ast2obj_withitem(void* _o)\n{\n    withitem_ty o = (withitem_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_RETURN_NONE;\n    }\n\n    result = PyType_GenericNew(withitem_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_expr(o->context_expr);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_context_expr, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_expr(o->optional_vars);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n\t\t\t\t\t\t  unsigned long opt),\n\t\t unsigned long opt, u32 timeout, u8 *hci_status)\n{\n\tint ret;\n\n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn -ENETDOWN;\n\n\t/* Serialize all requests */\n\thci_req_sync_lock(hdev);\n\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\thci_req_sync_unlock(hdev);\n\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n\t\t\t\t\t\t  unsigned long opt),\n\t\t unsigned long opt, u32 timeout, u8 *hci_status)\n{\n\tint ret;\n\n\t/* Serialize all requests */\n\thci_req_sync_lock(hdev);\n\t/* check the state after obtaing the lock to protect the HCI_UP\n\t * against any races from hci_dev_do_close when the controller\n\t * gets removed.\n\t */\n\tif (test_bit(HCI_UP, &hdev->flags))\n\t\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\telse\n\t\tret = -ENETDOWN;\n\thci_req_sync_unlock(hdev);\n\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "vector <string> genECDSAKey() {\n    vector<char> errMsg(BUF_LEN, 0);\n    int errStatus = 0;\n    vector <uint8_t> encr_pr_key(BUF_LEN, 0);\n    vector<char> pub_key_x(BUF_LEN, 0);\n    vector<char> pub_key_y(BUF_LEN, 0);\n\n    uint32_t enc_len = 0;\n\n    sgx_status_t status = trustedGenerateEcdsaKeyAES(eid, &errStatus,\n                                        errMsg.data(), encr_pr_key.data(), &enc_len,\n                                        pub_key_x.data(), pub_key_y.data());\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus,errMsg.data());\n\n    vector <string> keys(3);\n\n    vector<char> hexEncrKey(BUF_LEN * 2, 0);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "vector <string> genECDSAKey() {\n    vector<char> errMsg(BUF_LEN, 0);\n    int errStatus = 0;\n    vector <uint8_t> encr_pr_key(BUF_LEN, 0);\n    vector<char> pub_key_x(BUF_LEN, 0);\n    vector<char> pub_key_y(BUF_LEN, 0);\n\n    uint64_t enc_len = 0;\n\n    sgx_status_t status = trustedGenerateEcdsaKeyAES(eid, &errStatus,\n                                        errMsg.data(), encr_pr_key.data(), &enc_len,\n                                        pub_key_x.data(), pub_key_y.data());\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus,errMsg.data());\n\n    vector <string> keys(3);\n\n    vector<char> hexEncrKey(BUF_LEN * 2, 0);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int TLSOutStream::length()\n{\n  return offset + ptr - start;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "size_t TLSOutStream::length()\n{\n  return offset + ptr - start;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "        /* Check if epoch is current. */\n        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\n            return(1);  /* Nothing to do. */\n        \n        /* Process all the records. */\n        while (pqueue_peek(s->d1->unprocessed_rcds.q))\n            {\n            dtls1_get_unprocessed_record(s);\n            if ( ! dtls1_process_record(s))\n                return(0);\n            dtls1_buffer_record(s, &(s->d1->processed_rcds), \n                s->s3->rrec.seq_num);\n            }\n        }\n\n    /* sync epoch numbers once all the unprocessed records \n     * have been processed */\n    s->d1->processed_rcds.epoch = s->d1->r_epoch;\n    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\n\n    return(1);\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "        /* Check if epoch is current. */\n        if (s->d1->unprocessed_rcds.epoch != s->d1->r_epoch)\n            return(1);  /* Nothing to do. */\n        \n        /* Process all the records. */\n        while (pqueue_peek(s->d1->unprocessed_rcds.q))\n            {\n            dtls1_get_unprocessed_record(s);\n            if ( ! dtls1_process_record(s))\n                return(0);\n            if(dtls1_buffer_record(s, &(s->d1->processed_rcds),\n                s->s3->rrec.seq_num)<0)\n                return -1;\n            }\n        }\n\n    /* sync epoch numbers once all the unprocessed records \n     * have been processed */\n    s->d1->processed_rcds.epoch = s->d1->r_epoch;\n    s->d1->unprocessed_rcds.epoch = s->d1->r_epoch + 1;\n\n    return(1);\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void Rp_test(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint opts;\n\tResub m;\n\n\tre = js_toregexp(J, 0);\n\ttext = js_tostring(J, 1);\n\n\topts = 0;\n\tif (re->flags & JS_REGEXP_G) {\n\t\tif (re->last > strlen(text)) {\n\t\t\tre->last = 0;\n\t\t\tjs_pushboolean(J, 0);\n\t\t\treturn;\n\t\t}\n\t\tif (re->last > 0) {\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\n\tif (!js_regexec(re->prog, text, &m, opts)) {\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\tjs_pushboolean(J, 1);\n\t\treturn;\n\t}\n\n\tif (re->flags & JS_REGEXP_G)\n\t\tre->last = 0;\n\n\tjs_pushboolean(J, 0);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void Rp_test(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint result;\n\tint opts;\n\tResub m;\n\n\tre = js_toregexp(J, 0);\n\ttext = js_tostring(J, 1);\n\n\topts = 0;\n\tif (re->flags & JS_REGEXP_G) {\n\t\tif (re->last > strlen(text)) {\n\t\t\tre->last = 0;\n\t\t\tjs_pushboolean(J, 0);\n\t\t\treturn;\n\t\t}\n\t\tif (re->last > 0) {\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\n\tresult = js_regexec(re->prog, text, &m, opts);\n\tif (result < 0)\n\t\tjs_error(J, \"regexec failed\");\n\tif (result == 0) {\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\tjs_pushboolean(J, 1);\n\t\treturn;\n\t}\n\n\tif (re->flags & JS_REGEXP_G)\n\t\tre->last = 0;\n\n\tjs_pushboolean(J, 0);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "bool QHstsHeaderParser::parse(const QList<QPair<QByteArray, QByteArray>> &headers)\n{\n    for (const auto &h : headers) {\n        // We use '==' since header name was already 'trimmed' for us:\n        if (h.first == \"Strict-Transport-Security\") {\n            header = h.second;\n            // RFC6797, 8.1:\n            //\n            //  The UA MUST ignore any STS header fields not conforming to the\n            // grammar specified in Section 6.1 (\"Strict-Transport-Security HTTP\n            // Response Header Field\").\n            //\n            // If a UA receives more than one STS header field in an HTTP\n            // response message over secure transport, then the UA MUST process\n            // only the first such header field.",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "bool QHstsHeaderParser::parse(const QList<QPair<QByteArray, QByteArray>> &headers)\n{\n    for (const auto &h : headers) {\n        // We compare directly because header name was already 'trimmed' for us:\n        if (h.first.compare(\"Strict-Transport-Security\", Qt::CaseInsensitive) == 0) {\n            header = h.second;\n            // RFC6797, 8.1:\n            //\n            //  The UA MUST ignore any STS header fields not conforming to the\n            // grammar specified in Section 6.1 (\"Strict-Transport-Security HTTP\n            // Response Header Field\").\n            //\n            // If a UA receives more than one STS header field in an HTTP\n            // response message over secure transport, then the UA MUST process\n            // only the first such header field.",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t * redirected to loopback in the rtable/dst).\n\t\t */\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\tskb_dst_drop(skb);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t * redirected to loopback in the rtable/dst).\n\t\t */\n\t\tif (pktinfo->ipi_ifindex == LOOPBACK_IFINDEX)\n\t\t\tpktinfo->ipi_ifindex = inet_iif(skb);\n\n\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\t/* We need to keep the dst for __ip_options_echo()\n\t * We could restrict the test to opt.ts_needtime || opt.srr,\n\t * but the following is good enough as IP options are not often used.\n\t */\n\tif (unlikely(IPCB(skb)->opt.optlen))\n\t\tskb_dst_force(skb);\n\telse\n\t\tskb_dst_drop(skb);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "sysUpTime_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "sysUpTime_handler(snmp_varbind_t *varbind, snmp_oid_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tif (amount_after == 0)\n\t\t    break;\t// nothing left to change\n\t\tdp->df_lnum[idx] += amount_after;\n\t    }\n\t    else\n\t    {\n\t\tcheck_unchanged = FALSE;\n\n\t\t// 2. 3. 4. 5.: inserted/deleted lines touching this diff.\n\t\tif (deleted > 0)\n\t\t{\n\t\t    if (dp->df_lnum[idx] >= line1)\n\t\t    {\n\t\t\toff = dp->df_lnum[idx] - lnum_deleted;\n\t\t\tif (last <= line2)\n\t\t\t{\n\t\t\t    // 4. delete all lines of diff\n\t\t\t    if (dp->df_next != NULL\n\t\t\t\t    && dp->df_next->df_lnum[idx] - 1 <= line2)\n\t\t\t    {\n\t\t\t\t// delete continues in next diff, only do\n\t\t\t\t// lines until that one\n\t\t\t\tn = dp->df_next->df_lnum[idx] - lnum_deleted;\n\t\t\t\tdeleted -= n;\n\t\t\t\tn -= dp->df_count[idx];\n\t\t\t\tlnum_deleted = dp->df_next->df_lnum[idx];\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tn = deleted - dp->df_count[idx];\n\t\t\t    dp->df_count[idx] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // 5. delete lines at or just before top of diff\n\t\t\t    n = off;\n\t\t\t    dp->df_count[idx] -= line2 - dp->df_lnum[idx] + 1;\n\t\t\t    check_unchanged = TRUE;\n\t\t\t}\n\t\t\tdp->df_lnum[idx] = line1;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\toff = 0;\n\t\t\tif (last < line2)\n\t\t\t{\n\t\t\t    // 2. delete at end of diff\n\t\t\t    dp->df_count[idx] -= last - lnum_deleted + 1;\n\t\t\t    if (dp->df_next != NULL\n\t\t\t\t    && dp->df_next->df_lnum[idx] - 1 <= line2)\n\t\t\t    {\n\t\t\t\t// delete continues in next diff, only do\n\t\t\t\t// lines until that one\n\t\t\t\tn = dp->df_next->df_lnum[idx] - 1 - last;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t    break;\t// nothing left to change\n\t\tdp->df_lnum[idx] += amount_after;\n\t    }\n\t    else\n\t    {\n\t\tcheck_unchanged = FALSE;\n\n\t\t// 2. 3. 4. 5.: inserted/deleted lines touching this diff.\n\t\tif (deleted > 0)\n\t\t{\n\t\t    off = 0;\n\t\t    if (dp->df_lnum[idx] >= line1)\n\t\t    {\n\t\t\tif (last <= line2)\n\t\t\t{\n\t\t\t    // 4. delete all lines of diff\n\t\t\t    if (dp->df_next != NULL\n\t\t\t\t    && dp->df_next->df_lnum[idx] - 1 <= line2)\n\t\t\t    {\n\t\t\t\t// delete continues in next diff, only do\n\t\t\t\t// lines until that one\n\t\t\t\tn = dp->df_next->df_lnum[idx] - lnum_deleted;\n\t\t\t\tdeleted -= n;\n\t\t\t\tn -= dp->df_count[idx];\n\t\t\t\tlnum_deleted = dp->df_next->df_lnum[idx];\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tn = deleted - dp->df_count[idx];\n\t\t\t    dp->df_count[idx] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // 5. delete lines at or just before top of diff\n\t\t\t    off = dp->df_lnum[idx] - lnum_deleted;\n\t\t\t    n = off;\n\t\t\t    dp->df_count[idx] -= line2 - dp->df_lnum[idx] + 1;\n\t\t\t    check_unchanged = TRUE;\n\t\t\t}\n\t\t\tdp->df_lnum[idx] = line1;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (last < line2)\n\t\t\t{\n\t\t\t    // 2. delete at end of diff\n\t\t\t    dp->df_count[idx] -= last - lnum_deleted + 1;\n\t\t\t    if (dp->df_next != NULL\n\t\t\t\t    && dp->df_next->df_lnum[idx] - 1 <= line2)\n\t\t\t    {\n\t\t\t\t// delete continues in next diff, only do\n\t\t\t\t// lines until that one\n\t\t\t\tn = dp->df_next->df_lnum[idx] - 1 - last;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "bool StatelessReader::change_received(\n        CacheChange_t* change)\n{\n    // Only make the change visible if there is not another with a bigger sequence number.\n    // TODO Revisar si no hay que incluirlo.\n    if (!thereIsUpperRecordOf(change->writerGUID, change->sequenceNumber))\n    {\n        // Update Ownership strength.\n        if (EXCLUSIVE_OWNERSHIP_QOS == m_att.ownershipKind)\n        {\n            auto writer = std::find_if(matched_writers_.begin(), matched_writers_.end(),\n                            [change](const RemoteWriterInfo_t& item)\n                            {\n                                return item.guid == change->writerGUID;\n                            });\n            assert(matched_writers_.end() != writer);\n            change->reader_info.writer_ownership_strength = writer->ownership_strength;\n        }\n        else\n        {\n            change->reader_info.writer_ownership_strength = std::numeric_limits<uint32_t>::max();\n        }\n\n        if (mp_history->received_change(change, 0))\n        {\n            auto payload_length = change->serializedPayload.length;\n            auto guid = change->writerGUID;\n            auto seq = change->sequenceNumber;\n\n            Time_t::now(change->reader_info.receptionTimestamp);\n            SequenceNumber_t previous_seq = update_last_notified(change->writerGUID, change->sequenceNumber);\n            ++total_unread_;\n\n            on_data_notify(guid, change->sourceTimestamp);\n\n            auto listener = getListener();\n            if (listener != nullptr)\n            {\n                if (SequenceNumber_t{0, 0} != previous_seq)\n                {\n                    assert(previous_seq < seq);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "bool StatelessReader::change_received(\n        CacheChange_t* change)\n{\n    // Only make the change visible if there is not another with a bigger sequence number.\n    // TODO Revisar si no hay que incluirlo.\n    if (!thereIsUpperRecordOf(change->writerGUID, change->sequenceNumber))\n    {\n        bool update_notified = true;\n\n        decltype(matched_writers_)::iterator writer = matched_writers_.end();\n        if ((EXCLUSIVE_OWNERSHIP_QOS == m_att.ownershipKind) ||\n                (m_trustedWriterEntityId == change->writerGUID.entityId))\n        {\n            writer = std::find_if(matched_writers_.begin(), matched_writers_.end(),\n                            [change](const RemoteWriterInfo_t& item)\n                            {\n                                return item.guid == change->writerGUID;\n                            });\n            bool is_matched = matched_writers_.end() != writer;\n            update_notified = is_matched;\n        }\n\n        // Update Ownership strength.\n        if (EXCLUSIVE_OWNERSHIP_QOS == m_att.ownershipKind)\n        {\n            assert(matched_writers_.end() != writer);\n            change->reader_info.writer_ownership_strength = writer->ownership_strength;\n        }\n        else\n        {\n            change->reader_info.writer_ownership_strength = std::numeric_limits<uint32_t>::max();\n        }\n\n        if (mp_history->received_change(change, 0))\n        {\n            auto payload_length = change->serializedPayload.length;\n            auto guid = change->writerGUID;\n            auto seq = change->sequenceNumber;\n\n            Time_t::now(change->reader_info.receptionTimestamp);\n            SequenceNumber_t previous_seq{ 0, 0 };\n            if (update_notified)\n            {\n                previous_seq = update_last_notified(change->writerGUID, change->sequenceNumber);\n            }\n            ++total_unread_;\n\n            on_data_notify(guid, change->sourceTimestamp);\n\n            auto listener = getListener();\n            if (listener != nullptr)\n            {\n                if (SequenceNumber_t{0, 0} != previous_seq)\n                {\n                    assert(previous_seq < seq);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\tnew_umask_val = set_umask(optarg);\n\t\t\tif (umask_cmdline)\n\t\t\t\tumask_val = new_umask_val;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\t__set_bit(CONFIG_TEST_BIT, &debug);\n\t\t\t__set_bit(DONT_RESPAWN_BIT, &debug);\n\t\t\t__set_bit(DONT_FORK_BIT, &debug);\n\t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n\t\t\tif (optarg && optarg[0]) {\n\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tfprintf(stderr, \"Unable to open config-test log file %s\\n\", optarg);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tdup2(fd, STDERR_FILENO);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tconf_file = optarg;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\tnew_umask_val = set_umask(optarg);\n\t\t\tif (umask_cmdline)\n\t\t\t\tumask_val = new_umask_val;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\t__set_bit(CONFIG_TEST_BIT, &debug);\n\t\t\t__set_bit(DONT_RESPAWN_BIT, &debug);\n\t\t\t__set_bit(DONT_FORK_BIT, &debug);\n\t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n\t\t\tif (optarg && optarg[0]) {\n\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tfprintf(stderr, \"Unable to open config-test log file %s\\n\", optarg);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tdup2(fd, STDERR_FILENO);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tconf_file = optarg;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "read_subpkt(cdk_stream_t inp, cdk_subpkt_t * r_ctx, size_t * r_nbytes)\n{\n\tbyte c, c1;\n\tsize_t size, nread, n;\n\tcdk_subpkt_t node;\n\tcdk_error_t rc;\n\n\tif (!inp || !r_nbytes)\n\t\treturn CDK_Inv_Value;\n\n\tif (DEBUG_PKT)\n\t\t_gnutls_write_log(\"read_subpkt:\\n\");\n\n\tn = 0;\n\t*r_nbytes = 0;\n\tc = cdk_stream_getc(inp);\n\tn++;\n\tif (c == 255) {\n\t\tsize = read_32(inp);\n\t\tn += 4;\n\t} else if (c >= 192 && c < 255) {\n\t\tc1 = cdk_stream_getc(inp);\n\t\tn++;\n\t\tif (c1 == 0)\n\t\t\treturn 0;\n\t\tsize = ((c - 192) << 8) + c1 + 192;\n\t} else if (c < 192)\n\t\tsize = c;\n\telse\n\t\treturn CDK_Inv_Packet;\n\n\tnode = cdk_subpkt_new(size);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "read_subpkt(cdk_stream_t inp, cdk_subpkt_t * r_ctx, size_t * r_nbytes)\n{\n\tint c, c1;\n\tsize_t size, nread, n;\n\tcdk_subpkt_t node;\n\tcdk_error_t rc;\n\n\tif (!inp || !r_nbytes)\n\t\treturn CDK_Inv_Value;\n\n\tif (DEBUG_PKT)\n\t\t_gnutls_write_log(\"read_subpkt:\\n\");\n\n\tn = 0;\n\t*r_nbytes = 0;\n\tc = cdk_stream_getc(inp);\n\tn++;\n\n\tif (c == 255) {\n\t\tsize = read_32(inp);\n\t\tif (size == (u32)-1)\n\t\t\treturn CDK_Inv_Packet;\n\n\t\tn += 4;\n\t} else if (c >= 192 && c < 255) {\n\t\tc1 = cdk_stream_getc(inp);\n\t\tif (c1 == EOF)\n\t\t\treturn CDK_Inv_Packet;\n\n\t\tn++;\n\t\tif (c1 == 0)\n\t\t\treturn 0;\n\t\tsize = ((c - 192) << 8) + c1 + 192;\n\t} else if (c < 192)\n\t\tsize = c;\n\telse\n\t\treturn CDK_Inv_Packet;\n\n\tnode = cdk_subpkt_new(size);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int b_unpack (lua_State *L) {\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);\n  size_t ld;\n  const char *data = luaL_checklstring(L, 2, &ld);\n  size_t pos = luaL_optinteger(L, 3, 1) - 1;\n  int n = 0;  /* number of results */\n  defaultoptions(&h);\n  while (*fmt) {\n    int opt = *fmt++;\n    size_t size = optsize(L, opt, &fmt);\n    pos += gettoalign(pos, &h, opt, size);\n    luaL_argcheck(L, pos+size <= ld, 2, \"data string too short\");\n    /* stack space for item + next position */\n    luaL_checkstack(L, 2, \"too many results\");\n    switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i':  case 'I': {  /* integer types */\n        int issigned = islower(opt);\n        lua_Number res = getinteger(data+pos, h.endian, issigned, size);\n        lua_pushnumber(L, res); n++;\n        break;\n      }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int b_unpack (lua_State *L) {\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);\n  size_t ld;\n  const char *data = luaL_checklstring(L, 2, &ld);\n  size_t pos = luaL_optinteger(L, 3, 1);\n  luaL_argcheck(L, pos > 0, 3, \"offset must be 1 or greater\");\n  pos--; /* Lua indexes are 1-based, but here we want 0-based for C\n          * pointer math. */\n  int n = 0;  /* number of results */\n  defaultoptions(&h);\n  while (*fmt) {\n    int opt = *fmt++;\n    size_t size = optsize(L, opt, &fmt);\n    pos += gettoalign(pos, &h, opt, size);\n    luaL_argcheck(L, size <= ld && pos <= ld - size,\n                   2, \"data string too short\");\n    /* stack space for item + next position */\n    luaL_checkstack(L, 2, \"too many results\");\n    switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i':  case 'I': {  /* integer types */\n        int issigned = islower(opt);\n        lua_Number res = getinteger(data+pos, h.endian, issigned, size);\n        lua_pushnumber(L, res); n++;\n        break;\n      }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(0==strncasecmp(header_buf+linestart, \"transfer-encoding\", colon-linestart)\n\t\t\t\t\t\t   && 0==strncasecmp(header_buf+valuestart, \"chunked\", 7))\n\t\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"chunked transfer-encoding!\\n\");\n#endif\n\t\t\t\t\t\t\tchunked = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twhile(header_buf[i]=='\\r' || header_buf[i] == '\\n')\n\t\t\t\t\t\ti++;\n\t\t\t\t\tlinestart = i;\n\t\t\t\t\tcolon = linestart;\n\t\t\t\t\tvaluestart = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* copy the remaining of the received data back to buf */\n\t\t\tn = header_buf_used - endofheaders;\n\t\t\tmemcpy(buf, header_buf + endofheaders, n);\n\t\t\t/* if(headers) */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(0==strncasecmp(header_buf+linestart, \"transfer-encoding\", colon-linestart)\n\t\t\t\t\t\t   && 0==strncasecmp(header_buf+valuestart, \"chunked\", 7))\n\t\t\t\t\t\t{\n#ifdef DEBUG\n\t\t\t\t\t\t\tprintf(\"chunked transfer-encoding!\\n\");\n#endif\n\t\t\t\t\t\t\tchunked = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twhile((i < (int)header_buf_used) && (header_buf[i]=='\\r' || header_buf[i] == '\\n'))\n\t\t\t\t\t\ti++;\n\t\t\t\t\tlinestart = i;\n\t\t\t\t\tcolon = linestart;\n\t\t\t\t\tvaluestart = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* copy the remaining of the received data back to buf */\n\t\t\tn = header_buf_used - endofheaders;\n\t\t\tmemcpy(buf, header_buf + endofheaders, n);\n\t\t\t/* if(headers) */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "            ogs_app()->pool.sess * OGS_MAX_NUM_OF_QER);\n    ogs_pool_init(&ogs_pfcp_bar_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_BAR);\n\n    ogs_pool_init(&ogs_pfcp_pdr_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_PDR);\n    ogs_pool_init(&ogs_pfcp_pdr_teid_pool, ogs_pfcp_pdr_pool.size);\n    ogs_pool_random_id_generate(&ogs_pfcp_pdr_teid_pool);\n\n    pdr_random_to_index = ogs_calloc(\n            sizeof(ogs_pool_id_t), ogs_pfcp_pdr_pool.size);\n    ogs_assert(pdr_random_to_index);\n    for (i = 0; i < ogs_pfcp_pdr_pool.size; i++)\n        pdr_random_to_index[ogs_pfcp_pdr_teid_pool.array[i]] = i;\n\n    ogs_pool_init(&ogs_pfcp_rule_pool,\n            ogs_app()->pool.sess *\n            OGS_MAX_NUM_OF_PDR * OGS_MAX_NUM_OF_FLOW_IN_PDR);\n\n    ogs_pool_init(&ogs_pfcp_dev_pool, OGS_MAX_NUM_OF_DEV);\n    ogs_pool_init(&ogs_pfcp_subnet_pool, OGS_MAX_NUM_OF_SUBNET);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "            ogs_app()->pool.sess * OGS_MAX_NUM_OF_QER);\n    ogs_pool_init(&ogs_pfcp_bar_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_BAR);\n\n    ogs_pool_init(&ogs_pfcp_pdr_pool,\n            ogs_app()->pool.sess * OGS_MAX_NUM_OF_PDR);\n    ogs_pool_init(&ogs_pfcp_pdr_teid_pool, ogs_pfcp_pdr_pool.size);\n    ogs_pool_random_id_generate(&ogs_pfcp_pdr_teid_pool);\n\n    pdr_random_to_index = ogs_calloc(\n            sizeof(ogs_pool_id_t), ogs_pfcp_pdr_pool.size+1);\n    ogs_assert(pdr_random_to_index);\n    for (i = 0; i < ogs_pfcp_pdr_pool.size; i++)\n        pdr_random_to_index[ogs_pfcp_pdr_teid_pool.array[i]] = i;\n\n    ogs_pool_init(&ogs_pfcp_rule_pool,\n            ogs_app()->pool.sess *\n            OGS_MAX_NUM_OF_PDR * OGS_MAX_NUM_OF_FLOW_IN_PDR);\n\n    ogs_pool_init(&ogs_pfcp_dev_pool, OGS_MAX_NUM_OF_DEV);\n    ogs_pool_init(&ogs_pfcp_subnet_pool, OGS_MAX_NUM_OF_SUBNET);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "minimask_equal(const struct minimask *a, const struct minimask *b)\n{\n    return !memcmp(a, b, sizeof *a\n                   + MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks)));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "minimask_equal(const struct minimask *a, const struct minimask *b)\n{\n    /* At first glance, it might seem that this can be reasonably optimized\n     * into a single memcmp() for the total size of the region.  Such an\n     * optimization will work OK with most implementations of memcmp() that\n     * proceed from the start of the regions to be compared to the end in\n     * reasonably sized chunks.  However, memcmp() is not required to be\n     * implemented that way, and an implementation that, for example, compares\n     * all of the bytes in both regions without early exit when it finds a\n     * difference, or one that compares, say, 64 bytes at a time, could access\n     * an unmapped region of memory if minimasks 'a' and 'b' have different\n     * lengths.  By first checking that the maps are the same with the first\n     * memcmp(), we verify that 'a' and 'b' have the same length and therefore\n     * ensure that the second memcmp() is safe. */\n    return (!memcmp(a, b, sizeof *a)\n            && !memcmp(a + 1, b + 1,\n                       MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks))));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  auto* params = reinterpret_cast<TfLiteShapeParams*>(node->builtin_data);\n  switch (params->out_type) {\n    case kTfLiteInt32:\n      output->type = kTfLiteInt32;\n      break;\n    case kTfLiteInt64:\n      output->type = kTfLiteInt64;\n      break;\n    default:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  auto* params = reinterpret_cast<TfLiteShapeParams*>(node->builtin_data);\n  switch (params->out_type) {\n    case kTfLiteInt32:\n      output->type = kTfLiteInt32;\n      break;\n    case kTfLiteInt64:\n      output->type = kTfLiteInt64;\n      break;\n    default:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "bgp_capability_parse (struct peer *peer, u_char *pnt, u_char length,\n\t\t      u_char **error)\n{\n  int ret;\n  u_char *end;\n  struct capability cap;\n\n  end = pnt + length;\n\n  while (pnt < end)\n    {\n      afi_t afi;\n      safi_t safi;\n\n      /* Fetch structure to the byte stream. */\n      memcpy (&cap, pnt, sizeof (struct capability));\n\n      afi = ntohs(cap.mpc.afi);\n      safi = cap.mpc.safi;\n\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s OPEN has CAPABILITY code: %d, length %d\",\n\t\t   peer->host, cap.code, cap.length);\n\n      /* We need at least capability code and capability length. */\n      if (pnt + 2 > end)\n\t{\n\t  zlog_info (\"%s Capability length error\", peer->host);\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t  return -1;\n\t}\n\n      /* Capability length check. */\n      if (pnt + (cap.length + 2) > end)\n\t{\n\t  zlog_info (\"%s Capability length error\", peer->host);\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t  return -1;\n\t}\n\n      /* We know MP Capability Code. */\n      if (cap.code == CAPABILITY_CODE_MP)\n\t{\n\t  if (BGP_DEBUG (normal, NORMAL))\n\t    zlog_debug (\"%s OPEN has MP_EXT CAP for afi/safi: %u/%u\",\n\t\t       peer->host, afi, safi);\n\n\t  /* Ignore capability when override-capability is set. */\n\t  if (! CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n\t    {\n\t      /* Set negotiated value. */\n\t      ret = bgp_capability_mp (peer, &cap);\n\n\t      /* Unsupported Capability. */\n\t      if (ret < 0)\n\t\t{\n\t\t  /* Store return data. */\n\t\t  memcpy (*error, &cap, cap.length + 2);\n\t\t  *error += cap.length + 2;\n\t\t}\n\t    }\n\t}\n      else if (cap.code == CAPABILITY_CODE_REFRESH\n\t       || cap.code == CAPABILITY_CODE_REFRESH_OLD)\n\t{\n\t  /* Check length. */\n\t  if (cap.length != CAPABILITY_CODE_REFRESH_LEN)\n\t    {\n\t      zlog_info (\"%s Route Refresh Capability length error %d\",\n\t\t\t peer->host, cap.length);\n\t      bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t      return -1;\n\t    }\n\n\t  if (BGP_DEBUG (normal, NORMAL))\n\t    zlog_debug (\"%s OPEN has ROUTE-REFRESH capability(%s) for all address-families\",\n\t\t       peer->host,\n\t\t       cap.code == CAPABILITY_CODE_REFRESH_OLD ? \"old\" : \"new\");\n\n\t  /* BGP refresh capability */\n\t  if (cap.code == CAPABILITY_CODE_REFRESH_OLD)\n\t    SET_FLAG (peer->cap, PEER_CAP_REFRESH_OLD_RCV);\n\t  else\n\t    SET_FLAG (peer->cap, PEER_CAP_REFRESH_NEW_RCV);\n\t}\n      else if (cap.code == CAPABILITY_CODE_ORF\n\t       || cap.code == CAPABILITY_CODE_ORF_OLD)\n\tbgp_capability_orf (peer, &cap, pnt + sizeof (struct capability));\n      else if (cap.code == CAPABILITY_CODE_RESTART)\n       {\n         struct graceful_restart_af graf;\n         u_int16_t restart_flag_time;\n         int restart_bit = 0;\n         u_char *restart_pnt;\n         u_char *restart_end;\n\n         /* Check length. */\n         if (cap.length < CAPABILITY_CODE_RESTART_LEN)\n           {\n             zlog_info (\"%s Graceful Restart Capability length error %d\",\n                        peer->host, cap.length);\n             bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n             return -1;\n           }\n\n         SET_FLAG (peer->cap, PEER_CAP_RESTART_RCV);\n         restart_flag_time = ntohs(cap.mpc.afi);\n         if (CHECK_FLAG (restart_flag_time, RESTART_R_BIT))\n           restart_bit = 1;\n         UNSET_FLAG (restart_flag_time, 0xF000);\n\t peer->v_gr_restart = restart_flag_time;\n\n         if (BGP_DEBUG (normal, NORMAL))\n           {\n             zlog_debug (\"%s OPEN has Graceful Restart capability\", peer->host);\n             zlog_debug (\"%s Peer has%srestarted. Restart Time : %d\",\n                        peer->host, restart_bit ? \" \" : \" not \",\n\t\t\tpeer->v_gr_restart);\n           }\n\n         restart_pnt = pnt + 4;\n         restart_end = pnt + cap.length + 2;\n\n         while (restart_pnt < restart_end)\n           {\n             memcpy (&graf, restart_pnt, sizeof (struct graceful_restart_af));\n\n             afi = ntohs(graf.afi);\n             safi = graf.safi;\n\n             if (CHECK_FLAG (graf.flag, RESTART_F_BIT))\n\t\tSET_FLAG (peer->af_cap[afi][safi], PEER_CAP_RESTART_AF_PRESERVE_RCV);\n\n             if (strcmp (afi_safi_print (afi, safi), \"Unknown\") == 0)\n               {\n                  if (BGP_DEBUG (normal, NORMAL))\n                    zlog_debug (\"%s Addr-family %d/%d(afi/safi) not supported. I gnore the Graceful Restart capability\",\n                               peer->host, afi, safi);\n               }\n             else if (! peer->afc[afi][safi])\n               {\n                  if (BGP_DEBUG (normal, NORMAL))\n                     zlog_debug (\"%s Addr-family %d/%d(afi/safi) not enabled. Ignore the Graceful Restart capability\",\n                                peer->host, afi, safi);\n               }\n             else\n               {\n                 if (BGP_DEBUG (normal, NORMAL))\n                   zlog_debug (\"%s Address family %s is%spreserved\", peer->host,\n\t\t\t       afi_safi_print (afi, safi),\n\t\t\t       CHECK_FLAG (peer->af_cap[afi][safi],\n\t\t\t       PEER_CAP_RESTART_AF_PRESERVE_RCV)\n\t\t\t       ? \" \" : \" not \");\n\n                   SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_RESTART_AF_RCV);\n               }\n             restart_pnt += 4;\n           }\n       }\n      else if (cap.code == CAPABILITY_CODE_DYNAMIC)\n\t{\n\t  /* Check length. */\n\t  if (cap.length != CAPABILITY_CODE_DYNAMIC_LEN)\n\t    {\n\t      zlog_info (\"%s Dynamic Capability length error %d\",\n\t\t\t peer->host, cap.length);\n\t      bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t      return -1;\n\t    }\n\n\t  if (BGP_DEBUG (normal, NORMAL))\n\t    zlog_debug (\"%s OPEN has DYNAMIC capability\", peer->host);\n\n\t  SET_FLAG (peer->cap, PEER_CAP_DYNAMIC_RCV);\n\t}\n \n      else if (cap.code > 128)\n\t{\n\t  /* We don't send Notification for unknown vendor specific\n\t     capabilities.  It seems reasonable for now...  */\n\t  zlog_warn (\"%s Vendor specific capability %d\",\n\t\t     peer->host, cap.code);\n\t}\n      else\n\t{\n\t  zlog_warn (\"%s unrecognized capability code: %d - ignored\",\n\t\t     peer->host, cap.code);\n\t  memcpy (*error, &cap, cap.length + 2);\n\t  *error += cap.length + 2;\n\t}\n\n      pnt += cap.length + 2;\n    }\n  return 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "bgp_capability_parse (struct peer *peer, size_t length, u_char **error)\n{\n  int ret;\n  struct stream *s = BGP_INPUT (peer);\n  size_t end = stream_get_getp (s) + length;\n  \n  assert (STREAM_READABLE (s) >= length);\n  \n  while (stream_get_getp (s) < end)\n    {\n      size_t start;\n      u_char *sp = stream_pnt (s);\n      struct capability_header caphdr;\n      \n      /* We need at least capability code and capability length. */\n      if (stream_get_getp(s) + 2 > end)\n\t{\n\t  zlog_info (\"%s Capability length error (< header)\", peer->host);\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t  return -1;\n\t}\n      \n      caphdr.code = stream_getc (s);\n      caphdr.length = stream_getc (s);\n      start = stream_get_getp (s);\n      \n      /* Capability length check sanity check. */\n      if (start + caphdr.length > end)\n\t{\n\t  zlog_info (\"%s Capability length error (< length)\", peer->host);\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t  return -1;\n\t}\n      \n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s OPEN has %s capability (%u), length %u\",\n\t\t   peer->host,\n\t\t   LOOKUP (capcode_str, caphdr.code),\n\t\t   caphdr.code, caphdr.length);\n      \n      /* Length sanity check, type-specific, for known capabilities */\n      switch (caphdr.code)\n        {\n          case CAPABILITY_CODE_MP:\n          case CAPABILITY_CODE_REFRESH:\n          case CAPABILITY_CODE_REFRESH_OLD:\n          case CAPABILITY_CODE_ORF:\n          case CAPABILITY_CODE_ORF_OLD:\n          case CAPABILITY_CODE_RESTART:\n          case CAPABILITY_CODE_DYNAMIC:\n              /* Check length. */\n              if (caphdr.length < cap_minsizes[caphdr.code])\n                {\n                  zlog_info (\"%s %s Capability length error: got %u,\"\n                             \" expected at least %u\",\n                             peer->host, \n                             LOOKUP (capcode_str, caphdr.code),\n                             caphdr.length, cap_minsizes[caphdr.code]);\n                  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n                  return -1;\n                }\n          /* we deliberately ignore unknown codes, see below */\n          default:\n            break;\n        }\n      \n      switch (caphdr.code)\n        {\n          case CAPABILITY_CODE_MP:\n            {\n              /* Ignore capability when override-capability is set. */\n              if (! CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n                {\n                  /* Set negotiated value. */\n                  ret = bgp_capability_mp (peer, &caphdr);\n\n                  /* Unsupported Capability. */\n                  if (ret < 0)\n                    {\n                      /* Store return data. */\n                      memcpy (*error, sp, caphdr.length + 2);\n                      *error += caphdr.length + 2;\n                    }\n                }\n            }\n            break;\n          case CAPABILITY_CODE_REFRESH:\n          case CAPABILITY_CODE_REFRESH_OLD:\n            {\n              /* BGP refresh capability */\n              if (caphdr.code == CAPABILITY_CODE_REFRESH_OLD)\n                SET_FLAG (peer->cap, PEER_CAP_REFRESH_OLD_RCV);\n              else\n                SET_FLAG (peer->cap, PEER_CAP_REFRESH_NEW_RCV);\n            }\n            break;\n          case CAPABILITY_CODE_ORF:\n          case CAPABILITY_CODE_ORF_OLD:\n            if (bgp_capability_orf (peer, &caphdr))\n              return -1;\n            break;\n          case CAPABILITY_CODE_RESTART:\n            if (bgp_capability_restart (peer, &caphdr))\n              return -1;\n            break;\n          case CAPABILITY_CODE_DYNAMIC:\n            SET_FLAG (peer->cap, PEER_CAP_DYNAMIC_RCV);\n            break;\n          default:\n            if (caphdr.code > 128)\n              {\n                /* We don't send Notification for unknown vendor specific\n                   capabilities.  It seems reasonable for now...  */\n                zlog_warn (\"%s Vendor specific capability %d\",\n                           peer->host, caphdr.code);\n              }\n            else\n              {\n                zlog_warn (\"%s unrecognized capability code: %d - ignored\",\n                           peer->host, caphdr.code);\n                memcpy (*error, sp, caphdr.length + 2);\n                *error += caphdr.length + 2;\n              }\n          }\n      if (stream_get_getp(s) != (start + caphdr.length))\n        {\n          if (stream_get_getp(s) > (start + caphdr.length))\n            zlog_warn (\"%s Cap-parser for %s read past cap-length, %u!\",\n                       peer->host, LOOKUP (capcode_str, caphdr.code),\n                       caphdr.length);\n          stream_set_getp (s, start + caphdr.length);\n        }\n    }\n  return 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void gf_isom_write_tx3g(GF_Tx3gSampleEntryBox *a, GF_BitStream *bs, u32 sidx, u32 sidx_offset)\n{\n\tu32 size, j, fount_count;\n\tBool is_qt_text = (a->type==GF_ISOM_BOX_TYPE_TEXT) ? GF_TRUE : GF_FALSE;\n\tconst char *qt_fontname = NULL;\n\tvoid gpp_write_rgba(GF_BitStream *bs, u32 col);\n\tvoid gpp_write_box(GF_BitStream *bs, GF_BoxRecord *rec);\n\tvoid gpp_write_style(GF_BitStream *bs, GF_StyleRecord *rec);\n\n\n\tif (sidx_offset) gf_bs_write_u8(bs, sidx + sidx_offset);\n\n\t/*SINCE WINCE HAS A READONLY VERSION OF MP4 WE MUST DO IT BY HAND*/\n\tsize = 8 + 18 + 8 + 12;\n\tsize += 8 + 2;\n\tfount_count = 0;\n\tif (is_qt_text) {\n\t\tGF_TextSampleEntryBox *qt = (GF_TextSampleEntryBox *)a;\n\t\tif (qt->textName) {\n\t\t\tqt_fontname = qt->textName;\n\t\t\tfount_count = 1;\n\t\t}\n\t} else {\n\t\tif (a->font_table) {\n\t\t\tfount_count = a->font_table->entry_count;\n\t\t\tfor (j=0; j<fount_count; j++) {\n\t\t\t\tsize += 3;\n\t\t\t\tif (a->font_table->fonts[j].fontName) size += (u32) strlen(a->font_table->fonts[j].fontName);\n\t\t\t}\n\t\t}\n\t}\n\t/*write TextSampleEntry box*/\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, a->type);\n\tgf_bs_write_data(bs, a->reserved, 6);\n\tgf_bs_write_u16(bs, a->dataReferenceIndex);\n\tgf_bs_write_u32(bs, a->displayFlags);\n\tgf_bs_write_u8(bs, a->horizontal_justification);\n\tgf_bs_write_u8(bs, a->vertical_justification);\n\tgpp_write_rgba(bs, a->back_color);\n\tgpp_write_box(bs, &a->default_box);\n\tgpp_write_style(bs, &a->default_style);\n\t/*write font table box*/\n\tsize -= (8 + 18 + 8 + 12);\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FTAB);\n\n\tgf_bs_write_u16(bs, fount_count);\n\tfor (j=0; j<fount_count; j++) {\n\t\tif (is_qt_text) {\n\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\tif (qt_fontname) {\n\t\t\t\tu32 len = (u32) strlen(qt_fontname);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, qt_fontname, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_write_u16(bs, a->font_table->fonts[j].fontID);\n\t\t\tif (a->font_table->fonts[j].fontName) {\n\t\t\t\tu32 len = (u32) strlen(a->font_table->fonts[j].fontName);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, a->font_table->fonts[j].fontName, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t}\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void gf_isom_write_tx3g(GF_Tx3gSampleEntryBox *_a, GF_BitStream *bs, u32 sidx, u32 sidx_offset)\n{\n\tu32 size, j, fount_count;\n\tconst char *qt_fontname = NULL;\n\tvoid gpp_write_rgba(GF_BitStream *bs, u32 col);\n\tvoid gpp_write_box(GF_BitStream *bs, GF_BoxRecord *rec);\n\tvoid gpp_write_style(GF_BitStream *bs, GF_StyleRecord *rec);\n\n\tGF_TextSampleEntryBox *qt = (_a->type==GF_ISOM_BOX_TYPE_TEXT) ? (GF_TextSampleEntryBox *)_a : NULL;\n\tGF_Tx3gSampleEntryBox *ttxt = (_a->type!=GF_ISOM_BOX_TYPE_TEXT) ? (GF_Tx3gSampleEntryBox *)_a : NULL;\n\n\tif (sidx_offset) gf_bs_write_u8(bs, sidx + sidx_offset);\n\n\t/*SINCE WINCE HAS A READONLY VERSION OF MP4 WE MUST DO IT BY HAND*/\n\tsize = 8 + 18 + 8 + 12;\n\tsize += 8 + 2;\n\tfount_count = 0;\n\tif (qt && qt->textName) {\n\t\tqt_fontname = qt->textName;\n\t\tfount_count = 1;\n\t} else if (ttxt && ttxt->font_table) {\n\t\tfount_count = ttxt->font_table->entry_count;\n\t\tfor (j=0; j<fount_count; j++) {\n\t\t\tsize += 3;\n\t\t\tif (ttxt->font_table->fonts[j].fontName)\n\t\t\t\tsize += (u32) strlen(ttxt->font_table->fonts[j].fontName);\n\t\t}\n\t}\n\t/*write TextSampleEntry box*/\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_TX3G);\n\tgf_bs_write_data(bs, _a->reserved, 6);\n\tgf_bs_write_u16(bs, _a->dataReferenceIndex);\n\tgf_bs_write_u32(bs, _a->displayFlags);\n\tif (qt) {\n\t\tGF_StyleRecord sr;\n\t\tmemset(&sr, 0, sizeof(GF_StyleRecord));\n\t\tgf_bs_write_u8(bs, qt->textJustification);\n\t\tgf_bs_write_u8(bs, (u8) -1);\n\t\tgpp_write_rgba(bs, rgb_48_to_32(qt->background_color) );\n\t\tgpp_write_box(bs, &qt->default_box);\n\t\tsr.text_color = rgb_48_to_32(qt->foreground_color);\n\t\tsr.style_flags = qt->fontFace;\n\t\tgpp_write_style(bs, &sr);\n\t} else {\n\t\tgf_bs_write_u8(bs, ttxt->horizontal_justification);\n\t\tgf_bs_write_u8(bs, ttxt->vertical_justification);\n\t\tgpp_write_rgba(bs, ttxt->back_color);\n\t\tgpp_write_box(bs, &ttxt->default_box);\n\t\tgpp_write_style(bs, &ttxt->default_style);\n\t}\n\t/*write font table box*/\n\tsize -= (8 + 18 + 8 + 12);\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FTAB);\n\n\tgf_bs_write_u16(bs, fount_count);\n\tfor (j=0; j<fount_count; j++) {\n\t\tif (qt) {\n\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\tif (qt_fontname) {\n\t\t\t\tu32 len = (u32) strlen(qt_fontname);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, qt_fontname, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_write_u16(bs, ttxt->font_table->fonts[j].fontID);\n\t\t\tif (ttxt->font_table->fonts[j].fontName) {\n\t\t\t\tu32 len = (u32) strlen(ttxt->font_table->fonts[j].fontName);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, ttxt->font_table->fonts[j].fontName, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t}\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *buf)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    int32_t len;\n    uint8_t command;\n    uint8_t *outbuf;\n    int rc;\n\n    command = buf[0];\n    outbuf = (uint8_t *)r->iov.iov_base;\n    DPRINTF(\"Command: lun=%d tag=0x%x data=0x%02x\", req->lun, req->tag, buf[0]);\n\n#ifdef DEBUG_SCSI\n    {\n        int i;\n        for (i = 1; i < r->req.cmd.len; i++) {\n            printf(\" 0x%02x\", buf[i]);\n        }\n        printf(\"\\n\");\n    }\n    case RESERVE_10:\n    case RELEASE:\n    case RELEASE_10:\n    case START_STOP:\n    case ALLOW_MEDIUM_REMOVAL:\n    case READ_CAPACITY_10:\n    case READ_TOC:\n    case GET_CONFIGURATION:\n    case SERVICE_ACTION_IN_16:\n    case VERIFY_10:\n        rc = scsi_disk_emulate_command(r, outbuf);\n        if (rc < 0) {\n            return 0;\n        }\n\n        r->iov.iov_len = rc;\n        break;\n    case SYNCHRONIZE_CACHE:\n        bdrv_acct_start(s->bs, &r->acct, 0, BDRV_ACCT_FLUSH);\n        r->req.aiocb = bdrv_aio_flush(s->bs, scsi_flush_complete, r);\n        if (r->req.aiocb == NULL) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *buf)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    int32_t len;\n    uint8_t command;\n    int rc;\n\n    command = buf[0];\n    DPRINTF(\"Command: lun=%d tag=0x%x data=0x%02x\", req->lun, req->tag, buf[0]);\n\n#ifdef DEBUG_SCSI\n    {\n        int i;\n        for (i = 1; i < r->req.cmd.len; i++) {\n            printf(\" 0x%02x\", buf[i]);\n        }\n        printf(\"\\n\");\n    }\n    case RESERVE_10:\n    case RELEASE:\n    case RELEASE_10:\n    case START_STOP:\n    case ALLOW_MEDIUM_REMOVAL:\n    case READ_CAPACITY_10:\n    case READ_TOC:\n    case GET_CONFIGURATION:\n    case SERVICE_ACTION_IN_16:\n    case VERIFY_10:\n        rc = scsi_disk_emulate_command(r);\n        if (rc < 0) {\n            return 0;\n        }\n\n        r->iov.iov_len = rc;\n        break;\n    case SYNCHRONIZE_CACHE:\n        bdrv_acct_start(s->bs, &r->acct, 0, BDRV_ACCT_FLUSH);\n        r->req.aiocb = bdrv_aio_flush(s->bs, scsi_flush_complete, r);\n        if (r->req.aiocb == NULL) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tif (obuf == NULL)\n\t\treturn 0;\n\t_TIFFmemset(obuf, 0, tilesize);\n\t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n\t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n\tfor (row = 0; row < imagelength; row += tilelength) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\t/*\n\t\t\t * Tile is clipped horizontally.  Calculate\n\t\t\t * visible portion and skewing factors.\n\t\t\t */\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tint oskew = tilew - width;\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, width,\n\t\t\t\t    oskew, oskew + iskew);\n\t\t\t} else",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tif (obuf == NULL)\n\t\treturn 0;\n\t_TIFFmemset(obuf, 0, tilesize);\n\t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n\t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n\tfor (row = 0; row < imagelength; row += tilelength) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth && colb < imagew; col += tw) {\n\t\t\t/*\n\t\t\t * Tile is clipped horizontally.  Calculate\n\t\t\t * visible portion and skewing factors.\n\t\t\t */\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tint oskew = tilew - width;\n\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, width,\n\t\t\t\t    oskew, oskew + iskew);\n\t\t\t} else",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static char *fstrndup(const char *ptr, unsigned long len) {\n  char *result;\n  if (len <= 0) return NULL;\n  result = ALLOC_N(char, len);\n  memccpy(result, ptr, 0, len);\n  return result;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static char *fstrndup(const char *ptr, unsigned long len) {\n  char *result;\n  if (len <= 0) return NULL;\n  result = ALLOC_N(char, len);\n  memcpy(result, ptr, len);\n  return result;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "doProlog(XML_Parser parser, const ENCODING *enc, const char *s, const char *end,\n         int tok, const char *next, const char **nextPtr, XML_Bool haveMore) {\n#ifdef XML_DTD\n  static const XML_Char externalSubsetName[] = {ASCII_HASH, '\\0'};\n#endif /* XML_DTD */\n  static const XML_Char atypeCDATA[]\n      = {ASCII_C, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\\0'};\n  static const XML_Char atypeID[] = {ASCII_I, ASCII_D, '\\0'};\n  static const XML_Char atypeIDREF[]\n      = {ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, '\\0'};\n  static const XML_Char atypeIDREFS[]\n      = {ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, ASCII_S, '\\0'};\n        normalizePublicId(tem);\n        parser->m_declEntity->publicId = tem;\n        poolFinish(&dtd->pool);\n        /* Don't suppress the default handler if we fell through from\n         * the XML_ROLE_DOCTYPE_PUBLIC_ID case.\n         */\n        if (parser->m_entityDeclHandler && role == XML_ROLE_ENTITY_PUBLIC_ID)\n          handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_DOCTYPE_CLOSE:\n      if (parser->m_doctypeName) {\n        parser->m_startDoctypeDeclHandler(\n            parser->m_handlerArg, parser->m_doctypeName, parser->m_doctypeSysid,\n            parser->m_doctypePubid, 0);\n        poolClear(&parser->m_tempPool);\n        handleDefault = XML_FALSE;\n      }\n      /* parser->m_doctypeSysid will be non-NULL in the case of a previous\n         XML_ROLE_DOCTYPE_SYSTEM_ID, even if parser->m_startDoctypeDeclHandler\n         was not set, indicating an external subset",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "doProlog(XML_Parser parser, const ENCODING *enc, const char *s, const char *end,\n         int tok, const char *next, const char **nextPtr, XML_Bool haveMore,\n         XML_Bool allowClosingDoctype) {\n#ifdef XML_DTD\n  static const XML_Char externalSubsetName[] = {ASCII_HASH, '\\0'};\n#endif /* XML_DTD */\n  static const XML_Char atypeCDATA[]\n      = {ASCII_C, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\\0'};\n  static const XML_Char atypeID[] = {ASCII_I, ASCII_D, '\\0'};\n  static const XML_Char atypeIDREF[]\n      = {ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, '\\0'};\n  static const XML_Char atypeIDREFS[]\n      = {ASCII_I, ASCII_D, ASCII_R, ASCII_E, ASCII_F, ASCII_S, '\\0'};\n        parser->m_declEntity->publicId = tem;\n        poolFinish(&dtd->pool);\n        /* Don't suppress the default handler if we fell through from\n         * the XML_ROLE_DOCTYPE_PUBLIC_ID case.\n         */\n        if (parser->m_entityDeclHandler && role == XML_ROLE_ENTITY_PUBLIC_ID)\n          handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_DOCTYPE_CLOSE:\n      if (allowClosingDoctype != XML_TRUE) {\n        /* Must not close doctype from within expanded parameter entities */\n        return XML_ERROR_INVALID_TOKEN;\n      }\n\n      if (parser->m_doctypeName) {\n        parser->m_startDoctypeDeclHandler(\n            parser->m_handlerArg, parser->m_doctypeName, parser->m_doctypeSysid,\n            parser->m_doctypePubid, 0);\n        poolClear(&parser->m_tempPool);\n        handleDefault = XML_FALSE;\n      }\n      /* parser->m_doctypeSysid will be non-NULL in the case of a previous\n         XML_ROLE_DOCTYPE_SYSTEM_ID, even if parser->m_startDoctypeDeclHandler\n         was not set, indicating an external subset",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tpr_warning(\"PMI: No event at index %d!\\n\", idx);\n\t\twrperfmon(PERFMON_CMD_ENABLE, cpuc->idx_mask);\n\t\treturn;\n\t}\n\n\thwc = &event->hw;\n\talpha_perf_event_update(event, hwc, idx, alpha_pmu->pmc_max_period[idx]+1);\n\tdata.period = event->hw.last_period;\n\n\tif (alpha_perf_event_set_period(event, hwc, idx)) {\n\t\tif (perf_event_overflow(event, 1, &data, regs)) {\n\t\t\t/* Interrupts coming too quickly; \"throttle\" the\n\t\t\t * counter, i.e., disable it for a little while.\n\t\t\t */\n\t\t\talpha_pmu_stop(event, 0);\n\t\t}\n\t}\n\twrperfmon(PERFMON_CMD_ENABLE, cpuc->idx_mask);\n\n\treturn;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\tpr_warning(\"PMI: No event at index %d!\\n\", idx);\n\t\twrperfmon(PERFMON_CMD_ENABLE, cpuc->idx_mask);\n\t\treturn;\n\t}\n\n\thwc = &event->hw;\n\talpha_perf_event_update(event, hwc, idx, alpha_pmu->pmc_max_period[idx]+1);\n\tdata.period = event->hw.last_period;\n\n\tif (alpha_perf_event_set_period(event, hwc, idx)) {\n\t\tif (perf_event_overflow(event, &data, regs)) {\n\t\t\t/* Interrupts coming too quickly; \"throttle\" the\n\t\t\t * counter, i.e., disable it for a little while.\n\t\t\t */\n\t\t\talpha_pmu_stop(event, 0);\n\t\t}\n\t}\n\twrperfmon(PERFMON_CMD_ENABLE, cpuc->idx_mask);\n\n\treturn;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\telse if (input_string[0] == 'x' || input_string[0] == 'X')\n\t{\n\t\tbit_not_hex = false;\n\t\tsp = input_string + 1;\n\t}\n\telse\n\t{\n\t\tbit_not_hex = true;\n\t\tsp = input_string;\n\t}\n\n\tslen = strlen(sp);\n\t/* Determine bitlength from input string */\n\tif (bit_not_hex)\n\t\tbitlen = slen;\n\telse\n\t\tbitlen = slen * 4;\n\n\t/*\n\t * Sometimes atttypmod is not supplied. If it is supplied we need to make\n\t * sure that the bitstring fits.\n\t */\n\tif (atttypmod <= 0)\n\t\tatttypmod = bitlen;\n\telse if (bitlen > atttypmod)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t{\n\t\tbit_not_hex = false;\n\t\tsp = input_string + 1;\n\t}\n\telse\n\t{\n\t\tbit_not_hex = true;\n\t\tsp = input_string;\n\t}\n\n\t/*\n\t * Determine bitlength from input string.  MaxAllocSize ensures a regular\n\t * input is small enough, but we must check hex input.\n\t */\n\tslen = strlen(sp);\n\tif (bit_not_hex)\n\t\tbitlen = slen;\n\telse\n\t{\n\t\tif (slen > VARBITMAXLEN / 4)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tVARBITMAXLEN)));\n\t\tbitlen = slen * 4;\n\t}\n\n\t/*\n\t * Sometimes atttypmod is not supplied. If it is supplied we need to make\n\t * sure that the bitstring fits.\n\t */\n\tif (atttypmod <= 0)\n\t\tatttypmod = bitlen;\n\telse if (bitlen > atttypmod)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_STRING_DATA_RIGHT_TRUNCATION),",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tstruct ppp_net *pn;\n\n\tpch = kzalloc(sizeof(struct channel), GFP_KERNEL);\n\tif (!pch)\n\t\treturn -ENOMEM;\n\n\tpn = ppp_pernet(net);\n\n\tpch->ppp = NULL;\n\tpch->chan = chan;\n\tpch->chan_net = net;\n\tchan->ppp = pch;\n\tinit_ppp_file(&pch->file, CHANNEL);\n\tpch->file.hdrlen = chan->hdrlen;\n#ifdef CONFIG_PPP_MULTILINK\n\tpch->lastseq = -1;\n#endif /* CONFIG_PPP_MULTILINK */\n\tinit_rwsem(&pch->chan_sem);\n\tspin_lock_init(&pch->downl);\n\trwlock_init(&pch->upl);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tstruct ppp_net *pn;\n\n\tpch = kzalloc(sizeof(struct channel), GFP_KERNEL);\n\tif (!pch)\n\t\treturn -ENOMEM;\n\n\tpn = ppp_pernet(net);\n\n\tpch->ppp = NULL;\n\tpch->chan = chan;\n\tpch->chan_net = get_net(net);\n\tchan->ppp = pch;\n\tinit_ppp_file(&pch->file, CHANNEL);\n\tpch->file.hdrlen = chan->hdrlen;\n#ifdef CONFIG_PPP_MULTILINK\n\tpch->lastseq = -1;\n#endif /* CONFIG_PPP_MULTILINK */\n\tinit_rwsem(&pch->chan_sem);\n\tspin_lock_init(&pch->downl);\n\trwlock_init(&pch->upl);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    HTTPContext *s = h->priv_data;\n    int len;\n    /* read bytes from input buffer first */\n    len = s->buf_end - s->buf_ptr;\n    if (len > 0) {\n        if (len > size)\n            len = size;\n        memcpy(buf, s->buf_ptr, len);\n        s->buf_ptr += len;\n    } else {\n        int64_t target_end = s->end_off ? s->end_off : s->filesize;\n        if ((!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off >= target_end)\n            return AVERROR_EOF;\n        len = ffurl_read(s->hd, buf, size);\n        if (!len && (!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off < target_end) {\n            av_log(h, AV_LOG_ERROR,\n                   \"Stream ends prematurely at %\"PRId64\", should be %\"PRId64\"\\n\",\n                   s->off, target_end\n                  );\n            return AVERROR(EIO);\n        }\n    }\n    if (len > 0) {\n        s->off += len;\n        if (s->chunksize > 0)\n            s->chunksize -= len;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    HTTPContext *s = h->priv_data;\n    int len;\n    /* read bytes from input buffer first */\n    len = s->buf_end - s->buf_ptr;\n    if (len > 0) {\n        if (len > size)\n            len = size;\n        memcpy(buf, s->buf_ptr, len);\n        s->buf_ptr += len;\n    } else {\n        uint64_t target_end = s->end_off ? s->end_off : s->filesize;\n        if ((!s->willclose || s->chunksize == UINT64_MAX) && s->off >= target_end)\n            return AVERROR_EOF;\n        len = ffurl_read(s->hd, buf, size);\n        if (!len && (!s->willclose || s->chunksize == UINT64_MAX) && s->off < target_end) {\n            av_log(h, AV_LOG_ERROR,\n                   \"Stream ends prematurely at %\"PRIu64\", should be %\"PRIu64\"\\n\",\n                   s->off, target_end\n                  );\n            return AVERROR(EIO);\n        }\n    }\n    if (len > 0) {\n        s->off += len;\n        if (s->chunksize > 0)\n            s->chunksize -= len;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "{\n\tconst struct xt_standard_target *t = (void *)ip6t_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t/* Head of user chain: ERROR target with chainname */\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (s->target_offset == sizeof(struct ip6t_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t    t->verdict < 0 &&\n\t\t    unconditional(&s->ipv6)) {\n\t\t\t/* Tail of chains: STANDARD target (return/policy) */\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "{\n\tconst struct xt_standard_target *t = (void *)ip6t_get_target_c(s);\n\n\tif (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {\n\t\t/* Head of user chain: ERROR target with chainname */\n\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (unconditional(s) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t    t->verdict < 0) {\n\t\t\t/* Tail of chains: STANDARD target (return/policy) */\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];\n\t\t}\n\t\treturn 1;\n\t} else\n\t\t(*rulenum)++;\n\n\treturn 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static Jsi_RC jsi_ArrayFillCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int istart = 0, iend, n, nsiz;\n    Jsi_Number nstart = 0, nend = 0; // TODO: merge with code in ArraySliceCmd.\n    Jsi_Value *value = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1),\n        *end = Jsi_ValueArrayIndex(interp, args, 2);\n    Jsi_Obj *obj = _this->d.obj;\n    n = Jsi_ObjGetLength(interp, obj);\n\n    if (start && Jsi_GetNumberFromValue(interp, start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static Jsi_RC jsi_ArrayFillCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) \n        return Jsi_LogError(\"expected array object\");\n    Jsi_RC rc = JSI_OK;\n    int istart = 0, iend, n, nsiz;\n    Jsi_Number nstart = 0, nend = 0; // TODO: merge with code in ArraySliceCmd.\n    Jsi_Value *value = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1),\n        *end = Jsi_ValueArrayIndex(interp, args, 2);\n    Jsi_Obj *obj = _this->d.obj;\n    n = jsi_SizeOfArray(interp, obj);\n\n    if (start && Jsi_GetNumberFromValue(interp, start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;\n        if (istart < 0)\n            istart = (n+istart);\n        if (istart<0)\n            goto bail;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\treturn HRTIMER_NORESTART;\n\n\tevent->pmu->read(event);\n\n\tperf_sample_data_init(&data, 0);\n\tdata.period = event->hw.last_period;\n\tregs = get_irq_regs();\n\n\tif (regs && !perf_exclude_event(event, regs)) {\n\t\tif (!(event->attr.exclude_idle && current->pid == 0))\n\t\t\tif (perf_event_overflow(event, 0, &data, regs))\n\t\t\t\tret = HRTIMER_NORESTART;\n\t}\n\n\tperiod = max_t(u64, 10000, event->hw.sample_period);\n\thrtimer_forward_now(hrtimer, ns_to_ktime(period));\n\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\treturn HRTIMER_NORESTART;\n\n\tevent->pmu->read(event);\n\n\tperf_sample_data_init(&data, 0);\n\tdata.period = event->hw.last_period;\n\tregs = get_irq_regs();\n\n\tif (regs && !perf_exclude_event(event, regs)) {\n\t\tif (!(event->attr.exclude_idle && current->pid == 0))\n\t\t\tif (perf_event_overflow(event, &data, regs))\n\t\t\t\tret = HRTIMER_NORESTART;\n\t}\n\n\tperiod = max_t(u64, 10000, event->hw.sample_period);\n\thrtimer_forward_now(hrtimer, ns_to_ktime(period));\n\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static RList *r_bin_wasm_get_data_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\n\tRList *ret = NULL;\n\tRBinWasmDataEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\tsize_t n = 0;\n\n\twhile (i < len && r < count) {\n\n\t\tif (!(ptr = R_NEW0 (RBinWasmDataEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(n = consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tptr->offset.len = n;\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) {\t\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tptr->data = sec->payload_data + i;\n\n\t\tr_list_append (ret, ptr);\n\n\t\tr += 1;\n\n\t}\n\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static RList *r_bin_wasm_get_data_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmDataEntry *ptr = NULL;\n\tut32 len =  sec->payload_len;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tint buflen = bin->buf->length - (ut32)sec->payload_data;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\tsize_t n = 0;\n\n\twhile (i < len && len < buflen && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmDataEntry))) {\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (i + 4 >= buflen) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!(n = consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tptr->offset.len = n;\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) {\t\n\t\t\tgoto beach;\n\t\t}\n\t\tif (i + 4 >= buflen) {\n\t\t\tgoto beach;\n\t\t}\n\t\tptr->data = sec->payload_data + i;\n\n\t\tr_list_append (ret, ptr);\n\n\t\tr += 1;\n\n\t}\n\treturn ret;\nbeach:\n\tfree (ptr);\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tSlapi_Operation *operation;\n\tentry_address *addr;\n\tint is_fixup_operation= 0;\n\tint is_ruv = 0;                 /* True if the current entry is RUV */\n\tCSN *opcsn = NULL;\n\tint repl_op;\n\tint opreturn = 0;\n\tint mod_count = 0;\n\tint not_an_error = 0;\n\tint fixup_tombstone = 0;\n\tint ec_locked = 0;\n\n\tslapi_pblock_get( pb, SLAPI_BACKEND, &be);\n\tslapi_pblock_get( pb, SLAPI_PLUGIN_PRIVATE, &li );\n\tslapi_pblock_get( pb, SLAPI_TARGET_ADDRESS, &addr );\n\tslapi_pblock_get( pb, SLAPI_MODIFY_MODS, &mods );\n\tslapi_pblock_get( pb, SLAPI_TXN, (void**)&parent_txn );\n\tslapi_pblock_get( pb, SLAPI_IS_REPLICATED_OPERATION, &repl_op);\n\tslapi_pblock_get( pb, SLAPI_OPERATION, &operation );\n\n\tfixup_tombstone = operation_is_flag_set(operation, OP_FLAG_TOMBSTONE_FIXUP);\n\t * transaction to plugins (see slapi_back_transaction_* APIs).\n\t *\n\tif(SERIALLOCK(li) && !operation_is_flag_set(operation,OP_FLAG_REPL_FIXUP)) {\n\t\tdblayer_lock_backend(be);\n\t\tdblock_acquired= 1;\n\t}\n\t */\n\tif ( MANAGE_ENTRY_BEFORE_DBLOCK(li)) {\n\t\t/* find and lock the entry we are about to modify */\n\t\tif (fixup_tombstone) {\n\t\t\te = find_entry2modify_only_ext( pb, be, addr, TOMBSTONE_INCLUDED, &txn );\n\t\t} else {\n\t\t\te = find_entry2modify( pb, be, addr, &txn );\n\t\t}\n\t\tif (e == NULL) {\n\t\t\tldap_result_code= -1;\n\t\t\tgoto error_return; /* error result sent by find_entry2modify() */\n\t\t}\n\t}\n\n\ttxn.back_txn_txn = NULL; /* ready to create the child transaction */\n\tfor (retry_count = 0; retry_count < RETRY_TIMES; retry_count++) {\n\t\tint cache_rc = 0;\n\t\tint new_mod_count = 0;\n\t\tif (txn.back_txn_txn && (txn.back_txn_txn != parent_txn)) {\n\t\t\t/* don't release SERIAL LOCK */\n\t\t\tldap_result_code= LDAP_OPERATIONS_ERROR;\n\t\t\tgoto error_return;\n\t\t}\n\t\t/* stash the transaction for plugins */\n\t\tslapi_pblock_set(pb, SLAPI_TXN, txn.back_txn_txn);\n\n\t\tif (0 == retry_count) { /* just once */\n\t\t\tif ( !MANAGE_ENTRY_BEFORE_DBLOCK(li)) {\n\t\t\t\t/* find and lock the entry we are about to modify */\n\t\t\t\tif (fixup_tombstone) {\n\t\t\t\t\te = find_entry2modify_only_ext( pb, be, addr, TOMBSTONE_INCLUDED, &txn );\n\t\t\t\t} else {\n\t\t\t\t\te = find_entry2modify( pb, be, addr, &txn );\n\t\t\t\t}\n\t\t\t\tif (e == NULL) {\n\t\t\t\t\tldap_result_code= -1;\n\t\t\t\t\tgoto error_return; /* error result sent by find_entry2modify() */\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif ( !is_fixup_operation && !fixup_tombstone)\n\t\t\t{\n\t\t\t\tif (!repl_op && slapi_entry_flag_is_set(e->ep_entry, SLAPI_ENTRY_FLAG_TOMBSTONE))\n\t\t\t\t{\n\t\t\t\t\tldap_result_code = LDAP_UNWILLING_TO_PERFORM;\n                \t\t\tldap_result_message = \"Operation not allowed on tombstone entry.\";\n\tif (ldap_result_code == -1) {\n\t\t/* Reset to LDAP_NO_SUCH_OBJECT*/\n\t\tldap_result_code = LDAP_NO_SUCH_OBJECT;\n\t\tslapi_pblock_set(pb, SLAPI_RESULT_CODE, &ldap_result_code);\n\t} else {\n\t\tif (not_an_error) {\n\t\t\t/* This is mainly used by urp.  Solved conflict is not an error.\n\t\t\t * And we don't want the supplier to halt sending the updates. */\n\t\t\tldap_result_code = LDAP_SUCCESS;\n\t\t}\n\t\tslapi_send_ldap_result( pb, ldap_result_code, NULL, ldap_result_message, 0, NULL );\n\t}\n\n\t/* free our backups */\n\tldap_mods_free(mods_original, 1);\n\tbackentry_free(&original_entry);\n\tbackentry_free(&tmpentry);\n\tslapi_ch_free_string(&errbuf);\n\n\treturn rc;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tentry_address *addr;\n\tint is_fixup_operation= 0;\n\tint is_ruv = 0;                 /* True if the current entry is RUV */\n\tCSN *opcsn = NULL;\n\tint repl_op;\n\tint opreturn = 0;\n\tint mod_count = 0;\n\tint not_an_error = 0;\n\tint fixup_tombstone = 0;\n\tint ec_locked = 0;\n\tint result_sent = 0;\n\n\tslapi_pblock_get( pb, SLAPI_BACKEND, &be);\n\tslapi_pblock_get( pb, SLAPI_PLUGIN_PRIVATE, &li );\n\tslapi_pblock_get( pb, SLAPI_TARGET_ADDRESS, &addr );\n\tslapi_pblock_get( pb, SLAPI_MODIFY_MODS, &mods );\n\tslapi_pblock_get( pb, SLAPI_TXN, (void**)&parent_txn );\n\tslapi_pblock_get( pb, SLAPI_IS_REPLICATED_OPERATION, &repl_op);\n\tslapi_pblock_get( pb, SLAPI_OPERATION, &operation );\n\n\tfixup_tombstone = operation_is_flag_set(operation, OP_FLAG_TOMBSTONE_FIXUP);\n\t * transaction to plugins (see slapi_back_transaction_* APIs).\n\t *\n\tif(SERIALLOCK(li) && !operation_is_flag_set(operation,OP_FLAG_REPL_FIXUP)) {\n\t\tdblayer_lock_backend(be);\n\t\tdblock_acquired= 1;\n\t}\n\t */\n\tif ( MANAGE_ENTRY_BEFORE_DBLOCK(li)) {\n\t\t/* find and lock the entry we are about to modify */\n\t\tif (fixup_tombstone) {\n\t\t\te = find_entry2modify_only_ext( pb, be, addr, TOMBSTONE_INCLUDED, &txn, &result_sent );\n\t\t} else {\n\t\t\te = find_entry2modify( pb, be, addr, &txn, &result_sent );\n\t\t}\n\t\tif (e == NULL) {\n\t\t\tldap_result_code = -1;\n\t\t\tgoto error_return; /* error result sent by find_entry2modify() */\n\t\t}\n\t}\n\n\ttxn.back_txn_txn = NULL; /* ready to create the child transaction */\n\tfor (retry_count = 0; retry_count < RETRY_TIMES; retry_count++) {\n\t\tint cache_rc = 0;\n\t\tint new_mod_count = 0;\n\t\tif (txn.back_txn_txn && (txn.back_txn_txn != parent_txn)) {\n\t\t\t/* don't release SERIAL LOCK */\n\t\t\tldap_result_code= LDAP_OPERATIONS_ERROR;\n\t\t\tgoto error_return;\n\t\t}\n\t\t/* stash the transaction for plugins */\n\t\tslapi_pblock_set(pb, SLAPI_TXN, txn.back_txn_txn);\n\n\t\tif (0 == retry_count) { /* just once */\n\t\t\tif ( !MANAGE_ENTRY_BEFORE_DBLOCK(li)) {\n\t\t\t\t/* find and lock the entry we are about to modify */\n\t\t\t\tif (fixup_tombstone) {\n\t\t\t\t\te = find_entry2modify_only_ext( pb, be, addr, TOMBSTONE_INCLUDED, &txn, &result_sent );\n\t\t\t\t} else {\n\t\t\t\t\te = find_entry2modify( pb, be, addr, &txn, &result_sent );\n\t\t\t\t}\n\t\t\t\tif (e == NULL) {\n\t\t\t\t\tldap_result_code = -1;\n\t\t\t\t\tgoto error_return; /* error result sent by find_entry2modify() */\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif ( !is_fixup_operation && !fixup_tombstone)\n\t\t\t{\n\t\t\t\tif (!repl_op && slapi_entry_flag_is_set(e->ep_entry, SLAPI_ENTRY_FLAG_TOMBSTONE))\n\t\t\t\t{\n\t\t\t\t\tldap_result_code = LDAP_UNWILLING_TO_PERFORM;\n                \t\t\tldap_result_message = \"Operation not allowed on tombstone entry.\";\n\tif (ldap_result_code == -1) {\n\t\t/* Reset to LDAP_NO_SUCH_OBJECT*/\n\t\tldap_result_code = LDAP_NO_SUCH_OBJECT;\n\t\tslapi_pblock_set(pb, SLAPI_RESULT_CODE, &ldap_result_code);\n\t} else {\n\t\tif (not_an_error) {\n\t\t\t/* This is mainly used by urp.  Solved conflict is not an error.\n\t\t\t * And we don't want the supplier to halt sending the updates. */\n\t\t\tldap_result_code = LDAP_SUCCESS;\n\t\t}\n\t\tif (!result_sent) {\n\t\t\t/* result is already sent in find_entry. */\n\t\t\tslapi_send_ldap_result( pb, ldap_result_code, NULL, ldap_result_message, 0, NULL );\n\t\t}\n\t}\n\n\t/* free our backups */\n\tldap_mods_free(mods_original, 1);\n\tbackentry_free(&original_entry);\n\tbackentry_free(&tmpentry);\n\tslapi_ch_free_string(&errbuf);\n\n\treturn rc;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "DefragReverseSimpleTest(void)\n{\n    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n    Packet *reassembled = NULL;\n    int id = 12;\n    int i;\n    int ret = 0;\n\n    DefragInit();\n\n    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n    if (p1 == NULL)\n        goto end;\n    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n    if (p2 == NULL)\n        goto end;\n    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n    if (p3 == NULL)\n        goto end;\n\n    if (Defrag(NULL, NULL, p3, NULL) != NULL)\n        goto end;\n    if (Defrag(NULL, NULL, p2, NULL) != NULL)\n        goto end;\n\n    reassembled = Defrag(NULL, NULL, p1, NULL);\n    if (reassembled == NULL)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "DefragReverseSimpleTest(void)\n{\n    Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;\n    Packet *reassembled = NULL;\n    int id = 12;\n    int i;\n    int ret = 0;\n\n    DefragInit();\n\n    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n    if (p1 == NULL)\n        goto end;\n    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n    if (p2 == NULL)\n        goto end;\n    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n    if (p3 == NULL)\n        goto end;\n\n    if (Defrag(NULL, NULL, p3, NULL) != NULL)\n        goto end;\n    if (Defrag(NULL, NULL, p2, NULL) != NULL)\n        goto end;\n\n    reassembled = Defrag(NULL, NULL, p1, NULL);\n    if (reassembled == NULL)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tint phy_addr;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;\n\n\tstruct netdev_desc *desc;\n\tint i;\n\n\tphy_addr = np->phy_addr;\n\tswitch (cmd) {\n\tcase SIOCDEVPRIVATE:\n\t\tbreak;\n\n\tcase SIOCDEVPRIVATE + 1:\n\t\tmiidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 2:\n\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 3:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 4:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 5:\n\t\tnetif_stop_queue (dev);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 6:\n\t\tnetif_wake_queue (dev);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 7:\n\t\tprintk\n\t\t    (\"tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\\n\",\n\t\t     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,\n\t\t     np->old_rx);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 8:\n\t\tprintk(\"TX ring:\\n\");\n\t\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\t\tdesc = &np->tx_ring[i];\n\t\t\tprintk\n\t\t\t    (\"%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x\",\n\t\t\t     i,\n\t\t\t     (u32) (np->tx_ring_dma + i * sizeof (*desc)),\n\t\t\t     (u32)le64_to_cpu(desc->next_desc),\n\t\t\t     (u32)le64_to_cpu(desc->status),\n\t\t\t     (u32)(le64_to_cpu(desc->fraginfo) >> 32),\n\t\t\t     (u32)le64_to_cpu(desc->fraginfo));\n\t\t\tprintk (\"\\n\");\n\t\t}\n\t\tprintk (\"\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tint phy_addr;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct mii_ioctl_data *miidata = if_mii(rq);\n\n\tphy_addr = np->phy_addr;\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tmiidata->phy_id = phy_addr;\n\t\tbreak;\n\tcase SIOCGMIIREG:\n\t\tmiidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);\n\t\tbreak;\n\tcase SIOCSMIIREG:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tint size = decode_access_size(insn);\n\n\tif(!ok_for_kernel(insn) || dir == both) {\n\t\tprintk(\"Unsupported unaligned load/store trap for kernel at <%08lx>.\\n\",\n\t\t       regs->pc);\n\t\tunaligned_panic(\"Wheee. Kernel does fpu/atomic unaligned load/store.\");\n\t} else {\n\t\tunsigned long addr = compute_effective_address(regs, insn);\n\t\tint err;\n\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, addr);\n\t\tswitch (dir) {\n\t\tcase load:\n\t\t\terr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),\n\t\t\t\t\t\t\t regs),\n\t\t\t\t\t  size, (unsigned long *) addr,\n\t\t\t\t\t  decode_signedness(insn));\n\t\t\tbreak;\n\n\t\tcase store:\n\t\t\terr = do_int_store(((insn>>25)&0x1f), size,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tint size = decode_access_size(insn);\n\n\tif(!ok_for_kernel(insn) || dir == both) {\n\t\tprintk(\"Unsupported unaligned load/store trap for kernel at <%08lx>.\\n\",\n\t\t       regs->pc);\n\t\tunaligned_panic(\"Wheee. Kernel does fpu/atomic unaligned load/store.\");\n\t} else {\n\t\tunsigned long addr = compute_effective_address(regs, insn);\n\t\tint err;\n\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, addr);\n\t\tswitch (dir) {\n\t\tcase load:\n\t\t\terr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),\n\t\t\t\t\t\t\t regs),\n\t\t\t\t\t  size, (unsigned long *) addr,\n\t\t\t\t\t  decode_signedness(insn));\n\t\t\tbreak;\n\n\t\tcase store:\n\t\t\terr = do_int_store(((insn>>25)&0x1f), size,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tdata.period = event->hw.last_period;\n\tregs.ip     = 0;\n\n\t/*\n\t * Prepare a generic sample, i.e. fill in the invariant fields.\n\t * We will overwrite the from and to address before we output\n\t * the sample.\n\t */\n\tperf_prepare_sample(&header, &data, event, &regs);\n\n\tif (perf_output_begin(&handle, event, header.size * (top - at), 1, 1))\n\t\treturn 1;\n\n\tfor (; at < top; at++) {\n\t\tdata.ip\t\t= at->from;\n\t\tdata.addr\t= at->to;\n\n\t\tperf_output_sample(&handle, &header, &data, event);\n\t}\n\n\tperf_output_end(&handle);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tdata.period = event->hw.last_period;\n\tregs.ip     = 0;\n\n\t/*\n\t * Prepare a generic sample, i.e. fill in the invariant fields.\n\t * We will overwrite the from and to address before we output\n\t * the sample.\n\t */\n\tperf_prepare_sample(&header, &data, event, &regs);\n\n\tif (perf_output_begin(&handle, event, header.size * (top - at), 1))\n\t\treturn 1;\n\n\tfor (; at < top; at++) {\n\t\tdata.ip\t\t= at->from;\n\t\tdata.addr\t= at->to;\n\n\t\tperf_output_sample(&handle, &header, &data, event);\n\t}\n\n\tperf_output_end(&handle);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\n\tStream_Read_UINT16(s, fields->Len); /* Len (2 bytes) */\n\tStream_Read_UINT16(s, fields->MaxLen); /* MaxLen (2 bytes) */\n\tStream_Read_UINT32(s, fields->BufferOffset); /* BufferOffset (4 bytes) */\n\treturn 1;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\n\tStream_Read_UINT16(s, fields->Len); /* Len (2 bytes) */\n\tStream_Read_UINT16(s, fields->MaxLen); /* MaxLen (2 bytes) */\n\tStream_Read_UINT32(s, fields->BufferOffset); /* BufferOffset (4 bytes) */\n\treturn 1;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    (void) ConcatenateMagickString(type,\"errr\",MagickPathExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)\n      {\n        if (length > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        chunk=(unsigned char *) AcquireQuantumMemory(length+MagickPathExtent,\n          sizeof(*chunk));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    (void) ConcatenateMagickString(type,\"errr\",MagickPathExtent);\n    length=ReadBlobMSBLong(image);\n    count=(unsigned int) ReadBlob(image,4,(unsigned char *) type);\n\n    if (logging != MagickFalse)\n      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      {\n        if (color_image != (Image *) NULL)\n          color_image=DestroyImage(color_image);\n        if (color_image_info != (Image *) NULL)\n          color_image_info=DestroyImageInfo(color_image_info);\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n      }\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)\n      {\n        if (length > GetBlobSize(image))\n          ThrowReaderException(CorruptImageError,\"InsufficientImageDataInFile\");\n        chunk=(unsigned char *) AcquireQuantumMemory(length+MagickPathExtent,\n          sizeof(*chunk));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,\n                            UINT32 scanline)\n{\n\tnsc_encode_argb_to_aycocg_sse2(context, data, scanline);\n\n\tif (context->ChromaSubsamplingLevel > 0)\n\t{\n\t\tnsc_encode_subsampling_sse2(context);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static BOOL nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,\n                            UINT32 scanline)\n{\n\tnsc_encode_argb_to_aycocg_sse2(context, data, scanline);\n\n\tif (context->ChromaSubsamplingLevel > 0)\n\t{\n\t\tnsc_encode_subsampling_sse2(context);\n\t}\n\n\treturn TRUE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tif (dhcp_server_state_machine == DHCP_SERVER_STATE_IDLE) {\n\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_OFFER;\n\t\t}\n\t\tbreak;\n\tcase DHCP_MESSAGE_TYPE_REQUEST:\n\t\t#if (debug_dhcps)\t\n\t\tprintf(\"\\r\\n[%d]get message DHCP_MESSAGE_TYPE_REQUEST\\n\", xTaskGetTickCount());\n\t\t#endif\n#if (!IS_USE_FIXED_IP) \t\n#if (debug_dhcps)\n\t\tprintf(\"\\r\\ndhcp_server_state_machine=%d\", dhcp_server_state_machine);\n\t\tprintf(\"\\r\\ndhcps_allocated_client_address=%d.%d.%d.%d\", \n\t\t\t\tip4_addr1(&dhcps_allocated_client_address),\n\t\t\t\tip4_addr2(&dhcps_allocated_client_address),\n\t\t\t\tip4_addr3(&dhcps_allocated_client_address),\n\t\t\t\tip4_addr4(&dhcps_allocated_client_address));\n\t\tprintf(\"\\r\\nclient_request_ip=%d.%d.%d.%d\\n\", \n\t\t\t\tip4_addr1(&client_request_ip),\n\t\t\t\tip4_addr2(&client_request_ip),\n\t\t\t\tip4_addr3(&client_request_ip),\n\t\t\t\tip4_addr4(&client_request_ip));\n#endif\t\t\n\t\tif (dhcp_server_state_machine == DHCP_SERVER_STATE_OFFER) {\n\t\t\tif (ip4_addr4(&dhcps_allocated_client_address) != 0) { \n\t\t\t\tif (memcmp((void *)&dhcps_allocated_client_address, (void *)&client_request_ip, 4) == 0) {  \t\n\t\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n\t\t\t  \t} else {\n\t\t\t\t  \tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t\t  \t}\n\t\t\t} else {\n\t\t\t  \tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t\t}  \n\t\t} else if(dhcp_server_state_machine == DHCP_SERVER_STATE_IDLE){\n\t\t\tuint8_t ip_addr4 = check_client_request_ip(&client_request_ip, client_addr);\n\t\t\tif(ip_addr4 > 0){\n\t\t\t\tIP4_ADDR(&dhcps_allocated_client_address, (ip4_addr1(&dhcps_network_id)),\n\t\t\t\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), ip_addr4);\n\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n\t\t\t}else{\n\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t\t}\n\t\t} else {\n\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t}\n#else\t\t\n\t\tif (!(dhcp_server_state_machine == DHCP_SERVER_STATE_ACK ||\n\t\t\tdhcp_server_state_machine == DHCP_SERVER_STATE_NAK)) {\n\t\t        dhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t}\n#endif\n\t\tbreak;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_OFFER;\n\t\t}\n\t\tbreak;\n\tcase DHCP_MESSAGE_TYPE_REQUEST:\n\t\t#if (debug_dhcps)\t\n\t\tprintf(\"\\r\\n[%d]get message DHCP_MESSAGE_TYPE_REQUEST\\n\", xTaskGetTickCount());\n\t\t#endif\n#if (!IS_USE_FIXED_IP) \t\n#if (debug_dhcps)\n\t\tprintf(\"\\r\\ndhcp_server_state_machine=%d\", dhcp_server_state_machine);\n#if LWIP_VERSION_MAJOR >= 2\n\t\tprintf(\"\\r\\ndhcps_allocated_client_address=%d.%d.%d.%d\", \n\t\t\t\tip4_addr1(ip_2_ip4(&dhcps_allocated_client_address)),\n\t\t\t\tip4_addr2(ip_2_ip4(&dhcps_allocated_client_address)),\n\t\t\t\tip4_addr3(ip_2_ip4(&dhcps_allocated_client_address)),\n\t\t\t\tip4_addr4(ip_2_ip4(&dhcps_allocated_client_address)));\n\t\tprintf(\"\\r\\nclient_request_ip=%d.%d.%d.%d\\n\", \n\t\t\t\tip4_addr1(ip_2_ip4(&client_request_ip)),\n\t\t\t\tip4_addr2(ip_2_ip4(&client_request_ip)),\n\t\t\t\tip4_addr3(ip_2_ip4(&client_request_ip)),\n\t\t\t\tip4_addr4(ip_2_ip4(&client_request_ip)));\n#else\n\t\tprintf(\"\\r\\ndhcps_allocated_client_address=%d.%d.%d.%d\", \n\t\t\t\tip4_addr1(&dhcps_allocated_client_address),\n\t\t\t\tip4_addr2(&dhcps_allocated_client_address),\n\t\t\t\tip4_addr3(&dhcps_allocated_client_address),\n\t\t\t\tip4_addr4(&dhcps_allocated_client_address));\n\t\tprintf(\"\\r\\nclient_request_ip=%d.%d.%d.%d\\n\", \n\t\t\t\tip4_addr1(&client_request_ip),\n\t\t\t\tip4_addr2(&client_request_ip),\n\t\t\t\tip4_addr3(&client_request_ip),\n\t\t\t\tip4_addr4(&client_request_ip));\n#endif\n\n#endif\t\t\n\n\t\t// for renew\n\t\tif((*(uint32_t *) dhcp_message_repository->ciaddr != 0) && (*(uint32_t *)&client_request_ip == 0)) {\n\t\t\tmemcpy(&client_request_ip, dhcp_message_repository->ciaddr, sizeof(client_request_ip));\n\t\t}\n\n\t\tif (dhcp_server_state_machine == DHCP_SERVER_STATE_OFFER) {\n\t\t\tuint8_t ip_addr4 = check_client_direct_request_ip(&client_request_ip, client_addr);\n\n\t\t\tif(ip_addr4 > 0){\n#if LWIP_VERSION_MAJOR >= 2\n\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(ip_2_ip4(&dhcps_network_id)),ip4_addr2(ip_2_ip4(&dhcps_network_id)),ip4_addr3(ip_2_ip4(&dhcps_network_id)),ip_addr4);\n\t\t\t\tIP4_ADDR(ip_2_ip4(&dhcps_allocated_client_address), (ip4_addr1(ip_2_ip4(&dhcps_network_id))),\n\t\t\t\t\t\tip4_addr2(ip_2_ip4(&dhcps_network_id)), ip4_addr3(ip_2_ip4(&dhcps_network_id)), ip_addr4);\n#else\n\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),ip_addr4);\n\t\t\t\tIP4_ADDR(&dhcps_allocated_client_address, (ip4_addr1(&dhcps_network_id)),\n\t\t\t\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), ip_addr4);\n#endif\n\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n\t\t\t\tbreak;\n\t\t\t}\n\n#if LWIP_VERSION_MAJOR >= 2\n\t\t\tif (ip4_addr4(ip_2_ip4(&dhcps_allocated_client_address)) != 0) \n#else\n\t\t\tif (ip4_addr4(&dhcps_allocated_client_address) != 0) \n#endif \n\t\t\t{ \n\t\t\t\tif (memcmp((void *)&dhcps_allocated_client_address, (void *)&client_request_ip, 4) == 0) {  \n#if LWIP_VERSION_MAJOR >= 2\n\t\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(ip_2_ip4(&dhcps_network_id)),ip4_addr2(ip_2_ip4(&dhcps_network_id)),ip4_addr3(ip_2_ip4(&dhcps_network_id)),ip4_addr4(ip_2_ip4(&dhcps_allocated_client_address)));\n#else\n\t\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),ip4_addr4(&dhcps_allocated_client_address));\n#endif\n\t\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n\t\t\t  \t} else {\n\t\t\t\t  \tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t\t  \t}\n\t\t\t} else {\n\t\t\t  \tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t\t}  \n#ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO\n\t\t} else if(dhcp_server_state_machine == DHCP_SERVER_STATE_IDLE){\n\t\t\tuint8_t ip_addr4 = check_client_direct_request_ip(&client_request_ip, client_addr);\n\n\t\t\tif(ip_addr4 > 0){\t\t\t\n#if LWIP_VERSION_MAJOR >= 2\n\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(ip_2_ip4(&dhcps_network_id)),ip4_addr2(ip_2_ip4(&dhcps_network_id)),ip4_addr3(ip_2_ip4(&dhcps_network_id)),ip_addr4);\n\t\t\t\tIP4_ADDR(ip_2_ip4(&dhcps_allocated_client_address), (ip4_addr1(ip_2_ip4(&dhcps_network_id))),\n\t\t\t\t\t\tip4_addr2(ip_2_ip4(&dhcps_network_id)), ip4_addr3(ip_2_ip4(&dhcps_network_id)), ip_addr4);\n#else\n\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),ip_addr4);\n\t\t\t\tIP4_ADDR(&dhcps_allocated_client_address, (ip4_addr1(&dhcps_network_id)),\n\t\t\t\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), ip_addr4);\n#endif\n\n\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n\t\t\t}else{\n\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t}\n#else\t\t\n\t\tif (!(dhcp_server_state_machine == DHCP_SERVER_STATE_ACK ||\n\t\t\tdhcp_server_state_machine == DHCP_SERVER_STATE_NAK)) {\n\t\t        dhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t}\n#endif\n\t\tbreak;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static int find_high_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=31;i>=0;i--) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static int find_high_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=31;i>=0;i--) {\n\t\tif(x&(1U<<(unsigned int)i)) return i;\n\t}\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  output->type = input->type;\n\n  return context->ResizeTensor(context, output,\n                               TfLiteIntArrayCopy(input->dims));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  output->type = input->type;\n\n  return context->ResizeTensor(context, output,\n                               TfLiteIntArrayCopy(input->dims));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\tif ((fd = _open_as_other(path_name, req)) == -1) {\n\t\terror(\"Unable to open %s: Permission denied\", path_name);\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\tsep = \":\";\n\t\t}\n\t\tND_PRINT((ndo, \"]\"));\n\t\treturn;\n\t}\n\n\tParse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0);\n\n\tif (sfsname) {\n\t\t/* file system ID is ASCII, not numeric, for this server OS */\n\t\tstatic char temp[NFSX_V3FHMAX+1];\n\n\t\t/* Make sure string is null-terminated */\n\t\tstrncpy(temp, sfsname, NFSX_V3FHMAX);\n\t\ttemp[sizeof(temp) - 1] = '\\0';\n\t\t/* Remove trailing spaces */\n\t\tspacep = strchr(temp, ' ');\n\t\tif (spacep)\n\t\t\t*spacep = '\\0';\n\n\t\tND_PRINT((ndo, \" fh %s/\", temp));\n\t} else {\n\t\tND_PRINT((ndo, \" fh %d,%d/\",\n\t\t\t     fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor));\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\tsep = \":\";\n\t\t}\n\t\tND_PRINT((ndo, \"]\"));\n\t\treturn;\n\t}\n\n\tParse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0);\n\n\tif (sfsname) {\n\t\t/* file system ID is ASCII, not numeric, for this server OS */\n\t\tchar temp[NFSX_V3FHMAX+1];\n\t\tu_int stringlen;\n\n\t\t/* Make sure string is null-terminated */\n\t\tstringlen = len;\n\t\tif (stringlen > NFSX_V3FHMAX)\n\t\t\tstringlen = NFSX_V3FHMAX;\n\t\tstrncpy(temp, sfsname, stringlen);\n\t\ttemp[stringlen] = '\\0';\n\t\t/* Remove trailing spaces */\n\t\tspacep = strchr(temp, ' ');\n\t\tif (spacep)\n\t\t\t*spacep = '\\0';\n\n\t\tND_PRINT((ndo, \" fh %s/\", temp));\n\t} else {\n\t\tND_PRINT((ndo, \" fh %d,%d/\",\n\t\t\t     fsid.Fsid_dev.Major, fsid.Fsid_dev.Minor));\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static void ssdp_recv(int sd)\n{\n\tssize_t len;\n\tstruct sockaddr sa;\n\tsocklen_t salen;\n\tchar buf[MAX_PKT_SIZE];\n\n\tmemset(buf, 0, sizeof(buf));\n\tlen = recvfrom(sd, buf, sizeof(buf), MSG_DONTWAIT, &sa, &salen);\n\tif (len > 0) {\n\t\tbuf[len] = 0;\n\n\t\tif (sa.sa_family != AF_INET)\n\t\t\treturn;\n\n\t\tif (strstr(buf, \"M-SEARCH *\")) {\n\t\t\tsize_t i;\n\t\t\tchar *ptr, *type;\n\t\t\tstruct ifsock *ifs;\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&sa;\n\n\t\t\tifs = find_outbound(&sa);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static void ssdp_recv(int sd)\n{\n\tssize_t len;\n\tstruct sockaddr sa;\n\tsocklen_t salen;\n\tchar buf[MAX_PKT_SIZE + 1];\n\n\tmemset(buf, 0, sizeof(buf));\n\tlen = recvfrom(sd, buf, sizeof(buf) - 1, MSG_DONTWAIT, &sa, &salen);\n\tif (len > 0) {\n\t\tif (sa.sa_family != AF_INET)\n\t\t\treturn;\n\n\t\tif (strstr(buf, \"M-SEARCH *\")) {\n\t\t\tsize_t i;\n\t\t\tchar *ptr, *type;\n\t\t\tstruct ifsock *ifs;\n\t\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)&sa;\n\n\t\t\tifs = find_outbound(&sa);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len,\n\t\t\t\t     unsigned long data_len, int noblock,\n\t\t\t\t     int *errcode)\n{\n\tstruct sk_buff *skb;\n\tgfp_t gfp_mask;\n\tlong timeo;\n\tint err;\n\n\tgfp_mask = sk->sk_allocation;\n\tif (gfp_mask & __GFP_WAIT)\n\t\tgfp_mask |= __GFP_REPEAT;\n\n\ttimeo = sock_sndtimeo(sk, noblock);\n\twhile (1) {\n\t\terr = sock_error(sk);\n\t\tif (err != 0)\n\t\t\tgoto failure;\n\n\t\terr = -EPIPE;\n\t\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\t\tgoto failure;\n\n\t\tif (atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {\n\t\t\tskb = alloc_skb(header_len, gfp_mask);\n\t\t\tif (skb) {\n\t\t\t\tint npages;\n\t\t\t\tint i;\n\n\t\t\t\t/* No pages, we're done... */\n\t\t\t\tif (!data_len)\n\t\t\t\t\tbreak;\n\n\t\t\t\tnpages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;\n\t\t\t\tskb->truesize += data_len;\n\t\t\t\tskb_shinfo(skb)->nr_frags = npages;\n\t\t\t\tfor (i = 0; i < npages; i++) {\n\t\t\t\t\tstruct page *page;\n\n\t\t\t\t\tpage = alloc_pages(sk->sk_allocation, 0);\n\t\t\t\t\tif (!page) {\n\t\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\t\t\tskb_shinfo(skb)->nr_frags = i;\n\t\t\t\t\t\tkfree_skb(skb);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "struct sk_buff *sock_alloc_send_pskb(struct sock *sk, unsigned long header_len,\n\t\t\t\t     unsigned long data_len, int noblock,\n\t\t\t\t     int *errcode)\n{\n\tstruct sk_buff *skb;\n\tgfp_t gfp_mask;\n\tlong timeo;\n\tint err;\n\tint npages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;\n\n\terr = -EMSGSIZE;\n\tif (npages > MAX_SKB_FRAGS)\n\t\tgoto failure;\n\n\tgfp_mask = sk->sk_allocation;\n\tif (gfp_mask & __GFP_WAIT)\n\t\tgfp_mask |= __GFP_REPEAT;\n\n\ttimeo = sock_sndtimeo(sk, noblock);\n\twhile (1) {\n\t\terr = sock_error(sk);\n\t\tif (err != 0)\n\t\t\tgoto failure;\n\n\t\terr = -EPIPE;\n\t\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\t\tgoto failure;\n\n\t\tif (atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {\n\t\t\tskb = alloc_skb(header_len, gfp_mask);\n\t\t\tif (skb) {\n\t\t\t\tint i;\n\n\t\t\t\t/* No pages, we're done... */\n\t\t\t\tif (!data_len)\n\t\t\t\t\tbreak;\n\n\t\t\t\tskb->truesize += data_len;\n\t\t\t\tskb_shinfo(skb)->nr_frags = npages;\n\t\t\t\tfor (i = 0; i < npages; i++) {\n\t\t\t\t\tstruct page *page;\n\n\t\t\t\t\tpage = alloc_pages(sk->sk_allocation, 0);\n\t\t\t\t\tif (!page) {\n\t\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\t\t\tskb_shinfo(skb)->nr_frags = i;\n\t\t\t\t\t\tkfree_skb(skb);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\tbreak;\n\n\tcase IPV6_2292RTHDR:\n\t\tval = np->rxopt.bits.osrcrt;\n\t\tbreak;\n\n\tcase IPV6_HOPOPTS:\n\tcase IPV6_RTHDRDSTOPTS:\n\tcase IPV6_RTHDR:\n\tcase IPV6_DSTOPTS:\n\t{\n\n\t\tlock_sock(sk);\n\t\tlen = ipv6_getsockopt_sticky(sk, np->opt,\n\t\t\t\t\t     optname, optval, len);\n\t\trelease_sock(sk);\n\t\t/* check if ipv6_getsockopt_sticky() returns err code */\n\t\tif (len < 0)\n\t\t\treturn len;\n\t\treturn put_user(len, optlen);\n\t}\n\n\tcase IPV6_RECVHOPOPTS:\n\t\tval = np->rxopt.bits.hopopts;\n\t\tbreak;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n\tcase IPV6_2292RTHDR:\n\t\tval = np->rxopt.bits.osrcrt;\n\t\tbreak;\n\n\tcase IPV6_HOPOPTS:\n\tcase IPV6_RTHDRDSTOPTS:\n\tcase IPV6_RTHDR:\n\tcase IPV6_DSTOPTS:\n\t{\n\t\tstruct ipv6_txoptions *opt;\n\n\t\tlock_sock(sk);\n\t\topt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));\n\t\tlen = ipv6_getsockopt_sticky(sk, opt, optname, optval, len);\n\t\trelease_sock(sk);\n\t\t/* check if ipv6_getsockopt_sticky() returns err code */\n\t\tif (len < 0)\n\t\t\treturn len;\n\t\treturn put_user(len, optlen);\n\t}\n\n\tcase IPV6_RECVHOPOPTS:\n\t\tval = np->rxopt.bits.hopopts;\n\t\tbreak;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "      do\n      {\n         //Read incoming packet\n         error = rza1EthReceivePacket(interface);\n\n         //No more data in the receive buffer?\n      } while(error != ERROR_BUFFER_EMPTY);\n   }\n\n   //Re-enable EDMAC interrupts\n   ETHER.EESIPR0 =  ETHER_EESIPR0_TWBIP | ETHER_EESIPR0_FRIP;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "      do\n      {\n         //Read incoming packet\n         error = rza1EthReceivePacket(interface);\n\n         //No more data in the receive buffer?\n      } while(error != ERROR_BUFFER_EMPTY);\n   }\n\n   //Re-enable EDMAC interrupts\n   ETHER.EESIPR0 = ETHER_EESIPR0_TWBIP | ETHER_EESIPR0_FRIP;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "        int          GetS32BE (int nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n\n            if ( nPos < 0 || nPos + 3 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 3];\n            if ( nRes & 0x80000000 )\n                nRes |= ~0xffffffff;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "        int          GetS32BE (const unsigned int& nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n\n            if ( m_nLen < 4 || nPos > (m_nLen - 4) )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];\n            nRes = (nRes << 8) + m_sFile[nPos + 1];\n            nRes = (nRes << 8) + m_sFile[nPos + 2];\n            nRes = (nRes << 8) + m_sFile[nPos + 3];\n            if ( nRes & 0x80000000 )\n                nRes |= ~0xffffffff;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "retry:\n\tif (err && !es)\n\t\tes = __es_alloc_extent(true);\n\t/*\n\t * ext4_clear_inode() depends on us taking i_es_lock unconditionally\n\t * so that we are sure __es_shrink() is done with the inode before it\n\t * is reclaimed.\n\t */\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end, &reserved, es);\n\tif (es && !es->es_len)\n\t\t__es_free_extent(es);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\tif (err)\n\t\tgoto retry;\n\n\text4_es_print_tree(inode);\n\text4_da_release_space(inode, reserved);\n\treturn;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "retry:\n\tif (err && !es)\n\t\tes = __es_alloc_extent(true);\n\t/*\n\t * ext4_clear_inode() depends on us taking i_es_lock unconditionally\n\t * so that we are sure __es_shrink() is done with the inode before it\n\t * is reclaimed.\n\t */\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end, &reserved, es);\n\t/* Free preallocated extent if it didn't get used. */\n\tif (es) {\n\t\tif (!es->es_len)\n\t\t\t__es_free_extent(es);\n\t\tes = NULL;\n\t}\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\tif (err)\n\t\tgoto retry;\n\n\text4_es_print_tree(inode);\n\text4_da_release_space(inode, reserved);\n\treturn;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void Context::onUpstreamConnectionClose(PeerType peer_type) {\n  if (wasm_->onUpstreamConnectionClose_) {\n    wasm_->onUpstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void Context::onUpstreamConnectionClose(PeerType peer_type) {\n  if (in_vm_context_created_ && wasm_->onUpstreamConnectionClose_) {\n    wasm_->onUpstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,\n\t\t\tint length, int offset, int total_size)\n{\n\tstruct oz_port *port = hport;\n\tstruct urb *urb;\n\tint err = 0;\n\n\toz_dbg(ON, \"oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\\n\",\n\t       length, offset, total_size);\n\turb = oz_find_urb_by_id(port, 0, req_id);\n\tif (!urb)\n\t\treturn;\n\tif (status == 0) {\n\t\tint copy_len;\n\t\tint required_size = urb->transfer_buffer_length;\n\n\t\tif (required_size > total_size)\n\t\t\trequired_size = total_size;\n\t\tcopy_len = required_size-offset;\n\t\tif (length <= copy_len)\n\t\t\tcopy_len = length;\n\t\tmemcpy(urb->transfer_buffer+offset, desc, copy_len);\n\t\toffset += copy_len;\n\t\tif (offset < required_size) {\n\t\t\tstruct usb_ctrlrequest *setup =",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void oz_hcd_get_desc_cnf(void *hport, u8 req_id, u8 status, const u8 *desc,\n\t\t\tu8 length, u16 offset, u16 total_size)\n{\n\tstruct oz_port *port = hport;\n\tstruct urb *urb;\n\tint err = 0;\n\n\toz_dbg(ON, \"oz_hcd_get_desc_cnf length = %d offs = %d tot_size = %d\\n\",\n\t       length, offset, total_size);\n\turb = oz_find_urb_by_id(port, 0, req_id);\n\tif (!urb)\n\t\treturn;\n\tif (status == 0) {\n\t\tunsigned int copy_len;\n\t\tunsigned int required_size = urb->transfer_buffer_length;\n\n\t\tif (required_size > total_size)\n\t\t\trequired_size = total_size;\n\t\tcopy_len = required_size-offset;\n\t\tif (length <= copy_len)\n\t\t\tcopy_len = length;\n\t\tmemcpy(urb->transfer_buffer+offset, desc, copy_len);\n\t\toffset += copy_len;\n\t\tif (offset < required_size) {\n\t\t\tstruct usb_ctrlrequest *setup =",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t    // delete the diff entry, the buffers are now equal here\n\t\t    dfree = dp;\n\t\t    dp = dp->df_next;\n\t\t    if (dprev == NULL)\n\t\t\tcurtab->tp_first_diff = dp;\n\t\t    else\n\t\t\tdprev->df_next = dp;\n\t\t}\n\t    }\n\n\t    // Adjust marks.  This will change the following entries!\n\t    if (added != 0)\n\t    {\n\t\tmark_adjust(lnum, lnum + count - 1, (long)MAXLNUM, (long)added);\n\t\tif (curwin->w_cursor.lnum >= lnum)\n\t\t{\n\t\t    // Adjust the cursor position if it's in/after the changed\n\t\t    // lines.\n\t\t    if (curwin->w_cursor.lnum >= lnum + count)\n\t\t\tcurwin->w_cursor.lnum += added;\n\t\t    else if (added < 0)\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t}\n\t    changed_lines(lnum, 0, lnum + count, (long)added);\n\n\t    if (dfree != NULL)\n\t    {\n\t\t// Diff is deleted, update folds in other windows.\n#ifdef FEAT_FOLDING\n\t\tdiff_fold_update(dfree, idx_to);\n#endif\n\t\tvim_free(dfree);\n\t    }\n\t    else\n\t\t// mark_adjust() may have changed the count in a wrong way\n\t\tdp->df_count[idx_to] = new_count;\n\n\t    // When changing the current buffer, keep track of line numbers\n\t    if (idx_cur == idx_to)\n\t\toff += added;\n\t}\n\n\t// If before the range or not deleted, go to next diff.\n\tif (dfree == NULL)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t{\n\t\t    // delete the diff entry, the buffers are now equal here\n\t\t    dfree = dp;\n\t\t    dp = dp->df_next;\n\t\t    if (dprev == NULL)\n\t\t\tcurtab->tp_first_diff = dp;\n\t\t    else\n\t\t\tdprev->df_next = dp;\n\t\t}\n\t    }\n\n\t    if (added != 0)\n\t    {\n\t\t// Adjust marks.  This will change the following entries!\n\t\tmark_adjust(lnum, lnum + count - 1, (long)MAXLNUM, (long)added);\n\t\tif (curwin->w_cursor.lnum >= lnum)\n\t\t{\n\t\t    // Adjust the cursor position if it's in/after the changed\n\t\t    // lines.\n\t\t    if (curwin->w_cursor.lnum >= lnum + count)\n\t\t\tcurwin->w_cursor.lnum += added;\n\t\t    else if (added < 0)\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t}\n\t    changed_lines(lnum, 0, lnum + count, (long)added);\n\n\t    if (dfree != NULL)\n\t    {\n\t\t// Diff is deleted, update folds in other windows.\n#ifdef FEAT_FOLDING\n\t\tdiff_fold_update(dfree, idx_to);\n#endif\n\t\tvim_free(dfree);\n\t    }\n\n\t    // mark_adjust() may have made \"dp\" invalid.  We don't know where\n\t    // to continue then, bail out.\n\t    if (added != 0 && !valid_diff(dp))\n\t\tbreak;\n\n\t    if (dfree == NULL)\n\t\t// mark_adjust() may have changed the count in a wrong way\n\t\tdp->df_count[idx_to] = new_count;\n\n\t    // When changing the current buffer, keep track of line numbers\n\t    if (idx_cur == idx_to)\n\t\toff += added;\n\t}\n\n\t// If before the range or not deleted, go to next diff.\n\tif (dfree == NULL)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  int num_inputs = NumInputs(node);\n  TF_LITE_ENSURE(context, num_inputs >= 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  output->type = input1->type;\n\n  // Check that all input tensors have the same shape and type.\n  for (int i = kInputTensor1 + 1; i < num_inputs; ++i) {\n    const TfLiteTensor* input = GetInput(context, node, i);\n    TF_LITE_ENSURE(context, HaveSameShapes(input1, input));\n    TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input->type);\n  }\n\n  // Use the first input node's dimension to be the dimension of the output\n  // node.\n  TfLiteIntArray* input1_dims = input1->dims;\n  TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input1_dims);\n  return context->ResizeTensor(context, output, output_dims);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  int num_inputs = NumInputs(node);\n  TF_LITE_ENSURE(context, num_inputs >= 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  output->type = input1->type;\n\n  // Check that all input tensors have the same shape and type.\n  for (int i = kInputTensor1 + 1; i < num_inputs; ++i) {\n    const TfLiteTensor* input;\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &input));\n    TF_LITE_ENSURE(context, HaveSameShapes(input1, input));\n    TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input->type);\n  }\n\n  // Use the first input node's dimension to be the dimension of the output\n  // node.\n  TfLiteIntArray* input1_dims = input1->dims;\n  TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input1_dims);\n  return context->ResizeTensor(context, output, output_dims);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "/* static */ tsl::StatusOr<int> GpuDriver::GetDeviceAttribute(\n    CUdevice_attribute attribute, CUdevice device) {\n  int val;\n  CUresult res = cuDeviceGetAttribute(&val, attribute, device);\n  if (res != CUDA_SUCCESS) {\n    return tsl::Status(\n        port::error::INTERNAL,\n        absl::StrFormat(\"failed to get device attribute %d for device %d: %s\",\n                        attribute, device, ToString(res)));\n  }\n  return val;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "/* static */ tsl::StatusOr<int> GpuDriver::GetDeviceAttribute(\n    CUdevice_attribute attribute, CUdevice device) {\n  int val;\n  CUresult res = cuDeviceGetAttribute(&val, attribute, device);\n  if (res != CUDA_SUCCESS) {\n    return tsl::Status(\n        tsl::error::INTERNAL,\n        absl::StrFormat(\"failed to get device attribute %d for device %d: %s\",\n                        attribute, device, ToString(res)));\n  }\n  return val;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n    if (argc > 2)\n        tcpPort = atoi(argv[2]);\n\n    IedClientError error;\n\n    IedConnection con = IedConnection_create();\n\n    IedConnection_connect(con, &error, hostname, tcpPort);\n\n    if (error == IED_ERROR_OK) {\n\n\n        /************************\n         * Direct control\n         ***********************/\n\n        ControlObjectClient control\n            = ControlObjectClient_create(\"simpleIOGenericIO/GGIO1.SPCSO1\", con);\n\n        MmsValue* ctlVal = MmsValue_newBoolean(true);\n\n        ControlObjectClient_setOrigin(control, NULL, 3);\n\n        if (ControlObjectClient_operate(control, ctlVal, 0 /* operate now */)) {\n            printf(\"simpleIOGenericIO/GGIO1.SPCSO1 operated successfully\\n\");\n        }\n        else {\n            printf(\"failed to operate simpleIOGenericIO/GGIO1.SPCSO1\\n\");\n        }\n\n        MmsValue_delete(ctlVal);\n\n        ControlObjectClient_destroy(control);\n\n        /* Check if status value has changed */\n\n        MmsValue* stVal = IedConnection_readObject(con, &error, \"simpleIOGenericIO/GGIO1.SPCSO1.stVal\", IEC61850_FC_ST);\n\n        if (error == IED_ERROR_OK) {\n            bool state = MmsValue_getBoolean(stVal);\n            MmsValue_delete(stVal);\n\n            printf(\"New status of simpleIOGenericIO/GGIO1.SPCSO1.stVal: %i\\n\", state);\n        }\n        else {\n            printf(\"Reading status for simpleIOGenericIO/GGIO1.SPCSO1 failed!\\n\");\n        }\n\n\n        /************************\n         * Select before operate\n         ***********************/\n\n        control = ControlObjectClient_create(\"simpleIOGenericIO/GGIO1.SPCSO2\", con);\n\n        if (ControlObjectClient_select(control)) {\n\n            ctlVal = MmsValue_newBoolean(true);\n\n            if (ControlObjectClient_operate(control, ctlVal, 0 /* operate now */)) {\n                printf(\"simpleIOGenericIO/GGIO1.SPCSO2 operated successfully\\n\");\n            }\n            else {\n                printf(\"failed to operate simpleIOGenericIO/GGIO1.SPCSO2!\\n\");\n            }\n\n            MmsValue_delete(ctlVal);\n        }\n        else {\n            printf(\"failed to select simpleIOGenericIO/GGIO1.SPCSO2!\\n\");\n        }\n\n        ControlObjectClient_destroy(control);\n\n\n        /****************************************\n         * Direct control with enhanced security\n         ****************************************/\n\n        control = ControlObjectClient_create(\"simpleIOGenericIO/GGIO1.SPCSO3\", con);\n\n        ControlObjectClient_setCommandTerminationHandler(control, commandTerminationHandler, NULL);\n\n        ctlVal = MmsValue_newBoolean(true);\n\n        if (ControlObjectClient_operate(control, ctlVal, 0 /* operate now */)) {\n            printf(\"simpleIOGenericIO/GGIO1.SPCSO3 operated successfully\\n\");\n        }\n        else {\n            printf(\"failed to operate simpleIOGenericIO/GGIO1.SPCSO3\\n\");\n        }\n\n        MmsValue_delete(ctlVal);\n\n        /* Wait for command termination message */\n        Thread_sleep(1000);\n\n        ControlObjectClient_destroy(control);\n\n        /* Check if status value has changed */\n\n       stVal = IedConnection_readObject(con, &error, \"simpleIOGenericIO/GGIO1.SPCSO3.stVal\", IEC61850_FC_ST);\n\n        if (error == IED_ERROR_OK) {\n            bool state = MmsValue_getBoolean(stVal);\n\n            printf(\"New status of simpleIOGenericIO/GGIO1.SPCSO3.stVal: %i\\n\", state);\n\n            MmsValue_delete(stVal);\n        }\n        else {\n            printf(\"Reading status for simpleIOGenericIO/GGIO1.SPCSO3 failed!\\n\");\n        }\n\n        /***********************************************\n         * Select before operate with enhanced security\n         ***********************************************/\n\n        control = ControlObjectClient_create(\"simpleIOGenericIO/GGIO1.SPCSO4\", con);\n\n        ControlObjectClient_setCommandTerminationHandler(control, commandTerminationHandler, NULL);\n\n        ctlVal = MmsValue_newBoolean(true);\n\n        if (ControlObjectClient_selectWithValue(control, ctlVal)) {\n\n            if (ControlObjectClient_operate(control, ctlVal, 0 /* operate now */)) {\n                printf(\"simpleIOGenericIO/GGIO1.SPCSO4 operated successfully\\n\");\n            }\n            else {\n                printf(\"failed to operate simpleIOGenericIO/GGIO1.SPCSO4!\\n\");\n            }\n\n        }\n        else {\n            printf(\"failed to select simpleIOGenericIO/GGIO1.SPCSO4!\\n\");\n        }\n\n        MmsValue_delete(ctlVal);\n\n        /* Wait for command termination message */\n        Thread_sleep(1000);\n\n        ControlObjectClient_destroy(control);\n\n\n        /*********************************************************************\n         * Direct control with enhanced security (expect CommandTermination-)\n         *********************************************************************/\n\n        control = ControlObjectClient_create(\"simpleIOGenericIO/GGIO1.SPCSO9\", con);\n\n        ControlObjectClient_setCommandTerminationHandler(control, commandTerminationHandler, NULL);\n\n        ctlVal = MmsValue_newBoolean(true);\n\n        if (ControlObjectClient_operate(control, ctlVal, 0 /* operate now */)) {\n            printf(\"simpleIOGenericIO/GGIO1.SPCSO9 operated successfully\\n\");\n        }\n        else {\n            printf(\"failed to operate simpleIOGenericIO/GGIO1.SPCSO9\\n\");\n        }\n\n        MmsValue_delete(ctlVal);\n\n        /* Wait for command termination message */\n        Thread_sleep(1000);\n\n        ControlObjectClient_destroy(control);\n\n\n        IedConnection_close(con);\n    }\n    else {\n    \tprintf(\"Connection failed!\\n\");\n    }\n\n    IedConnection_destroy(con);\n    return 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n    if (argc > 2)\n        tcpPort = atoi(argv[2]);\n\n    IedClientError error;\n\n    IedConnection con = IedConnection_create();\n\n    IedConnection_connect(con, &error, hostname, tcpPort);\n\n    if (error == IED_ERROR_OK)\n    {\n        MmsValue* ctlVal = NULL;\n        MmsValue* stVal = NULL;\n\n        /************************\n         * Direct control\n         ***********************/\n\n        ControlObjectClient control\n            = ControlObjectClient_create(\"simpleIOGenericIO/GGIO1.SPCSO1\", con);\n\n        if (control)\n        {\n            ctlVal = MmsValue_newBoolean(true);\n\n            ControlObjectClient_setOrigin(control, NULL, 3);\n\n            if (ControlObjectClient_operate(control, ctlVal, 0 /* operate now */)) {\n                printf(\"simpleIOGenericIO/GGIO1.SPCSO1 operated successfully\\n\");\n            }\n            else {\n                printf(\"failed to operate simpleIOGenericIO/GGIO1.SPCSO1\\n\");\n            }\n\n            MmsValue_delete(ctlVal);\n\n            ControlObjectClient_destroy(control);\n\n            /* Check if status value has changed */\n\n            stVal = IedConnection_readObject(con, &error, \"simpleIOGenericIO/GGIO1.SPCSO1.stVal\", IEC61850_FC_ST);\n\n            if (error == IED_ERROR_OK) {\n                bool state = MmsValue_getBoolean(stVal);\n                MmsValue_delete(stVal);\n\n                printf(\"New status of simpleIOGenericIO/GGIO1.SPCSO1.stVal: %i\\n\", state);\n            }\n            else {\n                printf(\"Reading status for simpleIOGenericIO/GGIO1.SPCSO1 failed!\\n\");\n            }\n\n        }\n        else {\n            printf(\"Control object simpleIOGenericIO/GGIO1.SPCSO1 not found in server\\n\");\n        }\n\n        /************************\n         * Select before operate\n         ***********************/\n\n        control = ControlObjectClient_create(\"simpleIOGenericIO/GGIO1.SPCSO2\", con);\n\n        if (control)\n        {\n            if (ControlObjectClient_select(control)) {\n\n                ctlVal = MmsValue_newBoolean(true);\n\n                if (ControlObjectClient_operate(control, ctlVal, 0 /* operate now */)) {\n                    printf(\"simpleIOGenericIO/GGIO1.SPCSO2 operated successfully\\n\");\n                }\n                else {\n                    printf(\"failed to operate simpleIOGenericIO/GGIO1.SPCSO2!\\n\");\n                }\n\n                MmsValue_delete(ctlVal);\n            }\n            else {\n                printf(\"failed to select simpleIOGenericIO/GGIO1.SPCSO2!\\n\");\n            }\n\n            ControlObjectClient_destroy(control);\n        }\n        else {\n            printf(\"Control object simpleIOGenericIO/GGIO1.SPCSO2 not found in server\\n\");\n        }\n\n        /****************************************\n         * Direct control with enhanced security\n         ****************************************/\n\n        control = ControlObjectClient_create(\"simpleIOGenericIO/GGIO1.SPCSO3\", con);\n\n        if (control)\n        {\n            ControlObjectClient_setCommandTerminationHandler(control, commandTerminationHandler, NULL);\n\n            ctlVal = MmsValue_newBoolean(true);\n\n            if (ControlObjectClient_operate(control, ctlVal, 0 /* operate now */)) {\n                printf(\"simpleIOGenericIO/GGIO1.SPCSO3 operated successfully\\n\");\n            }\n            else {\n                printf(\"failed to operate simpleIOGenericIO/GGIO1.SPCSO3\\n\");\n            }\n\n            MmsValue_delete(ctlVal);\n\n            /* Wait for command termination message */\n            Thread_sleep(1000);\n\n            ControlObjectClient_destroy(control);\n\n            /* Check if status value has changed */\n\n            stVal = IedConnection_readObject(con, &error, \"simpleIOGenericIO/GGIO1.SPCSO3.stVal\", IEC61850_FC_ST);\n\n            if (error == IED_ERROR_OK) {\n                bool state = MmsValue_getBoolean(stVal);\n\n                printf(\"New status of simpleIOGenericIO/GGIO1.SPCSO3.stVal: %i\\n\", state);\n\n                MmsValue_delete(stVal);\n            }\n            else {\n                printf(\"Reading status for simpleIOGenericIO/GGIO1.SPCSO3 failed!\\n\");\n            }\n        }\n        else {\n            printf(\"Control object simpleIOGenericIO/GGIO1.SPCSO3 not found in server\\n\");\n        }\n\n        /***********************************************\n         * Select before operate with enhanced security\n         ***********************************************/\n\n        control = ControlObjectClient_create(\"simpleIOGenericIO/GGIO1.SPCSO4\", con);\n\n        if (control)\n        {\n            ControlObjectClient_setCommandTerminationHandler(control, commandTerminationHandler, NULL);\n\n            ctlVal = MmsValue_newBoolean(true);\n\n            if (ControlObjectClient_selectWithValue(control, ctlVal)) {\n\n                if (ControlObjectClient_operate(control, ctlVal, 0 /* operate now */)) {\n                    printf(\"simpleIOGenericIO/GGIO1.SPCSO4 operated successfully\\n\");\n                }\n                else {\n                    printf(\"failed to operate simpleIOGenericIO/GGIO1.SPCSO4!\\n\");\n                }\n\n            }\n            else {\n                printf(\"failed to select simpleIOGenericIO/GGIO1.SPCSO4!\\n\");\n            }\n\n            MmsValue_delete(ctlVal);\n\n            /* Wait for command termination message */\n            Thread_sleep(1000);\n\n            ControlObjectClient_destroy(control);\n        }\n        else {\n            printf(\"Control object simpleIOGenericIO/GGIO1.SPCSO4 not found in server\\n\");\n        }\n\n        /*********************************************************************\n         * Direct control with enhanced security (expect CommandTermination-)\n         *********************************************************************/\n\n        control = ControlObjectClient_create(\"simpleIOGenericIO/GGIO1.SPCSO9\", con);\n\n        if (control)\n        {\n            ControlObjectClient_setCommandTerminationHandler(control, commandTerminationHandler, NULL);\n\n            ctlVal = MmsValue_newBoolean(true);\n\n            if (ControlObjectClient_operate(control, ctlVal, 0 /* operate now */)) {\n                printf(\"simpleIOGenericIO/GGIO1.SPCSO9 operated successfully\\n\");\n            }\n            else {\n                printf(\"failed to operate simpleIOGenericIO/GGIO1.SPCSO9\\n\");\n            }\n\n            MmsValue_delete(ctlVal);\n\n            /* Wait for command termination message */\n            Thread_sleep(1000);\n\n            ControlObjectClient_destroy(control);\n        }\n        else {\n            printf(\"Control object simpleIOGenericIO/GGIO1.SPCSO9 not found in server\\n\");\n        }\n\n        IedConnection_close(con);\n    }\n    else {\n    \tprintf(\"Connection failed!\\n\");\n    }\n\n    IedConnection_destroy(con);\n    return 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static bool check_block(struct file *fp, u32 *size4, loff_t *pos, u32 *offset,\n\t\t\tunsigned expected_size, const char* expected_sha256)\n{\n\tksu_kernel_read_compat(fp, size4, 0x4, pos); // signer-sequence length\n\tksu_kernel_read_compat(fp, size4, 0x4, pos); // signer length\n\tksu_kernel_read_compat(fp, size4, 0x4, pos); // signed data length\n\n\t*offset += 0x4 * 3;\n\n\tksu_kernel_read_compat(fp, size4, 0x4, pos); // digests-sequence length\n\n\t*pos += *size4;\n\t*offset += 0x4 + *size4;\n\n\tksu_kernel_read_compat(fp, size4, 0x4, pos); // certificates length\n\tksu_kernel_read_compat(fp, size4, 0x4, pos); // certificate length\n\t*offset += 0x4 * 2;\n\n\tif (*size4 == expected_size) {\n\t\t*offset += *size4;\n\n\t\t#define CERT_MAX_LENGTH 1024\n\t\tchar cert[CERT_MAX_LENGTH];\n\t\tif (*size4 > CERT_MAX_LENGTH) {\n\t\t\tpr_info(\"cert length overlimit\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tksu_kernel_read_compat(fp, cert, *size4, pos);\n\t\tunsigned char digest[SHA256_DIGEST_SIZE];\n\t\tif (IS_ERR(ksu_sha256(cert, *size4, digest))) {\n\t\t\tpr_info(\"sha256 error\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tchar hash_str[SHA256_DIGEST_SIZE * 2 + 1];\n\t\thash_str[SHA256_DIGEST_SIZE * 2] = '\\0';\n\n\t\tbin2hex(hash_str, digest, SHA256_DIGEST_SIZE);\n\t\tpr_info(\"sha256: %s, expected: %s\\n\", hash_str, expected_sha256);\n\t\tif (strcmp(expected_sha256, hash_str) == 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static bool check_block(struct file *fp, u32 *size4, loff_t *pos, u32 *offset,\n\t\t\tunsigned expected_size, const char *expected_sha256)\n{\n\tksu_kernel_read_compat(fp, size4, 0x4, pos); // signer-sequence length\n\tksu_kernel_read_compat(fp, size4, 0x4, pos); // signer length\n\tksu_kernel_read_compat(fp, size4, 0x4, pos); // signed data length\n\n\t*offset += 0x4 * 3;\n\n\tksu_kernel_read_compat(fp, size4, 0x4, pos); // digests-sequence length\n\n\t*pos += *size4;\n\t*offset += 0x4 + *size4;\n\n\tksu_kernel_read_compat(fp, size4, 0x4, pos); // certificates length\n\tksu_kernel_read_compat(fp, size4, 0x4, pos); // certificate length\n\t*offset += 0x4 * 2;\n\n\tif (*size4 == expected_size) {\n\t\t*offset += *size4;\n\n#define CERT_MAX_LENGTH 1024\n\t\tchar cert[CERT_MAX_LENGTH];\n\t\tif (*size4 > CERT_MAX_LENGTH) {\n\t\t\tpr_info(\"cert length overlimit\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tksu_kernel_read_compat(fp, cert, *size4, pos);\n\t\tunsigned char digest[SHA256_DIGEST_SIZE];\n\t\tif (IS_ERR(ksu_sha256(cert, *size4, digest))) {\n\t\t\tpr_info(\"sha256 error\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tchar hash_str[SHA256_DIGEST_SIZE * 2 + 1];\n\t\thash_str[SHA256_DIGEST_SIZE * 2] = '\\0';\n\n\t\tbin2hex(hash_str, digest, SHA256_DIGEST_SIZE);\n\t\tpr_info(\"sha256: %s, expected: %s\\n\", hash_str,\n\t\t\texpected_sha256);\n\t\tif (strcmp(expected_sha256, hash_str) == 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t}\n\t\t\tcase 32867: break;\n\t\t\tdefault: p->is_raw = 0;\n    }\n\tif (!p->dng_version && p->tiff_samples == 3)\n\t\tif (p->tiff_ifd[raw].bytes && p->tiff_bps != 14 && p->tiff_bps != 2048)\n\t\t\tp->is_raw = 0;\n\tif (!p->dng_version && p->tiff_bps == 8 && p->tiff_compress == 1 &&\n\t\tp->tiff_ifd[raw].phint == 1) p->is_raw = 0;\n\tif (p->tiff_bps == 8 && p->tiff_samples == 4) p->is_raw = 0;\n\tfor (i=0; i < (int)p->tiff_nifds; i++)\n\t\tif (i != raw && p->tiff_ifd[i].samples == max_samp &&\n\t\t\tp->tiff_ifd[i].width * p->tiff_ifd[i].height / SQR(p->tiff_ifd[i].bps+1) >\n\t\t\t(int)(p->thumb_width *       p->thumb_height / SQR(p->thumb_misc+1))) {\n\t\t\tp->thumb_width  = p->tiff_ifd[i].width;\n\t\t\tp->thumb_height = p->tiff_ifd[i].height;\n\t\t\tp->thumb_offset = p->tiff_ifd[i].offset;\n\t\t\tp->thumb_length = p->tiff_ifd[i].bytes;\n\t\t\tp->thumb_misc   = p->tiff_ifd[i].bps;\n\t\t\tthm = i;\n\t\t}\n\tif (thm >= 0) {\n\t\tp->thumb_misc |= p->tiff_ifd[thm].samples << 5;\n\t\tswitch (p->tiff_ifd[thm].comp) {\n\t\tcase 0:\n\t\t\tp->write_thumb = &DCR_CLASS dcr_layer_thumb;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (p->tiff_ifd[thm].bps > 8)\n\t\t\t\tp->thumb_load_raw = &DCR_CLASS dcr_kodak_thumb_load_raw;\n\t\t\telse",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\tcase 32867: break;\n\t\t\tdefault: p->is_raw = 0;\n    }\n\tif (!p->dng_version && p->tiff_samples == 3)\n\t\tif (p->tiff_ifd[raw].bytes && p->tiff_bps != 14 && p->tiff_bps != 2048)\n\t\t\tp->is_raw = 0;\n\tif (!p->dng_version && p->tiff_bps == 8 && p->tiff_compress == 1 &&\n\t\tp->tiff_ifd[raw].phint == 1) p->is_raw = 0;\n\tif (p->tiff_bps == 8 && p->tiff_samples == 4) p->is_raw = 0;\n\tfor (i=0; i < (int)p->tiff_nifds; i++)\n    {\n        int sqr_1 = SQR(p->tiff_ifd[i].bps+1); if (sqr_1 == 0) sqr_1 = 1;\n        int sqr_2 = SQR(p->thumb_misc+1); if (sqr_2 == 0) sqr_2 = 1;\n\t\tif (i != raw && p->tiff_ifd[i].samples == max_samp &&\n            p->tiff_ifd[i].width * p->tiff_ifd[i].height / sqr_1 >\n            (int)(p->thumb_width *       p->thumb_height / sqr_2)) {\n\t\t\tp->thumb_width  = p->tiff_ifd[i].width;\n\t\t\tp->thumb_height = p->tiff_ifd[i].height;\n\t\t\tp->thumb_offset = p->tiff_ifd[i].offset;\n\t\t\tp->thumb_length = p->tiff_ifd[i].bytes;\n\t\t\tp->thumb_misc   = p->tiff_ifd[i].bps;\n\t\t\tthm = i;\n\t\t}\n    }\n\tif (thm >= 0) {\n\t\tp->thumb_misc |= p->tiff_ifd[thm].samples << 5;\n\t\tswitch (p->tiff_ifd[thm].comp) {\n\t\tcase 0:\n\t\t\tp->write_thumb = &DCR_CLASS dcr_layer_thumb;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (p->tiff_ifd[thm].bps > 8)\n\t\t\t\tp->thumb_load_raw = &DCR_CLASS dcr_kodak_thumb_load_raw;\n\t\t\telse",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\tstruct device_node *ports, *np;\n\tchar *name;\n\n\tports = of_get_child_by_name(padctl->dev->of_node, \"ports\");\n\tif (!ports)\n\t\treturn NULL;\n\n\tname = kasprintf(GFP_KERNEL, \"%s-%u\", type, index);\n\tif (!name) {\n\t\tof_node_put(ports);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tnp = of_get_child_by_name(ports, name);\n\tkfree(name);\n\tof_node_put(ports);\n\n\treturn np;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\tstruct device_node *ports, *np;\n\tchar *name;\n\n\tports = of_get_child_by_name(padctl->dev->of_node, \"ports\");\n\tif (!ports)\n\t\treturn NULL;\n\n\tname = kasprintf(GFP_KERNEL, \"%s-%u\", type, index);\n\tif (!name) {\n\t\tof_node_put(ports);\n\t\treturn NULL;\n\t}\n\tnp = of_get_child_by_name(ports, name);\n\tkfree(name);\n\tof_node_put(ports);\n\n\treturn np;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static PyObject *__pyx_pf_17clickhouse_driver_6varint_2read_varint(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_f) {\n  Py_ssize_t __pyx_v_shift;\n  Py_ssize_t __pyx_v_result;\n  unsigned char __pyx_v_i;\n  PyObject *__pyx_v_read_one = NULL;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  unsigned char __pyx_t_4;\n  int __pyx_t_5;\n  __Pyx_RefNannySetupContext(\"read_varint\", 0);\n\n  /* \"clickhouse_driver/varint.pyx\":33\n *     Reads integer of variable length using LEB128.\n *     \"\"\"\n *     cdef Py_ssize_t shift = 0             # <<<<<<<<<<<<<<\n *     cdef Py_ssize_t result = 0\n *     cdef unsigned char i\n */\n  __pyx_v_shift = 0;\n\n  /* \"clickhouse_driver/varint.pyx\":34\n *     \"\"\"\n *     cdef Py_ssize_t shift = 0\n *     cdef Py_ssize_t result = 0             # <<<<<<<<<<<<<<\n *     cdef unsigned char i\n * \n */\n  __pyx_v_result = 0;\n\n  /* \"clickhouse_driver/varint.pyx\":37\n *     cdef unsigned char i\n * \n *     read_one = f.read_one             # <<<<<<<<<<<<<<\n * \n *     while True:\n */\n  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_f, __pyx_n_s_read_one); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 37, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_read_one = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/varint.pyx\":39\n *     read_one = f.read_one\n * \n *     while True:             # <<<<<<<<<<<<<<\n *         i = read_one()\n *         result |= (i & 0x7f) << shift\n */\n  while (1) {\n\n    /* \"clickhouse_driver/varint.pyx\":40\n * \n *     while True:\n *         i = read_one()             # <<<<<<<<<<<<<<\n *         result |= (i & 0x7f) << shift\n *         shift += 7\n */\n    __Pyx_INCREF(__pyx_v_read_one);\n    __pyx_t_2 = __pyx_v_read_one; __pyx_t_3 = NULL;\n    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {\n      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);\n      if (likely(__pyx_t_3)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n        __Pyx_INCREF(__pyx_t_3);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_2, function);\n      }\n    }\n    __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);\n    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 40, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __pyx_t_4 = __Pyx_PyInt_As_unsigned_char(__pyx_t_1); if (unlikely((__pyx_t_4 == (unsigned char)-1) && PyErr_Occurred())) __PYX_ERR(0, 40, __pyx_L1_error)\n    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n    __pyx_v_i = __pyx_t_4;\n\n    /* \"clickhouse_driver/varint.pyx\":41\n *     while True:\n *         i = read_one()\n *         result |= (i & 0x7f) << shift             # <<<<<<<<<<<<<<\n *         shift += 7\n *         if i < 0x80:\n */\n    __pyx_v_result = (__pyx_v_result | ((__pyx_v_i & 0x7f) << __pyx_v_shift));\n\n    /* \"clickhouse_driver/varint.pyx\":42\n *         i = read_one()\n *         result |= (i & 0x7f) << shift\n *         shift += 7             # <<<<<<<<<<<<<<\n *         if i < 0x80:\n *             break\n */\n    __pyx_v_shift = (__pyx_v_shift + 7);\n\n    /* \"clickhouse_driver/varint.pyx\":43\n *         result |= (i & 0x7f) << shift\n *         shift += 7\n *         if i < 0x80:             # <<<<<<<<<<<<<<\n *             break\n * \n */\n    __pyx_t_5 = ((__pyx_v_i < 0x80) != 0);\n    if (__pyx_t_5) {\n\n      /* \"clickhouse_driver/varint.pyx\":44\n *         shift += 7\n *         if i < 0x80:\n *             break             # <<<<<<<<<<<<<<\n * \n *     return result\n */\n      goto __pyx_L4_break;\n\n      /* \"clickhouse_driver/varint.pyx\":43\n *         result |= (i & 0x7f) << shift\n *         shift += 7\n *         if i < 0x80:             # <<<<<<<<<<<<<<\n *             break\n * \n */\n    }\n  }\n  __pyx_L4_break:;\n\n  /* \"clickhouse_driver/varint.pyx\":46\n *             break\n * \n *     return result             # <<<<<<<<<<<<<<\n */\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_result); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 46, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_r = __pyx_t_1;\n  __pyx_t_1 = 0;\n  goto __pyx_L0;\n\n  /* \"clickhouse_driver/varint.pyx\":29\n * \n * \n * def read_varint(f):             # <<<<<<<<<<<<<<\n *     \"\"\"\n *     Reads integer of variable length using LEB128.\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static PyObject *__pyx_pf_17clickhouse_driver_6varint_2read_varint(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_f) {\n  unsigned char __pyx_v_shift;\n  unsigned PY_LONG_LONG __pyx_v_i;\n  unsigned PY_LONG_LONG __pyx_v_result;\n  PyObject *__pyx_v_read_one = NULL;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  unsigned PY_LONG_LONG __pyx_t_4;\n  int __pyx_t_5;\n  __Pyx_RefNannySetupContext(\"read_varint\", 0);\n\n  /* \"clickhouse_driver/varint.pyx\":32\n *     Reads integer of variable length using LEB128.\n *     \"\"\"\n *     cdef unsigned char shift = 0             # <<<<<<<<<<<<<<\n *     cdef unsigned long long i, result = 0\n * \n */\n  __pyx_v_shift = 0;\n\n  /* \"clickhouse_driver/varint.pyx\":33\n *     \"\"\"\n *     cdef unsigned char shift = 0\n *     cdef unsigned long long i, result = 0             # <<<<<<<<<<<<<<\n * \n *     read_one = f.read_one\n */\n  __pyx_v_result = 0;\n\n  /* \"clickhouse_driver/varint.pyx\":35\n *     cdef unsigned long long i, result = 0\n * \n *     read_one = f.read_one             # <<<<<<<<<<<<<<\n * \n *     while True:\n */\n  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_f, __pyx_n_s_read_one); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 35, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_read_one = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/varint.pyx\":37\n *     read_one = f.read_one\n * \n *     while True:             # <<<<<<<<<<<<<<\n *         i = read_one()\n *         result |= (i & 0x7f) << shift\n */\n  while (1) {\n\n    /* \"clickhouse_driver/varint.pyx\":38\n * \n *     while True:\n *         i = read_one()             # <<<<<<<<<<<<<<\n *         result |= (i & 0x7f) << shift\n *         shift += 7\n */\n    __Pyx_INCREF(__pyx_v_read_one);\n    __pyx_t_2 = __pyx_v_read_one; __pyx_t_3 = NULL;\n    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_2))) {\n      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);\n      if (likely(__pyx_t_3)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);\n        __Pyx_INCREF(__pyx_t_3);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_2, function);\n      }\n    }\n    __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);\n    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 38, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __pyx_t_4 = __Pyx_PyInt_As_unsigned_PY_LONG_LONG(__pyx_t_1); if (unlikely((__pyx_t_4 == (unsigned PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 38, __pyx_L1_error)\n    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n    __pyx_v_i = __pyx_t_4;\n\n    /* \"clickhouse_driver/varint.pyx\":39\n *     while True:\n *         i = read_one()\n *         result |= (i & 0x7f) << shift             # <<<<<<<<<<<<<<\n *         shift += 7\n *         if i < 0x80:\n */\n    __pyx_v_result = (__pyx_v_result | ((__pyx_v_i & 0x7f) << __pyx_v_shift));\n\n    /* \"clickhouse_driver/varint.pyx\":40\n *         i = read_one()\n *         result |= (i & 0x7f) << shift\n *         shift += 7             # <<<<<<<<<<<<<<\n *         if i < 0x80:\n *             break\n */\n    __pyx_v_shift = (__pyx_v_shift + 7);\n\n    /* \"clickhouse_driver/varint.pyx\":41\n *         result |= (i & 0x7f) << shift\n *         shift += 7\n *         if i < 0x80:             # <<<<<<<<<<<<<<\n *             break\n * \n */\n    __pyx_t_5 = ((__pyx_v_i < 0x80) != 0);\n    if (__pyx_t_5) {\n\n      /* \"clickhouse_driver/varint.pyx\":42\n *         shift += 7\n *         if i < 0x80:\n *             break             # <<<<<<<<<<<<<<\n * \n *     return result\n */\n      goto __pyx_L4_break;\n\n      /* \"clickhouse_driver/varint.pyx\":41\n *         result |= (i & 0x7f) << shift\n *         shift += 7\n *         if i < 0x80:             # <<<<<<<<<<<<<<\n *             break\n * \n */\n    }\n  }\n  __pyx_L4_break:;\n\n  /* \"clickhouse_driver/varint.pyx\":44\n *             break\n * \n *     return result             # <<<<<<<<<<<<<<\n */\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = __Pyx_PyInt_From_unsigned_PY_LONG_LONG(__pyx_v_result); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 44, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_r = __pyx_t_1;\n  __pyx_t_1 = 0;\n  goto __pyx_L0;\n\n  /* \"clickhouse_driver/varint.pyx\":28\n * \n * \n * def read_varint(f):             # <<<<<<<<<<<<<<\n *     \"\"\"\n *     Reads integer of variable length using LEB128.\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)\n{\n    /* MPEG-4 Studio Profile only, not supported by hardware */\n    if (avctx->bits_per_raw_sample > 8) {\n        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        return avctx->pix_fmt;\n    }\n\n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        return AV_PIX_FMT_YUV420P;\n\n    if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {\n        if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)\n            avctx->color_range = AVCOL_RANGE_MPEG;\n        return AV_PIX_FMT_GRAY8;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)\n{\n    MpegEncContext *s = avctx->priv_data;\n    /* MPEG-4 Studio Profile only, not supported by hardware */\n    if (avctx->bits_per_raw_sample > 8) {\n        av_assert1(s->studio_profile);\n        return avctx->pix_fmt;\n    }\n\n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        return AV_PIX_FMT_YUV420P;\n\n    if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {\n        if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)\n            avctx->color_range = AVCOL_RANGE_MPEG;\n        return AV_PIX_FMT_GRAY8;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "static bool ParseSampler(Sampler *sampler, std::string *err, const json &o,\n                         bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&sampler->name, err, o, \"name\", false);\n\n  int minFilter = -1;\n  int magFilter = -1;\n  int wrapS = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  int wrapT = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  //int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  ParseIntegerProperty(&minFilter, err, o, \"minFilter\", false);\n  ParseIntegerProperty(&magFilter, err, o, \"magFilter\", false);\n  ParseIntegerProperty(&wrapS, err, o, \"wrapS\", false);\n  ParseIntegerProperty(&wrapT, err, o, \"wrapT\", false);\n  //ParseIntegerProperty(&wrapR, err, o, \"wrapR\", false);  // tinygltf extension\n\n  // TODO(syoyo): Check the value is alloed one.\n  // (e.g. we allow 9728(NEAREST), but don't allow 9727)\n\n  sampler->minFilter = minFilter;\n  sampler->magFilter = magFilter;\n  sampler->wrapS = wrapS;\n  sampler->wrapT = wrapT;\n  //sampler->wrapR = wrapR;\n\n  ParseExtensionsProperty(&(sampler->extensions), err, o);\n  ParseExtrasProperty(&(sampler->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        sampler->extensions_json_string = JsonToString(GetValue(it));\n      }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "static bool ParseSampler(Sampler *sampler, std::string *err, const json &o,\n                         bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&sampler->name, err, o, \"name\", false);\n\n  int minFilter = -1;\n  int magFilter = -1;\n  int wrapS = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  int wrapT = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  // int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  ParseIntegerProperty(&minFilter, err, o, \"minFilter\", false);\n  ParseIntegerProperty(&magFilter, err, o, \"magFilter\", false);\n  ParseIntegerProperty(&wrapS, err, o, \"wrapS\", false);\n  ParseIntegerProperty(&wrapT, err, o, \"wrapT\", false);\n  // ParseIntegerProperty(&wrapR, err, o, \"wrapR\", false);  // tinygltf\n  // extension\n\n  // TODO(syoyo): Check the value is alloed one.\n  // (e.g. we allow 9728(NEAREST), but don't allow 9727)\n\n  sampler->minFilter = minFilter;\n  sampler->magFilter = magFilter;\n  sampler->wrapS = wrapS;\n  sampler->wrapT = wrapT;\n  // sampler->wrapR = wrapR;\n\n  ParseExtensionsProperty(&(sampler->extensions), err, o);\n  ParseExtrasProperty(&(sampler->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        sampler->extensions_json_string = JsonToString(GetValue(it));\n      }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "HostPlatform::GetUncachedExecutor(const StreamExecutorConfig& config) {\n  auto executor = std::make_unique<StreamExecutor>(\n      this, std::make_unique<HostExecutor>(config.plugin_config),\n      config.ordinal);\n  auto init_status = executor->Init(config.device_options);\n  if (!init_status.ok()) {\n    return tsl::Status(\n        port::error::INTERNAL,\n        absl::StrFormat(\n            \"failed initializing StreamExecutor for device ordinal %d: %s\",\n            config.ordinal, init_status.ToString().c_str()));\n  }\n\n  return std::move(executor);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "HostPlatform::GetUncachedExecutor(const StreamExecutorConfig& config) {\n  auto executor = std::make_unique<StreamExecutor>(\n      this, std::make_unique<HostExecutor>(config.plugin_config),\n      config.ordinal);\n  auto init_status = executor->Init(config.device_options);\n  if (!init_status.ok()) {\n    return tsl::Status(\n        tsl::error::INTERNAL,\n        absl::StrFormat(\n            \"failed initializing StreamExecutor for device ordinal %d: %s\",\n            config.ordinal, init_status.ToString().c_str()));\n  }\n\n  return std::move(executor);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  if (output->type == kTfLiteFloat32 || output->type == kTfLiteInt32) {\n    EvalDiv<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteUInt8) {\n    TF_LITE_ENSURE_OK(\n        context, EvalQuantized<kernel_type>(context, node, params, data, input1,\n                                            input2, output));\n  } else {\n    context->ReportError(\n        context,\n        \"Div only supports FLOAT32, INT32 and quantized UINT8 now, got %d.\",\n        output->type);\n    return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  // TODO(b/193904910): This can written with C++ templates\n#define TF_LITE_CHECK_DIV_NON_ZERO(data_type)                       \\\n  const auto* input2_data = GetTensorData<data_type>(input2);       \\\n  const size_t input2_elements = input2->bytes / sizeof(data_type); \\\n  for (size_t i = 0; i < input2_elements; i++) {                    \\\n    TF_LITE_ENSURE(context, input2_data[i] != 0);                   \\\n  }\n\n  if (output->type == kTfLiteFloat32) {\n    // Div by zero seems ok in this case, just like in TF case infinities are\n    // returned. So we don't do a check at this point.\n    EvalDiv<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteInt32) {\n    TF_LITE_CHECK_DIV_NON_ZERO(int32_t);\n    EvalDiv<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteUInt8) {\n    TF_LITE_CHECK_DIV_NON_ZERO(uint8_t);\n    TF_LITE_ENSURE_OK(\n        context, EvalQuantized<kernel_type>(context, node, params, data, input1,\n                                            input2, output));\n  } else {\n    context->ReportError(\n        context,\n        \"Div only supports FLOAT32, INT32 and quantized UINT8 now, got %d.\",\n        output->type);\n    return kTfLiteError;\n  }\n#undef TF_LITE_CHECK_DIV_NON_ZERO\n\n  return kTfLiteOk;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                     void *p_vrfy )\n{\n    size_t cn_len;\n    int ret;\n    int pathlen = 0, selfsigned = 0;\n    mbedtls_x509_crt *parent;\n    mbedtls_x509_name *name;\n    mbedtls_x509_sequence *cur = NULL;\n    mbedtls_pk_type_t pk_type;\n\n    if( profile == NULL )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    *flags = 0;\n\n    if( cn != NULL )\n    {\n        name = &crt->subject;\n        cn_len = strlen( cn );\n\n        if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )\n        {\n            cur = &crt->subject_alt_names;\n\n    {\n        if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n            break;\n    }\n\n    if( parent != NULL )\n    {\n        ret = x509_crt_verify_top( crt, parent, ca_crl, profile,\n                                   pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n        if( ret != 0 )\n            return( ret );\n    }\n    else\n    {\n        /* Look for a parent upwards the chain */\n        for( parent = crt->next; parent != NULL; parent = parent->next )\n            if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n                break;\n\n        /* Are we part of the chain or at the top? */\n        if( parent != NULL )\n        {\n            ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,\n                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n        {\n            ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,\n                                       pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n    }\n\n    if( *flags != 0 )\n        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n\n    return( 0 );\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "                     void *p_vrfy )\n{\n    size_t cn_len;\n    int ret;\n    int pathlen = 0, selfsigned = 0;\n    mbedtls_x509_crt *parent;\n    mbedtls_x509_name *name;\n    mbedtls_x509_sequence *cur = NULL;\n    mbedtls_pk_type_t pk_type;\n\n    *flags = 0;\n\n    if( profile == NULL )\n    {\n        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;\n        goto exit;\n    }\n\n    if( cn != NULL )\n    {\n        name = &crt->subject;\n        cn_len = strlen( cn );\n\n        if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )\n        {\n            cur = &crt->subject_alt_names;\n\n    {\n        if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n            break;\n    }\n\n    if( parent != NULL )\n    {\n        ret = x509_crt_verify_top( crt, parent, ca_crl, profile,\n                                   pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n        if( ret != 0 )\n            goto exit;\n    }\n    else\n    {\n        /* Look for a parent upwards the chain */\n        for( parent = crt->next; parent != NULL; parent = parent->next )\n            if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n                break;\n\n        /* Are we part of the chain or at the top? */\n        if( parent != NULL )\n        {\n            ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,\n                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                goto exit;\n        }\n        else\n        {\n            ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,\n                                       pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                goto exit;\n        }\n    }\n\nexit:\n    if( ret != 0 )\n    {\n        *flags = (uint32_t) -1;\n        return( ret );\n    }\n\n    if( *flags != 0 )\n        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n\n    return( 0 );\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "cdf_file_property_info(struct magic_set *ms, const cdf_property_info_t *info,\n    size_t count, const uint64_t clsid[2])\n{\n        size_t i;\n        cdf_timestamp_t tp;\n        struct timespec ts;\n        char buf[64];\n        const char *str = NULL;\n        const char *s;\n        int len;\n\n        if (!NOTMIME(ms))\n\t\tstr = cdf_clsid_to_mime(clsid, clsid2mime);\n\n        for (i = 0; i < count; i++) {\n                cdf_print_property_name(buf, sizeof(buf), info[i].pi_id);\n                switch (info[i].pi_type) {\n                case CDF_NULL:\n                        break;\n                case CDF_SIGNED16:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %hd\", buf,\n                            info[i].pi_s16) == -1)\n                                return -1;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "cdf_file_property_info(struct magic_set *ms, const cdf_property_info_t *info,\n    size_t count, const cdf_directory_t *root_storage)\n{\n        size_t i;\n        cdf_timestamp_t tp;\n        struct timespec ts;\n        char buf[64];\n        const char *str = NULL;\n        const char *s;\n        int len;\n\n        if (!NOTMIME(ms) && root_storage)\n\t\tstr = cdf_clsid_to_mime(root_storage->d_storage_uuid, clsid2mime);\n\n        for (i = 0; i < count; i++) {\n                cdf_print_property_name(buf, sizeof(buf), info[i].pi_id);\n                switch (info[i].pi_type) {\n                case CDF_NULL:\n                        break;\n                case CDF_SIGNED16:\n                        if (NOTMIME(ms) && file_printf(ms, \", %s: %hd\", buf,\n                            info[i].pi_s16) == -1)\n                                return -1;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\treturn 0;\n\t}\n\tcase FBIOPUTCMAP_SPARC: {\n\t\tstruct fbcmap __user *c = (struct fbcmap __user *) arg;\n\t\tstruct fb_cmap cmap;\n\t\tu16 red, green, blue;\n\t\tu8 red8, green8, blue8;\n\t\tunsigned char __user *ured;\n\t\tunsigned char __user *ugreen;\n\t\tunsigned char __user *ublue;\n\t\tint index, count, i;\n\n\t\tif (get_user(index, &c->index) ||\n\t\t    __get_user(count, &c->count) ||\n\t\t    __get_user(ured, &c->red) ||\n\t\t    __get_user(ugreen, &c->green) ||\n\t\t    __get_user(ublue, &c->blue))\n\t\t\treturn -EFAULT;\n\n\t\tcmap.len = 1;\n\t\tcmap.red = &red;\n\t\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\tcase FBIOGETCMAP_SPARC: {\n\t\tstruct fbcmap __user *c = (struct fbcmap __user *) arg;\n\t\tunsigned char __user *ured;\n\t\tunsigned char __user *ugreen;\n\t\tunsigned char __user *ublue;\n\t\tstruct fb_cmap *cmap = &info->cmap;\n\t\tint index, count, i;\n\t\tu8 red, green, blue;\n\n\t\tif (get_user(index, &c->index) ||\n\t\t    __get_user(count, &c->count) ||\n\t\t    __get_user(ured, &c->red) ||\n\t\t    __get_user(ugreen, &c->green) ||\n\t\t    __get_user(ublue, &c->blue))\n\t\t\treturn -EFAULT;\n\n\t\tif (index + count > cmap->len)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\treturn 0;\n\t}\n\tcase FBIOPUTCMAP_SPARC: {\n\t\tstruct fbcmap __user *c = (struct fbcmap __user *) arg;\n\t\tstruct fb_cmap cmap;\n\t\tu16 red, green, blue;\n\t\tu8 red8, green8, blue8;\n\t\tunsigned char __user *ured;\n\t\tunsigned char __user *ugreen;\n\t\tunsigned char __user *ublue;\n\t\tunsigned int index, count, i;\n\n\t\tif (get_user(index, &c->index) ||\n\t\t    __get_user(count, &c->count) ||\n\t\t    __get_user(ured, &c->red) ||\n\t\t    __get_user(ugreen, &c->green) ||\n\t\t    __get_user(ublue, &c->blue))\n\t\t\treturn -EFAULT;\n\n\t\tcmap.len = 1;\n\t\tcmap.red = &red;\n\t\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\tcase FBIOGETCMAP_SPARC: {\n\t\tstruct fbcmap __user *c = (struct fbcmap __user *) arg;\n\t\tunsigned char __user *ured;\n\t\tunsigned char __user *ugreen;\n\t\tunsigned char __user *ublue;\n\t\tstruct fb_cmap *cmap = &info->cmap;\n\t\tunsigned int index, count, i;\n\t\tu8 red, green, blue;\n\n\t\tif (get_user(index, &c->index) ||\n\t\t    __get_user(count, &c->count) ||\n\t\t    __get_user(ured, &c->red) ||\n\t\t    __get_user(ugreen, &c->green) ||\n\t\t    __get_user(ublue, &c->blue))\n\t\t\treturn -EFAULT;\n\n\t\tif (index + count > cmap->len)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void PDPClient::assignRemoteEndpoints(\n        ParticipantProxyData* pdata)\n{\n    {\n        eprosima::shared_lock<eprosima::shared_mutex> disc_lock(mp_builtin->getDiscoveryMutex());\n\n        // Verify if this participant is a server\n        for (auto& svr : mp_builtin->m_DiscoveryServers)\n        {\n            if (data_matches_with_prefix(svr.guidPrefix, *pdata))\n            {\n                std::unique_lock<std::recursive_mutex> lock(*getMutex());\n                svr.proxy = pdata;\n            }\n        }\n    }\n\n#if HAVE_SECURITY\n    if (mp_RTPSParticipant->security_manager().discovered_participant(*pdata))\n#endif // HAVE_SECURITY\n    {\n        perform_builtin_endpoints_matching(*pdata);\n    }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void PDPClient::assignRemoteEndpoints(\n        ParticipantProxyData* pdata)\n{\n    bool ignored = false;\n    notify_and_maybe_ignore_new_participant(pdata, ignored);\n    if (!ignored)\n    {\n        {\n            eprosima::shared_lock<eprosima::shared_mutex> disc_lock(mp_builtin->getDiscoveryMutex());\n\n            // Verify if this participant is a server\n            for (auto& svr : mp_builtin->m_DiscoveryServers)\n            {\n                if (data_matches_with_prefix(svr.guidPrefix, *pdata))\n                {\n                    std::unique_lock<std::recursive_mutex> lock(*getMutex());\n                    svr.proxy = pdata;\n                }\n            }\n        }\n\n#if HAVE_SECURITY\n        if (mp_RTPSParticipant->security_manager().discovered_participant(*pdata))\n#endif // HAVE_SECURITY\n        {\n            perform_builtin_endpoints_matching(*pdata);\n        }\n    }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void nego_process_negotiation_failure(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\tUINT32 failureCode;\n\tWLog_DBG(TAG, \"RDP_NEG_FAILURE\");\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, failureCode);\n\n\tswitch (failureCode)\n\t{\n\t\tcase SSL_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\n\t\tcase SSL_NOT_ALLOWED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_NOT_ALLOWED_BY_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\n\t\tcase SSL_CERT_NOT_ON_SERVER:\n\t\t\tWLog_ERR(TAG, \"Error: SSL_CERT_NOT_ON_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\n\t\tcase INCONSISTENT_FLAGS:\n\t\t\tWLog_ERR(TAG, \"Error: INCONSISTENT_FLAGS\");\n\t\t\tbreak;\n\n\t\tcase HYBRID_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: HYBRID_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Error: Unknown protocol security error %\" PRIu32 \"\", failureCode);\n\t\t\tbreak;\n\t}\n\n\tnego->state = NEGO_STATE_FAIL;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "BOOL nego_process_negotiation_failure(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\tUINT32 failureCode;\n\tWLog_DBG(TAG, \"RDP_NEG_FAILURE\");\n\tif (Stream_GetRemainingLength(s) < 7)\n\t\treturn FALSE;\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, failureCode);\n\n\tswitch (failureCode)\n\t{\n\t\tcase SSL_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\n\t\tcase SSL_NOT_ALLOWED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_NOT_ALLOWED_BY_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\n\t\tcase SSL_CERT_NOT_ON_SERVER:\n\t\t\tWLog_ERR(TAG, \"Error: SSL_CERT_NOT_ON_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\n\t\tcase INCONSISTENT_FLAGS:\n\t\t\tWLog_ERR(TAG, \"Error: INCONSISTENT_FLAGS\");\n\t\t\tbreak;\n\n\t\tcase HYBRID_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: HYBRID_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Error: Unknown protocol security error %\" PRIu32 \"\", failureCode);\n\t\t\tbreak;\n\t}\n\n\tnego->state = NEGO_STATE_FAIL;\n\treturn TRUE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int MSG_ReadBits( msg_t *msg, int bits ) {\n\tint\t\t\tvalue;\n\tint\t\t\tget;\n\tqboolean\tsgn;\n\tint\t\t\ti, nbits;\n//\tFILE*\tfp;\n\n\tvalue = 0;\n\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t\tsgn = qtrue;\n\t} else {\n\t\tsgn = qfalse;\n\t}\n\n\tif (msg->oob) {\n\t\tif(bits==8)\n\t\t{\n\t\t\tvalue = msg->data[msg->readcount];\n\t\t\tmsg->readcount += 1;\n\t\t\tmsg->bit += 8;\n\t\t}\n\t\telse if(bits==16)\n\t\t{\n\t\t\tshort temp;\n\t\t\t\n\t\t{\n\t\t\tCopyLittleLong(&value, &msg->data[msg->readcount]);\n\t\t\tmsg->readcount += 4;\n\t\t\tmsg->bit += 32;\n\t\t}\n\t\telse\n\t\t\tCom_Error(ERR_DROP, \"can't read %d bits\", bits);\n\t} else {\n\t\tnbits = 0;\n\t\tif (bits&7) {\n\t\t\tnbits = bits&7;\n\t\t\tfor(i=0;i<nbits;i++) {\n\t\t\t\tvalue |= (Huff_getBit(msg->data, &msg->bit)<<i);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif (bits) {\n//\t\t\tfp = fopen(\"c:\\\\netchan.bin\", \"a\");\n\t\t\tfor(i=0;i<bits;i+=8) {\n\t\t\t\tHuff_offsetReceive (msgHuff.decompressor.tree, &get, msg->data, &msg->bit);\n//\t\t\t\tfwrite(&get, 1, 1, fp);\n\t\t\t\tvalue |= (get<<(i+nbits));\n\t\t\t}\n//\t\t\tfclose(fp);\n\t\t}\n\t\tmsg->readcount = (msg->bit>>3)+1;\n\t}\n\tif ( sgn && bits > 0 && bits < 32 ) {\n\t\tif ( value & ( 1 << ( bits - 1 ) ) ) {\n\t\t\tvalue |= -1 ^ ( ( 1 << bits ) - 1 );\n\t\t}\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int MSG_ReadBits( msg_t *msg, int bits ) {\n\tint\t\t\tvalue;\n\tint\t\t\tget;\n\tqboolean\tsgn;\n\tint\t\t\ti, nbits;\n//\tFILE*\tfp;\n\n\tif ( msg->readcount > msg->cursize ) {\n\t\treturn 0;\n\t}\n\n\tvalue = 0;\n\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t\tsgn = qtrue;\n\t} else {\n\t\tsgn = qfalse;\n\t}\n\n\tif (msg->oob) {\n\t\tif (msg->readcount + (bits>>3) > msg->cursize) {\n\t\t\tmsg->readcount = msg->cursize + 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(bits==8)\n\t\t{\n\t\t\tvalue = msg->data[msg->readcount];\n\t\t\tmsg->readcount += 1;\n\t\t\tmsg->bit += 8;\n\t\t}\n\t\telse if(bits==16)\n\t\t{\n\t\t\tshort temp;\n\t\t\t\n\t\t\tCopyLittleLong(&value, &msg->data[msg->readcount]);\n\t\t\tmsg->readcount += 4;\n\t\t\tmsg->bit += 32;\n\t\t}\n\t\telse\n\t\t\tCom_Error(ERR_DROP, \"can't read %d bits\", bits);\n\t} else {\n\t\tnbits = 0;\n\t\tif (bits&7) {\n\t\t\tnbits = bits&7;\n\t\t\tif (msg->bit + nbits > msg->cursize << 3) {\n\t\t\t\tmsg->readcount = msg->cursize + 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor(i=0;i<nbits;i++) {\n\t\t\t\tvalue |= (Huff_getBit(msg->data, &msg->bit)<<i);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif (bits) {\n//\t\t\tfp = fopen(\"c:\\\\netchan.bin\", \"a\");\n\t\t\tfor(i=0;i<bits;i+=8) {\n\t\t\t\tHuff_offsetReceive (msgHuff.decompressor.tree, &get, msg->data, &msg->bit, msg->cursize<<3);\n//\t\t\t\tfwrite(&get, 1, 1, fp);\n\t\t\t\tvalue |= (get<<(i+nbits));\n\n\t\t\t\tif (msg->bit > msg->cursize<<3) {\n\t\t\t\t\tmsg->readcount = msg->cursize + 1;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfclose(fp);\n\t\t}\n\t\tmsg->readcount = (msg->bit>>3)+1;\n\t}\n\tif ( sgn && bits > 0 && bits < 32 ) {\n\t\tif ( value & ( 1 << ( bits - 1 ) ) ) {\n\t\t\tvalue |= -1 ^ ( ( 1 << bits ) - 1 );\n\t\t}\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)\n{\n\tstruct pipe_buffer *bufs;\n\tunsigned int head, tail, mask, n;\n\n\t/*\n\t * We can shrink the pipe, if arg is greater than the ring occupancy.\n\t * Since we don't expect a lot of shrink+grow operations, just free and\n\t * allocate again like we would do for growing.  If the pipe currently\n\t * contains more buffers than arg, then return busy.\n\t */\n\tmask = pipe->ring_size - 1;\n\thead = pipe->head;\n\ttail = pipe->tail;\n\tn = pipe_occupancy(pipe->head, pipe->tail);\n\tif (nr_slots < n)\n\t\treturn -EBUSY;\n\n\tbufs = kcalloc(nr_slots, sizeof(*bufs),\n\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * The pipe array wraps around, so just start the new one at zero\n\t * and adjust the indices.\n\t */\n\tif (n > 0) {\n\t\tunsigned int h = head & mask;\n\t\tunsigned int t = tail & mask;\n\t\tif (h > t) {\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\thead = n;\n\ttail = 0;\n\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->ring_size = nr_slots;\n\tif (pipe->max_usage > nr_slots)\n\t\tpipe->max_usage = nr_slots;\n\tpipe->tail = tail;\n\tpipe->head = head;\n\n\t/* This might have made more room for writers */\n\twake_up_interruptible(&pipe->wr_wait);\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)\n{\n\tstruct pipe_buffer *bufs;\n\tunsigned int head, tail, mask, n;\n\n\tbufs = kcalloc(nr_slots, sizeof(*bufs),\n\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&pipe->rd_wait.lock);\n\tmask = pipe->ring_size - 1;\n\thead = pipe->head;\n\ttail = pipe->tail;\n\n\tn = pipe_occupancy(head, tail);\n\tif (nr_slots < n) {\n\t\tspin_unlock_irq(&pipe->rd_wait.lock);\n\t\tkfree(bufs);\n\t\treturn -EBUSY;\n\t}\n\n\t/*\n\t * The pipe array wraps around, so just start the new one at zero\n\t * and adjust the indices.\n\t */\n\tif (n > 0) {\n\t\tunsigned int h = head & mask;\n\t\tunsigned int t = tail & mask;\n\t\tif (h > t) {\n\t\t\tmemcpy(bufs, pipe->bufs + t,\n\ttail = 0;\n\n\tkfree(pipe->bufs);\n\tpipe->bufs = bufs;\n\tpipe->ring_size = nr_slots;\n\tif (pipe->max_usage > nr_slots)\n\t\tpipe->max_usage = nr_slots;\n\tpipe->tail = tail;\n\tpipe->head = head;\n\n\tspin_unlock_irq(&pipe->rd_wait.lock);\n\n\t/* This might have made more room for writers */\n\twake_up_interruptible(&pipe->wr_wait);\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void perf_event_disable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct task_struct *task = ctx->task;\n\n\tif (!task) {\n\t\t/*\n\t\t * Disable the event on the cpu that it's on\n\t\t */\n\t\tcpu_function_call(event->cpu, __perf_event_disable, event);\n\t\treturn;\n\t}\n\nretry:\n\tif (!task_function_call(task, __perf_event_disable, event))\n\t\treturn;\n\n\traw_spin_lock_irq(&ctx->lock);\n\t/*\n\t * If the event is still active, we need to retry the cross-call.\n\t */\n\tif (event->state == PERF_EVENT_STATE_ACTIVE) {\n\t\traw_spin_unlock_irq(&ctx->lock);\n\t\t/*\n\t\t * Reload the task pointer, it might have been changed by\n\t\t * a concurrent perf_event_context_sched_out().\n\t\t */\n\t\ttask = ctx->task;\n\t\tgoto retry;\n\t}\n\n\t/*\n\t * Since we have the lock this context can't be scheduled\n\t * in, so we can change the state safely.\n\t */\n\tif (event->state == PERF_EVENT_STATE_INACTIVE) {\n\t\tupdate_group_times(event);\n\t\tevent->state = PERF_EVENT_STATE_OFF;\n\t}\n\traw_spin_unlock_irq(&ctx->lock);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void perf_event_disable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx;\n\n\tctx = perf_event_ctx_lock(event);\n\t_perf_event_disable(event);\n\tperf_event_ctx_unlock(event, ctx);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    }\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      unsigned char\n        pixel;\n\n      for (x=((ssize_t) number_pixels-3); x > 0; x-=4)\n      {\n        pixel=(unsigned char) *indexes++;\n        *q=((pixel & 0x01) << 7);\n        pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n          TransparentOpacity ? 1 : 0);\n        *q|=((pixel & 0x01) << 6);\n        p++;\n        pixel=(unsigned char) *indexes++;\n        *q|=((pixel & 0x01) << 5);\n        pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n          TransparentOpacity ? 1 : 0);\n        *q|=((pixel & 0x01) << 4);\n        p++;\n        pixel=(unsigned char) *indexes++;\n        *q|=((pixel & 0x01) << 3);\n        pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n          TransparentOpacity ? 1 : 0);\n        *q|=((pixel & 0x01) << 2);\n        p++;\n        pixel=(unsigned char) *indexes++;\n        *q|=((pixel & 0x01) << 1);\n        pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n          TransparentOpacity ? 1 : 0);\n        *q|=((pixel & 0x01) << 0);\n        p++;\n        q++;\n      }\n      if ((number_pixels % 4) != 0)\n        {\n          *q='\\0';\n          for (bit=3; bit >= (ssize_t) (4-(number_pixels % 4)); bit-=2)\n          {\n            pixel=(unsigned char) *indexes++;\n            *q|=((pixel & 0x01) << (unsigned char) (bit+4));\n            pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n              TransparentOpacity ? 1 : 0);\n            *q|=((pixel & 0x01) << (unsigned char) (bit+4-1));\n            p++;\n          }\n          q++;\n        }\n      break;\n    }\n    case 4:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels ; x++)\n      {\n        pixel=(unsigned char) *indexes++;\n        *q=((pixel & 0xf) << 4);\n        pixel=(unsigned char) (16*QuantumScale*((Quantum) (QuantumRange-\n          GetPixelOpacity(p)))+0.5);\n        *q|=((pixel & 0xf) << 0);\n        p++;\n        q++;\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopShortPixel(quantum_info->endian,(unsigned short) GetPixelIndex(indexes+x),q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelAlpha(p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p++;\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopShortPixel(quantum_info->endian,(unsigned short) GetPixelIndex(indexes+x),q);\n        pixel=ScaleQuantumToShort((Quantum) (QuantumRange-GetPixelOpacity(p)));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p++;\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n            q=PopFloatPixel(quantum_info,(float) GetPixelIndex(indexes+x),q);\n            pixel=(float)  (GetPixelAlpha(p));\n            q=PopFloatPixel(quantum_info,pixel,q);\n            p++;\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopLongPixel(quantum_info->endian,(unsigned int) GetPixelIndex(indexes+x),q);\n        pixel=ScaleQuantumToLong((Quantum) (QuantumRange-GetPixelOpacity(p)));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p++;\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        }\n    }\n    default:\n    {\n      QuantumAny\n        range;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,\n          GetPixelIndex(indexes+x),q);\n        q=PopQuantumPixel(quantum_info,\n          ScaleQuantumToAny((Quantum) (GetPixelAlpha(p)),range),q);\n        p++;\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    }\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      unsigned char\n        pixel;\n\n      for (x=((ssize_t) number_pixels-3); x > 0; x-=4)\n      {\n        pixel=(unsigned char) ((ssize_t) *indexes++);\n        *q=((pixel & 0x01) << 7);\n        pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n          TransparentOpacity ? 1 : 0);\n        *q|=((pixel & 0x01) << 6);\n        p++;\n        pixel=(unsigned char) ((ssize_t) *indexes++);\n        *q|=((pixel & 0x01) << 5);\n        pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n          TransparentOpacity ? 1 : 0);\n        *q|=((pixel & 0x01) << 4);\n        p++;\n        pixel=(unsigned char) ((ssize_t) *indexes++);\n        *q|=((pixel & 0x01) << 3);\n        pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n          TransparentOpacity ? 1 : 0);\n        *q|=((pixel & 0x01) << 2);\n        p++;\n        pixel=(unsigned char) ((ssize_t) *indexes++);\n        *q|=((pixel & 0x01) << 1);\n        pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n          TransparentOpacity ? 1 : 0);\n        *q|=((pixel & 0x01) << 0);\n        p++;\n        q++;\n      }\n      if ((number_pixels % 4) != 0)\n        {\n          *q='\\0';\n          for (bit=3; bit >= (ssize_t) (4-(number_pixels % 4)); bit-=2)\n          {\n            pixel=(unsigned char) ((ssize_t) *indexes++);\n            *q|=((pixel & 0x01) << (unsigned char) (bit+4));\n            pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n              TransparentOpacity ? 1 : 0);\n            *q|=((pixel & 0x01) << (unsigned char) (bit+4-1));\n            p++;\n          }\n          q++;\n        }\n      break;\n    }\n    case 4:\n    {\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels ; x++)\n      {\n        pixel=(unsigned char) ((ssize_t) *indexes++);\n        *q=((pixel & 0xf) << 4);\n        pixel=(unsigned char) ((ssize_t) (16*QuantumScale*((Quantum)\n          (QuantumRange-GetPixelOpacity(p)))+0.5));\n        *q|=((pixel & 0xf) << 0);\n        p++;\n        q++;\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopShortPixel(quantum_info->endian,(unsigned short)\n              ((ssize_t) GetPixelIndex(indexes+x)),q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelAlpha(p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p++;\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopShortPixel(quantum_info->endian,(unsigned short)\n          ((ssize_t) GetPixelIndex(indexes+x)),q);\n        pixel=ScaleQuantumToShort((Quantum) (QuantumRange-GetPixelOpacity(p)));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p++;\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n            q=PopFloatPixel(quantum_info,(float) GetPixelIndex(indexes+x),q);\n            pixel=(float)  (GetPixelAlpha(p));\n            q=PopFloatPixel(quantum_info,pixel,q);\n            p++;\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopLongPixel(quantum_info->endian,(unsigned int)\n          GetPixelIndex(indexes+x),q);\n        pixel=ScaleQuantumToLong((Quantum) (QuantumRange-GetPixelOpacity(p)));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p++;\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        }\n    }\n    default:\n    {\n      QuantumAny\n        range;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,GetPixelIndex(indexes+x),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny((Quantum)\n          (GetPixelAlpha(p)),range),q);\n        p++;\n        q+=quantum_info->pad;\n      }\n      break;\n    }\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "    GET_STATE(self);\n    Check_Type(array_nl, T_STRING);\n    len = RSTRING_LEN(array_nl);\n    if (len == 0) {\n        if (state->array_nl) {\n            ruby_xfree(state->array_nl);\n            state->array_nl = NULL;\n        }\n    } else {\n        if (state->array_nl) ruby_xfree(state->array_nl);\n        state->array_nl = strdup(RSTRING_PTR(array_nl));\n        state->array_nl_len = len;\n    }\n    return Qnil;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "    GET_STATE(self);\n    Check_Type(array_nl, T_STRING);\n    len = RSTRING_LEN(array_nl);\n    if (len == 0) {\n        if (state->array_nl) {\n            ruby_xfree(state->array_nl);\n            state->array_nl = NULL;\n        }\n    } else {\n        if (state->array_nl) ruby_xfree(state->array_nl);\n        state->array_nl = fstrndup(RSTRING_PTR(array_nl), len);\n        state->array_nl_len = len;\n    }\n    return Qnil;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "GlyphCache::GlyphCache(const Face & face, const uint32 face_options)\n: _glyph_loader(new Loader(face, bool(face_options & gr_face_dumbRendering))),\n  _glyphs(_glyph_loader && *_glyph_loader && _glyph_loader->num_glyphs()\n        ? grzeroalloc<const GlyphFace *>(_glyph_loader->num_glyphs()) : 0),\n  _boxes(_glyph_loader && _glyph_loader->has_boxes() && _glyph_loader->num_glyphs()\n        ? grzeroalloc<GlyphBox *>(_glyph_loader->num_glyphs()) : 0),\n  _num_glyphs(_glyphs ? _glyph_loader->num_glyphs() : 0),\n  _num_attrs(_glyphs ? _glyph_loader->num_attrs() : 0),\n  _upem(_glyphs ? _glyph_loader->units_per_em() : 0)\n{\n    if ((face_options & gr_face_preloadGlyphs) && _glyph_loader && _glyphs)\n    {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "GlyphCache::GlyphCache(const Face & face, const uint32 face_options)\n: _glyph_loader(new Loader(face)),\n  _glyphs(_glyph_loader && *_glyph_loader && _glyph_loader->num_glyphs()\n        ? grzeroalloc<const GlyphFace *>(_glyph_loader->num_glyphs()) : 0),\n  _boxes(_glyph_loader && _glyph_loader->has_boxes() && _glyph_loader->num_glyphs()\n        ? grzeroalloc<GlyphBox *>(_glyph_loader->num_glyphs()) : 0),\n  _num_glyphs(_glyphs ? _glyph_loader->num_glyphs() : 0),\n  _num_attrs(_glyphs ? _glyph_loader->num_attrs() : 0),\n  _upem(_glyphs ? _glyph_loader->units_per_em() : 0)\n{\n    if ((face_options & gr_face_preloadGlyphs) && _glyph_loader && _glyphs)\n    {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n\n\txb_ad(ctxt->pipe_ctxt != NULL);\n\tdest_ctxt = ctxt->pipe_ctxt;\n\n\tstream_ctxt = (ds_stream_ctxt_t *) ctxt->ptr;\n\n\tpthread_mutex_lock(&stream_ctxt->mutex);\n\tif (stream_ctxt->dest_file == NULL) {\n\t\tstream_ctxt->dest_file = ds_open(dest_ctxt, path, mystat);\n\t\tif (stream_ctxt->dest_file == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tpthread_mutex_unlock(&stream_ctxt->mutex);\n\n\tfile = (ds_file_t *) my_malloc(sizeof(ds_file_t) +\n\t\t\t\t       sizeof(ds_stream_file_t),\n\t\t\t\t       MYF(MY_FAE));\n\tstream_file = (ds_stream_file_t *) (file + 1);\n\n\txbstream = stream_ctxt->xbstream;\n\n\txbstream_file = xb_stream_write_open(xbstream, path, mystat,\n\t\t                             stream_ctxt,\n\t\t\t\t\t     my_xbstream_write_callback);\n\n\tif (xbstream_file == NULL) {\n\t\tmsg(\"xb_stream_write_open() failed.\");",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\txb_wstream_file_t\t*xbstream_file;\n\n\n\txb_ad(ctxt->pipe_ctxt != NULL);\n\tdest_ctxt = ctxt->pipe_ctxt;\n\n\tstream_ctxt = (ds_stream_ctxt_t *) ctxt->ptr;\n\n\tpthread_mutex_lock(&stream_ctxt->mutex);\n\tif (stream_ctxt->dest_file == NULL) {\n\t\tstream_ctxt->dest_file = ds_open(dest_ctxt, path, mystat);\n\t}\n\tpthread_mutex_unlock(&stream_ctxt->mutex);\n\tif (stream_ctxt->dest_file == NULL) {\n\t\treturn NULL;\n\t}\n\n\tfile = (ds_file_t *) my_malloc(sizeof(ds_file_t) +\n\t\t\t\t       sizeof(ds_stream_file_t),\n\t\t\t\t       MYF(MY_FAE));\n\tif (!file) {\n\t\tmsg(\"my_malloc() failed.\");\n\t\tgoto err;\n\t}\n\tstream_file = (ds_stream_file_t *) (file + 1);\n\n\txbstream = stream_ctxt->xbstream;\n\n\txbstream_file = xb_stream_write_open(xbstream, path, mystat,\n\t\t                             stream_ctxt,\n\t\t\t\t\t     my_xbstream_write_callback);\n\n\tif (xbstream_file == NULL) {\n\t\tmsg(\"xb_stream_write_open() failed.\");",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\t\tcontinue;\n\t\t}\n\n\t\tif ((cfi->fileCharacteristics & FID_FILE_CHAR_PARENT) &&\n\t\t    isdotdot)\n\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,\n\t\t\t\t\tUDF_NAME_LEN);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:\n\tfi = NULL;\n\tif (fibh->sbh != fibh->ebh)\n\t\tbrelse(fibh->ebh);\n\tbrelse(fibh->sbh);\nout_ok:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "unix_client_connect(hsm_com_client_hdl_t *hdl)\n{\n\tint\t\t\t\t\tfd, len;\n\tstruct sockaddr_un\tunix_addr;\n\n\tif ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) \n\t{\n\t\treturn HSM_COM_ERROR;\n\t}\n\n\tmemset(&unix_addr,0,sizeof(unix_addr));\n\n\tunix_addr.sun_family = AF_UNIX;\n\t\n\tif(strlen(hdl->c_path) >= sizeof(unix_addr.sun_path))\n\t{\n\t\tclose(fd);\n\t\treturn HSM_COM_PATH_ERR;\n\t}\n\n\tsnprintf(unix_addr.sun_path, sizeof(unix_addr.sun_path), \"%s\", hdl->c_path);\n\n\tlen = SUN_LEN(&unix_addr);\n\n\tunlink(unix_addr.sun_path);\n\n\tif(bind(fd, (struct sockaddr *)&unix_addr, len) < 0)\n\t{\n\t\tunlink(hdl->c_path);\n\t\tclose(fd);\n\n\t\treturn HSM_COM_BIND_ERR;\n\t}\n\n\tif(chmod(unix_addr.sun_path, S_IRWXU) < 0)\n\t{\n\t\tunlink(hdl->c_path);\n\t\tclose(fd);\n\t\treturn HSM_COM_CHMOD_ERR;\n\t}\n\n\tmemset(&unix_addr,0,sizeof(unix_addr));\n\n\tunix_addr.sun_family = AF_UNIX;\n\tstrncpy(unix_addr.sun_path, hdl->s_path, sizeof(unix_addr.sun_path));\n\tunix_addr.sun_path[sizeof(unix_addr.sun_path)-1] = 0;\n\n\tlen = SUN_LEN(&unix_addr);\n\n\tif (connect(fd, (struct sockaddr *) &unix_addr, len) < 0) \n\t{\n\t\tunlink(hdl->c_path);\n\t\tclose(fd);\n\t\treturn HSM_COM_CONX_ERR;\n\t}\n\n\thdl->client_fd = fd;\n\thdl->client_state = HSM_COM_C_STATE_CT;\n\n\t// Send connection data packet\n\tif(unix_sck_send_conn(hdl, 2) != HSM_COM_OK)\n\t{\n\t\thdl->client_state = HSM_COM_C_STATE_IN;\n\t\treturn HSM_COM_SEND_ERR;\n\t}\n\n\n\n\treturn HSM_COM_OK;\n\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "unix_client_connect(hsm_com_client_hdl_t *hdl)\n{\n\tint\t\t\t\t\tfd, len;\n\tstruct sockaddr_un\tunix_addr;\n\thsm_com_errno_t\t\tres = HSM_COM_OK;\n\n\tif ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) \n\t{\n\t\treturn HSM_COM_ERROR;\n\t}\n\n\tmemset(&unix_addr,0,sizeof(unix_addr));\n\n\tunix_addr.sun_family = AF_UNIX;\n\t\n\tif(strlen(hdl->c_path) >= sizeof(unix_addr.sun_path))\n\t{\n\t\tres = HSM_COM_PATH_ERR;\n\t\tgoto cleanup;\n\t}\n\n\tsnprintf(unix_addr.sun_path, sizeof(unix_addr.sun_path), \"%s\", hdl->c_path);\n\n\tlen = SUN_LEN(&unix_addr);\n\n\tunlink(unix_addr.sun_path);\n\n\tif(bind(fd, (struct sockaddr *)&unix_addr, len) < 0)\n\t{\n\t\tres = HSM_COM_BIND_ERR;\n\t\tgoto cleanup;\n\t}\n\n\tif(chmod(unix_addr.sun_path, S_IRWXU) < 0)\n\t{\n\t\tres = HSM_COM_CHMOD_ERR;\n\t\tgoto cleanup;\n\t}\n\n\tmemset(&unix_addr,0,sizeof(unix_addr));\n\n\tunix_addr.sun_family = AF_UNIX;\n\tstrncpy(unix_addr.sun_path, hdl->s_path, sizeof(unix_addr.sun_path));\n\tunix_addr.sun_path[sizeof(unix_addr.sun_path)-1] = 0;\n\n\tlen = SUN_LEN(&unix_addr);\n\n\tif (connect(fd, (struct sockaddr *) &unix_addr, len) < 0) \n\t{\n\t\tres = HSM_COM_CONX_ERR;\n\t\tgoto cleanup;\n\t}\n\n\thdl->client_fd = fd;\n\thdl->client_state = HSM_COM_C_STATE_CT;\n\n\t// Send connection data packet\n\tif(unix_sck_send_conn(hdl, 2) != HSM_COM_OK)\n\t{\n\t\thdl->client_state = HSM_COM_C_STATE_IN;\n\t\tres = HSM_COM_SEND_ERR;\n\t}\n\n\treturn res;\n\ncleanup:\n\tclose(fd);\n\treturn res;\n\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "did_set_shortmess(optset_T *args)\n{\n    char_u\t**varp = (char_u **)args->os_varp;\n\n    return did_set_option_listflag(*varp, (char_u *)SHM_ALL, args->os_errbuf);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "did_set_shortmess(optset_T *args)\n{\n    char_u\t**varp = (char_u **)args->os_varp;\n\n    return did_set_option_listflag(*varp, (char_u *)SHM_ALL, args->os_errbuf,\n\t\t    args->os_errbuflen);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "                separator = *data;\n                data++;\n                length--;\n            }\n            size_t j;\n            for (j = 0; j < MOBI_ATTRVALUE_MAXSIZE && length && *data != separator && *data != '>'; j++) {\n                *value++ = (char) *data++;\n                length--;\n            }\n            /* self closing tag '/>' */\n            if (*(data - 1) == '/' && *data == '>') {\n                value--;\n            }\n            *value = '\\0';\n            /* return offset to the beginning of the attribute value string */\n            return size - length - j;\n        }\n        data++;\n    } while (--length);\n    value[0] = '\\0';\n    return SIZE_MAX;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "                separator = *data;\n                data++;\n                length--;\n            }\n            size_t j;\n            for (j = 0; j < MOBI_ATTRVALUE_MAXSIZE && length && *data != separator && *data != '>'; j++) {\n                *value++ = (char) *data++;\n                length--;\n            }\n            /* self closing tag '/>' */\n            if (length && *(data - 1) == '/' && *data == '>') {\n                value--;\n            }\n            *value = '\\0';\n            /* return offset to the beginning of the attribute value string */\n            return size - length - j;\n        }\n        data++;\n    } while (--length);\n    value[0] = '\\0';\n    return SIZE_MAX;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int main(int argc, char **argv)\n{\n  test_cmp_parameters inParam;\n  FILE *fbase=NULL, *ftest=NULL;\n  int same = 0;\n  char lbase[256];\n  char strbase[256];\n  char ltest[256];\n  char strtest[256];\n\n  if( parse_cmdline_cmp(argc, argv, &inParam) == 1 )\n    {\n    compare_dump_files_help_display();\n    goto cleanup;\n    }\n\n  /* Display Parameters*/\n  printf(\"******Parameters********* \\n\");\n  printf(\" base_filename = %s\\n\"\n  /* open test file */\n  printf(\"Try to open: %s for reading ... \", inParam.test_filename);\n  if((ftest = fopen(inParam.test_filename, \"rb\"))==NULL)\n    {\n    goto cleanup;\n    }\n  printf(\"Ok.\\n\");\n\n  while (fgets(lbase, sizeof(lbase), fbase) && fgets(ltest,sizeof(ltest),ftest))\n    {\n    int nbase = sscanf(lbase, \"%255[^\\r\\n]\", strbase);\n    int ntest = sscanf(ltest, \"%255[^\\r\\n]\", strtest);\n    assert( nbase != 255 && ntest != 255 );\n    if( nbase != 1 || ntest != 1 )\n      {\n      fprintf(stderr, \"could not parse line from files\\n\" );\n      goto cleanup;\n      }\n    if( strcmp( strbase, strtest ) != 0 )\n      {\n      fprintf(stderr,\"<%s> vs. <%s>\\n\", strbase, strtest);\n      goto cleanup;\n      }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int main(int argc, char **argv)\n{\n  test_cmp_parameters inParam;\n  FILE *fbase=NULL, *ftest=NULL;\n  int same = 0;\n  char lbase[512];\n  char strbase[512];\n  char ltest[512];\n  char strtest[512];\n\n  if( parse_cmdline_cmp(argc, argv, &inParam) == 1 )\n    {\n    compare_dump_files_help_display();\n    goto cleanup;\n    }\n\n  /* Display Parameters*/\n  printf(\"******Parameters********* \\n\");\n  printf(\" base_filename = %s\\n\"\n  /* open test file */\n  printf(\"Try to open: %s for reading ... \", inParam.test_filename);\n  if((ftest = fopen(inParam.test_filename, \"rb\"))==NULL)\n    {\n    goto cleanup;\n    }\n  printf(\"Ok.\\n\");\n\n  while (fgets(lbase, sizeof(lbase), fbase) && fgets(ltest,sizeof(ltest),ftest))\n    {\n    int nbase = sscanf(lbase, \"%511[^\\r\\n]\", strbase);\n    int ntest = sscanf(ltest, \"%511[^\\r\\n]\", strtest);\n    assert( nbase != 511 && ntest != 511 );\n    if( nbase != 1 || ntest != 1 )\n      {\n      fprintf(stderr, \"could not parse line from files\\n\" );\n      goto cleanup;\n      }\n    if( strcmp( strbase, strtest ) != 0 )\n      {\n      fprintf(stderr,\"<%s> vs. <%s>\\n\", strbase, strtest);\n      goto cleanup;\n      }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "BOOL glyph_cache_put(rdpGlyphCache* glyphCache, UINT32 id, UINT32 index, rdpGlyph* glyph)\n{\n\trdpGlyph* prevGlyph;\n\n\tif (id > 9)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache id: %\" PRIu32 \"\", id);\n\t\treturn FALSE;\n\t}\n\n\tif (index > glyphCache->glyphCache[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index, id);\n\t\treturn FALSE;\n\t}\n\n\tWLog_Print(glyphCache->log, WLOG_DEBUG, \"GlyphCachePut: id: %\" PRIu32 \" index: %\" PRIu32 \"\", id,\n\t           index);\n\tprevGlyph = glyphCache->glyphCache[id].entries[index];\n\n\tif (prevGlyph)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "BOOL glyph_cache_put(rdpGlyphCache* glyphCache, UINT32 id, UINT32 index, rdpGlyph* glyph)\n{\n\trdpGlyph* prevGlyph;\n\n\tif (id > 9)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache id: %\" PRIu32 \"\", id);\n\t\treturn FALSE;\n\t}\n\n\tif (index >= glyphCache->glyphCache[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index, id);\n\t\treturn FALSE;\n\t}\n\n\tWLog_Print(glyphCache->log, WLOG_DEBUG, \"GlyphCachePut: id: %\" PRIu32 \" index: %\" PRIu32 \"\", id,\n\t           index);\n\tprevGlyph = glyphCache->glyphCache[id].entries[index];\n\n\tif (prevGlyph)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\t\t\tretval = posix_acl_valid(inode->i_sb->s_user_ns, acl);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t}\n\t} else\n\t\tacl = NULL;\n\n\tswitch (handler->flags) {\n\tcase ACL_TYPE_ACCESS:\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tretval = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto err_out;\n\t\t\telse {\n\t\t\t\tstruct iattr iattr;\n\t\t\t\tif (retval == 0) {\n\t\t\t\t\t/*\n\t\t\t\t\t * ACL can be represented\n\t\t\t\t\t * by the mode bits. So don't\n\t\t\t\t\t * update ACL.\n\t\t\t\t\t */\n\t\t\t\t\tacl = NULL;\n\t\t\t\t\tvalue = NULL;\n\t\t\t\t\tsize = 0;\n\t\t\t\t}\n\t\t\t\t/* Updte the mode bits */\n\t\t\t\tiattr.ia_mode = ((mode & S_IALLUGO) |\n\t\t\t\t\t\t (inode->i_mode & ~S_IALLUGO));\n\t\t\t\tiattr.ia_valid = ATTR_MODE;\n\t\t\t\t/* FIXME should we update ctime ?\n\t\t\t\t * What is the following setxattr update the\n\t\t\t\t * mode ?\n\t\t\t\t */\n\t\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tretval = acl ? -EINVAL : 0;\n\t\t\tgoto err_out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\t\t\tretval = posix_acl_valid(inode->i_sb->s_user_ns, acl);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t}\n\t} else\n\t\tacl = NULL;\n\n\tswitch (handler->flags) {\n\tcase ACL_TYPE_ACCESS:\n\t\tif (acl) {\n\t\t\tstruct iattr iattr;\n\n\t\t\tretval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t\tif (!acl) {\n\t\t\t\t/*\n\t\t\t\t * ACL can be represented\n\t\t\t\t * by the mode bits. So don't\n\t\t\t\t * update ACL.\n\t\t\t\t */\n\t\t\t\tvalue = NULL;\n\t\t\t\tsize = 0;\n\t\t\t}\n\t\t\tiattr.ia_valid = ATTR_MODE;\n\t\t\t/* FIXME should we update ctime ?\n\t\t\t * What is the following setxattr update the\n\t\t\t * mode ?\n\t\t\t */\n\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tretval = acl ? -EINVAL : 0;\n\t\t\tgoto err_out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tBUG();",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "int test_sqr(BIO *bp, BN_CTX *ctx)\n\t{\n\tBIGNUM a,c,d,e;\n\tint i;\n\n\tBN_init(&a);\n\tBN_init(&c);\n\tBN_init(&d);\n\tBN_init(&e);\n\n\tfor (i=0; i<num0; i++)\n\t\t{\n\t\tBN_bntest_rand(&a,40+i*10,0,0);\n\t\ta.neg=rand_neg();\n\t\tBN_sqr(&c,&a,ctx);\n\t\tif (bp != NULL)\n\t\t\t{\n\t\t\tif (!results)\n\t\t\t\t{\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" * \");\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" - \");\n\t\t\t\t}\n\t\t\tBN_print(bp,&c);\n\t\t\tBIO_puts(bp,\"\\n\");\n\t\t\t}\n\t\tBN_div(&d,&e,&c,&a,ctx);\n\t\tBN_sub(&d,&d,&a);\n\t\tif(!BN_is_zero(&d) || !BN_is_zero(&e))\n\t\t    {\n\t\t    fprintf(stderr,\"Square test failed!\\n\");\n\t\t    return 0;\n\t\t    }\n\t\t}\n\tBN_free(&a);\n\tBN_free(&c);\n\tBN_free(&d);\n\tBN_free(&e);\n\treturn(1);\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "int test_sqr(BIO *bp, BN_CTX *ctx)\n\t{\n\tBIGNUM *a,*c,*d,*e;\n\tint i, ret = 0;\n\n\ta = BN_new();\n\tc = BN_new();\n\td = BN_new();\n\te = BN_new();\n\tif (a == NULL || c == NULL || d == NULL || e == NULL)\n\t\t{\n\t\tgoto err;\n\t\t}\n\n\tfor (i=0; i<num0; i++)\n\t\t{\n\t\tBN_bntest_rand(a,40+i*10,0,0);\n\t\ta->neg=rand_neg();\n\t\tBN_sqr(c,a,ctx);\n\t\tif (bp != NULL)\n\t\t\t{\n\t\t\tif (!results)\n\t\t\t\t{\n\t\t\t\tBN_print(bp,a);\n\t\t\t\tBIO_puts(bp,\" * \");\n\t\t\t\tBN_print(bp,a);\n\t\t\t\tBIO_puts(bp,\" - \");\n\t\t\t\t}\n\t\t\tBN_print(bp,c);\n\t\t\tBIO_puts(bp,\"\\n\");\n\t\t\t}\n\t\tBN_div(d,e,c,a,ctx);\n\t\tBN_sub(d,d,a);\n\t\tif(!BN_is_zero(d) || !BN_is_zero(e))\n\t\t\t{\n\t\t\tfprintf(stderr,\"Square test failed!\\n\");\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t/* Regression test for a BN_sqr overflow bug. */\n\tBN_hex2bn(&a,\n\t\t\"80000000000000008000000000000001FFFFFFFFFFFFFFFE0000000000000000\");\n\tBN_sqr(c, a, ctx);\n\tif (bp != NULL)\n\t\t{\n\t\tif (!results)\n\t\t\t{\n\t\t\tBN_print(bp,a);\n\t\t\tBIO_puts(bp,\" * \");\n\t\t\tBN_print(bp,a);\n\t\t\tBIO_puts(bp,\" - \");\n\t\t\t}\n\t\tBN_print(bp,c);\n\t\tBIO_puts(bp,\"\\n\");\n\t\t}\n\tBN_mul(d, a, a, ctx);\n\tif (BN_cmp(c, d))\n\t\t{\n\t\tfprintf(stderr, \"Square test failed: BN_sqr and BN_mul produce \"\n\t\t\t\"different results!\\n\");\n\t\tgoto err;\n\t\t}\n\n\t/* Regression test for a BN_sqr overflow bug. */\n\tBN_hex2bn(&a,\n\t\t\"80000000000000000000000080000001FFFFFFFE000000000000000000000000\");\n\tBN_sqr(c, a, ctx);\n\tif (bp != NULL)\n\t\t{\n\t\tif (!results)\n\t\t\t{\n\t\t\tBN_print(bp,a);\n\t\t\tBIO_puts(bp,\" * \");\n\t\t\tBN_print(bp,a);\n\t\t\tBIO_puts(bp,\" - \");\n\t\t\t}\n\t\tBN_print(bp,c);\n\t\tBIO_puts(bp,\"\\n\");\n\t\t}\n\tBN_mul(d, a, a, ctx);\n\tif (BN_cmp(c, d))\n\t\t{\n\t\tfprintf(stderr, \"Square test failed: BN_sqr and BN_mul produce \"\n\t\t\t\"different results!\\n\");\n\t\tgoto err;\n\t\t}\n\tret = 1;\nerr:\n\tif (a != NULL) BN_free(a);\n\tif (c != NULL) BN_free(c);\n\tif (d != NULL) BN_free(d);\n\tif (e != NULL) BN_free(e);\n\treturn ret;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "{\n\tFILE *f;\n\tint ret;\n\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "{\n\tFILE *f;\n\tint ret;\n\n\tf = fopen(name, \"w\");\n\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (s && (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0)) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "cmdline_insert_reg(int *gotesc UNUSED)\n{\n    int\t\ti;\n    int\t\tc;\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t// disallow scrolling here\n#endif\n    putcmdline('\"', TRUE);\n    ++no_mapping;\n    ++allow_keys;\n    i = c = plain_vgetc();\t// CTRL-R <char>\n    if (i == Ctrl_O)\n\ti = Ctrl_R;\t\t// CTRL-R CTRL-O == CTRL-R CTRL-R\n    if (i == Ctrl_R)\n\tc = plain_vgetc();\t// CTRL-R CTRL-R <char>\n    extra_char = NUL;\n    --no_mapping;\n    --allow_keys;\n#ifdef FEAT_EVAL\n    /*\n     * Insert the result of an expression.\n     * Need to save the current command line, to be able to enter\n     * a new one...\n     */\n    new_cmdpos = -1;\n    if (c == '=')\n    {\n\tif (ccline.cmdfirstc == '='  // can't do this recursively\n\t\t|| cmdline_star > 0) // or when typing a password\n\t{\n\t    beep_flush();\n\t    c = ESC;\n\t}\n#ifdef FEAT_EVAL\n\tif (new_cmdpos >= 0)\n\t{\n\t    // set_cmdline_pos() was used\n\t    if (new_cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    else\n\t\tccline.cmdpos = new_cmdpos;\n\t}\n#endif\n    }\n    // remove the double quote\n    redrawcmd();\n\n    // The text has been stuffed, the command line didn't change yet.\n    return CMDLINE_NOT_CHANGED;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "cmdline_insert_reg(int *gotesc UNUSED)\n{\n    int\t\ti;\n    int\t\tc;\n    int\t\tsave_new_cmdpos = new_cmdpos;\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t// disallow scrolling here\n#endif\n    putcmdline('\"', TRUE);\n    ++no_mapping;\n    ++allow_keys;\n    i = c = plain_vgetc();\t// CTRL-R <char>\n    if (i == Ctrl_O)\n\ti = Ctrl_R;\t\t// CTRL-R CTRL-O == CTRL-R CTRL-R\n    if (i == Ctrl_R)\n\tc = plain_vgetc();\t// CTRL-R CTRL-R <char>\n    extra_char = NUL;\n    --no_mapping;\n    --allow_keys;\n#ifdef FEAT_EVAL\n    /*\n     * Insert the result of an expression.\n     */\n    new_cmdpos = -1;\n    if (c == '=')\n    {\n\tif (ccline.cmdfirstc == '='  // can't do this recursively\n\t\t|| cmdline_star > 0) // or when typing a password\n\t{\n\t    beep_flush();\n\t    c = ESC;\n\t}\n\tif (new_cmdpos >= 0)\n\t{\n\t    // set_cmdline_pos() was used\n\t    if (new_cmdpos > ccline.cmdlen)\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    else\n\t\tccline.cmdpos = new_cmdpos;\n\t}\n#endif\n    }\n    new_cmdpos = save_new_cmdpos;\n\n    // remove the double quote\n    redrawcmd();\n\n    // The text has been stuffed, the command line didn't change yet.\n    return CMDLINE_NOT_CHANGED;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "bool CPlayListASX::LoadData(std::istream& stream)\n{\n  CLog::Log(LOGINFO, \"Parsing ASX\");\n\n  if(stream.peek() == '[')\n  {\n    return LoadAsxIniInfo(stream);\n  }\n  else\n  {\n    CXBMCTinyXML xmlDoc;\n    stream >> xmlDoc;\n\n    if (xmlDoc.Error())\n    {\n      CLog::Log(LOGERROR, \"Unable to parse ASX info Error: {}\", xmlDoc.ErrorDesc());\n      return false;\n    }\n\n    TiXmlElement *pRootElement = xmlDoc.RootElement();\n\n    // lowercase every element\n    TiXmlNode *pNode = pRootElement;\n    TiXmlNode *pChild = NULL;\n    std::string value;\n    value = pNode->Value();\n    StringUtils::ToLower(value);\n    pNode->SetValue(value);\n    while(pNode)\n    {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "bool CPlayListASX::LoadData(std::istream& stream)\n{\n  CLog::Log(LOGINFO, \"Parsing ASX\");\n\n  if(stream.peek() == '[')\n  {\n    return LoadAsxIniInfo(stream);\n  }\n  else\n  {\n    std::string asxstream(std::istreambuf_iterator<char>(stream), {});\n    CXBMCTinyXML xmlDoc;\n    xmlDoc.Parse(asxstream, TIXML_DEFAULT_ENCODING);\n\n    if (xmlDoc.Error())\n    {\n      CLog::Log(LOGERROR, \"Unable to parse ASX info Error: {}\", xmlDoc.ErrorDesc());\n      return false;\n    }\n\n    TiXmlElement *pRootElement = xmlDoc.RootElement();\n\n    if (!pRootElement)\n      return false;\n\n    // lowercase every element\n    TiXmlNode *pNode = pRootElement;\n    TiXmlNode *pChild = NULL;\n    std::string value;\n    value = pNode->Value();\n    StringUtils::ToLower(value);\n    pNode->SetValue(value);\n    while(pNode)\n    {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "        functor::ScatterScalarFunctor<Device, T, Index, op> functor;\n        const Index bad_i = functor(c, c->template eigen_device<Device>(),\n                                    params_flat, update, indices_flat);\n        OP_REQUIRES(c, bad_i < 0,\n                    errors::InvalidArgument(\n                        \"indices\", SliceDebugString(indices.shape(), bad_i),\n                        \" = \", indices_flat(bad_i), \" is not in [0, \",\n                        params->dim_size(0), \")\"));\n      } else {\n        int64_t num_updates = updates.NumElements();\n        OP_REQUIRES(c, num_updates % N == 0,\n                    errors::InvalidArgument(\n                        \"shape of indices (\", indices.shape().DebugString(),\n                        \") is not compatible with the shape of updates (\",\n                        updates.shape().DebugString(), \")\"));\n        auto updates_flat = updates.shaped<T, 2>({N, num_updates / N});\n\n        functor::ScatterFunctor<Device, T, Index, op> functor;\n        const Index bad_i = functor(c, c->template eigen_device<Device>(),\n                                    params_flat, updates_flat, indices_flat);\n        OP_REQUIRES(c, bad_i < 0,\n                    errors::InvalidArgument(\n                        \"indices\", SliceDebugString(indices.shape(), bad_i),\n                        \" = \", indices_flat(bad_i), \" is not in [0, \",\n                        params->dim_size(0), \")\"));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "        functor::ScatterScalarFunctor<Device, T, Index, op> functor;\n        const Index bad_i = functor(c, c->template eigen_device<Device>(),\n                                    params_flat, update, indices_flat);\n        OP_REQUIRES(c, bad_i < 0,\n                    errors::InvalidArgument(\n                        \"indices\", SliceDebugString(indices.shape(), bad_i),\n                        \" = \", indices_flat(bad_i), \" is not in [0, \",\n                        params->dim_size(0), \")\"));\n      } else {\n        int64_t num_updates = updates.NumElements();\n        OP_REQUIRES(\n            c, TensorShapeUtils::StartsWith(updates.shape(), indices.shape()),\n            errors::InvalidArgument(\n                \"The shape of indices (\", indices.shape().DebugString(),\n                \") must be a prefix of the shape of updates (\",\n                updates.shape().DebugString(), \")\"));\n        auto updates_flat = updates.shaped<T, 2>({N, num_updates / N});\n\n        functor::ScatterFunctor<Device, T, Index, op> functor;\n        const Index bad_i = functor(c, c->template eigen_device<Device>(),\n                                    params_flat, updates_flat, indices_flat);\n        OP_REQUIRES(c, bad_i < 0,\n                    errors::InvalidArgument(\n                        \"indices\", SliceDebugString(indices.shape(), bad_i),\n                        \" = \", indices_flat(bad_i), \" is not in [0, \",\n                        params->dim_size(0), \")\"));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "\n        tsize_t\n          strip_size;\n\n        unsigned char\n          *strip_pixels;\n\n        /*\n          Convert stripped TIFF image.\n        */\n        extent=2*TIFFStripSize(tiff);\n#if defined(TIFF_VERSION_BIG)\n        extent+=image->columns*sizeof(uint64);\n#else\n        extent+=image->columns*sizeof(uint32);\n#endif\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "\n        tsize_t\n          strip_size;\n\n        unsigned char\n          *strip_pixels;\n\n        /*\n          Convert stripped TIFF image.\n        */\n        extent=4*TIFFStripSize(tiff);\n#if defined(TIFF_VERSION_BIG)\n        extent+=image->columns*sizeof(uint64);\n#else\n        extent+=image->columns*sizeof(uint32);\n#endif\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "void acpi_ns_terminate(void)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ns_terminate);\n\n#ifdef ACPI_EXEC_APP\n\t{\n\t\tunion acpi_operand_object *prev;\n\t\tunion acpi_operand_object *next;\n\n\t\t/* Delete any module-level code blocks */\n\n\t\tnext = acpi_gbl_module_code_list;\n\t\twhile (next) {\n\t\t\tprev = next;\n\t\t\tnext = next->method.mutex;\n\t\t\tprev->method.mutex = NULL;\t/* Clear the Mutex (cheated) field */\n\t\t\tacpi_ut_remove_reference(prev);\n\t\t}\n\t}\n#endif\n\n\t/*\n\t * Free the entire namespace -- all nodes and all objects\n\t * attached to the nodes\n\t */\n\tacpi_ns_delete_namespace_subtree(acpi_gbl_root_node);\n\n\t/* Delete any objects attached to the root node */\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "void acpi_ns_terminate(void)\n{\n\tacpi_status status;\n\tunion acpi_operand_object *prev;\n\tunion acpi_operand_object *next;\n\n\tACPI_FUNCTION_TRACE(ns_terminate);\n\n\t/* Delete any module-level code blocks */\n\n\tnext = acpi_gbl_module_code_list;\n\twhile (next) {\n\t\tprev = next;\n\t\tnext = next->method.mutex;\n\t\tprev->method.mutex = NULL;\t/* Clear the Mutex (cheated) field */\n\t\tacpi_ut_remove_reference(prev);\n\t}\n\n\t/*\n\t * Free the entire namespace -- all nodes and all objects\n\t * attached to the nodes\n\t */\n\tacpi_ns_delete_namespace_subtree(acpi_gbl_root_node);\n\n\t/* Delete any objects attached to the root node */\n\n\tstatus = acpi_ut_acquire_mutex(ACPI_MTX_NAMESPACE);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "                    sBuffer[ nCount ] = '\\0';\n                    for ( pCur = sBuffer; *pCur == ' ' || *pCur == '\\t'; ++pCur );\n                    if ( !strncmp( pCur, \"dup\", 3 ) )\n                    {\n                        for ( pCur += 3; *pCur == ' ' || *pCur == '\\t'; ++pCur ) ;\n                        for ( pTemp = pCur; *pTemp >= '0' && *pTemp <= '9'; ++pTemp ) ;\n                        if ( *pTemp )\n                        {\n                            char nChar = *pTemp;\n                            *pTemp = '\\0';\n                            nCode = atoi( pCur );\n                            *pTemp = nChar;\n                            if ( nCode == 8 && *pTemp == '#')\n                            {\n                                nCode = 0;\n                                for (++pTemp; *pTemp >= '0' && *pTemp <= '7'; ++pTemp)\n                                {\n                                    nCode = nCode * 8 + (*pTemp - '0');\n                                }\n                            }\n                            if ( nCode < 256 )\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    else if ( '/' == nChar  )\n                    {\n                        sToken.clear();\n                        sGlyph.clear();\n\n                        while ( ( nChar = sEexec[++nIndex] ) != ' ' )\n                            sGlyph.push_back( (wchar_t)nChar );\n                    }\n                }\n            }\n            MemUtilsFree( sEexecBuffer );\n\n            // \u041f\u0440\u043e\u0432\u0435\u0434\u0435\u043c \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0443 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 m_arrCharstrings \u043f\u043e \u044e\u043d\u0438\u043a\u043e\u0434\u043d\u043e\u043c\u0443 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e\n            qsort( m_arrCharstrings.GetData(), m_arrCharstrings.GetSize(), sizeof(Type1Glyph), CompareType1Glyph );\n        }\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "                    for ( pCur = sBuffer; *pCur == ' ' || *pCur == '\\t'; ++pCur );\n                    if ( !strncmp( pCur, \"dup\", 3 ) )\n                    {\n                        for ( pCur += 3; *pCur == ' ' || *pCur == '\\t'; ++pCur ) ;\n                        for ( pTemp = pCur; *pTemp >= '0' && *pTemp <= '9'; ++pTemp ) ;\n                        if ( *pTemp )\n                        {\n                            char nChar = *pTemp;\n                            *pTemp = '\\0';\n                            nCode = atoi( pCur );\n\t\t\t\t\t\t\tif (nCode < 0) nCode = 0;\t\t\t\t\t\t\t\t\n                            *pTemp = nChar;\n                            if ( nCode == 8 && *pTemp == '#')\n                            {\n                                nCode = 0;\n                                for (++pTemp; *pTemp >= '0' && *pTemp <= '7'; ++pTemp)\n                                {\n                                    nCode = nCode * 8 + (*pTemp - '0');\n                                }\n                            }\n                            if ( nCode < 256 )\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    else if ( '/' == nChar  )\n                    {\n                        sToken.clear();\n                        sGlyph.clear();\n\n                        while ( nIndex < nEexecLen && ( nChar = sEexec[++nIndex] ) != ' ' )\n                            sGlyph.push_back( (wchar_t)nChar );\n                    }\n                }\n            }\n            MemUtilsFree( sEexecBuffer );\n\n            // \u041f\u0440\u043e\u0432\u0435\u0434\u0435\u043c \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0443 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 m_arrCharstrings \u043f\u043e \u044e\u043d\u0438\u043a\u043e\u0434\u043d\u043e\u043c\u0443 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044e\n            qsort( m_arrCharstrings.GetData(), m_arrCharstrings.GetSize(), sizeof(Type1Glyph), CompareType1Glyph );\n        }\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  },
  {
    "input": "FstringParser_ConcatFstring(FstringParser *state, const char **str,\n                            const char *end, int raw, int recurse_lvl,\n                            struct compiling *c, const node *n)\n{\n    FstringParser_check_invariants(state);\n\n    /* Parse the f-string. */\n    while (1) {\n        PyObject *literal = NULL;\n        expr_ty expression = NULL;\n\n        /* If there's a zero length literal in front of the\n           expression, literal will be NULL. If we're at the end of\n           the f-string, expression will be NULL (unless result == 1,\n           see below). */\n        int result = fstring_find_literal_and_expr(str, end, raw, recurse_lvl,\n                                                   &literal, &expression,\n                                                   c, n);\n        if (result < 0)\n            return -1;\n\n        /* Add the literal, if any. */\n        if (!literal) {\n            /* Do nothing. Just leave last_str alone (and possibly\n               NULL). */\n        } else if (!state->last_str) {\n            state->last_str = literal;\n            literal = NULL;\n        } else {\n            /* We have a literal, concatenate it. */\n            assert(PyUnicode_GET_LENGTH(literal) != 0);\n            if (FstringParser_ConcatAndDel(state, literal) < 0)\n                return -1;\n            literal = NULL;\n        }\n        assert(!state->last_str ||\n               PyUnicode_GET_LENGTH(state->last_str) != 0);\n\n        /* We've dealt with the literal now. It can't be leaked on further\n           errors. */\n        assert(literal == NULL);\n\n        /* See if we should just loop around to get the next literal\n           and expression, while ignoring the expression this\n           time. This is used for un-doubling braces, as an\n           optimization. */\n        if (result == 1)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 2
  },
  {
    "input": "FstringParser_ConcatFstring(FstringParser *state, const char **str,\n                            const char *end, int raw, int recurse_lvl,\n                            struct compiling *c, const node *n)\n{\n    FstringParser_check_invariants(state);\n    state->fmode = 1;\n\n    /* Parse the f-string. */\n    while (1) {\n        PyObject *literal = NULL;\n        expr_ty expression = NULL;\n\n        /* If there's a zero length literal in front of the\n           expression, literal will be NULL. If we're at the end of\n           the f-string, expression will be NULL (unless result == 1,\n           see below). */\n                                                   &literal, &expression,\n                                                   c, n);\n        if (result < 0)\n            return -1;\n\n        /* Add the literal, if any. */\n        if (!literal) {\n            /* Do nothing. Just leave last_str alone (and possibly\n               NULL). */\n        } else if (!state->last_str) {\n            /*  Note that the literal can be zero length, if the\n                input string is \"\\\\\\n\" or \"\\\\\\r\", among others. */\n            state->last_str = literal;\n            literal = NULL;\n        } else {\n            /* We have a literal, concatenate it. */\n            assert(PyUnicode_GET_LENGTH(literal) != 0);\n            if (FstringParser_ConcatAndDel(state, literal) < 0)\n                return -1;\n            literal = NULL;\n        }\n\n        /* We've dealt with the literal now. It can't be leaked on further\n           errors. */\n        assert(literal == NULL);\n\n        /* See if we should just loop around to get the next literal\n           and expression, while ignoring the expression this\n           time. This is used for un-doubling braces, as an\n           optimization. */\n        if (result == 1)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 3
  }
]