[
  {
    "input": "\t\t\t\tmemcpy(&facilities->fail_call, p + 2, AX25_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_ADD) {\n\t\t\t\tmemcpy(&facilities->fail_addr, p + 3, ROSE_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_DIGIS) {\n\t\t\t\tfac_national_digis_received = 1;\n\t\t\t\tfacilities->source_ndigis = 0;\n\t\t\t\tfacilities->dest_ndigis   = 0;\n\t\t\t\tfor (pt = p + 2, lg = 0 ; lg < l ; pt += AX25_ADDR_LEN, lg += AX25_ADDR_LEN) {\n\t\t\t\t\tif (pt[6] & AX25_HBIT)\n\t\t\t\t\t\tmemcpy(&facilities->dest_digis[facilities->dest_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\telse\n\t\t\t\t\t\tmemcpy(&facilities->source_digis[facilities->source_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\tmemcpy(&facilities->fail_call, p + 2, AX25_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_ADD) {\n\t\t\t\tmemcpy(&facilities->fail_addr, p + 3, ROSE_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_DIGIS) {\n\t\t\t\tfac_national_digis_received = 1;\n\t\t\t\tfacilities->source_ndigis = 0;\n\t\t\t\tfacilities->dest_ndigis   = 0;\n\t\t\t\tfor (pt = p + 2, lg = 0 ; lg < l ; pt += AX25_ADDR_LEN, lg += AX25_ADDR_LEN) {\n\t\t\t\t\tif (pt[6] & AX25_HBIT) {\n\t\t\t\t\t\tif (facilities->dest_ndigis >= ROSE_MAX_DIGIS)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tmemcpy(&facilities->dest_digis[facilities->dest_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (facilities->source_ndigis >= ROSE_MAX_DIGIS)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tmemcpy(&facilities->source_digis[facilities->source_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  bytes_per_line=image->columns;\n  if (storage_class == DirectClass)\n    bytes_per_line*=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n  buffer=(unsigned char *) AcquireQuantumMemory(PictInfoSize,sizeof(*buffer));\n  packed_scanline=(unsigned char *) AcquireQuantumMemory((size_t)\n   (row_bytes+MaxCount),sizeof(*packed_scanline));\n  scanline=(unsigned char *) AcquireQuantumMemory(row_bytes,sizeof(*scanline));\n  if ((buffer == (unsigned char *) NULL) ||\n      (packed_scanline == (unsigned char *) NULL) ||\n      (scanline == (unsigned char *) NULL))\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(scanline,0,row_bytes);\n  (void) ResetMagickMemory(packed_scanline,0,(size_t) (row_bytes+MaxCount));\n  /*\n    Write header, header size, size bounding box, version, and reserved.\n  */\n  (void) ResetMagickMemory(buffer,0,PictInfoSize);\n  (void) WriteBlob(image,PictInfoSize,buffer);\n  (void) WriteBlobMSBShort(image,0);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.left);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  bytes_per_line=image->columns;\n  if (storage_class == DirectClass)\n    bytes_per_line*=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n  buffer=(unsigned char *) AcquireQuantumMemory(PictInfoSize,sizeof(*buffer));\n  packed_scanline=(unsigned char *) AcquireQuantumMemory((size_t)\n   (row_bytes+MaxCount),sizeof(*packed_scanline));\n  scanline=(unsigned char *) AcquireQuantumMemory(row_bytes,sizeof(*scanline));\n  if ((buffer == (unsigned char *) NULL) ||\n      (packed_scanline == (unsigned char *) NULL) ||\n      (scanline == (unsigned char *) NULL))\n    {\n      if (scanline != (unsigned char *) NULL)\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n      if (packed_scanline != (unsigned char *) NULL)\n        packed_scanline=(unsigned char *) RelinquishMagickMemory(\n          packed_scanline);\n      if (buffer != (unsigned char *) NULL)\n        buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  (void) ResetMagickMemory(scanline,0,row_bytes);\n  (void) ResetMagickMemory(packed_scanline,0,(size_t) (row_bytes+MaxCount));\n  /*\n    Write header, header size, size bounding box, version, and reserved.\n  */\n  (void) ResetMagickMemory(buffer,0,PictInfoSize);\n  (void) WriteBlob(image,PictInfoSize,buffer);\n  (void) WriteBlobMSBShort(image,0);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.left);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t/* Protocol layer */\n\tcase TIOCOUTQ: {\n\t\tlong amount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase TIOCINQ: {\n\t\t/*\n\t\t * These two are safe on a single CPU system as only\n\t\t * user tasks fiddle here\n\t\t */\n\t\tstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\n\t\tlong amount = 0;\n\n\t\tif (skb)\n\t\t\tamount = skb->len - sizeof(struct ddpehdr);\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\t/* Routing */\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\trc = -EPERM;\n\t\tif (capable(CAP_NET_ADMIN))\n\t\t\trc = atrtr_ioctl(cmd, argp);\n\t\tbreak;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t/* Protocol layer */\n\tcase TIOCOUTQ: {\n\t\tlong amount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tlong amount = 0;\n\n\t\tspin_lock_irq(&sk->sk_receive_queue.lock);\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb)\n\t\t\tamount = skb->len - sizeof(struct ddpehdr);\n\t\tspin_unlock_irq(&sk->sk_receive_queue.lock);\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\t/* Routing */\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\trc = -EPERM;\n\t\tif (capable(CAP_NET_ADMIN))\n\t\t\trc = atrtr_ioctl(cmd, argp);\n\t\tbreak;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "bool RequestParser::OnHeadersEnd() {\n  bool matched = view_matcher_(request_->method(), request_->url().path(),\n                               &stream_);\n\n  if (!matched) {\n    LOG_WARN(\"No view matches the request: %s %s\", request_->method().c_str(),\n             request_->url().path().c_str());\n  }\n\n  return matched;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "bool RequestParser::OnHeadersEnd() {\n  // Decode the URL path before match.\n  std::string url_path = Url::DecodeUnsafe(request_->url().path());\n  bool matched = view_matcher_(request_->method(), url_path, &stream_);\n  if (!matched) {\n    LOG_WARN(\"No view matches the request: %s %s\", request_->method().c_str(),\n             url_path.c_str());\n  }\n  return matched;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "snmp_engine_get_bulk(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t *varbinds_length)\n{\n  snmp_mib_resource_t *resource;\n  uint32_t i, j, original_varbinds_length;\n  uint32_t oid[SNMP_MAX_NR_VALUES][SNMP_MSG_OID_MAX_LEN];\n  uint8_t repeater;\n\n  /*\n   * A local copy of the requested oids must be kept since\n   *  the varbinds are modified on the fly\n   */\n  original_varbinds_length = *varbinds_length;\n  for(i = 0; i < original_varbinds_length; i++) {\n    snmp_oid_copy(oid[i], varbinds[i].oid);\n  }\n\n  *varbinds_length = 0;\n  for(i = 0; i < original_varbinds_length; i++) {\n    if(i >= header->error_status_non_repeaters.non_repeaters) {\n      break;\n    }\n\n    resource = snmp_mib_find_next(oid[i]);\n    if(!resource) {\n      switch(header->version) {\n      case SNMP_VERSION_1:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        /*\n         * Varbinds are 1 indexed\n         */\n        header->error_index_max_repetitions.error_index = i + 1;\n        break;\n      case SNMP_VERSION_2C:\n        (&varbinds[i])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;\n        break;\n      default:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = 0;\n      }\n    } else {\n      if(*varbinds_length < SNMP_MAX_NR_VALUES) {\n        resource->handler(&varbinds[*varbinds_length], resource->oid);\n        (*varbinds_length)++;\n      }\n    }\n  }\n\n  for(i = 0; i < header->error_index_max_repetitions.max_repetitions; i++) {\n    repeater = 0;\n    for(j = header->error_status_non_repeaters.non_repeaters; j < original_varbinds_length; j++) {\n      resource = snmp_mib_find_next(oid[j]);\n      if(!resource) {\n        switch(header->version) {\n        case SNMP_VERSION_1:\n          header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n          /*\n           * Varbinds are 1 indexed\n           */\n          header->error_index_max_repetitions.error_index = *varbinds_length + 1;\n          break;\n        case SNMP_VERSION_2C:\n          if(*varbinds_length < SNMP_MAX_NR_VALUES) {\n            (&varbinds[*varbinds_length])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;\n            snmp_oid_copy((&varbinds[*varbinds_length])->oid, oid[j]);\n            (*varbinds_length)++;\n          }\n          break;\n        default:\n          header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n          header->error_index_max_repetitions.error_index = 0;\n        }\n      } else {\n        if(*varbinds_length < SNMP_MAX_NR_VALUES) {\n          resource->handler(&varbinds[*varbinds_length], resource->oid);\n          (*varbinds_length)++;\n          snmp_oid_copy(oid[j], resource->oid);\n          repeater++;\n        }\n      }\n    }\n    if(repeater == 0) {\n      break;\n    }\n  }\n\n  return 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "snmp_engine_get_bulk(snmp_header_t *header, snmp_varbind_t *varbinds)\n{\n  snmp_mib_resource_t *resource;\n  snmp_oid_t oids[SNMP_MAX_NR_VALUES];\n  uint32_t j, original_varbinds_length;\n  uint8_t repeater;\n  uint8_t i, varbinds_length;\n\n  /*\n   * A local copy of the requested oids must be kept since\n   *  the varbinds are modified on the fly\n   */\n  original_varbinds_length = 0;\n  while(varbinds[original_varbinds_length].value_type != BER_DATA_TYPE_EOC && original_varbinds_length < SNMP_MAX_NR_VALUES) {\n    memcpy(&oids[original_varbinds_length], &varbinds[original_varbinds_length].oid, sizeof(snmp_oid_t));\n    original_varbinds_length++;\n  }\n\n  varbinds_length = 0;\n  for(i = 0; i < original_varbinds_length; i++) {\n    if(i >= header->non_repeaters) {\n      break;\n    }\n\n    resource = snmp_mib_find_next(&oids[i]);\n    if(!resource) {\n      switch(header->version) {\n      case SNMP_VERSION_1:\n        header->error_status = SNMP_STATUS_NO_SUCH_NAME;\n        /*\n         * Varbinds are 1 indexed\n         */\n        header->error_index = i + 1;\n        break;\n      case SNMP_VERSION_2C:\n        (&varbinds[i])->value_type = BER_DATA_TYPE_END_OF_MIB_VIEW;\n        break;\n      default:\n        header->error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index = 0;\n      }\n    } else {\n      if(varbinds_length < SNMP_MAX_NR_VALUES) {\n        resource->handler(&varbinds[varbinds_length], &resource->oid);\n        (varbinds_length)++;\n      } else {\n        return -1;\n      }\n    }\n  }\n\n  for(i = 0; i < header->max_repetitions; i++) {\n    repeater = 0;\n    for(j = header->non_repeaters; j < original_varbinds_length; j++) {\n      resource = snmp_mib_find_next(&oids[j]);\n      if(!resource) {\n        switch(header->version) {\n        case SNMP_VERSION_1:\n          header->error_status = SNMP_STATUS_NO_SUCH_NAME;\n          /*\n           * Varbinds are 1 indexed\n           */\n          header->error_index = varbinds_length + 1;\n          break;\n        case SNMP_VERSION_2C:\n          if(varbinds_length < SNMP_MAX_NR_VALUES) {\n            (&varbinds[varbinds_length])->value_type = BER_DATA_TYPE_END_OF_MIB_VIEW;\n            memcpy(&varbinds[varbinds_length].oid, &oids[j], sizeof(snmp_oid_t));\n            (varbinds_length)++;\n          } else {\n            return -1;\n          }\n          break;\n        default:\n          header->error_status = SNMP_STATUS_NO_SUCH_NAME;\n          header->error_index = 0;\n        }\n      } else {\n        if(varbinds_length < SNMP_MAX_NR_VALUES) {\n          resource->handler(&varbinds[varbinds_length], &resource->oid);\n          (varbinds_length)++;\n          memcpy(&oids[j], &resource->oid, sizeof(snmp_oid_t));\n          repeater++;\n        } else {\n          return -1;\n        }\n      }\n    }\n    if(repeater == 0) {\n      break;\n    }\n  }\n\n  return 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\n\treturn rv;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tif (_gdImageWebpCtx(im, out, -1)) {\n\t\trv = NULL;\n\t} else {\n\t\trv = gdDPExtractData(out, size);\n\t}\n\tout->gd_free(out);\n\n\treturn rv;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                while (data >= data_start && !isspace(*data) && *data != tag_open) {\n                    data--;\n                }\n                result->start = ++data;\n                /* now go forward */\n                int i = 0;\n                while (data <= data_end && !isspace(*data) && *data != tag_close && i < MOBI_ATTRVALUE_MAXSIZE) {\n                    result->value[i++] = (char) *data++;\n                }\n                /* self closing tag '/>' */\n                if (*(data - 1) == '/' && *data == '>') {\n                    --data; --i;\n                }\n                result->end = data;\n                result->value[i] = '\\0';\n                return MOBI_SUCCESS;\n            }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                while (data >= data_start && !isspace(*data) && *data != tag_open) {\n                    data--;\n                }\n                result->start = ++data;\n                /* now go forward */\n                int i = 0;\n                while (data <= data_end && !isspace(*data) && *data != tag_close && i < MOBI_ATTRVALUE_MAXSIZE) {\n                    result->value[i++] = (char) *data++;\n                }\n                /* self closing tag '/>' */\n                if (data <= data_end && *(data - 1) == '/' && *data == '>') {\n                    --data; --i;\n                }\n                result->end = data;\n                result->value[i] = '\\0';\n                return MOBI_SUCCESS;\n            }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tinode = d_backing_inode(path.dentry);\n\tret = inode_permission(inode, MAY_WRITE);\n\tif (ret)\n\t\tgoto out;\n\n\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\n\traw = bpf_any_get(inode->i_private, *type);\n\ttouch_atime(&path);\n\n\tpath_put(&path);\n\treturn raw;\nout:\n\tpath_put(&path);\n\treturn ERR_PTR(ret);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tinode = d_backing_inode(path.dentry);\n\tret = inode_permission(inode, MAY_WRITE);\n\tif (ret)\n\t\tgoto out;\n\n\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\n\traw = bpf_any_get(inode->i_private, *type);\n\tif (!IS_ERR(raw))\n\t\ttouch_atime(&path);\n\n\tpath_put(&path);\n\treturn raw;\nout:\n\tpath_put(&path);\n\treturn ERR_PTR(ret);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int sgi_clock_set(clockid_t clockid, struct timespec *tp)\n{\n\n\tu64 nsec;\n\tu64 rem;\n\n\tnsec = rtc_time() * sgi_clock_period;\n\n\tsgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n\n\tif (rem <= tp->tv_nsec)\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec - rem;\n\telse {\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;\n\t\tsgi_clock_offset.tv_sec--;\n\t}\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int sgi_clock_set(clockid_t clockid, struct timespec *tp)\n{\n\n\tu64 nsec;\n\tu32 rem;\n\n\tnsec = rtc_time() * sgi_clock_period;\n\n\tsgi_clock_offset.tv_sec = tp->tv_sec - div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\n\tif (rem <= tp->tv_nsec)\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec - rem;\n\telse {\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;\n\t\tsgi_clock_offset.tv_sec--;\n\t}\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int bn_ham(const bn_t a) {\n\tint c = 0;\n\n\tfor (int i = 0; i < bn_bits(a); i++) {\n\t\tc += bn_get_bit(a, i);\n\t}\n\n\treturn c;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "size_t bn_ham(const bn_t a) {\n\tint c = 0;\n\n\tfor (int i = 0; i < bn_bits(a); i++) {\n\t\tc += bn_get_bit(a, i);\n\t}\n\n\treturn c;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    else if(status<0){\n      VANESSA_LOGGER_DEBUG_UNSAFE(\"protocol->out_setup %d\", status);\n      VANESSA_LOGGER_ERR(\"Fatal error negotiating setup. Exiting child.\");\n      perdition_exit_cleanly(-1);\n    }\n\n#ifdef WITH_SSL_SUPPORT\n    else if((opt.ssl_mode & SSL_MODE_TLS_OUTGOING) &&\n          (status & PROTOCOL_S_STARTTLS)) {\n      server_io=perdition_ssl_client_connection(server_io, opt.ssl_ca_file, \n\t\t      opt.ssl_ca_path, opt.ssl_listen_ciphers, servername);\n      if(!server_io) {\n        VANESSA_LOGGER_DEBUG(\"perdition_ssl_connection outgoing\");\n        VANESSA_LOGGER_ERR(\"Fatal error establishing SSL connection\");\n        perdition_exit_cleanly(-1);\n      }\n      tls_state |= SSL_MODE_TLS_OUTGOING;\n    }\n    else if((opt.ssl_mode & SSL_MODE_TLS_OUTGOING) &&\n\t\t    (opt.ssl_mode & SSL_MODE_TLS_OUTGOING_FORCE) &&\n\t\t    !(status & PROTOCOL_S_STARTTLS)) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    else if(status<0){\n      VANESSA_LOGGER_DEBUG_UNSAFE(\"protocol->out_setup %d\", status);\n      VANESSA_LOGGER_ERR(\"Fatal error negotiating setup. Exiting child.\");\n      perdition_exit_cleanly(-1);\n    }\n\n#ifdef WITH_SSL_SUPPORT\n    else if((opt.ssl_mode & SSL_MODE_TLS_OUTGOING) &&\n          (status & PROTOCOL_S_STARTTLS)) {\n      server_io=perdition_ssl_client_connection(server_io, opt.ssl_ca_file, \n\t\t      opt.ssl_ca_path, opt.ssl_outgoing_ciphers, servername);\n      if(!server_io) {\n        VANESSA_LOGGER_DEBUG(\"perdition_ssl_connection outgoing\");\n        VANESSA_LOGGER_ERR(\"Fatal error establishing SSL connection\");\n        perdition_exit_cleanly(-1);\n      }\n      tls_state |= SSL_MODE_TLS_OUTGOING;\n    }\n    else if((opt.ssl_mode & SSL_MODE_TLS_OUTGOING) &&\n\t\t    (opt.ssl_mode & SSL_MODE_TLS_OUTGOING_FORCE) &&\n\t\t    !(status & PROTOCOL_S_STARTTLS)) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "htp_status_t htp_connp_REQ_PROTOCOL(htp_connp_t *connp) {\n    // Is this a short-style HTTP/0.9 request? If it is,\n    // we will not want to parse request headers.\n    if (connp->in_tx->is_protocol_0_9 == 0) {\n        // Switch to request header parsing.\n        connp->in_state = htp_connp_REQ_HEADERS;\n        connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n    } else {\n        // Let's check if the protocol was simply missing\n        int64_t pos = connp->in_current_read_offset;\n        int afterspaces = 0;\n        // Probe if data looks like a header line\n        while (pos < connp->in_current_len) {\n            if (connp->in_current_data[pos] == ':') {\n                htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Request line: missing protocol\");\n                connp->in_tx->is_protocol_0_9 = 0;\n                // Switch to request header parsing.\n                connp->in_state = htp_connp_REQ_HEADERS;\n                connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n                return HTP_OK;\n            } else if (htp_is_lws(connp->in_current_data[pos])) {\n                // Allows spaces after header name\n                afterspaces = 1;\n            } else if (htp_is_space(connp->in_current_data[pos]) || afterspaces == 1) {\n                break;\n            }\n            pos++;\n        }\n        // We're done with this request.\n        connp->in_state = htp_connp_REQ_FINALIZE;\n    }\n\n    return HTP_OK;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "htp_status_t htp_connp_REQ_PROTOCOL(htp_connp_t *connp) {\n    // Is this a short-style HTTP/0.9 request? If it is,\n    // we will not want to parse request headers.\n    if (connp->in_tx->is_protocol_0_9 == 0) {\n        // Switch to request header parsing.\n        connp->in_state = htp_connp_REQ_HEADERS;\n        connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n    } else {\n        // Let's check if the protocol was simply missing\n        int64_t pos = connp->in_current_read_offset;\n        // Probe if data looks like a header line\n        while (pos < connp->in_current_len) {\n            if (!htp_is_space(connp->in_current_data[pos])) {\n                htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Request line: missing protocol\");\n                connp->in_tx->is_protocol_0_9 = 0;\n                // Switch to request header parsing.\n                connp->in_state = htp_connp_REQ_HEADERS;\n                connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n                return HTP_OK;\n            }\n            pos++;\n        }\n        // We're done with this request.\n        connp->in_state = htp_connp_REQ_FINALIZE;\n    }\n\n    return HTP_OK;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t}\n\t\tfree += EXT2_XATTR_LEN(name_len);\n\t}\n\terror = -ENOSPC;\n\tif (free < EXT2_XATTR_LEN(name_len) + EXT2_XATTR_SIZE(value_len))\n\t\tgoto cleanup;\n\n\t/* Here we know that we can set the new attribute. */\n\n\tif (header) {\n\t\tstruct mb_cache_entry *ce;\n\n\t\t/* assert(header == HDR(bh)); */\n\t\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev,\n\t\t\t\t\tbh->b_blocknr);\n\t\tlock_buffer(bh);\n\t\tif (header->h_refcount == cpu_to_le32(1)) {\n\t\t\tea_bdebug(bh, \"modifying in-place\");\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\t/* keep the buffer locked while modifying it. */\n\t\t} else {\n\t\t\tint offset;\n\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\tunlock_buffer(bh);\n\t\t\tea_bdebug(bh, \"cloning\");\n\t\t\theader = kmalloc(bh->b_size, GFP_KERNEL);\n\t\t\terror = -ENOMEM;\n\t\t\tif (header == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(header, HDR(bh), bh->b_size);\n\t\t\theader->h_refcount = cpu_to_le32(1);\n\n\t\t\toffset = (char *)here - bh->b_data;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tfree += EXT2_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT2_XATTR_LEN(name_len);\n\t}\n\terror = -ENOSPC;\n\tif (free < EXT2_XATTR_LEN(name_len) + EXT2_XATTR_SIZE(value_len))\n\t\tgoto cleanup;\n\n\t/* Here we know that we can set the new attribute. */\n\n\tif (header) {\n\t\t/* assert(header == HDR(bh)); */\n\t\tlock_buffer(bh);\n\t\tif (header->h_refcount == cpu_to_le32(1)) {\n\t\t\t__u32 hash = le32_to_cpu(header->h_hash);\n\n\t\t\tea_bdebug(bh, \"modifying in-place\");\n\t\t\t/*\n\t\t\t * This must happen under buffer lock for\n\t\t\t * ext2_xattr_set2() to reliably detect modified block\n\t\t\t */\n\t\t\tmb2_cache_entry_delete_block(EXT2_SB(sb)->s_mb_cache,\n\t\t\t\t\t\t     hash, bh->b_blocknr);\n\n\t\t\t/* keep the buffer locked while modifying it. */\n\t\t} else {\n\t\t\tint offset;\n\n\t\t\tunlock_buffer(bh);\n\t\t\tea_bdebug(bh, \"cloning\");\n\t\t\theader = kmalloc(bh->b_size, GFP_KERNEL);\n\t\t\terror = -ENOMEM;\n\t\t\tif (header == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(header, HDR(bh), bh->b_size);\n\t\t\theader->h_refcount = cpu_to_le32(1);\n\n\t\t\toffset = (char *)here - bh->b_data;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "char *oidc_util_get_chunked_cookie(request_rec *r, const char *cookieName, int chunkSize) {\n\tchar *cookieValue = NULL;\n\tchar *chunkValue = NULL;\n\tint i = 0;\n\tif (chunkSize == 0) {\n\t\tcookieValue = oidc_util_get_cookie(r, cookieName);\n\t} else {\n\t\tint chunkCount = oidc_util_get_chunked_count(r, cookieName);\n\t\tif (chunkCount > 0) {\n\t\t\tcookieValue = \"\";\n\t\t\tfor (i = 0; i < chunkCount; i++) {\n\t\t\t\tchunkValue = oidc_util_get_cookie(r, oidc_util_get_chunk_cookie_name(r, cookieName, i));\n\t\t\t\tif (chunkValue != NULL)\n\t\t\t\t\tcookieValue = apr_psprintf(r->pool, \"%s%s\", cookieValue, chunkValue);\n\t\t\t}\n\t\t} else {\n\t\t\tcookieValue = oidc_util_get_cookie(r, cookieName);\n\t\t}\n\t}\n\treturn cookieValue;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "char *oidc_util_get_chunked_cookie(request_rec *r, const char *cookieName, int chunkSize) {\n\tchar *cookieValue = NULL, *chunkValue = NULL;\n\tint chunkCount = 0, i = 0;\n\tif (chunkSize == 0)\n\t\treturn oidc_util_get_cookie(r, cookieName);\n\tchunkCount = oidc_util_get_chunked_count(r, cookieName);\n\tif (chunkCount == 0)\n\t\treturn oidc_util_get_cookie(r, cookieName);\n\tif ((chunkCount < 0) || (chunkCount > 99)) {\n\t\toidc_warn(r, \"chunk count out of bounds: %d\", chunkCount);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < chunkCount; i++) {\n\t\tchunkValue = oidc_util_get_cookie(r, oidc_util_get_chunk_cookie_name(r, cookieName, i));\n\t\tif (chunkValue == NULL) {\n\t\t\toidc_warn(r, \"could not find chunk %d; aborting\", i);\n\t\t\tbreak;\n\t\t}\n\t\tcookieValue = apr_psprintf(r->pool, \"%s%s\", cookieValue ? cookieValue : \"\", chunkValue);\n\t}\n\treturn cookieValue;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        mutt_buffer_addstr(buf, \"HEADER \");\n\n        /* extract header name */\n        delim = strchr(pat->p.str, ':');\n        if (!delim)\n        {\n          mutt_error(_(\"Header search without header name: %s\"), pat->p.str);\n          return -1;\n        }\n        *delim = '\\0';\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        mutt_buffer_addch(buf, ' ');\n\n        /* and field */\n        *delim = ':';\n        delim++;\n        SKIPWS(delim);\n        imap_quote_string(term, sizeof(term), delim);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_BODY:\n        mutt_buffer_addstr(buf, \"BODY \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_WHOLE_MSG:\n        mutt_buffer_addstr(buf, \"TEXT \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_SERVERSEARCH:\n      {\n        struct ImapData *idata = ctx->data;\n        if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))\n        {\n          mutt_error(_(\"Server-side custom search not supported: %s\"), pat->p.str);\n          return -1;\n        }\n      }\n        mutt_buffer_addstr(buf, \"X-GM-RAW \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n    }\n  }\n\n  return 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        mutt_buffer_addstr(buf, \"HEADER \");\n\n        /* extract header name */\n        delim = strchr(pat->p.str, ':');\n        if (!delim)\n        {\n          mutt_error(_(\"Header search without header name: %s\"), pat->p.str);\n          return -1;\n        }\n        *delim = '\\0';\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        mutt_buffer_addch(buf, ' ');\n\n        /* and field */\n        *delim = ':';\n        delim++;\n        SKIPWS(delim);\n        imap_quote_string(term, sizeof(term), delim, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_BODY:\n        mutt_buffer_addstr(buf, \"BODY \");\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_WHOLE_MSG:\n        mutt_buffer_addstr(buf, \"TEXT \");\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_SERVERSEARCH:\n      {\n        struct ImapData *idata = ctx->data;\n        if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))\n        {\n          mutt_error(_(\"Server-side custom search not supported: %s\"), pat->p.str);\n          return -1;\n        }\n      }\n        mutt_buffer_addstr(buf, \"X-GM-RAW \");\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n    }\n  }\n\n  return 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct perf_event *event = file->private_data;\n\tvoid (*func)(struct perf_event *);\n\tu32 flags = arg;\n\n\tswitch (cmd) {\n\tcase PERF_EVENT_IOC_ENABLE:\n\t\tfunc = perf_event_enable;\n\t\tbreak;\n\tcase PERF_EVENT_IOC_DISABLE:\n\t\tfunc = perf_event_disable;\n\t\tbreak;\n\tcase PERF_EVENT_IOC_RESET:\n\t\tfunc = perf_event_reset;\n\t\tbreak;\n\n\tcase PERF_EVENT_IOC_REFRESH:\n\t\treturn perf_event_refresh(event, arg);\n\n\tcase PERF_EVENT_IOC_PERIOD:\n\t\treturn perf_event_period(event, (u64 __user *)arg);\n\n\tcase PERF_EVENT_IOC_ID:\n\t{\n\t\tu64 id = primary_event_id(event);\n\n\t\tif (copy_to_user((void __user *)arg, &id, sizeof(id)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase PERF_EVENT_IOC_SET_OUTPUT:\n\t{\n\t\tint ret;\n\t\tif (arg != -1) {\n\t\t\tstruct perf_event *output_event;\n\t\t\tstruct fd output;\n\t\t\tret = perf_fget_light(arg, &output);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\toutput_event = output.file->private_data;\n\t\t\tret = perf_event_set_output(event, output_event);\n\t\t\tfdput(output);\n\t\t} else {\n\t\t\tret = perf_event_set_output(event, NULL);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tcase PERF_EVENT_IOC_SET_FILTER:\n\t\treturn perf_event_set_filter(event, (void __user *)arg);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\tif (flags & PERF_IOC_FLAG_GROUP)\n\t\tperf_event_for_each(event, func);\n\telse\n\t\tperf_event_for_each_child(event, func);\n\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct perf_event *event = file->private_data;\n\tstruct perf_event_context *ctx;\n\tlong ret;\n\n\tctx = perf_event_ctx_lock(event);\n\tret = _perf_ioctl(event, cmd, arg);\n\tperf_event_ctx_unlock(event, ctx);\n\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,\n\tint offset, int len, int odd, struct sk_buff *skb),\n\tvoid *from, int length, int transhdrlen,\n\tint hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,\n\tstruct rt6_info *rt, unsigned int flags, int dontfrag)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_cork *cork;\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\tunsigned int maxfraglen, fragheaderlen;\n\tint exthdrlen;\n\tint dst_exthdrlen;\n\tint hh_len;\n\tint mtu;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\t__u8 tx_flags = 0;\n\n\tif (flags&MSG_PROBE)\n\t\treturn 0;\n\tcork = &inet->cork.base;\n\tif (skb_queue_empty(&sk->sk_write_queue)) {\n\t\t/*\n\t\t\tunsigned int alloclen;\nalloc_new_skb:\n\t\t\t/* There's no room in the current skb */\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t/* update mtu and maxfraglen if necessary */\n\t\t\tif (skb == NULL || skb_prev == NULL)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt);\n\n\t\t\tskb_prev = skb;\n\n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t */\n\t\t\tdatalen = length + fraggap;\n\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,\n\tint offset, int len, int odd, struct sk_buff *skb),\n\tvoid *from, int length, int transhdrlen,\n\tint hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,\n\tstruct rt6_info *rt, unsigned int flags, int dontfrag)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_cork *cork;\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\tunsigned int maxfraglen, fragheaderlen, mtu;\n\tint exthdrlen;\n\tint dst_exthdrlen;\n\tint hh_len;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\t__u8 tx_flags = 0;\n\n\tif (flags&MSG_PROBE)\n\t\treturn 0;\n\tcork = &inet->cork.base;\n\tif (skb_queue_empty(&sk->sk_write_queue)) {\n\t\t/*\n\t\t\tunsigned int alloclen;\nalloc_new_skb:\n\t\t\t/* There's no room in the current skb */\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t/* update mtu and maxfraglen if necessary */\n\t\t\tif (skb == NULL || skb_prev == NULL)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt,\n\t\t\t\t\t\t    np->pmtudisc ==\n\t\t\t\t\t\t    IPV6_PMTUDISC_PROBE);\n\n\t\t\tskb_prev = skb;\n\n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t */\n\t\t\tdatalen = length + fraggap;\n\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)\n{\n\tint i;\n\tint j;\n\n\tif (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=\n\t  mat1->numcols_) {\n\t\treturn 1;\n\t}\n\tfor (i = 0; i < mat0->numrows_; i++) {\n\t\tfor (j = 0; j < mat0->numcols_; j++) {\n\t\t\tif (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {\n\t\t\t\treturn 1;\n\t\t\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)\n{\n\tjas_matind_t i;\n\tjas_matind_t j;\n\n\tif (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=\n\t  mat1->numcols_) {\n\t\treturn 1;\n\t}\n\tfor (i = 0; i < mat0->numrows_; i++) {\n\t\tfor (j = 0; j < mat0->numcols_; j++) {\n\t\t\tif (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {\n\t\t\t\treturn 1;\n\t\t\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteStatus L2Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  switch (input->type) {  // Already know in/out types are same.\n    case kTfLiteFloat32:\n      L2EvalFloat<kernel_type>(context, node, params, data, input, output);\n      break;\n    case kTfLiteUInt8:\n    // We don't have a quantized implementation, so just fall through to the\n    // 'default' case.\n    default:\n      context->ReportError(context, \"Type %d not currently supported.\",\n                           input->type);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteStatus L2Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  switch (input->type) {  // Already know in/out types are same.\n    case kTfLiteFloat32:\n      L2EvalFloat<kernel_type>(context, node, params, data, input, output);\n      break;\n    case kTfLiteUInt8:\n    // We don't have a quantized implementation, so just fall through to the\n    // 'default' case.\n    default:\n      context->ReportError(context, \"Type %d not currently supported.\",\n                           input->type);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tuint32_t *payload = NULL; //buffer to store GPMF samples from the MP4.\n\n\n\t// get file return data\n\tif (argc != 2)\n\t{\n\t\tprintf(\"usage: %s <file_with_GPMF>\\n\", argv[0]);\n\t\treturn -1;\n\t}\n\n\tsize_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);\n//\tsize_t mp4 = OpenMP4SourceUDTA(argv[1]);  //Search for GPMF payload with MP4's udta \n\n\tmetadatalength = GetDuration(mp4);\n\n\tif (metadatalength > 0.0)\n\t{\n\t\tuint32_t index, payloads = GetNumberPayloads(mp4);\n//\t\tprintf(\"found %.2fs of metadata, from %d payloads, within %s\\n\", metadatalength, payloads, argv[1]);\n\n#if 1\n\t\t\tGPMF_ResetState(ms);\n\t\t\tprintf(\"\\n\");\n\n\t\t}\n#endif\n\n\n\t\tfor (index = 0; index < payloads; index++)\n\t\t{\n\t\t\tuint32_t payloadsize = GetPayloadSize(mp4, index);\n\t\t\tfloat in = 0.0, out = 0.0; //times\n\t\t\tpayload = GetPayload(mp4, payload, index);\n\t\t\tif (payload == NULL)\n\t\t\t\tgoto cleanup;\n\n\t\t\tret = GetPayloadTime(mp4, index, &in, &out);\n\t\t\tif (ret != GPMF_OK)\n\t\t\t\tgoto cleanup;\n\n\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n\t\t\tif (ret != GPMF_OK)\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n#endif \n\t\t}\n\n#if 1\n\t\t// Find all the available Streams and compute they sample rates\n\t\twhile (GPMF_OK == GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS))\n\t\t{\n\t\t\tif (GPMF_OK == GPMF_SeekToSamples(ms)) //find the last FOURCC within the stream\n\t\t\t{\n\t\t\t\tuint32_t fourcc = GPMF_Key(ms);\n\t\t\t\tdouble rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE);// GPMF_SAMPLE_RATE_FAST);\n\t\t\t\tprintf(\"%c%c%c%c sampling rate = %f Hz\\n\", PRINTF_4CC(fourcc), rate);\n\t\t\t}\n\t\t}\n#endif\n\n\n\tcleanup:\n\t\tif (payload) FreePayload(payload); payload = NULL;\n\t\tCloseSource(mp4);\n\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\n\t// get file return data\n\tif (argc != 2)\n\t{\n\t\tprintf(\"usage: %s <file_with_GPMF>\\n\", argv[0]);\n\t\treturn -1;\n\t}\n\n\tsize_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);\n\tif (mp4 == 0)\n\t{\n\t\tprintf(\"error: %s is an invalid MP4/MOV\\n\", argv[1]);\n\t\treturn -1;\n\t}\n\n//\tsize_t mp4 = OpenMP4SourceUDTA(argv[1]);  //Search for GPMF payload with MP4's udta \n\n\tmetadatalength = GetDuration(mp4);\n\n\tif (metadatalength > 0.0)\n\t{\n\t\tuint32_t index, payloads = GetNumberPayloads(mp4);\n//\t\tprintf(\"found %.2fs of metadata, from %d payloads, within %s\\n\", metadatalength, payloads, argv[1]);\n\n#if 1\n\t\t\tGPMF_ResetState(ms);\n\t\t\tprintf(\"\\n\");\n\n\t\t}\n#endif\n\n\n\t\tfor (index = 0; index < payloads; index++)\n\t\t{\n\t\t\tuint32_t payloadsize = GetPayloadSize(mp4, index);\n\t\t\tdouble in = 0.0, out = 0.0; //times\n\t\t\tpayload = GetPayload(mp4, payload, index);\n\t\t\tif (payload == NULL)\n\t\t\t\tgoto cleanup;\n\n\t\t\tret = GetPayloadTime(mp4, index, &in, &out);\n\t\t\tif (ret != GPMF_OK)\n\t\t\t\tgoto cleanup;\n\n\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n\t\t\tif (ret != GPMF_OK)\n\t\t\t}\n#endif \n\t\t}\n\n#if 1\n\t\t// Find all the available Streams and compute they sample rates\n\t\twhile (GPMF_OK == GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS))\n\t\t{\n\t\t\tif (GPMF_OK == GPMF_SeekToSamples(ms)) //find the last FOURCC within the stream\n\t\t\t{\n\t\t\t\tdouble in = 0.0, out = 0.0;\n\t\t\t\tuint32_t fourcc = GPMF_Key(ms);\n\t\t\t\tdouble rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE, &in, &out);// GPMF_SAMPLE_RATE_FAST);\n\t\t\t\tprintf(\"%c%c%c%c sampling rate = %f Hz (from %f to %f)\\n\", PRINTF_4CC(fourcc), rate, in, out);\n\t\t\t}\n\t\t}\n#endif\n\n\n\tcleanup:\n\t\tif (payload) FreePayload(payload); payload = NULL;\n\t\tCloseSource(mp4);\n\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int64_t OutputFile::readImpl(char* /*buffer*/, int64_t /*length*/) {\n  raise_warning(\"cannot read from a php://output stream\");\n  return -1;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int64_t OutputFile::readImpl(char* /*buffer*/, int64_t /*length*/) {\n  raise_warning(\"cannot read from a php://output stream\");\n  return 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_2_LE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_4_BE:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_BE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_4_LE:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_LE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_LENGTH_INCLUDES_ITSELF:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags |= PSTRING_LENGTH_INCLUDES_ITSELF;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\tbad:\n\t\t\t\t\tif (ms->flags & MAGIC_CHECK)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_2_LE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_4_BE:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_BE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_4_LE:\n\t\t\t\t\tswitch (m->type) {\n\t\t\t\t\tcase FILE_PSTRING:\n\t\t\t\t\tcase FILE_REGEX:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t}\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_LE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_LENGTH_INCLUDES_ITSELF:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags |= PSTRING_LENGTH_INCLUDES_ITSELF;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\tbad:\n\t\t\t\t\tif (ms->flags & MAGIC_CHECK)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\nprivate int\nmget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n    int flip, int recursion_level, int *printed_something,\n    int *need_separator, int *returnval)\n{\n\tuint32_t soffset, offset = ms->offset;\n\tuint32_t lhs;\n\tint rv, oneed_separator, in_type;\n\tchar *sbuf, *rbuf;\n\tunion VALUETYPE *p = &ms->ms_value;\n\tstruct mlist ml;\n\n\tif (recursion_level >= 20) {\n\t\tfile_error(ms, 0, \"recursion nesting exceeded\");\n\t\treturn -1;\n\t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t    (uint32_t)nbytes, m) == -1)\n\t\treturn -1;\n\n\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\tfprintf(stderr, \"mget(type=%d, flag=%x, offset=%u, o=%\"\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_REGEX:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\t\tif (offset == 0)\n\t\t\treturn 0;\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = ms->o.buf;\n\t\tsoffset = ms->offset;\n\t\tms->o.buf = NULL;\n\t\tms->offset = 0;\n\t\trv = file_softmagic(ms, s + offset, nbytes - offset,\n\t\t    recursion_level, BINTEST, text);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\tfprintf(stderr, \"indirect @offs=%u[%d]\\n\", offset, rv);\n\t\trbuf = ms->o.buf;\n\t\tms->o.buf = sbuf;\n\t\tms->offset = soffset;\n\t\tif (rv == 1) {\n\t\t\tif ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&\n\t\t\t    file_printf(ms, F(ms, m, \"%u\"), offset) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(rbuf);\n\t\treturn rv;\n\n\tcase FILE_USE:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = m->value.s;\n\t\tif (*sbuf == '^') {\n\t\t\tsbuf++;\n\t\t\tflip = !flip;\n\t\t}\n\t\tif (file_magicfind(ms, sbuf, &ml) == -1) {\n\t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", sbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\toneed_separator = *need_separator;\n\t\tif (m->flag & NOSPACE)\n\t\t\t*need_separator = 0;\n\t\trv = match(ms, ml.magic, ml.nmagic, s, nbytes, offset + o,\n\t\t    mode, text, flip, recursion_level, printed_something,\n\t\t    need_separator, returnval);\n\t\tif (rv != 1)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\nprivate int\nmget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n    int flip, int recursion_level, int *printed_something,\n    int *need_separator, int *returnval)\n{\n\tuint32_t offset = ms->offset;\n\tuint32_t lhs;\n\tfile_pushbuf_t *pb;\n\tint rv, oneed_separator, in_type;\n\tchar *rbuf;\n\tunion VALUETYPE *p = &ms->ms_value;\n\tstruct mlist ml;\n\n\tif (recursion_level >= MAX_RECURSION_LEVEL) {\n\t\tfile_error(ms, 0, \"recursion nesting exceeded\");\n\t\treturn -1;\n\t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t    (uint32_t)nbytes, m) == -1)\n\t\treturn -1;\n\n\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\tfprintf(stderr, \"mget(type=%d, flag=%x, offset=%u, o=%\"\n\t\tbreak;\n\n\tcase FILE_REGEX:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\t\tif (offset == 0)\n\t\t\treturn 0;\n\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\n\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\treturn -1;\n\n\t\trv = file_softmagic(ms, s + offset, nbytes - offset,\n\t\t    recursion_level, BINTEST, text);\n\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\tfprintf(stderr, \"indirect @offs=%u[%d]\\n\", offset, rv);\n\n\t\trbuf = file_pop_buffer(ms, pb);\n\t\tif (rbuf == NULL)\n\t\t\treturn -1;\n\n\t\tif (rv == 1) {\n\t\t\tif ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&\n\t\t\t    file_printf(ms, F(ms, m, \"%u\"), offset) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(rbuf);\n\t\treturn rv;\n\n\tcase FILE_USE:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\trbuf = m->value.s;\n\t\tif (*rbuf == '^') {\n\t\t\trbuf++;\n\t\t\tflip = !flip;\n\t\t}\n\t\tif (file_magicfind(ms, rbuf, &ml) == -1) {\n\t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", rbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\toneed_separator = *need_separator;\n\t\tif (m->flag & NOSPACE)\n\t\t\t*need_separator = 0;\n\t\trv = match(ms, ml.magic, ml.nmagic, s, nbytes, offset + o,\n\t\t    mode, text, flip, recursion_level, printed_something,\n\t\t    need_separator, returnval);\n\t\tif (rv != 1)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  void lazyCompile(Runtime &runtime) {\n    if (LLVM_UNLIKELY(isLazy())) {\n      lazyCompileImpl(runtime);\n    }\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  ExecutionStatus lazyCompile(Runtime &runtime) {\n    if (LLVM_UNLIKELY(isLazy())) {\n      return lazyCompileImpl(runtime);\n    }\n    return ExecutionStatus::RETURNED;\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n      // Points to the original or updated (if batch_dims is set) indices.\n      const Tensor* op_indices = &indices;\n      if (batch_dims_ > 0) {\n        OP_REQUIRES_OK(c, c->allocate_temp(indices.dtype(), indices.shape(),\n                                           &tmp_indices));\n        functor::DenseUpdate<Device, Index, ASSIGN> copy_functor;\n        copy_functor(c->eigen_device<Device>(), tmp_indices.flat<Index>(),\n                     indices.flat<Index>());\n\n        AddBatchOffsets(&tmp_indices, params);\n        op_indices = &tmp_indices;\n      }\n\n      int64_t gather_dim_size = 1;\n      for (int idx = 0; idx <= batch_dims_; ++idx) {\n        gather_dim_size *= params.dim_size(idx);\n      }\n      int64_t inner_size = 1;\n      for (int i = batch_dims_ + 1; i < params.dims(); ++i) {\n        inner_size *= params.dim_size(i);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n      // Points to the original or updated (if batch_dims is set) indices.\n      const Tensor* op_indices = &indices;\n      if (batch_dims_ > 0) {\n        OP_REQUIRES_OK(c, c->allocate_temp(indices.dtype(), indices.shape(),\n                                           &tmp_indices));\n        functor::DenseUpdate<Device, Index, ASSIGN> copy_functor;\n        copy_functor(c->eigen_device<Device>(), tmp_indices.flat<Index>(),\n                     indices.flat<Index>());\n\n        AddBatchOffsets(c, &tmp_indices, params);\n        if (!c->status().ok()) return;\n        op_indices = &tmp_indices;\n      }\n\n      int64_t gather_dim_size = 1;\n      for (int idx = 0; idx <= batch_dims_; ++idx) {\n        gather_dim_size *= params.dim_size(idx);\n      }\n      int64_t inner_size = 1;\n      for (int i = batch_dims_ + 1; i < params.dims(); ++i) {\n        inner_size *= params.dim_size(i);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "split_der(asn1buf *buf, uint8_t *const *der, size_t len, taginfo *tag_out)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n\n    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (rlen != 0)\n        return ASN1_BAD_LENGTH;\n    insert_bytes(buf, contents, clen);\n    return 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "split_der(asn1buf *buf, uint8_t *const *der, size_t len, taginfo *tag_out)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n\n    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen, 0);\n    if (ret)\n        return ret;\n    if (rlen != 0)\n        return ASN1_BAD_LENGTH;\n    insert_bytes(buf, contents, clen);\n    return 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "     ci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: URL requested: %s\\n\", httpinf.url);\n\n     /* Check the URL against SquidClamav Whitelist */\n     if (simple_pattern_compare(httpinf.url, WHITELIST) == 1) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (WHITELIST match) for url: %s\\n\", httpinf.url);\n\t   return CI_MOD_ALLOW204;\n     }\n\n     \n     /* Check URL header against squidGuard */\n     if (usepipe == 1) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Sending request to chained program: %s\\n\", squidguard);\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Request: %s %s %s %s\\n\", httpinf.url,clientip,username,httpinf.method);\n\tfprintf(sgfpw,\"%s %s %s %s\\n\",httpinf.url,clientip,username,httpinf.method);\n\tfflush(sgfpw);\n\t/* the chained redirector must return empty line if ok or the redirection url */\n\tchain_ret = (char *)malloc(sizeof(char)*MAX_URL_SIZE);\n\tif (chain_ret != NULL) {\n\t   ret = fgets(chain_ret,MAX_URL_SIZE,sgfpr);\n\t   if ((ret != NULL) && (strlen(chain_ret) > 1)) {\n\t\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: Chained program redirection received: %s\\n\", chain_ret);\n\t\tif (logredir)\n\t\t   ci_debug_printf(0, \"INFO Chained program redirection received: %s\\n\", chain_ret);\n\t\t/* Create the redirection url to squid */\n\t\tdata->blocked = 1;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n     /* Check the URL against SquidClamav Whitelist */\n     if (simple_pattern_compare(httpinf.url, WHITELIST) == 1) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (WHITELIST match) for url: %s\\n\", httpinf.url);\n\t   return CI_MOD_ALLOW204;\n     }\n\n     \n     /* Check URL header against squidGuard */\n     if (usepipe == 1) {\n\tchar *rbuff = NULL;\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Sending request to chained program: %s\\n\", squidguard);\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Request: %s %s %s %s\\n\", httpinf.url,clientip,username,httpinf.method);\n\t/* escaping escaped character to prevent unescaping by squidguard */\n\trbuff = replace(httpinf.url, \"%\", \"%25\");\n\tfprintf(sgfpw,\"%s %s %s %s\\n\",rbuff,clientip,username,httpinf.method);\n\tfflush(sgfpw);\n\txfree(rbuff);\n\t/* the chained redirector must return empty line if ok or the redirection url */\n\tchain_ret = (char *)malloc(sizeof(char)*MAX_URL_SIZE);\n\tif (chain_ret != NULL) {\n\t   ret = fgets(chain_ret,MAX_URL_SIZE,sgfpr);\n\t   if ((ret != NULL) && (strlen(chain_ret) > 1)) {\n\t\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: Chained program redirection received: %s\\n\", chain_ret);\n\t\tif (logredir)\n\t\t   ci_debug_printf(0, \"INFO Chained program redirection received: %s\\n\", chain_ret);\n\t\t/* Create the redirection url to squid */\n\t\tdata->blocked = 1;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int is_manager_apk(char *path)\n{\n\treturn check_v2_signature(path, ksu_expected_size, ksu_expected_hash);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "bool is_manager_apk(char *path)\n{\n\treturn check_v2_signature(path, ksu_expected_size, ksu_expected_hash);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "do_prefetch_tables (const void *gcmM, size_t gcmM_size)\n{\n  prefetch_table(gcmM, gcmM_size);\n  prefetch_table(gcmR, sizeof(gcmR));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "do_prefetch_tables (const void *gcmM, size_t gcmM_size)\n{\n  /* Modify counters to trigger copy-on-write and unsharing if physical pages\n   * of look-up table are shared between processes.  Modifying counters also\n   * causes checksums for pages to change and hint same-page merging algorithm\n   * that these pages are frequently changing.  */\n  gcm_table.counter_head++;\n  gcm_table.counter_tail++;\n\n  /* Prefetch look-up tables to cache.  */\n  prefetch_table(gcmM, gcmM_size);\n  prefetch_table(&gcm_table, sizeof(gcm_table));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "create_spnego_ctx(void)\n{\n\tspnego_gss_ctx_id_t spnego_ctx = NULL;\n\tspnego_ctx = (spnego_gss_ctx_id_t)\n\t\tmalloc(sizeof (spnego_gss_ctx_id_rec));\n\n\tif (spnego_ctx == NULL) {\n\t\treturn (NULL);\n\t}\n\n\tspnego_ctx->magic_num = SPNEGO_MAGIC_ID;\n\tspnego_ctx->mech_set = NULL;\n\tspnego_ctx->internal_mech = NULL;\n\tspnego_ctx->optionStr = NULL;\n\tspnego_ctx->DER_mechTypes.length = 0;\n\tspnego_ctx->DER_mechTypes.value = NULL;\n\tspnego_ctx->default_cred = GSS_C_NO_CREDENTIAL;\n\tspnego_ctx->mic_reqd = 0;\n\tspnego_ctx->mic_sent = 0;\n\tspnego_ctx->mic_rcvd = 0;\n\tspnego_ctx->mech_complete = 0;\n\tspnego_ctx->nego_done = 0;\n\tspnego_ctx->internal_name = GSS_C_NO_NAME;\n\tspnego_ctx->actual_mech = GSS_C_NO_OID;\n\n\tcheck_spnego_options(spnego_ctx);\n\n\treturn (spnego_ctx);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "create_spnego_ctx(int initiate)\n{\n\tspnego_gss_ctx_id_t spnego_ctx = NULL;\n\tspnego_ctx = (spnego_gss_ctx_id_t)\n\t\tmalloc(sizeof (spnego_gss_ctx_id_rec));\n\n\tif (spnego_ctx == NULL) {\n\t\treturn (NULL);\n\t}\n\n\tspnego_ctx->magic_num = SPNEGO_MAGIC_ID;\n\tspnego_ctx->internal_mech = NULL;\n\tspnego_ctx->optionStr = NULL;\n\tspnego_ctx->DER_mechTypes.length = 0;\n\tspnego_ctx->DER_mechTypes.value = NULL;\n\tspnego_ctx->default_cred = GSS_C_NO_CREDENTIAL;\n\tspnego_ctx->mic_reqd = 0;\n\tspnego_ctx->mic_sent = 0;\n\tspnego_ctx->mic_rcvd = 0;\n\tspnego_ctx->mech_complete = 0;\n\tspnego_ctx->nego_done = 0;\n\tspnego_ctx->opened = 0;\n\tspnego_ctx->initiate = initiate;\n\tspnego_ctx->internal_name = GSS_C_NO_NAME;\n\tspnego_ctx->actual_mech = GSS_C_NO_OID;\n\n\tcheck_spnego_options(spnego_ctx);\n\n\treturn (spnego_ctx);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "accept_xsmp_connection (SmsConn        sms_conn,\n                        GsmXsmpServer *server,\n                        unsigned long *mask_ret,\n                        SmsCallbacks  *callbacks_ret,\n                        char         **failure_reason_ret)\n{\n        IceConn        ice_conn;\n        GsmXSMPClient *client;\n\n        /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */\n        if (server->priv->xsmp_sockets == NULL) {\n                g_debug (\"GsmXsmpServer: In shutdown, rejecting new client\");\n\n                *failure_reason_ret = strdup (_(\"Refusing new client connection because the session is currently being shut down\\n\"));\n                return FALSE;\n        }\n\n        ice_conn = SmsGetIceConnection (sms_conn);\n        client = ice_conn->context;\n\n        g_return_val_if_fail (client != NULL, TRUE);\n\n        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n\n        return TRUE;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "accept_xsmp_connection (SmsConn        sms_conn,\n                        GsmXsmpServer *server,\n                        unsigned long *mask_ret,\n                        SmsCallbacks  *callbacks_ret,\n                        char         **failure_reason_ret)\n{\n        IceConn                ice_conn;\n        GsmClient             *client;\n        GsmIceConnectionWatch *data;\n\n        /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */\n        if (server->priv->xsmp_sockets == NULL) {\n                g_debug (\"GsmXsmpServer: In shutdown, rejecting new client\");\n\n                *failure_reason_ret = strdup (_(\"Refusing new client connection because the session is currently being shut down\\n\"));\n                return FALSE;\n        }\n\n        ice_conn = SmsGetIceConnection (sms_conn);\n        data = ice_conn->context;\n\n        /* Each GsmXSMPClient has its own IceConn watcher */\n        free_ice_connection_watch (data);\n\n        client = gsm_xsmp_client_new (ice_conn);\n\n        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n        /* the store will own the ref */\n        g_object_unref (client);\n\n        gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);\n\n        return TRUE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "file_extension(const char *s)\t/* I - Filename or URL */\n{\n  const char\t*extension;\t/* Pointer to directory separator */\n  static char\tbuf[1024];\t/* Buffer for files with targets */\n\n\n  if (s == NULL)\n    return (NULL);\n  else if (!strncmp(s, \"data:image/bmp;\", 15))\n    return (\"bmp\");\n  else if (!strncmp(s, \"data:image/gif;\", 15))\n    return (\"gif\");\n  else if (!strncmp(s, \"data:image/jpeg;\", 16))\n  if ((extension = strrchr(extension, '.')) == NULL)\n    return (\"\");\n  else\n    extension ++;\n\n  if (strchr(extension, '#') == NULL)\n    return (extension);\n\n  strlcpy(buf, extension, sizeof(buf));\n\n  *(char *)strchr(buf, '#') = '\\0';\n\n  return (buf);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "file_extension(const char *s)\t/* I - Filename or URL */\n{\n  const char\t*extension;\t/* Pointer to directory separator */\n  char\t\t*bufptr;\t/* Pointer into buffer */\n  static char\tbuf[1024];\t/* Buffer for files with targets */\n\n\n  if (s == NULL)\n    return (NULL);\n  else if (!strncmp(s, \"data:image/bmp;\", 15))\n    return (\"bmp\");\n  else if (!strncmp(s, \"data:image/gif;\", 15))\n    return (\"gif\");\n  else if (!strncmp(s, \"data:image/jpeg;\", 16))\n  if ((extension = strrchr(extension, '.')) == NULL)\n    return (\"\");\n  else\n    extension ++;\n\n  if (strchr(extension, '#') == NULL)\n    return (extension);\n\n  strlcpy(buf, extension, sizeof(buf));\n\n  if ((bufptr = strchr(buf, '#')) != NULL)\n    *bufptr = '\\0';\n\n  return (buf);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tevtchn_to_irq[row][col] = -1;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tWRITE_ONCE(evtchn_to_irq[row][col], -1);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t}\n\t}\n\tif (!found) {\n\t\tbtrfs_err(fs_info,\n\t\"dev extent physical offset %llu devid %llu has no corresponding chunk\",\n\t\t\tphysical_offset, devid);\n\t\tret = -EUCLEAN;\n\t}\n\n\t/* Make sure no dev extent is beyond device bondary */\n\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);\n\tif (!dev) {\n\t\tbtrfs_err(fs_info, \"failed to find devid %llu\", devid);\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\n\t/* It's possible this device is a dummy for seed device */\n\tif (dev->disk_total_bytes == 0) {\n\t\tdev = find_device(fs_info->fs_devices->seed, devid, NULL);\n\t\tif (!dev) {\n\t\t\tbtrfs_err(fs_info, \"failed to find seed devid %llu\",\n\t\t\t\t  devid);\n\t\t\tret = -EUCLEAN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (physical_offset + physical_len > dev->disk_total_bytes) {\n\t\tbtrfs_err(fs_info,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t}\n\t}\n\tif (!found) {\n\t\tbtrfs_err(fs_info,\n\t\"dev extent physical offset %llu devid %llu has no corresponding chunk\",\n\t\t\tphysical_offset, devid);\n\t\tret = -EUCLEAN;\n\t}\n\n\t/* Make sure no dev extent is beyond device bondary */\n\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true);\n\tif (!dev) {\n\t\tbtrfs_err(fs_info, \"failed to find devid %llu\", devid);\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\n\t/* It's possible this device is a dummy for seed device */\n\tif (dev->disk_total_bytes == 0) {\n\t\tdev = btrfs_find_device(fs_info->fs_devices->seed, devid, NULL,\n\t\t\t\t\tNULL, false);\n\t\tif (!dev) {\n\t\t\tbtrfs_err(fs_info, \"failed to find seed devid %llu\",\n\t\t\t\t  devid);\n\t\t\tret = -EUCLEAN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (physical_offset + physical_len > dev->disk_total_bytes) {\n\t\tbtrfs_err(fs_info,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "DH *get_dh2048(void)\n{\n    static unsigned char dhp_2048[] = {\n        0xD5, 0x75, 0xF1, 0x23, 0xC1, 0x81, 0x4B, 0x44, 0x23, 0xBE,\n        0x97, 0x81, 0x7A, 0xDA, 0x97, 0x1F, 0x1F, 0x0D, 0xD5, 0xEC,\n        0xC5, 0x5F, 0x86, 0x42, 0x7F, 0x38, 0xA3, 0x95, 0xEE, 0xA0,\n        0x52, 0x2C, 0xB7, 0x20, 0x29, 0xC1, 0xC7, 0xE6, 0x8E, 0x6F,\n        0xE5, 0xC1, 0x0D, 0xDD, 0x8A, 0xEF, 0x8D, 0xE7, 0xA8, 0x63,\n        0xB4, 0xF7, 0x58, 0x32, 0x0E, 0x24, 0xAC, 0x30, 0x94, 0xF5,\n        0xC7, 0x02, 0x81, 0x1B, 0xC7, 0x68, 0xE5, 0x71, 0xD7, 0x1E,\n        0x3D, 0xE4, 0x2E, 0x2F, 0xC0, 0x0A, 0xED, 0x34, 0xAC, 0xC0,\n        0x1F, 0x0A, 0x56, 0xA4, 0x12, 0x02, 0xFD, 0x68, 0xD2, 0x4D,\n        0x5E, 0x0A, 0x5D, 0x78, 0xE3, 0xA0, 0x85, 0x75, 0xD2, 0xA9,\n        0xC1, 0xF2, 0xAD, 0x65, 0x11, 0xDE, 0xE8, 0x05, 0x68, 0x36,\n        0x4C, 0x92, 0x99, 0x21, 0xB9, 0x69, 0xD0, 0x6F, 0xD8, 0xA3,\n        0xEA, 0x35, 0x13, 0x93, 0xDC, 0x1B, 0x13, 0x16, 0xB2, 0x15,\n        0x8E, 0x10, 0x22, 0xCE, 0x01, 0x1F, 0x1C, 0x09, 0x86, 0xD5,\n        0xE7, 0xCB, 0xCF, 0xFA, 0xED, 0x2F, 0xE2, 0x3A, 0x65, 0x14,\n        0xC9, 0xFA, 0x70, 0x99, 0xF7, 0xE0, 0x30, 0xBF, 0x7F, 0xEA,\n        0x84, 0x14, 0x8A, 0x51, 0xC9, 0xE9, 0x85, 0x73, 0x7F, 0xA1,\n        0xB0, 0xC3, 0x33, 0x9A, 0xAB, 0x69, 0x4E, 0x75, 0xFB, 0x12,\n        0xB0, 0x9E, 0xB1, 0xD9, 0xD1, 0xB9, 0x32, 0x1D, 0xC6, 0xD9,\n        0x2C, 0xAA, 0xB0, 0xC5, 0x3E, 0x69, 0x56, 0xA2, 0xB3, 0xA2,\n        0x81, 0xCA, 0x9D, 0x77, 0xBB, 0x52, 0x44, 0xA2, 0xED, 0xE0,\n        0xF0, 0x2A, 0x81, 0x85, 0x90, 0xB6, 0x04, 0x60, 0xEB, 0x09,\n        0x72, 0x08, 0x44, 0xAF, 0x28, 0xF5, 0x15, 0x34, 0x87, 0x5C,\n        0x8A, 0xB4, 0x5B, 0x15, 0x6A, 0xAD, 0x27, 0x4E, 0xA0, 0xDE,\n        0x99, 0x22, 0xCF, 0xAB, 0x4C, 0xFD, 0x75, 0x10, 0x5D, 0xFF,\n        0xE8, 0x81, 0x50, 0xC4, 0xC0, 0x4B\n    };\n    static unsigned char dhg_2048[] = {\n        0x02\n    };\n    DH *dh = DH_new();\n    BIGNUM *p, *g;\n\n    if (dh == NULL)\n        return NULL;\n    p = BN_bin2bn(dhp_2048, sizeof(dhp_2048), NULL);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "DH *get_dh2048(void)\n{\n    static unsigned char dhp_2048[] = {\n        0xCF, 0x9F, 0x3A, 0x9C, 0xC5, 0xA5, 0x89, 0x27, 0x6D, 0x2C,\n        0x2C, 0xF3, 0xA6, 0x00, 0xD2, 0x7C, 0xEA, 0xFA, 0xF2, 0x43,\n        0x4F, 0x49, 0x0A, 0xFC, 0xA6, 0xE7, 0x75, 0xCA, 0x07, 0xDC,\n        0xA5, 0xF2, 0x83, 0x4E, 0x5A, 0xA0, 0xA0, 0xF5, 0x9C, 0xFD,\n        0x02, 0xE6, 0x9E, 0xFC, 0x01, 0x59, 0xD7, 0xB6, 0xC1, 0x4E,\n        0xC0, 0xB6, 0x71, 0x49, 0xF0, 0xC7, 0xD5, 0x2F, 0x8D, 0xDF,\n        0xD3, 0xF1, 0x82, 0x82, 0x23, 0x33, 0x13, 0x93, 0xEB, 0x50,\n        0x29, 0xFD, 0x1B, 0x5A, 0x2F, 0xD5, 0x08, 0x99, 0x64, 0xE9,\n        0x7B, 0x1A, 0xDD, 0x68, 0x16, 0x08, 0xD0, 0x13, 0x82, 0xB6,\n        0x86, 0x62, 0x76, 0xAA, 0x16, 0x14, 0xCC, 0x86, 0x72, 0x26,\n        0x45, 0x8E, 0x2A, 0x82, 0x5B, 0x6F, 0xC1, 0xDF, 0xAA, 0x18,\n        0x43, 0xB8, 0xAD, 0x84, 0x52, 0xF2, 0xD9, 0x9C, 0xC0, 0x47,\n        0x52, 0x1B, 0x8E, 0x42, 0xC4, 0xD3, 0x61, 0x7B, 0x65, 0xA7,\n        0x69, 0x03, 0xB5, 0xD4, 0x6C, 0x83, 0x6A, 0x46, 0x73, 0xAF,\n        0x76, 0x77, 0x70, 0xC2, 0xD0, 0x74, 0xFE, 0x78, 0xF5, 0x75,\n        0x3B, 0xCE, 0xE2, 0xB6, 0xA0, 0x25, 0xE9, 0xE8, 0x4B, 0xA2,\n        0xF1, 0x20, 0x88, 0x13, 0x07, 0xED, 0x66, 0xBC, 0x46, 0xA1,\n        0xB3, 0x44, 0xAF, 0x2C, 0xED, 0x73, 0x75, 0x3D, 0x14, 0x6E,\n        0x43, 0x92, 0x40, 0x99, 0xB0, 0xD1, 0xBF, 0x2C, 0x4D, 0x0F,\n        0x2A, 0x63, 0xF4, 0x85, 0x7B, 0x1B, 0x0E, 0x48, 0x5A, 0x06,\n        0x02, 0xA6, 0x3D, 0x9E, 0x78, 0x05, 0xA8, 0x7C, 0xAD, 0x54,\n        0x49, 0xDE, 0x7A, 0xE6, 0x36, 0x5C, 0x50, 0xFC, 0x09, 0x81,\n        0x9E, 0x83, 0x53, 0x8C, 0x42, 0xEF, 0x12, 0x36, 0x4F, 0x22,\n        0x16, 0x2A, 0x15, 0x88, 0x83, 0xA9, 0x00, 0x66, 0x9E, 0xD1,\n        0xDC, 0x0F, 0x54, 0xC0, 0x32, 0x5C, 0x4C, 0x5E, 0xE2, 0x3D,\n        0xBC, 0x56, 0x89, 0x75, 0x28, 0xA3\n    };\n    static unsigned char dhg_2048[] = {\n        0x02\n    };\n    DH *dh = DH_new();\n    BIGNUM *p, *g;\n\n    if (dh == NULL)\n        return NULL;\n    p = BN_bin2bn(dhp_2048, sizeof(dhp_2048), NULL);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      int member_count = 0;\n      bool all_same = true;\n      if (me.second.m_has_this) {\n        bool any_multiple = false;\n        auto& fr = me.second.m_member_memos.begin()->second.m_return_value;\n        member_count = me.second.m_member_memos.size();\n        for (auto& mme : me.second.m_member_memos) {\n          if (mme.second.m_return_value != fr) all_same = false;\n          count += mme.second.m_count;\n          auto ser_len = mme.second.m_return_value.length();\n          min_ser_len = std::min(min_ser_len, ser_len);\n          max_ser_len = std::max(max_ser_len, ser_len);\n          if (mme.second.m_count > 1) any_multiple = true;\n        }\n        if (!any_multiple && !all_same) continue;\n      } else {\n        min_ser_len = max_ser_len = me.second.m_return_value.length();\n        count = me.second.m_count;\n        all_same = me.second.m_ret_tv_same;\n      }\n      fprintf(stderr, \"%d %s %d %d %s %s %s %d\\n\",\n              count, me.first.data(),",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      int member_count = 0;\n      bool all_same = true;\n      if (me.second.m_has_this) {\n        bool any_multiple = false;\n        auto& fr = me.second.m_member_memos.begin()->second.m_return_value;\n        member_count = me.second.m_member_memos.size();\n        for (auto& mme : me.second.m_member_memos) {\n          if (mme.second.m_return_value != fr) all_same = false;\n          count += mme.second.m_count;\n          auto ser_len = mme.second.m_return_value.length();\n          min_ser_len = std::min<int64_t>(min_ser_len, ser_len);\n          max_ser_len = std::max<int64_t>(max_ser_len, ser_len);\n          if (mme.second.m_count > 1) any_multiple = true;\n        }\n        if (!any_multiple && !all_same) continue;\n      } else {\n        min_ser_len = max_ser_len = me.second.m_return_value.length();\n        count = me.second.m_count;\n        all_same = me.second.m_ret_tv_same;\n      }\n      fprintf(stderr, \"%d %s %d %d %s %s %s %d\\n\",\n              count, me.first.data(),",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\treturn false;\n\t}\n\tif (header.fixups_version > 0) {\n\t\teprintf (\"Unsupported fixups version: %u\\n\", header.fixups_version);\n\t\treturn false;\n\t}\n\tut64 starts_at = offset + header.starts_offset;\n\tif (header.starts_offset > size) {\n\t\treturn false;\n\t}\n\tut32 segs_count;\n\tif ((segs_count = r_buf_read_le32_at (bin->b, starts_at)) == UT32_MAX) {\n\t\treturn false;\n\t}\n\tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, segs_count);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tbin->fixups_header = header;\n\tbin->fixups_offset = offset;\n\tbin->fixups_size = size;\n\tsize_t i;\n\tut64 cursor = starts_at + sizeof (ut32);\n\tut64 bsize = r_buf_size (bin->b);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\treturn false;\n\t}\n\tif (header.fixups_version > 0) {\n\t\teprintf (\"Unsupported fixups version: %u\\n\", header.fixups_version);\n\t\treturn false;\n\t}\n\tut64 starts_at = offset + header.starts_offset;\n\tif (header.starts_offset > size) {\n\t\treturn false;\n\t}\n\tut32 segs_count = r_buf_read_le32_at (bin->b, starts_at);\n\tif (segs_count == UT32_MAX || segs_count == 0) {\n\t\treturn false;\n\t}\n\tbin->segs_count = segs_count;\n\tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, segs_count);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tbin->fixups_header = header;\n\tbin->fixups_offset = offset;\n\tbin->fixups_size = size;\n\tsize_t i;\n\tut64 cursor = starts_at + sizeof (ut32);\n\tut64 bsize = r_buf_size (bin->b);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void big_key_describe(const struct key *key, struct seq_file *m)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\n\tseq_puts(m, key->description);\n\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %zu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void big_key_describe(const struct key *key, struct seq_file *m)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\n\tseq_puts(m, key->description);\n\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \": %zu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "init_ctx_new(OM_uint32 *minor_status,\n\t     spnego_gss_cred_id_t spcred,\n\t     gss_ctx_id_t *ctx,\n\t     send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\tsc = create_spnego_ctx();\n\tif (sc == NULL)\n\t\treturn GSS_S_FAILURE;\n\n\t/* determine negotiation mech set */\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,\n\t\t\t\t   &sc->mech_set);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\t/* Set an initial internal mech to make the first context token. */\n\tsc->internal_mech = &sc->mech_set->elements[0];\n\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\t/*\n\t * The actual context is not yet determined, set the output\n\t * context handle to refer to the spnego context itself.\n\t */\n\tsc->ctx_handle = GSS_C_NO_CONTEXT;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\t*tokflag = INIT_TOKEN_SEND;\n\tret = GSS_S_CONTINUE_NEEDED;\n\ncleanup:\n\trelease_spnego_ctx(&sc);\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "init_ctx_new(OM_uint32 *minor_status,\n\t     spnego_gss_cred_id_t spcred,\n\t     gss_ctx_id_t *ctx,\n\t     send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\tsc = create_spnego_ctx(1);\n\tif (sc == NULL)\n\t\treturn GSS_S_FAILURE;\n\n\t/* determine negotiation mech set */\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,\n\t\t\t\t   &sc->mech_set);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\t/* Set an initial internal mech to make the first context token. */\n\tsc->internal_mech = &sc->mech_set->elements[0];\n\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\n\tsc->ctx_handle = GSS_C_NO_CONTEXT;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\t*tokflag = INIT_TOKEN_SEND;\n\tret = GSS_S_CONTINUE_NEEDED;\n\ncleanup:\n\trelease_spnego_ctx(&sc);\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\n\t\t/*\n\t\t * Get a reference to this pipe buffer,\n\t\t * so we can copy the contents over.\n\t\t */\n\t\tpipe_buf_get(ipipe, ibuf);\n\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\n\t\t/*\n\t\t * Don't inherit the gift flag, we need to\n\t\t * prevent multiple steals of this page.\n\t\t */\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\n\t\t/*\n\t\t * Get a reference to this pipe buffer,\n\t\t * so we can copy the contents over.\n\t\t */\n\t\tif (!pipe_buf_get(ipipe, ibuf)) {\n\t\t\tif (ret == 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\n\t\t/*\n\t\t * Don't inherit the gift flag, we need to\n\t\t * prevent multiple steals of this page.\n\t\t */\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int jpg_dec_parseopts(char *optstr, jpg_dec_importopts_t *opts)\n{\n\tjas_tvparser_t *tvp;\n\n\topts->max_size = 0;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\treturn -1;\n\t}\n\n\twhile (!jas_tvparser_next(tvp)) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_MAXSIZE:\n\t\t\topts->max_size = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t  jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int jpg_dec_parseopts(char *optstr, jpg_dec_importopts_t *opts)\n{\n\tjas_tvparser_t *tvp;\n\n\topts->max_samples = 64 * JAS_MEBI;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\treturn -1;\n\t}\n\n\twhile (!jas_tvparser_next(tvp)) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_MAXSIZE:\n\t\t\topts->max_samples = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t  jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void dbOutputHexBlob(Jsi_DString *dStr, const void *pBlob, int nBlob){\n  int i;\n  char out[100], *zBlob = (char *)pBlob;\n  Jsi_DSAppend(dStr, \"X'\", NULL);\n  for(i=0; i<nBlob; i++){ snprintf(out, sizeof(out),\"%02x\",zBlob[i]&0xff);Jsi_DSAppend(dStr, out, NULL); }\n  Jsi_DSAppend(dStr, \"'\", NULL);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void dbOutputHexBlob(Jsi_DString *dStr, const void *pBlob, int nBlob){\n  int i;\n  char out[JSI_MAX_NUMBER_STRING], *zBlob = (char *)pBlob;\n  Jsi_DSAppend(dStr, \"X'\", NULL);\n  for(i=0; i<nBlob; i++){ snprintf(out, sizeof(out),\"%02x\",zBlob[i]&0xff);Jsi_DSAppend(dStr, out, NULL); }\n  Jsi_DSAppend(dStr, \"'\", NULL);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int ZEXPORT deflateCopy (dest, source)\n    z_streamp dest;\n    z_streamp source;\n{\n#ifdef MAXSEG_64K\n    return Z_STREAM_ERROR;\n#else\n    deflate_state *ds;\n    deflate_state *ss;\n    ushf *overlay;\n\n\n    if (deflateStateCheck(source) || dest == Z_NULL) {\n        return Z_STREAM_ERROR;\n    }\n\n    ss = source->state;\n\n    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));\n\n    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));\n    if (ds == Z_NULL) return Z_MEM_ERROR;\n    dest->state = (struct internal_state FAR *) ds;\n    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));\n    ds->strm = dest;\n\n    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));\n    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));\n    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);\n    ds->pending_buf = (uchf *) overlay;\n\n    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||\n        ds->pending_buf == Z_NULL) {\n        deflateEnd (dest);\n        return Z_MEM_ERROR;\n    }\n    /* following zmemcpy do not work for 16-bit MSDOS */\n    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));\n    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));\n    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));\n    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n\n    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);\n    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);\n    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;\n\n    ds->l_desc.dyn_tree = ds->dyn_ltree;\n    ds->d_desc.dyn_tree = ds->dyn_dtree;\n    ds->bl_desc.dyn_tree = ds->bl_tree;\n\n    return Z_OK;\n#endif /* MAXSEG_64K */\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int ZEXPORT deflateCopy (dest, source)\n    z_streamp dest;\n    z_streamp source;\n{\n#ifdef MAXSEG_64K\n    return Z_STREAM_ERROR;\n#else\n    deflate_state *ds;\n    deflate_state *ss;\n\n\n    if (deflateStateCheck(source) || dest == Z_NULL) {\n        return Z_STREAM_ERROR;\n    }\n\n    ss = source->state;\n\n    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));\n\n    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));\n    if (ds == Z_NULL) return Z_MEM_ERROR;\n    dest->state = (struct internal_state FAR *) ds;\n    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));\n    ds->strm = dest;\n\n    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));\n    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));\n    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, 4);\n\n    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||\n        ds->pending_buf == Z_NULL) {\n        deflateEnd (dest);\n        return Z_MEM_ERROR;\n    }\n    /* following zmemcpy do not work for 16-bit MSDOS */\n    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));\n    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));\n    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));\n    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n\n    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);\n    ds->sym_buf = ds->pending_buf + ds->lit_bufsize;\n\n    ds->l_desc.dyn_tree = ds->dyn_ltree;\n    ds->d_desc.dyn_tree = ds->dyn_dtree;\n    ds->bl_desc.dyn_tree = ds->bl_tree;\n\n    return Z_OK;\n#endif /* MAXSEG_64K */\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      }\n    }\n  }\n\n  const float float_activation_min = params.float_activation_min;\n  const float float_activation_max = params.float_activation_max;\n  float* data_ptr = output_data;\n  if (bias_data) {\n    const int outer_size =\n        batches * output_depth * output_height * output_width;\n    const int num_channels = input_shape.Dims(4);\n    for (int n = 0; n < outer_size; ++n) {\n      for (int c = 0; c < output_num_channels; ++c) {\n        data_ptr[c] = ActivationFunctionWithMinMax(data_ptr[c] + bias_data[c],\n                                                   float_activation_min,\n                                                   float_activation_max);\n      }\n      data_ptr += num_channels;\n    }\n  } else {\n    const int flat_size = output_shape.FlatSize();\n    for (int i = 0; i < flat_size; ++i) {\n      data_ptr[i] = ActivationFunctionWithMinMax(\n          data_ptr[i], float_activation_min, float_activation_max);\n    }\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        }\n      }\n    }\n  }\n\n  const float float_activation_min = params.float_activation_min;\n  const float float_activation_max = params.float_activation_max;\n  float* data_ptr = output_data;\n  if (bias_data) {\n    const int outer_size =\n        batches * output_depth * output_height * output_width;\n    for (int n = 0; n < outer_size; ++n) {\n      for (int c = 0; c < output_num_channels; ++c) {\n        data_ptr[c] = ActivationFunctionWithMinMax(data_ptr[c] + bias_data[c],\n                                                   float_activation_min,\n                                                   float_activation_max);\n      }\n      data_ptr += output_num_channels;\n    }\n  } else {\n    const int flat_size = output_shape.FlatSize();\n    for (int i = 0; i < flat_size; ++i) {\n      data_ptr[i] = ActivationFunctionWithMinMax(\n          data_ptr[i], float_activation_min, float_activation_max);\n    }\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static mif_hdr_t *mif_hdr_get(jas_stream_t *in)\n{\n\tuchar magicbuf[MIF_MAGICLEN];\n\tchar buf[4096];\n\tmif_hdr_t *hdr;\n\tbool done;\n\tjas_tvparser_t *tvp;\n\tint id;\n\n\thdr = 0;\n\ttvp = 0;\n\n\tif (jas_stream_read(in, magicbuf, MIF_MAGICLEN) != MIF_MAGICLEN) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static mif_hdr_t *mif_hdr_get(jas_stream_t *in)\n{\n\tjas_uchar magicbuf[MIF_MAGICLEN];\n\tchar buf[4096];\n\tmif_hdr_t *hdr;\n\tbool done;\n\tjas_tvparser_t *tvp;\n\tint id;\n\n\thdr = 0;\n\ttvp = 0;\n\n\tif (jas_stream_read(in, magicbuf, MIF_MAGICLEN) != MIF_MAGICLEN) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    int length() { return ptr - start; }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    size_t length() { return ptr - start; }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int get_query(struct MHD_Connection *connection, char **query, const char *separator)\n{\n\tint element_counter;\n\tchar **elements;\n\tchar *query_str;\n\tstruct collect_query collect_query;\n\tint i;\n\tint j;\n\tint length = 0;\n\n\tdebug(LOG_DEBUG, \" Getting query, separator is [%s].\", separator);\n\n\telement_counter = MHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, counter_iterator, NULL);\n\tif (element_counter < 0) {\n\t\t*query = safe_strdup(\"\");\n\t\treturn MHD_NO;\n\t}\n\telements = calloc(element_counter, sizeof(char *));\n\n\t// Collect the arguments of the query string from MHD\n\tMHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, collect_query_string, &collect_query);\n\n\tfor (i = 0; i < element_counter; i++) {\n\t\tif (!elements[i])\n\t\t\tcontinue;\n\t\tlength += strlen(elements[i]);\n\n\t\tif (i > 0) // q=foo&o=bar the '&' need also some space\n\t\t\tlength++;\n\t}\n\n\t// don't miss the zero terminator\n\tif (*query == NULL) {\n\t\tfor (i = 0; i < element_counter; i++) {\n\t\t\tfree(elements[i]);\n\t\t}\n\t\tfree(elements);\n\t\treturn 0;\n\t}\n\n\tquery_str = safe_calloc(QUERYMAXLEN);\n\n\tfor (i = 0, j = 0; i < element_counter; i++) {\n\t\tif (!elements[i]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdebug(LOG_DEBUG, \" element [%d] is [%s]\", i, elements[i]);\n\n\t\tstrncpy(*query + j, elements[i], length - j);\n\t\tif (i == 0) {\n\t\t\t// query_str is empty when i = 0 so safe to copy a single char into it\n\t\t\tstrcpy(query_str, \"?\");\n\t\t} else {\n\t\t\tif (QUERYMAXLEN - strlen(query_str) > length - j + 1) {\n\t\t\t\tstrncat(query_str, separator, QUERYMAXLEN - strlen(query_str));\n\t\t\t}\n\t\t}\n\n\t\t// note: query string will be truncated if too long\n\t\tif (QUERYMAXLEN - strlen(query_str) > length - j) {\n\t\t\tstrncat(query_str, *query, QUERYMAXLEN - strlen(query_str));\n\t\t} else {\n\t\t\tdebug(LOG_WARNING, \" Query string exceeds the maximum of %d bytes so has been truncated.\", QUERYMAXLEN/2);\n\t\t}\n\n\t\tfree(elements[i]);\n\t}\n\n\tdebug(LOG_DEBUG, \" query is [%s]\", query_str);\n\tstrncpy(*query, query_str, QUERYMAXLEN);\n\tfree(query_str);\n\tfree(elements);\n\treturn 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int get_query(struct MHD_Connection *connection, char **query, const char *separator)\n{\n\tint element_counter;\n\tchar **elements;\n\tchar *query_str;\n\tstruct collect_query collect_query;\n\tint i;\n\tint j = 4;\n\tint length = 0;\n\n\tdebug(LOG_DEBUG, \" Getting query, separator is [%s].\", separator);\n\n\telement_counter = MHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, counter_iterator, NULL);\n\tif (element_counter < 0) {\n\t\t*query = safe_strdup(\"\");\n\t\treturn MHD_NO;\n\t}\n\telements = calloc(element_counter, sizeof(char *));\n\t// Collect the arguments of the query string from MHD\n\tMHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, collect_query_string, &collect_query);\n\n\tfor (i = 0; i < element_counter; i++) {\n\t\tif (!elements[i])\n\t\t\tcontinue;\n\t\tlength += strlen(elements[i]);\n\n\t\tif (i > 0) // q=foo&o=bar the '&' need also some space\n\t\t\tlength++;\n\n\t\tdebug(LOG_DEBUG, \" cumulative element length is [%d]\", length);\n\t}\n\n\t// don't miss the zero terminator\n\tif (*query == NULL) {\n\t\tfor (i = 0; i < element_counter; i++) {\n\t\t\tfree(elements[i]);\n\t\t}\n\t\tfree(elements);\n\t\treturn 0;\n\t}\n\n\tquery_str = safe_calloc(QUERYMAXLEN);\n\n\tfor (i = 0, j = 0; i < element_counter; i++) {\n\t\tif (!elements[i]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdebug(LOG_DEBUG, \" element [%d] is [%s]\", i, elements[i]);\n\n\t\tif (length + j < QUERYMAXLEN) {\n\n\t\t\tstrncpy(*query + j, elements[i], length - j);\n\n\t\t\tif (i == 0) {\n\t\t\t\t// query_str is empty when i = 0 so safe to copy a single char into it\n\t\t\t\tstrcpy(query_str, \"?\");\n\t\t\t} else {\n\t\t\t\tif (QUERYMAXLEN - strlen(query_str) > length - j + 1) {\n\t\t\t\t\tstrncat(query_str, separator, QUERYMAXLEN - strlen(query_str));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstrncat(query_str, *query, QUERYMAXLEN - strlen(query_str));\n\t\t} else {\n\t\t\tdebug(LOG_WARNING, \" Query string is too long, invalid or corrupt so is ignored.\");\n\t\t}\n\n\t\tfree(elements[i]);\n\t}\n\n\tdebug(LOG_DEBUG, \" query is [%s]\", query_str);\n\tstrncpy(*query, query_str, QUERYMAXLEN);\n\tfree(query_str);\n\tfree(elements);\n\treturn 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      throw FizzException(\n          \"supported version mismatch\", AlertDescription::protocol_version);\n    }\n  }\n\n  state.writeRecordLayer()->setProtocolVersion(*version);\n\n  validateClientHello(chlo);\n\n  auto cipher = negotiateCipher(chlo, state.context()->getSupportedCiphers());\n\n  verifyCookieState(cookieState, *version, cipher);\n\n  auto resStateResult = getResumptionState(\n      chlo,\n      state.context()->getTicketCipher(),\n      state.context()->getSupportedPskModes());\n\n  auto replayCacheResultFuture = getReplayCacheResult(\n      chlo,\n      state.context()->getAcceptEarlyData(*version),\n        std::unique_ptr<HandshakeContext> handshakeContext;\n        std::tie(scheduler, handshakeContext) = setupSchedulerAndContext(\n            *state.context()->getFactory(),\n            cipher,\n            chlo,\n            resState,\n            cookieState,\n            pskType,\n            std::move(state.handshakeContext()),\n            version);\n\n        if (state.cipher().has_value() && cipher != *state.cipher()) {\n          throw FizzException(\n              \"cipher mismatch with previous negotiation\",\n              AlertDescription::illegal_parameter);\n        }\n\n        auto alpn = negotiateAlpn(chlo, folly::none, *state.context());\n\n        auto clockSkew = getClockSkew(\n            resState,\n            obfuscatedAge,\n            state.context()->getClock().getCurrentTime());\n\n        auto appToken = getAppToken(resState);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "          \"supported version mismatch\", AlertDescription::protocol_version);\n    }\n  }\n\n  state.writeRecordLayer()->setProtocolVersion(*version);\n\n  validateClientHello(chlo);\n\n  auto cipher = negotiateCipher(chlo, state.context()->getSupportedCiphers());\n\n  if (state.cipher().has_value() && cipher != *state.cipher()) {\n    throw FizzException(\n        \"cipher mismatch with previous negotiation\",\n        AlertDescription::illegal_parameter);\n  }\n\n  verifyCookieState(cookieState, *version, cipher);\n\n  auto resStateResult = getResumptionState(\n      chlo,\n      state.context()->getTicketCipher(),\n      state.context()->getSupportedPskModes());\n\n  auto replayCacheResultFuture = getReplayCacheResult(\n      chlo,\n      state.context()->getAcceptEarlyData(*version),\n        std::unique_ptr<KeyScheduler> scheduler;\n        std::unique_ptr<HandshakeContext> handshakeContext;\n        std::tie(scheduler, handshakeContext) = setupSchedulerAndContext(\n            *state.context()->getFactory(),\n            cipher,\n            chlo,\n            resState,\n            cookieState,\n            pskType,\n            std::move(state.handshakeContext()),\n            version);\n\n        auto alpn = negotiateAlpn(chlo, folly::none, *state.context());\n\n        auto clockSkew = getClockSkew(\n            resState,\n            obfuscatedAge,\n            state.context()->getClock().getCurrentTime());\n\n        auto appToken = getAppToken(resState);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\n\tif (!valid_localpart(maddr->user) ||\n\t    !valid_domainpart(maddr->domain)) {\n\t\t/* accept empty return-path in MAIL FROM, required for bounces */\n\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\t\treturn (1);\n\n\t\t/* no user-part, reject */\n\t\tif (maddr->user[0] == '\\0')\n\t\t\treturn (0);\n\n\t\t/* no domain, local user */\n\t\tif (maddr->domain[0] == '\\0') {\n\t\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\t    sizeof(maddr->domain));\n\t\t\treturn (1);\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (1);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\n\t/* accept empty return-path in MAIL FROM, required for bounces */\n\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\treturn (1);\n\n\t/* no or invalid user-part, reject */\n\tif (maddr->user[0] == '\\0' || !valid_localpart(maddr->user))\n\t\treturn (0);\n\n\t/* no domain part, local user */\n\tif (maddr->domain[0] == '\\0') {\n\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\tsizeof(maddr->domain));\n\t}\n\n\tif (!valid_domainpart(maddr->domain))\n\t\treturn (0);\n\n\treturn (1);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "cib_remote_msg(gpointer data)\n{\n    const char *value = NULL;\n    xmlNode *command = NULL;\n    cib_client_t *client = data;\n\n    crm_trace(\"%s callback\", client->encrypted ? \"secure\" : \"clear-text\");\n\n    command = crm_recv_remote_msg(client->session, client->encrypted);\n    if (command == NULL) {\n        return -1;\n    }\n\n    value = crm_element_name(command);\n    if (safe_str_neq(value, \"cib_command\")) {\n        crm_log_xml_trace(command, \"Bad command: \");\n        goto bail;\n    }\n\n    if (client->name == NULL) {\n        value = crm_element_value(command, F_CLIENTNAME);\n        if (value == NULL) {\n            client->name = strdup(client->id);\n        } else {\n            client->name = strdup(value);\n        }\n    }\n\n    if (client->callback_id == NULL) {\n        value = crm_element_value(command, F_CIB_CALLBACK_TOKEN);\n        if (value != NULL) {\n            client->callback_id = strdup(value);\n            crm_trace(\"Callback channel for %s is %s\", client->id, client->callback_id);\n\n        } else {\n            client->callback_id = strdup(client->id);\n        }\n    }\n\n    /* unset dangerous options */\n    xml_remove_prop(command, F_ORIG);\n    xml_remove_prop(command, F_CIB_HOST);\n    xml_remove_prop(command, F_CIB_GLOBAL_UPDATE);\n\n    crm_xml_add(command, F_TYPE, T_CIB);\n    crm_xml_add(command, F_CIB_CLIENTID, client->id);\n    crm_xml_add(command, F_CIB_CLIENTNAME, client->name);\n#if ENABLE_ACL\n    crm_xml_add(command, F_CIB_USER, client->user);\n#endif\n\n    if (crm_element_value(command, F_CIB_CALLID) == NULL) {\n        char *call_uuid = crm_generate_uuid();\n\n        /* fix the command */\n        crm_xml_add(command, F_CIB_CALLID, call_uuid);\n        free(call_uuid);\n    }\n\n    if (crm_element_value(command, F_CIB_CALLOPTS) == NULL) {\n        crm_xml_add_int(command, F_CIB_CALLOPTS, 0);\n    }\n\n    crm_log_xml_trace(command, \"Remote command: \");\n    cib_common_callback_worker(0, 0, command, client, TRUE);\n  bail:\n    free_xml(command);\n    command = NULL;\n    return 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "cib_remote_msg(gpointer data)\n{\n    xmlNode *command = NULL;\n    cib_client_t *client = data;\n    int disconnected = 0;\n    int timeout = client->remote_auth ? -1 : 1000;\n\n    crm_trace(\"%s callback\", client->encrypted ? \"secure\" : \"clear-text\");\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n    if (client->encrypted && (client->handshake_complete == FALSE)) {\n        int rc = 0;\n\n        /* Muliple calls to handshake will be required, this callback\n         * will be invoked once the client sends more handshake data. */\n        do {\n            rc = gnutls_handshake(*client->session);\n\n            if (rc < 0 && rc != GNUTLS_E_AGAIN) {\n                crm_err(\"Remote cib tls handshake failed\");\n                return -1;\n            }\n        } while (rc == GNUTLS_E_INTERRUPTED);\n\n        if (rc == 0) {\n            crm_debug(\"Remote cib tls handshake completed\");\n            client->handshake_complete = TRUE;\n            if (client->remote_auth_timeout) {\n                g_source_remove(client->remote_auth_timeout);\n            }\n            /* after handshake, clients must send auth in a few seconds */\n            client->remote_auth_timeout = g_timeout_add(REMOTE_AUTH_TIMEOUT, remote_auth_timeout_cb, client);\n        }\n        return 0;\n    }\n#endif\n\n    crm_recv_remote_msg(client->session, &client->recv_buf, client->encrypted, timeout, &disconnected);\n\n    /* must pass auth before we will process anything else */\n    if (client->remote_auth == FALSE) {\n        xmlNode *reg;\n#if ENABLE_ACL\n        const char *user = NULL;\n#endif\n        command = crm_parse_remote_buffer(&client->recv_buf);\n        if (cib_remote_auth(command) == FALSE) {\n            free_xml(command);\n            return -1;\n        }\n\n        crm_debug(\"remote connection authenticated successfully\");\n        client->remote_auth = TRUE;\n        g_source_remove(client->remote_auth_timeout);\n        client->remote_auth_timeout = 0;\n        client->name = crm_element_value_copy(command, \"name\");\n\n#if ENABLE_ACL\n        user = crm_element_value(command, \"user\");\n        if (user) {\n           new_client->user = strdup(user);\n        }\n#endif\n\n        /* send ACK */\n        reg = create_xml_node(NULL, \"cib_result\");\n        crm_xml_add(reg, F_CIB_OPERATION, CRM_OP_REGISTER);\n        crm_xml_add(reg, F_CIB_CLIENTID, client->id);\n        crm_send_remote_msg(client->session, reg, client->encrypted);\n        free_xml(reg);\n        free_xml(command);\n    }\n\n    command = crm_parse_remote_buffer(&client->recv_buf);\n    while (command) {\n        crm_trace(\"command received\");\n        cib_handle_remote_msg(client, command);\n        free_xml(command);\n        command = crm_parse_remote_buffer(&client->recv_buf);\n    }\n\n    if (disconnected) {\n        crm_trace(\"disconnected while receiving remote cib msg.\");\n        return -1;\n    }\n\n    return 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  if (overflow2(sizeof(unsigned char *), sy)) {\n    return NULL;\n  }\n\n  if (overflow2(sizeof(int) + sizeof(unsigned char), sx * sy)) {\n    return NULL;\n  }\n\n  // Check for OOM before doing a potentially large allocation.\n  auto allocsz = sizeof(gdImage)\n    + sy * (sizeof(int *) + sizeof(unsigned char *))\n    + sx * sy * (sizeof(int) + sizeof(unsigned char));\n  if (UNLIKELY(precheckOOM(allocsz))) {\n    // Don't throw here because GD might need to do its own cleanup.\n    return NULL;\n  }\n\n  im = (gdImage *) gdMalloc(sizeof(gdImage));\n  memset(im, 0, sizeof(gdImage));\n  im->tpixels = (int **) gdMalloc(sizeof(int *) * sy);\n  im->AA_opacity = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n  im->polyInts = 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  if (overflow2(sizeof(unsigned char *), sy)) {\n    return NULL;\n  }\n\n  if (overflow2(sizeof(int) + sizeof(unsigned char), sx * sy)) {\n    return NULL;\n  }\n\n  // Check for OOM before doing a potentially large allocation.\n  auto allocsz = sizeof(gdImage)\n    + (sizeof(int *) + sizeof(unsigned char *)) * sy\n    + (sizeof(int) + sizeof(unsigned char)) * sx * sy;\n  if (UNLIKELY(precheckOOM(allocsz))) {\n    // Don't throw here because GD might need to do its own cleanup.\n    return NULL;\n  }\n\n  im = (gdImage *) gdMalloc(sizeof(gdImage));\n  memset(im, 0, sizeof(gdImage));\n  im->tpixels = (int **) gdMalloc(sizeof(int *) * sy);\n  im->AA_opacity = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n  im->polyInts = 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                        int index) {\n  if (index >= 0 && index < node->outputs->size) {\n    const int tensor_index = node->outputs->data[index];\n    if (tensor_index != kTfLiteOptionalTensor) {\n      if (context->tensors != nullptr) {\n        return &context->tensors[tensor_index];\n      } else {\n        return context->GetTensor(context, tensor_index);\n      }\n    }\n  }\n  return nullptr;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                        int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->outputs->size, node->outputs->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "          \"Data of TensorProto ( tensor name: \",\n          tensor.name(),\n          \") is stored externally and should not have data field.\",\n          value_field);\n    }\n\n    bool has_location = false;\n    for (const StringStringEntryProto& entry : tensor.external_data()) {\n      if (entry.has_key() && entry.has_value() && entry.key() == \"location\") {\n        has_location = true;\n        std::string data_path = path_join(ctx.get_model_dir(), entry.value());\n        // use stat to check whether the file exists\n        struct stat buffer;\n        if (stat((data_path).c_str(), &buffer) != 0) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be stored in \",\n              data_path,\n              \", but it doesn't exist or is not accessible.\");\n        }\n      }\n    }\n    if (!has_location) {\n      fail_check(\"TensorProto ( tensor name: \", tensor.name(), \") is stored externally but doesn't have a location.\");\n    }\n    return;\n  }\n  int64_t nelem = 1;\n  for (auto x : tensor.dims()) {\n    nelem *= x;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "          \"Data of TensorProto ( tensor name: \",\n          tensor.name(),\n          \") is stored externally and should not have data field.\",\n          value_field);\n    }\n\n    bool has_location = false;\n    for (const StringStringEntryProto& entry : tensor.external_data()) {\n      if (entry.has_key() && entry.has_value() && entry.key() == \"location\") {\n        has_location = true;\n        std::string relative_path = clean_relative_path(entry.value());\n        // Check that normalized relative path starts with \"../\" or \"..\\\" on windows.\n        if (relative_path.rfind(\"..\" + k_preferred_path_separator, 0) == 0) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be file inside the \",\n              ctx.get_model_dir(),\n              \", but the '\",\n              entry.value(),\n              \"' points outside the directory\");\n        }\n\n        std::string data_path = path_join(ctx.get_model_dir(), relative_path);\n        // use stat to check whether the file exists\n        struct stat buffer;\n        if (stat((data_path).c_str(), &buffer) != 0) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be stored in \",\n              data_path,\n              \", but it doesn't exist or is not accessible.\");\n        }\n#ifdef _WIN32\n#else // POSIX\n      //  Do not allow symlinks or directories.\n        if (!S_ISREG(buffer.st_mode)) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be stored in \",\n              data_path,\n              \", but it is not regular file.\");\n        }\n#endif\n      }\n    }\n    if (!has_location) {\n      fail_check(\"TensorProto ( tensor name: \", tensor.name(), \") is stored externally but doesn't have a location.\");\n    }\n    return;\n  }\n  int64_t nelem = 1;\n  for (auto x : tensor.dims()) {\n    nelem *= x;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  PyObject *__pyx_v_state = 0;\n  PyObject *__pyx_v__dict = 0;\n  int __pyx_v_use_setstate;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  int __pyx_t_5;\n  int __pyx_t_6;\n  __Pyx_RefNannySetupContext(\"__reduce_cython__\", 0);\n\n  /* \"(tree fragment)\":5\n *     cdef object _dict\n *     cdef bint use_setstate\n *     state = (self.buffer, self.buffer_size, self.position)             # <<<<<<<<<<<<<<\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:\n */\n  __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->buffer); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->buffer_size); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_self->position); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __Pyx_GIVEREF(__pyx_t_1);\n  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1);\n  __Pyx_GIVEREF(__pyx_t_2);\n  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2);\n  __Pyx_GIVEREF(__pyx_t_3);\n  PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_3);\n  __pyx_t_1 = 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  PyObject *__pyx_v__dict = 0;\n  int __pyx_v_use_setstate;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  int __pyx_t_5;\n  int __pyx_t_6;\n  int __pyx_lineno = 0;\n  const char *__pyx_filename = NULL;\n  int __pyx_clineno = 0;\n  __Pyx_RefNannySetupContext(\"__reduce_cython__\", 0);\n\n  /* \"(tree fragment)\":5\n *     cdef object _dict\n *     cdef bint use_setstate\n *     state = (self.buffer, self.buffer_size, self.position)             # <<<<<<<<<<<<<<\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:\n */\n  __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->buffer); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = __Pyx_PyInt_From_unsigned_PY_LONG_LONG(__pyx_v_self->buffer_size); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_3 = __Pyx_PyInt_From_unsigned_PY_LONG_LONG(__pyx_v_self->position); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __Pyx_GIVEREF(__pyx_t_1);\n  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1);\n  __Pyx_GIVEREF(__pyx_t_2);\n  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2);\n  __Pyx_GIVEREF(__pyx_t_3);\n  PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_3);\n  __pyx_t_1 = 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void* ipc_alloc(int size)\n{\n\tvoid* out;\n\tif(size > PAGE_SIZE)\n\t\tout = vmalloc(size);\n\telse\n\t\tout = kmalloc(size, GFP_KERNEL);\n\treturn out;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void *ipc_alloc(int size)\n{\n\tvoid *out;\n\tif(size > PAGE_SIZE)\n\t\tout = vmalloc(size);\n\telse\n\t\tout = kmalloc(size, GFP_KERNEL);\n\treturn out;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        {\n          ec = CreateRestrictedDirectory(state_temp_dir);\n        }\n        else\n        {\n          ec = CreateNormalDirectory(state_temp_dir);\n        }\n\n        if (ec)\n        {\n          // Delete previous uninstaller\n          if (DeleteFile(unexe))\n          {\n            myDelete(state_temp_dir, DEL_DIR|DEL_RECURSE);\n            if (!retry++) goto retry_un_dir;\n          }\n        }\n        else\n        {\n          HANDLE hProc;\n          SetCurrentDirectory(state_temp_dir);\n#ifdef NSIS_SUPPORT_MOVEONREBOOT\n          MoveFileOnReboot(state_temp_dir, NULL);\n#endif",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        {\n          ec = CreateRestrictedDirectory(state_temp_dir);\n        }\n        else\n        {\n          ec = CreateNormalDirectory(state_temp_dir);\n        }\n\n        if (ec)\n        {\n          // Delete previous uninstaller (if it is safe to do so)\n          if (!(GetFileAttributes(unexe) & FILE_ATTRIBUTE_REPARSE_POINT) && DeleteFile(unexe))\n          {\n            myDelete(state_temp_dir, DEL_DIR);\n            if (!retry++) goto retry_un_dir;\n          }\n        }\n        else\n        {\n          HANDLE hProc;\n          SetCurrentDirectory(state_temp_dir);\n#ifdef NSIS_SUPPORT_MOVEONREBOOT\n          MoveFileOnReboot(state_temp_dir, NULL);\n#endif",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\n\t    // insert the new text\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\n\t\t// insert block's trailing spaces only if there's text behind\n\t\tif ((j < count - 1 || !shortline) && spaces)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t\telse\n\t\t    totlen -= spaces;  // didn't use these spaces\n\t    }\n\n\t    // may insert some spaces after the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t\t    ++curwin->w_cursor.lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t// put cursor on first inserted character\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\n\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\n\t    // insert the new text\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\n\t\t// insert block's trailing spaces only if there's text behind\n\t\tif ((j < count - 1 || !shortline) && spaces > 0)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t\telse\n\t\t    totlen -= spaces;  // didn't use these spaces\n\t    }\n\n\t    // may insert some spaces after the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t// put cursor on first inserted character\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\n\n    // Make sure the cursor is not after the NUL.\n    int len = (int)STRLEN(ml_get_curline());\n    if (curwin->w_cursor.col > len)\n    {\n\tif (cur_ve_flags == VE_ALL)\n\t    curwin->w_cursor.coladd = curwin->w_cursor.col - len;\n\tcurwin->w_cursor.col = len;\n    }\n\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "bool RepeatedAttrDefEqual(\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a1,\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {\n  std::unordered_map<string, const OpDef::AttrDef*> a1_set;\n  for (const OpDef::AttrDef& def : a1) {\n    DCHECK(a1_set.find(def.name()) == a1_set.end())\n        << \"AttrDef names must be unique, but '\" << def.name()\n        << \"' appears more than once\";\n    a1_set[def.name()] = &def;\n  }\n  for (const OpDef::AttrDef& def : a2) {\n    auto iter = a1_set.find(def.name());\n    if (iter == a1_set.end()) return false;\n    if (!AttrDefEqual(*iter->second, def)) return false;\n    a1_set.erase(iter);\n  }\n  if (!a1_set.empty()) return false;\n  return true;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "bool RepeatedAttrDefEqual(\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a1,\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {\n  std::unordered_map<string, const OpDef::AttrDef*> a1_set;\n  for (const OpDef::AttrDef& def : a1) {\n    if (a1_set.find(def.name()) != a1_set.end()) {\n      LOG(ERROR) << \"AttrDef names must be unique, but '\" << def.name()\n                 << \"' appears more than once\";\n    }\n    a1_set[def.name()] = &def;\n  }\n  for (const OpDef::AttrDef& def : a2) {\n    auto iter = a1_set.find(def.name());\n    if (iter == a1_set.end()) return false;\n    if (!AttrDefEqual(*iter->second, def)) return false;\n    a1_set.erase(iter);\n  }\n  if (!a1_set.empty()) return false;\n  return true;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct device *dev = &intf->dev;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct net_device *netdev;\n\tstruct catc *catc;\n\tu8 broadcast[ETH_ALEN];\n\tint i, pktsz, ret;\n\n\tif (usb_set_interface(usbdev,\n\t\t\tintf->altsetting->desc.bInterfaceNumber, 1)) {\n\t\tdev_err(dev, \"Can't set altsetting 1.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tnetdev = alloc_etherdev(sizeof(struct catc));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tusb_fill_bulk_urb(catc->tx_urb, usbdev, usb_sndbulkpipe(usbdev, 1),\n\t\tNULL, 0, catc_tx_done, catc);\n\n\tusb_fill_bulk_urb(catc->rx_urb, usbdev, usb_rcvbulkpipe(usbdev, 1),\n\t\tcatc->rx_buf, pktsz, catc_rx_done, catc);\n\n\tusb_fill_int_urb(catc->irq_urb, usbdev, usb_rcvintpipe(usbdev, 2),\n                catc->irq_buf, 2, catc_irq_done, catc, 1);\n\n\tif (!catc->is_f5u011) {\n\t\tdev_dbg(dev, \"Checking memory size\\n\");\n\n\t\ti = 0x12345678;\n\t\tcatc_write_mem(catc, 0x7a80, &i, 4);\n\t\ti = 0x87654321;\t\n\t\tcatc_write_mem(catc, 0xfa80, &i, 4);\n\t\tcatc_read_mem(catc, 0x7a80, &i, 4);\n\t  \n\t\tswitch (i) {\n\t\tcase 0x12345678:\n\t\t\tcatc_set_reg(catc, TxBufCount, 8);\n\t\t\tcatc_set_reg(catc, RxBufCount, 32);\n\t\t\tdev_dbg(dev, \"64k Memory\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&intf->dev,\n\t\t\t\t \"Couldn't detect memory size, assuming 32k\\n\");\n\t\tcase 0x87654321:\n\t\t\tcatc_set_reg(catc, TxBufCount, 4);\n\t\t\tcatc_set_reg(catc, RxBufCount, 16);\n\t\t\tdev_dbg(dev, \"32k Memory\\n\");\n\t\t\tbreak;\n\t\t}\n\t  \n\t\tdev_dbg(dev, \"Getting MAC from SEEROM.\\n\");\n\t  \n\t\tcatc_get_mac(catc, netdev->dev_addr);\n\t\t\n\t\tdev_dbg(dev, \"Setting MAC into registers.\\n\");\n\t  \n\t\tfor (i = 0; i < 6; i++)\n\t\t\tcatc_set_reg(catc, StationAddr0 - i, netdev->dev_addr[i]);\n\t\t",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct device *dev = &intf->dev;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct net_device *netdev;\n\tstruct catc *catc;\n\tu8 broadcast[ETH_ALEN];\n\tint pktsz, ret;\n\n\tif (usb_set_interface(usbdev,\n\t\t\tintf->altsetting->desc.bInterfaceNumber, 1)) {\n\t\tdev_err(dev, \"Can't set altsetting 1.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tnetdev = alloc_etherdev(sizeof(struct catc));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\tusb_fill_bulk_urb(catc->tx_urb, usbdev, usb_sndbulkpipe(usbdev, 1),\n\t\tNULL, 0, catc_tx_done, catc);\n\n\tusb_fill_bulk_urb(catc->rx_urb, usbdev, usb_rcvbulkpipe(usbdev, 1),\n\t\tcatc->rx_buf, pktsz, catc_rx_done, catc);\n\n\tusb_fill_int_urb(catc->irq_urb, usbdev, usb_rcvintpipe(usbdev, 2),\n                catc->irq_buf, 2, catc_irq_done, catc, 1);\n\n\tif (!catc->is_f5u011) {\n\t\tu32 *buf;\n\t\tint i;\n\n\t\tdev_dbg(dev, \"Checking memory size\\n\");\n\n\t\tbuf = kmalloc(4, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_free;\n\t\t}\n\n\t\t*buf = 0x12345678;\n\t\tcatc_write_mem(catc, 0x7a80, buf, 4);\n\t\t*buf = 0x87654321;\n\t\tcatc_write_mem(catc, 0xfa80, buf, 4);\n\t\tcatc_read_mem(catc, 0x7a80, buf, 4);\n\t  \n\t\tswitch (*buf) {\n\t\tcase 0x12345678:\n\t\t\tcatc_set_reg(catc, TxBufCount, 8);\n\t\t\tcatc_set_reg(catc, RxBufCount, 32);\n\t\t\tdev_dbg(dev, \"64k Memory\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&intf->dev,\n\t\t\t\t \"Couldn't detect memory size, assuming 32k\\n\");\n\t\tcase 0x87654321:\n\t\t\tcatc_set_reg(catc, TxBufCount, 4);\n\t\t\tcatc_set_reg(catc, RxBufCount, 16);\n\t\t\tdev_dbg(dev, \"32k Memory\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree(buf);\n\t  \n\t\tdev_dbg(dev, \"Getting MAC from SEEROM.\\n\");\n\t  \n\t\tcatc_get_mac(catc, netdev->dev_addr);\n\t\t\n\t\tdev_dbg(dev, \"Setting MAC into registers.\\n\");\n\t  \n\t\tfor (i = 0; i < 6; i++)\n\t\t\tcatc_set_reg(catc, StationAddr0 - i, netdev->dev_addr[i]);\n\t\t",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    Check_Type(indent, T_STRING);\n    len = RSTRING_LEN(indent);\n    if (len == 0) {\n        if (state->indent) {\n            ruby_xfree(state->indent);\n            state->indent = NULL;\n            state->indent_len = 0;\n        }\n    } else {\n        if (state->indent) ruby_xfree(state->indent);\n        state->indent = strdup(RSTRING_PTR(indent));\n        state->indent_len = len;\n    }\n    return Qnil;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    Check_Type(indent, T_STRING);\n    len = RSTRING_LEN(indent);\n    if (len == 0) {\n        if (state->indent) {\n            ruby_xfree(state->indent);\n            state->indent = NULL;\n            state->indent_len = 0;\n        }\n    } else {\n        if (state->indent) ruby_xfree(state->indent);\n        state->indent = fstrndup(RSTRING_PTR(indent), len);\n        state->indent_len = len;\n    }\n    return Qnil;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  void event_cb(drachtio::RequestHandler::GlobalInfo *g, curl_socket_t s,\n                       int action, const boost::system::error_code & error,\n                       int *fdp) {\n    std::shared_ptr<RequestHandler> p = RequestHandler::getInstance() ;\n    std::map<curl_socket_t, boost::asio::ip::tcp::socket *>& socket_map = p->getSocketMap() ;\n    boost::asio::deadline_timer& timer = p->getTimer() ;\n\n    if(socket_map.find(s) == socket_map.end()) {\n      DR_LOG(log_error) << \"event_cb: socket already closed\";\n      return;\n    }\n\n    /* make sure the event matches what are wanted */\n    if(*fdp == action || *fdp == CURL_POLL_INOUT) {\n      CURLMcode rc;\n      if(error)\n        action = CURL_CSELECT_ERR;\n      rc = curl_multi_socket_action(g->multi, s, action, &g->still_running);\n\n      mcode_test(\"event_cb: curl_multi_socket_action\", rc);\n      check_multi_info(g);\n\n      if(g->still_running <= 0) {\n        timer.cancel();\n      }\n\n      /* keep on watching.\n       * the socket may have been closed and/or fdp may have been changed\n       * in curl_multi_socket_action(), so check them both */\n      if(!error && socket_map.find(s) != socket_map.end() &&\n         (*fdp == action || *fdp == CURL_POLL_INOUT)) {\n        boost::asio::ip::tcp::socket *tcp_socket = socket_map.find(s)->second;\n\n        if(action == CURL_POLL_IN) {\n          tcp_socket->async_read_some(boost::asio::null_buffers(),\n                                      boost::bind(&event_cb, g, s,\n                                                  action, boost::placeholders::_1, fdp));\n        }\n        if(action == CURL_POLL_OUT) {\n          tcp_socket->async_write_some(boost::asio::null_buffers(),\n                                       boost::bind(&event_cb, g, s,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  void event_cb(drachtio::RequestHandler::GlobalInfo *g, curl_socket_t s,\n                       int action, const boost::system::error_code & error,\n                       int *fdp) {\n    int f = *fdp;\n    std::shared_ptr<RequestHandler> p = RequestHandler::getInstance() ;\n    std::map<curl_socket_t, boost::asio::ip::tcp::socket *>& socket_map = p->getSocketMap() ;\n    boost::asio::deadline_timer& timer = p->getTimer() ;\n\n    if(socket_map.find(s) == socket_map.end()) {\n      DR_LOG(log_error) << \"event_cb: socket already closed\";\n      return;\n    }\n\n    /* make sure the event matches what are wanted */\n    if(f == action || f == CURL_POLL_INOUT) {\n      CURLMcode rc;\n      if(error)\n        action = CURL_CSELECT_ERR;\n      rc = curl_multi_socket_action(g->multi, s, action, &g->still_running);\n\n      mcode_test(\"event_cb: curl_multi_socket_action\", rc);\n      check_multi_info(g);\n\n      if(g->still_running <= 0) {\n        timer.cancel();\n      }\n\n      /* keep on watching.\n       * the socket may have been closed and/or fdp may have been changed\n       * in curl_multi_socket_action(), so check them both */\n      if(!error && socket_map.find(s) != socket_map.end() &&\n         (f == action || f == CURL_POLL_INOUT)) {\n        boost::asio::ip::tcp::socket *tcp_socket = socket_map.find(s)->second;\n\n        if(action == CURL_POLL_IN) {\n          tcp_socket->async_read_some(boost::asio::null_buffers(),\n                                      boost::bind(&event_cb, g, s,\n                                                  action, boost::placeholders::_1, fdp));\n        }\n        if(action == CURL_POLL_OUT) {\n          tcp_socket->async_write_some(boost::asio::null_buffers(),\n                                       boost::bind(&event_cb, g, s,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        else\n        {\n            if (b2->size ==0)\n            {\n                // b2->size = 0, whatever b1->size is, do nothing\n                result = 0;\n            }\n            else\n            {\n                // b2->size != 0, whatever b1->size is\n                unsigned char* temp = (unsigned char*)realloc(b1->buffer, b1->size + b2->size);\n                if (temp == NULL)\n                {\n                    /* Codes_SRS_BUFFER_07_023: [BUFFER_append shall return a nonzero upon any error that is encountered.] */\n                    LogError(\"Failure: allocating temp buffer.\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    /* Codes_SRS_BUFFER_07_024: [BUFFER_append concatenates b2 onto b1 without modifying b2 and shall return zero on success.]*/\n                    b1->buffer = temp;\n                    // Append the BUFFER",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        else\n        {\n            if (b2->size ==0)\n            {\n                // b2->size = 0, whatever b1->size is, do nothing\n                result = 0;\n            }\n            else\n            {\n                // b2->size != 0, whatever b1->size is\n                unsigned char* temp;\n                size_t malloc_size = safe_add_size_t(b1->size, b2->size);\n                if (malloc_size == SIZE_MAX || \n                    (temp = (unsigned char*)realloc(b1->buffer, malloc_size)) == NULL)\n                {\n                    /* Codes_SRS_BUFFER_07_023: [BUFFER_append shall return a nonzero upon any error that is encountered.] */\n                    LogError(\"Failure: allocating temp buffer.\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    /* Codes_SRS_BUFFER_07_024: [BUFFER_append concatenates b2 onto b1 without modifying b2 and shall return zero on success.]*/\n                    b1->buffer = temp;\n                    // Append the BUFFER",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "njs_vm_start(njs_vm_t *vm)\n{\n    njs_int_t  ret;\n\n    ret = njs_module_load(vm);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_vmcode_interpreter(vm, vm->start);\n\n    return (ret == NJS_ERROR) ? NJS_ERROR : NJS_OK;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "njs_vm_start(njs_vm_t *vm)\n{\n    njs_int_t  ret;\n\n    ret = njs_module_load(vm);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_vmcode_interpreter(vm, vm->start, NULL, NULL);\n\n    return (ret == NJS_ERROR) ? NJS_ERROR : NJS_OK;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static pj_status_t ssl_on_recv_packet(dtls_srtp *ds, unsigned idx,\n                                      const void *data, pj_size_t len)\n{\n    char tmp[128];\n    pj_size_t nwritten;\n\n    pj_lock_acquire(ds->ossl_lock);\n\n    if (!ds->ossl_rbio[idx]) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_EGONE;\n    }\n\n    nwritten = BIO_write(ds->ossl_rbio[idx], data, (int)len);\n    if (nwritten < len) {\n        /* Error? */\n        pj_status_t status;\n        status = GET_SSL_STATUS(ds);\n#if DTLS_DEBUG\n        pj_perror(2, ds->base.name, status, \"BIO_write() error\");\n#endif\n        pj_lock_release(ds->ossl_lock);\n        return status;\n    }\n\n    if (!ds->ossl_ssl[idx]) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_EGONE;\n    }\n\n    /* Consume (and ignore) the packet */\n    while (1) {\n        int rc = SSL_read(ds->ossl_ssl[idx], tmp, sizeof(tmp));\n        if (rc <= 0) {\n#if DTLS_DEBUG\n            pj_status_t status = GET_SSL_STATUS(ds);\n            if (status != PJ_SUCCESS)\n                pj_perror(2, ds->base.name, status, \"SSL_read() error\");\n#endif\n            break;\n        }\n    }\n\n    pj_lock_release(ds->ossl_lock);\n\n    /* Flush anything pending in the write BIO */\n    return ssl_flush_wbio(ds, idx);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static pj_status_t ssl_on_recv_packet(dtls_srtp *ds, unsigned idx,\n                                      const void *data, pj_size_t len)\n{\n    char tmp[128];\n    pj_size_t nwritten;\n\n    DTLS_LOCK(ds);\n\n    if (!ds->ossl_rbio[idx]) {\n        DTLS_UNLOCK(ds);\n        return PJ_EGONE;\n    }\n\n    nwritten = BIO_write(ds->ossl_rbio[idx], data, (int)len);\n    if (nwritten < len) {\n        /* Error? */\n        pj_status_t status;\n        status = GET_SSL_STATUS(ds);\n#if DTLS_DEBUG\n        pj_perror(2, ds->base.name, status, \"BIO_write() error\");\n#endif\n        DTLS_UNLOCK(ds);\n        return status;\n    }\n\n    if (!ds->ossl_ssl[idx]) {\n        DTLS_UNLOCK(ds);\n        return PJ_EGONE;\n    }\n\n    /* Consume (and ignore) the packet */\n    while (1) {\n        int rc = SSL_read(ds->ossl_ssl[idx], tmp, sizeof(tmp));\n        if (rc <= 0) {\n#if DTLS_DEBUG\n            pj_status_t status = GET_SSL_STATUS(ds);\n            if (status != PJ_SUCCESS)\n                pj_perror(2, ds->base.name, status, \"SSL_read() error\");\n#endif\n            break;\n        }\n    }\n\n    DTLS_UNLOCK(ds);\n\n    /* Flush anything pending in the write BIO */\n    return ssl_flush_wbio(ds, idx);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "FdOutStream::FdOutStream(int fd_, bool blocking_, int timeoutms_, int bufSize_)\n  : fd(fd_), blocking(blocking_), timeoutms(timeoutms_),\n    bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)\n{\n  ptr = start = sentUpTo = new U8[bufSize];\n  end = start + bufSize;\n\n  gettimeofday(&lastWrite, NULL);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "FdOutStream::FdOutStream(int fd_, bool blocking_, int timeoutms_, size_t bufSize_)\n  : fd(fd_), blocking(blocking_), timeoutms(timeoutms_),\n    bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)\n{\n  ptr = start = sentUpTo = new U8[bufSize];\n  end = start + bufSize;\n\n  gettimeofday(&lastWrite, NULL);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static ssize_t _hostfs_pwrite(\n    oe_fd_t* desc,\n    const void* buf,\n    size_t count,\n    oe_off_t offset)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_pwrite_ocall(&ret, file->host_fd, buf, count, offset) !=\n        OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static ssize_t _hostfs_pwrite(\n    oe_fd_t* desc,\n    const void* buf,\n    size_t count,\n    oe_off_t offset)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    /*\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/pwrite.html\n     * for more detail.\n     */\n    if (!file || count > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_pwrite_ocall(&ret, file->host_fd, buf, count, offset) !=\n        OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed count.\n     */\n    if (ret > (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void HeaderTable::setCapacity(uint32_t capacity) {\n  auto oldCapacity = capacity_;\n  capacity_ = capacity;\n  if (capacity_ <= oldCapacity) {\n    evict(0);\n  } else {\n    auto oldTail = tail();\n    auto oldLength = table_.size();\n    uint32_t newLength = (capacity_ >> 5) + 1;\n    table_.resize(newLength);\n    if (size_ > 0 && oldTail > head_) {\n      // the list wrapped around, need to move oldTail..oldLength to the end of\n      // the now-larger table_\n      std::copy(table_.begin() + oldTail, table_.begin() + oldLength,\n                table_.begin() + newLength - (oldLength - oldTail));\n      // Update the names indecies that pointed to the old range\n      for (auto& names_it: names_) {\n        for (auto& idx: names_it.second) {\n          if (idx >= oldTail) {\n            DCHECK_LT(idx + (table_.size() - oldLength), table_.size());\n            idx += (table_.size() - oldLength);\n          } else {\n            // remaining indecies in the list were smaller than oldTail, so\n            // should be indexed from 0\n            break;\n          }\n        }\n      }\n    }\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void HeaderTable::setCapacity(uint32_t capacity) {\n  // TODO: ddmello - the below is a little dangerous as we update the\n  // capacity right away.  Some properties of the class utilize that variable\n  // and so might be better to refactor and update capacity at the end of the\n  // method (and update other methods)\n  auto oldCapacity = capacity_;\n  capacity_ = capacity;\n  if (capacity_ == oldCapacity) {\n    return;\n  } else if (capacity_ < oldCapacity) {\n    // NOTE: currently no actual resizing is performed...\n    evict(0);\n  } else {\n    // NOTE: due to the above lack of resizing, we must determine whether a\n    // resize is actually appropriate (to handle cases where the underlying\n    // vector is still >= to the size related to the new capacity requested)\n    uint32_t newLength = (capacity_ >> 5) + 1;\n    if (newLength > table_.size()) {\n      auto oldTail = tail();\n      auto oldLength = table_.size();\n      table_.resize(newLength);\n      if (size_ > 0 && oldTail > head_) {\n        // the list wrapped around, need to move oldTail..oldLength to the end\n        // of the now-larger table_\n        std::copy(table_.begin() + oldTail, table_.begin() + oldLength,\n                  table_.begin() + newLength - (oldLength - oldTail));\n        // Update the names indecies that pointed to the old range\n        for (auto& names_it: names_) {\n          for (auto& idx: names_it.second) {\n            if (idx >= oldTail) {\n              DCHECK_LT(idx + (table_.size() - oldLength), table_.size());\n              idx += (table_.size() - oldLength);\n            } else {\n              // remaining indecies in the list were smaller than oldTail, so\n              // should be indexed from 0\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\n\t/* Switch off the timer when it_value is zero */\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\n\t/* Switch off the timer when it_value is zero */\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = timr->it_sigev_notify == SIGEV_NONE;\n\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "Status TensorSliceWriter::SaveData(const T* data, int64_t num_elements,\n                                   SavedSlice* ss) {\n  size_t size_bound =\n      ss->ByteSize() + kTensorProtoHeaderBytes +\n      (MaxBytesPerElement(DataTypeToEnum<T>::value) * num_elements);\n  if (size_bound > kMaxMessageBytes) {\n    return errors::InvalidArgument(\n        \"Tensor slice is too large to serialize (conservative estimate: \",\n        size_bound, \" bytes)\");\n  }\n  Fill(data, num_elements, ss->mutable_data());\n  DCHECK_GE(ss->ByteSize(), 0);\n  DCHECK_LE(ss->ByteSize(), size_bound);\n  return OkStatus();\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "Status TensorSliceWriter::SaveData(const T* data, int64_t num_elements,\n                                   SavedSlice* ss) {\n  size_t max_bytes_per_element =\n      MaxBytesPerElementOrZero(DataTypeToEnum<T>::value);\n  if (max_bytes_per_element == 0) {\n    return errors::InvalidArgument(\n        \"Tensor slice serialization not implemented for dtype \",\n        DataTypeToEnum<T>::value);\n  }\n  size_t size_bound = ss->ByteSize() + kTensorProtoHeaderBytes +\n                      (max_bytes_per_element * num_elements);\n  if (size_bound > kMaxMessageBytes) {\n    return errors::InvalidArgument(\n        \"Tensor slice is too large to serialize (conservative estimate: \",\n        size_bound, \" bytes)\");\n  }\n  Fill(data, num_elements, ss->mutable_data());\n  DCHECK_GE(ss->ByteSize(), 0);\n  DCHECK_LE(ss->ByteSize(), size_bound);\n  return OkStatus();\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\tnow = ast_tvnow();\n\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x >= TRUNK_CALL_START) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\tint start, found = 0;\n\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\n\t\tnow = ast_tvnow();\n\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n\t\tfor (x = start; 1; x++) {\n\t\t\tif (x == TRUNK_CALL_START) {\n\t\t\t\tx = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\t\n\t\t\tif (x == start - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x == start - 1 && !found) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static RList *symbols(RBinFile *bf) {\n\tRList *res = r_list_newf ((RListFree)r_bin_symbol_free);\n\tr_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tHtUU *hash = ht_uu_new0 ();\n\tif (!hash) {\n\t\treturn res;\n\t}\n\tbool found = false;\n\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\tRCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tht_uu_find (hash, sym->paddr, &found);\n\t\tif (found) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\tif (s) {\n\t\t\tr_list_append (res, s);\n\t\t\tht_uu_insert (hash, sym->paddr, 1);\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &element->symbols[i];\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static RList *symbols(RBinFile *bf) {\n\tr_return_val_if_fail (bf && bf->o && bf->o->bin_obj, NULL);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tHtUU *hash = ht_uu_new0 ();\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\tRList *res = r_list_newf ((RListFree)r_bin_symbol_free);\n\tbool found = false;\n\tif (element->lined_symbols) {\n\t\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n\t\t\tif (!sym) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t\tht_uu_insert (hash, sym->paddr, 1);\n\t\t\t}\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &element->symbols[i];\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void FileBody::Dump(std::ostream& os, const std::string& prefix) const {\n  os << prefix << \"<file: \" << path_.string() << \">\" << std::endl;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void FileBody::Dump(std::ostream& os, const std::string& prefix) const {\n  os << prefix << \"<file: \" << path_.u8string() << \">\" << std::endl;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  void SetUp() override {\n    env_ = std::make_unique<FakeClockEnv>(Env::Default());\n    tfdataz_metrics_ = std::make_unique<TfDatazMetricsCollector>(*env_);\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  void SetUp() override {\n    env_ = std::make_unique<FakeClockEnv>(Env::Default());\n    tfdataz_metrics_ =\n        std::make_unique<TfDatazMetricsCollector>(*env_, iterator_.get());\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "Http::FilterTrailersStatus Context::onResponseTrailers() {\n  if (!wasm_->onResponseTrailers_) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  if (wasm_->onResponseTrailers_(this, id_).u64_ == 0) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  return Http::FilterTrailersStatus::StopIteration;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "Http::FilterTrailersStatus Context::onResponseTrailers() {\n  if (!in_vm_context_created_ || !wasm_->onResponseTrailers_) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  if (wasm_->onResponseTrailers_(this, id_).u64_ == 0) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  return Http::FilterTrailersStatus::StopIteration;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "generic_ret *init_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static generic_ret         ret;\n    gss_buffer_desc            client_name,\n        service_name;\n    kadm5_server_handle_t      handle;\n    OM_uint32                  minor_stat;\n    const char                 *errmsg = NULL;\n    size_t clen, slen;\n    char *cdots, *sdots;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n                                   \"client=%.*s%s, service=%.*s%s, addr=%s, \"\n                                   \"vers=%d, flavor=%d\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     errmsg ? errmsg : _(\"success\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     (int)slen, (char *)service_name.value, sdots,\n                     client_addr(rqstp->rq_xprt),\n                     ret.api_version & ~(KADM5_API_VERSION_MASK),\n                     rqstp->rq_cred.oa_flavor);\n    if (errmsg != NULL)\n        krb5_free_error_message(NULL, errmsg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n\nexit_func:\n    return(&ret);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "generic_ret *init_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static generic_ret         ret;\n    gss_buffer_desc            client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc            service_name = GSS_C_EMPTY_BUFFER;\n    kadm5_server_handle_t      handle;\n    OM_uint32                  minor_stat;\n    const char                 *errmsg = NULL;\n    size_t clen, slen;\n    char *cdots, *sdots;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n                                   \"vers=%d, flavor=%d\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     errmsg ? errmsg : _(\"success\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     (int)slen, (char *)service_name.value, sdots,\n                     client_addr(rqstp->rq_xprt),\n                     ret.api_version & ~(KADM5_API_VERSION_MASK),\n                     rqstp->rq_cred.oa_flavor);\n    if (errmsg != NULL)\n        krb5_free_error_message(NULL, errmsg);\n\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    return(&ret);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void enc624j600UpdateMacConfig(NetInterface *interface)\n{\n   uint16_t duplexMode;\n\n   //Determine the new duplex mode by reading the PHYDPX bit\n   duplexMode = enc624j600ReadReg(interface, ENC624J600_REG_ESTAT) & ESTAT_PHYDPX;\n\n   //Full-duplex mode?\n   if(duplexMode)\n   {\n      //Configure the FULDPX bit to match the current duplex mode\n      enc624j600WriteReg(interface, ENC624J600_REG_MACON2, MACON2_DEFER |\n         MACON2_PADCFG2 | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1 | MACON2_FULDPX);\n      //Configure the Back-to-Back Inter-Packet Gap register\n      enc624j600WriteReg(interface, ENC624J600_REG_MABBIPG, 0x15);\n   }\n   //Half-duplex mode?\n   else\n   {\n      //Configure the FULDPX bit to match the current duplex mode\n      enc624j600WriteReg(interface, ENC624J600_REG_MACON2, MACON2_DEFER |\n         MACON2_PADCFG2 | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1);\n      //Configure the Back-to-Back Inter-Packet Gap register\n      enc624j600WriteReg(interface, ENC624J600_REG_MABBIPG, 0x12);\n   }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void enc624j600UpdateMacConfig(NetInterface *interface)\n{\n   uint16_t duplexMode;\n\n   //Determine the new duplex mode by reading the PHYDPX bit\n   duplexMode = enc624j600ReadReg(interface, ENC624J600_ESTAT) & ENC624J600_ESTAT_PHYDPX;\n\n   //Full-duplex mode?\n   if(duplexMode)\n   {\n      //Configure the FULDPX bit to match the current duplex mode\n      enc624j600WriteReg(interface, ENC624J600_MACON2, ENC624J600_MACON2_DEFER |\n         ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN |\n         ENC624J600_MACON2_R1_DEFAULT | ENC624J600_MACON2_FULDPX);\n\n      //Configure the Back-to-Back Inter-Packet Gap register\n      enc624j600WriteReg(interface, ENC624J600_MABBIPG,\n         ENC624J600_MABBIPG_BBIPG_DEFAULT_FD);\n   }\n   //Half-duplex mode?\n   else\n   {\n      //Configure the FULDPX bit to match the current duplex mode\n      enc624j600WriteReg(interface, ENC624J600_MACON2, ENC624J600_MACON2_DEFER |\n         ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN |\n         ENC624J600_MACON2_R1_DEFAULT);\n\n      //Configure the Back-to-Back Inter-Packet Gap register\n      enc624j600WriteReg(interface, ENC624J600_MABBIPG,\n         ENC624J600_MABBIPG_BBIPG_DEFAULT_HD);\n   }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\nint read_escaped_char(\n    yyscan_t yyscanner,\n    uint8_t* escaped_char)\n{\n  char text[4] = {0, 0, 0, 0};\n\n  text[0] = '\\\\';\n  text[1] = RE_YY_INPUT(yyscanner);\n\n  if (text[1] == EOF)\n    return 0;\n\n  if (text[1] == 'x')\n  {\n    text[2] = RE_YY_INPUT(yyscanner);\n\n    if (text[2] == EOF)\n      return 0;\n\n    text[3] = RE_YY_INPUT(yyscanner);\n\n    if (text[3] == EOF)\n      return 0;\n  }\n\n  *escaped_char = escaped_char_value(text);\n\n  return 1;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\nint read_escaped_char(\n    yyscan_t yyscanner,\n    uint8_t* escaped_char)\n{\n  char text[4] = {0, 0, 0, 0};\n\n  text[0] = '\\\\';\n  text[1] = RE_YY_INPUT(yyscanner);\n\n  if (text[1] == EOF || text[1] == 0)\n    return 0;\n\n  if (text[1] == 'x')\n  {\n    text[2] = RE_YY_INPUT(yyscanner);\n\n    if (!isxdigit(text[2]))\n      return 0;\n\n    text[3] = RE_YY_INPUT(yyscanner);\n\n    if (!isxdigit(text[3]))\n      return 0;\n  }\n\n  *escaped_char = escaped_char_value(text);\n\n  return 1;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun;\n\tvoid __user* argp = (void __user*)arg;\n\tstruct sock_fprog fprog;\n\tstruct ifreq ifr;\n\tint sndbuf;\n\tint vnet_hdr_sz;\n\tint ret;\n\n\tif (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89)\n\t\tif (copy_from_user(&ifr, argp, ifreq_len))\n\t\t\treturn -EFAULT;\n\n\tif (cmd == TUNGETFEATURES) {\n\t\t/* Currently this just means: \"what IFF flags are valid?\".\n\t\t * This is needed because we never checked for invalid flags on\n\t\t * TUNSETIFF. */\n\t\treturn put_user(IFF_TUN | IFF_TAP | IFF_NO_PI | IFF_ONE_QUEUE |\n\t\t\t\tIFF_VNET_HDR,\n\t\t\t\t(unsigned int __user*)argp);\n\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun;\n\tvoid __user* argp = (void __user*)arg;\n\tstruct sock_fprog fprog;\n\tstruct ifreq ifr;\n\tint sndbuf;\n\tint vnet_hdr_sz;\n\tint ret;\n\n\tif (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89) {\n\t\tif (copy_from_user(&ifr, argp, ifreq_len))\n\t\t\treturn -EFAULT;\n\t} else\n\t\tmemset(&ifr, 0, sizeof(ifr));\n\n\tif (cmd == TUNGETFEATURES) {\n\t\t/* Currently this just means: \"what IFF flags are valid?\".\n\t\t * This is needed because we never checked for invalid flags on\n\t\t * TUNSETIFF. */\n\t\treturn put_user(IFF_TUN | IFF_TAP | IFF_NO_PI | IFF_ONE_QUEUE |\n\t\t\t\tIFF_VNET_HDR,\n\t\t\t\t(unsigned int __user*)argp);\n\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      // are simplified to NDIMS==1 case.\n      //\n      // Because this optimization increases the binary size for each\n      // Functor (+, -, *, /, <, <=, etc.), type and ndim combination.\n      // we only apply such optimization for selected ops/types/ndims.\n      //\n      // Because NDIMS, Functor::use_broadcast_optimization and\n      // use_broadcast_optimization<T> are compile-time constant, gcc\n      // does a decent job avoiding generating code when conditions\n      // are not met.\n      const int a = in0.dimension(0);  // in0 is shape [a, b]\n      const int b = in0.dimension(1);\n      const int c = in1.dimension(0);  // in1 is shape [c, d]\n      const int d = in1.dimension(1);\n      if ((a == 1) && (d == 1)) {\n        auto lhs = in0.reshape(OneByM(b)).broadcast(NByOne(c));\n        auto rhs = in1.reshape(NByOne(c)).broadcast(OneByM(b));\n        Assign(dev, out, lhs.binaryExpr(rhs, func));\n        return;\n      }\n      if ((b == 1) && (c == 1)) {\n        auto lhs = in0.reshape(NByOne(a)).broadcast(OneByM(d));\n        auto rhs = in1.reshape(OneByM(d)).broadcast(NByOne(a));\n        Assign(dev, out, lhs.binaryExpr(rhs, func));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      // are simplified to NDIMS==1 case.\n      //\n      // Because this optimization increases the binary size for each\n      // Functor (+, -, *, /, <, <=, etc.), type and ndim combination.\n      // we only apply such optimization for selected ops/types/ndims.\n      //\n      // Because NDIMS, Functor::use_broadcast_optimization and\n      // use_broadcast_optimization<T> are compile-time constant, gcc\n      // does a decent job avoiding generating code when conditions\n      // are not met.\n      const Eigen::DenseIndex a = in0.dimension(0);  // in0 is shape [a, b]\n      const Eigen::DenseIndex b = in0.dimension(1);\n      const Eigen::DenseIndex c = in1.dimension(0);  // in1 is shape [c, d]\n      const Eigen::DenseIndex d = in1.dimension(1);\n      if ((a == 1) && (d == 1)) {\n        auto lhs = in0.reshape(OneByM(b)).broadcast(NByOne(c));\n        auto rhs = in1.reshape(NByOne(c)).broadcast(OneByM(b));\n        Assign(dev, out, lhs.binaryExpr(rhs, func));\n        return;\n      }\n      if ((b == 1) && (c == 1)) {\n        auto lhs = in0.reshape(NByOne(a)).broadcast(OneByM(d));\n        auto rhs = in1.reshape(OneByM(d)).broadcast(NByOne(a));\n        Assign(dev, out, lhs.binaryExpr(rhs, func));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "#endif\n    int\t\tts = wp->w_buffer->b_p_ts;\n    int\t\tc;\n\n    vcol = 0;\n    line = ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);\n    if (pos->col == MAXCOL)\n\tposptr = NULL;  // continue until the NUL\n    else\n    {\n\t// Special check for an empty line, which can happen on exit, when\n\t// ml_get_buf() always returns an empty string.\n\tif (*ptr == NUL)\n\t    pos->col = 0;\n\tposptr = ptr + pos->col;\n\tif (has_mbyte)\n\t    // always start on the first byte\n\t    posptr -= (*mb_head_off)(line, posptr);\n    }\n\n    /*\n     * This function is used very often, do some speed optimizations.\n     * When 'list', 'linebreak', 'showbreak' and 'breakindent' are not set\n     * use a simple loop.",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "#endif\n    int\t\tts = wp->w_buffer->b_p_ts;\n    int\t\tc;\n\n    vcol = 0;\n    line = ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);\n    if (pos->col == MAXCOL)\n\tposptr = NULL;  // continue until the NUL\n    else\n    {\n\tcolnr_T i;\n\n\t// In a few cases the position can be beyond the end of the line.\n\tfor (i = 0; i < pos->col; ++i)\n\t    if (ptr[i] == NUL)\n\t    {\n\t\tpos->col = i;\n\t\tbreak;\n\t    }\n\tposptr = ptr + pos->col;\n\tif (has_mbyte)\n\t    // always start on the first byte\n\t    posptr -= (*mb_head_off)(line, posptr);\n    }\n\n    /*\n     * This function is used very often, do some speed optimizations.\n     * When 'list', 'linebreak', 'showbreak' and 'breakindent' are not set\n     * use a simple loop.",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int btrfs_get_dev_stats(struct btrfs_fs_info *fs_info,\n\t\t\tstruct btrfs_ioctl_get_dev_stats *stats)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tint i;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, stats->devid, NULL, NULL);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tif (!dev) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, device not found\");\n\t\treturn -ENODEV;\n\t} else if (!dev->dev_stats_valid) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, not yet valid\");\n\t\treturn -ENODEV;\n\t} else if (stats->flags & BTRFS_DEV_STATS_RESET) {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int btrfs_get_dev_stats(struct btrfs_fs_info *fs_info,\n\t\t\tstruct btrfs_ioctl_get_dev_stats *stats)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tint i;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, stats->devid, NULL, NULL,\n\t\t\t\ttrue);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tif (!dev) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, device not found\");\n\t\treturn -ENODEV;\n\t} else if (!dev->dev_stats_valid) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, not yet valid\");\n\t\treturn -ENODEV;\n\t} else if (stats->flags & BTRFS_DEV_STATS_RESET) {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n\t\t\t\t       size_t len)\n{\n\tuaddr_t a;\n\tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n\t\t\t       CORE_MMU_USER_PARAM_SIZE);\n\n\tif (ADD_OVERFLOW(uaddr, len, &a))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t/*\n\t * Rely on TA private memory test to check if address range is private\n\t * to TA or not.\n\t */\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n\t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\tfor (a = uaddr; a < (uaddr + len); a += addr_incr) {\n\t\tuint32_t attr;\n\t\tTEE_Result res;\n\n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n\t\t\t\t       size_t len)\n{\n\tuaddr_t a;\n\tuaddr_t end_addr = 0;\n\tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n\t\t\t       CORE_MMU_USER_PARAM_SIZE);\n\n\tif (ADD_OVERFLOW(uaddr, len, &end_addr))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t/*\n\t * Rely on TA private memory test to check if address range is private\n\t * to TA or not.\n\t */\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n\t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\tfor (a = ROUNDDOWN(uaddr, addr_incr); a < end_addr; a += addr_incr) {\n\t\tuint32_t attr;\n\t\tTEE_Result res;\n\n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "   * ri-record.\n   */\n  size_t subkey_lf = le32toh (nk->subkey_lf);\n  subkey_lf += 0x1000;\n  if (!IS_VALID_BLOCK (h, subkey_lf)) {\n    SET_ERRNO (EFAULT,\n               \"subkey_lf is not a valid block (0x%zx)\", subkey_lf);\n    goto error;\n  }\n\n  if (_get_children (h, subkey_lf, &children, &blocks, flags) == -1)\n    goto error;\n\n  /* Check the number of children we ended up reading matches\n   * nr_subkeys_in_nk.\n   */\n  size_t nr_children = _hivex_get_offset_list_length (&children);\n  if (nr_subkeys_in_nk != nr_children) {\n    if (!h->unsafe) {\n      SET_ERRNO (ENOTSUP,\n                 \"nr_subkeys_in_nk = %zu \"",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "   * ri-record.\n   */\n  size_t subkey_lf = le32toh (nk->subkey_lf);\n  subkey_lf += 0x1000;\n  if (!IS_VALID_BLOCK (h, subkey_lf)) {\n    SET_ERRNO (EFAULT,\n               \"subkey_lf is not a valid block (0x%zx)\", subkey_lf);\n    goto error;\n  }\n\n  if (_get_children (h, subkey_lf, &children, &blocks, flags, 0) == -1)\n    goto error;\n\n  /* Check the number of children we ended up reading matches\n   * nr_subkeys_in_nk.\n   */\n  size_t nr_children = _hivex_get_offset_list_length (&children);\n  if (nr_subkeys_in_nk != nr_children) {\n    if (!h->unsafe) {\n      SET_ERRNO (ENOTSUP,\n                 \"nr_subkeys_in_nk = %zu \"",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                                  \" : \", x.shape().DebugString(), \" vs. \",\n                                  v.shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, i.dim_size(0) == v.dim_size(0),\n                errors::InvalidArgument(\n                    \"i and x shape doesn't match at index 0: \",\n                    i.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n\n    Tensor y = x;  // This creates an alias intentionally.\n    // Skip processing if tensors are empty.\n    if (x.NumElements() > 0 || v.NumElements() > 0) {\n      OP_REQUIRES_OK(ctx, DoCompute(ctx, i, v, &y));\n    }\n    ctx->set_output(0, y);\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                                  \" : \", x.shape().DebugString(), \" vs. \",\n                                  v.shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, i.dim_size(0) == v.dim_size(0),\n                errors::InvalidArgument(\n                    \"i and x shape doesn't match at index 0: \",\n                    i.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n\n    Tensor y = x;  // This creates an alias intentionally.\n    // Skip processing if tensors are empty.\n    if (x.NumElements() > 0 && v.NumElements() > 0) {\n      OP_REQUIRES_OK(ctx, DoCompute(ctx, i, v, &y));\n    }\n    ctx->set_output(0, y);\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "untrusted_launcher_response_callback (GtkDialog                 *dialog,\n                                      int                        response_id,\n                                      ActivateParametersDesktop *parameters)\n{\n    GdkScreen *screen;\n    char *uri;\n    GFile *file;\n\n    switch (response_id)\n    {\n        case RESPONSE_RUN:\n        {\n            screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n            uri = nautilus_file_get_uri (parameters->file);\n            DEBUG (\"Launching untrusted launcher %s\", uri);\n            nautilus_launch_desktop_file (screen, uri, NULL,\n                                          parameters->parent_window);\n            g_free (uri);\n        }\n        break;\n\n        case RESPONSE_MARK_TRUSTED:\n        {\n            file = nautilus_file_get_location (parameters->file);\n            nautilus_file_mark_desktop_file_trusted (file,\n                                                     parameters->parent_window,\n                                                     TRUE,\n                                                     NULL, NULL);\n            g_object_unref (file);\n        }\n        break;\n\n        default:\n        {\n            /* Just destroy dialog */\n        }\n        break;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "untrusted_launcher_response_callback (GtkDialog                 *dialog,\n                                      int                        response_id,\n                                      ActivateParametersDesktop *parameters)\n{\n    GdkScreen *screen;\n    char *uri;\n    GFile *file;\n\n    switch (response_id)\n    {\n        case GTK_RESPONSE_OK:\n        {\n            file = nautilus_file_get_location (parameters->file);\n\n            /* We need to do this in order to prevent malicious desktop files\n             * with the executable bit already set.\n             * See https://bugzilla.gnome.org/show_bug.cgi?id=777991\n             */\n            nautilus_file_set_metadata (parameters->file, NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,\n                                        NULL,\n                                        \"yes\");\n\n            nautilus_file_mark_desktop_file_executable (file,\n                                                        parameters->parent_window,\n                                                        TRUE,\n                                                        NULL, NULL);\n\n            /* Need to force a reload of the attributes so is_trusted is marked\n             * correctly. Not sure why the general monitor doesn't fire in this\n             * case when setting the metadata\n             */\n            nautilus_file_invalidate_all_attributes (parameters->file);\n\n            screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n            uri = nautilus_file_get_uri (parameters->file);\n            DEBUG (\"Launching untrusted launcher %s\", uri);\n            nautilus_launch_desktop_file (screen, uri, NULL,\n                                          parameters->parent_window);\n            g_free (uri);\n            g_object_unref (file);\n        }\n        break;\n\n        default:\n        {\n            /* Just destroy dialog */\n        }\n        break;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t    authblob->Signature);\n\t\treturn -EINVAL;\n\t}\n\n\tnt_off = le32_to_cpu(authblob->NtChallengeResponse.BufferOffset);\n\tnt_len = le16_to_cpu(authblob->NtChallengeResponse.Length);\n\n\tdn_off = le32_to_cpu(authblob->DomainName.BufferOffset);\n\tdn_len = le16_to_cpu(authblob->DomainName.Length);\n\n\tif (blob_len < (u64)dn_off + dn_len || blob_len < (u64)nt_off + nt_len)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_SMB_INSECURE_SERVER\n\tlm_off = le32_to_cpu(authblob->LmChallengeResponse.BufferOffset);\n\tlm_len = le16_to_cpu(authblob->LmChallengeResponse.Length);\n\tif (blob_len < (u64)lm_off + lm_len)\n\t\treturn -EINVAL;\n\n\t/* process NTLM authentication */\n\tif (nt_len == CIFS_AUTH_RESP_SIZE) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t    authblob->Signature);\n\t\treturn -EINVAL;\n\t}\n\n\tnt_off = le32_to_cpu(authblob->NtChallengeResponse.BufferOffset);\n\tnt_len = le16_to_cpu(authblob->NtChallengeResponse.Length);\n\n\tdn_off = le32_to_cpu(authblob->DomainName.BufferOffset);\n\tdn_len = le16_to_cpu(authblob->DomainName.Length);\n\n\tif (blob_len < (u64)dn_off + dn_len || blob_len < (u64)nt_off + nt_len ||\n\t    nt_len < CIFS_ENCPWD_SIZE)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_SMB_INSECURE_SERVER\n\tlm_off = le32_to_cpu(authblob->LmChallengeResponse.BufferOffset);\n\tlm_len = le16_to_cpu(authblob->LmChallengeResponse.Length);\n\tif (blob_len < (u64)lm_off + lm_len)\n\t\treturn -EINVAL;\n\n\t/* process NTLM authentication */\n\tif (nt_len == CIFS_AUTH_RESP_SIZE) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int enable_trace_input(struct flb_hs *hs, const char *name, const char *prefix, const char *output_name, struct mk_list *props)\n{\n    struct flb_input_instance *in;\n\n\n    in = find_input(hs, name);\n    if (in == NULL) {\n        return 404;\n    }\n\n    flb_chunk_trace_context_new(in, output_name, prefix, NULL, props);\n    return (in->chunk_trace_ctxt == NULL ? 503 : 0);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int enable_trace_input(struct flb_hs *hs, const char *name, ssize_t nlen, const char *prefix,\n                              const char *output_name, struct mk_list *props)\n{\n    struct flb_input_instance *in;\n\n    in = find_input(hs, name, nlen);\n    if (in == NULL) {\n        flb_error(\"unable to find input: [%d]%.*s\", (int)nlen, (int)nlen, name);\n        return 404;\n    }\n\n    flb_chunk_trace_context_new(in, output_name, prefix, NULL, props);\n\n    if (in->chunk_trace_ctxt == NULL) {\n        flb_error(\"unable to start tracing\");\n        return 503;\n    }\n\n    return 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void Archive::Seek(int64 Offset,int Method)\n{\n  if (!QOpen.Seek(Offset,Method))\n    File::Seek(Offset,Method);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void Archive::Seek(int64 Offset,int Method)\n{\n#ifdef USE_QOPEN\n  if (QOpen.Seek(Offset,Method))\n    return;\n#endif\n#ifdef USE_ARCMEM\n  if (ArcMem.Seek(Offset,Method))\n    return;\n#endif\n  File::Seek(Offset,Method);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "test_make_inputs (xd3_stream *stream, xoff_t *ss_out, xoff_t *ts_out)\n{\n  usize_t ts = (mt_random (&static_mtrand) % TEST_FILE_MEAN) + TEST_FILE_MEAN / 2;\n  usize_t ss = (mt_random (&static_mtrand) % TEST_FILE_MEAN) + TEST_FILE_MEAN / 2;\n  uint8_t *buf = (uint8_t*) malloc (ts + ss), *sbuf = buf, *tbuf = buf + ss;\n  usize_t sadd = 0, sadd_max = (usize_t)(ss * TEST_ADD_RATIO);\n  FILE  *tf = NULL, *sf = NULL;\n  usize_t i, j;\n  int ret;\n\n  if (buf == NULL) { return ENOMEM; }\n\n  if ((tf = fopen (TEST_TARGET_FILE, \"w\")) == NULL ||\n      (ss_out != NULL && (sf = fopen (TEST_SOURCE_FILE, \"w\")) == NULL))",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "test_make_inputs (xd3_stream *stream, xoff_t *ss_out, xoff_t *ts_out)\n{\n  usize_t ts = (mt_random (&static_mtrand) % TEST_FILE_MEAN) +\n    TEST_FILE_MEAN / 2;\n  usize_t ss = (mt_random (&static_mtrand) % TEST_FILE_MEAN) +\n    TEST_FILE_MEAN / 2;\n  uint8_t *buf = (uint8_t*) malloc (ts + ss), *sbuf = buf, *tbuf = buf + ss;\n  usize_t sadd = 0, sadd_max = (usize_t)(ss * TEST_ADD_RATIO);\n  FILE  *tf = NULL, *sf = NULL;\n  usize_t i, j;\n  int ret;\n\n  if (buf == NULL) { return ENOMEM; }\n\n  if ((tf = fopen (TEST_TARGET_FILE, \"w\")) == NULL ||\n      (ss_out != NULL && (sf = fopen (TEST_SOURCE_FILE, \"w\")) == NULL))",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int fsmVerify(const char *path, rpmfi fi)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n\n    rc = fsmStat(path, 1, &dsb);\n    if (rc)\n\treturn rc;\n\n\trc = fsmRename(path, rmpath);\n\t/* XXX shouldn't we take unlink return code here? */\n\tif (!rc)\n\t    (void) fsmUnlink(rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n            rc = fsmStat(path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n            if (S_ISDIR(dsb.st_mode)) return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int fsmVerify(const char *path, rpmfi fi, const struct stat *fsb)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n\n    rc = fsmStat(path, 1, &dsb);\n    if (rc)\n\treturn rc;\n\n\t/* XXX shouldn't we take unlink return code here? */\n\tif (!rc)\n\t    (void) fsmUnlink(rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n\t    uid_t luid = dsb.st_uid;\n            rc = fsmStat(path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n\t    /* Only permit directory symlinks by target owner and root */\n            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == fsb->st_uid))\n\t\t    return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\tbreak;\n\t\t\tcase SC_FILE_TYPE_INTERNAL_EF:   /* EF for RSA keys */\n\t\t\t\tp_idx = efi_idx;\n\t\t\t\tbreak;\n\t\t\tdefault:                         /* EF */\n\t\t\t\tp_idx = ef_idx;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Encryption key present ? */\n\t\t\tiPinCount = iACLen - 1;\t\t\n\n\t\t\tif (buf[iOffset] & 0x20) {\n\t\t\t\tint iSC;\n\t\t\t\tif (len < 1 + (size_t)iACLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiSC = buf[iOffset + iACLen];\n\n\t\t\t\tswitch( (iSC>>5) & 0x03 ) {\n\t\t\t\tcase 0:\n\t\t\t\t\tiMethod = SC_AC_TERM;\t\t/* key authentication */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\tbreak;\n\t\t\tcase SC_FILE_TYPE_INTERNAL_EF:   /* EF for RSA keys */\n\t\t\t\tp_idx = efi_idx;\n\t\t\t\tbreak;\n\t\t\tdefault:                         /* EF */\n\t\t\t\tp_idx = ef_idx;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Encryption key present ? */\n\t\t\tiPinCount = iACLen > 0 ? iACLen - 1 : 0;\n\n\t\t\tif (buf[iOffset] & 0x20) {\n\t\t\t\tint iSC;\n\t\t\t\tif (len < 1 + (size_t)iACLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiSC = buf[iOffset + iACLen];\n\n\t\t\t\tswitch( (iSC>>5) & 0x03 ) {\n\t\t\t\tcase 0:\n\t\t\t\t\tiMethod = SC_AC_TERM;\t\t/* key authentication */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void unix_notinflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tspin_lock(&unix_gc_lock);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tBUG_ON(list_empty(&u->link));\n\n\t\tif (atomic_long_dec_and_test(&u->inflight))\n\t\t\tlist_del_init(&u->link);\n\t\tunix_tot_inflight--;\n\t}\n\tfp->f_cred->user->unix_inflight--;\n\tspin_unlock(&unix_gc_lock);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void unix_notinflight(struct user_struct *user, struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tspin_lock(&unix_gc_lock);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tBUG_ON(list_empty(&u->link));\n\n\t\tif (atomic_long_dec_and_test(&u->inflight))\n\t\t\tlist_del_init(&u->link);\n\t\tunix_tot_inflight--;\n\t}\n\tuser->unix_inflight--;\n\tspin_unlock(&unix_gc_lock);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\tlogit(NSLOG_CONFIG_ERROR, TRUE, \"Error: Failed to process config file '%s'. Aborting\\n\", config_file);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\ttiming_point(\"Main config file read\\n\");\n\n\t\t\t/* NOTE 11/06/07 EG moved to after we read config files, as user may have overridden timezone offset */\n\t\t\t/* get program (re)start time and save as macro */\n\t\t\tprogram_start = time(NULL);\n\t\t\tmy_free(mac->x[MACRO_PROCESSSTARTTIME]);\n\t\t\tasprintf(&mac->x[MACRO_PROCESSSTARTTIME], \"%llu\", (unsigned long long)program_start);\n\n\t\t\t/* drop privileges */\n\t\t\tif(drop_privileges(nagios_user, nagios_group) == ERROR) {\n\n\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, \"Failed to drop privileges.  Aborting.\");\n\n\t\t\t\tcleanup();\n\t\t\t\texit(ERROR);\n\t\t\t\t}\n\n\t\t\tif (test_path_access(nagios_binary_path, X_OK)) {\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: failed to access() %s: %s\\n\", nagios_binary_path, strerror(errno));\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Spawning workers will be impossible. Aborting.\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\n\t\t\tif (test_configured_paths() == ERROR) {\n\t\t\t\t/* error has already been logged */\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t/* enter daemon mode (unless we're restarting...) */\n\t\t\tif(daemon_mode == TRUE && sigrestart == FALSE) {\n\n\t\t\t\tresult = daemon_init();\n\n\t\t\t\t/* we had an error daemonizing, so bail... */\n\t\t\t\tif(result == ERROR) {\n\t\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, \"Bailing out due to failure to daemonize. (PID=%d)\", (int)getpid());\n\t\t\t\t\tcleanup();\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t\t}\n\n\t\t\t\t/* get new PID */\n\t\t\t\tnagios_pid = (int)getpid();\n\t\t\t\t}\n\n\t\t\t/* this must be logged after we read config data, as user may have changed location of main log file */\n\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Nagios %s starting... (PID=%d)\\n\", PROGRAM_VERSION, (int)getpid());\n\n\t\t\t/* log the local time - may be different than clock time due to timezone offset */\n\t\t\tnow = time(NULL);\n\t\t\ttm = localtime_r(&now, &tm_s);\n\t\t\tstrftime(datestring, sizeof(datestring), \"%a %b %d %H:%M:%S %Z %Y\", tm);\n\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Local time is %s\", datestring);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\tlogit(NSLOG_CONFIG_ERROR, TRUE, \"Error: Failed to process config file '%s'. Aborting\\n\", config_file);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\ttiming_point(\"Main config file read\\n\");\n\n\t\t\t/* NOTE 11/06/07 EG moved to after we read config files, as user may have overridden timezone offset */\n\t\t\t/* get program (re)start time and save as macro */\n\t\t\tprogram_start = time(NULL);\n\t\t\tmy_free(mac->x[MACRO_PROCESSSTARTTIME]);\n\t\t\tasprintf(&mac->x[MACRO_PROCESSSTARTTIME], \"%llu\", (unsigned long long)program_start);\n\t\t\t\n\t\t\t/* enter daemon mode (unless we're restarting...) */\n\t\t\tif(daemon_mode == TRUE && sigrestart == FALSE) {\n\n\t\t\t\tresult = daemon_init();\n\n\t\t\t\t/* we had an error daemonizing, so bail... */\n\t\t\t\tif(result == ERROR) {\n\t\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, \"Bailing out due to failure to daemonize. (PID=%d)\", (int)getpid());\n\t\t\t\t\tcleanup();\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t\t}\n\n\t\t\t\t/* get new PID */\n\t\t\t\tnagios_pid = (int)getpid();\n\t\t\t\t}\n\n\t\t\t/* drop privileges */\n\t\t\tif(drop_privileges(nagios_user, nagios_group) == ERROR) {\n\n\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, \"Failed to drop privileges.  Aborting.\");\n\n\t\t\t\tcleanup();\n\t\t\t\texit(ERROR);\n\t\t\t\t}\n\n\t\t\tif (test_path_access(nagios_binary_path, X_OK)) {\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: failed to access() %s: %s\\n\", nagios_binary_path, strerror(errno));\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Spawning workers will be impossible. Aborting.\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\n\t\t\tif (test_configured_paths() == ERROR) {\n\t\t\t\t/* error has already been logged */\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\n\t\t\t/* this must be logged after we read config data, as user may have changed location of main log file */\n\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Nagios %s starting... (PID=%d)\\n\", PROGRAM_VERSION, (int)getpid());\n\n\t\t\t/* log the local time - may be different than clock time due to timezone offset */\n\t\t\tnow = time(NULL);\n\t\t\ttm = localtime_r(&now, &tm_s);\n\t\t\tstrftime(datestring, sizeof(datestring), \"%a %b %d %H:%M:%S %Z %Y\", tm);\n\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Local time is %s\", datestring);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tpipe_unlock(pipe);\n\t\treturn -ENOMEM;\n\t}\n\n\tnbuf = 0;\n\trem = 0;\n\tfor (idx = 0; idx < pipe->nrbufs && rem < len; idx++)\n\t\trem += pipe->bufs[(pipe->curbuf + idx) & (pipe->buffers - 1)].len;\n\n\tret = -EINVAL;\n\tif (rem < len) {\n\t\tpipe_unlock(pipe);\n\t\tgoto out;\n\t}\n\n\trem = len;\n\twhile (rem) {\n\t\tstruct pipe_buffer *ibuf;\n\t\tstruct pipe_buffer *obuf;\n\n\t\tBUG_ON(nbuf >= pipe->buffers);\n\t\tBUG_ON(!pipe->nrbufs);\n\t\tibuf = &pipe->bufs[pipe->curbuf];\n\t\tobuf = &bufs[nbuf];\n\n\t\tif (rem >= ibuf->len) {\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t} else {\n\t\t\tpipe_buf_get(pipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\t\tobuf->len = rem;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tnbuf++;\n\t\trem -= obuf->len;\n\t}\n\tpipe_unlock(pipe);\n\tfuse_copy_init(&cs, 0, NULL);\n\tcs.pipebufs = bufs;\n\tcs.nr_segs = nbuf;\n\tcs.pipe = pipe;\n\n\tif (flags & SPLICE_F_MOVE)\n\t\tcs.move_pages = 1;\n\n\tret = fuse_dev_do_write(fud, &cs, len);\n\n\tpipe_lock(pipe);\n\tfor (idx = 0; idx < nbuf; idx++)\n\t\tpipe_buf_release(pipe, &bufs[idx]);\n\tpipe_unlock(pipe);\n\nout:\n\tkvfree(bufs);\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tpipe_unlock(pipe);\n\t\treturn -ENOMEM;\n\t}\n\n\tnbuf = 0;\n\trem = 0;\n\tfor (idx = 0; idx < pipe->nrbufs && rem < len; idx++)\n\t\trem += pipe->bufs[(pipe->curbuf + idx) & (pipe->buffers - 1)].len;\n\n\tret = -EINVAL;\n\tif (rem < len)\n\t\tgoto out_free;\n\n\trem = len;\n\twhile (rem) {\n\t\tstruct pipe_buffer *ibuf;\n\t\tstruct pipe_buffer *obuf;\n\n\t\tBUG_ON(nbuf >= pipe->buffers);\n\t\tBUG_ON(!pipe->nrbufs);\n\t\tibuf = &pipe->bufs[pipe->curbuf];\n\t\tobuf = &bufs[nbuf];\n\n\t\tif (rem >= ibuf->len) {\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t} else {\n\t\t\tif (!pipe_buf_get(pipe, ibuf))\n\t\t\t\tgoto out_free;\n\n\t\t\t*obuf = *ibuf;\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\t\tobuf->len = rem;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tnbuf++;\n\t\trem -= obuf->len;\n\t}\n\tpipe_unlock(pipe);\n\tcs.pipebufs = bufs;\n\tcs.nr_segs = nbuf;\n\tcs.pipe = pipe;\n\n\tif (flags & SPLICE_F_MOVE)\n\t\tcs.move_pages = 1;\n\n\tret = fuse_dev_do_write(fud, &cs, len);\n\n\tpipe_lock(pipe);\nout_free:\n\tfor (idx = 0; idx < nbuf; idx++)\n\t\tpipe_buf_release(pipe, &bufs[idx]);\n\tpipe_unlock(pipe);\n\n\tkvfree(bufs);\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void deletesuccessor(file_t **existing, file_t *duplicate, int matchconfirmed,\n      int (*comparef)(file_t *f1, file_t *f2), struct log_info *loginfo)\n{\n  file_t *to_keep;\n  file_t *to_delete;\n\n  if (comparef(duplicate, *existing) >= 0)\n  {\n    to_keep = *existing;\n    to_delete = duplicate;\n  }\n  else\n  {\n    to_keep = duplicate;\n    to_delete = *existing;\n  if (loginfo)\n    log_begin_set(loginfo);\n\n  printf(\"   [+] %s\\n\", to_keep->d_name);\n\n  if (loginfo)\n    log_file_remaining(loginfo, to_keep->d_name);\n\n  if (matchconfirmed)\n  {\n    if (remove(to_delete->d_name) == 0) {\n      printf(\"   [-] %s\\n\", to_delete->d_name);\n\n      if (loginfo)\n        log_file_deleted(loginfo, to_delete->d_name);\n    } else {\n      printf(\"   [!] %s \", to_delete->d_name);\n      printf(\"-- unable to delete file!\\n\");\n\n      if (loginfo)\n        log_file_remaining(loginfo, to_delete->d_name);\n    }\n  }\n  else\n  {\n    printf(\"   [!] %s\\n\", to_delete->d_name);\n    printf(\" -- unable to confirm match; file not deleted!\\n\");\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void deletesuccessor(file_t **existing, file_t *duplicate, int matchconfirmed,\n      int (*comparef)(file_t *f1, file_t *f2), struct log_info *loginfo)\n{\n  file_t *to_keep;\n  file_t *to_delete;\n  char *errorstring;\n\n  if (comparef(duplicate, *existing) >= 0)\n  {\n    to_keep = *existing;\n    to_delete = duplicate;\n  }\n  else\n  {\n    to_keep = duplicate;\n    to_delete = *existing;\n  if (loginfo)\n    log_begin_set(loginfo);\n\n  printf(\"   [+] %s\\n\", to_keep->d_name);\n\n  if (loginfo)\n    log_file_remaining(loginfo, to_keep->d_name);\n\n  if (matchconfirmed)\n  {\n    if (removeifnotchanged(to_delete, &errorstring) == 0) {\n      printf(\"   [-] %s\\n\", to_delete->d_name);\n\n      if (loginfo)\n        log_file_deleted(loginfo, to_delete->d_name);\n    } else {\n      printf(\"   [!] %s \", to_delete->d_name);\n      printf(\"-- unable to delete file: %s!\\n\", errorstring);\n\n      if (loginfo)\n        log_file_remaining(loginfo, to_delete->d_name);\n    }\n  }\n  else\n  {\n    printf(\"   [!] %s\\n\", to_delete->d_name);\n    printf(\" -- unable to confirm match; file not deleted!\\n\");\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void CoreUserInputHandler::handleSay(const BufferInfo &bufferInfo, const QString &msg)\n{\n    if (bufferInfo.bufferName().isEmpty() || !bufferInfo.acceptsRegularMessages())\n        return;  // server buffer\n\n    QByteArray encMsg = channelEncode(bufferInfo.bufferName(), msg);\n#ifdef HAVE_QCA2\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg, network()->cipher(bufferInfo.bufferName()));\n#else\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg);\n#endif\n    emit displayMsg(Message::Plain, bufferInfo.type(), bufferInfo.bufferName(), msg, network()->myNick(), Message::Self);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void CoreUserInputHandler::handleSay(const BufferInfo &bufferInfo, const QString &msg)\n{\n    if (bufferInfo.bufferName().isEmpty() || !bufferInfo.acceptsRegularMessages())\n        return;  // server buffer\n\n    std::function<QByteArray(const QString &, const QString &)> encodeFunc = [this] (const QString &target, const QString &message) -> QByteArray {\n        return channelEncode(target, message);\n    };\n\n#ifdef HAVE_QCA2\n    putPrivmsg(bufferInfo.bufferName(), msg, encodeFunc, network()->cipher(bufferInfo.bufferName()));\n#else\n    putPrivmsg(bufferInfo.bufferName(), msg, encodeFunc);\n#endif\n    emit displayMsg(Message::Plain, bufferInfo.type(), bufferInfo.bufferName(), msg, network()->myNick(), Message::Self);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static RzList *classes_from_symbols(RzBinFile *bf) {\n\tRzBinSymbol *sym;\n\tRzListIter *iter;\n\trz_list_foreach (bf->o->symbols, iter, sym) {\n\t\tif (sym->name[0] != '_') {\n\t\t\tcontinue;\n\t\t}\n\t\tconst char *cn = sym->classname;\n\t\tif (cn) {\n\t\t\tRzBinClass *c = rz_bin_file_add_class(bf, sym->classname, NULL, 0);\n\t\t\tif (!c) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// swift specific\n\t\t\tchar *dn = sym->dname;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static RzList *classes_from_symbols(RzBinFile *bf) {\n\tRzBinSymbol *sym;\n\tRzListIter *iter;\n\trz_list_foreach (bf->o->symbols, iter, sym) {\n\t\tif (!sym->name || sym->name[0] != '_') {\n\t\t\tcontinue;\n\t\t}\n\t\tconst char *cn = sym->classname;\n\t\tif (cn) {\n\t\t\tRzBinClass *c = rz_bin_file_add_class(bf, sym->classname, NULL, 0);\n\t\t\tif (!c) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// swift specific\n\t\t\tchar *dn = sym->dname;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ext2_xattr_delete_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct mb_cache_entry *ce;\n\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\tif (!bh) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: block %d read error\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tea_bdebug(bh, \"b_count=%d\", atomic_read(&(bh->b_count)));\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev, bh->b_blocknr);\n\tlock_buffer(bh);\n\tif (HDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\text2_free_blocks(inode, EXT2_I(inode)->i_file_acl, 1);\n\t\tget_bh(bh);\n\t\tbforget(bh);\n\t\tunlock_buffer(bh);\n\t} else {\n\t\tle32_add_cpu(&HDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\tea_bdebug(bh, \"refcount now=%d\",\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tif (IS_SYNC(inode))\n\t\t\tsync_dirty_buffer(bh);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t}\n\tEXT2_I(inode)->i_file_acl = 0;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ext2_xattr_delete_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\tif (!bh) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: block %d read error\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tea_bdebug(bh, \"b_count=%d\", atomic_read(&(bh->b_count)));\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tlock_buffer(bh);\n\tif (HDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\n\t\t/*\n\t\t * This must happen under buffer lock for ext2_xattr_set2() to\n\t\t * reliably detect freed block\n\t\t */\n\t\tmb2_cache_entry_delete_block(EXT2_SB(inode->i_sb)->s_mb_cache,\n\t\t\t\t\t     hash, bh->b_blocknr);\n\t\text2_free_blocks(inode, EXT2_I(inode)->i_file_acl, 1);\n\t\tget_bh(bh);\n\t\tbforget(bh);\n\t\tunlock_buffer(bh);\n\t} else {\n\t\tle32_add_cpu(&HDR(bh)->h_refcount, -1);\n\t\tea_bdebug(bh, \"refcount now=%d\",\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tif (IS_SYNC(inode))\n\t\t\tsync_dirty_buffer(bh);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t}\n\tEXT2_I(inode)->i_file_acl = 0;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n    OP_REQUIRES_OK(context, context->input(\"sparse_indices\", &input_indices));\n    OP_REQUIRES_OK(context, context->input(\"sparse_values\", &input_values));\n    OP_REQUIRES_OK(context, context->input(\"sparse_shape\", &input_shape));\n    OP_REQUIRES_OK(context, GetMap(context, true /* is_writing */, &map));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    input_indices->shape().DebugString()));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    input_values->shape().DebugString()));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    input_shape->shape().DebugString()));\n\n    int rank = input_shape->NumElements();\n\n    OP_REQUIRES(\n        context, rank > 1,\n        errors::InvalidArgument(\n            \"Rank of input SparseTensor should be > 1, but saw rank: \", rank));\n\n    auto input_shape_vec = input_shape->vec<int64_t>();\n    int new_num_elements = 1;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    SparseTensorsMap* map;\n\n    OP_REQUIRES_OK(context, context->input(\"sparse_indices\", &input_indices));\n    OP_REQUIRES_OK(context, context->input(\"sparse_values\", &input_values));\n    OP_REQUIRES_OK(context, context->input(\"sparse_shape\", &input_shape));\n    OP_REQUIRES_OK(context, GetMap(context, true /* is_writing */, &map));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    input_indices->shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    input_values->shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    input_shape->shape().DebugString()));\n    OP_REQUIRES(\n        context,\n        input_values->shape().dim_size(0) == input_indices->shape().dim_size(0),\n        errors::InvalidArgument(\n            \"Number of values must match first dimension of indices. \", \"Got \",\n            input_values->shape().dim_size(0),\n            \" values, indices shape: \", input_indices->shape().DebugString()));\n    OP_REQUIRES(\n        context,\n        input_shape->shape().dim_size(0) == input_indices->shape().dim_size(1),\n        errors::InvalidArgument(\n            \"Number of dimensions must match second dimension of indices. \",\n            \"Got \", input_shape->shape().dim_size(0),\n            \" dimensions, indices shape: \",\n            input_indices->shape().DebugString()));\n\n    int rank = input_shape->NumElements();\n\n    OP_REQUIRES(\n        context, rank > 1,\n        errors::InvalidArgument(\n            \"Rank of input SparseTensor should be > 1, but saw rank: \", rank));\n\n    auto input_shape_vec = input_shape->vec<int64_t>();\n    int new_num_elements = 1;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tif (parm != NULL)\n\t\t\tr = decode_bit_field(obj, objlen, (u8 *) parm, *len);\n\t\tbreak;\n\tcase SC_ASN1_OCTET_STRING:\n\t\tif (parm != NULL) {\n\t\t\tsize_t c;\n\t\t\tassert(len != NULL);\n\n\t\t\t/* Strip off padding zero */\n\t\t\tif ((entry->flags & SC_ASN1_UNSIGNED)\n\t\t\t && obj[0] == 0x00 && objlen > 1) {\n\t\t\t\tobjlen--;\n\t\t\t\tobj++;\n\t\t\t}\n\n\t\t\t/* Allocate buffer if needed */\n\t\t\tif (entry->flags & SC_ASN1_ALLOC) {\n\t\t\t\tu8 **buf = (u8 **) parm;\n\t\t\t\t*buf = malloc(objlen);\n\t\t\t\tif (*buf == NULL) {\n\t\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tif (parm != NULL)\n\t\t\tr = decode_bit_field(obj, objlen, (u8 *) parm, *len);\n\t\tbreak;\n\tcase SC_ASN1_OCTET_STRING:\n\t\tif (parm != NULL) {\n\t\t\tsize_t c;\n\t\t\tassert(len != NULL);\n\n\t\t\t/* Strip off padding zero */\n\t\t\tif ((entry->flags & SC_ASN1_UNSIGNED)\n\t\t\t\t\t&& objlen > 1 && obj[0] == 0x00) {\n\t\t\t\tobjlen--;\n\t\t\t\tobj++;\n\t\t\t}\n\n\t\t\t/* Allocate buffer if needed */\n\t\t\tif (entry->flags & SC_ASN1_ALLOC) {\n\t\t\t\tu8 **buf = (u8 **) parm;\n\t\t\t\t*buf = malloc(objlen);\n\t\t\t\tif (*buf == NULL) {\n\t\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static json_t * check_attestation_fido_u2f(json_t * j_params, unsigned char * credential_id, size_t credential_id_len, unsigned char * cert_x, size_t cert_x_len, unsigned char * cert_y, size_t cert_y_len, cbor_item_t * att_stmt, unsigned char * rpid_hash, size_t rpid_hash_len, const unsigned char * client_data) {\n  json_t * j_error = json_array(), * j_return;\n  cbor_item_t * key = NULL, * x5c = NULL, * sig = NULL, * att_cert = NULL;\n  int i, ret;\n  char * message = NULL;\n  gnutls_pubkey_t pubkey = NULL;\n  gnutls_x509_crt_t cert = NULL;\n  gnutls_datum_t cert_dat, data, signature, cert_issued_by;\n  unsigned char data_signed[200], client_data_hash[32], cert_export[32], cert_export_b64[64];\n  size_t data_signed_offset = 0, client_data_hash_len = 32, cert_export_len = 32, cert_export_b64_len = 0;\n  \n  if (j_error != NULL) {\n    do {\n      if (gnutls_x509_crt_init(&cert)) {\n        json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_x509_crt_init\"));\n        break;\n      }\n      if (gnutls_pubkey_init(&pubkey)) {\n        json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_pubkey_init\"));\n      if (!generate_digest_raw(digest_SHA256, client_data, o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error generate_digest_raw client_data\");\n        break;\n      }\n\n      if (sig == NULL || !cbor_isa_bytestring(sig)) {\n        json_array_append_new(j_error, json_string(\"Error sig is not a bytestring\"));\n        break;\n      }\n      \n      // Build bytestring to verify signature\n      data_signed[0] = 0x0;\n      data_signed_offset = 1;\n      \n      memcpy(data_signed+data_signed_offset, rpid_hash, rpid_hash_len);\n      data_signed_offset += rpid_hash_len;\n      \n      memcpy(data_signed+data_signed_offset, client_data_hash, client_data_hash_len);\n      data_signed_offset+=client_data_hash_len;\n      \n      data.data = data_signed;\n      data.size = data_signed_offset;\n      \n      signature.data = cbor_bytestring_handle(sig);\n      signature.size = cbor_bytestring_length(sig);\n      \n      if (gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) {\n        json_array_append_new(j_error, json_string(\"Invalid signature\"));\n      }\n      \n    } while (0);\n    \n    if (json_array_size(j_error)) {\n      j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"error\", j_error);\n    } else {\n      j_return = json_pack(\"{sis{ss%}}\", \"result\", G_OK, \"data\", \"certificate\", cert_export_b64, cert_export_b64_len);\n    }\n    json_decref(j_error);\n    gnutls_pubkey_deinit(pubkey);\n    gnutls_x509_crt_deinit(cert);\n    if (att_cert != NULL) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static json_t * check_attestation_fido_u2f(json_t * j_params, unsigned char * credential_id, size_t credential_id_len, unsigned char * cert_x, size_t cert_x_len, unsigned char * cert_y, size_t cert_y_len, cbor_item_t * att_stmt, unsigned char * rpid_hash, size_t rpid_hash_len, const unsigned char * client_data) {\n  json_t * j_error = json_array(), * j_return;\n  cbor_item_t * key = NULL, * x5c = NULL, * sig = NULL, * att_cert = NULL;\n  int i, ret;\n  char * message = NULL;\n  gnutls_pubkey_t pubkey = NULL;\n  gnutls_x509_crt_t cert = NULL;\n  gnutls_datum_t cert_dat, data, signature, cert_issued_by;\n  unsigned char * data_signed = NULL, client_data_hash[32], cert_export[32], cert_export_b64[64];\n  size_t data_signed_offset = 0, client_data_hash_len = 32, cert_export_len = 32, cert_export_b64_len = 0;\n  \n  if (j_error != NULL) {\n    do {\n      if (gnutls_x509_crt_init(&cert)) {\n        json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_x509_crt_init\"));\n        break;\n      }\n      if (gnutls_pubkey_init(&pubkey)) {\n        json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_pubkey_init\"));\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error generate_digest_raw client_data\");\n        break;\n      }\n\n      if (sig == NULL || !cbor_isa_bytestring(sig)) {\n        json_array_append_new(j_error, json_string(\"Error sig is not a bytestring\"));\n        break;\n      }\n      \n      if ((data_signed = o_malloc(rpid_hash_len+client_data_hash_len+credential_id_len+cert_x_len+cert_y_len+2)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error allocating data_signed\");\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        break;\n      }\n      \n      // Build bytestring to verify signature\n      data_signed[0] = 0x0;\n      data_signed_offset = 1;\n      \n      memcpy(data_signed+data_signed_offset, rpid_hash, rpid_hash_len);\n      data_signed_offset += rpid_hash_len;\n      \n      memcpy(data_signed+data_signed_offset, client_data_hash, client_data_hash_len);\n      data_signed_offset+=client_data_hash_len;\n      \n      data.size = data_signed_offset;\n      \n      signature.data = cbor_bytestring_handle(sig);\n      signature.size = cbor_bytestring_length(sig);\n      \n      if (gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) {\n        json_array_append_new(j_error, json_string(\"Invalid signature\"));\n      }\n      \n    } while (0);\n    o_free(data_signed);\n    \n    if (json_array_size(j_error)) {\n      j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"error\", j_error);\n    } else {\n      j_return = json_pack(\"{sis{ss%}}\", \"result\", G_OK, \"data\", \"certificate\", cert_export_b64, cert_export_b64_len);\n    }\n    json_decref(j_error);\n    gnutls_pubkey_deinit(pubkey);\n    gnutls_x509_crt_deinit(cert);\n    if (att_cert != NULL) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    if (!message) {\n        log_warning(\"Carbon received with no message element\");\n        return TRUE;\n    }\n\n    char *message_txt = xmpp_message_get_body(message);\n    if (!message_txt) {\n        log_warning(\"Carbon received with no message.\");\n        return TRUE;\n    }\n\n    const gchar *to = xmpp_stanza_get_to(message);\n    const gchar *from = xmpp_stanza_get_from(message);\n\n    // happens when receive a carbon of a self sent message\n    if (!to) to = from;\n\n    Jid *jid_from = jid_create(from);\n    Jid *jid_to = jid_create(to);\n    Jid *my_jid = jid_create(connection_get_fulljid());\n\n    // check for pgp encrypted message\n    char *enc_message = NULL;\n    xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);\n    if (x) {\n        enc_message = xmpp_stanza_get_text(x);\n    }\n\n    // if we are the recipient, treat as standard incoming message\n    if (g_strcmp0(my_jid->barejid, jid_to->barejid) == 0) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        log_warning(\"Carbon received with no message element\");\n        return TRUE;\n    }\n\n    char *message_txt = xmpp_message_get_body(message);\n    if (!message_txt) {\n        log_warning(\"Carbon received with no message.\");\n        return TRUE;\n    }\n\n    Jid *my_jid = jid_create(connection_get_fulljid());\n    const char *const stanza_from = xmpp_stanza_get_from(stanza);\n    Jid *msg_jid = jid_create(stanza_from);\n    if (g_strcmp0(my_jid->barejid, msg_jid->barejid) != 0) {\n        log_warning(\"Invalid carbon received, from: %s\", stanza_from);\n        return TRUE;\n    }\n\n    const gchar *to = xmpp_stanza_get_to(message);\n    const gchar *from = xmpp_stanza_get_from(message);\n\n    // happens when receive a carbon of a self sent message\n    if (!to) to = from;\n\n    Jid *jid_from = jid_create(from);\n    Jid *jid_to = jid_create(to);\n\n    // check for pgp encrypted message\n    char *enc_message = NULL;\n    xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);\n    if (x) {\n        enc_message = xmpp_stanza_get_text(x);\n    }\n\n    // if we are the recipient, treat as standard incoming message\n    if (g_strcmp0(my_jid->barejid, jid_to->barejid) == 0) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_WRONLY)) {\n\t\tsize = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (strcmp(f->file, \"tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/cgroup.procs\") == 0 ||\n\t\t\tstrcmp(f->file, \"cgroup.procs\") == 0)\n\t\t// special case - we have to translate the pids\n\t\tr = do_write_pids(fc->pid, f->controller, f->cgroup, f->file, localbuf);\n\telse\n\t\tr = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf);\n\n\tif (!r)\n\t\tsize = -EINVAL;\n\nout:\n\tfree_key(k);\n\treturn size;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_WRONLY)) {\n\t\tsize = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (strcmp(f->file, \"tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/cgroup.procs\") == 0 ||\n\t\t\tstrcmp(f->file, \"cgroup.procs\") == 0)\n\t\t// special case - we have to translate the pids\n\t\tr = do_write_pids(fc->pid, fc->uid, f->controller, f->cgroup, f->file, localbuf);\n\telse\n\t\tr = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf);\n\n\tif (!r)\n\t\tsize = -EINVAL;\n\nout:\n\tfree_key(k);\n\treturn size;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    AreaData::Evidence evi = {argv[1], argv[2], argv[3]};\n    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n        area->replaceEvidence(idx, evi);\n    }\n    sendEvidenceList(area);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    AreaData::Evidence evi = {argv[1], argv[2], argv[3]};\n    if (is_int && idx < area->evidence().size() && idx >= 0) {\n        area->replaceEvidence(idx, evi);\n    }\n    sendEvidenceList(area);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  void operator()(const CPUDevice& d, typename TTypes<T>::ConstFlat gradient,\n                  typename TTypes<T>::ConstFlat input,\n                  typename TTypes<T>::ConstScalar input_min_tensor,\n                  typename TTypes<T>::ConstScalar input_max_tensor,\n                  typename TTypes<T>::Flat input_backprop,\n                  typename TTypes<T>::Scalar input_min_backprop,\n                  typename TTypes<T>::Scalar input_max_backprop) {\n    QuantizeAndDequantizeOneScaleGradientImpl<CPUDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  void operator()(const CpuDevice& d, typename TTypes<T>::ConstFlat gradient,\n                  typename TTypes<T>::ConstFlat input,\n                  typename TTypes<T>::ConstScalar input_min_tensor,\n                  typename TTypes<T>::ConstScalar input_max_tensor,\n                  typename TTypes<T>::Flat input_backprop,\n                  typename TTypes<T>::Scalar input_min_backprop,\n                  typename TTypes<T>::Scalar input_max_backprop) {\n    QuantizeAndDequantizeOneScaleGradientImpl<CpuDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                            shape.DebugString(), \" which is not fully defined\");\n  }\n\n  PartialTensorShape new_dims;\n  if (outputs[0]->dtype() == DT_INT32) {\n    std::vector<int32> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int32_t dim = outputs[0]->flat<int32>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  } else {\n    std::vector<int64_t> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int64_t dim = outputs[0]->flat<int64_t>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  }\n\n  if (!shape.IsCompatibleWith(new_dims)) {\n    return errors::Internal(\"Expected shape \", shape.DebugString(),\n                            \"to be compatible with \", new_dims.DebugString());\n  }\n\n  return Status::OK();\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                            shape.DebugString(), \" which is not fully defined\");\n  }\n\n  PartialTensorShape new_dims;\n  if (outputs[0]->dtype() == DT_INT32) {\n    std::vector<int32> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int32_t dim = outputs[0]->flat<int32>()(i);\n      shp.push_back(dim);\n    }\n    s = TensorShapeUtils::MakeShape(shp, &new_dims);\n    if (!s.ok()) return s;\n  } else {\n    std::vector<int64_t> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int64_t dim = outputs[0]->flat<int64_t>()(i);\n      shp.push_back(dim);\n    }\n    s = TensorShapeUtils::MakeShape(shp, &new_dims);\n    if (!s.ok()) return s;\n  }\n\n  if (!shape.IsCompatibleWith(new_dims)) {\n    return errors::Internal(\"Expected shape \", shape.DebugString(),\n                            \"to be compatible with \", new_dims.DebugString());\n  }\n\n  return Status::OK();\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\n\t\tstruct dentry *new_dir, const char *new_name)\n{\n\tint error;\n\tstruct dentry *dentry = NULL, *trap;\n\tconst char *old_name;\n\n\ttrap = lock_rename(new_dir, old_dir);\n\t/* Source or destination directories don't exist? */\n\tif (d_really_is_negative(old_dir) || d_really_is_negative(new_dir))\n\t\tgoto exit;\n\t/* Source does not exist, cyclic rename, or mountpoint? */\n\tif (d_really_is_negative(old_dentry) || old_dentry == trap ||\n\t    d_mountpoint(old_dentry))\n\t\tgoto exit;\n\tdentry = lookup_one_len(new_name, new_dir, strlen(new_name));\n\t/* Lookup failed, cyclic rename or target exists? */\n\tif (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))\n\t\tgoto exit;\n\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\n\terror = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),\n\t\t\t      dentry, 0);\n\tif (error) {\n\t\tfsnotify_oldname_free(old_name);\n\t\tgoto exit;\n\t}\n\td_move(old_dentry, dentry);\n\tfsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name,\n\t\td_is_dir(old_dentry),\n\t\tNULL, old_dentry);\n\tfsnotify_oldname_free(old_name);\n\tunlock_rename(new_dir, old_dir);\n\tdput(dentry);\n\treturn old_dentry;\nexit:\n\tif (dentry && !IS_ERR(dentry))\n\t\tdput(dentry);\n\tunlock_rename(new_dir, old_dir);\n\treturn NULL;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\n\t\tstruct dentry *new_dir, const char *new_name)\n{\n\tint error;\n\tstruct dentry *dentry = NULL, *trap;\n\tstruct name_snapshot old_name;\n\n\ttrap = lock_rename(new_dir, old_dir);\n\t/* Source or destination directories don't exist? */\n\tif (d_really_is_negative(old_dir) || d_really_is_negative(new_dir))\n\t\tgoto exit;\n\t/* Source does not exist, cyclic rename, or mountpoint? */\n\tif (d_really_is_negative(old_dentry) || old_dentry == trap ||\n\t    d_mountpoint(old_dentry))\n\t\tgoto exit;\n\tdentry = lookup_one_len(new_name, new_dir, strlen(new_name));\n\t/* Lookup failed, cyclic rename or target exists? */\n\tif (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))\n\t\tgoto exit;\n\n\ttake_dentry_name_snapshot(&old_name, old_dentry);\n\n\terror = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),\n\t\t\t      dentry, 0);\n\tif (error) {\n\t\trelease_dentry_name_snapshot(&old_name);\n\t\tgoto exit;\n\t}\n\td_move(old_dentry, dentry);\n\tfsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name.name,\n\t\td_is_dir(old_dentry),\n\t\tNULL, old_dentry);\n\trelease_dentry_name_snapshot(&old_name);\n\tunlock_rename(new_dir, old_dir);\n\tdput(dentry);\n\treturn old_dentry;\nexit:\n\tif (dentry && !IS_ERR(dentry))\n\t\tdput(dentry);\n\tunlock_rename(new_dir, old_dir);\n\treturn NULL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteStatus PrepareAny(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteBool);\n  return PrepareSimple(context, node);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteStatus PrepareAny(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteBool);\n  return PrepareSimple(context, node);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tbond_dev->netdev_ops = &bond_netdev_ops;\n\tbond_dev->ethtool_ops = &bond_ethtool_ops;\n\tbond_set_mode_ops(bond, bond->params.mode);\n\n\tbond_dev->destructor = bond_destructor;\n\n\t/* Initialize the device options */\n\tbond_dev->tx_queue_len = 0;\n\tbond_dev->flags |= IFF_MASTER|IFF_MULTICAST;\n\tbond_dev->priv_flags |= IFF_BONDING;\n\tbond_dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\n\t/* At first, we block adding VLANs. That's the only way to\n\t * prevent problems that occur when adding VLANs over an\n\t * empty bond. The block will be removed once non-challenged\n\t * slaves are enslaved.\n\t */\n\tbond_dev->features |= NETIF_F_VLAN_CHALLENGED;\n\n\t/* don't acquire bond device's netif_tx_lock when\n\t * transmitting */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tbond_dev->netdev_ops = &bond_netdev_ops;\n\tbond_dev->ethtool_ops = &bond_ethtool_ops;\n\tbond_set_mode_ops(bond, bond->params.mode);\n\n\tbond_dev->destructor = bond_destructor;\n\n\t/* Initialize the device options */\n\tbond_dev->tx_queue_len = 0;\n\tbond_dev->flags |= IFF_MASTER|IFF_MULTICAST;\n\tbond_dev->priv_flags |= IFF_BONDING;\n\tbond_dev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n\n\t/* At first, we block adding VLANs. That's the only way to\n\t * prevent problems that occur when adding VLANs over an\n\t * empty bond. The block will be removed once non-challenged\n\t * slaves are enslaved.\n\t */\n\tbond_dev->features |= NETIF_F_VLAN_CHALLENGED;\n\n\t/* don't acquire bond device's netif_tx_lock when\n\t * transmitting */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "inline bool ShapeIsVector(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* shape = GetInput(context, node, kShapeTensor);\n  return (shape->dims->size == 1 && shape->type == kTfLiteInt32);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "inline bool ShapeIsVector(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* shape = GetInput(context, node, kShapeTensor);\n  return (shape != nullptr && shape->dims->size == 1 &&\n          shape->type == kTfLiteInt32);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_COM))) {\n\t\treturn -1;\n\t}\n\tsprintf(buf, \"Creator: JasPer Version %s\", jas_getversion());\n\tcom = &enc->mrk->parms.com;\n\tcom->len = JAS_CAST(uint_fast16_t, strlen(buf));\n\tcom->regid = JPC_COM_LATIN;\n\tif (!(com->data = JAS_CAST(uchar *, jas_strdup(buf)))) {\n\t\tabort();\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write COM marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n#if 0",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_COM))) {\n\t\treturn -1;\n\t}\n\tsprintf(buf, \"Creator: JasPer Version %s\", jas_getversion());\n\tcom = &enc->mrk->parms.com;\n\tcom->len = JAS_CAST(uint_fast16_t, strlen(buf));\n\tcom->regid = JPC_COM_LATIN;\n\tif (!(com->data = JAS_CAST(jas_uchar *, jas_strdup(buf)))) {\n\t\tabort();\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write COM marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n#if 0",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TEST_F(ZNCTest, AwayNotify) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    auto client = ConnectClient();\n    client.Write(\"CAP LS\");\n    client.Write(\"PASS :hunter2\");\n    client.Write(\"NICK nick\");\n    client.Write(\"USER user/test x x :x\");\n    QByteArray cap_ls;\n    client.ReadUntilAndGet(\" LS :\", cap_ls);\n    ASSERT_THAT(cap_ls.toStdString(), AllOf(HasSubstr(\"cap-notify\"), Not(HasSubstr(\"away-notify\"))));\n    client.Write(\"CAP REQ :cap-notify\");\n    client.ReadUntil(\"ACK :cap-notify\");\n    client.Write(\"CAP END\");\n    client.ReadUntil(\" 001 \");\n    ircd.ReadUntil(\"USER\");\n    ircd.Write(\"CAP user LS :away-notify\");\n    ircd.ReadUntil(\"CAP REQ :away-notify\");\n    ircd.Write(\"CAP user ACK :away-notify\");\n    ircd.ReadUntil(\"CAP END\");\n    ircd.Write(\":server 001 user :welcome\");\n    client.ReadUntil(\"CAP user NEW :away-notify\");\n    client.Write(\"CAP REQ :away-notify\");\n    client.ReadUntil(\"ACK :away-notify\");\n    ircd.Write(\":x!y@z AWAY :reason\");\n    client.ReadUntil(\":x!y@z AWAY :reason\");\n    ircd.Close();\n    client.ReadUntil(\"DEL :away-notify\");\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TEST_F(ZNCTest, StatusEchoMessage) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"CAP REQ :echo-message\");\n    client.Write(\"PRIVMSG *status :blah\");\n    client.ReadUntil(\":nick!user@irc.znc.in PRIVMSG *status :blah\");\n    client.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteStatus Resize(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteLSHProjectionParams*>(node->builtin_data);\n  TF_LITE_ENSURE(context, NumInputs(node) == 2 || NumInputs(node) == 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* hash = GetInput(context, node, 0);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(hash), 2);\n  // Support up to 32 bits.\n  TF_LITE_ENSURE(context, SizeOfDimension(hash, 1) <= 32);\n\n  const TfLiteTensor* input = GetInput(context, node, 1);\n  TF_LITE_ENSURE(context, NumDimensions(input) >= 1);\n\n  if (NumInputs(node) == 3) {\n    const TfLiteTensor* weight = GetInput(context, node, 2);\n    TF_LITE_ENSURE_EQ(context, NumDimensions(weight), 1);\n    TF_LITE_ENSURE_EQ(context, SizeOfDimension(weight, 0),\n                      SizeOfDimension(input, 0));\n  }\n\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  switch (params->type) {\n    case kTfLiteLshProjectionSparse:\n      outputSize->data[0] = SizeOfDimension(hash, 0);\n      break;\n    case kTfLiteLshProjectionDense:\n      outputSize->data[0] = SizeOfDimension(hash, 0) * SizeOfDimension(hash, 1);\n      break;\n    default:\n      return kTfLiteError;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteStatus Resize(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteLSHProjectionParams*>(node->builtin_data);\n  TF_LITE_ENSURE(context, NumInputs(node) == 2 || NumInputs(node) == 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* hash;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &hash));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(hash), 2);\n  // Support up to 32 bits.\n  TF_LITE_ENSURE(context, SizeOfDimension(hash, 1) <= 32);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &input));\n  TF_LITE_ENSURE(context, NumDimensions(input) >= 1);\n\n  if (NumInputs(node) == 3) {\n    const TfLiteTensor* weight;\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &weight));\n    TF_LITE_ENSURE_EQ(context, NumDimensions(weight), 1);\n    TF_LITE_ENSURE_EQ(context, SizeOfDimension(weight, 0),\n                      SizeOfDimension(input, 0));\n  }\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  switch (params->type) {\n    case kTfLiteLshProjectionSparse:\n      outputSize->data[0] = SizeOfDimension(hash, 0);\n      break;\n    case kTfLiteLshProjectionDense:\n      outputSize->data[0] = SizeOfDimension(hash, 0) * SizeOfDimension(hash, 1);\n      break;\n    default:\n      return kTfLiteError;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "expand_dynamic_string_token (struct link_map *l, const char *s)\n{\n  /* We make two runs over the string.  First we determine how large the\n     resulting string is and then we copy it over.  Since this is now\n     frequently executed operation we are looking here not for performance\n     but rather for code size.  */\n  size_t cnt;\n  size_t total;\n  char *result;\n\n  /* Determine the nubmer of DST elements.  */\n  cnt = DL_DST_COUNT (s, 1);\n\n  /* If we do not have to replace anything simply copy the string.  */\n  if (cnt == 0)\n    return local_strdup (s);\n\n  /* Determine the length of the substituted string.  */\n  total = DL_DST_REQUIRED (l, s, strlen (s), cnt);\n\n  /* Allocate the necessary memory.  */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "expand_dynamic_string_token (struct link_map *l, const char *s)\n{\n  /* We make two runs over the string.  First we determine how large the\n     resulting string is and then we copy it over.  Since this is now\n     frequently executed operation we are looking here not for performance\n     but rather for code size.  */\n  size_t cnt;\n  size_t total;\n  char *result;\n\n  /* Determine the number of DST elements.  */\n  cnt = DL_DST_COUNT (s, 1);\n\n  /* If we do not have to replace anything simply copy the string.  */\n  if (cnt == 0)\n    return local_strdup (s);\n\n  /* Determine the length of the substituted string.  */\n  total = DL_DST_REQUIRED (l, s, strlen (s), cnt);\n\n  /* Allocate the necessary memory.  */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void CommandData::ParseArg(wchar *Arg)\n{\n  if (IsSwitch(*Arg) && !NoMoreSwitches)\n    if (Arg[1]=='-' && Arg[2]==0)\n      NoMoreSwitches=true;\n    else\n      ProcessSwitch(Arg+1);\n  else\n    if (*Command==0)\n    {\n      wcsncpy(Command,Arg,ASIZE(Command));\n\n\n      *Command=toupperw(*Command);\n      // 'I' and 'S' commands can contain case sensitive strings after\n      // the first character, so we must not modify their case.\n      // 'S' can contain SFX name, which case is important in Unix.\n      if (*Command!='I' && *Command!='S')\n        wcsupper(Command);\n    }\n    else",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void CommandData::ParseArg(wchar *Arg)\n{\n  if (IsSwitch(*Arg) && !NoMoreSwitches)\n    if (Arg[1]=='-' && Arg[2]==0)\n      NoMoreSwitches=true;\n    else\n      ProcessSwitch(Arg+1);\n  else\n    if (*Command==0)\n    {\n      wcsncpyz(Command,Arg,ASIZE(Command));\n\n\n      *Command=toupperw(*Command);\n      // 'I' and 'S' commands can contain case sensitive strings after\n      // the first character, so we must not modify their case.\n      // 'S' can contain SFX name, which case is important in Unix.\n      if (*Command!='I' && *Command!='S')\n        wcsupper(Command);\n    }\n    else",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void __perf_sw_event(u32 event_id, u64 nr, int nmi,\n\t\t\t    struct pt_regs *regs, u64 addr)\n{\n\tstruct perf_sample_data data;\n\tint rctx;\n\n\tpreempt_disable_notrace();\n\trctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn;\n\n\tperf_sample_data_init(&data, addr);\n\n\tdo_perf_sw_event(PERF_TYPE_SOFTWARE, event_id, nr, nmi, &data, regs);\n\n\tperf_swevent_put_recursion_context(rctx);\n\tpreempt_enable_notrace();\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void __perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)\n{\n\tstruct perf_sample_data data;\n\tint rctx;\n\n\tpreempt_disable_notrace();\n\trctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn;\n\n\tperf_sample_data_init(&data, addr);\n\n\tdo_perf_sw_event(PERF_TYPE_SOFTWARE, event_id, nr, &data, regs);\n\n\tperf_swevent_put_recursion_context(rctx);\n\tpreempt_enable_notrace();\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    }\n\n  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);\n  free (input_u8);\n\n  if (rc == IDN2_OK)\n    {\n      /* wow, this is ugly, but libidn manpage states:\n       * char * out  output zero terminated string that must have room for at\n       * least 63 characters plus the terminating zero.\n       */\n      if (output)\n\tstrcpy (output, (const char *) output_u8);\n\n      free(output_u8);\n    }\n\n  return rc;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);\n  free (input_u8);\n\n  if (rc == IDN2_OK)\n    {\n      /* wow, this is ugly, but libidn manpage states:\n       * char * out  output zero terminated string that must have room for at\n       * least 63 characters plus the terminating zero.\n       */\n      size_t len = strlen ((char *) output_u8);\n\n      if (len > 63)\n        {\n\t  free (output_u8);\n\t  return IDN2_TOO_BIG_DOMAIN;\n        }\n\n      if (output)\n\tstrcpy (output, (char *) output_u8);\n\n      free (output_u8);\n    }\n\n  return rc;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) {\n\tr_return_val_if_fail (cmd && cmd->aliases && k, NULL);\n\treturn ht_pp_find(cmd->aliases, k, NULL);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) {\n\tr_return_val_if_fail (cmd && cmd->aliases && k, NULL);\n\treturn ht_pp_find (cmd->aliases, k, NULL);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(huffman_image->filename,MagickPathExtent,\"tiff:%s\",\n    filename);\n  (void) SetImageType(huffman_image,BilevelType,exception);\n  write_info=CloneImageInfo((ImageInfo *) NULL);\n  SetImageInfoFile(write_info,file);\n  (void) SetImageType(image,BilevelType,exception);\n  (void) SetImageDepth(image,1,exception);\n  write_info->compression=Group4Compression;\n  write_info->type=BilevelType;\n  (void) SetImageOption(write_info,\"quantum:polarity\",\"min-is-white\");\n  status=WriteTIFFImage(write_info,huffman_image,exception);\n  (void) fflush(file);\n  write_info=DestroyImageInfo(write_info);\n  if (status == MagickFalse)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(huffman_image->filename,MagickPathExtent,\"tiff:%s\",\n    filename);\n  (void) SetImageType(huffman_image,BilevelType,exception);\n  write_info=CloneImageInfo((ImageInfo *) NULL);\n  SetImageInfoFile(write_info,file);\n  (void) SetImageDepth(image,1,exception);\n  (void) SetImageType(image,BilevelType,exception);\n  write_info->compression=Group4Compression;\n  write_info->type=BilevelType;\n  (void) SetImageOption(write_info,\"quantum:polarity\",\"min-is-white\");\n  status=WriteTIFFImage(write_info,huffman_image,exception);\n  (void) fflush(file);\n  write_info=DestroyImageInfo(write_info);\n  if (status == MagickFalse)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    for (attempt = 0; attempt <= (fuzzy ? 0 : 1); ++attempt)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tscore = 0;\n\n\tif (!fuzzy)\n\t{\n\t    if (attempt > 0 && patc == pat)\n\t\tbreak;\t// there was no anchor, no need to try again\n\t    regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);\n\t    if (regmatch.regprog == NULL)\n\t    {\n\t\tif (patc != pat)\n\t\t    vim_free(patc);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// round == 1: Count the matches.\n\t// round == 2: Build the array to keep the matches.\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    count = 0;\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tif (!buf->b_p_bl)\t// skip unlisted buffers\n\t\t    continue;\n#ifdef FEAT_DIFF\n\t\tif (options & BUF_DIFF_FILTER)\n\t\t    // Skip buffers not suitable for\n\t\t    // :diffget or :diffput completion.\n\t\t    if (buf == curbuf || !diff_mode_buf(buf))\n\t\t\tcontinue;\n#endif\n\n\t\tif (!fuzzy)\n\t\t    p = buflist_match(&regmatch, buf, p_wic);\n\t\telse\n\t\t{\n\t\t    p = NULL;\n\t\t    // first try matching with the short file name\n\t\t    if ((score = fuzzy_match_str(buf->b_sfname, pat)) != 0)\n\t\t\tp = buf->b_sfname;\n\t\t    if (p == NULL)\n\t\t    {\n\t\t\t// next try matching with the full path file name\n\t\t\tif ((score = fuzzy_match_str(buf->b_ffname, pat)) != 0)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    // attempt == 1: try match without '\\<', match anywhere\n    for (attempt = 0; attempt <= (fuzzy ? 0 : 1); ++attempt)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tscore = 0;\n\n\tif (!fuzzy)\n\t{\n\t    if (attempt > 0 && patc == pat)\n\t\tbreak;\t// there was no anchor, no need to try again\n\t    regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);\n\t}\n\n\t// round == 1: Count the matches.\n\t// round == 2: Build the array to keep the matches.\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    count = 0;\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tif (!buf->b_p_bl)\t// skip unlisted buffers\n\t\t    continue;\n#ifdef FEAT_DIFF\n\t\tif (options & BUF_DIFF_FILTER)\n\t\t    // Skip buffers not suitable for\n\t\t    // :diffget or :diffput completion.\n\t\t    if (buf == curbuf || !diff_mode_buf(buf))\n\t\t\tcontinue;\n#endif\n\n\t\tif (!fuzzy)\n\t\t{\n\t\t    if (regmatch.regprog == NULL)\n\t\t    {\n\t\t\t// invalid pattern, possibly after recompiling\n\t\t\tif (patc != pat)\n\t\t\t    vim_free(patc);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    p = buflist_match(&regmatch, buf, p_wic);\n\t\t}\n\t\telse\n\t\t{\n\t\t    p = NULL;\n\t\t    // first try matching with the short file name\n\t\t    if ((score = fuzzy_match_str(buf->b_sfname, pat)) != 0)\n\t\t\tp = buf->b_sfname;\n\t\t    if (p == NULL)\n\t\t    {\n\t\t\t// next try matching with the full path file name\n\t\t\tif ((score = fuzzy_match_str(buf->b_ffname, pat)) != 0)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n\tstruct bio *bio = *bio_ret;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tsector_t block_in_file;\n\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t block_nr;\n\tint ret = 0;\n\n\tblock_in_file = (sector_t)page->index;\n\tlast_block = block_in_file + nr_pages;\n\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >>\n\t\t\t\t\t\t\tblkbits;\n\tif (last_block > last_block_in_file)\n\t\tlast_block = last_block_in_file;\n\n\t/* just zeroing out page which is beyond EOF */\n\tif (block_in_file >= last_block)\n\t\tgoto zero_out;\n\t/*\n\tmap->m_len = last_block - block_in_file;\n\n\tret = f2fs_map_blocks(inode, map, 0, F2FS_GET_BLOCK_DEFAULT);\n\tif (ret)\n\t\tgoto out;\ngot_it:\n\tif ((map->m_flags & F2FS_MAP_MAPPED)) {\n\t\tblock_nr = map->m_pblk + block_in_file - map->m_lblk;\n\t\tSetPageMappedToDisk(page);\n\n\t\tif (!PageUptodate(page) && !cleancache_get_page(page)) {\n\t\t\tSetPageUptodate(page);\n\t\t\tgoto confused;\n\t\t}\n\n\t\tif (!f2fs_is_valid_blkaddr(F2FS_I_SB(inode), block_nr,\n\t\t\t\t\t\tDATA_GENERIC_ENHANCE_READ)) {\n\t\t\tret = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t} else {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n\tstruct bio *bio = *bio_ret;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tsector_t block_in_file;\n\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t block_nr;\n\tint ret = 0;\n\n\tblock_in_file = (sector_t)page_index(page);\n\tlast_block = block_in_file + nr_pages;\n\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >>\n\t\t\t\t\t\t\tblkbits;\n\tif (last_block > last_block_in_file)\n\t\tlast_block = last_block_in_file;\n\n\t/* just zeroing out page which is beyond EOF */\n\tif (block_in_file >= last_block)\n\t\tgoto zero_out;\n\t/*\n\tmap->m_len = last_block - block_in_file;\n\n\tret = f2fs_map_blocks(inode, map, 0, F2FS_GET_BLOCK_DEFAULT);\n\tif (ret)\n\t\tgoto out;\ngot_it:\n\tif ((map->m_flags & F2FS_MAP_MAPPED)) {\n\t\tblock_nr = map->m_pblk + block_in_file - map->m_lblk;\n\t\tSetPageMappedToDisk(page);\n\n\t\tif (!PageUptodate(page) && (!PageSwapCache(page) &&\n\t\t\t\t\t!cleancache_get_page(page))) {\n\t\t\tSetPageUptodate(page);\n\t\t\tgoto confused;\n\t\t}\n\n\t\tif (!f2fs_is_valid_blkaddr(F2FS_I_SB(inode), block_nr,\n\t\t\t\t\t\tDATA_GENERIC_ENHANCE_READ)) {\n\t\t\tret = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t} else {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  const int num_elements = NumElements(input);\n  TF_LITE_ENSURE_EQ(context, num_elements, NumElements(output));\n  switch (input->type) {\n    case kTfLiteInt64:\n      return copyToTensor(context, input->data.i64, output, num_elements);\n    case kTfLiteInt32:\n      return copyToTensor(context, input->data.i32, output, num_elements);\n    case kTfLiteUInt8:\n      return copyToTensor(context, input->data.uint8, output, num_elements);\n    case kTfLiteFloat32:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  const int num_elements = NumElements(input);\n  TF_LITE_ENSURE_EQ(context, num_elements, NumElements(output));\n  switch (input->type) {\n    case kTfLiteInt64:\n      return copyToTensor(context, input->data.i64, output, num_elements);\n    case kTfLiteInt32:\n      return copyToTensor(context, input->data.i32, output, num_elements);\n    case kTfLiteUInt8:\n      return copyToTensor(context, input->data.uint8, output, num_elements);\n    case kTfLiteFloat32:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "GF_EXPORT\nGF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\t//box has been disabled, do not write\n\tif (!a->size) return GF_OK;\n\t\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s size %d write\\n\", gf_4cc_to_str(a->type), a->size));\n\te = gf_isom_box_write_listing(a, bs);\n\tif (e) return e;\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_write(a, a->child_boxes, bs);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "GF_EXPORT\nGF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\t//box has been disabled, do not write\n\tif (!a->size) return GF_OK;\n\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s size %d write\\n\", gf_4cc_to_str(a->type), a->size));\n\te = gf_isom_box_write_listing(a, bs);\n\tif (e) return e;\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_write(a, a->child_boxes, bs);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t\t\t// fixes MOOH.XM loading problems\n\t\t\t// seems to store more instruments in the header than in the actual file\n\t\t\tif (f.posWithBaseOffset() >= fileSize)\n\t\t\t\tbreak;\n\t\t\n\t\t\t//TXMInstrument* ins = &instr[y];\n\t\t\n\t\t\tf.readDwords(&instr[y].size,1);\n\t\t\t\n\t\t\tif (instr[y].size < 29)\n\t\t\t{\n\t\t\t\tmp_ubyte buffer[29];\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tf.read(buffer, 1, instr[y].size - 4);\n\t\t\t\tmemcpy(instr[y].name, buffer, 22);\n\t\t\t\tinstr[y].type = buffer[22];\n\t\t\t\tinstr[y].samp = LittleEndian::GET_WORD(buffer + 23);\n\t\t\t}\n\t\t\telse\n\t\t\t{",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\t\t\t// fixes MOOH.XM loading problems\n\t\t\t// seems to store more instruments in the header than in the actual file\n\t\t\tif (f.posWithBaseOffset() >= fileSize)\n\t\t\t\tbreak;\n\t\t\n\t\t\t//TXMInstrument* ins = &instr[y];\n\t\t\n\t\t\tf.readDwords(&instr[y].size,1);\n\t\t\t\n\t\t\tif (instr[y].size >= 4 && instr[y].size < 29)\n\t\t\t{\n\t\t\t\tmp_ubyte buffer[29];\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tf.read(buffer, 1, instr[y].size - 4);\n\t\t\t\tmemcpy(instr[y].name, buffer, 22);\n\t\t\t\tinstr[y].type = buffer[22];\n\t\t\t\tinstr[y].samp = LittleEndian::GET_WORD(buffer + 23);\n\t\t\t}\n\t\t\telse\n\t\t\t{",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\treturn 0;\n\t}\n\n\t// Read the header length field (including extended headers), and\n\t// extend to this full length. Because this is a 32-bit value,\n\t// we must place a sensible limit on the amount of data that will\n\t// be read, to avoid possibly allocating gigabytes of memory.\n\n\theader_len = lha_decode_uint32(&RAW_DATA(header, 24));\n\n\tif (header_len > LEVEL_3_MAX_HEADER_LEN) {\n\t\treturn 0;\n\t}\n\n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\n\t// Compression method:\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\treturn 0;\n\t}\n\n\t// Read the header length field (including extended headers), and\n\t// extend to this full length. Because this is a 32-bit value,\n\t// we must place a sensible limit on the amount of data that will\n\t// be read, to avoid possibly allocating gigabytes of memory.\n\n\theader_len = lha_decode_uint32(&RAW_DATA(header, 24));\n\n\tif (header_len > LEVEL_3_MAX_HEADER_LEN\n\t || header_len < RAW_DATA_LEN(header)) {\n\t\treturn 0;\n\t}\n\n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\n\t// Compression method:\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "QualifyIpPacket(IPHeader *pIpHeader, ULONG len)\n{\n    tTcpIpPacketParsingResult res;\n    UCHAR  ver_len = pIpHeader->v4.ip_verlen;\n    UCHAR  ip_version = (ver_len & 0xF0) >> 4;\n    USHORT ipHeaderSize = 0;\n    USHORT fullLength = 0;\n    res.value = 0;\n    \n    if (ip_version == 4)\n    {\n        ipHeaderSize = (ver_len & 0xF) << 2;\n        fullLength = swap_short(pIpHeader->v4.ip_length);\n        DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d\\n\",\n            ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength));\n        res.ipStatus = (ipHeaderSize >= sizeof(IPv4Header)) ? ppresIPV4 : ppresNotIP;\n        if (len < ipHeaderSize) res.ipCheckSum = ppresIPTooShort;\n        if (fullLength) {}\n        else\n        {\n            DPrintf(2, (\"ip v.%d, iplen %d\\n\", ip_version, fullLength));\n        }\n    }\n    else if (ip_version == 6)\n    {\n        UCHAR nextHeader = pIpHeader->v6.ip6_next_header;\n        BOOLEAN bParsingDone = FALSE;\n        ipHeaderSize = sizeof(pIpHeader->v6);\n        res.ipStatus = ppresIPV6;\n        res.ipCheckSum = ppresCSOK;\n        fullLength = swap_short(pIpHeader->v6.ip6_payload_len);\n        else\n        {\n            DPrintf(0, (\"[%s] ERROR: IP chain is too large (%d)\\n\", __FUNCTION__, ipHeaderSize));\n            res.ipStatus = ppresNotIP;\n        }\n    }\n    \n    if (res.ipStatus == ppresIPV4)\n    {\n        res.ipHeaderSize = ipHeaderSize;\n        res.xxpFull = len >= fullLength ? 1 : 0;\n        // bit \"more fragments\" or fragment offset mean the packet is fragmented\n        res.IsFragment = (pIpHeader->v4.ip_offset & ~0xC0) != 0;\n        switch (pIpHeader->v4.ip_protocol)\n        {\n            case PROTOCOL_TCP:\n            {\n                res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);\n            }\n            break;\n        case PROTOCOL_UDP:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "QualifyIpPacket(IPHeader *pIpHeader, ULONG len)\n{\n    tTcpIpPacketParsingResult res;\n    res.value = 0;\n\n    if (len < 4)\n    {\n        res.ipStatus = ppresNotIP;\n        return res;\n    }\n\n    UCHAR  ver_len = pIpHeader->v4.ip_verlen;\n    UCHAR  ip_version = (ver_len & 0xF0) >> 4;\n    USHORT ipHeaderSize = 0;\n    USHORT fullLength = 0;\n    res.value = 0;\n\n    if (ip_version == 4)\n    {\n        if (len < sizeof(IPv4Header))\n        {\n            res.ipStatus = ppresNotIP;\n            return res;\n        }\n        ipHeaderSize = (ver_len & 0xF) << 2;\n        fullLength = swap_short(pIpHeader->v4.ip_length);\n        DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\",\n            ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));\n\n        res.ipStatus = (ipHeaderSize >= sizeof(IPv4Header)) ? ppresIPV4 : ppresNotIP;\n        if (res.ipStatus == ppresNotIP)\n        {\n            return res;\n        }\n\n        if (ipHeaderSize >= fullLength || len < fullLength)\n        {\n            DPrintf(2, (\"[%s] - truncated packet - ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\",\n                ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));\n            res.ipCheckSum = ppresIPTooShort;\n            return res;\n        }\n    }\n    else if (ip_version == 6)\n    {\n        UCHAR nextHeader = pIpHeader->v6.ip6_next_header;\n        BOOLEAN bParsingDone = FALSE;\n        ipHeaderSize = sizeof(pIpHeader->v6);\n        res.ipStatus = ppresIPV6;\n        res.ipCheckSum = ppresCSOK;\n        fullLength = swap_short(pIpHeader->v6.ip6_payload_len);\n        else\n        {\n            DPrintf(0, (\"[%s] ERROR: IP chain is too large (%d)\\n\", __FUNCTION__, ipHeaderSize));\n            res.ipStatus = ppresNotIP;\n        }\n    }\n    \n    if (res.ipStatus == ppresIPV4)\n    {\n        res.ipHeaderSize = ipHeaderSize;\n\n        // bit \"more fragments\" or fragment offset mean the packet is fragmented\n        res.IsFragment = (pIpHeader->v4.ip_offset & ~0xC0) != 0;\n        switch (pIpHeader->v4.ip_protocol)\n        {\n            case PROTOCOL_TCP:\n            {\n                res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);\n            }\n            break;\n        case PROTOCOL_UDP:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, /* value */\n\t\t\t     0, /* index */\n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc < 0)\n\t\tdev_err(&port->dev, \"Reading line status failed (error = %d)\\n\",\n\t\t\trc);\n\telse {\n\t\tstatus = get_unaligned_le16(status_buf);\n\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\n\tkfree(status_buf);\n\treturn rc;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, /* value */\n\t\t\t     0, /* index */\n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc != KLSI_STATUSBUF_LEN) {\n\t\tdev_err(&port->dev, \"reading line status failed: %d\\n\", rc);\n\t\tif (rc >= 0)\n\t\t\trc = -EIO;\n\t} else {\n\t\tstatus = get_unaligned_le16(status_buf);\n\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\n\tkfree(status_buf);\n\treturn rc;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index) {\n  const bool use_tensor = index < node->inputs->size &&\n                          node->inputs->data[index] != kTfLiteOptionalTensor;\n  if (use_tensor) {\n    return GetMutableInput(context, node, index);\n  }\n  return nullptr;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index) {\n  return GetInput(context, node, index);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  int64_t num_batches = input_descriptor.count();\n  int64_t elements_per_batch_input = input_descriptor.NodesAcrossFeatureMaps();\n  int64_t elements_per_batch_output =\n      output_descriptor.NodesAcrossFeatureMaps();\n\n  int64_t max_batches_per_split =\n      std::numeric_limits<int>::max() / elements_per_batch_input;\n\n  if (max_batches_per_split == 0) {\n    return tsl::Status(\n        port::error::INTERNAL,\n        absl::StrCat(\n            \"Tensor has too many elements for int32 indexing: batches=\",\n            num_batches, \" elements_per_batch=\", elements_per_batch_input,\n            \".\"));\n  }\n\n  int64_t processed_batches = 0;\n  while (processed_batches < num_batches) {\n    int64_t num_batches_per_split =\n        std::min(max_batches_per_split, num_batches - processed_batches);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  int64_t num_batches = input_descriptor.count();\n  int64_t elements_per_batch_input = input_descriptor.NodesAcrossFeatureMaps();\n  int64_t elements_per_batch_output =\n      output_descriptor.NodesAcrossFeatureMaps();\n\n  int64_t max_batches_per_split =\n      std::numeric_limits<int>::max() / elements_per_batch_input;\n\n  if (max_batches_per_split == 0) {\n    return tsl::Status(\n        tsl::error::INTERNAL,\n        absl::StrCat(\n            \"Tensor has too many elements for int32 indexing: batches=\",\n            num_batches, \" elements_per_batch=\", elements_per_batch_input,\n            \".\"));\n  }\n\n  int64_t processed_batches = 0;\n  while (processed_batches < num_batches) {\n    int64_t num_batches_per_split =\n        std::min(max_batches_per_split, num_batches - processed_batches);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int setpwnam(struct passwd *pwd)\n{\n\tFILE *fp = NULL, *pwf = NULL;\n\tint save_errno;\n\tint found;\n\tint namelen;\n\tint buflen = 256;\n\tint contlen, rc;\n\tchar *linebuf = NULL;\n\tchar *tmpname = NULL;\n\tchar *atomic_dir = \"/etc\";\n\n\tpw_init();\n\n\tif ((fp = xfmkstemp(&tmpname, atomic_dir)) == NULL)\n\t\treturn -1;\n\n\t/* ptmp should be owned by root.root or root.wheel */\n\tif (fchown(fileno(fp), (uid_t) 0, (gid_t) 0) < 0)\n\t\tgoto fail;\n\n\t/* acquire exclusive lock */\n\tif (lckpwdf() < 0)\n\t\tgoto fail;\n\tpwf = fopen(PASSWD_FILE, \"r\");",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int setpwnam(struct passwd *pwd, const char *prefix)\n{\n\tFILE *fp = NULL, *pwf = NULL;\n\tint save_errno;\n\tint found;\n\tint namelen;\n\tint buflen = 256;\n\tint contlen, rc;\n\tchar *linebuf = NULL;\n\tchar *tmpname = NULL;\n\n\tpw_init();\n\n\tif ((fp = xfmkstemp(&tmpname, \"/etc\", prefix)) == NULL)\n\t\treturn -1;\n\n\t/* ptmp should be owned by root.root or root.wheel */\n\tif (fchown(fileno(fp), (uid_t) 0, (gid_t) 0) < 0)\n\t\tgoto fail;\n\n\t/* acquire exclusive lock */\n\tif (lckpwdf() < 0)\n\t\tgoto fail;\n\tpwf = fopen(PASSWD_FILE, \"r\");",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tZ_TYPE_P(return_value) = IS_OBJECT;\n\n\tif (ce->constructor->common.scope != spl_ce_SplFileInfo) {\n\t\tMAKE_STD_ZVAL(arg1);\n\t\tZVAL_STRINGL(arg1, file_path, file_path_len, use_copy);\n\t\tzend_call_method_with_1_params(&return_value, ce, &ce->constructor, \"__construct\", NULL, arg1);\n\t\tzval_ptr_dtor(&arg1);\n\t} else {\n\t\tspl_filesystem_info_set_filename(intern, file_path, file_path_len, use_copy TSRMLS_CC);\n\t}\n\t\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\treturn intern;\n} /* }}} */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tZ_TYPE_P(return_value) = IS_OBJECT;\n\n\tif (ce->constructor->common.scope != spl_ce_SplFileInfo) {\n\t\tMAKE_STD_ZVAL(arg1);\n\t\tZVAL_STRINGL(arg1, file_path, file_path_len, use_copy);\n\t\tzend_call_method_with_1_params(&return_value, ce, &ce->constructor, \"__construct\", NULL, arg1);\n\t\tzval_ptr_dtor(&arg1);\n\t} else {\n\t\tspl_filesystem_info_set_filename(intern, file_path, file_path_len, use_copy TSRMLS_CC);\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\treturn intern;\n} /* }}} */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        length = (Py_ssize_t) slen;\n        if (start < 0) {\n            start += length;\n            if (start < 0)\n                start = 0;\n        }\n        if (stop < 0)\n            stop += length;\n    }\n    if (unlikely(stop <= start))\n        return PyUnicode_FromUnicode(NULL, 0);\n    length = stop - start;\n    cstring += start;\n    if (decode_func) {\n        return decode_func(cstring, length, errors);\n    } else {\n        return PyUnicode_Decode(cstring, length, encoding, errors);\n    }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        length = (Py_ssize_t) slen;\n        if (start < 0) {\n            start += length;\n            if (start < 0)\n                start = 0;\n        }\n        if (stop < 0)\n            stop += length;\n    }\n    if (unlikely(stop <= start))\n        return __Pyx_NewRef(__pyx_empty_unicode);\n    length = stop - start;\n    cstring += start;\n    if (decode_func) {\n        return decode_func(cstring, length, errors);\n    } else {\n        return PyUnicode_Decode(cstring, length, encoding, errors);\n    }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        fe = fe2;\n        tlm2 = fe->fi_time_last_mod;\n        filenum = fiu+1;\n\n        /*  The space character at the end of line is silly,\n            but lets leave it there for the moment to avoid\n            changing output.  */\n        if (line_context->lc_file_entry_count > 9) {\n            dwarfstring_append_printf_u(&m3,\n                \"  file[%2u] \",fiu);\n            dwarfstring_append_printf_s(&m3,\n                \"%-20s \",\n                (char *) fe->fi_file_name);\n            dwarfstring_append_printf_u(&m3,\n                \"(file-number: %u)\\n\",\n                filenum);\n        } else {\n            dwarfstring_append_printf_u(&m3,\n                \"  file[%u]  \", fiu);\n            dwarfstring_append_printf_s(&m3,\n                \"%-20s \",(char *)fe->fi_file_name);\n            dwarfstring_append_printf_u(&m3,\n                \"(file-number: %u)\\n\",filenum);\n        }\n        _dwarf_printf(dbg,dwarfstring_string(&m3));\n        dwarfstring_reset(&m3);\n        if (fe->fi_dir_index_present) {\n            Dwarf_Unsigned di = 0;\n            di = fe->fi_dir_index;\n            dwarfstring_append_printf_i(&m3,\n                \"    dir index %d\\n\", di);\n        }\n        if (fe->fi_time_last_mod_present) {\n            time_t tt = (time_t) tlm2;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n        fe = fe2;\n        tlm2 = fe->fi_time_last_mod;\n        filenum = fiu+1;\n\n        /*  The space character at the end of line is silly,\n            but lets leave it there for the moment to avoid\n            changing output.  */\n        if (line_context->lc_file_entry_count > 9) {\n            dwarfstring_append_printf_u(&m3,\n                \"  file[%2u] \",fiu);\n        } else {\n            dwarfstring_append_printf_u(&m3,\n                \"  file[%u]  \", fiu);\n        }\n        /*  DWARF5 can have a null fi_file_name\n            if  the format code in the\n            line table header is unknown, such\n            as in a corrupt object file. */\n        dwarfstring_append_printf_s(&m3,\n            \"%-20s \",\n            fe->fi_file_name?\n            (char *) fe->fi_file_name:\n            \"<no file name>\");\n        dwarfstring_append_printf_u(&m3,\n            \"(file-number: %u)\\n\",\n            filenum);\n        _dwarf_printf(dbg,dwarfstring_string(&m3));\n        dwarfstring_reset(&m3);\n        if (fe->fi_dir_index_present) {\n            Dwarf_Unsigned di = 0;\n            di = fe->fi_dir_index;\n            dwarfstring_append_printf_i(&m3,\n                \"    dir index %d\\n\", di);\n        }\n        if (fe->fi_time_last_mod_present) {\n            time_t tt = (time_t) tlm2;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static Jsi_RC jsi_ArrayUnshiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    Jsi_Obj *obj = _this->d.obj;\n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = Jsi_ObjGetLength(interp, obj);\n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    if (argc <= 0) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    if (Jsi_ObjArraySizer(interp, obj, curlen+argc)<=0) \n        return Jsi_LogError(\"too long\");\n    memmove(obj->arr+argc, obj->arr, (curlen)*sizeof(Jsi_Value*));\n    obj->arrCnt += argc;\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        obj->arr[i] = NULL;\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); continue; }\n        obj->arr[i] = ov;\n        Jsi_IncrRefCount(interp, ov);\n    }\n    Jsi_ObjSetLength(interp, obj, curlen+argc);\n    \n    Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj));\n    return JSI_OK;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static Jsi_RC jsi_ArrayUnshiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    Jsi_Obj *obj = _this->d.obj;\n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = jsi_SizeOfArray(interp, obj);\n    if (argc <= 0) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    if (Jsi_ObjArraySizer(interp, obj, curlen+argc)<=0) \n        return Jsi_LogError(\"too long\");\n    memmove(obj->arr+argc, obj->arr, (curlen)*sizeof(Jsi_Value*));\n    obj->arrCnt += argc;\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        obj->arr[i] = NULL;\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); continue; }\n        obj->arr[i] = ov;\n        Jsi_IncrRefCount(interp, ov);\n    }\n    Jsi_ObjSetLength(interp, obj, curlen+argc);\n    \n    Jsi_ValueMakeNumber(interp, ret, jsi_SizeOfArray(interp, obj));\n    return JSI_OK;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "asmlinkage __visible void __init xen_start_kernel(void)\n{\n\tstruct physdev_set_iopl set_iopl;\n\tunsigned long initrd_start = 0;\n\tint rc;\n\n\tif (!xen_start_info)\n\t\treturn;\n\n\t__text_gen_insn(&early_xen_iret_patch,\n\t\t\tJMP32_INSN_OPCODE, &early_xen_iret_patch, &xen_iret,\n\t\t\tJMP32_INSN_SIZE);\n\n\txen_domain_type = XEN_PV_DOMAIN;\n\txen_start_flags = xen_start_info->flags;\n\n\txen_setup_features();\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "asmlinkage __visible void __init xen_start_kernel(struct start_info *si)\n{\n\tstruct physdev_set_iopl set_iopl;\n\tunsigned long initrd_start = 0;\n\tint rc;\n\n\tif (!si)\n\t\treturn;\n\n\tclear_bss();\n\n\txen_start_info = si;\n\n\t__text_gen_insn(&early_xen_iret_patch,\n\t\t\tJMP32_INSN_OPCODE, &early_xen_iret_patch, &xen_iret,\n\t\t\tJMP32_INSN_SIZE);\n\n\txen_domain_type = XEN_PV_DOMAIN;\n\txen_start_flags = xen_start_info->flags;\n\n\txen_setup_features();\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tbreak;\n\tcase PCIBAR_MEM64:\n\t\tdev->bar[idx].addr &= ~0xffffffffUL;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tcase PCIBAR_MEMHI64:\n\t\tdev->bar[idx].addr &= 0xffffffff;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tdefault:\n\t\tassert(0);\n\t}\n\n\tif (decode)\n\t\tregister_bar(dev, idx);\n\n\t/* update bar mapping */\n\tif (dev->dev_ops->vdev_update_bar_map && decode)\n\t\tdev->dev_ops->vdev_update_bar_map(ctx, dev, idx, orig_addr);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tbreak;\n\tcase PCIBAR_MEM64:\n\t\tdev->bar[idx].addr &= ~0xffffffffUL;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tcase PCIBAR_MEMHI64:\n\t\tdev->bar[idx].addr &= 0xffffffff;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: invalid bar type %d\\n\", __func__, type);\n\t\treturn;\n\t}\n\n\tif (decode)\n\t\tregister_bar(dev, idx);\n\n\t/* update bar mapping */\n\tif (dev->dev_ops->vdev_update_bar_map && decode)\n\t\tdev->dev_ops->vdev_update_bar_map(ctx, dev, idx, orig_addr);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n  if (query_string) {\n    // ntop->getTrace()->traceEvent(TRACE_WARNING, \"[HTTP] %s\", query_string);\n\n    tok = strtok_r(query_string, \"&\", &where);\n\n    while(tok != NULL) {\n      char *_equal;\n\n      if(strncmp(tok, \"csrf\", strlen(\"csrf\")) /* Do not put csrf into the params table */\n\t && (_equal = strchr(tok, '='))) {\n\tchar *decoded_buf;\n        int len;\n\n        _equal[0] = '\\0';\n        _equal = &_equal[1];\n        len = strlen(_equal);\n\n        purifyHTTPParameter(tok), purifyHTTPParameter(_equal);\n\n        // ntop->getTrace()->traceEvent(TRACE_WARNING, \"%s = %s\", tok, _equal);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n  if (query_string) {\n    // ntop->getTrace()->traceEvent(TRACE_WARNING, \"[HTTP] %s\", query_string);\n\n    tok = strtok_r(query_string, \"&\", &where);\n\n    while(tok != NULL) {\n      char *_equal;\n\n      if(strncmp(tok, \"csrf\", strlen(\"csrf\")) /* Do not put csrf into the params table */\n\t && (_equal = strchr(tok, '='))\n\t && (strlen(_equal) > 1)) {\n\tchar *decoded_buf;\n        int len;\n\n        _equal[0] = '\\0';\n        _equal = &_equal[1];\n        len = strlen(_equal);\n\n        purifyHTTPParameter(tok), purifyHTTPParameter(_equal);\n\n        // ntop->getTrace()->traceEvent(TRACE_WARNING, \"%s = %s\", tok, _equal);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  // Reinterprete the opaque data provided by user.\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n\n  const TfLiteType type = input1->type;\n  switch (type) {\n    case kTfLiteFloat32:\n    case kTfLiteInt32:\n      break;\n    default:\n      context->ReportError(context, \"Type '%s' is not supported by floor_div.\",",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  // Reinterprete the opaque data provided by user.\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n\n  const TfLiteType type = input1->type;\n  switch (type) {\n    case kTfLiteFloat32:\n    case kTfLiteInt32:\n      break;\n    default:\n      context->ReportError(context, \"Type '%s' is not supported by floor_div.\",",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n      // If we do not have any more data in file to read, we must process\n      // what we have until last byte. Otherwise we can return and append\n      // more data to unprocessed few bytes.\n      if ((D.Inp.InAddr>=DataBorder) && !D.NoDataLeft || D.Inp.InAddr>=D.DataSize)\n      {\n        D.Incomplete=true;\n        break;\n      }\n    }\n    if (((WriteBorder-UnpPtr) & MaxWinMask)<MAX_LZ_MATCH+3 && WriteBorder!=UnpPtr)\n    {\n      UnpWriteBuf();\n      if (WrittenFileSize>DestUnpSize)\n        return false;\n    }\n\n    uint MainSlot=DecodeNumber(D.Inp,&D.BlockTables.LD);\n    if (MainSlot<256)\n    {\n      Window[UnpPtr++]=(byte)MainSlot;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n      // If we do not have any more data in file to read, we must process\n      // what we have until last byte. Otherwise we can return and append\n      // more data to unprocessed few bytes.\n      if ((D.Inp.InAddr>=DataBorder) && !D.NoDataLeft || D.Inp.InAddr>=D.DataSize)\n      {\n        D.Incomplete=true;\n        break;\n      }\n    }\n    if (((WriteBorder-UnpPtr) & MaxWinMask)<MAX_INC_LZ_MATCH && WriteBorder!=UnpPtr)\n    {\n      UnpWriteBuf();\n      if (WrittenFileSize>DestUnpSize)\n        return false;\n    }\n\n    uint MainSlot=DecodeNumber(D.Inp,&D.BlockTables.LD);\n    if (MainSlot<256)\n    {\n      Window[UnpPtr++]=(byte)MainSlot;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  switch (sock->getType()) {\n  case AF_UNIX:\n    {\n#ifdef _MSC_VER\n      return false;\n#else\n      struct sockaddr_un *sa = (struct sockaddr_un *)sock_type;\n      sa->sun_family = AF_UNIX;\n      if (addr.length() > sizeof(sa->sun_path)) {\n        raise_warning(\n          \"Unix socket path length (%d) is larger than system limit (%lu)\",\n          addr.length(),\n          sizeof(sa->sun_path)\n        );\n        return false;\n      }\n      memcpy(sa->sun_path, addr.data(), addr.length());\n      sa_ptr = (struct sockaddr *)sa;\n      sa_size = offsetof(struct sockaddr_un, sun_path) + addr.length();\n#ifdef __linux__\n      if (addr.length() == 0) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  switch (sock->getType()) {\n  case AF_UNIX:\n    {\n#ifdef _MSC_VER\n      return false;\n#else\n      struct sockaddr_un *sa = (struct sockaddr_un *)sock_type;\n      sa->sun_family = AF_UNIX;\n      if (addr.length() > sizeof(sa->sun_path)) {\n        raise_warning(\n          \"Unix socket path length (%ld) is larger than system limit (%lu)\",\n          addr.length(),\n          sizeof(sa->sun_path)\n        );\n        return false;\n      }\n      memcpy(sa->sun_path, addr.data(), addr.length());\n      sa_ptr = (struct sockaddr *)sa;\n      sa_size = offsetof(struct sockaddr_un, sun_path) + addr.length();\n#ifdef __linux__\n      if (addr.length() == 0) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    ogs_getopt_t options;\n    struct {\n        char *config_file;\n        char *log_file;\n        char *log_level;\n        char *domain_mask;\n\n        bool enable_debug;\n        bool enable_trace;\n    } optarg;\n    const char *argv_out[argc];\n\n    memset(&optarg, 0, sizeof(optarg));\n\n    ogs_getopt_init(&options, (char**)argv);\n    while ((opt = ogs_getopt(&options, \"vhDc:l:e:m:dt\")) != -1) {\n        switch (opt) {\n        case 'v':\n            show_version();\n            return OGS_OK;\n        case 'h':",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    ogs_getopt_t options;\n    struct {\n        char *config_file;\n        char *log_file;\n        char *log_level;\n        char *domain_mask;\n\n        bool enable_debug;\n        bool enable_trace;\n    } optarg;\n    const char *argv_out[argc+1];\n\n    memset(&optarg, 0, sizeof(optarg));\n\n    ogs_getopt_init(&options, (char**)argv);\n    while ((opt = ogs_getopt(&options, \"vhDc:l:e:m:dt\")) != -1) {\n        switch (opt) {\n        case 'v':\n            show_version();\n            return OGS_OK;\n        case 'h':",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n  if (blocktyp == POST_BINARY) {\n    output_current_post();\n    blocktyp = POST_ASCII;\n  }\n  /* Mac line endings */\n  if (len > 0 && s[len-1] == '\\n')\n    s[len-1] = '\\r';\n  t1mac_output_data((byte *)s, len);\n  if (strncmp(s, \"/FontName\", 9) == 0) {\n    for (s += 9; isspace(*s); s++) ;\n    if (*s == '/') {\n      const char *t = ++s;\n      while (*t && !isspace(*t)) t++;\n      free(font_name);\n      font_name = (char *)malloc(t - s + 1);\n      memcpy(font_name, s, t - s);\n      font_name[t - s] = 0;\n    }\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n  if (blocktyp == POST_BINARY) {\n    output_current_post();\n    blocktyp = POST_ASCII;\n  }\n  /* Mac line endings */\n  if (len > 0 && s[len-1] == '\\n')\n    s[len-1] = '\\r';\n  t1mac_output_data((byte *)s, len);\n  if (strncmp(s, \"/FontName\", 9) == 0) {\n    for (s += 9; isspace((unsigned char) *s); s++)\n        /* skip */;\n    if (*s == '/') {\n      const char *t = ++s;\n      while (*t && !isspace((unsigned char) *t)) t++;\n      free(font_name);\n      font_name = (char *)malloc(t - s + 1);\n      memcpy(font_name, s, t - s);\n      font_name[t - s] = 0;\n    }\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      DSA_Verification_Operation(const DSA_PublicKey& dsa,\n                                 const std::string& emsa) :\n         PK_Ops::Verification_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_y(dsa.get_y()),\n         m_mod_q(dsa.group_q())\n         {}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      DSA_Verification_Operation(const DSA_PublicKey& dsa,\n                                 const std::string& emsa) :\n         PK_Ops::Verification_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_y(dsa.get_y()),\n         m_mod_q(dsa.group_q())\n         {\n         }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t    --depth;\n\t\t    line_breakcheck();\n\t\t    ins_compl_check_keys(50, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Do one more byte at this node.\n\t\t    n = arridx[depth] + curi[depth];\n\t\t    ++curi[depth];\n\t\t    c = byts[n];\n\t\t    if (c == 0)\n\t\t    {\n\t\t\t// End of word, deal with the word.\n\t\t\t// Don't use keep-case words in the fold-case tree,\n\t\t\t// they will appear in the keep-case tree.\n\t\t\t// Only use the word when the region matches.\n\t\t\tflags = (int)idxs[n];\n\t\t\tif ((round == 2 || (flags & WF_KEEPCAP) == 0)\n\t\t\t\t&& (flags & WF_NEEDCOMP) == 0\n\t\t\t\t&& (do_region\n\t\t\t\t    || (flags & WF_REGION) == 0\n\t\t\t\t    || (((unsigned)flags >> 16)\n\t\t\t\t\t\t       & lp->lp_region) != 0))",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t    --depth;\n\t\t    line_breakcheck();\n\t\t    ins_compl_check_keys(50, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Do one more byte at this node.\n\t\t    n = arridx[depth] + curi[depth];\n\t\t    ++curi[depth];\n\t\t    c = byts[n];\n\t\t    if (c == 0 || depth >= MAXWLEN - 1)\n\t\t    {\n\t\t\t// End of word or reached maximum length, deal with the\n\t\t\t// word.\n\t\t\t// Don't use keep-case words in the fold-case tree,\n\t\t\t// they will appear in the keep-case tree.\n\t\t\t// Only use the word when the region matches.\n\t\t\tflags = (int)idxs[n];\n\t\t\tif ((round == 2 || (flags & WF_KEEPCAP) == 0)\n\t\t\t\t&& (flags & WF_NEEDCOMP) == 0\n\t\t\t\t&& (do_region\n\t\t\t\t    || (flags & WF_REGION) == 0\n\t\t\t\t    || (((unsigned)flags >> 16)\n\t\t\t\t\t\t       & lp->lp_region) != 0))",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    if (GSSINT_CHK_LOOP(ctx))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    status = gssint_delete_internal_sec_context(minor_status,\n\t\t\t\t\t\tctx->mech_type,\n\t\t\t\t\t\t&ctx->internal_ctx_id,\n\t\t\t\t\t\toutput_token);\n    if (status)\n\treturn status;\n\n    /* now free up the space for the union context structure */\n    free(ctx->mech_type->elements);\n    free(ctx->mech_type);\n    free(*context_handle);\n    *context_handle = GSS_C_NO_CONTEXT;\n\n    return (GSS_S_COMPLETE);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    if (GSSINT_CHK_LOOP(ctx))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n\tstatus = gssint_delete_internal_sec_context(minor_status,\n\t\t\t\t\t\t    ctx->mech_type,\n\t\t\t\t\t\t    &ctx->internal_ctx_id,\n\t\t\t\t\t\t    output_token);\n\tif (status)\n\t    return status;\n    }\n\n    /* now free up the space for the union context structure */\n    free(ctx->mech_type->elements);\n    free(ctx->mech_type);\n    free(*context_handle);\n    *context_handle = GSS_C_NO_CONTEXT;\n\n    return (GSS_S_COMPLETE);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int mongo_env_read_socket( mongo *conn, void *buf, int len ) {\n    char *cbuf = buf;\n\n    while ( len ) {\n        int sent = recv( conn->sock, cbuf, len, 0 );\n        if ( sent == 0 || sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() );\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n\n    return MONGO_OK;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int mongo_env_read_socket( mongo *conn, void *buf, size_t len ) {\n    char *cbuf = buf;\n\n    while ( len ) {\n        size_t sent = recv( conn->sock, cbuf, len, 0 );\n        if ( sent == 0 || sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() );\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n\n    return MONGO_OK;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static ssize_t k90_show_macro_mode(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tconst char *macro_mode;\n\tchar data[8];\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_GET_MODE,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 2,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial mode (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\n\tswitch (data[0]) {\n\tcase K90_MACRO_MODE_HW:\n\t\tmacro_mode = \"HW\";\n\t\tbreak;\n\n\tcase K90_MACRO_MODE_SW:\n\t\tmacro_mode = \"SW\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"K90 in unknown mode: %02hhx.\\n\",\n\t\t\t data[0]);\n\t\treturn -EIO;\n\t}\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", macro_mode);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static ssize_t k90_show_macro_mode(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tconst char *macro_mode;\n\tchar *data;\n\n\tdata = kmalloc(2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_GET_MODE,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 2,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial mode (error %d).\\n\",\n\t\t\t ret);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tswitch (data[0]) {\n\tcase K90_MACRO_MODE_HW:\n\t\tmacro_mode = \"HW\";\n\t\tbreak;\n\n\tcase K90_MACRO_MODE_SW:\n\t\tmacro_mode = \"SW\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"K90 in unknown mode: %02hhx.\\n\",\n\t\t\t data[0]);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = snprintf(buf, PAGE_SIZE, \"%s\\n\", macro_mode);\nout:\n\tkfree(data);\n\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tuint_fast32_t rpx;\n\tuint_fast32_t rpy;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps; ++pi->compno,\n\t  ++pi->picomp) {\n\t\tpirlvl = pi->picomp->pirlvls;\n\t\tpi->xstep = pi->picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls - 1));\n\t\tpi->ystep = pi->picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcheightexpn + pi->picomp->numrlvls - 1));\n\t\tfor (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];\n\t\t  rlvlno < pi->picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp *\n\t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcwidthexpn +\n\t\t\t  pi->picomp->numrlvls - rlvlno - 1)));\n\t\t\tpi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp *\n\t\t\t\t  pi->rlvlno < pi->picomp->numrlvls && pi->rlvlno <\n\t\t\t\t  pchg->rlvlnoend; ++pi->rlvlno, ++pi->pirlvl) {\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;\n\t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);\n\t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n\t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n\t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n\t\t\t\t\tif (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx))) ||\n\t\t\t\t\t  !(pi->x % (pi->picomp->hsamp << rpx))) &&\n\t\t\t\t\t  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy))) ||\n\t\t\t\t\t  !(pi->y % (pi->picomp->vsamp << rpy)))) {\n\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,\n\t\t\t\t\t\t  pi->pirlvl->prcwidthexpn);\n\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,\n\t\t\t\t\t\t  pi->pirlvl->prcheightexpn);\n\t\t\t\t\t\tpi->prcno = prcvind *\n\t\t\t\t\t\t  pi->pirlvl->numhprcs +\n\t\t\t\t\t\t  prchind;\n\t\t\t\t\t\tassert(pi->prcno <\n\t\t\t\t\t\t  pi->pirlvl->numprcs);\n\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno <\n\t\t\t\t\t\t  pi->numlyrs && pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {\n\t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\nskip:\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tuint_fast32_t rpx;\n\tuint_fast32_t rpy;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->compno = pchg->compnostart, pi->picomp = &pi->picomps[pi->compno];\n\t  pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps;\n\t  ++pi->compno, ++pi->picomp) {\n\t\tpirlvl = pi->picomp->pirlvls;\n\t\t// Check for the potential for overflow problems.\n\t\tif (pirlvl->prcwidthexpn + pi->picomp->numrlvls >\n\t\t  JAS_UINTFAST32_NUMBITS - 2 ||\n\t\t  pirlvl->prcheightexpn + pi->picomp->numrlvls >\n\t\t  JAS_UINTFAST32_NUMBITS - 2) {\n\t\t\treturn -1;\n\t\t}\n\t\tpi->xstep = pi->picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls - 1));\n\t\tpi->ystep = pi->picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcheightexpn + pi->picomp->numrlvls - 1));\n\t\tfor (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];\n\t\t  rlvlno < pi->picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp *\n\t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcwidthexpn +\n\t\t\t  pi->picomp->numrlvls - rlvlno - 1)));\n\t\t\tpi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp *\n\t\t\t\t  pi->rlvlno < pi->picomp->numrlvls && pi->rlvlno <\n\t\t\t\t  pchg->rlvlnoend; ++pi->rlvlno, ++pi->pirlvl) {\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;\n\t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);\n\t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n\t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n\t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n\t\t\t\t\tif (((pi->x == pi->xstart &&\n\t\t\t\t\t  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx))) ||\n\t\t\t\t\t  !(pi->x % (pi->picomp->hsamp << rpx))) &&\n\t\t\t\t\t  ((pi->y == pi->ystart &&\n\t\t\t\t\t  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy))) ||\n\t\t\t\t\t  !(pi->y % (pi->picomp->vsamp << rpy)))) {\n\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,\n\t\t\t\t\t\t  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -\n\t\t\t\t\t\t  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);\n\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y,\n\t\t\t\t\t\t  pi->picomp->vsamp << r), pi->pirlvl->prcheightexpn) -\n\t\t\t\t\t\t  JPC_FLOORDIVPOW2(try0, pi->pirlvl->prcheightexpn);\n\t\t\t\t\t\tpi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;\n\t\t\t\t\t\tassert(pi->prcno < pi->pirlvl->numprcs);\n\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno < pi->numlyrs &&\n\t\t\t\t\t\t  pi->lyrno < JAS_CAST(int, pchg->lyrnoend);\n\t\t\t\t\t\t  ++pi->lyrno) {\n\t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\nskip:\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t} else if (ZEND_NUM_ARGS()) {\n\t\tintern->file_name_len = slprintf(tmp_fname, sizeof(tmp_fname), \"php://temp/maxmemory:%ld\", max_memory);\n\t\tintern->file_name = tmp_fname;\n\t} else {\n\t\tintern->file_name = \"php://temp\";\n\t\tintern->file_name_len = 10;\n\t}\n\tintern->u.file.open_mode = \"wb\";\n\tintern->u.file.open_mode_len = 1;\n\tintern->u.file.zcontext = NULL;\n\t\n\tif (spl_filesystem_file_open(intern, 0, 0 TSRMLS_CC) == SUCCESS) {\n\t\tintern->_path_len = 0;\n\t\tintern->_path = estrndup(\"\", 0);\n\t}\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n} /* }}} */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t} else if (ZEND_NUM_ARGS()) {\n\t\tintern->file_name_len = slprintf(tmp_fname, sizeof(tmp_fname), \"php://temp/maxmemory:%ld\", max_memory);\n\t\tintern->file_name = tmp_fname;\n\t} else {\n\t\tintern->file_name = \"php://temp\";\n\t\tintern->file_name_len = 10;\n\t}\n\tintern->u.file.open_mode = \"wb\";\n\tintern->u.file.open_mode_len = 1;\n\tintern->u.file.zcontext = NULL;\n\n\tif (spl_filesystem_file_open(intern, 0, 0 TSRMLS_CC) == SUCCESS) {\n\t\tintern->_path_len = 0;\n\t\tintern->_path = estrndup(\"\", 0);\n\t}\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n} /* }}} */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "obj2ast_withitem(PyObject* obj, withitem_ty* out, PyArena* arena)\n{\n    PyObject* tmp = NULL;\n    expr_ty context_expr;\n    expr_ty optional_vars;\n\n    if (_PyObject_HasAttrId(obj, &PyId_context_expr)) {\n        int res;\n        tmp = _PyObject_GetAttrId(obj, &PyId_context_expr);\n        if (tmp == NULL) goto failed;\n        res = obj2ast_expr(tmp, &context_expr, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    } else {\n        PyErr_SetString(PyExc_TypeError, \"required field \\\"context_expr\\\" missing from withitem\");\n        return 1;\n    }\n    if (exists_not_none(obj, &PyId_optional_vars)) {\n        int res;\n        tmp = _PyObject_GetAttrId(obj, &PyId_optional_vars);\n        if (tmp == NULL) goto failed;\n        res = obj2ast_expr(tmp, &optional_vars, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    } else {\n        optional_vars = NULL;\n    }\n    *out = withitem(context_expr, optional_vars, arena);\n    return 0;\nfailed:\n    Py_XDECREF(tmp);\n    return 1;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "obj2ast_withitem(PyObject* obj, withitem_ty* out, PyArena* arena)\n{\n    PyObject* tmp = NULL;\n    expr_ty context_expr;\n    expr_ty optional_vars;\n\n    if (lookup_attr_id(obj, &PyId_context_expr, &tmp) < 0) {\n        return 1;\n    }\n    if (tmp == NULL) {\n        PyErr_SetString(PyExc_TypeError, \"required field \\\"context_expr\\\" missing from withitem\");\n        return 1;\n    }\n    else {\n        int res;\n        res = obj2ast_expr(tmp, &context_expr, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    }\n    if (lookup_attr_id(obj, &PyId_optional_vars, &tmp) < 0) {\n        return 1;\n    }\n    if (tmp == NULL || tmp == Py_None) {\n        Py_CLEAR(tmp);\n        optional_vars = NULL;\n    }\n    else {\n        int res;\n        res = obj2ast_expr(tmp, &optional_vars, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    }\n    *out = withitem(context_expr, optional_vars, arena);\n    return 0;\nfailed:\n    Py_XDECREF(tmp);\n    return 1;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ppp_hdlc(netdissect_options *ndo,\n         const u_char *p, u_int length)\n{\n\tu_int caplen = ND_BYTES_AVAILABLE_AFTER(p);\n\tu_char *b, *t, c;\n\tconst u_char *s;\n\tu_int i, proto;\n\tconst void *sb, *se;\n\n\tif (caplen == 0)\n\t\treturn;\n\n        if (length == 0)\n                return;\n\n\tb = (u_char *)nd_malloc(ndo, caplen);\n\tif (b == NULL)\n\t\treturn;\n\n\t/*\n\t * Unescape all the data into a temporary, private, buffer.\n\t * Do this so that we don't overwrite the original packet\n\t * contents.\n\t */\n\tfor (s = p, t = b, i = caplen; i != 0; i--) {\n\t\tc = GET_U_1(s);\n\t\ts++;\n\t\tif (c == 0x7d) {\n\t\t\tif (i <= 1)\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t\tc = GET_U_1(s) ^ 0x20;\n\t\t\ts++;\n\t\t}\n\t\t*t++ = c;\n\t}\n\n\t/*\n\t * Change the end pointer, so bounds checks work.\n\t * Change the pointer to packet data to help debugging.\n\t */\n\tsb = ndo->ndo_packetp;\n\tse = ndo->ndo_snapend;\n\tndo->ndo_packetp = b;\n\tndo->ndo_snapend = t;\n\tlength = ND_BYTES_AVAILABLE_AFTER(b);\n\n        /* now lets guess about the payload codepoint format */\n        if (length < 1)\n                goto trunc;\n        proto = GET_U_1(b); /* start with a one-octet codepoint guess */\n\n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n            break;\n        default: /* last guess - proto must be a PPP proto-id */\n            if ((proto & 0xff00) == 0x7e00)\n                ND_PRINT(\"(protocol 0x%04x invalid)\", proto);\n            else\n                handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\n\ncleanup:\n\tndo->ndo_packetp = sb;\n\tndo->ndo_snapend = se;\n        return;\n\ntrunc:\n\tndo->ndo_packetp = sb;\n\tndo->ndo_snapend = se;\n\tnd_print_trunc(ndo);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ppp_hdlc(netdissect_options *ndo,\n         const u_char *p, u_int length)\n{\n\tu_int caplen = ND_BYTES_AVAILABLE_AFTER(p);\n\tu_char *b, *t, c;\n\tconst u_char *s;\n\tu_int i, proto;\n\n\tif (caplen == 0)\n\t\treturn;\n\n        if (length == 0)\n                return;\n\n\tb = (u_char *)malloc(caplen);\n\tif (b == NULL) {\n\t\t(*ndo->ndo_error)(ndo, S_ERR_ND_MEM_ALLOC,\n\t\t\t\"%s: malloc\", __func__);\n\t}\n\n\t/*\n\t * Unescape all the data into a temporary, private, buffer.\n\t * Do this so that we don't overwrite the original packet\n\t * contents.\n\t */\n\tfor (s = p, t = b, i = caplen; i != 0; i--) {\n\t\tc = GET_U_1(s);\n\t\ts++;\n\t\tif (c == 0x7d) {\n\t\t\tif (i <= 1)\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t\tc = GET_U_1(s) ^ 0x20;\n\t\t\ts++;\n\t\t}\n\t\t*t++ = c;\n\t}\n\n\t/*\n\t * Switch to the output buffer for dissection, and save it\n\t * on the buffer stack so it can be freed; our caller must\n\t * pop it when done.\n\t */\n\tif (!nd_push_buffer(ndo, b, b, (u_int)(t - b))) {\n\t\tfree(b);\n\t\t(*ndo->ndo_error)(ndo, S_ERR_ND_MEM_ALLOC,\n\t\t\t\"%s: can't push buffer on buffer stack\", __func__);\n\t}\n\tlength = ND_BYTES_AVAILABLE_AFTER(b);\n\n        /* now lets guess about the payload codepoint format */\n        if (length < 1)\n                goto trunc;\n        proto = GET_U_1(b); /* start with a one-octet codepoint guess */\n\n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n            break;\n        default: /* last guess - proto must be a PPP proto-id */\n            if ((proto & 0xff00) == 0x7e00)\n                ND_PRINT(\"(protocol 0x%04x invalid)\", proto);\n            else\n                handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\n\ncleanup:\n\tnd_pop_packet_info(ndo);\n        return;\n\ntrunc:\n\tnd_pop_packet_info(ndo);\n\tnd_print_trunc(ndo);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void CNativeControlEmbed::CreateObjectBuilderInContext(const std::string& name, JSSmart<CJSContext> context)\n{\n    v8::Isolate* current = CV8Worker::GetCurrent();\n    context->m_internal->m_global->Set(current, name.c_str(), v8::FunctionTemplate::New(current, NSNativeControl::CreateNativeObjectBuilder));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void CNativeControlEmbed::CreateObjectBuilderInContext(const std::string& name, JSSmart<CJSContext> context)\n{\n\tv8::Isolate* current = CV8Worker::GetCurrent();\n\tcontext->m_internal->m_global->Set(current, name.c_str(), v8::FunctionTemplate::New(current, NSNativeControl::CreateNativeObjectBuilder));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    void operator = (const IniSection &s)\n\t{\n\t    if (&s == this)\n\t    {\n\t\treturn;\n\t    } \n\t    IniBase::operator = (s);\n\t    ip = s.ip;\n\t    end_comment = s.end_comment; rewrite_by = s.rewrite_by;\n\t    container = s.container;\n\n\t    reindex ();\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    void operator = (const IniSection &s)\n\t{\n\t    if (&s == this)\n\t    {\n\t\treturn;\n\t    } \n\t    IniBase::operator = (s);\n\t    ip = s.ip;\n\t    end_comment = s.end_comment;\n            is_private = s.is_private;\n            rewrite_by = s.rewrite_by;\n\t    container = s.container;\n\n\t    reindex ();\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = valuelen;\n\t\tmemcpy(args->value, &name_loc->nameval[args->namelen], valuelen);\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tASSERT(name_rmt->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n\t\tvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n\t\t\t\t\t\t       valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = valuelen;\n\t}\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = valuelen;\n\t\tmemcpy(args->value, &name_loc->nameval[args->namelen], valuelen);\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tASSERT(name_rmt->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n\t\t\t\t\t\t       args->rmtvaluelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < args->rmtvaluelen) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = args->rmtvaluelen;\n\t}\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    else\n\tca.cmdchar = c;\n    idx = find_command(ca.cmdchar);\n    if (idx < 0)\n    {\n\t// Not a known command: beep.\n\tclearopbeep(oap);\n\tgoto normal_end;\n    }\n\n    if ((nv_cmds[idx].cmd_flags & NV_NCW)\n\t\t\t\t&& (check_text_locked(oap) || curbuf_locked()))\n\t// this command is not allowed now\n\tgoto normal_end;\n\n    // In Visual/Select mode, a few keys are handled in a special way.\n    if (VIsual_active)\n    {\n\t// when 'keymodel' contains \"stopsel\" may stop Select/Visual mode\n\tif (km_stopsel\n\t\t&& (nv_cmds[idx].cmd_flags & NV_STS)\n\t\t&& !(mod_mask & MOD_MASK_SHIFT))",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    else\n\tca.cmdchar = c;\n    idx = find_command(ca.cmdchar);\n    if (idx < 0)\n    {\n\t// Not a known command: beep.\n\tclearopbeep(oap);\n\tgoto normal_end;\n    }\n\n    if ((nv_cmds[idx].cmd_flags & NV_NCW) && check_text_or_curbuf_locked(oap))\n\t// this command is not allowed now\n\tgoto normal_end;\n\n    // In Visual/Select mode, a few keys are handled in a special way.\n    if (VIsual_active)\n    {\n\t// when 'keymodel' contains \"stopsel\" may stop Select/Visual mode\n\tif (km_stopsel\n\t\t&& (nv_cmds[idx].cmd_flags & NV_STS)\n\t\t&& !(mod_mask & MOD_MASK_SHIFT))",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong PPS ID %d in PPS\\n\", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &vvc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif (pps->sps_id >= 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\tvvc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->mixed_nal_types = gf_bs_read_int_log(bs, 1, \"mixed_nal_types\");\n\tpps->width = gf_bs_read_ue_log(bs, \"width\");\n\tpps->height = gf_bs_read_ue_log(bs, \"height\");\n\tpps->conf_window = gf_bs_read_int_log(bs, 1, \"conformance_window_flag\");\n\tif (pps->conf_window) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong PPS ID %d in PPS\\n\", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &vvc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif ((pps->sps_id<0) || (pps->sps_id >= 16)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\tvvc->sps_active_idx = pps->sps_id; /*set active sps*/\n\tpps->mixed_nal_types = gf_bs_read_int_log(bs, 1, \"mixed_nal_types\");\n\tpps->width = gf_bs_read_ue_log(bs, \"width\");\n\tpps->height = gf_bs_read_ue_log(bs, \"height\");\n\tpps->conf_window = gf_bs_read_int_log(bs, 1, \"conformance_window_flag\");\n\tif (pps->conf_window) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tfree (symbols);\n\n\tif (!addr && bin->main_cmd.cmd == LC_MAIN) {\n\t\taddr = bin->entry + bin->baddr;\n\t}\n\n\tif (!addr) {\n\t\tut8 b[128];\n\t\tut64 entry = addr_to_offset(bin, bin->entry);\n\t\t// XXX: X86 only and hacky!\n\t\tif (entry > bin->size || entry + sizeof (b) > bin->size)\n\t\t\treturn 0;\n\t\ti = r_buf_read_at (bin->b, entry, b, sizeof (b));\n\t\tif (i < 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tif (b[i] == 0xe8 && !b[i+3] && !b[i+4]) {\n\t\t\t\tint delta = b[i+1] | (b[i+2] << 8) | (b[i+3] << 16) | (b[i+4] << 24);\n\t\t\t\treturn bin->entry + i + 5 + delta;\n\n\t\t\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tfree (symbols);\n\n\tif (!addr && bin->main_cmd.cmd == LC_MAIN) {\n\t\taddr = bin->entry + bin->baddr;\n\t}\n\n\tif (!addr) {\n\t\tut8 b[128];\n\t\tut64 entry = addr_to_offset(bin, bin->entry);\n\t\t// XXX: X86 only and hacky!\n\t\tif (entry > bin->size || entry + sizeof (b) > bin->size) {\n\t\t\treturn 0;\n\t\t}\n\t\ti = r_buf_read_at (bin->b, entry, b, sizeof (b));\n\t\tif (i < 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tif (b[i] == 0xe8 && !b[i+3] && !b[i+4]) {\n\t\t\t\tint delta = b[i+1] | (b[i+2] << 8) | (b[i+3] << 16) | (b[i+4] << 24);\n\t\t\t\treturn bin->entry + i + 5 + delta;\n\n\t\t\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  }\n\n  if (upper_frequency_limit <= lower_frequency_limit) {\n    LOG(ERROR) << \"Upper frequency limit must be greater than \"\n               << \"lower frequency limit.\";\n    return false;\n  }\n\n  // An extra center frequency is computed at the top to get the upper\n  // limit on the high side of the final triangular filter.\n  center_frequencies_.resize(num_channels_ + 1);\n  const double mel_low = FreqToMel(lower_frequency_limit);\n  const double mel_hi = FreqToMel(upper_frequency_limit);\n  const double mel_span = mel_hi - mel_low;\n  const double mel_spacing = mel_span / static_cast<double>(num_channels_ + 1);\n  for (int i = 0; i < num_channels_ + 1; ++i) {\n    center_frequencies_[i] = mel_low + (mel_spacing * (i + 1));\n  }\n\n  // Always exclude DC; emulate HTK.\n  const double hz_per_sbin =",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  }\n\n  if (upper_frequency_limit <= lower_frequency_limit) {\n    LOG(ERROR) << \"Upper frequency limit must be greater than \"\n               << \"lower frequency limit.\";\n    return false;\n  }\n\n  // An extra center frequency is computed at the top to get the upper\n  // limit on the high side of the final triangular filter.\n  std::size_t center_frequencies_size = std::size_t(num_channels_) + 1;\n  if (center_frequencies_size >= std::numeric_limits<int>::max() ||\n      center_frequencies_size > center_frequencies_.max_size()) {\n    LOG(ERROR) << \"Number of filterbank channels must be less than \"\n               << std::numeric_limits<int>::max()\n               << \" and less than or equal to \"\n               << center_frequencies_.max_size();\n    return false;\n  }\n  center_frequencies_.resize(center_frequencies_size);\n\n  const double mel_low = FreqToMel(lower_frequency_limit);\n  const double mel_hi = FreqToMel(upper_frequency_limit);\n  const double mel_span = mel_hi - mel_low;\n  const double mel_spacing = mel_span / static_cast<double>(num_channels_ + 1);\n  for (int i = 0; i < num_channels_ + 1; ++i) {\n    center_frequencies_[i] = mel_low + (mel_spacing * (i + 1));\n  }\n\n  // Always exclude DC; emulate HTK.\n  const double hz_per_sbin =",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "struct btrfs_device *btrfs_find_device_by_devspec(\n\t\tstruct btrfs_fs_info *fs_info, u64 devid,\n\t\tconst char *device_path)\n{\n\tstruct btrfs_device *device;\n\n\tif (devid) {\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, NULL,\n\t\t\t\t\t   NULL);\n\t\tif (!device)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn device;\n\t}\n\n\tif (!device_path || !device_path[0])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\t/* Find first missing device */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "struct btrfs_device *btrfs_find_device_by_devspec(\n\t\tstruct btrfs_fs_info *fs_info, u64 devid,\n\t\tconst char *device_path)\n{\n\tstruct btrfs_device *device;\n\n\tif (devid) {\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, NULL,\n\t\t\t\t\t   NULL, true);\n\t\tif (!device)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn device;\n\t}\n\n\tif (!device_path || !device_path[0])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\t/* Find first missing device */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    const uint256 &epk,\n    const uint256 &cmu\n)\n{\n    auto pt = AttemptSaplingEncDecryption(ciphertext, ivk, epk);\n    if (!pt) {\n        return boost::none;\n    }\n\n    // Deserialize from the plaintext\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << pt.get();\n\n    SaplingNotePlaintext ret;\n    ss >> ret;\n\n    assert(ss.size() == 0);\n\n    uint256 pk_d;\n    if (!librustzcash_ivk_to_pkd(ivk.begin(), ret.d.data(), pk_d.begin())) {\n        return boost::none;\n    }\n\n    uint256 cmu_expected;\n    if (!librustzcash_sapling_compute_cm(\n        ret.d.data(),\n        pk_d.begin(),",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    const uint256 &ivk,\n    const uint256 &epk,\n    const uint256 &cmu\n)\n{\n    auto pt = AttemptSaplingEncDecryption(ciphertext, ivk, epk);\n    if (!pt) {\n        return boost::none;\n    }\n\n    // Deserialize from the plaintext\n    SaplingNotePlaintext ret;\n    try {\n        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n        ss << pt.get();\n        ss >> ret;\n        assert(ss.size() == 0);\n    } catch (const boost::thread_interrupted&) {\n        throw;\n    } catch (...) {\n        return boost::none;\n    }\n\n    uint256 pk_d;\n    if (!librustzcash_ivk_to_pkd(ivk.begin(), ret.d.data(), pk_d.begin())) {\n        return boost::none;\n    }\n\n    uint256 cmu_expected;\n    if (!librustzcash_sapling_compute_cm(\n        ret.d.data(),\n        pk_d.begin(),",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int http_connect(int sockfd, const char *host, int port, AyProxyData *proxy)\n{\n\t/* step two : do  proxy tunneling init */\n\tchar cmd[512];\n\tchar *inputline = NULL;\n\tchar *proxy_auth = NULL;\n\tchar debug_buff[512];\n\tint remaining = sizeof(cmd) - 1;\n\n\tremaining -= snprintf(cmd, sizeof(cmd), \"CONNECT %s:%d HTTP/1.1\\r\\n\", host, port);\n\tif (proxy->username && proxy->username[0]) {\n\t\tproxy_auth = encode_proxy_auth_str(proxy);\n\n\t\tstrncat(cmd, \"Proxy-Authorization: Basic \", remaining);\n\t\tremaining -= 27;\n\t\tstrncat(cmd, proxy_auth, remaining);\n\t\tremaining -= strlen(proxy_auth);\n\t\tstrncat(cmd, \"\\r\\n\", remaining);\n\t\tremaining -= 2;\n\t}\n\tstrncat(cmd, \"\\r\\n\", remaining);\n#ifndef DEBUG\n\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", cmd);\n\tdebug_print(debug_buff);\n#endif\n\tif (send(sockfd, cmd, strlen(cmd), 0) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n\tif (ay_recv_line(sockfd, &inputline) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n#ifndef DEBUG\n\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);\n\tdebug_print(debug_buff);\n#endif\n\tif (!strstr(inputline, \"200\")) {\n\t\t/* Check if proxy authorization needed */\n\t\tif (strstr(inputline, \"407\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\t\t\t\tfree(inputline);\n\t\t\t}\n\t\t\treturn AY_PROXY_AUTH_REQUIRED;\n\t\t}\n\t\tif (strstr(inputline, \"403\")) {\n\t\t}\n\t\tfree(inputline);\n\t\treturn AY_CONNECTION_REFUSED;\n\t}\n\n\twhile (strlen(inputline) > 1) {\n\t\tfree(inputline);\n\t\tif (ay_recv_line(sockfd, &inputline) < 0) {\n\t\t\treturn AY_CONNECTION_REFUSED;\n\t\t}\n#ifndef DEBUG\n\t\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);\n\t\tdebug_print(debug_buff);\n#endif\n\t}\n\tfree(inputline);\n\n\tg_free(proxy_auth);\n\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int http_connect(int sockfd, const char *host, int port, AyProxyData *proxy)\n{\n\t/* step two : do  proxy tunneling init */\n\tchar cmd[512];\n\tchar *inputline = NULL;\n\tchar *proxy_auth = NULL;\n\tint remaining = sizeof(cmd) - 1;\n\n\tremaining -= snprintf(cmd, sizeof(cmd), \"CONNECT %s:%d HTTP/1.1\\r\\n\", host, port);\n\tif (proxy->username && proxy->username[0]) {\n\t\tproxy_auth = encode_proxy_auth_str(proxy);\n\n\t\tstrncat(cmd, \"Proxy-Authorization: Basic \", remaining);\n\t\tremaining -= 27;\n\t\tstrncat(cmd, proxy_auth, remaining);\n\t\tremaining -= strlen(proxy_auth);\n\t\tstrncat(cmd, \"\\r\\n\", remaining);\n\t\tremaining -= 2;\n\t}\n\tstrncat(cmd, \"\\r\\n\", remaining);\n#ifdef DEBUG\n\tdebug_print(\"<%s>\\n\", cmd);\n#endif\n\tif (send(sockfd, cmd, strlen(cmd), 0) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n\tif (ay_recv_line(sockfd, &inputline) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n#ifdef DEBUG\n\tdebug_print(\"<%s>\\n\", inputline);\n#endif\n\tif (!strstr(inputline, \"200\")) {\n\t\t/* Check if proxy authorization needed */\n\t\tif (strstr(inputline, \"407\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\t\t\t\tfree(inputline);\n\t\t\t}\n\t\t\treturn AY_PROXY_AUTH_REQUIRED;\n\t\t}\n\t\tif (strstr(inputline, \"403\")) {\n\t\t}\n\t\tfree(inputline);\n\t\treturn AY_CONNECTION_REFUSED;\n\t}\n\n\twhile (strlen(inputline) > 1) {\n\t\tfree(inputline);\n\t\tif (ay_recv_line(sockfd, &inputline) < 0) {\n\t\t\treturn AY_CONNECTION_REFUSED;\n\t\t}\n#ifdef DEBUG\n\t\tdebug_print(\"<%s>\\n\", inputline);\n#endif\n\t}\n\tfree(inputline);\n\n\tg_free(proxy_auth);\n\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "            }\n        }\n\n        vector<string> public_shares(n);\n        for (int i = 0; i < n; ++i) {\n            public_shares[i] = publicShares[i].asString();\n        }\n\n        vector<string> public_keys = calculateAllBlsPublicKeys(public_shares);\n\n        if (public_keys.size() != n) {\n            throw SGXException(UNKNOWN_ERROR, \"\");\n        }\n\n        for (int i = 0; i < n; ++i) {\n            result[\"publicKeys\"][i] = public_keys[i];\n        }\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "            }\n        }\n\n        vector<string> public_shares(n);\n        for (int i = 0; i < n; ++i) {\n            public_shares[i] = publicShares[i].asString();\n        }\n\n        vector<string> public_keys = calculateAllBlsPublicKeys(public_shares);\n\n        if (public_keys.size() != (uint64_t)n) {\n            throw SGXException(UNKNOWN_ERROR, \"\");\n        }\n\n        for (int i = 0; i < n; ++i) {\n            result[\"publicKeys\"][i] = public_keys[i];\n        }\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    if (tok->atbol) {\n        int col = 0;\n        int altcol = 0;\n        tok->atbol = 0;\n        for (;;) {\n            c = tok_nextc(tok);\n            if (c == ' ') {\n                col++, altcol++;\n            }\n            else if (c == '\\t') {\n                col = (col/tok->tabsize + 1) * tok->tabsize;\n                altcol = (altcol/tok->alttabsize + 1)\n                    * tok->alttabsize;\n            }\n            else if (c == '\\014')  {/* Control-L (formfeed) */\n                col = altcol = 0; /* For Emacs users */\n            }\n            else {\n                break;\n            }\n        }\n        tok_backup(tok, c);\n        if (c == '#' || c == '\\n') {\n            else {\n                blankline = 1; /* Ignore completely */\n            }\n            /* We can't jump back right here since we still\n               may need to skip to the end of a comment */\n        }\n        if (!blankline && tok->level == 0) {\n            if (col == tok->indstack[tok->indent]) {\n                /* No change */\n                if (altcol != tok->altindstack[tok->indent]) {\n                    if (indenterror(tok)) {\n                        return ERRORTOKEN;\n                    }\n                }\n            }\n            else if (col > tok->indstack[tok->indent]) {\n                /* Indent -- always one */\n                if (tok->indent+1 >= MAXINDENT) {\n                    tok->done = E_TOODEEP;\n                    tok->cur = tok->inp;\n                    return ERRORTOKEN;\n                }\n                if (altcol <= tok->altindstack[tok->indent]) {\n                    if (indenterror(tok)) {\n                        return ERRORTOKEN;\n                    }\n                }\n                tok->pendin++;\n                tok->indstack[++tok->indent] = col;\n                tok->altindstack[tok->indent] = altcol;\n            }\n            else /* col < tok->indstack[tok->indent] */ {\n                /* Dedent -- any number, must be consistent */\n                while (tok->indent > 0 &&\n                    col < tok->indstack[tok->indent]) {\n                    tok->pendin--;\n                    tok->indent--;\n                }\n                if (col != tok->indstack[tok->indent]) {\n                    tok->done = E_DEDENT;\n                    tok->cur = tok->inp;\n                    return ERRORTOKEN;\n                }\n                if (altcol != tok->altindstack[tok->indent]) {\n                    if (indenterror(tok)) {\n                        return ERRORTOKEN;\n                    }\n                }\n            }\n        }\n    }\n\n    tok->start = tok->cur;\n\n    /* Return pending indents/dedents */\n    if (tok->pendin != 0) {\n        if (tok->pendin < 0) {\n    }\n\n    /* Check for EOF and errors now */\n    if (c == EOF) {\n        return tok->done == E_EOF ? ENDMARKER : ERRORTOKEN;\n    }\n\n    /* Identifier (most frequent token!) */\n    nonascii = 0;\n    if (is_potential_identifier_start(c)) {\n        /* Process b\"\", r\"\", u\"\", br\"\" and rb\"\" */\n        int saw_b = 0, saw_r = 0, saw_u = 0, saw_f = 0;\n        while (1) {\n            if (!(saw_b || saw_u || saw_f) && (c == 'b' || c == 'B'))\n                saw_b = 1;\n            /* Since this is a backwards compatibility support literal we don't\n               want to support it in arbitrary order like byte literals. */\n            else if (!(saw_b || saw_u || saw_r || saw_f)\n                     && (c == 'u'|| c == 'U')) {\n                saw_u = 1;\n            }\n        tok_backup(tok, c);\n        if (nonascii && !verify_identifier(tok)) {\n            return ERRORTOKEN;\n        }\n        *p_start = tok->start;\n        *p_end = tok->cur;\n\n        /* async/await parsing block. */\n        if (tok->cur - tok->start == 5) {\n            /* Current token length is 5. */\n            if (tok->async_def) {\n                /* We're inside an 'async def' function. */\n                if (memcmp(tok->start, \"async\", 5) == 0) {\n                    return ASYNC;\n                }\n                if (memcmp(tok->start, \"await\", 5) == 0) {\n                    return AWAIT;\n                }\n            }\n            else if (memcmp(tok->start, \"async\", 5) == 0) {\n                /* The current token is 'async'.",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    if (tok->atbol) {\n        int col = 0;\n        int altcol = 0;\n        tok->atbol = 0;\n        for (;;) {\n            c = tok_nextc(tok);\n            if (c == ' ') {\n                col++, altcol++;\n            }\n            else if (c == '\\t') {\n                col = (col / tok->tabsize + 1) * tok->tabsize;\n                altcol = (altcol / ALTTABSIZE + 1) * ALTTABSIZE;\n            }\n            else if (c == '\\014')  {/* Control-L (formfeed) */\n                col = altcol = 0; /* For Emacs users */\n            }\n            else {\n                break;\n            }\n        }\n        tok_backup(tok, c);\n        if (c == '#' || c == '\\n') {\n            else {\n                blankline = 1; /* Ignore completely */\n            }\n            /* We can't jump back right here since we still\n               may need to skip to the end of a comment */\n        }\n        if (!blankline && tok->level == 0) {\n            if (col == tok->indstack[tok->indent]) {\n                /* No change */\n                if (altcol != tok->altindstack[tok->indent]) {\n                    return indenterror(tok);\n                }\n            }\n            else if (col > tok->indstack[tok->indent]) {\n                /* Indent -- always one */\n                if (tok->indent+1 >= MAXINDENT) {\n                    tok->done = E_TOODEEP;\n                    tok->cur = tok->inp;\n                    return ERRORTOKEN;\n                }\n                if (altcol <= tok->altindstack[tok->indent]) {\n                    return indenterror(tok);\n                }\n                tok->pendin++;\n                tok->indstack[++tok->indent] = col;\n                tok->altindstack[tok->indent] = altcol;\n            }\n            else /* col < tok->indstack[tok->indent] */ {\n                /* Dedent -- any number, must be consistent */\n                while (tok->indent > 0 &&\n                    col < tok->indstack[tok->indent]) {\n                    tok->pendin--;\n                    tok->indent--;\n                }\n                if (col != tok->indstack[tok->indent]) {\n                    tok->done = E_DEDENT;\n                    tok->cur = tok->inp;\n                    return ERRORTOKEN;\n                }\n                if (altcol != tok->altindstack[tok->indent]) {\n                    return indenterror(tok);\n                }\n            }\n        }\n    }\n\n    tok->start = tok->cur;\n\n    /* Return pending indents/dedents */\n    if (tok->pendin != 0) {\n        if (tok->pendin < 0) {\n    }\n\n    /* Check for EOF and errors now */\n    if (c == EOF) {\n        return tok->done == E_EOF ? ENDMARKER : ERRORTOKEN;\n    }\n\n    /* Identifier (most frequent token!) */\n    nonascii = 0;\n    if (is_potential_identifier_start(c)) {\n        /* Process the various legal combinations of b\"\", r\"\", u\"\", and f\"\". */\n        int saw_b = 0, saw_r = 0, saw_u = 0, saw_f = 0;\n        while (1) {\n            if (!(saw_b || saw_u || saw_f) && (c == 'b' || c == 'B'))\n                saw_b = 1;\n            /* Since this is a backwards compatibility support literal we don't\n               want to support it in arbitrary order like byte literals. */\n            else if (!(saw_b || saw_u || saw_r || saw_f)\n                     && (c == 'u'|| c == 'U')) {\n                saw_u = 1;\n            }\n        tok_backup(tok, c);\n        if (nonascii && !verify_identifier(tok)) {\n            return ERRORTOKEN;\n        }\n        *p_start = tok->start;\n        *p_end = tok->cur;\n\n        /* async/await parsing block. */\n        if (tok->cur - tok->start == 5) {\n            /* Current token length is 5. */\n            if (tok->async_always || tok->async_def) {\n                /* We're inside an 'async def' function. */\n                if (memcmp(tok->start, \"async\", 5) == 0) {\n                    return ASYNC;\n                }\n                if (memcmp(tok->start, \"await\", 5) == 0) {\n                    return AWAIT;\n                }\n            }\n            else if (memcmp(tok->start, \"async\", 5) == 0) {\n                /* The current token is 'async'.",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  JsVar *parent = 0;\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    bool ok = false;\n    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      // if no parent, check in root?\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n\n      if (jsvHasChildren(parent)) {\n        // else remove properly.\n        if (jsvIsArray(parent)) {\n          // For arrays, we must make sure we don't change the length\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);\n        } else {\n          jsvRemoveChild(parent, a);\n        }\n        ok = true;\n      }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  JsVar *parent = 0;\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    bool ok = false;\n    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      // if no parent, check in root?\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n\n#ifdef DEBUG\n      if (jsvHasChildren(parent)) assert(jsvIsChild(parent, a));\n#endif\n      if (jsvHasChildren(parent) && jsvIsChild(parent, a)) {\n        // else remove properly.\n        /* we use jsvIsChild here just in case. delete probably isn't called\n        that often so it pays to be safe */\n        if (jsvIsArray(parent)) {\n          // For arrays, we must make sure we don't change the length\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);\n        } else {\n          jsvRemoveChild(parent, a);\n        }\n        ok = true;\n      }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tint r = EMULATION_OK;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\n\tinit_emulate_ctxt(vcpu);\n\n\t/*\n\t * We will reenter on the same instruction since we do not set\n\t * complete_userspace_io. This does not handle watchpoints yet,\n\t * those would be handled in the emulate_ops.\n\t */\n\tif (!(emulation_type & EMULTYPE_SKIP) &&\n\t    kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\treturn r;\n\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu->stat.insn_emulation;\n\n\treturn r;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint r;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu->stat.insn_emulation;\n\n\treturn r;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static_inline bool unsafe_yyjson_num_equals(void *lhs, void *rhs) {\n    yyjson_val_uni *luni = &((yyjson_val *)lhs)->uni;\n    yyjson_val_uni *runi = &((yyjson_val *)rhs)->uni;\n    yyjson_subtype lt = unsafe_yyjson_get_subtype(lhs);\n    yyjson_subtype rt = unsafe_yyjson_get_subtype(rhs);\n    if (lt == rt)\n        return luni->u64 == runi->u64;\n    if (lt == YYJSON_SUBTYPE_SINT && rt == YYJSON_SUBTYPE_UINT)\n        return luni->i64 >= 0 && luni->u64 == runi->u64;\n    if (lt == YYJSON_SUBTYPE_UINT && rt == YYJSON_SUBTYPE_SINT)\n        return runi->i64 >= 0 && luni->u64 == runi->u64;\n    return false;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static_inline bool unsafe_yyjson_num_equals(void *lhs, void *rhs) {\n    yyjson_val_uni *luni = &((yyjson_val *)lhs)->uni;\n    yyjson_val_uni *runi = &((yyjson_val *)rhs)->uni;\n    yyjson_subtype lt = unsafe_yyjson_get_subtype(lhs);\n    yyjson_subtype rt = unsafe_yyjson_get_subtype(rhs);\n    if (lt == rt) return luni->u64 == runi->u64;\n    if (lt == YYJSON_SUBTYPE_SINT && rt == YYJSON_SUBTYPE_UINT) {\n        return luni->i64 >= 0 && luni->u64 == runi->u64;\n    }\n    if (lt == YYJSON_SUBTYPE_UINT && rt == YYJSON_SUBTYPE_SINT) {\n        return runi->i64 >= 0 && luni->u64 == runi->u64;\n    }\n    return false;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "u32 cdk_pk_get_keyid(cdk_pubkey_t pk, u32 * keyid)\n{\n\tu32 lowbits = 0;\n\tbyte buf[24];\n\n\tif (pk && (!pk->keyid[0] || !pk->keyid[1])) {\n\t\tif (pk->version < 4 && is_RSA(pk->pubkey_algo)) {\n\t\t\tbyte p[MAX_MPI_BYTES];\n\t\t\tsize_t n;\n\n\t\t\tn = MAX_MPI_BYTES;\n\t\t\t_gnutls_mpi_print(pk->mpi[0], p, &n);\n\t\t\tpk->keyid[0] =\n\t\t\t    p[n - 8] << 24 | p[n - 7] << 16 | p[n -\n\t\t\t\t\t\t\t\t6] << 8 |\n\t\t\t    p[n - 5];\n\t\t\tpk->keyid[1] =\n\t\t\t    p[n - 4] << 24 | p[n - 3] << 16 | p[n -\n\t\t\t\t\t\t\t\t2] << 8 |\n\t\t\t    p[n - 1];\n\t\t} else if (pk->version == 4) {\n\t\t\tcdk_pk_get_fingerprint(pk, buf);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "u32 cdk_pk_get_keyid(cdk_pubkey_t pk, u32 * keyid)\n{\n\tu32 lowbits = 0;\n\tbyte buf[24];\n\tint rc;\n\n\tif (pk && (!pk->keyid[0] || !pk->keyid[1])) {\n\t\tif (pk->version < 4 && is_RSA(pk->pubkey_algo)) {\n\t\t\tbyte p[MAX_MPI_BYTES];\n\t\t\tsize_t n;\n\n\t\t\tn = MAX_MPI_BYTES;\n\t\t\trc = _gnutls_mpi_print(pk->mpi[0], p, &n);\n\t\t\tif (rc < 0 || n < 8) {\n\t\t\t\tkeyid[0] = keyid[1] = (u32)-1;\n\t\t\t\treturn (u32)-1;\n\t\t\t}\n\n\t\t\tpk->keyid[0] =\n\t\t\t    p[n - 8] << 24 | p[n - 7] << 16 | p[n -\n\t\t\t\t\t\t\t\t6] << 8 |\n\t\t\t    p[n - 5];\n\t\t\tpk->keyid[1] =\n\t\t\t    p[n - 4] << 24 | p[n - 3] << 16 | p[n -\n\t\t\t\t\t\t\t\t2] << 8 |\n\t\t\t    p[n - 1];\n\t\t} else if (pk->version == 4) {\n\t\t\tcdk_pk_get_fingerprint(pk, buf);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\t/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t */\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tstruct frag_hdr fhdr;\n\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\n\t\t/* reserve space for Hardware header */\n\t\tskb_reserve(skb, hh_len);\n\n\t\t/* create space for UDP/IP header */\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\n\t\t/* initialize network header pointer */\n\t\tskb_reset_network_header(skb);\n\n\t\t/* initialize protocol header pointer */\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\n\t\t/* Specify the length of each IPv6 datagram fragment.\n\t\t * It has to be a multiple of 8.\n\t\t */\n\t\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\tipv6_select_ident(&fhdr, rt);\n\t\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t}\n\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n\n{\n\tstruct sk_buff *skb;\n\tstruct frag_hdr fhdr;\n\tint err;\n\n\t/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t */\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\n\t\t/* reserve space for Hardware header */\n\t\tskb_reserve(skb, hh_len);\n\n\t\t/* create space for UDP/IP header */\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\n\t\t/* initialize network header pointer */\n\t\tskb_reset_network_header(skb);\n\n\t\t/* initialize protocol header pointer */\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->csum = 0;\n\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t} else if (skb_is_gso(skb)) {\n\t\tgoto append;\n\t}\n\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t/* Specify the length of each IPv6 datagram fragment.\n\t * It has to be a multiple of 8.\n\t */\n\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\tipv6_select_ident(&fhdr, rt);\n\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n\nappend:\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n  int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,\n  int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,\n  uint_fast32_t inmem)\n{\n\tjas_image_cmpt_t *cmpt;\n\tsize_t size;\n\n\tcmpt = 0;\n\tif (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {\n\t\tgoto error;\n\t}\n\tif (!jas_safe_intfast32_add(tlx, width, 0) ||\n\t  !jas_safe_intfast32_add(tly, height, 0)) {\n\t\tgoto error;\n\t}\n\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\tgoto error;\n\t}\n\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) / 8;\n\n\t// Compute the number of samples in the image component, while protecting\n\t// against overflow.\n\t// size = cmpt->width_ * cmpt->height_ * cmpt->cps_;\n\tif (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||\n\t  !jas_safe_size_mul(size, cmpt->cps_, &size)) {\n\t\tgoto error;\n\t}\n\tcmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :\n\t  jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tgoto error;\n\t}\n\n\t/* Zero the component data.  This isn't necessary, but it is\n\tconvenient for debugging purposes. */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n  int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,\n  int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,\n  uint_fast32_t inmem)\n{\n\tjas_image_cmpt_t *cmpt;\n\tsize_t size;\n\n\tJAS_DBGLOG(100, (\n\t  \"jas_image_cmpt_create(%ld, %ld, %ld, %ld, %ld, %ld, %d, %d, %d)\\n\",\n\t  JAS_CAST(long, tlx),\n\t  JAS_CAST(long, tly),\n\t  JAS_CAST(long, hstep),\n\t  JAS_CAST(long, vstep),\n\t  JAS_CAST(long, width),\n\t  JAS_CAST(long, height),\n\t  JAS_CAST(int, depth),\n\t  sgnd,\n\t  inmem\n\t  ));\n\n\tcmpt = 0;\n\tif (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {\n\t\tgoto error;\n\t}\n\tif (!jas_safe_intfast32_add(tlx, width, 0) ||\n\t  !jas_safe_intfast32_add(tly, height, 0)) {\n\t\tgoto error;\n\t}\n\tif (!jas_safe_intfast32_mul3(width, height, depth, 0)) {\n\t\tgoto error;\n\t}\n\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\tgoto error;\n\t}\n\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) / 8;\n\n\t// Compute the number of samples in the image component, while protecting\n\t// against overflow.\n\t// size = cmpt->width_ * cmpt->height_ * cmpt->cps_;\n\tif (!jas_safe_size_mul3(cmpt->width_, cmpt->height_, cmpt->cps_, &size)) {\n\t\tgoto error;\n\t}\n\tcmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :\n\t  jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tgoto error;\n\t}\n\n\t/* Zero the component data.  This isn't necessary, but it is\n\tconvenient for debugging purposes. */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int dccp_error(struct net *net, struct nf_conn *tmpl,\n\t\t      struct sk_buff *skb, unsigned int dataoff,\n\t\t      enum ip_conntrack_info *ctinfo,\n\t\t      u_int8_t pf, unsigned int hooknum)\n{\n\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb->len - dataoff;\n\tunsigned int cscov;\n\tconst char *msg;\n\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tif (dh == NULL) {\n\t\tmsg = \"nf_ct_dccp: short packet \";\n\t\tgoto out_invalid;\n\t}\n\n\tif (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||\n\t    dh->dccph_doff * 4 > dccp_len) {\n\t\tmsg = \"nf_ct_dccp: truncated/malformed packet \";\n\t\tgoto out_invalid;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int dccp_error(struct net *net, struct nf_conn *tmpl,\n\t\t      struct sk_buff *skb, unsigned int dataoff,\n\t\t      enum ip_conntrack_info *ctinfo,\n\t\t      u_int8_t pf, unsigned int hooknum)\n{\n\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb->len - dataoff;\n\tunsigned int cscov;\n\tconst char *msg;\n\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);\n\tif (dh == NULL) {\n\t\tmsg = \"nf_ct_dccp: short packet \";\n\t\tgoto out_invalid;\n\t}\n\n\tif (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||\n\t    dh->dccph_doff * 4 > dccp_len) {\n\t\tmsg = \"nf_ct_dccp: truncated/malformed packet \";\n\t\tgoto out_invalid;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\n\ttmsize_t wc = cc / bps;\n\ttmsize_t count = cc;\n\tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp = (uint8 *)_TIFFmalloc(cc);\n\n    if(cc%(bps*stride)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"fpAcc\",\n                     \"%s\", \"cc%(bps*stride))!=0\");\n        return 0;\n    }\n\n\tif (!tmp)\n\t\treturn 0;\n\n\twhile (count > stride) {\n\t\tREPEAT4(stride, cp[stride] =\n                        (unsigned char) ((cp[stride] + cp[0]) & 0xff); cp++)\n\t\tcount -= stride;\n\t}\n\n\t_TIFFmemcpy(tmp, cp0, cc);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\n\ttmsize_t wc = cc / bps;\n\ttmsize_t count = cc;\n\tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp;\n\n    if(cc%(bps*stride)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"fpAcc\",\n                     \"%s\", \"cc%(bps*stride))!=0\");\n        return 0;\n    }\n\n    tmp = (uint8 *)_TIFFmalloc(cc);\n\tif (!tmp)\n\t\treturn 0;\n\n\twhile (count > stride) {\n\t\tREPEAT4(stride, cp[stride] =\n                        (unsigned char) ((cp[stride] + cp[0]) & 0xff); cp++)\n\t\tcount -= stride;\n\t}\n\n\t_TIFFmemcpy(tmp, cp0, cc);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      info_dir_name = CPDB_BACKEND_INFO_DIR;\n    path = cpdbConcatPath(info_dir_name, backend_file_name);\n    \n    if ((file = fopen(path, \"r\")) == NULL)\n    {\n        logerror(\"Error creating backend %s : Couldn't open %s for reading\\n\",\n                    backend_name, path);\n        free(path);\n        return NULL;\n    }\n    if (fscanf(file, \"%s\", obj_path) == 0)\n    {\n        logerror(\"Error creating backend %s : Couldn't parse %s\\n\",\n                    backend_name, path);\n        free(path);\n        fclose(file);\n        return NULL;\n    }\n    free(path);\n    fclose(file);\n    ",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      info_dir_name = CPDB_BACKEND_INFO_DIR;\n    path = cpdbConcatPath(info_dir_name, backend_file_name);\n    \n    if ((file = fopen(path, \"r\")) == NULL)\n    {\n        logerror(\"Error creating backend %s : Couldn't open %s for reading\\n\",\n                    backend_name, path);\n        free(path);\n        return NULL;\n    }\n    if (fscanf(file, \"%1023s\", obj_path) == 0)\n    {\n        logerror(\"Error creating backend %s : Couldn't parse %s\\n\",\n                    backend_name, path);\n        free(path);\n        fclose(file);\n        return NULL;\n    }\n    free(path);\n    fclose(file);\n    ",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n{\n\tstruct sem_array *sma;\n\tstruct sem_undo_list *ulp;\n\tstruct sem_undo *un, *new;\n\tint nsems;\n\tint error;\n\n\terror = get_undo_list(&ulp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\trcu_read_lock();\n\tspin_lock(&ulp->lock);\n\tun = lookup_undo(ulp, semid);\n\tspin_unlock(&ulp->lock);\n\tif (likely(un!=NULL))\n\n\t/* no undo structure around - allocate one. */\n\t/* step 1: figure out the size of the semaphore array */\n\tsma = sem_obtain_object_check(ns, semid);\n\tif (IS_ERR(sma)) {\n\t\trcu_read_unlock();\n\t\treturn ERR_CAST(sma);\n\t}\n\n\tnsems = sma->sem_nsems;\n\tipc_rcu_getref(sma);\n\trcu_read_unlock();\n\n\t/* step 2: allocate new undo structure */\n\tnew = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);\n\tif (!new) {\n\t\tsem_putref(sma);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* step 3: Acquire the lock on semaphore array */\n\tsem_lock_and_putref(sma);\n\tif (sma->sem_perm.deleted) {\n\t\tsem_unlock(sma);\n\t\tkfree(new);\n\t\tun = ERR_PTR(-EIDRM);\n\t\tgoto out;\n\t}\n\tspin_lock(&ulp->lock);\n\n\t/*\n\t * step 4: check for races: did someone else allocate the undo struct?\n\t */\n\tun = lookup_undo(ulp, semid);\n\tnew->semid = semid;\n\tassert_spin_locked(&ulp->lock);\n\tlist_add_rcu(&new->list_proc, &ulp->list_proc);\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_add(&new->list_id, &sma->list_id);\n\tun = new;\n\nsuccess:\n\tspin_unlock(&ulp->lock);\n\trcu_read_lock();\n\tsem_unlock(sma);\nout:\n\treturn un;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n{\n\tstruct sem_array *sma;\n\tstruct sem_undo_list *ulp;\n\tstruct sem_undo *un, *new;\n\tint nsems, error;\n\n\terror = get_undo_list(&ulp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\trcu_read_lock();\n\tspin_lock(&ulp->lock);\n\tun = lookup_undo(ulp, semid);\n\tspin_unlock(&ulp->lock);\n\tif (likely(un!=NULL))\n\n\t/* no undo structure around - allocate one. */\n\t/* step 1: figure out the size of the semaphore array */\n\tsma = sem_obtain_object_check(ns, semid);\n\tif (IS_ERR(sma)) {\n\t\trcu_read_unlock();\n\t\treturn ERR_CAST(sma);\n\t}\n\n\tnsems = sma->sem_nsems;\n\tif (!ipc_rcu_getref(sma)) {\n\t\trcu_read_unlock();\n\t\tun = ERR_PTR(-EIDRM);\n\t\tgoto out;\n\t}\n\trcu_read_unlock();\n\n\t/* step 2: allocate new undo structure */\n\tnew = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);\n\tif (!new) {\n\t\tsem_putref(sma);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* step 3: Acquire the lock on semaphore array */\n\tsem_lock_and_putref(sma);\n\tif (sma->sem_perm.deleted) {\n\t\tsem_unlock(sma, -1);\n\t\tkfree(new);\n\t\tun = ERR_PTR(-EIDRM);\n\t\tgoto out;\n\t}\n\tspin_lock(&ulp->lock);\n\n\t/*\n\t * step 4: check for races: did someone else allocate the undo struct?\n\t */\n\tun = lookup_undo(ulp, semid);\n\tnew->semid = semid;\n\tassert_spin_locked(&ulp->lock);\n\tlist_add_rcu(&new->list_proc, &ulp->list_proc);\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_add(&new->list_id, &sma->list_id);\n\tun = new;\n\nsuccess:\n\tspin_unlock(&ulp->lock);\n\trcu_read_lock();\n\tsem_unlock(sma, -1);\nout:\n\treturn un;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t/* Fill in device structure with ethernet-generic values. */\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\trandom_ether_addr(dev->dev_addr);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\t/* Fill in device structure with ethernet-generic values. */\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n\trandom_ether_addr(dev->dev_addr);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    {\n      if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->refno != -1)\n      {\n        j++;\n        if (!ctx->quiet)\n          mutt_progress_update(&progress, j, -1);\n        snprintf(buf, sizeof(buf), \"DELE %d\\r\\n\", ctx->hdrs[i]->refno);\n        ret = pop_query(pop_data, buf, sizeof(buf));\n        if (ret == 0)\n        {\n          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);\n#ifdef USE_HCACHE\n          mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n#endif\n        }\n      }\n\n#ifdef USE_HCACHE\n      if (ctx->hdrs[i]->changed)\n      {\n        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    {\n      if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->refno != -1)\n      {\n        j++;\n        if (!ctx->quiet)\n          mutt_progress_update(&progress, j, -1);\n        snprintf(buf, sizeof(buf), \"DELE %d\\r\\n\", ctx->hdrs[i]->refno);\n        ret = pop_query(pop_data, buf, sizeof(buf));\n        if (ret == 0)\n        {\n          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));\n#ifdef USE_HCACHE\n          mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n#endif\n        }\n      }\n\n#ifdef USE_HCACHE\n      if (ctx->hdrs[i]->changed)\n      {\n        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static char *dex_resolve_library(const char *library) {\n\tif (!library || library[0] != 'L') {\n\t\treturn NULL;\n\t}\n\tchar *demangled = strdup(library + 1);\n\trz_str_replace_ch(demangled, '/', '.', 1);\n\tdemangled[strlen(demangled) - 1] = 0;\n\treturn demangled;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static char *dex_resolve_library(const char *library) {\n\tif (!library || library[0] != 'L') {\n\t\treturn NULL;\n\t}\n\tchar *demangled = strdup(library + 1);\n\trz_str_replace_ch(demangled, '/', '.', 1);\n\tif (RZ_STR_ISNOTEMPTY(demangled)) {\n\t\tdemangled[strlen(demangled) - 1] = 0;\n\t}\n\treturn demangled;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    }\n  }\n\n  int original_rank = dense_shape_.size();\n  int block_dim = 0;\n\n  blocked_shape_.resize(original_rank);\n  block_size_.resize(block_map_.size());\n  for (int i = 0; i < original_rank; i++) {\n    if (block_dim < block_map_.size() && block_map_[block_dim] == i) {\n      int orig_dim = traversal_order_[original_rank + block_dim];\n      block_size_[block_dim] = dense_size[orig_dim];\n      blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];\n      block_dim++;\n    } else {\n      blocked_shape_[i] = dense_shape_[i];\n    }\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    }\n  }\n\n  int original_rank = dense_shape_.size();\n  int block_dim = 0;\n\n  blocked_shape_.resize(original_rank);\n  block_size_.resize(block_map_.size());\n  for (int i = 0; i < original_rank; i++) {\n    if (block_dim < block_map_.size() && block_map_[block_dim] == i) {\n      if (original_rank + block_dim < traversal_order_.size()) {\n        int orig_dim = traversal_order_[original_rank + block_dim];\n        block_size_[block_dim] = dense_size[orig_dim];\n        blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];\n        block_dim++;\n      }\n    } else {\n      blocked_shape_[i] = dense_shape_[i];\n    }\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void set_task_blockstep(struct task_struct *task, bool on)\n{\n\tunsigned long debugctl;\n\n\t/*\n\t * Ensure irq/preemption can't change debugctl in between.\n\t * Note also that both TIF_BLOCKSTEP and debugctl should\n\t * be changed atomically wrt preemption.\n\t * FIXME: this means that set/clear TIF_BLOCKSTEP is simply\n\t * wrong if task != current, SIGKILL can wakeup the stopped\n\t * tracee and set/clear can play with the running task, this\n\t * can confuse the next __switch_to_xtra().\n\t */\n\tlocal_irq_disable();\n\tdebugctl = get_debugctlmsr();\n\tif (on) {\n\t\tdebugctl |= DEBUGCTLMSR_BTF;\n\t\tset_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t} else {\n\t\tdebugctl &= ~DEBUGCTLMSR_BTF;\n\t\tclear_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void set_task_blockstep(struct task_struct *task, bool on)\n{\n\tunsigned long debugctl;\n\n\t/*\n\t * Ensure irq/preemption can't change debugctl in between.\n\t * Note also that both TIF_BLOCKSTEP and debugctl should\n\t * be changed atomically wrt preemption.\n\t *\n\t * NOTE: this means that set/clear TIF_BLOCKSTEP is only safe if\n\t * task is current or it can't be running, otherwise we can race\n\t * with __switch_to_xtra(). We rely on ptrace_freeze_traced() but\n\t * PTRACE_KILL is not safe.\n\t */\n\tlocal_irq_disable();\n\tdebugctl = get_debugctlmsr();\n\tif (on) {\n\t\tdebugctl |= DEBUGCTLMSR_BTF;\n\t\tset_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t} else {\n\t\tdebugctl &= ~DEBUGCTLMSR_BTF;\n\t\tclear_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int WriteRiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)\n{\n    int do_rf64 = 0, write_junk = 1;\n    ChunkHeader ds64hdr, datahdr, fmthdr;\n    RiffChunkHeader riffhdr;\n    DS64Chunk ds64_chunk;\n    JunkChunk junkchunk;\n    WaveHeader wavhdr;\n    uint32_t bcount;\n\n    int64_t total_data_bytes, total_riff_bytes;\n    int num_channels = WavpackGetNumChannels (wpc);\n    int32_t channel_mask = WavpackGetChannelMask (wpc);\n    int32_t sample_rate = WavpackGetSampleRate (wpc);\n    int bytes_per_sample = WavpackGetBytesPerSample (wpc);\n    int bits_per_sample = WavpackGetBitsPerSample (wpc);\n        wavhdr.GUID [6] = 0x80;\n        wavhdr.GUID [9] = 0xaa;\n        wavhdr.GUID [11] = 0x38;\n        wavhdr.GUID [12] = 0x9b;\n        wavhdr.GUID [13] = 0x71;\n    }\n\n    strncpy (riffhdr.ckID, do_rf64 ? \"RF64\" : \"RIFF\", sizeof (riffhdr.ckID));\n    strncpy (riffhdr.formType, \"WAVE\", sizeof (riffhdr.formType));\n    total_riff_bytes = sizeof (riffhdr) + wavhdrsize + sizeof (datahdr) + ((total_data_bytes + 1) & ~(int64_t)1);\n    if (do_rf64) total_riff_bytes += sizeof (ds64hdr) + sizeof (ds64_chunk);\n    if (write_junk) total_riff_bytes += sizeof (junkchunk);\n    strncpy (fmthdr.ckID, \"fmt \", sizeof (fmthdr.ckID));\n    strncpy (datahdr.ckID, \"data\", sizeof (datahdr.ckID));\n    fmthdr.ckSize = wavhdrsize;\n\n    if (write_junk) {\n        CLEAR (junkchunk);\n        strncpy (junkchunk.ckID, \"junk\", sizeof (junkchunk.ckID));\n        junkchunk.ckSize = sizeof (junkchunk) - 8;\n        WavpackNativeToLittleEndian (&junkchunk, ChunkHeaderFormat);\n    }\n\n    if (do_rf64) {\n        strncpy (ds64hdr.ckID, \"ds64\", sizeof (ds64hdr.ckID));\n        ds64hdr.ckSize = sizeof (ds64_chunk);\n        CLEAR (ds64_chunk);\n        ds64_chunk.riffSize64 = total_riff_bytes;\n        ds64_chunk.dataSize64 = total_data_bytes;\n        ds64_chunk.sampleCount64 = total_samples;\n        riffhdr.ckSize = (uint32_t) -1;\n        datahdr.ckSize = (uint32_t) -1;\n        WavpackNativeToLittleEndian (&ds64hdr, ChunkHeaderFormat);\n        WavpackNativeToLittleEndian (&ds64_chunk, DS64ChunkFormat);\n    }\n    else {\n        riffhdr.ckSize = (uint32_t) total_riff_bytes;\n        datahdr.ckSize = (uint32_t) total_data_bytes;\n    }\n\n    // write the RIFF chunks up to just before the data starts\n\n    WavpackNativeToLittleEndian (&riffhdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&fmthdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&wavhdr, WaveHeaderFormat);\n    WavpackNativeToLittleEndian (&datahdr, ChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &riffhdr, sizeof (riffhdr), &bcount) || bcount != sizeof (riffhdr) ||\n        (do_rf64 && (!DoWriteFile (outfile, &ds64hdr, sizeof (ds64hdr), &bcount) || bcount != sizeof (ds64hdr))) ||\n        (do_rf64 && (!DoWriteFile (outfile, &ds64_chunk, sizeof (ds64_chunk), &bcount) || bcount != sizeof (ds64_chunk))) ||\n        (write_junk && (!DoWriteFile (outfile, &junkchunk, sizeof (junkchunk), &bcount) || bcount != sizeof (junkchunk))) ||\n        !DoWriteFile (outfile, &fmthdr, sizeof (fmthdr), &bcount) || bcount != sizeof (fmthdr) ||\n        !DoWriteFile (outfile, &wavhdr, wavhdrsize, &bcount) || bcount != wavhdrsize ||\n        !DoWriteFile (outfile, &datahdr, sizeof (datahdr), &bcount) || bcount != sizeof (datahdr)) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n    }\n\n    return TRUE;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int WriteRiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)\n{\n    int do_rf64 = 0, write_junk = 1, table_length = 0;\n    ChunkHeader ds64hdr, datahdr, fmthdr;\n    RiffChunkHeader riffhdr;\n    DS64Chunk ds64_chunk;\n    CS64Chunk cs64_chunk;\n    JunkChunk junkchunk;\n    WaveHeader wavhdr;\n    uint32_t bcount;\n\n    int64_t total_data_bytes, total_riff_bytes;\n    int num_channels = WavpackGetNumChannels (wpc);\n    int32_t channel_mask = WavpackGetChannelMask (wpc);\n    int32_t sample_rate = WavpackGetSampleRate (wpc);\n    int bytes_per_sample = WavpackGetBytesPerSample (wpc);\n    int bits_per_sample = WavpackGetBitsPerSample (wpc);\n        wavhdr.GUID [9] = 0xaa;\n        wavhdr.GUID [11] = 0x38;\n        wavhdr.GUID [12] = 0x9b;\n        wavhdr.GUID [13] = 0x71;\n    }\n\n    strncpy (riffhdr.ckID, do_rf64 ? \"RF64\" : \"RIFF\", sizeof (riffhdr.ckID));\n    strncpy (riffhdr.formType, \"WAVE\", sizeof (riffhdr.formType));\n    total_riff_bytes = sizeof (riffhdr) + wavhdrsize + sizeof (datahdr) + ((total_data_bytes + 1) & ~(int64_t)1);\n    if (do_rf64) total_riff_bytes += sizeof (ds64hdr) + sizeof (ds64_chunk);\n    total_riff_bytes += table_length * sizeof (CS64Chunk);\n    if (write_junk) total_riff_bytes += sizeof (junkchunk);\n    strncpy (fmthdr.ckID, \"fmt \", sizeof (fmthdr.ckID));\n    strncpy (datahdr.ckID, \"data\", sizeof (datahdr.ckID));\n    fmthdr.ckSize = wavhdrsize;\n\n    if (write_junk) {\n        CLEAR (junkchunk);\n        strncpy (junkchunk.ckID, \"junk\", sizeof (junkchunk.ckID));\n        junkchunk.ckSize = sizeof (junkchunk) - 8;\n        WavpackNativeToLittleEndian (&junkchunk, ChunkHeaderFormat);\n    }\n\n    if (do_rf64) {\n        strncpy (ds64hdr.ckID, \"ds64\", sizeof (ds64hdr.ckID));\n        ds64hdr.ckSize = sizeof (ds64_chunk) + (table_length * sizeof (CS64Chunk));\n        CLEAR (ds64_chunk);\n        ds64_chunk.riffSize64 = total_riff_bytes;\n        ds64_chunk.dataSize64 = total_data_bytes;\n        ds64_chunk.sampleCount64 = total_samples;\n        ds64_chunk.tableLength = table_length;\n        riffhdr.ckSize = (uint32_t) -1;\n        datahdr.ckSize = (uint32_t) -1;\n        WavpackNativeToLittleEndian (&ds64hdr, ChunkHeaderFormat);\n        WavpackNativeToLittleEndian (&ds64_chunk, DS64ChunkFormat);\n    }\n    else {\n        riffhdr.ckSize = (uint32_t) total_riff_bytes;\n        datahdr.ckSize = (uint32_t) total_data_bytes;\n    }\n\n    // this \"table\" is just a dummy placeholder for testing (normally not written)\n\n    if (table_length) {\n        strncpy (cs64_chunk.ckID, \"dmmy\", sizeof (cs64_chunk.ckID));\n        cs64_chunk.chunkSize64 = 12345678;\n        WavpackNativeToLittleEndian (&cs64_chunk, CS64ChunkFormat);\n    }\n\n    // write the RIFF chunks up to just before the data starts\n\n    WavpackNativeToLittleEndian (&riffhdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&fmthdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&wavhdr, WaveHeaderFormat);\n    WavpackNativeToLittleEndian (&datahdr, ChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &riffhdr, sizeof (riffhdr), &bcount) || bcount != sizeof (riffhdr) ||\n        (do_rf64 && (!DoWriteFile (outfile, &ds64hdr, sizeof (ds64hdr), &bcount) || bcount != sizeof (ds64hdr))) ||\n        (do_rf64 && (!DoWriteFile (outfile, &ds64_chunk, sizeof (ds64_chunk), &bcount) || bcount != sizeof (ds64_chunk)))) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n    }\n\n    // again, this is normally not written except for testing\n\n    while (table_length--)\n        if (!DoWriteFile (outfile, &cs64_chunk, sizeof (cs64_chunk), &bcount) || bcount != sizeof (cs64_chunk)) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n        }\n\n\n    if ((write_junk && (!DoWriteFile (outfile, &junkchunk, sizeof (junkchunk), &bcount) || bcount != sizeof (junkchunk))) ||\n        !DoWriteFile (outfile, &fmthdr, sizeof (fmthdr), &bcount) || bcount != sizeof (fmthdr) ||\n        !DoWriteFile (outfile, &wavhdr, wavhdrsize, &bcount) || bcount != wavhdrsize ||\n        !DoWriteFile (outfile, &datahdr, sizeof (datahdr), &bcount) || bcount != sizeof (datahdr)) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n    }\n\n    return TRUE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t    else if (attr->name == attMAPIPROPS) \n\t    { \n\t\tMAPI_Attr **mapi_attrs \n\t\t    = mapi_attr_read (attr->len, attr->buf); \n\t\tif (mapi_attrs)\n\t\t{ \n\t\t    int i;\n\t\t    for (i = 0; mapi_attrs[i]; i++)\n\t\t    {\n\t\t\tMAPI_Attr *a = mapi_attrs[i];\n\t\t\t    \n\t\t\tif (a->name == MAPI_BODY_HTML)\n\t\t\t{\n\t\t\t    body.html_bodies = get_html_data (a);\n                                html_size = a->num_values;\n\t\t\t}\n\t\t\telse if (a->name == MAPI_RTF_COMPRESSED)\n\t\t\t{\n\t\t\t    body.rtf_bodies = get_rtf_data (a);\n                                rtf_size = a->num_values;\n\t\t\t}\n\t\t    }\n\t\t    /* cannot save attributes to file, since they\n\t\t     * are not attachment attributes */ \n\t\t    /* file_add_mapi_attrs (file, mapi_attrs); */\n\t\t    mapi_attr_free_list (mapi_attrs); \n\t\t    XFREE (mapi_attrs); ",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t    else if (attr->name == attMAPIPROPS) \n\t    { \n\t\tMAPI_Attr **mapi_attrs \n\t\t    = mapi_attr_read (attr->len, attr->buf); \n\t\tif (mapi_attrs)\n\t\t{ \n\t\t    int i;\n\t\t    for (i = 0; mapi_attrs[i]; i++)\n\t\t    {\n\t\t\tMAPI_Attr *a = mapi_attrs[i];\n\t\t\n\t\t\tif (a->type == szMAPI_BINARY && a->name == MAPI_BODY_HTML)\n\t\t\t{\n\t\t\t    body.html_bodies = get_html_data (a);\n                                html_size = a->num_values;\n\t\t\t}\n\t\t\telse if (a->type == szMAPI_BINARY && a->name == MAPI_RTF_COMPRESSED)\n\t\t\t{\n\t\t\t    body.rtf_bodies = get_rtf_data (a);\n                                rtf_size = a->num_values;\n\t\t\t}\n\t\t    }\n\t\t    /* cannot save attributes to file, since they\n\t\t     * are not attachment attributes */ \n\t\t    /* file_add_mapi_attrs (file, mapi_attrs); */\n\t\t    mapi_attr_free_list (mapi_attrs); \n\t\t    XFREE (mapi_attrs); ",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    usize alc_max; /* maximum value count for allocator */\n    usize ctn_len; /* the number of elements in current container */\n    yyjson_val *val_hdr; /* the head of allocated values */\n    yyjson_val *val_end; /* the end of allocated values */\n    yyjson_val *val_tmp; /* temporary pointer for realloc */\n    yyjson_val *val; /* current JSON value */\n    yyjson_val *ctn; /* current container */\n    yyjson_val *ctn_parent; /* parent of current container */\n    yyjson_doc *doc; /* the JSON document, equals to val_hdr */\n    const char *msg; /* error message */\n    \n    bool raw; /* read number as raw */\n    bool inv; /* allow invalid unicode */\n    u8 *raw_end; /* raw end for null-terminator */\n    u8 **pre; /* previous raw end pointer */\n    \n    dat_len = has_read_flag(STOP_WHEN_DONE) ? 256 : (usize)(end - cur);\n    hdr_len = sizeof(yyjson_doc) / sizeof(yyjson_val);\n    hdr_len += (sizeof(yyjson_doc) % sizeof(yyjson_val)) > 0;\n    alc_max = USIZE_MAX / sizeof(yyjson_val);\n    alc_len = hdr_len + (dat_len / YYJSON_READER_ESTIMATED_MINIFY_RATIO) + 4;\n    if (*cur++ == '{') {\n        ctn->tag = YYJSON_TYPE_OBJ;\n        ctn->uni.ofs = 0;\n        goto obj_key_begin;\n    } else {\n        ctn->tag = YYJSON_TYPE_ARR;\n        ctn->uni.ofs = 0;\n        goto arr_val_begin;\n    }\n    \narr_begin:\n    /* save current container */\n    ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n               (ctn->tag & YYJSON_TAG_MASK);\n    \n    /* create a new array value, save parent container offset */\n    val_incr();\n    val->tag = YYJSON_TYPE_ARR;\n    val->uni.ofs = (usize)((u8 *)val - (u8 *)ctn);\n    \n    /* push the new array value as current container */\n    if (char_is_space(*cur)) {\n        while (char_is_space(*++cur));\n        goto arr_val_end;\n    }\n    if (has_read_flag(ALLOW_COMMENTS)) {\n        if (skip_spaces_and_comments(&cur)) goto arr_val_end;\n        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \narr_end:\n    /* get parent container */\n    ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n    \n    /* save the next sibling value offset */\n    ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n    ctn->tag = ((ctn_len) << YYJSON_TAG_BIT) | YYJSON_TYPE_ARR;\n    if (unlikely(ctn == ctn_parent)) goto doc_end;\n    \n    /* pop parent as current container */\n    ctn = ctn_parent;\n    ctn_len = (usize)(ctn->tag >> YYJSON_TAG_BIT);\n    if ((ctn->tag & YYJSON_TYPE_MASK) == YYJSON_TYPE_OBJ) {\n        goto obj_val_end;\n    } else {\n        goto arr_val_end;\n    }\n    \nobj_begin:\n    /* push container */\n    ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n               (ctn->tag & YYJSON_TAG_MASK);\n    val_incr();\n    val->tag = YYJSON_TYPE_OBJ;\n    /* offset to the parent */\n    val->uni.ofs = (usize)((u8 *)val - (u8 *)ctn);\n    ctn = val;\n    ctn_len = 0;\n    \n    if (char_is_space(*cur)) {\n        while (char_is_space(*++cur));\n        goto obj_val_end;\n    }\n    if (has_read_flag(ALLOW_COMMENTS)) {\n        if (skip_spaces_and_comments(&cur)) goto obj_val_end;\n        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \nobj_end:\n    /* pop container */\n    ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n    /* point to the next value */\n    ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n    ctn->tag = (ctn_len << (YYJSON_TAG_BIT - 1)) | YYJSON_TYPE_OBJ;\n    if (unlikely(ctn == ctn_parent)) goto doc_end;\n    ctn = ctn_parent;\n    ctn_len = (usize)(ctn->tag >> YYJSON_TAG_BIT);\n    if ((ctn->tag & YYJSON_TYPE_MASK) == YYJSON_TYPE_OBJ) {\n        goto obj_val_end;\n    return_err(cur, MEMORY_ALLOCATION, \"memory allocation failed\");\nfail_trailing_comma:\n    return_err(cur, JSON_STRUCTURE, \"trailing comma is not allowed\");\nfail_literal:\n    return_err(cur, LITERAL, \"invalid literal\");\nfail_comment:\n    return_err(cur, INVALID_COMMENT, \"unclosed multiline comment\");\nfail_character:\n    return_err(cur, UNEXPECTED_CHARACTER, \"unexpected character\");\nfail_garbage:\n    return_err(cur, UNEXPECTED_CONTENT, \"unexpected content after document\");\n    \n#undef val_incr\n#undef return_err\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    usize alc_max; /* maximum value count for allocator */\n    usize ctn_len; /* the number of elements in current container */\n    yyjson_val *val_hdr; /* the head of allocated values */\n    yyjson_val *val_end; /* the end of allocated values */\n    yyjson_val *val_tmp; /* temporary pointer for realloc */\n    yyjson_val *val; /* current JSON value */\n    yyjson_val *ctn; /* current container */\n    yyjson_val *ctn_parent; /* parent of current container */\n    yyjson_doc *doc; /* the JSON document, equals to val_hdr */\n    const char *msg; /* error message */\n\n    u32 container_depth = 0; /* limit on number of open array and map */\n    bool raw; /* read number as raw */\n    bool inv; /* allow invalid unicode */\n    u8 *raw_end; /* raw end for null-terminator */\n    u8 **pre; /* previous raw end pointer */\n    \n    dat_len = has_read_flag(STOP_WHEN_DONE) ? 256 : (usize)(end - cur);\n    hdr_len = sizeof(yyjson_doc) / sizeof(yyjson_val);\n    hdr_len += (sizeof(yyjson_doc) % sizeof(yyjson_val)) > 0;\n    alc_max = USIZE_MAX / sizeof(yyjson_val);\n    alc_len = hdr_len + (dat_len / YYJSON_READER_ESTIMATED_MINIFY_RATIO) + 4;\n        ctn->tag = YYJSON_TYPE_OBJ;\n        ctn->uni.ofs = 0;\n        goto obj_key_begin;\n    } else {\n        ctn->tag = YYJSON_TYPE_ARR;\n        ctn->uni.ofs = 0;\n        goto arr_val_begin;\n    }\n    \narr_begin:\n    container_depth++;\n    if (unlikely(container_depth >= YYJSON_READER_CONTAINER_RECURSION_LIMIT)) {\n        goto fail_recursion;\n    }\n\n    /* save current container */\n    ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n               (ctn->tag & YYJSON_TAG_MASK);\n    \n    /* create a new array value, save parent container offset */\n    val_incr();\n    val->tag = YYJSON_TYPE_ARR;\n    val->uni.ofs = (usize)((u8 *)val - (u8 *)ctn);\n    \n    /* push the new array value as current container */\n        while (char_is_space(*++cur));\n        goto arr_val_end;\n    }\n    if (has_read_flag(ALLOW_COMMENTS)) {\n        if (skip_spaces_and_comments(&cur)) goto arr_val_end;\n        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \narr_end:\n    container_depth--;\n\n    /* get parent container */\n    ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n    \n    /* save the next sibling value offset */\n    ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n    ctn->tag = ((ctn_len) << YYJSON_TAG_BIT) | YYJSON_TYPE_ARR;\n    if (unlikely(ctn == ctn_parent)) goto doc_end;\n    \n    /* pop parent as current container */\n    ctn = ctn_parent;\n    ctn_len = (usize)(ctn->tag >> YYJSON_TAG_BIT);\n    if ((ctn->tag & YYJSON_TYPE_MASK) == YYJSON_TYPE_OBJ) {\n        goto obj_val_end;\n    } else {\n        goto arr_val_end;\n    }\n    \nobj_begin:\n    container_depth++;\n    if (unlikely(container_depth >= YYJSON_READER_CONTAINER_RECURSION_LIMIT)) {\n        goto fail_recursion;\n    }\n\n    /* push container */\n    ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n               (ctn->tag & YYJSON_TAG_MASK);\n    val_incr();\n    val->tag = YYJSON_TYPE_OBJ;\n    /* offset to the parent */\n    val->uni.ofs = (usize)((u8 *)val - (u8 *)ctn);\n    ctn = val;\n    ctn_len = 0;\n    \n        while (char_is_space(*++cur));\n        goto obj_val_end;\n    }\n    if (has_read_flag(ALLOW_COMMENTS)) {\n        if (skip_spaces_and_comments(&cur)) goto obj_val_end;\n        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \nobj_end:\n    container_depth--;\n\n    /* pop container */\n    ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n    /* point to the next value */\n    ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n    ctn->tag = (ctn_len << (YYJSON_TAG_BIT - 1)) | YYJSON_TYPE_OBJ;\n    if (unlikely(ctn == ctn_parent)) goto doc_end;\n    ctn = ctn_parent;\n    ctn_len = (usize)(ctn->tag >> YYJSON_TAG_BIT);\n    if ((ctn->tag & YYJSON_TYPE_MASK) == YYJSON_TYPE_OBJ) {\n        goto obj_val_end;\nfail_trailing_comma:\n    return_err(cur, JSON_STRUCTURE, \"trailing comma is not allowed\");\nfail_literal:\n    return_err(cur, LITERAL, \"invalid literal\");\nfail_comment:\n    return_err(cur, INVALID_COMMENT, \"unclosed multiline comment\");\nfail_character:\n    return_err(cur, UNEXPECTED_CHARACTER, \"unexpected character\");\nfail_garbage:\n    return_err(cur, UNEXPECTED_CONTENT, \"unexpected content after document\");\nfail_recursion:\n    return_err(cur, RECURSION_DEPTH, \"array and object recursion depth exceeded\");\n    \n#undef val_incr\n#undef return_err\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void rand_gen(uint8_t *out, int out_len) {\n\tint m = RLC_CEIL(out_len, RLC_MD_LEN);\n\tuint8_t hash[RLC_MD_LEN], data[(RLC_RAND_SIZE - 1)/2];\n\tctx_t *ctx = core_get();\n\n\t/* data = V */\n\tmemcpy(data, ctx->rand + 1, (RLC_RAND_SIZE - 1)/2);\n\tfor (int i = 0; i < m; i++) {\n\t\t/* w_i = Hash(data) */\n\t\tmd_map(hash, data, sizeof(data));\n\t\t/* W = W || w_i */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void rand_gen(uint8_t *out, size_t out_len) {\n\tint m = RLC_CEIL(out_len, RLC_MD_LEN);\n\tuint8_t hash[RLC_MD_LEN], data[(RLC_RAND_SIZE - 1)/2];\n\tctx_t *ctx = core_get();\n\n\t/* data = V */\n\tmemcpy(data, ctx->rand + 1, (RLC_RAND_SIZE - 1)/2);\n\tfor (int i = 0; i < m; i++) {\n\t\t/* w_i = Hash(data) */\n\t\tmd_map(hash, data, sizeof(data));\n\t\t/* W = W || w_i */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int cg_mkdir(const char *path, mode_t mode)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *path1, *cgdir = NULL, *controller;\n\tconst char *cgroup;\n\tint ret;\n\n\tif (!fc)\n\t\treturn -EIO;\n\n\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath)\n\t\tpath1 = \"/\";\n\telse\n\t\tpath1 = cgdir;\n\n\tif (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\n\tret = cgfs_create(controller, cgroup, fc->uid, fc->gid);\n\tprintf(\"cgfs_create returned %d for %s %s\\n\", ret, controller, cgroup);\n\nout:\n\tfree(cgdir);\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int cg_mkdir(const char *path, mode_t mode)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *path1, *cgdir = NULL, *controller, *next = NULL;\n\tconst char *cgroup;\n\tint ret;\n\n\tif (!fc)\n\t\treturn -EIO;\n\n\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath)\n\t\tpath1 = \"/\";\n\telse\n\t\tpath1 = cgdir;\n\n\tif (!caller_is_in_ancestor(fc->pid, controller, path1, &next)) {\n\t\tif (fpath && strcmp(next, fpath) == 0)\n\t\t\tret = -EEXIST;\n\t\telse\n\t\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\n\tret = cgfs_create(controller, cgroup, fc->uid, fc->gid);\n\tprintf(\"cgfs_create returned %d for %s %s\\n\", ret, controller, cgroup);\n\nout:\n\tfree(cgdir);\n\tfree(next);\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static bool init_ehdr(ELFOBJ *bin) {\n\tut8 e_ident[EI_NIDENT];\n\tut8 ehdr[sizeof (Elf_(Ehdr))] = {0};\n\tint i, len;\n\tif (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) == -1) {\n\t\tR_LOG_ERROR (\"read (magic)\");\n\t\treturn false;\n\t}\n\tsdb_set (bin->kv, \"elf_type.cparse\", \"enum elf_type { ET_NONE=0, ET_REL=1,\"\n\t\t\t\" ET_EXEC=2, ET_DYN=3, ET_CORE=4, ET_LOOS=0xfe00, ET_HIOS=0xfeff,\"\n\t\t\t\" ET_LOPROC=0xff00, ET_HIPROC=0xffff };\", 0);\n\tsdb_set (bin->kv, \"elf_machine.cparse\", \"enum elf_machine {EM_NONE=0, EM_M32=1,\"\n\t\t\t\" EM_SPARC=2, EM_386=3, EM_68K=4, EM_88K=5, EM_IAMCU=6, EM_860=7, EM_MIPS=8,\"\n\t\t\t\" EM_S370=9, EM_MIPS_RS3_LE=10, EM_RS6000=11, EM_PARISC=15, EM_nCUBE=16,\"\n\t\t\t\" EM_VPP500=17, EM_SPARC32PLUS=18, EM_960=19, EM_PPC=20, EM_PPC64=21, EM_S390=22,\"\n\t\t\t\" EM_SPU=23, EM_V800=36, EM_FR20=37, EM_RH32=38, EM_RCE=39, EM_ARM=40,\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_header.format\", \"?[2]E[2]E[4]ExxxxN2N2N2N2N2N2\"\n\t\t\t\" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#endif\n\tbin->endian = (e_ident[EI_DATA] == ELFDATA2MSB)? 1: 0;\n\tmemset (&bin->ehdr, 0, sizeof (Elf_(Ehdr)));\n\tlen = r_buf_read_at (bin->b, 0, ehdr, sizeof (ehdr));\n\tif (len < 32) { // tinyelf != sizeof (Elf_(Ehdr))) {\n\t\tR_LOG_ERROR (\"read (ehdr)\");\n\t\treturn false;\n\t}\n\t// XXX no need to check twice\n\tmemcpy (&bin->ehdr.e_ident, ehdr, 16);\n\tif (!__is_valid_ident (bin)) {\n\t\treturn false;\n\t}\n\ti = 16;\n\t// TODO: use r_read or r_buf_read_ apis instead\n\tbin->ehdr.e_type = READ16 (ehdr, i);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static bool init_ehdr(ELFOBJ *bin) {\n\tut8 e_ident[EI_NIDENT];\n\tut8 ehdr[sizeof (Elf_(Ehdr))] = {0};\n\tint i, len;\n\tif (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) == -1) {\n\t\tR_LOG_DEBUG (\"read (magic)\");\n\t\treturn false;\n\t}\n\tsdb_set (bin->kv, \"elf_type.cparse\", \"enum elf_type { ET_NONE=0, ET_REL=1,\"\n\t\t\t\" ET_EXEC=2, ET_DYN=3, ET_CORE=4, ET_LOOS=0xfe00, ET_HIOS=0xfeff,\"\n\t\t\t\" ET_LOPROC=0xff00, ET_HIPROC=0xffff };\", 0);\n\tsdb_set (bin->kv, \"elf_machine.cparse\", \"enum elf_machine {EM_NONE=0, EM_M32=1,\"\n\t\t\t\" EM_SPARC=2, EM_386=3, EM_68K=4, EM_88K=5, EM_IAMCU=6, EM_860=7, EM_MIPS=8,\"\n\t\t\t\" EM_S370=9, EM_MIPS_RS3_LE=10, EM_RS6000=11, EM_PARISC=15, EM_nCUBE=16,\"\n\t\t\t\" EM_VPP500=17, EM_SPARC32PLUS=18, EM_960=19, EM_PPC=20, EM_PPC64=21, EM_S390=22,\"\n\t\t\t\" EM_SPU=23, EM_V800=36, EM_FR20=37, EM_RH32=38, EM_RCE=39, EM_ARM=40,\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_header.format\", \"?[2]E[2]E[4]ExxxxN2N2N2N2N2N2\"\n\t\t\t\" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#endif\n\tbin->endian = (e_ident[EI_DATA] == ELFDATA2MSB)? 1: 0;\n\tmemset (&bin->ehdr, 0, sizeof (Elf_(Ehdr)));\n\tlen = r_buf_read_at (bin->b, 0, ehdr, sizeof (ehdr));\n\tif (len < 32) { // tinyelf != sizeof (Elf_(Ehdr))) {\n\t\tR_LOG_DEBUG (\"read (ehdr)\");\n\t\treturn false;\n\t}\n\t// XXX no need to check twice\n\tmemcpy (&bin->ehdr.e_ident, ehdr, 16);\n\tif (!__is_valid_ident (bin)) {\n\t\treturn false;\n\t}\n\ti = 16;\n\t// TODO: use r_read or r_buf_read_ apis instead\n\tbin->ehdr.e_type = READ16 (ehdr, i);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\nnext_tag:\n\tif (unlikely(datalen - dp < 2)) {\n\t\tif (datalen == dp)\n\t\t\tgoto missing_eoc;\n\t\tgoto data_overrun_error;\n\t}\n\n\t/* Extract a tag from the data */\n\ttag = data[dp++];\n\tif (tag == 0) {\n\t\t/* It appears to be an EOC. */\n\t\tif (data[dp++] != 0)\n\t\t\tgoto invalid_eoc;\n\t\tif (--indef_level <= 0) {\n\t\t\t*_len = dp - *_dp;\n\t\t\t*_dp = dp;\n\t\t\treturn 0;\n\t\t}\n\t\tgoto next_tag;\n\t}\n\tif (unlikely((tag & 0x1f) == ASN1_LONG_TAG)) {\n\t\tdo {\n\t\t\tif (unlikely(datalen - dp < 2))\n\t\t\t\tgoto data_overrun_error;\n\t\t\ttmp = data[dp++];\n\t\t} while (tmp & 0x80);\n\t}\n\n\t/* Extract the length */\n\tlen = data[dp++];\n\tif (len <= 0x7f) {\n\t\tdp += len;\n\t\tgoto next_tag;\n\t}\n\n\tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\t/* Indefinite length */\n\t\tif (unlikely((tag & ASN1_CONS_BIT) == ASN1_PRIM << 5))\n\t\t\tgoto indefinite_len_primitive;\n\t\tindef_level++;\n\t\tgoto next_tag;\n\t}\n\n\tn = len - 0x80;\n\tif (unlikely(n > sizeof(size_t) - 1))\n\t\tgoto length_too_long;\n\tif (unlikely(n > datalen - dp))\n\t\tgoto data_overrun_error;\n\tfor (len = 0; n > 0; n--) {\n\t\tlen <<= 8;\n\t\tlen |= data[dp++];\n\t}\n\tdp += len;\n\tgoto next_tag;\n\nlength_too_long:\n\t*_errmsg = \"Unsupported length\";\n\tgoto error;\nindefinite_len_primitive:\n\t*_errmsg = \"Indefinite len primitive not permitted\";\n\tgoto error;\ninvalid_eoc:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\nnext_tag:\n\tif (unlikely(datalen - dp < 2)) {\n\t\tif (datalen == dp)\n\t\t\tgoto missing_eoc;\n\t\tgoto data_overrun_error;\n\t}\n\n\t/* Extract a tag from the data */\n\ttag = data[dp++];\n\tif (tag == ASN1_EOC) {\n\t\t/* It appears to be an EOC. */\n\t\tif (data[dp++] != 0)\n\t\t\tgoto invalid_eoc;\n\t\tif (--indef_level <= 0) {\n\t\t\t*_len = dp - *_dp;\n\t\t\t*_dp = dp;\n\t\t\treturn 0;\n\t\t}\n\t\tgoto next_tag;\n\t}\n\tif (unlikely((tag & 0x1f) == ASN1_LONG_TAG)) {\n\t\tdo {\n\t\t\tif (unlikely(datalen - dp < 2))\n\t\t\t\tgoto data_overrun_error;\n\t\t\ttmp = data[dp++];\n\t\t} while (tmp & 0x80);\n\t}\n\n\t/* Extract the length */\n\tlen = data[dp++];\n\tif (len <= 0x7f)\n\t\tgoto check_length;\n\n\tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\t/* Indefinite length */\n\t\tif (unlikely((tag & ASN1_CONS_BIT) == ASN1_PRIM << 5))\n\t\t\tgoto indefinite_len_primitive;\n\t\tindef_level++;\n\t\tgoto next_tag;\n\t}\n\n\tn = len - 0x80;\n\tif (unlikely(n > sizeof(len) - 1))\n\t\tgoto length_too_long;\n\tif (unlikely(n > datalen - dp))\n\t\tgoto data_overrun_error;\n\tlen = 0;\n\tfor (; n > 0; n--) {\n\t\tlen <<= 8;\n\t\tlen |= data[dp++];\n\t}\ncheck_length:\n\tif (len > datalen - dp)\n\t\tgoto data_overrun_error;\n\tdp += len;\n\tgoto next_tag;\n\nlength_too_long:\n\t*_errmsg = \"Unsupported length\";\n\tgoto error;\nindefinite_len_primitive:\n\t*_errmsg = \"Indefinite len primitive not permitted\";\n\tgoto error;\ninvalid_eoc:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void fp12_exp_dig(fp12_t c, const fp12_t a, dig_t b) {\n\tbn_t _b;\n\tfp12_t t, v;\n\tint8_t u, naf[RLC_DIG + 1];\n\tint l;\n\n\tif (b == 0) {\n\t\tfp12_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(_b);\n\tfp12_null(t);\n\tfp12_null(v);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void fp12_exp_dig(fp12_t c, const fp12_t a, dig_t b) {\n\tbn_t _b;\n\tfp12_t t, v;\n\tint8_t u, naf[RLC_DIG + 1];\n\tsize_t l;\n\n\tif (b == 0) {\n\t\tfp12_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(_b);\n\tfp12_null(t);\n\tfp12_null(v);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t        ip_print(ndo, p, length);\n\t\tbreak;\n\n\tcase NLPID_IP6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\n\tcase NLPID_CLNP:\n\tcase NLPID_ESIS:\n\tcase NLPID_ISIS:\n\t\tisoclns_print(ndo, p - 1, length + 1, ndo->ndo_snapend - p + 1); /* OSI printers need the NLPID field */\n\t\tbreak;\n\n\tcase NLPID_SNAP:\n\t\tif (snap_print(ndo, p, length, ndo->ndo_snapend - p, NULL, NULL, 0) == 0) {\n\t\t\t/* ether_type not known, print raw packet */\n                        if (!ndo->ndo_eflag)\n                            fr_hdr_print(ndo, length + hdr_len, hdr_len,\n                                         dlci, flags, nlpid);\n\t\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\t\tND_DEFAULTPRINT(p - hdr_len, length + hdr_len);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t        ip_print(ndo, p, length);\n\t\tbreak;\n\n\tcase NLPID_IP6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\n\tcase NLPID_CLNP:\n\tcase NLPID_ESIS:\n\tcase NLPID_ISIS:\n\t\tisoclns_print(ndo, p - 1, length + 1); /* OSI printers need the NLPID field */\n\t\tbreak;\n\n\tcase NLPID_SNAP:\n\t\tif (snap_print(ndo, p, length, ndo->ndo_snapend - p, NULL, NULL, 0) == 0) {\n\t\t\t/* ether_type not known, print raw packet */\n                        if (!ndo->ndo_eflag)\n                            fr_hdr_print(ndo, length + hdr_len, hdr_len,\n                                         dlci, flags, nlpid);\n\t\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\t\tND_DEFAULTPRINT(p - hdr_len, length + hdr_len);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "context_parse_args (FlatpakContext *context,\n                    ...)\n{\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GOptionContext) oc = NULL;\n  g_autoptr(GOptionGroup) group = NULL;\n  g_autoptr(GPtrArray) args = g_ptr_array_new_with_free_func (g_free);\n  g_auto(GStrv) argv = NULL;\n  const char *arg;\n  va_list ap;\n\n  g_ptr_array_add (args, g_strdup (\"argv[0]\"));\n\n  va_start (ap, context);\n\n  while ((arg = va_arg (ap, const char *)) != NULL)\n    g_ptr_array_add (args, g_strdup (arg));\n\n  va_end (ap);\n\n  g_ptr_array_add (args, NULL);\n  argv = (GStrv) g_ptr_array_free (g_steal_pointer (&args), FALSE);\n\n  oc = g_option_context_new (\"\");\n  group = flatpak_context_get_options (context);\n  g_option_context_add_group (oc, group);\n  g_option_context_parse_strv (oc, &argv, &local_error);\n  g_assert_no_error (local_error);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "context_parse_args (FlatpakContext *context,\n                    GError        **error,\n                    ...)\n{\n  g_autoptr(GOptionContext) oc = NULL;\n  g_autoptr(GOptionGroup) group = NULL;\n  g_autoptr(GPtrArray) args = g_ptr_array_new_with_free_func (g_free);\n  g_auto(GStrv) argv = NULL;\n  const char *arg;\n  va_list ap;\n\n  g_ptr_array_add (args, g_strdup (\"argv[0]\"));\n\n  va_start (ap, error);\n\n  while ((arg = va_arg (ap, const char *)) != NULL)\n    g_ptr_array_add (args, g_strdup (arg));\n\n  va_end (ap);\n\n  g_ptr_array_add (args, NULL);\n  argv = (GStrv) g_ptr_array_free (g_steal_pointer (&args), FALSE);\n\n  oc = g_option_context_new (\"\");\n  group = flatpak_context_get_options (context);\n  g_option_context_add_group (oc, group);\n  g_option_context_parse_strv (oc, &argv, error);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  if (! pool->blocks) {\n    if (! poolGrow(pool))\n      return XML_ERROR_NO_MEMORY;\n  }\n\n  for (;;) {\n    const char *next\n        = entityTextPtr; /* XmlEntityValueTok doesn't always set the last arg */\n    int tok = XmlEntityValueTok(enc, entityTextPtr, entityTextEnd, &next);\n\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, entityTextPtr, next, __LINE__,\n                                  account)) {\n      accountingOnAbort(parser);\n      result = XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      goto endEntityValue;\n    }\n#endif\n\n    switch (tok) {\n    case XML_TOK_PARAM_ENTITY_REF:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  if (! pool->blocks) {\n    if (! poolGrow(pool))\n      return XML_ERROR_NO_MEMORY;\n  }\n\n  for (;;) {\n    const char *next\n        = entityTextPtr; /* XmlEntityValueTok doesn't always set the last arg */\n    int tok = XmlEntityValueTok(enc, entityTextPtr, entityTextEnd, &next);\n\n#if defined(XML_DTD) || XML_GE == 1\n    if (! accountingDiffTolerated(parser, tok, entityTextPtr, next, __LINE__,\n                                  account)) {\n      accountingOnAbort(parser);\n      result = XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      goto endEntityValue;\n    }\n#endif\n\n    switch (tok) {\n    case XML_TOK_PARAM_ENTITY_REF:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tworking_segment_size = working_descriptor->packet_size;\n\n\t\t\t} else {\n\t\t\t\t// We don't know what this packet is, so we'll let the parser continue\n\t\t\t\t// just so that we can dequeue it in one shot\n\t\t\t\tworking_segment_size = packet_size + PACKET_SIZE_TYPE_SIZE;\n\n\t\t\t\tif (working_segment_size > CRSF_MAX_PACKET_LEN) {\n\t\t\t\t\tparser_statistics->invalid_unknown_packet_sizes++;\n\t\t\t\t\tparser_state = PARSER_STATE_HEADER;\n\t\t\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparser_state = PARSER_STATE_PAYLOAD;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tworking_segment_size = working_descriptor->packet_size;\n\n\t\t\t} else {\n\t\t\t\t// We don't know what this packet is, so we'll let the parser continue\n\t\t\t\t// just so that we can dequeue it in one shot\n\t\t\t\tworking_segment_size = packet_size - PACKET_SIZE_TYPE_SIZE;\n\n\t\t\t\tif (working_index + working_segment_size + CRC_SIZE > CRSF_MAX_PACKET_LEN) {\n\t\t\t\t\tparser_statistics->invalid_unknown_packet_sizes++;\n\t\t\t\t\tparser_state = PARSER_STATE_HEADER;\n\t\t\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparser_state = PARSER_STATE_PAYLOAD;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t/*\n\t * Size? If bigger than 4 bytes, the actual data is not\n\t * in the entry but somewhere else (offset).\n\t */\n\tif (s > 4)\n\t\tdoff = exif_get_long (d + offset + 8, data->priv->order);\n\telse\n\t\tdoff = offset + 8;\n\n\t/* Sanity checks */\n\tif ((doff + s < doff) || (doff + s < s) || (doff + s > size)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag data past end of buffer (%u > %u)\", doff+s, size);\t\n\t\treturn 0;\n\t}\n\n\tentry->data = exif_data_alloc (data, s);\n\tif (entry->data) {\n\t\tentry->size = s;\n\t\tmemcpy (entry->data, d + doff, s);\n\t} else {\n\t\tEXIF_LOG_NO_MEMORY(data->priv->log, \"ExifData\", s);\n\t\treturn 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t/*\n\t * Size? If bigger than 4 bytes, the actual data is not\n\t * in the entry but somewhere else (offset).\n\t */\n\tif (s > 4)\n\t\tdoff = exif_get_long (d + offset + 8, data->priv->order);\n\telse\n\t\tdoff = offset + 8;\n\n\t/* Sanity checks */\n\tif (doff >= size) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag starts past end of buffer (%u > %u)\", doff, size);\n\t\treturn 0;\n\t}\n\n\tif (s > size - doff) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag data goes past end of buffer (%u > %u)\", doff+s, size);\n\t\treturn 0;\n\t}\n\n\tentry->data = exif_data_alloc (data, s);\n\tif (entry->data) {\n\t\tentry->size = s;\n\t\tmemcpy (entry->data, d + doff, s);\n\t} else {\n\t\tEXIF_LOG_NO_MEMORY(data->priv->log, \"ExifData\", s);\n\t\treturn 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tstruct common_audit_data sa;\n\tstruct apparmor_audit_data aad = {0,};\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\t/* args points to a PAGE_SIZE buffer, AppArmor requires that\n\t * the buffer must be null terminated or have size <= PAGE_SIZE -1\n\t * so that AppArmor can null terminate them\n\t */\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\n\t/* task can only write its own attributes */\n\tif (current != task)\n\t\treturn -EACCES;\n\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t} else\n\t\t\tgoto fail;\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\tif (strcmp(command, \"exec\") == 0)\n\t\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\telse\n\t\t\tgoto fail;\n\t} else\n\t\t/* only support the \"current\" and \"exec\" process attributes */\n\t\treturn -EINVAL;\n\n\tif (!error)\n\t\terror = size;\n\treturn error;\n\nfail:\n\tsa.type = LSM_AUDIT_DATA_NONE;\n\tsa.aad = &aad;\n\taad.profile = aa_current_profile();\n\taad.op = OP_SETPROCATTR;\n\taad.info = name;\n\taad.error = -EINVAL;\n\taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n\treturn -EINVAL;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tstruct common_audit_data sa;\n\tstruct apparmor_audit_data aad = {0,};\n\tchar *command, *largs = NULL, *args = value;\n\tsize_t arg_size;\n\tint error;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\t/* task can only write its own attributes */\n\tif (current != task)\n\t\treturn -EACCES;\n\n\t/* AppArmor requires that the buffer must be null terminated atm */\n\tif (args[size - 1] != '\\0') {\n\t\t/* null terminate */\n\t\tlargs = args = kmalloc(size + 1, GFP_KERNEL);\n\t\tif (!args)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(args, value, size);\n\t\targs[size] = '\\0';\n\t}\n\n\terror = -EINVAL;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\tgoto out;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\tgoto out;\n\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t} else\n\t\t\tgoto fail;\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\tif (strcmp(command, \"exec\") == 0)\n\t\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\telse\n\t\t\tgoto fail;\n\t} else\n\t\t/* only support the \"current\" and \"exec\" process attributes */\n\t\tgoto fail;\n\n\tif (!error)\n\t\terror = size;\nout:\n\tkfree(largs);\n\treturn error;\n\nfail:\n\tsa.type = LSM_AUDIT_DATA_NONE;\n\tsa.aad = &aad;\n\taad.profile = aa_current_profile();\n\taad.op = OP_SETPROCATTR;\n\taad.info = name;\n\taad.error = error = -EINVAL;\n\taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n\tgoto out;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tu32 j, type, nb_items, first=GF_TRUE;\n\t\tbin128 uuid;\n\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\tnb_items = gf_isom_get_user_data_count(file, track_number, type, uuid);\n\t\tfprintf(stderr, \"%s (%d) \", gf_4cc_to_str(type), nb_items);\n\t\tfor (j=0; j<nb_items; j++) {\n\t\t\tu8 *udta=NULL;\n\t\t\tu32 udta_size;\n\t\t\tgf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);\n\t\t\tif (!udta) continue;\n\t\t\tif (gf_utf8_is_legal(udta, udta_size)) {\n\t\t\t\tif (first) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tfirst = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\t%s\\n\", (char *) udta);\n\t\t\t}\n\t\t\tgf_free(udta);\n\t\t}\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tu32 j, type, nb_items, first=GF_TRUE;\n\t\tbin128 uuid;\n\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\tnb_items = gf_isom_get_user_data_count(file, track_number, type, uuid);\n\t\tfprintf(stderr, \"%s (%d) \", gf_4cc_to_str(type), nb_items);\n\t\tfor (j=0; j<nb_items; j++) {\n\t\t\tu8 *udta=NULL;\n\t\t\tu32 udta_size;\n\t\t\tgf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);\n\t\t\tif (!udta) continue;\n\t\t\tif (udta_size && gf_utf8_is_legal(udta, udta_size)) {\n\t\t\t\tu32 idx;\n\t\t\t\tif (first) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tfirst = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\t\");\n\t\t\t\tfor (idx=0; idx<udta_size; idx++) {\n\t\t\t\t\tif (!udta[idx]) break;\n\t\t\t\t\tfprintf(stderr, \"%c\", udta[idx]);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tgf_free(udta);\n\t\t}\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    int\t\tsave_msg_scroll = msg_scroll;\n    int\t\tsave_State = State;\t// remember State when called\n    int\t\tsome_key_typed = FALSE;\t// one of the keys was typed\n    // mouse drag and release events are ignored, unless they are\n    // preceded with a mouse down event\n    int\t\tignore_drag_release = TRUE;\n#ifdef FEAT_EVAL\n    int\t\tbreak_ctrl_c = FALSE;\n#endif\n    expand_T\txpc;\n    long\t*b_im_ptr = NULL;\n    cmdline_info_T save_ccline;\n    int\t\tdid_save_ccline = FALSE;\n    int\t\tcmdline_type;\n    int\t\twild_type;\n\n    // one recursion level deeper\n    ++depth;\n\n    if (ccline.cmdbuff != NULL)\n    {\n    msg_scroll = FALSE;\n\n    State = MODE_CMDLINE;\n\n    if (firstc == '/' || firstc == '?' || firstc == '@')\n    {\n\t// Use \":lmap\" mappings for search pattern and input().\n\tif (curbuf->b_p_imsearch == B_IMODE_USE_INSERT)\n\t    b_im_ptr = &curbuf->b_p_iminsert;\n\telse\n\t    b_im_ptr = &curbuf->b_p_imsearch;\n\tif (*b_im_ptr == B_IMODE_LMAP)\n\t    State |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(*b_im_ptr == B_IMODE_IM);\n#endif\n    }\n#ifdef HAVE_INPUT_METHOD\n    else if (p_imcmdline)\n\tim_set_active(TRUE);\n#endif\n\n\tcase K_INS:\n\tcase K_KINS:\n\t\tccline.overstrike = !ccline.overstrike;\n#ifdef CURSOR_SHAPE\n\t\tui_cursor_shape();\t// may show different cursor shape\n#endif\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_HAT:\n\t\tcmdline_toggle_langmap(b_im_ptr);\n\t\tgoto cmdline_not_changed;\n\n//\tcase '@':   only in very old vi\n\tcase Ctrl_U:\n\t\t// delete all characters left of the cursor\n\t\tj = ccline.cmdpos;\n\t\tccline.cmdlen -= j;\n\t\ti = ccline.cmdpos = 0;\n\t\twhile (i < ccline.cmdlen)\n\t\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINELEAVE);\n\n    State = save_State;\n\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n#ifdef HAVE_INPUT_METHOD\n    if (b_im_ptr != NULL && *b_im_ptr != B_IMODE_LMAP)\n\tim_save_status(b_im_ptr);\n    im_set_active(FALSE);\n#endif\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    sb_text_end_cmdline();\n\ntheend:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    int\t\tsave_State = State;\t// remember State when called\n    int\t\tsome_key_typed = FALSE;\t// one of the keys was typed\n    // mouse drag and release events are ignored, unless they are\n    // preceded with a mouse down event\n    int\t\tignore_drag_release = TRUE;\n#ifdef FEAT_EVAL\n    int\t\tbreak_ctrl_c = FALSE;\n#endif\n    expand_T\txpc;\n    long\t*b_im_ptr = NULL;\n    buf_T\t*b_im_ptr_buf = NULL;\t// buffer where b_im_ptr is valid\n    cmdline_info_T save_ccline;\n    int\t\tdid_save_ccline = FALSE;\n    int\t\tcmdline_type;\n    int\t\twild_type;\n\n    // one recursion level deeper\n    ++depth;\n\n    if (ccline.cmdbuff != NULL)\n    {\n\n    State = MODE_CMDLINE;\n\n    if (firstc == '/' || firstc == '?' || firstc == '@')\n    {\n\t// Use \":lmap\" mappings for search pattern and input().\n\tif (curbuf->b_p_imsearch == B_IMODE_USE_INSERT)\n\t    b_im_ptr = &curbuf->b_p_iminsert;\n\telse\n\t    b_im_ptr = &curbuf->b_p_imsearch;\n\tb_im_ptr_buf = curbuf;\n\tif (*b_im_ptr == B_IMODE_LMAP)\n\t    State |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(*b_im_ptr == B_IMODE_IM);\n#endif\n    }\n#ifdef HAVE_INPUT_METHOD\n    else if (p_imcmdline)\n\tim_set_active(TRUE);\n#endif\n\n\tcase K_INS:\n\tcase K_KINS:\n\t\tccline.overstrike = !ccline.overstrike;\n#ifdef CURSOR_SHAPE\n\t\tui_cursor_shape();\t// may show different cursor shape\n#endif\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_HAT:\n\t\tcmdline_toggle_langmap(\n\t\t\t\t    buf_valid(b_im_ptr_buf) ? b_im_ptr : NULL);\n\t\tgoto cmdline_not_changed;\n\n//\tcase '@':   only in very old vi\n\tcase Ctrl_U:\n\t\t// delete all characters left of the cursor\n\t\tj = ccline.cmdpos;\n\t\tccline.cmdlen -= j;\n\t\ti = ccline.cmdpos = 0;\n\t\twhile (i < ccline.cmdlen)\n\t\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINELEAVE);\n\n    State = save_State;\n\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n#ifdef HAVE_INPUT_METHOD\n    if (b_im_ptr != NULL && buf_valid(b_im_ptr_buf)\n\t\t\t\t\t\t  && *b_im_ptr != B_IMODE_LMAP)\n\tim_save_status(b_im_ptr);\n    im_set_active(FALSE);\n#endif\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    sb_text_end_cmdline();\n\ntheend:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ecma_op_internal_buffer_append (ecma_collection_t *container_p, /**< internal container pointer */\n                                ecma_value_t key_arg, /**< key argument */\n                                ecma_value_t value_arg, /**< value argument */\n                                lit_magic_string_id_t lit_id) /**< class id */\n{\n  JERRY_ASSERT (container_p != NULL);\n\n  ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (value_arg));\n  }\n\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);\n} /* ecma_op_internal_buffer_append */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ecma_op_internal_buffer_append (ecma_collection_t *container_p, /**< internal container pointer */\n                                ecma_value_t key_arg, /**< key argument */\n                                ecma_value_t value_arg, /**< value argument */\n                                lit_magic_string_id_t lit_id) /**< class id */\n{\n  JERRY_ASSERT (container_p != NULL);\n\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_value_t values[] = { ecma_copy_value_if_not_object (key_arg), ecma_copy_value_if_not_object (value_arg) };\n    ecma_collection_append (container_p, values, 2);\n  }\n  else\n  {\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n  }\n\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);\n} /* ecma_op_internal_buffer_append */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t++p;\n\n\tif (*p!='m') {\n\t\tif (*p!='a' && *p!='O' && *p!='C' && *p!='r') {\n\t\t\tgoto outexcept;\n\t\t}\n\t\tintern->ar_flags &= ~SPL_ARRAY_CLONE_MASK;\n\t\tintern->ar_flags |= flags & SPL_ARRAY_CLONE_MASK;\n\t\tzval_ptr_dtor(&intern->array);\n\t\tALLOC_INIT_ZVAL(intern->array);\n\t\tif (!php_var_unserialize(&intern->array, &p, s + buf_len, &var_hash TSRMLS_CC)) {\n\t\t\tgoto outexcept;\n\t\t}\n\t\tvar_push_dtor(&var_hash, &intern->array);\n\t}\n\tif (*p != ';') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\t/* members */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t++p;\n\n\tif (*p!='m') {\n\t\tif (*p!='a' && *p!='O' && *p!='C' && *p!='r') {\n\t\t\tgoto outexcept;\n\t\t}\n\t\tintern->ar_flags &= ~SPL_ARRAY_CLONE_MASK;\n\t\tintern->ar_flags |= flags & SPL_ARRAY_CLONE_MASK;\n\t\tzval_ptr_dtor(&intern->array);\n\t\tALLOC_INIT_ZVAL(intern->array);\n\t\tif (!php_var_unserialize(&intern->array, &p, s + buf_len, &var_hash TSRMLS_CC)\n\t\t\t\t|| (Z_TYPE_P(intern->array) != IS_ARRAY && Z_TYPE_P(intern->array) != IS_OBJECT)) {\n\t\t\tzval_ptr_dtor(&intern->array);\n\t\t\tgoto outexcept;\n\t\t}\n\t\tvar_push_dtor(&var_hash, &intern->array);\n\t}\n\tif (*p != ';') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\t/* members */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    const int image_height = grads_image.dimension(1);\n    const int image_width = grads_image.dimension(2);\n\n    const int num_boxes = grads.dimension(0);\n    const int crop_height = grads.dimension(1);\n    const int crop_width = grads.dimension(2);\n    const int depth = grads.dimension(3);\n\n    grads_image.setZero();\n\n    auto CropAndResizeBackImgPerBox = [&](int start_box, int limit_box) {\n      for (int b = start_box; b < limit_box; ++b) {\n        const float y1 = boxes(b, 0);\n        const float x1 = boxes(b, 1);\n        const float y2 = boxes(b, 2);\n        const float x2 = boxes(b, 3);\n\n        const int32 b_in = box_index(b);\n        if (!FastBoundsCheck(b_in, batch_size)) {\n          continue;\n        }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    const int image_height = grads_image.dimension(1);\n    const int image_width = grads_image.dimension(2);\n\n    const int num_boxes = grads.dimension(0);\n    const int crop_height = grads.dimension(1);\n    const int crop_width = grads.dimension(2);\n    const int depth = grads.dimension(3);\n\n    grads_image.setZero();\n\n    auto CropAndResizeBackImgPerBox = [&](int64 start_box, int64 limit_box) {\n      for (int b = start_box; b < limit_box; ++b) {\n        const float y1 = boxes(b, 0);\n        const float x1 = boxes(b, 1);\n        const float y2 = boxes(b, 2);\n        const float x2 = boxes(b, 3);\n\n        const int32 b_in = box_index(b);\n        if (!FastBoundsCheck(b_in, batch_size)) {\n          continue;\n        }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos);\n\t}\n\n\t/*HEVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);\n\n\t/*VVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n\t\n\t/*AV1*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n\n\t/*VPx*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);\n\n\t/*JP2H*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos);\n\n\t/*DolbyVision*/",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos);\n\t}\n\n\t/*HEVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);\n\n\t/*VVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n\n\t/*AV1*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n\n\t/*VPx*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);\n\n\t/*JP2H*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos);\n\n\t/*DolbyVision*/",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int nfc_data_exchange(struct nfc_dev *dev, u32 target_idx, struct sk_buff *skb,\n\t\t      data_exchange_cb_t cb, void *cb_context)\n{\n\tint rc;\n\n\tpr_debug(\"dev_name=%s target_idx=%u skb->len=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, skb->len);\n\n\tdevice_lock(&dev->dev);\n\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\tif (dev->rf_mode == NFC_RF_INITIATOR && dev->active_target != NULL) {\n\t\tif (dev->active_target->idx != target_idx) {\n\t\t\trc = -EADDRNOTAVAIL;\n\t\t\tkfree_skb(skb);\n\t\t\tgoto error;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int nfc_data_exchange(struct nfc_dev *dev, u32 target_idx, struct sk_buff *skb,\n\t\t      data_exchange_cb_t cb, void *cb_context)\n{\n\tint rc;\n\n\tpr_debug(\"dev_name=%s target_idx=%u skb->len=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, skb->len);\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->shutting_down) {\n\t\trc = -ENODEV;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\tif (dev->rf_mode == NFC_RF_INITIATOR && dev->active_target != NULL) {\n\t\tif (dev->active_target->idx != target_idx) {\n\t\t\trc = -EADDRNOTAVAIL;\n\t\t\tkfree_skb(skb);\n\t\t\tgoto error;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "rad_get_vendor_attr(u_int32_t *vendor, const void **data, size_t *len)\n{\n\tstruct vendor_attribute *attr;\n\n\tattr = (struct vendor_attribute *)*data;\n\t*vendor = ntohl(attr->vendor_value);\n\t*data = attr->attrib_data;\n\t*len = attr->attrib_len - 2;\n\n\treturn (attr->attrib_type);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "rad_get_vendor_attr(u_int32_t *vendor, unsigned char *type, const void **data, size_t *len, const void *raw, size_t raw_len)\n{\n\tstruct vendor_attribute *attr;\n\n\tif (raw_len < sizeof(struct vendor_attribute)) {\n\t\treturn -1;\n\t}\n\n\tattr = (struct vendor_attribute *) raw;\n\t*vendor = ntohl(attr->vendor_value);\n\t*type = attr->attrib_type;\n\t*data = attr->attrib_data;\n\t*len = attr->attrib_len - 2;\n\n\tif ((attr->attrib_len + 4) > raw_len) {\n\t\treturn -1;\n\t}\n\n\treturn (attr->attrib_type);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tfilter_dbg(port->driver_bound, data, \"<- i8042 (interrupt, %d, %d%s%s)\\n\",\n\t\t   port_no, irq,\n\t\t   dfl & SERIO_PARITY ? \", bad parity\" : \"\",\n\t\t   dfl & SERIO_TIMEOUT ? \", timeout\" : \"\");\n\n\tfiltered = i8042_filter(data, str, serio);\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\tif (likely(port->exists && !filtered))\n\t\tserio_interrupt(serio, data, dfl);\n\n out:\n\treturn IRQ_RETVAL(ret);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tfilter_dbg(port->driver_bound, data, \"<- i8042 (interrupt, %d, %d%s%s)\\n\",\n\t\t   port_no, irq,\n\t\t   dfl & SERIO_PARITY ? \", bad parity\" : \"\",\n\t\t   dfl & SERIO_TIMEOUT ? \", timeout\" : \"\");\n\n\tfiltered = i8042_filter(data, str, serio);\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\tif (likely(serio && !filtered))\n\t\tserio_interrupt(serio, data, dfl);\n\n out:\n\treturn IRQ_RETVAL(ret);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t}\n\n\t/*\n\t * We have to traverse the policy forwards, not in reverse,\n\t * to support the \"pwcheck == all\" case.\n\t */\n\tTAILQ_FOREACH(us, &nss->parse_tree->userspecs, entries) {\n\t    int user_match = userlist_matches(nss->parse_tree, ctx->user.pw,\n\t\t&us->users);\n\t    if (user_match != ALLOW) {\n\t\tif (callback != NULL && user_match != UNSPEC) {\n\t\t    callback(nss->parse_tree, us, user_match, NULL, UNSPEC,\n\t\t\tNULL, UNSPEC, UNSPEC, UNSPEC, cb_data);\n\t\t}\n\t\tcontinue;\n\t    }\n\t    TAILQ_FOREACH(priv, &us->privileges, entries) {\n\t\tint priv_nopass = UNSPEC;\n\t\tint host_match = hostlist_matches(nss->parse_tree, ctx->user.pw,\n\t\t    &priv->hostlist);\n\t\tif (host_match != ALLOW) {\n\t\t\t\t    cs->cmnd, cs->runchroot, NULL);\n\t\t\t    }\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if (callback != NULL) {\n\t\t\tcallback(nss->parse_tree, us, user_match, priv,\n\t\t\t    host_match, cs, date_match, runas_match,\n\t\t\t    cmnd_match, cb_data);\n\t\t    }\n\t\t    if (cmnd_match != UNSPEC) {\n\t\t\t/*\n\t\t\t * We take the last match but must process\n\t\t\t * the entire policy for pwcheck == all.\n\t\t\t */\n\t\t\tmatch = cmnd_match;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (!sudo_nss_can_continue(nss, match))",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t}\n\n\t/*\n\t * We have to traverse the policy forwards, not in reverse,\n\t * to support the \"pwcheck == all\" case.\n\t */\n\tTAILQ_FOREACH(us, &nss->parse_tree->userspecs, entries) {\n\t    int user_match = userlist_matches(nss->parse_tree, ctx->user.pw,\n\t\t&us->users);\n\t    if (user_match != ALLOW) {\n\t\tif (callback != NULL && user_match == DENY) {\n\t\t    callback(nss->parse_tree, us, user_match, NULL, UNSPEC,\n\t\t\tNULL, UNSPEC, UNSPEC, UNSPEC, cb_data);\n\t\t}\n\t\tcontinue;\n\t    }\n\t    TAILQ_FOREACH(priv, &us->privileges, entries) {\n\t\tint priv_nopass = UNSPEC;\n\t\tint host_match = hostlist_matches(nss->parse_tree, ctx->user.pw,\n\t\t    &priv->hostlist);\n\t\tif (host_match != ALLOW) {\n\t\t\t\t    cs->cmnd, cs->runchroot, NULL);\n\t\t\t    }\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if (callback != NULL) {\n\t\t\tcallback(nss->parse_tree, us, user_match, priv,\n\t\t\t    host_match, cs, date_match, runas_match,\n\t\t\t    cmnd_match, cb_data);\n\t\t    }\n\t\t    if (SPECIFIED(cmnd_match)) {\n\t\t\t/*\n\t\t\t * We take the last match but must process\n\t\t\t * the entire policy for pwcheck == all.\n\t\t\t */\n\t\t\tmatch = cmnd_match;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (!sudo_nss_can_continue(nss, match))",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,\n\t\t\t      indx, data, size, 100);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size,\n\t\t\t const void *data)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(data, size, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,\n\t\t\t      indx, buf, size, 100);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\tkfree(buf);\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "Http::FilterMetadataStatus Context::onResponseMetadata() {\n  if (!wasm_->onResponseMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onResponseMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; // This is currently the only return code.\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "Http::FilterMetadataStatus Context::onResponseMetadata() {\n  if (!in_vm_context_created_ || !wasm_->onResponseMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onResponseMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; // This is currently the only return code.\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteStatus LeakyReluEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  const auto* params =\n      reinterpret_cast<TfLiteLeakyReluParams*>(node->builtin_data);\n  const LeakyReluOpData* data =\n      reinterpret_cast<LeakyReluOpData*>(node->user_data);\n\n  LeakyReluParams op_params;\n  switch (input->type) {\n    case kTfLiteFloat32: {\n      op_params.alpha = params->alpha;\n      optimized_ops::LeakyRelu(",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteStatus LeakyReluEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const auto* params =\n      reinterpret_cast<TfLiteLeakyReluParams*>(node->builtin_data);\n  const LeakyReluOpData* data =\n      reinterpret_cast<LeakyReluOpData*>(node->user_data);\n\n  LeakyReluParams op_params;\n  switch (input->type) {\n    case kTfLiteFloat32: {\n      op_params.alpha = params->alpha;\n      optimized_ops::LeakyRelu(",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tif (!parse_thread (bin, &lc, off, is_first_thread)) {\n\t\t\t\tbprintf (\"Cannot parse thread\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tis_first_thread = false;\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLIB:\n\t\tcase LC_LOAD_WEAK_DYLIB:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"load_dylib\", 0);\n\t\t\tbin->nlibs++;\n\t\t\tif (!parse_dylib(bin, off)){\n\t\t\t\tbprintf (\"Cannot parse dylib\\n\");\n\t\t\t\tbin->nlibs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_INFO:\n\t\tcase LC_DYLD_INFO_ONLY:\n\t\t\t{\n\t\t\tut8 dyldi[sizeof (struct dyld_info_command)] = {0};\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dyld_info\", 0);\n\t\t\tbin->dyld_info = malloc (sizeof(struct dyld_info_command));\n\n\t\t\tif (off + sizeof (struct dyld_info_command) > bin->size){\n\t\t\t\tbprintf (\"Cannot parse dyldinfo\\n\");\n\t\t\t\tfree (bin->dyld_info);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {\n\t\t\t\tfree (bin->dyld_info);\n\t\t\t\tbin->dyld_info = NULL;\n\t\t\t\tbprintf (\"Error: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\t} else {\n\t\t\t\tbin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);\n\t\t\t\tbin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);\n\t\t\t\tbin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);\n\t\t\t\tbin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);\n\t\t\t\tbin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);\n\t\t\t\tbin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);\n\t\t\t\tbin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);\n\t\t\t\tbin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);\n\t\t\t\tbin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);\n\t\t\t\tbin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);\n\t\t\t\tbin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);\n\t\t\t\tbin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_CODE_SIGNATURE:\n\t\t\tparse_signature (bin, off);\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"signature\", 0);\n\t\t\t/* ut32 dataoff\n\t\t\t// ut32 datasize */\n\t\t\tbreak;\n\t\tcase LC_SOURCE_VERSION:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tif (!parse_thread (bin, &lc, off, is_first_thread)) {\n\t\t\t\tbprintf (\"Cannot parse thread\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tis_first_thread = false;\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLIB:\n\t\tcase LC_LOAD_WEAK_DYLIB:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"load_dylib\", 0);\n\t\t\tbin->nlibs++;\n\t\t\tif (!parse_dylib (bin, off)){\n\t\t\t\tbprintf (\"Cannot parse dylib\\n\");\n\t\t\t\tbin->nlibs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_INFO:\n\t\tcase LC_DYLD_INFO_ONLY:\n\t\t\t{\n\t\t\tut8 dyldi[sizeof (struct dyld_info_command)] = {0};\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dyld_info\", 0);\n\t\t\tbin->dyld_info = calloc (1, sizeof (struct dyld_info_command));\n\t\t\tif (bin->dyld_info) {\n\t\t\t\tif (off + sizeof (struct dyld_info_command) > bin->size){\n\t\t\t\t\tbprintf (\"Cannot parse dyldinfo\\n\");\n\t\t\t\t\tR_FREE (bin->dyld_info);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {\n\t\t\t\t\tfree (bin->dyld_info);\n\t\t\t\t\tbin->dyld_info = NULL;\n\t\t\t\t\tbprintf (\"Error: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\t\t} else {\n\t\t\t\t\tbin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_CODE_SIGNATURE:\n\t\t\tparse_signature (bin, off);\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"signature\", 0);\n\t\t\t/* ut32 dataoff\n\t\t\t// ut32 datasize */\n\t\t\tbreak;\n\t\tcase LC_SOURCE_VERSION:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n\tchar *ea_name;\n\tint rc;\n\tint size = 0;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tinode->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(inode);\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n\tchar *ea_name;\n\tint rc;\n\tint size = 0;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\trc = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tinode->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void dm9000WritePhyReg(uint8_t address, uint16_t data)\n{\n   //Write PHY register address\n   dm9000WriteReg(DM9000_REG_EPAR, 0x40 | address);\n   //Write register value\n   dm9000WriteReg(DM9000_REG_EPDRL, LSB(data));\n   dm9000WriteReg(DM9000_REG_EPDRH, MSB(data));\n\n   //Start the write operation\n   dm9000WriteReg(DM9000_REG_EPCR, EPCR_EPOS | EPCR_ERPRW);\n   //PHY access is still in progress?\n   while((dm9000ReadReg(DM9000_REG_EPCR) & EPCR_ERRE) != 0)\n   {\n   }\n\n   //Wait 5us minimum\n   usleep(5);\n   //Clear command register\n   dm9000WriteReg(DM9000_REG_EPCR, EPCR_EPOS);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void dm9000WritePhyReg(uint8_t address, uint16_t data)\n{\n   //Write PHY register address\n   dm9000WriteReg(DM9000_EPAR, 0x40 | address);\n   //Write register value\n   dm9000WriteReg(DM9000_EPDRL, LSB(data));\n   dm9000WriteReg(DM9000_EPDRH, MSB(data));\n\n   //Start the write operation\n   dm9000WriteReg(DM9000_EPCR, DM9000_EPCR_EPOS | DM9000_EPCR_ERPRW);\n\n   //PHY access is still in progress?\n   while((dm9000ReadReg(DM9000_EPCR) & DM9000_EPCR_ERRE) != 0)\n   {\n   }\n\n   //Wait 5us minimum\n   usleep(5);\n   //Clear command register\n   dm9000WriteReg(DM9000_EPCR, DM9000_EPCR_EPOS);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    else\n\tnew_ts_str = vim_strnsave(new_ts_str, eap->arg - new_ts_str);\n#else\n    ptr = eap->arg;\n    new_ts = getdigits(&ptr);\n    if (new_ts < 0 && *eap->arg == '-')\n    {\n\temsg(_(e_argument_must_be_positive));\n\treturn;\n    }\n    if (new_ts < 0 || new_ts > 9999)\n    {\n\tsemsg(_(e_invalid_argument_str), eap->arg);\n\treturn;\n    }\n    if (new_ts == 0)\n\tnew_ts = curbuf->b_p_ts;\n#endif\n    for (lnum = eap->line1; !got_int && lnum <= eap->line2; ++lnum)\n    {\n\tptr = ml_get(lnum);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    else\n\tnew_ts_str = vim_strnsave(new_ts_str, eap->arg - new_ts_str);\n#else\n    ptr = eap->arg;\n    new_ts = getdigits(&ptr);\n    if (new_ts < 0 && *eap->arg == '-')\n    {\n\temsg(_(e_argument_must_be_positive));\n\treturn;\n    }\n    if (new_ts < 0 || new_ts > TABSTOP_MAX)\n    {\n\tsemsg(_(e_invalid_argument_str), eap->arg);\n\treturn;\n    }\n    if (new_ts == 0)\n\tnew_ts = curbuf->b_p_ts;\n#endif\n    for (lnum = eap->line1; !got_int && lnum <= eap->line2; ++lnum)\n    {\n\tptr = ml_get(lnum);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tret = make_NegHints(minor_status, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tsc = create_spnego_ctx();\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->internal_mech = GSS_C_NO_OID;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tret = make_NegHints(minor_status, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tsc = create_spnego_ctx(0);\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->internal_mech = GSS_C_NO_OID;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\t/* don't alter vm_end if the coredump is running */\n\tif (!prev || !mmget_still_valid(mm) || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tvoid verifyDirectoryPermissions(const string &path) {\n\t\tTRACE_POINT();\n\t\tstruct stat buf;\n\n\t\tif (stat(path.c_str(), &buf) == -1) {\n\t\t\tint e = errno;\n\t\t\tthrow FileSystemException(\"Cannot stat() \" + path, e, path);\n\t\t} else if (buf.st_mode != (S_IFDIR | parseModeString(\"u=rwx,g=rx,o=rx\"))) {\n\t\t\tthrow RuntimeException(\"Tried to reuse existing server instance directory \" +\n\t\t\t\tpath + \", but it has wrong permissions\");\n\t\t} else if (buf.st_uid != geteuid() || buf.st_gid != getegid()) {\n\t\t\t/* The server instance directory is always created by the Watchdog. Its UID/GID never\n\t\t\t * changes because:\n\t\t\t * 1. Disabling user switching only lowers the privilege of the HelperAgent.\n\t\t\t * 2. For the UID/GID to change, the web server must be completely restarted\n\t\t\t *    (not just graceful reload) so that the control process can change its UID/GID.\n\t\t\t *    This causes the PID to change, so that an entirely new server instance\n\t\t\t *    directory is created.",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tvoid verifyDirectoryPermissions(const string &path, struct stat &buf) {\n\t\tTRACE_POINT();\n\n\t\tif (buf.st_mode != (S_IFDIR | parseModeString(\"u=rwx,g=rx,o=rx\"))) {\n\t\t\tthrow RuntimeException(\"Tried to reuse existing server instance directory \" +\n\t\t\t\tpath + \", but it has wrong permissions\");\n\t\t} else if (buf.st_uid != geteuid() || buf.st_gid != getegid()) {\n\t\t\t/* The server instance directory is always created by the Watchdog. Its UID/GID never\n\t\t\t * changes because:\n\t\t\t * 1. Disabling user switching only lowers the privilege of the HelperAgent.\n\t\t\t * 2. For the UID/GID to change, the web server must be completely restarted\n\t\t\t *    (not just graceful reload) so that the control process can change its UID/GID.\n\t\t\t *    This causes the PID to change, so that an entirely new server instance\n\t\t\t *    directory is created.",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "struct bpf_prog *bpf_prog_get(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\n\tprog = __bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\n\tatomic_inc(&prog->aux->refcnt);\n\tfdput(f);\n\n\treturn prog;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "struct bpf_prog *bpf_prog_get(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\n\tprog = __bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\n\tprog = bpf_prog_inc(prog);\n\tfdput(f);\n\n\treturn prog;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\tif (vapic_addr)\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\telse\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tif (vapic_addr) {\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t\t\t\t&vcpu->arch.apic->vapic_cache,\n\t\t\t\t\tvapic_addr, sizeof(u32)))\n\t\t\treturn -EINVAL;\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t} else {\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t}\n\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (!s)\n\t\treturn;\n\n\tkey_id = se050_rsa_keypair_from_nvm(s);\n\tif (key_id) {\n\t\tst = sss_se05x_key_object_get_handle(&k_object, key_id);\n\t\tif (st == kStatus_SSS_Success)\n\t\t\tsss_se05x_key_store_erase_key(se050_kstore, &k_object);\n\t}\n\n\tcrypto_bignum_free(s->e);\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->qp);\n\tcrypto_bignum_free(s->dp);\n\tcrypto_bignum_free(s->dq);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (!s)\n\t\treturn;\n\n\tkey_id = se050_rsa_keypair_from_nvm(s);\n\tif (key_id) {\n\t\tst = sss_se05x_key_object_get_handle(&k_object, key_id);\n\t\tif (st == kStatus_SSS_Success)\n\t\t\tsss_se05x_key_store_erase_key(se050_kstore, &k_object);\n\t}\n\n\tcrypto_bignum_free(&s->e);\n\tcrypto_bignum_free(&s->d);\n\tcrypto_bignum_free(&s->n);\n\tcrypto_bignum_free(&s->p);\n\tcrypto_bignum_free(&s->q);\n\tcrypto_bignum_free(&s->qp);\n\tcrypto_bignum_free(&s->dp);\n\tcrypto_bignum_free(&s->dq);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "load_kernel_module_list (void)\n{\n  GHashTable *modules = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  g_autofree char *modules_data = NULL;\n  g_autoptr(GError) error = NULL;\n  char *start, *end;\n  \n  if (!g_file_get_contents (\"/proc/modules\", &modules_data, NULL, &error))\n    {\n      g_info (\"Failed to read /proc/modules: %s\", error->message);\n      return modules;\n    }\n\n  /* /proc/modules is a table of modules.\n   * Columns are split by spaces and rows by newlines.\n   * The first column is the name. */\n  start = modules_data;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "load_kernel_module_list (void)\n{\n  GHashTable *modules = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  g_autofree char *modules_data = NULL;\n  g_autoptr(GError) error = NULL;\n  char *start, *end;\n\n  if (!g_file_get_contents (\"/proc/modules\", &modules_data, NULL, &error))\n    {\n      g_info (\"Failed to read /proc/modules: %s\", error->message);\n      return modules;\n    }\n\n  /* /proc/modules is a table of modules.\n   * Columns are split by spaces and rows by newlines.\n   * The first column is the name. */\n  start = modules_data;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    long l;\n    int withvalues = 0;\n    robj *hash;\n    listpackEntry ele;\n\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4)\n            withvalues = 1;\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n\n    /* Handle variant without <count> argument. Reply with simple bulk string */\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,hash,OBJ_HASH)) {\n        return;\n    }\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    long l;\n    int withvalues = 0;\n    robj *hash;\n    listpackEntry ele;\n\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4) {\n            withvalues = 1;\n            if (l < LONG_MIN/2 || l > LONG_MAX/2) {\n                addReplyError(c,\"value is out of range\");\n                return;\n            }\n        }\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n\n    /* Handle variant without <count> argument. Reply with simple bulk string */\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,hash,OBJ_HASH)) {\n        return;\n    }\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int hugepage_madvise(struct vm_area_struct *vma,\n\t\t     unsigned long *vm_flags, int advice)\n{\n\tswitch (advice) {\n\tcase MADV_HUGEPAGE:\n\t\t/*\n\t\t * Be somewhat over-protective like KSM for now!\n\t\t */\n\t\tif (*vm_flags & (VM_HUGEPAGE |\n\t\t\t\t VM_SHARED   | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |\n\t\t\t\t VM_MIXEDMAP | VM_SAO))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_NOHUGEPAGE;\n\t\t*vm_flags |= VM_HUGEPAGE;\n\t\t/*\n\t\t * If the vma become good for khugepaged to scan,\n\t\t * register it here without waiting a page fault that\n\t\t * may not happen any time soon.\n\t\t */\n\t\tif (unlikely(khugepaged_enter_vma_merge(vma)))\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase MADV_NOHUGEPAGE:\n\t\t/*\n\t\t * Be somewhat over-protective like KSM for now!\n\t\t */\n\t\tif (*vm_flags & (VM_NOHUGEPAGE |\n\t\t\t\t VM_SHARED   | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |\n\t\t\t\t VM_MIXEDMAP | VM_SAO))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_HUGEPAGE;\n\t\t*vm_flags |= VM_NOHUGEPAGE;\n\t\t/*\n\t\t * Setting VM_NOHUGEPAGE will prevent khugepaged from scanning\n\t\t * this vma even if we leave the mm registered in khugepaged if\n\t\t * it got registered before VM_NOHUGEPAGE was set.\n\t\t */\n\t\tbreak;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int hugepage_madvise(struct vm_area_struct *vma,\n\t\t     unsigned long *vm_flags, int advice)\n{\n\tswitch (advice) {\n\tcase MADV_HUGEPAGE:\n\t\t/*\n\t\t * Be somewhat over-protective like KSM for now!\n\t\t */\n\t\tif (*vm_flags & (VM_HUGEPAGE | VM_NO_THP))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_NOHUGEPAGE;\n\t\t*vm_flags |= VM_HUGEPAGE;\n\t\t/*\n\t\t * If the vma become good for khugepaged to scan,\n\t\t * register it here without waiting a page fault that\n\t\t * may not happen any time soon.\n\t\t */\n\t\tif (unlikely(khugepaged_enter_vma_merge(vma)))\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase MADV_NOHUGEPAGE:\n\t\t/*\n\t\t * Be somewhat over-protective like KSM for now!\n\t\t */\n\t\tif (*vm_flags & (VM_NOHUGEPAGE | VM_NO_THP))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_HUGEPAGE;\n\t\t*vm_flags |= VM_NOHUGEPAGE;\n\t\t/*\n\t\t * Setting VM_NOHUGEPAGE will prevent khugepaged from scanning\n\t\t * this vma even if we leave the mm registered in khugepaged if\n\t\t * it got registered before VM_NOHUGEPAGE was set.\n\t\t */\n\t\tbreak;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\t\t\t!utf8_trail(str[pos + 3])) {\n\t\t\t\t\tif (avail < 2 || utf8_lead(str[pos + 1]))\n\t\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t\telse if (avail < 3 || utf8_lead(str[pos + 2]))\n\t\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t\telse if (avail < 4 || utf8_lead(str[pos + 3]))\n\t\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t\telse\n\t\t\t\t\t\tMB_FAILURE(pos, 4);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis_char = ((c & 0x07) << 18) | ((str[pos + 1] & 0x3f) << 12) | ((str[pos + 2] & 0x3f) << 6) | (str[pos + 3] & 0x3f);\n\t\t\t\tif (this_char < 0x10000 || this_char > 0x10FFFF) { /* non-shortest form or outside range */\n\t\t\t\t\tMB_FAILURE(pos, 4);\n\t\t\t\t}\n\t\t\t\tpos += 4;\n\t\t\t} else {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t}\n\t\t}\n\t\tbreak;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\t\t\t!utf8_trail(str[pos + 3])) {\n\t\t\t\t\tif (avail < 2 || utf8_lead(str[pos + 1]))\n\t\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t\telse if (avail < 3 || utf8_lead(str[pos + 2]))\n\t\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t\telse if (avail < 4 || utf8_lead(str[pos + 3]))\n\t\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t\telse\n\t\t\t\t\t\tMB_FAILURE(pos, 4);\n\t\t\t\t}\n\n\t\t\t\tthis_char = ((c & 0x07) << 18) | ((str[pos + 1] & 0x3f) << 12) | ((str[pos + 2] & 0x3f) << 6) | (str[pos + 3] & 0x3f);\n\t\t\t\tif (this_char < 0x10000 || this_char > 0x10FFFF) { /* non-shortest form or outside range */\n\t\t\t\t\tMB_FAILURE(pos, 4);\n\t\t\t\t}\n\t\t\t\tpos += 4;\n\t\t\t} else {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t}\n\t\t}\n\t\tbreak;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & FSX_PROJID) {\n\t\t/*\n\t\t * CAP_FSETID overrides the following restrictions:\n\t\t *\n\t\t * The set-user-ID and set-group-ID bits of a file will be\n\t\t * cleared upon successful return from chown()\n\t\t */\n\t\tif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\n\t\t    !inode_capable(VFS_I(ip), CAP_FSETID))\n\t\t\tip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\n\n\t\t/*\n\t\t * Change the ownerships and register quota modifications\n\t\t * in the transaction.\n\t\t */\n\t\tif (xfs_get_projid(ip) != fa->fsx_projid) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_PQUOTA_ON(mp)) {\n\t\t\t\tolddquot = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_pdquot, pdqp);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t * Change file ownership.  Must be the owner or privileged.\n\t */\n\tif (mask & FSX_PROJID) {\n\t\t/*\n\t\t * CAP_FSETID overrides the following restrictions:\n\t\t *\n\t\t * The set-user-ID and set-group-ID bits of a file will be\n\t\t * cleared upon successful return from chown()\n\t\t */\n\t\tif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\n\t\t    !capable_wrt_inode_uidgid(VFS_I(ip), CAP_FSETID))\n\t\t\tip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\n\n\t\t/*\n\t\t * Change the ownerships and register quota modifications\n\t\t * in the transaction.\n\t\t */\n\t\tif (xfs_get_projid(ip) != fa->fsx_projid) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_PQUOTA_ON(mp)) {\n\t\t\t\tolddquot = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_pdquot, pdqp);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_nack(\n\t\t\t\t\tpjmedia_rtcp_session *session,\n\t\t\t\t\tvoid *buf,\n\t\t\t\t\tpj_size_t *length,\n\t\t\t\t\tunsigned nack_cnt,\n\t\t\t\t\tconst pjmedia_rtcp_fb_nack nack[])\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    unsigned len, i;\n\n    PJ_ASSERT_RETURN(session && buf && length && nack_cnt && nack, PJ_EINVAL);\n\n    len = (3 + nack_cnt) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP-FB NACK header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_RTPFB;\n    hdr->count = 1; /* FMT = 1 */\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Build RTCP-FB NACK FCI */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < nack_cnt; ++i) {\n\tpj_uint16_t val;\n\tval = pj_htons((pj_uint16_t)nack[i].pid);\n\tpj_memcpy(p, &val, 2);\n\tval = pj_htons(nack[i].blp);\n\tpj_memcpy(p+2, &val, 2);\n\tp += 4;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_nack(\n\t\t\t\t\tpjmedia_rtcp_session *session,\n\t\t\t\t\tvoid *buf,\n\t\t\t\t\tpj_size_t *length,\n\t\t\t\t\tunsigned nack_cnt,\n\t\t\t\t\tconst pjmedia_rtcp_fb_nack nack[])\n{\n    pjmedia_rtcp_fb_common *hdr;\n    pj_uint8_t *p;\n    unsigned len, i;\n\n    PJ_ASSERT_RETURN(session && buf && length && nack_cnt && nack, PJ_EINVAL);\n\n    len = (3 + nack_cnt) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP-FB NACK header */\n    hdr = (pjmedia_rtcp_fb_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_fb_com, sizeof(*hdr));\n    hdr->rtcp_common.pt = RTCP_RTPFB;\n    hdr->rtcp_common.count = 1; /* FMT = 1 */\n    hdr->rtcp_common.length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Build RTCP-FB NACK FCI */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < nack_cnt; ++i) {\n\tpj_uint16_t val;\n\tval = pj_htons((pj_uint16_t)nack[i].pid);\n\tpj_memcpy(p, &val, 2);\n\tval = pj_htons(nack[i].blp);\n\tpj_memcpy(p+2, &val, 2);\n\tp += 4;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static const char *jsi_evalprint(Jsi_Value *v)\n{\n    static char buf[100];\n    if (!v)\n        return \"nil\";\n    if (v->vt == JSI_VT_NUMBER) {\n        snprintf(buf, 100, \"NUM:%\" JSI_NUMGFMT \" \", v->d.num);\n    } else if (v->vt == JSI_VT_BOOL) {\n        snprintf(buf, 100, \"BOO:%d\", v->d.val);\n    } else if (v->vt == JSI_VT_STRING) {\n        snprintf(buf, 100, \"STR:'%s'\", v->d.s.str);\n    } else if (v->vt == JSI_VT_VARIABLE) {\n        snprintf(buf, 100, \"VAR:%p\", v->d.lval);\n    } else if (v->vt == JSI_VT_NULL) {\n        snprintf(buf, 100, \"NULL\");\n    } else if (v->vt == JSI_VT_OBJECT) {\n        snprintf(buf, 100, \"OBJ:%p\", v->d.obj);\n    } else if (v->vt == JSI_VT_UNDEF) {\n        snprintf(buf, 100, \"UNDEFINED\");\n    }\n    return buf;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static const char *jsi_evalprint(Jsi_Value *v)\n{\n    static char buf[JSI_MAX_NUMBER_STRING];\n    if (!v)\n        return \"nil\";\n    if (v->vt == JSI_VT_NUMBER) {\n        snprintf(buf, sizeof(buf), \"NUM:%\" JSI_NUMGFMT \" \", v->d.num);\n    } else if (v->vt == JSI_VT_BOOL) {\n        snprintf(buf, sizeof(buf), \"BOO:%d\", v->d.val);\n    } else if (v->vt == JSI_VT_STRING) {\n        snprintf(buf, sizeof(buf), \"STR:'%s'\", v->d.s.str);\n    } else if (v->vt == JSI_VT_VARIABLE) {\n        snprintf(buf, sizeof(buf), \"VAR:%p\", v->d.lval);\n    } else if (v->vt == JSI_VT_NULL) {\n        snprintf(buf, sizeof(buf), \"NULL\");\n    } else if (v->vt == JSI_VT_OBJECT) {\n        snprintf(buf, sizeof(buf), \"OBJ:%p\", v->d.obj);\n    } else if (v->vt == JSI_VT_UNDEF) {\n        snprintf(buf, sizeof(buf), \"UNDEFINED\");\n    }\n    return buf;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        int          GetU8    (int nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n            if ( nPos < 0 || nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            return m_sFile[ nPos ];\n        }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        int          GetU8    (const unsigned int& nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n            if ( nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            return m_sFile[ nPos ];\n        }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void request_key_auth_describe(const struct key *key,\n\t\t\t\t      struct seq_file *m)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\n\tseq_puts(m, \"key:\");\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void request_key_auth_describe(const struct key *key,\n\t\t\t\t      struct seq_file *m)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\n\tseq_puts(m, \"key:\");\n\tseq_puts(m, key->description);\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  // vector space so that the vector doesn't resize itself, which could\n  // invalidate pointers to its strings' data.\n  tensor_proto_strs.reserve(num_components);\n  int64 total_size = 0;\n  for (int i = 0; i < num_components; ++i) {\n    const CompressedComponentMetadata& metadata =\n        compressed.component_metadata(i);\n    if (DataTypeCanUseMemcpy(metadata.dtype())) {\n      out->emplace_back(metadata.dtype(), metadata.tensor_shape());\n      TensorBuffer* buffer = DMAHelper::buffer(&out->back());\n      iov[i].iov_base = buffer->data();\n      iov[i].iov_len = buffer->size();\n    } else {\n      // Allocate an empty Tensor. We will fill it out later after\n      // uncompressing into the tensor_proto_str.\n      out->emplace_back();\n      tensor_proto_strs.emplace_back();\n      tstring& tensor_proto_str = tensor_proto_strs.back();\n      tensor_proto_str.resize_uninitialized(metadata.tensor_size_bytes());\n      iov[i].iov_base = tensor_proto_str.mdata();\n      iov[i].iov_len = tensor_proto_str.size();\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  // vector space so that the vector doesn't resize itself, which could\n  // invalidate pointers to its strings' data.\n  tensor_proto_strs.reserve(num_components);\n  int64 total_size = 0;\n  for (int i = 0; i < num_components; ++i) {\n    const CompressedComponentMetadata& metadata =\n        compressed.component_metadata(i);\n    if (DataTypeCanUseMemcpy(metadata.dtype())) {\n      out->emplace_back(metadata.dtype(), metadata.tensor_shape());\n      TensorBuffer* buffer = DMAHelper::buffer(&out->back());\n      if (buffer) {\n        iov[i].iov_base = buffer->data();\n        iov[i].iov_len = buffer->size();\n      } else {\n        iov[i].iov_base = nullptr;\n        iov[i].iov_len = 0;\n      }\n    } else {\n      // Allocate an empty Tensor. We will fill it out later after\n      // uncompressing into the tensor_proto_str.\n      out->emplace_back();\n      tensor_proto_strs.emplace_back();\n      tstring& tensor_proto_str = tensor_proto_strs.back();\n      tensor_proto_str.resize_uninitialized(metadata.tensor_size_bytes());\n      iov[i].iov_base = tensor_proto_str.mdata();\n      iov[i].iov_len = tensor_proto_str.size();\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t interprocess_token)\n{\n    OM_uint32 maj;\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    /* We don't currently support exporting partially established contexts. */\n    if (!ctx->established)\n        return GSS_S_UNAVAILABLE;\n\n    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n                                      interprocess_token);\n    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t interprocess_token)\n{\n    OM_uint32 maj;\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;\n\n    /* We don't currently support exporting partially established contexts. */\n    if (!ctx->established)\n        return GSS_S_UNAVAILABLE;\n\n    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n                                      interprocess_token);\n    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteStatus EvalQuantized(TfLiteContext* context, TfLiteNode* node,\n                           TfLiteFullyConnectedParams* params, OpData* data,\n                           const TfLiteTensor* input,\n                           const TfLiteTensor* filter, const TfLiteTensor* bias,\n                           TfLiteTensor* output) {\n  int32_t input_offset = -input->params.zero_point;\n  int32_t filter_offset = -filter->params.zero_point;\n  int32_t output_offset = output->params.zero_point;\n  // Only the Pie path supports quantized models and float inputs/outputs.\n  if (input->type == kTfLiteFloat32) {\n    TfLiteTensor* input_quantized = GetTemporary(context, node, /*index=*/0);\n    TfLiteTensor* scaling_factors = GetTemporary(context, node, /*index=*/1);\n    TfLiteTensor* accum_scratch = GetTemporary(context, node, /*index=*/2);\n    TfLiteTensor* input_offsets = GetTemporary(context, node, /*index=*/3);\n    TfLiteTensor* row_sums = GetTemporary(context, node, /*index=*/4);\n    return EvalHybrid(context, node, params, data, input, filter, bias,\n                      input_quantized, scaling_factors, accum_scratch, row_sums,\n                      input_offsets, output);\n  } else {\n    FullyConnectedParams op_params;\n    op_params.input_offset = input_offset;\n    op_params.weights_offset = filter_offset;\n    op_params.output_offset = output_offset;\n    op_params.output_multiplier = data->output_multiplier;\n    op_params.output_shift = data->output_shift;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteStatus EvalQuantized(TfLiteContext* context, TfLiteNode* node,\n                           TfLiteFullyConnectedParams* params, OpData* data,\n                           const TfLiteTensor* input,\n                           const TfLiteTensor* filter, const TfLiteTensor* bias,\n                           TfLiteTensor* output) {\n  int32_t input_offset = -input->params.zero_point;\n  int32_t filter_offset = -filter->params.zero_point;\n  int32_t output_offset = output->params.zero_point;\n  // Only the Pie path supports quantized models and float inputs/outputs.\n  if (input->type == kTfLiteFloat32) {\n    TfLiteTensor* input_quantized;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/0,\n                                                &input_quantized));\n    TfLiteTensor* scaling_factors;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/1,\n                                                &scaling_factors));\n    TfLiteTensor* accum_scratch;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, /*index=*/2, &accum_scratch));\n    TfLiteTensor* input_offsets;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, /*index=*/3, &input_offsets));\n    TfLiteTensor* row_sums;\n    TF_LITE_ENSURE_OK(context,\n                      GetTemporarySafe(context, node, /*index=*/4, &row_sums));\n    return EvalHybrid(context, node, params, data, input, filter, bias,\n                      input_quantized, scaling_factors, accum_scratch, row_sums,\n                      input_offsets, output);\n  } else {\n    FullyConnectedParams op_params;\n    op_params.input_offset = input_offset;\n    op_params.weights_offset = filter_offset;\n    op_params.output_offset = output_offset;\n    op_params.output_multiplier = data->output_multiplier;\n    op_params.output_shift = data->output_shift;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ripng_print(netdissect_options *ndo, const u_char *dat, unsigned int length)\n{\n\tregister const struct rip6 *rp = (const struct rip6 *)dat;\n\tregister const struct netinfo6 *ni;\n\tregister u_int amt;\n\tregister u_int i;\n\tint j;\n\tint trunc;\n\n\tif (ndo->ndo_snapend < dat)\n\t\treturn;\n\tamt = ndo->ndo_snapend - dat;\n\ti = min(length, amt);\n\tif (i < (sizeof(struct rip6) - sizeof(struct netinfo6)))\n\t\treturn;\n\ti -= (sizeof(struct rip6) - sizeof(struct netinfo6));\n\n\tswitch (rp->rip6_cmd) {\n\n\tcase RIP6_REQUEST:\n\t\tj = length / sizeof(*ni);\n\t\tif (j == 1\n\t\t    &&  rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6\n\t\t    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {\n\t\t\tND_PRINT((ndo, \" ripng-req dump\"));\n\t\t\tbreak;\n\t\t}\n\t\tif (j * sizeof(*ni) != length - 4)\n\t\t\tND_PRINT((ndo, \" ripng-req %d[%u]:\", j, length));\n\t\telse\n\t\t\tND_PRINT((ndo, \" ripng-req %d:\", j));\n\t\ttrunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);\n\t\tfor (ni = rp->rip6_nets; i >= sizeof(*ni);\n\t\t    i -= sizeof(*ni), ++ni) {\n\t\t\tif (ndo->ndo_vflag > 1)\n\t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\trip6_entry_print(ndo, ni, 0);\n\t\t}\n\t\tbreak;\n\tcase RIP6_RESPONSE:\n\t\tj = length / sizeof(*ni);\n\t\tif (j * sizeof(*ni) != length - 4)\n\t\t\tND_PRINT((ndo, \" ripng-resp %d[%u]:\", j, length));\n\t\telse\n\t\t\tND_PRINT((ndo, \" ripng-resp %d:\", j));\n\t\ttrunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);\n\t\tfor (ni = rp->rip6_nets; i >= sizeof(*ni);\n\t\t    i -= sizeof(*ni), ++ni) {\n\t\t\tif (ndo->ndo_vflag > 1)\n\t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\trip6_entry_print(ndo, ni, ni->rip6_metric);\n\t\t}\n\t\tif (trunc)\n\t\t\tND_PRINT((ndo, \"[|ripng]\"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \" ripng-%d ?? %u\", rp->rip6_cmd, length));\n\t\tbreak;\n\t}\n\tif (rp->rip6_vers != RIP6_VERSION)\n\t\tND_PRINT((ndo, \" [vers %d]\", rp->rip6_vers));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ripng_print(netdissect_options *ndo, const u_char *dat, unsigned int length)\n{\n\tregister const struct rip6 *rp = (const struct rip6 *)dat;\n\tregister const struct netinfo6 *ni;\n\tunsigned int length_left;\n\tu_int j;\n\n\tND_TCHECK(rp->rip6_cmd);\n\tswitch (rp->rip6_cmd) {\n\n\tcase RIP6_REQUEST:\n\t\tlength_left = length;\n\t\tif (length_left < (sizeof(struct rip6) - sizeof(struct netinfo6)))\n\t\t\tgoto trunc;\n\t\tlength_left -= (sizeof(struct rip6) - sizeof(struct netinfo6));\n \t\tj = length_left / sizeof(*ni);\n\t\tif (j == 1) {\n\t\t\tND_TCHECK(rp->rip6_nets);\n\t\t\tif (rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6\n\t\t\t    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {\n\t\t\t\tND_PRINT((ndo, \" ripng-req dump\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j * sizeof(*ni) != length_left)\n\t\t\tND_PRINT((ndo, \" ripng-req %u[%u]:\", j, length));\n\t\telse\n\t\t\tND_PRINT((ndo, \" ripng-req %u:\", j));\n\t\tfor (ni = rp->rip6_nets; length_left >= sizeof(*ni);\n\t\t    length_left -= sizeof(*ni), ++ni) {\n\t\t\tND_TCHECK(*ni);\n\t\t\tif (ndo->ndo_vflag > 1)\n\t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\trip6_entry_print(ndo, ni, 0);\n\t\t}\n\t\tif (length_left != 0)\n\t\t\tgoto trunc;\n\t\tbreak;\n\tcase RIP6_RESPONSE:\n\t\tlength_left = length;\n\t\tif (length_left < (sizeof(struct rip6) - sizeof(struct netinfo6)))\n\t\t\tgoto trunc;\n\t\tlength_left -= (sizeof(struct rip6) - sizeof(struct netinfo6));\n\t\tj = length_left / sizeof(*ni);\n\t\tif (j * sizeof(*ni) != length_left)\n\t\t\tND_PRINT((ndo, \" ripng-resp %d[%u]:\", j, length));\n\t\telse\n\t\t\tND_PRINT((ndo, \" ripng-resp %d:\", j));\n\t\tfor (ni = rp->rip6_nets; length_left >= sizeof(*ni);\n\t\t    length_left -= sizeof(*ni), ++ni) {\n\t\t\tND_TCHECK(*ni);\n\t\t\tif (ndo->ndo_vflag > 1)\n\t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\trip6_entry_print(ndo, ni, ni->rip6_metric);\n\t\t}\n\t\tif (length_left != 0)\n\t\t\tgoto trunc;\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \" ripng-%d ?? %u\", rp->rip6_cmd, length));\n\t\tbreak;\n\t}\n\tND_TCHECK(rp->rip6_vers);\n\tif (rp->rip6_vers != RIP6_VERSION)\n\t\tND_PRINT((ndo, \" [vers %d]\", rp->rip6_vers));\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|ripng]\"));\n\treturn;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (tmpstream) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len -\n\t\t  JP2_BOX_HDRLEN(false))) {\n\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (tmpstream) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t    {\n\t\tcan_unload = FALSE;\n\t\tbreak;\n\t    }\n    }\n    if (!can_unload)\n\tsemsg(_(e_attempt_to_delete_buffer_that_is_in_use_str), buf->b_fname);\n    return can_unload;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t    {\n\t\tcan_unload = FALSE;\n\t\tbreak;\n\t    }\n    }\n    if (!can_unload)\n    {\n\tchar_u *fname = buf->b_fname != NULL ? buf->b_fname : buf->b_ffname;\n\n\tsemsg(_(e_attempt_to_delete_buffer_that_is_in_use_str),\n\t\t\t\tfname != NULL ? fname : (char_u *)\"[No Name]\");\n    }\n    return can_unload;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tExifMnoteDataOlympus *n = (ExifMnoteDataOlympus *) en;\n\tExifShort c;\n\tsize_t i, tcount, o, o2, datao = 6, base = 0;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\to2 = 6 + n->offset; /* Start of interesting data */\n\tif ((o2 + 10 < o2) || (o2 + 10 < 10) || (o2 + 10 > buf_size)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Olympus headers start with \"OLYMP\" and need to have at least\n\t * a size of 22 bytes (6 for 'OLYMP', 2 other bytes, 2 for the\n\t * number of entries, and 12 for one entry.\n\t *\n\t\t\t} else {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase olympusV2:\n\t\t/* Olympus S760, S770 */\n\t\tdatao = o2;\n\t\to2 += 8;\n\t\tif ((o2 + 4 < o2) || (o2 + 4 < 4) || (o2 + 4 > buf_size)) return;\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Olympus maker note v2 (0x%02x, %02x, %02x, %02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3]);\n\n\t\tif ((buf[o2] == 'I') && (buf[o2 + 1] == 'I'))\n\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\telse if ((buf[o2] == 'M') && (buf[o2 + 1] == 'M'))\n\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\n\t\t/* The number of entries is at position 8+4. */\n\t\t\tif (n->order == EXIF_BYTE_ORDER_INTEL) {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\t\t} else {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase nikonV2:\n\t\to2 += 6;\n\t\tif ((o2 + 12 < o2) || (o2 + 12 < 12) || (o2 + 12 > buf_size)) return;\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Nikon maker note v2 (0x%02x, %02x, %02x, \"\n\t\t\t\"%02x, %02x, %02x, %02x, %02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3],\n\t\t\tbuf[o2 + 4], buf[o2 + 5], buf[o2 + 6], buf[o2 + 7]);\n\n\t\t/* Skip version number */\n\t\to2 += 1;\n\n\t\t/* Skip an unknown byte (00 or 0A). */\n\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\tbreak;\n\n\tdefault:\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Unknown Olympus variant %i.\", n->version);\n\t\treturn;\n\t}\n\n\t/* Sanity check the offset */\n\tif ((o2 + 2 < o2) || (o2 + 2 < 2) || (o2 + 2 > buf_size)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* Read the number of tags */\n\tc = exif_get_short (buf + o2, n->order);\n\to2 += 2;\n\n\t/* Remove any old entries */\n\tn->entries = exif_mem_alloc (en->mem, sizeof (MnoteOlympusEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteOlympus\", sizeof (MnoteOlympusEntry) * c);\n\t\treturn;\n\t}\n\n\t/* Parse all c entries, storing ones that are successfully parsed */\n\ttcount = 0;\n\tfor (i = c, o = o2; i; --i, o += 12) {\n\t\tsize_t s;\n\t\tif ((o + 12 < o) || (o + 12 < 12) || (o + 12 > buf_size)) {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteOlympus\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t    n->entries[tcount].tag        = exif_get_short (buf + o, n->order) + base;\n\t    n->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t    n->entries[tcount].components = exif_get_long (buf + o + 4, n->order);\n\t    n->entries[tcount].order      = n->order;\n\n\t    exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteOlympus\",\n\t\t      \"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t      mnote_olympus_tag_get_name (n->entries[tcount].tag));\n/*\t    exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteOlympus\",\n\t\t\t    \"0x%x %d %ld*(%d)\",\n\t\t    n->entries[tcount].tag,\n\t\t    n->entries[tcount].format,\n\t\t    n->entries[tcount].components,\n\t\t    (int)exif_format_get_size(n->entries[tcount].format)); */\n\n\t    /*\n\t     * Size? If bigger than 4 bytes, the actual data is not\n\t     * in the entry but somewhere else (offset).\n\t     */\n\t    s = exif_format_get_size (n->entries[tcount].format) *\n\t\t   \t\t\t n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (s) {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4) {\n\t\t\t\t/* The data in this case is merely a pointer */\n\t\t\t\tdataofs = exif_get_long (buf + dataofs, n->order) + datao;\n#ifdef EXIF_OVERCOME_SANYO_OFFSET_BUG\n\t\t\t\t/* Some Sanyo models (e.g. VPC-C5, C40) suffer from a bug when\n\t\t\t\t * writing the offset for the MNOTE_OLYMPUS_TAG_THUMBNAILIMAGE\n\t\t\t\t * tag in its MakerNote. The offset is actually the absolute\n\t\t\t\t * position in the file instead of the position within the IFD.\n\t\t\t\t */\n\t\t\t    if (dataofs + s > buf_size && n->version == sanyoV1) {\n\t\t\t\t\t/* fix pointer */\n\t\t\t\t\tdataofs -= datao + 6;\n\t\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\t  \"ExifMnoteOlympus\",\n\t\t\t\t\t\t  \"Inconsistent thumbnail tag offset; attempting to recover\");\n\t\t\t    }\n#endif\n\t\t\t}\n\t\t\tif ((dataofs + s < dataofs) || (dataofs + s < s) || \n\t\t\t    (dataofs + s > buf_size)) {\n\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t  \"ExifMnoteOlympus\",\n\t\t\t\t\t  \"Tag data past end of buffer (%u > %u)\",\n\t\t\t\t\t  (unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (en->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteOlympus\", s);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tExifMnoteDataOlympus *n = (ExifMnoteDataOlympus *) en;\n\tExifShort c;\n\tsize_t i, tcount, o, o2, datao = 6, base = 0;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\to2 = 6 + n->offset; /* Start of interesting data */\n\tif (CHECKOVERFLOW(o2,buf_size,10)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/*\n\t * Olympus headers start with \"OLYMP\" and need to have at least\n\t * a size of 22 bytes (6 for 'OLYMP', 2 other bytes, 2 for the\n\t * number of entries, and 12 for one entry.\n\t *\n\t\t\t} else {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase olympusV2:\n\t\t/* Olympus S760, S770 */\n\t\tdatao = o2;\n\t\to2 += 8;\n\t\tif (CHECKOVERFLOW(o2,buf_size,4)) return;\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Olympus maker note v2 (0x%02x, %02x, %02x, %02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3]);\n\n\t\tif ((buf[o2] == 'I') && (buf[o2 + 1] == 'I'))\n\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\telse if ((buf[o2] == 'M') && (buf[o2 + 1] == 'M'))\n\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\n\t\t/* The number of entries is at position 8+4. */\n\t\t\tif (n->order == EXIF_BYTE_ORDER_INTEL) {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\t\t} else {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase nikonV2:\n\t\to2 += 6;\n\t\tif (CHECKOVERFLOW(o2,buf_size,12)) return;\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Nikon maker note v2 (0x%02x, %02x, %02x, \"\n\t\t\t\"%02x, %02x, %02x, %02x, %02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3],\n\t\t\tbuf[o2 + 4], buf[o2 + 5], buf[o2 + 6], buf[o2 + 7]);\n\n\t\t/* Skip version number */\n\t\to2 += 1;\n\n\t\t/* Skip an unknown byte (00 or 0A). */\n\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\tbreak;\n\n\tdefault:\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Unknown Olympus variant %i.\", n->version);\n\t\treturn;\n\t}\n\n\t/* Sanity check the offset */\n\tif (CHECKOVERFLOW(o2,buf_size,2)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t/* Read the number of tags */\n\tc = exif_get_short (buf + o2, n->order);\n\to2 += 2;\n\n\t/* Remove any old entries */\n\tn->entries = exif_mem_alloc (en->mem, sizeof (MnoteOlympusEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteOlympus\", sizeof (MnoteOlympusEntry) * c);\n\t\treturn;\n\t}\n\n\t/* Parse all c entries, storing ones that are successfully parsed */\n\ttcount = 0;\n\tfor (i = c, o = o2; i; --i, o += 12) {\n\t\tsize_t s;\n\t\tif (CHECKOVERFLOW(o, buf_size, 12)) {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteOlympus\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t    n->entries[tcount].tag        = exif_get_short (buf + o, n->order) + base;\n\t    n->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t    n->entries[tcount].components = exif_get_long (buf + o + 4, n->order);\n\t    n->entries[tcount].order      = n->order;\n\n\t    exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteOlympus\",\n\t\t      \"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t      mnote_olympus_tag_get_name (n->entries[tcount].tag));\n/*\t    exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteOlympus\",\n\t\t\t    \"0x%x %d %ld*(%d)\",\n\t\t    n->entries[tcount].tag,\n\t\t    n->entries[tcount].format,\n\t\t    n->entries[tcount].components,\n\t\t    (int)exif_format_get_size(n->entries[tcount].format)); */\n\n\t    /* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n\t     * we will check the buffer sizes closer later. */\n\t    if (exif_format_get_size (n->entries[tcount].format) &&\n\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n\t    ) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifMnoteOlympus\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n\t\tcontinue;\n\t    }\n\t    /*\n\t     * Size? If bigger than 4 bytes, the actual data is not\n\t     * in the entry but somewhere else (offset).\n\t     */\n\t    s = exif_format_get_size (n->entries[tcount].format) *\n\t\t   \t\t\t n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (s) {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4) {\n\t\t\t\t/* The data in this case is merely a pointer */\n\t\t\t\tdataofs = exif_get_long (buf + dataofs, n->order) + datao;\n#ifdef EXIF_OVERCOME_SANYO_OFFSET_BUG\n\t\t\t\t/* Some Sanyo models (e.g. VPC-C5, C40) suffer from a bug when\n\t\t\t\t * writing the offset for the MNOTE_OLYMPUS_TAG_THUMBNAILIMAGE\n\t\t\t\t * tag in its MakerNote. The offset is actually the absolute\n\t\t\t\t * position in the file instead of the position within the IFD.\n\t\t\t\t */\n\t\t\t    if (dataofs > (buf_size - s) && n->version == sanyoV1) {\n\t\t\t\t\t/* fix pointer */\n\t\t\t\t\tdataofs -= datao + 6;\n\t\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\t  \"ExifMnoteOlympus\",\n\t\t\t\t\t\t  \"Inconsistent thumbnail tag offset; attempting to recover\");\n\t\t\t    }\n#endif\n\t\t\t}\n\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t  \"ExifMnoteOlympus\",\n\t\t\t\t\t  \"Tag data past end of buffer (%u > %u)\",\n\t\t\t\t\t  (unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (en->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteOlympus\", s);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    exarg_T *eap,\n    int\t    deep,\n    void    *coookie)\n{\n    cctx_T\t*cctx = coookie;\n    int\t\tcc = *name_end;\n    char_u\t*p = lvp->ll_name;\n    int\t\tret = OK;\n    size_t\tlen;\n    char_u\t*buf;\n    isntype_T\tisn = ISN_EXEC;\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    // Cannot use :lockvar and :unlockvar on local variables.\n    if (p[1] != ':')\n    {\n\tchar_u *end = find_name_end(p, NULL, NULL, FNE_CHECK_START);\n\n\tif (lookup_local(p, end - p, NULL, cctx) == OK)\n\t{\n\t    char_u *s = p;\n\n    }\n\n    // Checking is done at runtime.\n    *name_end = NUL;\n    len = name_end - p + 20;\n    buf = alloc(len);\n    if (buf == NULL)\n\tret = FAIL;\n    else\n    {\n\tchar *cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\";\n\n\tif (deep < 0)\n\t    vim_snprintf((char *)buf, len, \"%s! %s\", cmd, p);\n\telse\n\t    vim_snprintf((char *)buf, len, \"%s %d %s\", cmd, deep, p);\n\tret = generate_EXEC_copy(cctx, isn, buf);\n\n\tvim_free(buf);\n\t*name_end = cc;\n    }\n    return ret;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    int\t    deep,\n    void    *coookie)\n{\n    cctx_T\t*cctx = coookie;\n    int\t\tcc = *name_end;\n    char_u\t*p = lvp->ll_name;\n    int\t\tret = OK;\n    size_t\tlen;\n    char_u\t*buf;\n    isntype_T\tisn = ISN_EXEC;\n    char\t*cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\";\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    if (*p == NUL)\n    {\n\tsemsg(_(e_argument_required_for_str), cmd);\n\treturn FAIL;\n    }\n\n    // Cannot use :lockvar and :unlockvar on local variables.\n    if (p[1] != ':')\n    {\n\tchar_u *end = find_name_end(p, NULL, NULL, FNE_CHECK_START);\n\n\tif (lookup_local(p, end - p, NULL, cctx) == OK)\n\t{\n\t    char_u *s = p;\n\n\t}\n    }\n\n    // Checking is done at runtime.\n    *name_end = NUL;\n    len = name_end - p + 20;\n    buf = alloc(len);\n    if (buf == NULL)\n\tret = FAIL;\n    else\n    {\n\tif (deep < 0)\n\t    vim_snprintf((char *)buf, len, \"%s! %s\", cmd, p);\n\telse\n\t    vim_snprintf((char *)buf, len, \"%s %d %s\", cmd, deep, p);\n\tret = generate_EXEC_copy(cctx, isn, buf);\n\n\tvim_free(buf);\n\t*name_end = cc;\n    }\n    return ret;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "cssp_read_tsrequest(STREAM token, STREAM pubkey)\n{\n\tSTREAM s;\n\tint length;\n\tint tagval;\n\n\ts = tcp_recv(NULL, 4);\n\n\tif (s == NULL)\n\t\treturn False;\n\n\t// verify ASN.1 header\n\tif (s->p[0] != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t{\n\t\tlogger(Protocol, Error,\n\tif (s->p[1] < 0x80)\n\t\tlength = s->p[1] - 2;\n\telse if (s->p[1] == 0x81)\n\t\tlength = s->p[2] - 1;\n\telse if (s->p[1] == 0x82)\n\t\tlength = (s->p[2] << 8) | s->p[3];\n\telse\n\t\treturn False;\n\n\t// receive the remainings of message\n\ts = tcp_recv(s, length);\n\n\t// parse the response and into nego token\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\treturn False;\n\n\t// version [0]\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\treturn False;\n\tin_uint8s(s, length);\n\n\t// negoToken [1]\n\tif (token)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\t\treturn False;\n\n\t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)\n\t\t\treturn False;\n\n\t\ttoken->end = token->p = token->data;\n\t\tout_uint8p(token, s->p, length);\n\t\ts_mark_end(token);\n\t}\n\n\t// pubKey [3]\n\tif (pubkey)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3))\n\t\t\treturn False;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "cssp_read_tsrequest(STREAM token, STREAM pubkey)\n{\n\tSTREAM s;\n\tint length;\n\tint tagval;\n\tstruct stream packet;\n\n\ts = tcp_recv(NULL, 4);\n\n\tif (s == NULL)\n\t\treturn False;\n\n\t// verify ASN.1 header\n\tif (s->p[0] != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t{\n\t\tlogger(Protocol, Error,\n\t\tlength = s->p[1] - 2;\n\telse if (s->p[1] == 0x81)\n\t\tlength = s->p[2] - 1;\n\telse if (s->p[1] == 0x82)\n\t\tlength = (s->p[2] << 8) | s->p[3];\n\telse\n\t\treturn False;\n\n\t// receive the remainings of message\n\ts = tcp_recv(s, length);\n\tpacket = *s;\n\n\t// parse the response and into nego token\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\treturn False;\n\n\t// version [0]\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\treturn False;\n\n\tif (!s_check_rem(s, length))\n\t{\n\t\t rdp_protocol_error(\"cssp_read_tsrequest(), consume of version from stream would overrun\",\n\t\t\t\t    &packet);\n\t}\n\tin_uint8s(s, length);\n\n\t// negoToken [1]\n\tif (token)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\t\treturn False;\n\n\t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)\n\t\t\treturn False;\n\n\t\tif (!s_check_rem(s, length))\n\t\t{\n\t\t\trdp_protocol_error(\"cssp_read_tsrequest(), consume of token from stream would overrun\",\n\t\t\t\t\t   &packet);\n\t\t}\n\n\t\ts_realloc(token, length);\n\t\ts_reset(token);\n\t\tout_uint8p(token, s->p, length);\n\t\ts_mark_end(token);\n\t}\n\n\t// pubKey [3]\n\tif (pubkey)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3))\n\t\t\treturn False;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    else if (varp == &p_imak)\n    {\n\tif (gui.in_use && !im_xim_isvalid_imactivate())\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_KEYMAP\n    else if (varp == &curbuf->b_p_keymap)\n    {\n\t/* load or unload key mapping tables */\n\terrmsg = keymap_init();\n\n\tif (errmsg == NULL)\n\t{\n\t    if (*curbuf->b_p_keymap != NUL)\n\t    {\n\t\t/* Installed a new keymap, switch on using it. */\n\t\tcurbuf->b_p_iminsert = B_IMODE_LMAP;\n\t\tif (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)\n\t\t    curbuf->b_p_imsearch = B_IMODE_LMAP;\n\t    }\n    }\n#endif\n\n#if defined(FEAT_RENDER_OPTIONS)\n    else if (varp == &p_rop && gui.in_use)\n    {\n\tif (!gui_mch_set_rendering_options(p_rop))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    /* Options that are a list of flags. */\n    else\n    {\n\tp = NULL;\n\tif (varp == &p_ww)\n\t    p = (char_u *)WW_ALL;\n\tif (varp == &p_shm)\n\t    p = (char_u *)SHM_ALL;\n\telse if (varp == &(p_cpo))\n\t    p = (char_u *)CPO_ALL;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    else if (varp == &p_imak)\n    {\n\tif (gui.in_use && !im_xim_isvalid_imactivate())\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_KEYMAP\n    else if (varp == &curbuf->b_p_keymap)\n    {\n\tif (!valid_filetype(*varp))\n\t    errmsg = e_invarg;\n\telse\n\t    /* load or unload key mapping tables */\n\t    errmsg = keymap_init();\n\n\tif (errmsg == NULL)\n\t{\n\t    if (*curbuf->b_p_keymap != NUL)\n\t    {\n\t\t/* Installed a new keymap, switch on using it. */\n\t\tcurbuf->b_p_iminsert = B_IMODE_LMAP;\n\t\tif (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)\n\t\t    curbuf->b_p_imsearch = B_IMODE_LMAP;\n\t    }\n#endif\n\n#if defined(FEAT_RENDER_OPTIONS)\n    else if (varp == &p_rop && gui.in_use)\n    {\n\tif (!gui_mch_set_rendering_options(p_rop))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_AUTOCMD\n    else if (gvarp == &p_ft)\n    {\n\tif (!valid_filetype(*varp))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_SYN_HL\n    else if (gvarp == &p_syn)\n    {\n\tif (!valid_filetype(*varp))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    /* Options that are a list of flags. */\n    else\n    {\n\tp = NULL;\n\tif (varp == &p_ww)\n\t    p = (char_u *)WW_ALL;\n\tif (varp == &p_shm)\n\t    p = (char_u *)SHM_ALL;\n\telse if (varp == &(p_cpo))\n\t    p = (char_u *)CPO_ALL;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "            switch(rsvp_obj_ctype) {\n\t\tint subobj_type,af,subobj_len,total_subobj_len;\n\n            case RSVP_CTYPE_1:\n\n                if (obj_tlen < 4)\n                    return-1;\n\n\t\t/* read variable length subobjects */\n\t\ttotal_subobj_len = obj_tlen;\n                while(total_subobj_len > 0) {\n                    subobj_len  = EXTRACT_16BITS(obj_tptr);\n                    subobj_type = (EXTRACT_16BITS(obj_tptr+2))>>8;\n                    af = (EXTRACT_16BITS(obj_tptr+2))&0x00FF;\n\n                    ND_PRINT((ndo, \"%s  Subobject Type: %s (%u), AF: %s (%u), length: %u\",\n                           ident,\n                           tok2str(rsvp_obj_generalized_uni_values, \"Unknown\", subobj_type),\n                           subobj_type,\n                           tok2str(af_values, \"Unknown\", af), af,\n                           subobj_len));\n\n                    if(subobj_len == 0)\n                        goto invalid;\n\n                    switch(subobj_type) {\n                    case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS:\n                    case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS:\n\n                        switch(af) {\n                        case AFNUM_INET:\n                            if (subobj_len < 8)\n                                return -1;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tint subobj_type,af,subobj_len,total_subobj_len;\n\n            case RSVP_CTYPE_1:\n\n                if (obj_tlen < 4)\n                    return-1;\n\n\t\t/* read variable length subobjects */\n\t\ttotal_subobj_len = obj_tlen;\n                while(total_subobj_len > 0) {\n                    /* If RFC 3476 Section 3.1 defined that a sub-object of the\n                     * GENERALIZED_UNI RSVP object must have the Length field as\n                     * a multiple of 4, instead of the check below it would be\n                     * better to test total_subobj_len only once before the loop.\n                     * So long as it does not define it and this while loop does\n                     * not implement such a requirement, let's accept that within\n                     * each iteration subobj_len may happen to be a multiple of 1\n                     * and test it and total_subobj_len respectively.\n                     */\n                    if (total_subobj_len < 4)\n                        goto invalid;\n                    subobj_len  = EXTRACT_16BITS(obj_tptr);\n                    subobj_type = (EXTRACT_16BITS(obj_tptr+2))>>8;\n                    af = (EXTRACT_16BITS(obj_tptr+2))&0x00FF;\n\n                    ND_PRINT((ndo, \"%s  Subobject Type: %s (%u), AF: %s (%u), length: %u\",\n                           ident,\n                           tok2str(rsvp_obj_generalized_uni_values, \"Unknown\", subobj_type),\n                           subobj_type,\n                           tok2str(af_values, \"Unknown\", af), af,\n                           subobj_len));\n\n                    /* In addition to what is explained above, the same spec does not\n                     * explicitly say that the same Length field includes the 4-octet\n                     * sub-object header, but as long as this while loop implements it\n                     * as it does include, let's keep the check below consistent with\n                     * the rest of the code.\n                     */\n                    if(subobj_len < 4 || subobj_len > total_subobj_len)\n                        goto invalid;\n\n                    switch(subobj_type) {\n                    case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS:\n                    case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS:\n\n                        switch(af) {\n                        case AFNUM_INET:\n                            if (subobj_len < 8)\n                                return -1;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static pj_status_t transport_destroy  (pjmedia_transport *tp)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n\n    /* Close the slave transport */\n    if (adapter->del_base) {\n        pjmedia_transport_close(adapter->slave_tp);\n    }\n\n    /* Self destruct.. */\n    pj_pool_release(adapter->pool);\n\n    return PJ_SUCCESS;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static pj_status_t transport_destroy  (pjmedia_transport *tp)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n\n    /* Close the slave transport */\n    if (adapter->del_base) {\n        pjmedia_transport_close(adapter->slave_tp);\n    }\n\n    if (adapter->base.grp_lock) {\n        pj_grp_lock_dec_ref(adapter->base.grp_lock);\n    } else {\n        adapter_on_destroy(tp);\n    }\n\n    return PJ_SUCCESS;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static struct ip_options *ip_options_get_alloc(const int optlen)\n{\n\treturn kzalloc(sizeof(struct ip_options) + ((optlen + 3) & ~3),\n\t\t       GFP_KERNEL);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static struct ip_options_rcu *ip_options_get_alloc(const int optlen)\n{\n\treturn kzalloc(sizeof(struct ip_options_rcu) + ((optlen + 3) & ~3),\n\t\t       GFP_KERNEL);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "otError Commissioner::GeneratePskc(const char *              aPassPhrase,\n                                   const char *              aNetworkName,\n                                   const Mac::ExtendedPanId &aExtPanId,\n                                   Pskc &                    aPskc)\n{\n    otError     error      = OT_ERROR_NONE;\n    const char *saltPrefix = \"Thread\";\n    uint8_t     salt[OT_PBKDF2_SALT_MAX_LEN];\n    uint16_t    saltLen = 0;\n\n    VerifyOrExit((strlen(aPassPhrase) >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&\n                     (strlen(aPassPhrase) <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE) &&\n                     (strlen(aNetworkName) <= OT_NETWORK_NAME_MAX_SIZE),\n                 error = OT_ERROR_INVALID_ARGS);\n\n    memset(salt, 0, sizeof(salt));\n    memcpy(salt, saltPrefix, strlen(saltPrefix));\n    saltLen += static_cast<uint16_t>(strlen(saltPrefix));\n\n    memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId));\n    saltLen += OT_EXT_PAN_ID_SIZE;\n\n    memcpy(salt + saltLen, aNetworkName, strlen(aNetworkName));\n    saltLen += static_cast<uint16_t>(strlen(aNetworkName));\n\n    otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), static_cast<uint16_t>(strlen(aPassPhrase)),\n                 reinterpret_cast<const uint8_t *>(salt), saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);\n\nexit:\n    return error;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "otError Commissioner::GeneratePskc(const char *              aPassPhrase,\n                                   const char *              aNetworkName,\n                                   const Mac::ExtendedPanId &aExtPanId,\n                                   Pskc &                    aPskc)\n{\n    otError    error        = OT_ERROR_NONE;\n    const char saltPrefix[] = \"Thread\";\n    uint8_t    salt[OT_PBKDF2_SALT_MAX_LEN];\n    uint16_t   saltLen = 0;\n    uint16_t   passphraseLen;\n    uint8_t    networkNameLen;\n\n    passphraseLen  = static_cast<uint16_t>(strnlen(aPassPhrase, OT_COMMISSIONING_PASSPHRASE_MAX_SIZE + 1));\n    networkNameLen = static_cast<uint8_t>(strnlen(aNetworkName, OT_NETWORK_NAME_MAX_SIZE + 1));\n\n    VerifyOrExit((passphraseLen >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&\n                     (passphraseLen <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE) &&\n                     (networkNameLen <= OT_NETWORK_NAME_MAX_SIZE),\n                 error = OT_ERROR_INVALID_ARGS);\n\n    memset(salt, 0, sizeof(salt));\n    memcpy(salt, saltPrefix, sizeof(saltPrefix) - 1);\n    saltLen += static_cast<uint16_t>(sizeof(saltPrefix) - 1);\n\n    memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId));\n    saltLen += OT_EXT_PAN_ID_SIZE;\n\n    memcpy(salt + saltLen, aNetworkName, networkNameLen);\n    saltLen += networkNameLen;\n\n    otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), passphraseLen, reinterpret_cast<const uint8_t *>(salt),\n                 saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);\n\nexit:\n    return error;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static __inline__ void scm_set_cred(struct scm_cookie *scm,\n\t\t\t\t    struct pid *pid, const struct cred *cred)\n{\n\tscm->pid  = get_pid(pid);\n\tscm->cred = cred ? get_cred(cred) : NULL;\n\tscm->creds.pid = pid_vnr(pid);\n\tscm->creds.uid = cred ? cred->euid : INVALID_UID;\n\tscm->creds.gid = cred ? cred->egid : INVALID_GID;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static __inline__ void scm_set_cred(struct scm_cookie *scm,\n\t\t\t\t    struct pid *pid, const struct cred *cred)\n{\n\tscm->pid  = get_pid(pid);\n\tscm->cred = cred ? get_cred(cred) : NULL;\n\tscm->creds.pid = pid_vnr(pid);\n\tscm->creds.uid = cred ? cred->uid : INVALID_UID;\n\tscm->creds.gid = cred ? cred->gid : INVALID_GID;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tu8 *out_buf;\n\tint ret;\n\n\tif (buf[0] != REPORT_TYPE_LEDS)\n\t\treturn -EINVAL;\n\n\tout_buf = kzalloc(DJREPORT_SHORT_LENGTH, GFP_ATOMIC);\n\tif (!out_buf)\n\t\treturn -ENOMEM;\n\n\tif (count < DJREPORT_SHORT_LENGTH - 2)\n\t\tcount = DJREPORT_SHORT_LENGTH - 2;\n\n\tout_buf[0] = REPORT_ID_DJ_SHORT;\n\tout_buf[1] = djdev->device_index;\n\tmemcpy(out_buf + 2, buf, count);\n\n\tret = hid_hw_raw_request(djrcv_dev->hdev, out_buf[0], out_buf,\n\t\tDJREPORT_SHORT_LENGTH, report_type, reqtype);\n\n\tkfree(out_buf);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tu8 *out_buf;\n\tint ret;\n\n\tif (buf[0] != REPORT_TYPE_LEDS)\n\t\treturn -EINVAL;\n\n\tout_buf = kzalloc(DJREPORT_SHORT_LENGTH, GFP_ATOMIC);\n\tif (!out_buf)\n\t\treturn -ENOMEM;\n\n\tif (count > DJREPORT_SHORT_LENGTH - 2)\n\t\tcount = DJREPORT_SHORT_LENGTH - 2;\n\n\tout_buf[0] = REPORT_ID_DJ_SHORT;\n\tout_buf[1] = djdev->device_index;\n\tmemcpy(out_buf + 2, buf, count);\n\n\tret = hid_hw_raw_request(djrcv_dev->hdev, out_buf[0], out_buf,\n\t\tDJREPORT_SHORT_LENGTH, report_type, reqtype);\n\n\tkfree(out_buf);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    res = _gdContributionsAlloc(line_size, windows_size);\n\n    for (u = 0; u < line_size; u++) {\n        const double dCenter = (double)u / scale_d;\n        /* get the significant edge points affecting the pixel */\n        register int iLeft = MAX(0, (int)floor (dCenter - width_d));\n        int iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n        double dTotalWeight = 0.0;\n\t\tint iSrc;\n\n        res->ContribRow[u].Left = iLeft;\n        res->ContribRow[u].Right = iRight;\n\n        /* Cut edge points to fit in filter window in case of spill-off */\n        if (iRight - iLeft + 1 > windows_size)  {\n            if (iLeft < ((int)src_size - 1 / 2))  {\n                iLeft++;\n            } else {\n                iRight--;\n            }\n        }\n\n        for (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n            dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n        }\n\n\t\tif (dTotalWeight < 0.0) {\n\t\t\t_gdContributionsFree(res);\n\t\t\treturn NULL;\n\t\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    windows_size = 2 * (int)ceil(width_d) + 1;\n    res = _gdContributionsAlloc(line_size, windows_size);\n\n    for (u = 0; u < line_size; u++) {\n        const double dCenter = (double)u / scale_d;\n        /* get the significant edge points affecting the pixel */\n        register int iLeft = MAX(0, (int)floor (dCenter - width_d));\n        int iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n        double dTotalWeight = 0.0;\n\t\tint iSrc;\n\n        /* Cut edge points to fit in filter window in case of spill-off */\n        if (iRight - iLeft + 1 > windows_size)  {\n            if (iLeft < ((int)src_size - 1 / 2))  {\n                iLeft++;\n            } else {\n                iRight--;\n            }\n        }\n\n        res->ContribRow[u].Left = iLeft;\n        res->ContribRow[u].Right = iRight;\n\n        for (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n            dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n        }\n\n\t\tif (dTotalWeight < 0.0) {\n\t\t\t_gdContributionsFree(res);\n\t\t\treturn NULL;\n\t\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void ed_mul_sim_trick(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\t\tconst bn_t m) {\n\ted_t t0[1 << (ED_WIDTH / 2)], t1[1 << (ED_WIDTH / 2)], t[1 << ED_WIDTH];\n\tbn_t n;\n\tint l0, l1, w = ED_WIDTH / 2;\n\tuint8_t w0[RLC_FP_BITS + 1], w1[RLC_FP_BITS + 1];\n\n\tbn_null(n);\n\n\tif (bn_is_zero(k) || ed_is_infty(p)) {\n\t\ted_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ed_is_infty(q)) {\n\t\ted_mul(r, p, k);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void ed_mul_sim_trick(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\t\tconst bn_t m) {\n\ted_t t0[1 << (ED_WIDTH / 2)], t1[1 << (ED_WIDTH / 2)], t[1 << ED_WIDTH];\n\tbn_t n;\n\tsize_t l0, l1, w = ED_WIDTH / 2;\n\tuint8_t w0[RLC_FP_BITS + 1], w1[RLC_FP_BITS + 1];\n\n\tbn_null(n);\n\n\tif (bn_is_zero(k) || ed_is_infty(p)) {\n\t\ted_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ed_is_infty(q)) {\n\t\ted_mul(r, p, k);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                continue;\n            }\n            vol++;\n            if ((ret = decode_vol_header(ctx, gb)) < 0)\n                return ret;\n        } else if (startcode == USER_DATA_STARTCODE) {\n            decode_user_data(ctx, gb);\n        } else if (startcode == GOP_STARTCODE) {\n            mpeg4_decode_gop_header(s, gb);\n        } else if (startcode == VOS_STARTCODE) {\n            mpeg4_decode_profile_level(s, gb);\n            if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n                (s->avctx->level > 0 && s->avctx->level < 9)) {\n                s->studio_profile = 1;\n                next_start_code_studio(gb);\n                extension_and_user_data(s, gb, 0);\n            }\n        } else if (startcode == VISUAL_OBJ_STARTCODE) {\n            if (s->studio_profile) {\n                if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n                    return ret;\n            } else\n                mpeg4_decode_visual_object(s, gb);\n        } else if (startcode == VOP_STARTCODE) {\n            break;\n        }\n\n        align_get_bits(gb);\n        startcode = 0xff;\n    }\n\nend:\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n    s->avctx->has_b_frames = !s->low_delay;\n\n    if (s->studio_profile) {\n        if (!s->avctx->bits_per_raw_sample) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        return decode_studio_vop_header(ctx, gb);\n    } else\n        return decode_vop_header(ctx, gb);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                continue;\n            }\n            vol++;\n            if ((ret = decode_vol_header(ctx, gb)) < 0)\n                return ret;\n        } else if (startcode == USER_DATA_STARTCODE) {\n            decode_user_data(ctx, gb);\n        } else if (startcode == GOP_STARTCODE) {\n            mpeg4_decode_gop_header(s, gb);\n        } else if (startcode == VOS_STARTCODE) {\n            int profile, level;\n            mpeg4_decode_profile_level(s, gb, &profile, &level);\n            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n                (level > 0 && level < 9)) {\n                s->studio_profile = 1;\n                next_start_code_studio(gb);\n                extension_and_user_data(s, gb, 0);\n            } else if (s->studio_profile) {\n                avpriv_request_sample(s->avctx, \"Mixes studio and non studio profile\\n\");\n                return AVERROR_PATCHWELCOME;\n            }\n            s->avctx->profile = profile;\n            s->avctx->level   = level;\n        } else if (startcode == VISUAL_OBJ_STARTCODE) {\n            if (s->studio_profile) {\n                if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n                    return ret;\n            } else\n                mpeg4_decode_visual_object(s, gb);\n        } else if (startcode == VOP_STARTCODE) {\n            break;\n        }\n\n        align_get_bits(gb);\n        startcode = 0xff;\n    }\n\nend:\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n    s->avctx->has_b_frames = !s->low_delay;\n\n    if (s->studio_profile) {\n        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        if (!s->avctx->bits_per_raw_sample) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        return decode_studio_vop_header(ctx, gb);\n    } else\n        return decode_vop_header(ctx, gb);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tmemcpy(state->stateid.data, stateid->data, sizeof(state->stateid.data));\n\tmemcpy(state->open_stateid.data, stateid->data, sizeof(state->open_stateid.data));\n\tswitch (open_flags) {\n\t\tcase FMODE_READ:\n\t\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, fmode_t fmode)\n{\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tmemcpy(state->stateid.data, stateid->data, sizeof(state->stateid.data));\n\tmemcpy(state->open_stateid.data, stateid->data, sizeof(state->open_stateid.data));\n\tswitch (fmode) {\n\t\tcase FMODE_READ:\n\t\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tint error;\n\n\tdprintk(\"nfsd: SETACL(2acl)   %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n\t\tgoto out;\n\n\tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n\tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\n\tif (error)\n\t\tgoto out_drop_write;\n\n\tfh_drop_write(fh);\n\n\tnfserr = fh_getattr(fh, &resp->stat);\n\nout:\n\t/* argp->acl_{access,default} may have been allocated in\n\t   nfssvc_decode_setaclargs. */\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\treturn nfserr;\nout_drop_write:\n\tfh_drop_write(fh);\nout_errno:\n\tnfserr = nfserrno(error);\n\tgoto out;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t__be32 nfserr = 0;\n\tint error;\n\n\tdprintk(\"nfsd: SETACL(2acl)   %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n\t\tgoto out;\n\n\tinode = d_inode(fh->fh_dentry);\n\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\n\tfh_lock(fh);\n\n\terror = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);\n\tif (error)\n\t\tgoto out_drop_lock;\n\terror = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);\n\tif (error)\n\t\tgoto out_drop_lock;\n\n\tfh_unlock(fh);\n\n\tfh_drop_write(fh);\n\n\tnfserr = fh_getattr(fh, &resp->stat);\n\nout:\n\t/* argp->acl_{access,default} may have been allocated in\n\t   nfssvc_decode_setaclargs. */\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\treturn nfserr;\nout_drop_lock:\n\tfh_unlock(fh);\n\tfh_drop_write(fh);\nout_errno:\n\tnfserr = nfserrno(error);\n\tgoto out;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t{\n\t\tStream_Write_UINT8(s, brush->y);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tStream_Write_UINT8(s, brush->style);\n\t}\n\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->hatch = brush->index;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tStream_Write_UINT8(s, brush->hatch);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_05)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tStream_Write_UINT8(s, brush->y);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tStream_Write_UINT8(s, brush->style);\n\t}\n\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tBOOL rc;\n\t\tbrush->hatch = brush->index;\n\t\tbrush->bpp = get_bmf_bpp(brush->style, &rc);\n\t\tif (!rc)\n\t\t\treturn FALSE;\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tStream_Write_UINT8(s, brush->hatch);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_05)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "tsl::Status GpuExecutor::WaitForEvent(Stream* stream, Event* event) {\n  if (GpuDriver::WaitStreamOnEvent(context_, AsGpuStream(stream)->gpu_stream(),\n                                   AsGpuEvent(event)->gpu_event())) {\n    return ::tsl::OkStatus();\n  } else {\n    return tsl::Status(\n        port::error::INTERNAL,\n        absl::StrFormat(\"error recording waiting for CUDA event on stream %p\",\n                        stream));\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "tsl::Status GpuExecutor::WaitForEvent(Stream* stream, Event* event) {\n  if (GpuDriver::WaitStreamOnEvent(context_, AsGpuStream(stream)->gpu_stream(),\n                                   AsGpuEvent(event)->gpu_event())) {\n    return ::tsl::OkStatus();\n  } else {\n    return tsl::Status(\n        tsl::error::INTERNAL,\n        absl::StrFormat(\"error recording waiting for CUDA event on stream %p\",\n                        stream));\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void enc624j600EventHandler(NetInterface *interface)\n{\n   error_t error;\n   uint16_t status;\n   uint16_t value;\n\n   //Read interrupt status register\n   status = enc624j600ReadReg(interface, ENC624J600_REG_EIR);\n\n   //Check whether the link state has changed\n   if((status & EIR_LINKIF) != 0)\n   {\n      //Clear interrupt flag\n      enc624j600ClearBit(interface, ENC624J600_REG_EIR, EIR_LINKIF);\n      //Read Ethernet status register\n      value = enc624j600ReadReg(interface, ENC624J600_REG_ESTAT);\n\n      //Check link state\n      if((value & ESTAT_PHYLNK) != 0)\n      {\n         //Read PHY status register 3\n         value = enc624j600ReadPhyReg(interface, ENC624J600_PHY_REG_PHSTAT3);\n\n         //Get current speed\n         if((value & PHSTAT3_SPDDPX1) != 0)\n         {\n            interface->linkSpeed = NIC_LINK_SPEED_100MBPS;\n         }\n         else\n         {\n            interface->linkSpeed = NIC_LINK_SPEED_10MBPS;\n         }\n\n         //Determine the new duplex mode\n         if((value & PHSTAT3_SPDDPX2) != 0)\n         {\n            interface->duplexMode = NIC_FULL_DUPLEX_MODE;\n         }\n         else\n         {\n            interface->duplexMode = NIC_HALF_DUPLEX_MODE;\n         }\n\n         //Link is up\n         interface->linkState = TRUE;\n      {\n         //Link is down\n         interface->linkState = FALSE;\n      }\n\n      //Process link state change event\n      nicNotifyLinkChange(interface);\n   }\n\n   //Check whether a packet has been received?\n   if((status & EIR_PKTIF) != 0)\n   {\n      //Clear interrupt flag\n      enc624j600ClearBit(interface, ENC624J600_REG_EIR, EIR_PKTIF);\n\n      //Process all pending packets\n      do\n      {\n         //Read incoming packet\n         error = enc624j600ReceivePacket(interface);\n\n         //No more data in the receive buffer?\n      } while(error != ERROR_BUFFER_EMPTY);\n   }\n\n   //Re-enable LINKIE and PKTIE interrupts\n   enc624j600SetBit(interface, ENC624J600_REG_EIE, EIE_LINKIE | EIE_PKTIE);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void enc624j600EventHandler(NetInterface *interface)\n{\n   error_t error;\n   uint16_t status;\n   uint16_t value;\n\n   //Read interrupt status register\n   status = enc624j600ReadReg(interface, ENC624J600_EIR);\n\n   //Check whether the link state has changed\n   if((status & ENC624J600_EIR_LINKIF) != 0)\n   {\n      //Clear interrupt flag\n      enc624j600ClearBit(interface, ENC624J600_EIR, ENC624J600_EIR_LINKIF);\n      //Read Ethernet status register\n      value = enc624j600ReadReg(interface, ENC624J600_ESTAT);\n\n      //Check link state\n      if((value & ENC624J600_ESTAT_PHYLNK) != 0)\n      {\n         //Read PHY status register 3\n         value = enc624j600ReadPhyReg(interface, ENC624J600_PHSTAT3);\n\n         //Get current speed\n         if((value & ENC624J600_PHSTAT3_SPDDPX1) != 0)\n         {\n            interface->linkSpeed = NIC_LINK_SPEED_100MBPS;\n         }\n         else\n         {\n            interface->linkSpeed = NIC_LINK_SPEED_10MBPS;\n         }\n\n         //Determine the new duplex mode\n         if((value & ENC624J600_PHSTAT3_SPDDPX2) != 0)\n         {\n            interface->duplexMode = NIC_FULL_DUPLEX_MODE;\n         }\n         else\n         {\n            interface->duplexMode = NIC_HALF_DUPLEX_MODE;\n         }\n\n         //Link is up\n         interface->linkState = TRUE;\n      {\n         //Link is down\n         interface->linkState = FALSE;\n      }\n\n      //Process link state change event\n      nicNotifyLinkChange(interface);\n   }\n\n   //Check whether a packet has been received?\n   if((status & ENC624J600_EIR_PKTIF) != 0)\n   {\n      //Clear interrupt flag\n      enc624j600ClearBit(interface, ENC624J600_EIR, ENC624J600_EIR_PKTIF);\n\n      //Process all pending packets\n      do\n      {\n         //Read incoming packet\n         error = enc624j600ReceivePacket(interface);\n\n         //No more data in the receive buffer?\n      } while(error != ERROR_BUFFER_EMPTY);\n   }\n\n   //Re-enable LINKIE and PKTIE interrupts\n   enc624j600SetBit(interface, ENC624J600_EIE, ENC624J600_EIE_LINKIE |\n      ENC624J600_EIE_PKTIE);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\t      WLAN_EID_COUNTRY);\n\tis_11d = country_ie ? 1 : 0;\n\n\tmemset(&ssid_le, 0, sizeof(ssid_le));\n\tif (settings->ssid == NULL || settings->ssid_len == 0) {\n\t\tie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;\n\t\tssid_ie = brcmf_parse_tlvs(\n\t\t\t\t(u8 *)&settings->beacon.head[ie_offset],\n\t\t\t\tsettings->beacon.head_len - ie_offset,\n\t\t\t\tWLAN_EID_SSID);\n\t\tif (!ssid_ie)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(ssid_le.SSID, ssid_ie->data, ssid_ie->len);\n\t\tssid_le.SSID_len = cpu_to_le32(ssid_ie->len);\n\t\tbrcmf_dbg(TRACE, \"SSID is (%s) in Head\\n\", ssid_le.SSID);\n\t} else {\n\t\tmemcpy(ssid_le.SSID, settings->ssid, settings->ssid_len);\n\t\tssid_le.SSID_len = cpu_to_le32((u32)settings->ssid_len);\n\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\t      WLAN_EID_COUNTRY);\n\tis_11d = country_ie ? 1 : 0;\n\n\tmemset(&ssid_le, 0, sizeof(ssid_le));\n\tif (settings->ssid == NULL || settings->ssid_len == 0) {\n\t\tie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;\n\t\tssid_ie = brcmf_parse_tlvs(\n\t\t\t\t(u8 *)&settings->beacon.head[ie_offset],\n\t\t\t\tsettings->beacon.head_len - ie_offset,\n\t\t\t\tWLAN_EID_SSID);\n\t\tif (!ssid_ie || ssid_ie->len > IEEE80211_MAX_SSID_LEN)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(ssid_le.SSID, ssid_ie->data, ssid_ie->len);\n\t\tssid_le.SSID_len = cpu_to_le32(ssid_ie->len);\n\t\tbrcmf_dbg(TRACE, \"SSID is (%s) in Head\\n\", ssid_le.SSID);\n\t} else {\n\t\tmemcpy(ssid_le.SSID, settings->ssid, settings->ssid_len);\n\t\tssid_le.SSID_len = cpu_to_le32((u32)settings->ssid_len);\n\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        upstream_tls_context:\n          common_tls_context:\n            tls_certificates:\n            - certificate_chain:\n                filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n              private_key:\n                filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n            validation_context:\n              trusted_ca:\n                filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n              match_subject_alt_names:\n              - exact: localhost\n              - exact: 127.0.0.1\n    typed_extension_protocol_options:\n      envoy.extensions.upstreams.http.v3.HttpProtocolOptions:\n        \"@type\": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\n        use_downstream_protocol_config:\n          http3_protocol_options: {}\n        common_http_protocol_options:\n          idle_timeout: 1s\n  )EOF\",\n                                                       Network::Address::IpVersion::v4);\n  auto cluster = makeCluster(yaml);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        upstream_tls_context:\n          common_tls_context:\n            tls_certificates:\n            - certificate_chain:\n                filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_cert.pem\"\n              private_key:\n                filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n            validation_context:\n              trusted_ca:\n                filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n              match_typed_subject_alt_names:\n              - matcher:\n                  exact: localhost\n                san_type: URI\n              - matcher:\n                  exact: 127.0.0.1\n                san_type: IP_ADDRESS\n    typed_extension_protocol_options:\n      envoy.extensions.upstreams.http.v3.HttpProtocolOptions:\n        \"@type\": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\n        use_downstream_protocol_config:\n          http3_protocol_options: {}\n        common_http_protocol_options:\n          idle_timeout: 1s\n  )EOF\",\n                                                       Network::Address::IpVersion::v4);\n  auto cluster = makeCluster(yaml);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t/*\n\t * Issue flush and toggle pending_idx.  This makes pending_idx\n\t * different from running_idx, which means flush is in flight.\n\t */\n\tfq->flush_pending_idx ^= 1;\n\n\tblk_rq_init(q, flush_rq);\n\n\t/*\n\t * Borrow tag from the first request since they can't\n\t * be in flight at the same time.\n\t */\n\tif (q->mq_ops) {\n\t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n\t\tflush_rq->tag = first_rq->tag;\n\t}\n\n\tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;\n\tflush_rq->end_io = flush_end_io;\n\n\treturn blk_flush_queue_rq(flush_rq, false);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t/*\n\t * Issue flush and toggle pending_idx.  This makes pending_idx\n\t * different from running_idx, which means flush is in flight.\n\t */\n\tfq->flush_pending_idx ^= 1;\n\n\tblk_rq_init(q, flush_rq);\n\n\t/*\n\t * Borrow tag from the first request since they can't\n\t * be in flight at the same time. And acquire the tag's\n\t * ownership for flush req.\n\t */\n\tif (q->mq_ops) {\n\t\tstruct blk_mq_hw_ctx *hctx;\n\n\t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n\t\tflush_rq->tag = first_rq->tag;\n\t\tfq->orig_rq = first_rq;\n\n\t\thctx = q->mq_ops->map_queue(q, first_rq->mq_ctx->cpu);\n\t\tblk_mq_tag_set_rq(hctx, first_rq->tag, flush_rq);\n\t}\n\n\tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;\n\tflush_rq->end_io = flush_end_io;\n\n\treturn blk_flush_queue_rq(flush_rq, false);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    krb5_key_salt_tuple         *new_ks_tuple = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    check_1_6_dummy(entry, mask, n_ks_tuple, ks_tuple, &password);\n\n    /*\n     * Argument sanity checking, and opening up the DB\n     */\n    if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_LAST_SUCCESS) || (mask & KADM5_LAST_FAILED) ||\n       (mask & KADM5_FAIL_AUTH_COUNT))\n        return KADM5_BAD_MASK;\n    if ((mask & KADM5_KEY_DATA) && entry->n_key_data != 0)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if (entry == NULL)\n        return EINVAL;\n\n    /*\n     * Check to see if the principal exists\n     */\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n\n    switch(ret) {\n    case KADM5_UNK_PRINC:\n        break;\n    case 0:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    check_1_6_dummy(entry, mask, n_ks_tuple, ks_tuple, &password);\n\n    /*\n     * Argument sanity checking, and opening up the DB\n     */\n    if (entry == NULL)\n        return EINVAL;\n    if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_LAST_SUCCESS) || (mask & KADM5_LAST_FAILED) ||\n       (mask & KADM5_FAIL_AUTH_COUNT))\n        return KADM5_BAD_MASK;\n    if ((mask & KADM5_KEY_DATA) && entry->n_key_data != 0)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && entry->policy == NULL)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n\n    /*\n     * Check to see if the principal exists\n     */\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n\n    switch(ret) {\n    case KADM5_UNK_PRINC:\n        break;\n    case 0:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tDBG(SAVE, ul_debug(\"device %s, type %s\", dev->bid_name, dev->bid_type ?\n\t\t   dev->bid_type : \"(null)\"));\n\n\tfprintf(file, \"<device DEVNO=\\\"0x%04lx\\\" TIME=\\\"%ld.%ld\\\"\",\n\t\t\t(unsigned long) dev->bid_devno,\n\t\t\t(long) dev->bid_time,\n\t\t\t(long) dev->bid_utime);\n\n\tif (dev->bid_pri)\n\t\tfprintf(file, \" PRI=\\\"%d\\\"\", dev->bid_pri);\n\tlist_for_each(p, &dev->bid_tags) {\n\t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n\t\tfprintf(file, \" %s=\\\"%s\\\"\", tag->bit_name,tag->bit_val);\n\t}\n\tfprintf(file, \">%s</device>\\n\", dev->bid_name);\n\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tDBG(SAVE, ul_debug(\"device %s, type %s\", dev->bid_name, dev->bid_type ?\n\t\t   dev->bid_type : \"(null)\"));\n\n\tfprintf(file, \"<device DEVNO=\\\"0x%04lx\\\" TIME=\\\"%ld.%ld\\\"\",\n\t\t\t(unsigned long) dev->bid_devno,\n\t\t\t(long) dev->bid_time,\n\t\t\t(long) dev->bid_utime);\n\n\tif (dev->bid_pri)\n\t\tfprintf(file, \" PRI=\\\"%d\\\"\", dev->bid_pri);\n\n\tlist_for_each(p, &dev->bid_tags) {\n\t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n\n\t\tfputc(' ', file);\t\t\t/* space between tags */\n\t\tfputs(tag->bit_name, file);\t\t/* tag NAME */\n\t\tfputc('=', file);\t\t\t/* separator between NAME and VALUE */\n\t\tsave_quoted(tag->bit_val, file);\t/* tag \"VALUE\" */\n\t}\n\tfprintf(file, \">%s</device>\\n\", dev->bid_name);\n\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {\n    auto col_params = new CollectiveParams();\n    auto done_with_cleanup = [col_params, done = std::move(done)]() {\n      done();\n      col_params->Unref();\n    };\n    core::RefCountPtr<CollectiveGroupResource> resource;\n    OP_REQUIRES_OK_ASYNC(c, LookupResource(c, HandleFromInput(c, 1), &resource),\n                         done);\n\n    Tensor group_assignment = c->input(2);\n\n    OP_REQUIRES_OK_ASYNC(\n        c,\n        FillCollectiveParams(col_params, group_assignment, REDUCTION_COLLECTIVE,\n                             resource.get()),\n        done);\n    col_params->instance.shape = c->input(0).shape();\n    col_params->merge_op = merge_op_.get();",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {\n    auto col_params = new CollectiveParams();\n    auto done_with_cleanup = [col_params, done = std::move(done)]() {\n      done();\n      col_params->Unref();\n    };\n    core::RefCountPtr<CollectiveGroupResource> resource;\n    OP_REQUIRES_OK_ASYNC(c, LookupResource(c, HandleFromInput(c, 1), &resource),\n                         done_with_cleanup);\n\n    Tensor group_assignment = c->input(2);\n\n    OP_REQUIRES_OK_ASYNC(\n        c,\n        FillCollectiveParams(col_params, group_assignment, REDUCTION_COLLECTIVE,\n                             resource.get()),\n        done);\n    col_params->instance.shape = c->input(0).shape();\n    col_params->merge_op = merge_op_.get();",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    return tsl::errors::Unimplemented(\n        \"int8 -> float fused conv is disabled for this cuDNN version. See \"\n        \"go/nvbugs/3326122\");\n  }\n\n  if (activation_mode != dnn::ActivationMode::kRelu &&\n      activation_mode != dnn::ActivationMode::kRelu6 &&\n      activation_mode != dnn::ActivationMode::kElu &&\n      activation_mode != dnn::ActivationMode::kLeakyRelu &&\n      activation_mode != dnn::ActivationMode::kNone) {\n    return tsl::Status(port::error::INVALID_ARGUMENT,\n                       \"CuDNN fusion only supports activations of \"\n                       \"{Relu, Relu6, Elu, <None>}.\");\n  }\n\n  if (!actually_use_cudnn_frontend) {\n    std::vector<dnn::AlgorithmDesc> algorithms;\n\n    auto cuda_compute_capability = stream->GetCudaComputeCapability();\n    if (!GetConvolveAlgorithms(cuda_compute_capability, input_type,\n                               &algorithms)) {\n      return tsl::Status(port::error::UNKNOWN,\n                         \"Listing fused convolve algorithms failed.\");\n    }\n\n    for (const auto& algo : algorithms) {\n      // Only CUDNN_CONVOLUTION_FWD_ALGO_IMPLICIT_PRECOMP_GEMM is supported\n      // for identity activation, other algs seem to quietly do Relu. See\n      // https://docs.nvidia.com/deeplearning/sdk/cudnn-developer-guide/index.html#cudnnConvolutionBiasActivationForward\n      if (activation_mode == dnn::ActivationMode::kNone &&\n          algo.algo_id() != CUDNN_CONVOLUTION_FWD_ALGO_IMPLICIT_PRECOMP_GEMM) {\n        continue;\n    return ::tsl::OkStatus();\n  }\n\n#if CUDNN_VERSION >= 8100 && TF_ENABLE_CUDNN_FRONTEND\n  auto cudnn = cudnn_->GetHandle(parent_, stream);\n  auto op_graph_status = GetCudnnFusedOperationGraph(\n      kind, input_type, bias_type, output_type, conv_scale, side_input_scale,\n      leakyrelu_alpha, input_descriptor, filter_descriptor, bias_descriptor,\n      output_descriptor, convolution_descriptor, activation_mode, cudnn);\n  if (!op_graph_status.status().ok()) {\n    return tsl::Status(port::error::INTERNAL,\n                       absl::StrCat(\"Cudnn graph failed to build: \",\n                                    op_graph_status.status().ToString()));\n  }\n  auto op_graph = std::move(op_graph_status).value();\n\n  bool need_side_input =\n      SideInputNeeded(activation_mode, conv_scale, side_input_scale);\n  return CreateOpRunners<dnn::FusedConvSignature>(\n      stream, cudnn, parent_, cudnn_.get(), std::move(op_graph), kind,\n      input_type, {'x', 'w', 'z', 'b', 'y'}, use_fallback, out_exec_plans,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    return tsl::errors::Unimplemented(\n        \"int8 -> float fused conv is disabled for this cuDNN version. See \"\n        \"go/nvbugs/3326122\");\n  }\n\n  if (activation_mode != dnn::ActivationMode::kRelu &&\n      activation_mode != dnn::ActivationMode::kRelu6 &&\n      activation_mode != dnn::ActivationMode::kElu &&\n      activation_mode != dnn::ActivationMode::kLeakyRelu &&\n      activation_mode != dnn::ActivationMode::kNone) {\n    return tsl::Status(tsl::error::INVALID_ARGUMENT,\n                       \"CuDNN fusion only supports activations of \"\n                       \"{Relu, Relu6, Elu, <None>}.\");\n  }\n\n  if (!actually_use_cudnn_frontend) {\n    std::vector<dnn::AlgorithmDesc> algorithms;\n\n    auto cuda_compute_capability = stream->GetCudaComputeCapability();\n    if (!GetConvolveAlgorithms(cuda_compute_capability, input_type,\n                               &algorithms)) {\n      return tsl::Status(tsl::error::UNKNOWN,\n                         \"Listing fused convolve algorithms failed.\");\n    }\n\n    for (const auto& algo : algorithms) {\n      // Only CUDNN_CONVOLUTION_FWD_ALGO_IMPLICIT_PRECOMP_GEMM is supported\n      // for identity activation, other algs seem to quietly do Relu. See\n      // https://docs.nvidia.com/deeplearning/sdk/cudnn-developer-guide/index.html#cudnnConvolutionBiasActivationForward\n      if (activation_mode == dnn::ActivationMode::kNone &&\n          algo.algo_id() != CUDNN_CONVOLUTION_FWD_ALGO_IMPLICIT_PRECOMP_GEMM) {\n        continue;\n    return ::tsl::OkStatus();\n  }\n\n#if CUDNN_VERSION >= 8100 && TF_ENABLE_CUDNN_FRONTEND\n  auto cudnn = cudnn_->GetHandle(parent_, stream);\n  auto op_graph_status = GetCudnnFusedOperationGraph(\n      kind, input_type, bias_type, output_type, conv_scale, side_input_scale,\n      leakyrelu_alpha, input_descriptor, filter_descriptor, bias_descriptor,\n      output_descriptor, convolution_descriptor, activation_mode, cudnn);\n  if (!op_graph_status.status().ok()) {\n    return tsl::Status(tsl::error::INTERNAL,\n                       absl::StrCat(\"Cudnn graph failed to build: \",\n                                    op_graph_status.status().ToString()));\n  }\n  auto op_graph = std::move(op_graph_status).value();\n\n  bool need_side_input =\n      SideInputNeeded(activation_mode, conv_scale, side_input_scale);\n  return CreateOpRunners<dnn::FusedConvSignature>(\n      stream, cudnn, parent_, cudnn_.get(), std::move(op_graph), kind,\n      input_type, {'x', 'w', 'z', 'b', 'y'}, use_fallback, out_exec_plans,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ikev1_attrmap_print(netdissect_options *ndo,\n\t\t    const u_char *p, const u_char *ep,\n\t\t    const struct attrmap *map, size_t nmap)\n{\n\tint totlen;\n\tuint32_t t, v;\n\n\tif (p[0] & 0x80)\n\t\ttotlen = 4;\n\telse\n\t\ttotlen = 4 + EXTRACT_16BITS(&p[2]);\n\tif (ep < p + totlen) {\n\t\tND_PRINT((ndo,\"[|attr]\"));\n\t\treturn ep + 1;\n\t}\n\n\tND_PRINT((ndo,\"(\"));\n\tt = EXTRACT_16BITS(&p[0]) & 0x7fff;\n\tif (map && t < nmap && map[t].type)\n\t\tND_PRINT((ndo,\"type=%s \", map[t].type));\n\telse\n\t\tND_PRINT((ndo,\"type=#%d \", t));\n\tif (p[0] & 0x80) {\n\t\tND_PRINT((ndo,\"value=\"));\n\t\tv = EXTRACT_16BITS(&p[2]);\n\t\tif (map && t < nmap && v < map[t].nvalue && map[t].value[v])\n\t\t\tND_PRINT((ndo,\"%s\", map[t].value[v]));\n\t\telse\n\t\t\trawprint(ndo, (const uint8_t *)&p[2], 2);\n\t} else {\n\t\tND_PRINT((ndo,\"len=%d value=\", EXTRACT_16BITS(&p[2])));\n\t\trawprint(ndo, (const uint8_t *)&p[4], EXTRACT_16BITS(&p[2]));\n\t}\n\tND_PRINT((ndo,\")\"));\n\treturn p + totlen;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ikev1_attrmap_print(netdissect_options *ndo,\n\t\t    const u_char *p, const u_char *ep2,\n\t\t    const struct attrmap *map, size_t nmap)\n{\n\tint totlen;\n\tuint32_t t, v;\n\n\tND_TCHECK(p[0]);\n\tif (p[0] & 0x80)\n\t\ttotlen = 4;\n\telse {\n\t\tND_TCHECK_16BITS(&p[2]);\n\t\ttotlen = 4 + EXTRACT_16BITS(&p[2]);\n\t}\n\tif (ep2 < p + totlen) {\n\t\tND_PRINT((ndo,\"[|attr]\"));\n\t\treturn ep2 + 1;\n\t}\n\n\tND_TCHECK_16BITS(&p[0]);\n\tND_PRINT((ndo,\"(\"));\n\tt = EXTRACT_16BITS(&p[0]) & 0x7fff;\n\tif (map && t < nmap && map[t].type)\n\t\tND_PRINT((ndo,\"type=%s \", map[t].type));\n\telse\n\t\tND_PRINT((ndo,\"type=#%d \", t));\n\tif (p[0] & 0x80) {\n\t\tND_PRINT((ndo,\"value=\"));\n\t\tND_TCHECK_16BITS(&p[2]);\n\t\tv = EXTRACT_16BITS(&p[2]);\n\t\tif (map && t < nmap && v < map[t].nvalue && map[t].value[v])\n\t\t\tND_PRINT((ndo,\"%s\", map[t].value[v]));\n\t\telse {\n\t\t\tif (!rawprint(ndo, (const uint8_t *)&p[2], 2)) {\n\t\t\t\tND_PRINT((ndo,\")\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tND_PRINT((ndo,\"len=%d value=\", totlen - 4));\n\t\tif (!rawprint(ndo, (const uint8_t *)&p[4], totlen - 4)) {\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tgoto trunc;\n\t\t}\n\t}\n\tND_PRINT((ndo,\")\"));\n\treturn p + totlen;\n\ntrunc:\n\treturn NULL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int pure_strcmp(const char * const s1, const char * const s2)\n{\n    return pure_memcmp(s1, s2, strlen(s1) + 1U);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int pure_strcmp(const char * const s1, const char * const s2)\n{\n    const size_t s1_len = strlen(s1);\n    const size_t s2_len = strlen(s2);\n    const size_t len = (s1_len < s2_len) ? s1_len : s2_len;\n\n    return pure_memcmp(s1, s2, len + 1);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "_libssh2_packet_add(LIBSSH2_SESSION * session, unsigned char *data,\n                    size_t datalen, int macstate)\n{\n    int rc = 0;\n    char *message = NULL;\n    char *language = NULL;\n    size_t message_len = 0;\n    size_t language_len = 0;\n    LIBSSH2_CHANNEL *channelp = NULL;\n    size_t data_head = 0;\n    unsigned char msg = data[0];\n\n    switch(session->packAdd_state) {\n    case libssh2_NB_state_idle:\n        _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                       \"Packet type %d received, length=%d\",\n\n            /*\n              byte      SSH_MSG_DISCONNECT\n              uint32    reason code\n              string    description in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            */\n\n        case SSH_MSG_DISCONNECT:\n            if(datalen >= 5) {\n                size_t reason = _libssh2_ntohu32(data + 1);\n\n                if(datalen >= 9) {\n                    message_len = _libssh2_ntohu32(data + 5);\n\n                    if(message_len < datalen-13) {\n                        /* 9 = packet_type(1) + reason(4) + message_len(4) */\n                        message = (char *) data + 9;\n\n                        language_len =\n                            _libssh2_ntohu32(data + 9 + message_len);\n                        language = (char *) data + 9 + message_len + 4;\n\n                        if(language_len > (datalen-13-message_len)) {\n                            /* bad input, clear info */\n                            language = message = NULL;\n                            language_len = message_len = 0;\n                        }\n                    }\n                    else\n                        /* bad size, clear it */\n                        message_len = 0;\n                }\n                if(session->ssh_msg_disconnect) {\n                    LIBSSH2_DISCONNECT(session, reason, message,\n                                       message_len, language, language_len);\n                }\n                _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                               \"Disconnect(%d): %s(%s)\", reason,\n                               message, language);\n            }\n\n            LIBSSH2_FREE(session, data);\n            session->socket_state = LIBSSH2_SOCKET_DISCONNECTED;\n            session->packAdd_state = libssh2_NB_state_idle;\n            return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_DISCONNECT,\n                                  \"socket disconnect\");\n              boolean   always_display\n              string    message in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            */\n\n        case SSH_MSG_DEBUG:\n            if(datalen >= 2) {\n                int always_display = data[1];\n\n                if(datalen >= 6) {\n                    message_len = _libssh2_ntohu32(data + 2);\n\n                    if(message_len <= (datalen - 10)) {\n                        /* 6 = packet_type(1) + display(1) + message_len(4) */\n                        message = (char *) data + 6;\n                        language_len = _libssh2_ntohu32(data + 6 +\n                                                        message_len);\n\n                        if(language_len <= (datalen - 10 - message_len))\n                            language = (char *) data + 10 + message_len;\n                    }\n                }\n\n                if(session->ssh_msg_debug) {\n                    LIBSSH2_DEBUG(session, always_display, message,\n                                  message_len, language, language_len);\n                }\n            }\n            /*\n             * _libssh2_debug will actually truncate this for us so\n             * that it's not an inordinate about of data\n             */\n            _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                           \"Debug Packet: %s\", message);\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n              string    request name in US-ASCII only\n              boolean   want reply\n              ....      request-specific data follows\n            */\n\n        case SSH_MSG_GLOBAL_REQUEST:\n            if(datalen >= 5) {\n                uint32_t len = 0;\n                unsigned char want_reply = 0;\n                len = _libssh2_ntohu32(data + 1);\n                if(datalen >= (6 + len)) {\n                    want_reply = data[5 + len];\n                    _libssh2_debug(session,\n                                   LIBSSH2_TRACE_CONN,\n                                   \"Received global request type %.*s (wr %X)\",\n                                   len, data + 5, want_reply);\n                }\n\n\n                if(want_reply) {\n                    static const unsigned char packet =",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "_libssh2_packet_add(LIBSSH2_SESSION * session, unsigned char *data,\n                    size_t datalen, int macstate)\n{\n    int rc = 0;\n    unsigned char *message = NULL;\n    unsigned char *language = NULL;\n    size_t message_len = 0;\n    size_t language_len = 0;\n    LIBSSH2_CHANNEL *channelp = NULL;\n    size_t data_head = 0;\n    unsigned char msg = data[0];\n\n    switch(session->packAdd_state) {\n    case libssh2_NB_state_idle:\n        _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                       \"Packet type %d received, length=%d\",\n\n            /*\n              byte      SSH_MSG_DISCONNECT\n              uint32    reason code\n              string    description in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            */\n\n        case SSH_MSG_DISCONNECT:\n            if(datalen >= 5) {\n                uint32_t reason = 0;\n                struct string_buf buf;\n                buf.data = (unsigned char *)data;\n                buf.dataptr = buf.data;\n                buf.len = datalen;\n                buf.dataptr++; /* advance past type */\n\n                _libssh2_get_u32(&buf, &reason);\n                _libssh2_get_string(&buf, &message, &message_len);\n                _libssh2_get_string(&buf, &language, &language_len);\n\n                if(session->ssh_msg_disconnect) {\n                    LIBSSH2_DISCONNECT(session, reason, (const char *)message,\n                                       message_len, (const char *)language,\n                                       language_len);\n                }\n\n                _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                               \"Disconnect(%d): %s(%s)\", reason,\n                               message, language);\n            }\n\n            LIBSSH2_FREE(session, data);\n            session->socket_state = LIBSSH2_SOCKET_DISCONNECTED;\n            session->packAdd_state = libssh2_NB_state_idle;\n            return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_DISCONNECT,\n                                  \"socket disconnect\");\n              boolean   always_display\n              string    message in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            */\n\n        case SSH_MSG_DEBUG:\n            if(datalen >= 2) {\n                int always_display = data[1];\n\n                if(datalen >= 6) {\n                    struct string_buf buf;\n                    buf.data = (unsigned char *)data;\n                    buf.dataptr = buf.data;\n                    buf.len = datalen;\n                    buf.dataptr += 2; /* advance past type & always display */\n\n                    _libssh2_get_string(&buf, &message, &message_len);\n                    _libssh2_get_string(&buf, &language, &language_len);\n                }\n\n                if(session->ssh_msg_debug) {\n                    LIBSSH2_DEBUG(session, always_display,\n                                  (const char *)message,\n                                  message_len, (const char *)language,\n                                  language_len);\n                }\n            }\n\n            /*\n             * _libssh2_debug will actually truncate this for us so\n             * that it's not an inordinate about of data\n             */\n            _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                           \"Debug Packet: %s\", message);\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n              string    request name in US-ASCII only\n              boolean   want reply\n              ....      request-specific data follows\n            */\n\n        case SSH_MSG_GLOBAL_REQUEST:\n            if(datalen >= 5) {\n                uint32_t len = 0;\n                unsigned char want_reply = 0;\n                len = _libssh2_ntohu32(data + 1);\n                if((len <= (UINT_MAX - 6)) && (datalen >= (6 + len))) {\n                    want_reply = data[5 + len];\n                    _libssh2_debug(session,\n                                   LIBSSH2_TRACE_CONN,\n                                   \"Received global request type %.*s (wr %X)\",\n                                   len, data + 5, want_reply);\n                }\n\n\n                if(want_reply) {\n                    static const unsigned char packet =",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void recovery_character(const char *character)\n{\n    if (!awaiting_character) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n\n    if (strlen(mnemonic) + 1 > MNEMONIC_BUF - 1) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage,\n                        \"Too many characters attempted during recovery\");",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void recovery_character(const char *character)\n{\n    if (!awaiting_character || !recovery_started) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n\n    if (strlen(mnemonic) + 1 > MNEMONIC_BUF - 1) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage,\n                        \"Too many characters attempted during recovery\");",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t    jumpidx = curwin->w_jumplistidx - 1;\n\t    if (jumpidx < 0)\n\t\tjumpidx = curwin->w_jumplistlen - 1;\n\n\t    forward = jumpidx;\n\t    while (jumpidx != curwin->w_jumplistidx)\n\t    {\n\t\tbuf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    if (buf == curbuf || !buf->b_p_bl)\n\t\t\tbuf = NULL;\t// skip current and unlisted bufs\n\t\t    else if (buf->b_ml.ml_mfp == NULL)\n\t\t    {\n\t\t\t// skip unloaded buf, but may keep it for later\n\t\t\tif (bp == NULL)\n\t\t\t    bp = buf;\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t}\n\t\tif (buf != NULL)   // found a valid buffer: stop searching\n\t\t    break;\n\t    {\n\t\tif (buf == NULL)\n\t\t{\n\t\t    if (!forward)\t// tried both directions\n\t\t\tbreak;\n\t\t    buf = curbuf->b_prev;\n\t\t    forward = FALSE;\n\t\t    continue;\n\t\t}\n\t\t// in non-help buffer, try to skip help buffers, and vv\n\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl)\n\t\t{\n\t\t    if (buf->b_ml.ml_mfp != NULL)   // found loaded buffer\n\t\t\tbreak;\n\t\t    if (bp == NULL)\t// remember unloaded buf for later\n\t\t\tbp = buf;\n\t\t}\n\t\tif (forward)\n\t\t    buf = buf->b_next;\n\t\telse\n\t\t    buf = buf->b_prev;\n\t    }\n\t}\n\tif (buf == NULL)\t// No loaded buffer, use unloaded one\n\t    buf = bp;\n\tif (buf == NULL)\t// No loaded buffer, find listed one\n\t{\n\t    FOR_ALL_BUFFERS(buf)\n\t\tif (buf->b_p_bl && buf != curbuf)\n\t\t    break;\n\t}\n\tif (buf == NULL)\t// Still no buffer, just take one\n\t{\n\t    if (curbuf->b_next != NULL)\n\t\tbuf = curbuf->b_next;\n\t    else\n\t\tbuf = curbuf->b_prev;\n\t}\n    }\n\n    if (buf == NULL)\n    {\n\t// Autocommands must have wiped out all other buffers.  Only option\n\t// now is to make the current buffer empty.\n\treturn empty_curbuf(FALSE, (flags & DOBUF_FORCEIT), action);\n    }\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t    jumpidx = curwin->w_jumplistidx - 1;\n\t    if (jumpidx < 0)\n\t\tjumpidx = curwin->w_jumplistlen - 1;\n\n\t    forward = jumpidx;\n\t    while (jumpidx != curwin->w_jumplistidx)\n\t    {\n\t\tbuf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    // Skip current and unlisted bufs.  Also skip a quickfix\n\t\t    // buffer, it might be deleted soon.\n\t\t    if (buf == curbuf || !buf->b_p_bl\n#if defined(FEAT_QUICKFIX)\n\t\t\t    || bt_quickfix(buf)\n#endif\n\t\t\t    )\n\t\t\tbuf = NULL;\n\t\t    else if (buf->b_ml.ml_mfp == NULL)\n\t\t    {\n\t\t\t// skip unloaded buf, but may keep it for later\n\t\t\tif (bp == NULL)\n\t\t\t    bp = buf;\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t}\n\t\tif (buf != NULL)   // found a valid buffer: stop searching\n\t\t    break;\n\t    {\n\t\tif (buf == NULL)\n\t\t{\n\t\t    if (!forward)\t// tried both directions\n\t\t\tbreak;\n\t\t    buf = curbuf->b_prev;\n\t\t    forward = FALSE;\n\t\t    continue;\n\t\t}\n\t\t// in non-help buffer, try to skip help buffers, and vv\n\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl\n#if defined(FEAT_QUICKFIX)\n\t\t\t    && !bt_quickfix(buf)\n#endif\n\t\t\t   )\n\t\t{\n\t\t    if (buf->b_ml.ml_mfp != NULL)   // found loaded buffer\n\t\t\tbreak;\n\t\t    if (bp == NULL)\t// remember unloaded buf for later\n\t\t\tbp = buf;\n\t\t}\n\t\tif (forward)\n\t\t    buf = buf->b_next;\n\t\telse\n\t\t    buf = buf->b_prev;\n\t    }\n\t}\n\tif (buf == NULL)\t// No loaded buffer, use unloaded one\n\t    buf = bp;\n\tif (buf == NULL)\t// No loaded buffer, find listed one\n\t{\n\t    FOR_ALL_BUFFERS(buf)\n\t\tif (buf->b_p_bl && buf != curbuf\n#if defined(FEAT_QUICKFIX)\n\t\t\t    && !bt_quickfix(buf)\n#endif\n\t\t       )\n\t\t    break;\n\t}\n\tif (buf == NULL)\t// Still no buffer, just take one\n\t{\n\t    if (curbuf->b_next != NULL)\n\t\tbuf = curbuf->b_next;\n\t    else\n\t\tbuf = curbuf->b_prev;\n#if defined(FEAT_QUICKFIX)\n\t    if (bt_quickfix(buf))\n\t\tbuf = NULL;\n#endif\n\t}\n    }\n\n    if (buf == NULL)\n    {\n\t// Autocommands must have wiped out all other buffers.  Only option\n\t// now is to make the current buffer empty.\n\treturn empty_curbuf(FALSE, (flags & DOBUF_FORCEIT), action);\n    }\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                        break;\n                    }\n                    tlen -=8;\n                    tptr +=8;\n                }\n                break;\n\n        case BGPTYPE_PMSI_TUNNEL:\n        {\n                uint8_t tunnel_type, flags;\n\n                tunnel_type = *(tptr+1);\n                flags = *tptr;\n                tlen = len;\n\n                ND_TCHECK2(tptr[0], 5);\n                ND_PRINT((ndo, \"\\n\\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u\",\n                       tok2str(bgp_pmsi_tunnel_values, \"Unknown\", tunnel_type),\n                       tunnel_type,\n                       bittok2str(bgp_pmsi_flag_values, \"none\", flags),\n                       EXTRACT_24BITS(tptr+2)>>4));\n\n                tptr +=5;\n                tlen -= 5;\n\n                switch (tunnel_type) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                    }\n                    tlen -=8;\n                    tptr +=8;\n                }\n                break;\n\n        case BGPTYPE_PMSI_TUNNEL:\n        {\n                uint8_t tunnel_type, flags;\n\n                ND_TCHECK2(tptr[0], 5);\n                tunnel_type = *(tptr+1);\n                flags = *tptr;\n                tlen = len;\n\n                ND_PRINT((ndo, \"\\n\\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u\",\n                       tok2str(bgp_pmsi_tunnel_values, \"Unknown\", tunnel_type),\n                       tunnel_type,\n                       bittok2str(bgp_pmsi_flag_values, \"none\", flags),\n                       EXTRACT_24BITS(tptr+2)>>4));\n\n                tptr +=5;\n                tlen -= 5;\n\n                switch (tunnel_type) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ast2obj_arg(void* _o)\n{\n    arg_ty o = (arg_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    result = PyType_GenericNew(arg_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_identifier(o->arg);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_arg, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_expr(o->annotation);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ast2obj_arg(void* _o)\n{\n    arg_ty o = (arg_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_RETURN_NONE;\n    }\n\n    result = PyType_GenericNew(arg_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_identifier(o->arg);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_arg, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_expr(o->annotation);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    case TType::T_LIST: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readListBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readListEnd();\n      return;\n    }\n    default:\n      return;\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    case TType::T_LIST: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readListBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readListEnd();\n      return;\n    }\n    default: {\n      TProtocolException::throwInvalidSkipType(arg_type);\n    }\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic->pending_events;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_has_lapic(vcpu) && vcpu->arch.apic->pending_events;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TEST_P(SslSocketTest, Ipv6San) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/config/integration/certs/upstreamcacert.pem\"\n      match_subject_alt_names:\n        exact: \"::1\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/config/integration/certs/upstreamlocalhostcert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/config/integration/certs/upstreamlocalhostkey.pem\"\n)EOF\";",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TEST_P(SslSocketTest, Ipv6San) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/config/integration/certs/upstreamcacert.pem\"\n      match_typed_subject_alt_names:\n      - san_type: IP_ADDRESS\n        matcher:\n          exact: \"::1\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}/test/config/integration/certs/upstreamlocalhostcert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}/test/config/integration/certs/upstreamlocalhostkey.pem\"\n)EOF\";",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int i, count, name_len, ret;\n    char name[1024];\n\n    avio_rl64(pb);            // reserved 16 bytes\n    avio_rl64(pb);            // ...\n    count = avio_rl32(pb);    // markers count\n    avio_rl16(pb);            // reserved 2 bytes\n    name_len = avio_rl16(pb); // name length\n    for (i = 0; i < name_len; i++)\n        avio_r8(pb); // skip the name\n\n    for (i = 0; i < count; i++) {\n        int64_t pres_time;\n        int name_len;\n\n        avio_rl64(pb);             // offset, 8 bytes\n        pres_time = avio_rl64(pb); // presentation time\n        pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             // entry length\n        avio_rl32(pb);             // send time\n        avio_rl32(pb);             // flags\n        name_len = avio_rl32(pb);  // name length\n        if ((ret = avio_get_str16le(pb, name_len * 2, name,\n                                    sizeof(name))) < name_len)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int i, count, name_len, ret;\n    char name[1024];\n\n    avio_rl64(pb);            // reserved 16 bytes\n    avio_rl64(pb);            // ...\n    count = avio_rl32(pb);    // markers count\n    avio_rl16(pb);            // reserved 2 bytes\n    name_len = avio_rl16(pb); // name length\n    avio_skip(pb, name_len);\n\n    for (i = 0; i < count; i++) {\n        int64_t pres_time;\n        int name_len;\n\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n\n        avio_rl64(pb);             // offset, 8 bytes\n        pres_time = avio_rl64(pb); // presentation time\n        pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             // entry length\n        avio_rl32(pb);             // send time\n        avio_rl32(pb);             // flags\n        name_len = avio_rl32(pb);  // name length\n        if ((ret = avio_get_str16le(pb, name_len * 2, name,\n                                    sizeof(name))) < name_len)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                                   platform.ValueOrDie()->Name(), \": \",\n                                   status.ToString());\n    }\n  }\n\n  xla::LocalClientOptions client_options;\n  client_options.set_platform(platform.ValueOrDie());\n  client_options.set_intra_op_parallelism_threads(\n      device->tensorflow_cpu_worker_threads()->num_threads);\n\n  string allowed_gpus =\n      flr->config_proto()->gpu_options().visible_device_list();\n  TF_ASSIGN_OR_RETURN(absl::optional<std::set<int>> gpu_ids,\n                      ParseVisibleDeviceList(allowed_gpus));\n  client_options.set_allowed_devices(gpu_ids);\n\n  auto client = xla::ClientLibrary::GetOrCreateLocalClient(client_options);\n  if (!client.ok()) {\n    return client.status();\n  }\n  const XlaOpRegistry::DeviceRegistration* registration;\n  if (!XlaOpRegistry::GetCompilationDevice(platform_info.device_type().type(),\n                                           &registration)) {\n    return errors::InvalidArgument(\"No JIT device registered for \",\n                                   platform_info.device_type().type());",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                                   platform.ValueOrDie()->Name(), \": \",\n                                   status.ToString());\n    }\n  }\n\n  xla::LocalClientOptions client_options;\n  client_options.set_platform(platform.ValueOrDie());\n  client_options.set_intra_op_parallelism_threads(\n      device->tensorflow_cpu_worker_threads()->num_threads);\n\n  if (flr->config_proto()) {\n    string allowed_gpus =\n        flr->config_proto()->gpu_options().visible_device_list();\n    TF_ASSIGN_OR_RETURN(absl::optional<std::set<int>> gpu_ids,\n                        ParseVisibleDeviceList(allowed_gpus));\n    client_options.set_allowed_devices(gpu_ids);\n  }\n\n  auto client = xla::ClientLibrary::GetOrCreateLocalClient(client_options);\n  if (!client.ok()) {\n    return client.status();\n  }\n  const XlaOpRegistry::DeviceRegistration* registration;\n  if (!XlaOpRegistry::GetCompilationDevice(platform_info.device_type().type(),\n                                           &registration)) {\n    return errors::InvalidArgument(\"No JIT device registered for \",\n                                   platform_info.device_type().type());",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tunsigned long lr;\n\tlong level = 0;\n\tstruct signal_frame_64 __user *sigframe;\n\tunsigned long __user *fp, *uregs;\n\n\tnext_ip = perf_instruction_pointer(regs);\n\tlr = regs->link;\n\tsp = regs->gpr[1];\n\tperf_callchain_store(entry, next_ip);\n\n\tfor (;;) {\n\t\tfp = (unsigned long __user *) sp;\n\t\tif (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &next_sp))\n\t\t\treturn;\n\t\tif (level > 0 && read_user_stack_64(&fp[2], &next_ip))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Note: the next_sp - sp >= signal frame size check\n\t\t * is true when next_sp < sp, which can happen when\n\t\t * transitioning from an alternate signal stack to the",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tunsigned long lr;\n\tlong level = 0;\n\tstruct signal_frame_64 __user *sigframe;\n\tunsigned long __user *fp, *uregs;\n\n\tnext_ip = perf_instruction_pointer(regs);\n\tlr = regs->link;\n\tsp = regs->gpr[1];\n\tperf_callchain_store(entry, next_ip);\n\n\twhile (entry->nr < PERF_MAX_STACK_DEPTH) {\n\t\tfp = (unsigned long __user *) sp;\n\t\tif (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &next_sp))\n\t\t\treturn;\n\t\tif (level > 0 && read_user_stack_64(&fp[2], &next_ip))\n\t\t\treturn;\n\n\t\t/*\n\t\t * Note: the next_sp - sp >= signal frame size check\n\t\t * is true when next_sp < sp, which can happen when\n\t\t * transitioning from an alternate signal stack to the",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tif (cursor->hashval != sbp->hash) {\n\t\t\tcursor->hashval = sbp->hash;\n\t\t\tcursor->offset = 0;\n\t\t}\n\t\terror = context->put_listent(context,\n\t\t\t\t\tsbp->flags,\n\t\t\t\t\tsbp->name,\n\t\t\t\t\tsbp->namelen,\n\t\t\t\t\tsbp->valuelen,\n\t\t\t\t\t&sbp->name[sbp->namelen]);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\n\tkmem_free(sbuf);\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tif (cursor->hashval != sbp->hash) {\n\t\t\tcursor->hashval = sbp->hash;\n\t\t\tcursor->offset = 0;\n\t\t}\n\t\terror = context->put_listent(context,\n\t\t\t\t\tsbp->flags,\n\t\t\t\t\tsbp->name,\n\t\t\t\t\tsbp->namelen,\n\t\t\t\t\tsbp->valuelen,\n\t\t\t\t\t&sbp->name[sbp->namelen]);\n\t\tif (error) {\n\t\t\tkmem_free(sbuf);\n\t\t\treturn error;\n\t\t}\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\n\tkmem_free(sbuf);\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void handle_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        uint8_t buf[64];\n        memcpy(buf, msg, sizeof(buf));\n\n        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n        uint32_t msgSize = buf[8]        |\n                ((uint32_t)buf[7]) <<  8 |\n                ((uint32_t)buf[6]) << 16 |\n                ((uint32_t)buf[5]) << 24;\n\n        if (msgSize > 64 - 9) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n            return;\n        }\n\n        // Determine callback handler and message map type.\n        const MessagesMap_t *entry = message_map_entry(NORMAL_MSG, msgId, IN_MSG);\n        if (!entry) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n            return;\n        }\n\n        tiny_dispatch(entry, buf + 9, msgSize);\n    } else {\n        usb_rx_helper(msg, len, NORMAL_MSG);\n    }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void handle_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        msg_read_tiny(msg, len);\n    } else {\n        usb_rx_helper(msg, len, NORMAL_MSG);\n    }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        if (frame->color_range != AVCOL_RANGE_UNSPECIFIED)\n            print_str(\"color_range\", av_color_range_name(frame->color_range));\n        else\n            print_str_opt(\"color_range\", av_color_range_name(frame->color_range));\n\n        if (frame->colorspace != AVCOL_SPC_UNSPECIFIED)\n            print_str(\"color_space\", av_color_space_name(frame->colorspace));\n        else\n            print_str_opt(\"color_space\", av_color_space_name(frame->colorspace));\n\n        if (frame->color_primaries != AVCOL_PRI_UNSPECIFIED)\n            print_str(\"color_primaries\", av_color_primaries_name(frame->color_primaries));\n        else\n            print_str_opt(\"color_primaries\", av_color_primaries_name(frame->color_primaries));\n\n        if (frame->color_trc != AVCOL_TRC_UNSPECIFIED)\n            print_str(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n        else\n            print_str_opt(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n\n        if (frame->chroma_location != AVCHROMA_LOC_UNSPECIFIED)\n            print_str(\"chroma_location\", av_chroma_location_name(frame->chroma_location));\n        else\n            print_str_opt(\"chroma_location\", av_chroma_location_name(frame->chroma_location));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        if (frame->color_range != AVCOL_RANGE_UNSPECIFIED)\n            print_str(\"color_range\", av_color_range_name(frame->color_range));\n        else\n            print_str_opt(\"color_range\", av_color_range_name(frame->color_range));\n\n        if (frame->colorspace != AVCOL_SPC_UNSPECIFIED)\n            print_str(\"color_space\", av_color_space_name(frame->colorspace));\n        else\n            print_str_opt(\"color_space\", av_color_space_name(frame->colorspace));\n\n        print_primaries(w, frame->color_primaries);\n\n        if (frame->color_trc != AVCOL_TRC_UNSPECIFIED)\n            print_str(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n        else\n            print_str_opt(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n\n        if (frame->chroma_location != AVCHROMA_LOC_UNSPECIFIED)\n            print_str(\"chroma_location\", av_chroma_location_name(frame->chroma_location));\n        else\n            print_str_opt(\"chroma_location\", av_chroma_location_name(frame->chroma_location));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void IOBuf::reserveSlow(std::size_t minHeadroom, std::size_t minTailroom) {\n  size_t newCapacity = (size_t)length_ + minHeadroom + minTailroom;\n  DCHECK_LT(newCapacity, UINT32_MAX);\n\n  // reserveSlow() is dangerous if anyone else is sharing the buffer, as we may\n  // reallocate and free the original buffer.  It should only ever be called if\n  // we are the only user of the buffer.\n  DCHECK(!isSharedOne());\n\n  // We'll need to reallocate the buffer.\n  // There are a few options.\n  // - If we have enough total room, move the data around in the buffer\n  //   and adjust the data_ pointer.",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void IOBuf::reserveSlow(std::size_t minHeadroom, std::size_t minTailroom) {\n  size_t newCapacity = length_;\n  if (!checked_add(&newCapacity, newCapacity, minHeadroom) ||\n      !checked_add(&newCapacity, newCapacity, minTailroom) ||\n      newCapacity > kMaxIOBufSize) {\n    // overflow\n    throw_exception<std::bad_alloc>();\n  }\n\n  // reserveSlow() is dangerous if anyone else is sharing the buffer, as we may\n  // reallocate and free the original buffer.  It should only ever be called if\n  // we are the only user of the buffer.\n  DCHECK(!isSharedOne());\n\n  // We'll need to reallocate the buffer.\n  // There are a few options.\n  // - If we have enough total room, move the data around in the buffer\n  //   and adjust the data_ pointer.",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int msg_parse_fetch (IMAP_HEADER *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp;\n\n  if (!s)\n    return -1;\n\n  while (*s)\n  {\n    SKIPWS (s);\n\n    if (ascii_strncasecmp (\"FLAGS\", s, 5) == 0)\n    {\n    {\n      s += 12;\n      SKIPWS (s);\n      if (*s != '\\\"')\n      {\n        dprint (1, (debugfile, \"msg_parse_fetch(): bogus INTERNALDATE entry: %s\\n\", s));\n        return -1;\n      }\n      s++;\n      ptmp = tmp;\n      while (*s && *s != '\\\"')\n        *ptmp++ = *s++;\n      if (*s != '\\\"')\n        return -1;\n      s++; /* skip past the trailing \" */\n      *ptmp = 0;\n      h->received = imap_parse_date (tmp);\n    }\n    else if (ascii_strncasecmp (\"RFC822.SIZE\", s, 11) == 0)\n    {\n      s += 11;\n      SKIPWS (s);\n      ptmp = tmp;\n      while (isdigit ((unsigned char) *s))\n        *ptmp++ = *s++;\n      *ptmp = 0;\n      if (mutt_atol (tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if (!ascii_strncasecmp (\"BODY\", s, 4) ||\n      !ascii_strncasecmp (\"RFC822.HEADER\", s, 13))\n    {\n      /* handle above, in msg_fetch_header */\n      return -2;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int msg_parse_fetch (IMAP_HEADER *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp;\n  size_t dlen;\n\n  if (!s)\n    return -1;\n\n  while (*s)\n  {\n    SKIPWS (s);\n\n    if (ascii_strncasecmp (\"FLAGS\", s, 5) == 0)\n    {\n    {\n      s += 12;\n      SKIPWS (s);\n      if (*s != '\\\"')\n      {\n        dprint (1, (debugfile, \"msg_parse_fetch(): bogus INTERNALDATE entry: %s\\n\", s));\n        return -1;\n      }\n      s++;\n      ptmp = tmp;\n      dlen = sizeof(tmp) - 1;\n      while (*s && *s != '\\\"' && dlen)\n      {\n        *ptmp++ = *s++;\n        dlen--;\n      }\n      if (*s != '\\\"')\n        return -1;\n      s++; /* skip past the trailing \" */\n      *ptmp = 0;\n      h->received = imap_parse_date (tmp);\n    }\n    else if (ascii_strncasecmp (\"RFC822.SIZE\", s, 11) == 0)\n    {\n      s += 11;\n      SKIPWS (s);\n      ptmp = tmp;\n      dlen = sizeof(tmp) - 1;\n      while (isdigit ((unsigned char) *s) && dlen)\n      {\n        *ptmp++ = *s++;\n        dlen--;\n      }\n      *ptmp = 0;\n      if (mutt_atol (tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if (!ascii_strncasecmp (\"BODY\", s, 4) ||\n      !ascii_strncasecmp (\"RFC822.HEADER\", s, 13))\n    {\n      /* handle above, in msg_fetch_header */\n      return -2;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint16 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint32 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "MONGO_EXPORT int bson_append_binary( bson *b, const char *name, char type, const char *str, int len ) {\n    if ( type == BSON_BIN_BINARY_OLD ) {\n        int subtwolen = len + 4;\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+4+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32( b, &subtwolen );\n        bson_append_byte( b, type );\n        bson_append32( b, &len );\n        bson_append( b, str, len );\n    }\n    else {\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32( b, &len );\n        bson_append_byte( b, type );\n        bson_append( b, str, len );\n    }\n    return BSON_OK;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "MONGO_EXPORT int bson_append_binary( bson *b, const char *name, char type, const char *str, size_t len ) {\n    if ( type == BSON_BIN_BINARY_OLD ) {\n        int subtwolen = len + 4;\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+4+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32_as_int( b, ( int )subtwolen );\n        bson_append_byte( b, type );\n        bson_append32_as_int( b, ( int )len );\n        bson_append( b, str, len );\n    }\n    else {\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32_as_int( b, ( int )len );\n        bson_append_byte( b, type );\n        bson_append( b, str, len );\n    }\n    return BSON_OK;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void show_object(struct object *obj,\n\t\t\tstruct strbuf *path, const char *component,\n\t\t\tvoid *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tfinish_object(obj, path, component, cb_data);\n\tif (info->flags & REV_LIST_QUIET)\n\t\treturn;\n\tshow_object_with_name(stdout, obj, path, component);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void show_object(struct object *obj, const char *name, void *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tfinish_object(obj, name, cb_data);\n\tif (info->flags & REV_LIST_QUIET)\n\t\treturn;\n\tshow_object_with_name(stdout, obj, name);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "          if (LLVM_LIKELY(numVal == uintVal) && // Only integers.\n              LLVM_LIKELY(uintVal >= ip->iSwitchImm.op4) && // Bounds checking.\n              LLVM_LIKELY(uintVal <= ip->iSwitchImm.op5)) // Bounds checking.\n          {\n            // Calculate the offset into the bytecode where the jump table for\n            // this SwitchImm starts.\n            const uint8_t *tablestart = (const uint8_t *)llvh::alignAddr(\n                (const uint8_t *)ip + ip->iSwitchImm.op2, sizeof(uint32_t));\n\n            // Read the offset from the table.\n            const uint32_t *loc =\n                (const uint32_t *)tablestart + uintVal - ip->iSwitchImm.op4;\n\n            ip = IPADD(*loc);\n            DISPATCH;\n          }\n        }\n        // Wrong type or out of range, jump to default.\n        ip = IPADD(ip->iSwitchImm.op3);\n        DISPATCH;\n      }\n      LOAD_CONST(",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "          if (LLVM_LIKELY(numVal == uintVal) && // Only integers.\n              LLVM_LIKELY(uintVal >= ip->iSwitchImm.op4) && // Bounds checking.\n              LLVM_LIKELY(uintVal <= ip->iSwitchImm.op5)) // Bounds checking.\n          {\n            // Calculate the offset into the bytecode where the jump table for\n            // this SwitchImm starts.\n            const uint8_t *tablestart = (const uint8_t *)llvh::alignAddr(\n                (const uint8_t *)ip + ip->iSwitchImm.op2, sizeof(uint32_t));\n\n            // Read the offset from the table.\n            // Must be signed to account for backwards branching.\n            const int32_t *loc =\n                (const int32_t *)tablestart + uintVal - ip->iSwitchImm.op4;\n\n            ip = IPADD(*loc);\n            DISPATCH;\n          }\n        }\n        // Wrong type or out of range, jump to default.\n        ip = IPADD(ip->iSwitchImm.op3);\n        DISPATCH;\n      }\n      LOAD_CONST(",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (collen > 0)\n\t\t\t\t{\n\t\t\t\t\tcolor = CVAL(in);\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (replen > 0)\n\t\t\t\t{\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (collen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = CVAL(in);\n\t\t\t\t\tif (x & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tx = x + 1;\n\t\t\t\t\t\tcolor = -x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tcolor = x;\n\t\t\t\t\t}\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (replen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tindexh++;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && collen > 0)\n\t\t\t\t{\n\t\t\t\t\tcolor = CVAL(in);\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && replen > 0)\n\t\t\t\t{\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && collen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = CVAL(in);\n\t\t\t\t\tif (x & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tx = x + 1;\n\t\t\t\t\t\tcolor = -x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tcolor = x;\n\t\t\t\t\t}\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && replen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tindexh++;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin || !bin->segment_entries) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t}\n\t\tn->m_pkthdr.len -= len0;\n\t\tolen = m0->m_pkthdr.len;\n\t\tm0->m_pkthdr.len = len0;\n\t\tif (remain == 0) {\n\t\t\tn->m_next = m->m_next;\n\t\t\tm->m_next = NULL;\n\t\t\tn->m_len = 0;\n\t\t\treturn (n);\n\t\t}\n\t\tif (m->m_flags & M_EXT)\n\t\t\tgoto extpacket;\n\t\tif (remain > MHLEN) {\n\t\t\t/* m can't be the lead packet */\n\t\t\tm_align(n, 0);\n\t\t\tn->m_next = m_split(m, len, wait);\n\t\t\tif (n->m_next == NULL) {\n\t\t\t\t(void) m_free(n);\n\t\t\t\tm0->m_pkthdr.len = olen;\n\t\t\t\treturn (NULL);\n\t\t\t} else {\n\t\t\t\tn->m_len = 0;\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t} else\n\t\t\tm_align(n, remain);\n\t} else if (remain == 0) {\n\t\tn = m->m_next;\n\t\tm->m_next = NULL;\n\t\treturn (n);\n\t} else {\n\t\tMGET(n, wait, m->m_type);\n\t\tif (n == NULL)\n\t\t\treturn (NULL);\n\t\tm_align(n, remain);\n\t}\nextpacket:\n\tif (m->m_flags & M_EXT) {\n\t\tn->m_ext = m->m_ext;\n\t\tMCLADDREFERENCE(m, n);\n\t\tn->m_data = m->m_data + len;\n\t} else {\n\t\tmemcpy(mtod(n, caddr_t), mtod(m, caddr_t) + len, remain);\n\t}\n\tn->m_len = remain;\n\tm->m_len = len;\n\tn->m_next = m->m_next;\n\tm->m_next = NULL;\n\treturn (n);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t}\n\t\tn->m_pkthdr.len -= len0;\n\t\tolen = m0->m_pkthdr.len;\n\t\tm0->m_pkthdr.len = len0;\n\t\tif (remain == 0) {\n\t\t\tn->m_next = m->m_next;\n\t\t\tm->m_next = NULL;\n\t\t\tn->m_len = 0;\n\t\t\treturn (n);\n\t\t}\n\t\tif ((m->m_flags & M_EXT) == 0 && remain > MHLEN) {\n\t\t\t/* m can't be the lead packet */\n\t\t\tm_align(n, 0);\n\t\t\tn->m_next = m_split(m, len, wait);\n\t\t\tif (n->m_next == NULL) {\n\t\t\t\t(void) m_free(n);\n\t\t\t\tm0->m_pkthdr.len = olen;\n\t\t\t\treturn (NULL);\n\t\t\t} else {\n\t\t\t\tn->m_len = 0;\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t}\n\t} else if (remain == 0) {\n\t\tn = m->m_next;\n\t\tm->m_next = NULL;\n\t\treturn (n);\n\t} else {\n\t\tMGET(n, wait, m->m_type);\n\t\tif (n == NULL)\n\t\t\treturn (NULL);\n\t}\n\tif (m->m_flags & M_EXT) {\n\t\tn->m_ext = m->m_ext;\n\t\tMCLADDREFERENCE(m, n);\n\t\tn->m_data = m->m_data + len;\n\t} else {\n\t\tm_align(n, remain);\n\t\tmemcpy(mtod(n, caddr_t), mtod(m, caddr_t) + len, remain);\n\t}\n\tn->m_len = remain;\n\tm->m_len = len;\n\tn->m_next = m->m_next;\n\tm->m_next = NULL;\n\treturn (n);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tdo {\n\t\t\t\tspl_filesystem_dir_read(intern TSRMLS_CC);\n\t\t\t} while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n\t\t}\n\t\tintern->u.dir.index = index;\n\t\tbreak;\n\tcase SPL_FS_FILE:\n\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"An object of class %s cannot be cloned\", old_object->ce->name);\n\t\tbreak;\n\t}\n\t\n\tintern->file_class = source->file_class;\n\tintern->info_class = source->info_class;\n\tintern->oth = source->oth;\n\tintern->oth_handler = source->oth_handler;\n\n\tzend_objects_clone_members(new_object, new_obj_val, old_object, handle TSRMLS_CC);\n\n\tif (intern->oth_handler && intern->oth_handler->clone) {\n\t\tintern->oth_handler->clone(source, intern TSRMLS_CC);\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tdo {\n\t\t\t\tspl_filesystem_dir_read(intern TSRMLS_CC);\n\t\t\t} while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n\t\t}\n\t\tintern->u.dir.index = index;\n\t\tbreak;\n\tcase SPL_FS_FILE:\n\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"An object of class %s cannot be cloned\", old_object->ce->name);\n\t\tbreak;\n\t}\n\n\tintern->file_class = source->file_class;\n\tintern->info_class = source->info_class;\n\tintern->oth = source->oth;\n\tintern->oth_handler = source->oth_handler;\n\n\tzend_objects_clone_members(new_object, new_obj_val, old_object, handle TSRMLS_CC);\n\n\tif (intern->oth_handler && intern->oth_handler->clone) {\n\t\tintern->oth_handler->clone(source, intern TSRMLS_CC);\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, ",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, ",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int sendMessageAndForget(short ptype, short paylen, const void* payload) {\n    int ret;\n\n    // Unlike regular sockets, ENet sockets aren't safe to invoke from multiple\n    // threads at once. We have to synchronize them with a lock.\n    if (ServerMajorVersion >= 5) {\n        PltLockMutex(&enetMutex);\n        ret = sendMessageEnet(ptype, paylen, payload);\n        PltUnlockMutex(&enetMutex);\n    }\n    else {\n        ret = sendMessageTcp(ptype, paylen, payload);\n    }\n\n    return ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int sendMessageAndForget(short ptype, short paylen, const void* payload) {\n    int ret;\n\n    // Unlike regular sockets, ENet sockets aren't safe to invoke from multiple\n    // threads at once. We have to synchronize them with a lock.\n    if (AppVersionQuad[0] >= 5) {\n        PltLockMutex(&enetMutex);\n        ret = sendMessageEnet(ptype, paylen, payload);\n        PltUnlockMutex(&enetMutex);\n    }\n    else {\n        ret = sendMessageTcp(ptype, paylen, payload);\n    }\n\n    return ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tstruct crypto_alg *alg;\n\n\tif (!name)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tmask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);\n\ttype &= mask;\n\n\talg = crypto_alg_lookup(name, type, mask);\n\tif (!alg) {\n\t\trequest_module(\"%s\", name);\n\n\t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n\t\t      CRYPTO_ALG_NEED_FALLBACK))\n\t\t\trequest_module(\"%s-all\", name);\n\n\t\talg = crypto_alg_lookup(name, type, mask);\n\t}\n\n\tif (alg)\n\t\treturn crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;\n\n\treturn crypto_larval_add(name, type, mask);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tstruct crypto_alg *alg;\n\n\tif (!name)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tmask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);\n\ttype &= mask;\n\n\talg = crypto_alg_lookup(name, type, mask);\n\tif (!alg) {\n\t\trequest_module(\"crypto-%s\", name);\n\n\t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n\t\t      CRYPTO_ALG_NEED_FALLBACK))\n\t\t\trequest_module(\"crypto-%s-all\", name);\n\n\t\talg = crypto_alg_lookup(name, type, mask);\n\t}\n\n\tif (alg)\n\t\treturn crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;\n\n\treturn crypto_larval_add(name, type, mask);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info;\n\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\treturn do_send_specific(tgid, pid, sig, &info);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info = {};\n\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\treturn do_send_specific(tgid, pid, sig, &info);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "chpass_principal3_2_svc(chpass3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_chpass_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "chpass_principal3_2_svc(chpass3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_chpass_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ngx_http_lua_copy_request_headers(ngx_http_request_t *sr, ngx_http_request_t *r)\n{\n    ngx_table_elt_t                 *header;\n    ngx_list_part_t                 *part;\n    ngx_uint_t                       i;\n\n    if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    dd(\"before: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n\n    part = &r->headers_in.headers.part;\n    header = part->elts;\n\n    for (i = 0; /* void */; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        dd(\"setting request header %.*s: %.*s\", (int) header[i].key.len,\n           header[i].key.data, (int) header[i].value.len,\n           header[i].value.data);\n\n        if (ngx_http_lua_set_input_header(sr, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    dd(\"after: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n\n    return NGX_OK;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ngx_http_lua_copy_request_headers(ngx_http_request_t *sr,\n    ngx_http_request_t *pr, int pr_not_chunked)\n{\n    ngx_table_elt_t                 *clh, *header;\n    ngx_list_part_t                 *part;\n    ngx_uint_t                       i;\n    u_char                          *p;\n    off_t                            len;\n\n    dd(\"before: parent req headers count: %d\",\n       (int) pr->headers_in.headers.part.nelts);\n\n    if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    if (sr->request_body && !pr_not_chunked) {\n\n        /* craft our own Content-Length */\n\n        len = sr->request_body->buf ? ngx_buf_size(sr->request_body->buf) : 0;\n\n        clh = ngx_list_push(&sr->headers_in.headers);\n        if (clh == NULL) {\n            return NGX_ERROR;\n        }\n\n        clh->hash = ngx_http_lua_content_length_hash;\n        clh->key = ngx_http_lua_content_length_header_key;\n        clh->lowcase_key = ngx_pnalloc(sr->pool, clh->key.len);\n        if (clh->lowcase_key == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_strlow(clh->lowcase_key, clh->key.data, clh->key.len);\n\n        p = ngx_palloc(sr->pool, NGX_OFF_T_LEN);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        clh->value.data = p;\n        clh->value.len = ngx_sprintf(clh->value.data, \"%O\", len)\n                         - clh->value.data;\n\n        sr->headers_in.content_length = clh;\n        sr->headers_in.content_length_n = len;\n\n        dd(\"sr crafted content-length: %.*s\",\n           (int) sr->headers_in.content_length->value.len,\n           sr->headers_in.content_length->value.data);\n    }\n\n    /* copy the parent request's headers */\n\n    part = &pr->headers_in.headers.part;\n    header = part->elts;\n\n    for (i = 0; /* void */; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        if (!pr_not_chunked && header[i].key.len == sizeof(\"Content-Length\") - 1\n            && ngx_strncasecmp(header[i].key.data, (u_char *) \"Content-Length\",\n                               sizeof(\"Content-Length\") - 1) == 0)\n        {\n            continue;\n        }\n\n        dd(\"sr copied req header %.*s: %.*s\", (int) header[i].key.len,\n           header[i].key.data, (int) header[i].value.len,\n           header[i].value.data);\n\n        if (ngx_http_lua_set_input_header(sr, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    dd(\"after: parent req headers count: %d\",\n       (int) pr->headers_in.headers.part.nelts);\n\n    return NGX_OK;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void fp2_write_bin(uint8_t *bin, int len, const fp2_t a, int pack) {\n\tfp2_t t;\n\n\tfp2_null(t);\n\n\tRLC_TRY {\n\t\tfp2_new(t);\n\n\t\tif (pack && fp2_test_cyc(a)) {\n\t\t\tif (len < RLC_FP_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void fp2_write_bin(uint8_t *bin, size_t len, const fp2_t a, int pack) {\n\tfp2_t t;\n\n\tfp2_null(t);\n\n\tRLC_TRY {\n\t\tfp2_new(t);\n\n\t\tif (pack && fp2_test_cyc(a)) {\n\t\t\tif (len < RLC_FP_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)\n{\n  SV* sv;\n  HV* hv;\n  char* dbname;\n  char* host;\n  char* port;\n  char* user;\n  char* password;\n  char* mysql_socket;\n  int   result;\n  D_imp_xxh(dbh);\n\n  /* TODO- resolve this so that it is set only if DBI is 1.607 */\n#define TAKE_IMP_DATA_VERSION 1\n#if TAKE_IMP_DATA_VERSION\n  if (DBIc_has(imp_dbh, DBIcf_IMPSET))\n  { /* eg from take_imp_data() */\n    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,\" \\\n\t\t  \"host = %s, port = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\",\n\t\t  host ? host : \"NULL\",\n\t\t  port ? port : \"NULL\");\n\n  if (!imp_dbh->pmysql) {\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\n  }\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\n  if (!result)\n      Safefree(imp_dbh->pmysql);\n  return result;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n  SV* sv;\n  HV* hv;\n  char* dbname;\n  char* host;\n  char* port;\n  char* user;\n  char* password;\n  char* mysql_socket;\n  int   result;\n  int\tfresh = 0;\n  D_imp_xxh(dbh);\n\n  /* TODO- resolve this so that it is set only if DBI is 1.607 */\n#define TAKE_IMP_DATA_VERSION 1\n#if TAKE_IMP_DATA_VERSION\n  if (DBIc_has(imp_dbh, DBIcf_IMPSET))\n  { /* eg from take_imp_data() */\n    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,\" \\\n\t\t  \"host = %s, port = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\",\n\t\t  host ? host : \"NULL\",\n\t\t  port ? port : \"NULL\");\n\n  if (!imp_dbh->pmysql) {\n     fresh = 1;\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\n  }\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\n  if (fresh && !result) {\n      /* Prevent leaks, but do not free in case of a reconnect. See #97625 */\n      do_error(dbh, mysql_errno(imp_dbh->pmysql),\n              mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n      Safefree(imp_dbh->pmysql);\n      imp_dbh->pmysql = NULL;\n  }\n  return result;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (a->getType() == IAction::Move) {\n\t\tIMoveAction *ma = (IMoveAction*)a;\n\n\t\tma->from_inv.applyCurrentPlayer(player->getName());\n\t\tma->to_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ma->from_inv);\n\t\tif (ma->from_inv != ma->to_inv)\n\t\t\tm_inventory_mgr->setInventoryModified(ma->to_inv);\n\n\t\tbool from_inv_is_current_player =\n\t\t\t(ma->from_inv.type == InventoryLocation::PLAYER) &&\n\t\t\t(ma->from_inv.name == player->getName());\n\n\t\tbool to_inv_is_current_player =\n\t\t\t(ma->to_inv.type == InventoryLocation::PLAYER) &&\n\t\t\t(ma->to_inv.name == player->getName());\n\n\t\tInventoryLocation *remote = from_inv_is_current_player ?\n\t\t\t&ma->to_inv : &ma->from_inv;\n\n\t\t// Check for out-of-range interaction\n\t\tif (remote->type == InventoryLocation::NODEMETA) {\n\t\t\tv3f node_pos   = intToFloat(remote->p, BS);\n\t\t\tv3f player_pos = player->getPlayerSAO()->getEyePosition();\n\t\t\tf32 d = player_pos.getDistanceFrom(node_pos);\n\t\t\tif (!checkInteractDistance(player, d, \"inventory\"))",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (a->getType() == IAction::Move) {\n\t\tIMoveAction *ma = (IMoveAction*)a;\n\n\t\tma->from_inv.applyCurrentPlayer(player->getName());\n\t\tma->to_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ma->from_inv);\n\t\tif (ma->from_inv != ma->to_inv)\n\t\t\tm_inventory_mgr->setInventoryModified(ma->to_inv);\n\n\t\tbool from_inv_is_current_player = false;\n\t\tif (ma->from_inv.type == InventoryLocation::PLAYER) {\n\t\t\tif (ma->from_inv.name != player->getName())\n\t\t\t\treturn;\n\t\t\tfrom_inv_is_current_player = true;\n\t\t}\n\t\t\n\t\tbool to_inv_is_current_player = false;\n\t\tif (ma->to_inv.type == InventoryLocation::PLAYER) {\n\t\t\tif (ma->to_inv.name != player->getName())\n\t\t\t\treturn;\n\t\t\tto_inv_is_current_player = true;\n\t\t}\n\n\t\tInventoryLocation *remote = from_inv_is_current_player ?\n\t\t\t&ma->to_inv : &ma->from_inv;\n\n\t\t// Check for out-of-range interaction\n\t\tif (remote->type == InventoryLocation::NODEMETA) {\n\t\t\tv3f node_pos   = intToFloat(remote->p, BS);\n\t\t\tv3f player_pos = player->getPlayerSAO()->getEyePosition();\n\t\t\tf32 d = player_pos.getDistanceFrom(node_pos);\n\t\t\tif (!checkInteractDistance(player, d, \"inventory\"))",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  idata->cmddata = NULL;\n  /* noselect is for a gmail quirk (#3445) */\n  if (!list.name || list.noselect)\n    return;\n\n  mutt_debug(3, \"Subscribing to %s\\n\", list.name);\n\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  /* escape \\ and \" */\n  imap_quote_string(errstr, sizeof(errstr), list.name);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \"\\\"\");\n  mutt_buffer_init(&token);\n  mutt_buffer_init(&err);\n  err.data = errstr;\n  err.dsize = sizeof(errstr);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  idata->cmddata = NULL;\n  /* noselect is for a gmail quirk (#3445) */\n  if (!list.name || list.noselect)\n    return;\n\n  mutt_debug(3, \"Subscribing to %s\\n\", list.name);\n\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  /* escape \\ and \" */\n  imap_quote_string(errstr, sizeof(errstr), list.name, true);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \"\\\"\");\n  mutt_buffer_init(&token);\n  mutt_buffer_init(&err);\n  err.data = errstr;\n  err.dsize = sizeof(errstr);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "construct_command_line(struct manager_ctx *manager, struct server *server)\n{\n    static char cmd[BUF_SIZE];\n    char *method = manager->method;\n    int i;\n\n    build_config(working_dir, server);\n\n    if (server->method) method = server->method;\n    memset(cmd, 0, BUF_SIZE);\n    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n\n    if (manager->acl != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n    }\n    if (manager->timeout != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n    }\n#ifdef HAVE_SETRLIMIT",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "construct_command_line(struct manager_ctx *manager, struct server *server)\n{\n    static char cmd[BUF_SIZE];\n    int i;\n    int port;\n\n    port = atoi(server->port);\n\n    build_config(working_dir, manager, server);\n\n    memset(cmd, 0, BUF_SIZE);\n    snprintf(cmd, BUF_SIZE,\n             \"%s --manager-address %s -f %s/.shadowsocks_%d.pid -c %s/.shadowsocks_%d.conf\",\n             executable, manager->manager_address, working_dir, port, working_dir, port);\n\n    if (manager->acl != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n    }\n    if (manager->timeout != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n    }\n#ifdef HAVE_SETRLIMIT",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "         //Compute CRC over the current MAC address\n         crc = ksz8851CalcCrc(&entry->addr, sizeof(MacAddr));\n         //Calculate the corresponding index in the table\n         k = (crc >> 26) & 0x3F;\n         //Update hash table contents\n         hashTable[k / 16] |= (1 << (k % 16));\n      }\n   }\n\n   //Write the hash table to the KSZ8851 controller\n   ksz8851WriteReg(interface, KSZ8851_REG_MAHTR0, hashTable[0]);\n   ksz8851WriteReg(interface, KSZ8851_REG_MAHTR1, hashTable[1]);\n   ksz8851WriteReg(interface, KSZ8851_REG_MAHTR2, hashTable[2]);\n   ksz8851WriteReg(interface, KSZ8851_REG_MAHTR3, hashTable[3]);\n\n   //Debug message\n   TRACE_DEBUG(\"  MAHTR0 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_REG_MAHTR0));\n   TRACE_DEBUG(\"  MAHTR1 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_REG_MAHTR1));\n   TRACE_DEBUG(\"  MAHTR2 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_REG_MAHTR2));\n   TRACE_DEBUG(\"  MAHTR3 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_REG_MAHTR3));\n\n   //Successful processing\n   return NO_ERROR;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "         //Compute CRC over the current MAC address\n         crc = ksz8851CalcCrc(&entry->addr, sizeof(MacAddr));\n         //Calculate the corresponding index in the table\n         k = (crc >> 26) & 0x3F;\n         //Update hash table contents\n         hashTable[k / 16] |= (1 << (k % 16));\n      }\n   }\n\n   //Write the hash table to the KSZ8851 controller\n   ksz8851WriteReg(interface, KSZ8851_MAHTR0, hashTable[0]);\n   ksz8851WriteReg(interface, KSZ8851_MAHTR1, hashTable[1]);\n   ksz8851WriteReg(interface, KSZ8851_MAHTR2, hashTable[2]);\n   ksz8851WriteReg(interface, KSZ8851_MAHTR3, hashTable[3]);\n\n   //Debug message\n   TRACE_DEBUG(\"  MAHTR0 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_MAHTR0));\n   TRACE_DEBUG(\"  MAHTR1 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_MAHTR1));\n   TRACE_DEBUG(\"  MAHTR2 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_MAHTR2));\n   TRACE_DEBUG(\"  MAHTR3 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_MAHTR3));\n\n   //Successful processing\n   return NO_ERROR;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n\n\tif (is_guest_mode(vcpu))\n\t\tmsr_bitmap = vmx_msr_bitmap_nested;\n\telse if (vcpu->arch.apic_base & X2APIC_ENABLE) {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n\n\tif (is_guest_mode(vcpu))\n\t\tmsr_bitmap = vmx_msr_bitmap_nested;\n\telse if (cpu_has_secondary_exec_ctrls() &&\n\t\t (vmcs_read32(SECONDARY_VM_EXEC_CONTROL) &\n\t\t  SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE)) {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "checked_xmalloc (size_t size)\n{\n    alloc_limit_assert (\"checked_xmalloc\", size);\n    return xmalloc (size);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "checked_xmalloc (size_t num, size_t size)\n{\n    size_t res;\n    if (check_mul_overflow(num, size, &res))\n        abort();\n\n    alloc_limit_assert (\"checked_xmalloc\", res);\n    return xmalloc (num, size);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t value;\n\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, &value, 1, 1000);\n\treturn ret >= 0 ? value : ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t *buffer;\n\tuint8_t value;\n\n\tbuffer = kmalloc(1, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, buffer, 1, 1000);\n\n\tif (ret >= 0) {\n\t\tvalue = buffer[0];\n\t\tkfree(buffer);\n\t\treturn value;\n\t} else {\n\t\tkfree(buffer);\n\t\treturn ret;\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                                 std::string &boundary) {\n  if (req.ranges.size() > 1) {\n    boundary = detail::make_multipart_data_boundary();\n\n    auto it = res.headers.find(\"Content-Type\");\n    if (it != res.headers.end()) {\n      content_type = it->second;\n      res.headers.erase(it);\n    }\n\n    res.headers.emplace(\"Content-Type\",\n                        \"multipart/byteranges; boundary=\" + boundary);\n  }\n\n  auto type = detail::encoding_type(req, res);\n\n  if (res.body.empty()) {\n    if (res.content_length_ > 0) {\n      size_t length = 0;\n      if (req.ranges.empty()) {\n        length = res.content_length_;\n      } else if (req.ranges.size() == 1) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                                 std::string &boundary) {\n  if (req.ranges.size() > 1) {\n    boundary = detail::make_multipart_data_boundary();\n\n    auto it = res.headers.find(\"Content-Type\");\n    if (it != res.headers.end()) {\n      content_type = it->second;\n      res.headers.erase(it);\n    }\n\n    res.set_header(\"Content-Type\",\n                   \"multipart/byteranges; boundary=\" + boundary);\n  }\n\n  auto type = detail::encoding_type(req, res);\n\n  if (res.body.empty()) {\n    if (res.content_length_ > 0) {\n      size_t length = 0;\n      if (req.ranges.empty()) {\n        length = res.content_length_;\n      } else if (req.ranges.size() == 1) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    // and checking return code means an explicit GetLastError() comparison.  Instead\n    // rely on subsequent WinHttpQueryHeaders() to fail.\n    WinHttpQueryHeaders(\n        requestHandle,\n        WINHTTP_QUERY_RAW_HEADERS_CRLF,\n        WINHTTP_HEADER_NAME_BY_INDEX,\n        WINHTTP_NO_OUTPUT_BUFFER,\n        &responseHeadersTempLength,\n        WINHTTP_NO_HEADER_INDEX);\n\n    if ((responseHeadersTemp = (wchar_t*)malloc((size_t)responseHeadersTempLength + 2)) == NULL)\n    {\n        result = HTTPAPI_ALLOC_FAILED;\n        LogError(\"malloc failed: (result = %\" PRI_MU_ENUM \")\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n    }\n    else if (! WinHttpQueryHeaders(\n            requestHandle,\n            WINHTTP_QUERY_RAW_HEADERS_CRLF,\n            WINHTTP_HEADER_NAME_BY_INDEX,\n            responseHeadersTemp,\n            &responseHeadersTempLength,\n        {\n            size_t tokenTemp_size;\n\n            tokenTemp_size = WideCharToMultiByte(CP_ACP, 0, token, -1, NULL, 0, NULL, NULL);\n            if (tokenTemp_size == 0)\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"WideCharToMultiByte failed\");\n                break;\n            }\n            else if ((tokenTemp = (char*)malloc(sizeof(char) * tokenTemp_size)) == NULL)\n            {\n                result = HTTPAPI_ALLOC_FAILED;\n                LogError(\"malloc failed\");\n                break;\n            }\n            else if (WideCharToMultiByte(CP_ACP, 0, token, -1, tokenTemp, (int)tokenTemp_size, NULL, NULL) == 0)\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"WideCharToMultiByte failed\");\n                break;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    // and checking return code means an explicit GetLastError() comparison.  Instead\n    // rely on subsequent WinHttpQueryHeaders() to fail.\n    WinHttpQueryHeaders(\n        requestHandle,\n        WINHTTP_QUERY_RAW_HEADERS_CRLF,\n        WINHTTP_HEADER_NAME_BY_INDEX,\n        WINHTTP_NO_OUTPUT_BUFFER,\n        &responseHeadersTempLength,\n        WINHTTP_NO_HEADER_INDEX);\n\n    size_t malloc_size = safe_add_size_t((size_t)responseHeadersTempLength, 2);\n    if (malloc_size == SIZE_MAX)\n    {\n        LogError(\"Invalid malloc size\");\n        responseHeadersTemp = NULL;\n    }\n    else\n    {\n        responseHeadersTemp = (wchar_t*)malloc(malloc_size);\n    }\n\n    if (responseHeadersTemp == NULL)\n    {\n        result = HTTPAPI_ALLOC_FAILED;\n        LogError(\"malloc failed: (result = %\" PRI_MU_ENUM \")\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n    }\n    else if (! WinHttpQueryHeaders(\n            requestHandle,\n            WINHTTP_QUERY_RAW_HEADERS_CRLF,\n            WINHTTP_HEADER_NAME_BY_INDEX,\n            responseHeadersTemp,\n            &responseHeadersTempLength,\n        {\n            size_t tokenTemp_size;\n\n            tokenTemp_size = WideCharToMultiByte(CP_ACP, 0, token, -1, NULL, 0, NULL, NULL);\n            if (tokenTemp_size == 0)\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"WideCharToMultiByte failed\");\n                break;\n            }\n            else if ((malloc_size = safe_multiply_size_t(sizeof(char), tokenTemp_size)) == SIZE_MAX)\n            {\n                result = HTTPAPI_ALLOC_FAILED;\n                LogError(\"invalid malloc size\");\n                break;\n            }\n            else if ((tokenTemp = (char*)malloc(malloc_size)) == NULL)\n            {\n                result = HTTPAPI_ALLOC_FAILED;\n                LogError(\"malloc failed\");\n                break;\n            }\n            else if (WideCharToMultiByte(CP_ACP, 0, token, -1, tokenTemp, (int)tokenTemp_size, NULL, NULL) == 0)\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"WideCharToMultiByte failed\");\n                break;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    } else {\n        direct = 0;\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n\n    for (p = 0; p < 4 && in->data[p]; p++) {\n        int w = inlink->w;\n        int h = inlink->h;\n        int r = s->radius;\n        if (p) {\n            w = s->chroma_w;\n            h = s->chroma_h;\n            r = s->chroma_r;\n        }\n\n        if (FFMIN(w, h) > 2 * r)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    } else {\n        direct = 0;\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n\n    for (p = 0; p < 4 && in->data[p] && in->linesize[p]; p++) {\n        int w = inlink->w;\n        int h = inlink->h;\n        int r = s->radius;\n        if (p) {\n            w = s->chroma_w;\n            h = s->chroma_h;\n            r = s->chroma_r;\n        }\n\n        if (FFMIN(w, h) > 2 * r)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    if (ret) {\n        L_ERROR(\"output directory %s not made\\n\", procName, dirout);\n        return 1;\n    }\n\n        /* Capture the filenames in the input directory */\n    if ((safiles = getFilenamesInDirectory(dirin)) == NULL)\n        return ERROR_INT(\"safiles not made\", procName, 1);\n\n        /* Generate output text file names */\n    sprintf(charbuf, \"%s/%s.html\", dirout, rootname);\n    mainname = stringNew(charbuf);\n    sprintf(charbuf, \"%s/%s-links.html\", dirout, rootname);\n    linkname = stringNew(charbuf);\n    linknameshort = stringJoin(rootname, \"-links.html\");\n\n        /* Generate the thumbs and views */\n    sathumbs = sarrayCreate(0);\n    saviews = sarrayCreate(0);\n    nfiles = sarrayGetCount(safiles);\n    index = 0;\n    for (i = 0; i < nfiles; i++) {\n        fname = sarrayGetString(safiles, i, L_NOCOPY);\n            fprintf(stderr, \"file %s not a readable image\\n\", fullname);\n            lept_free(fullname);\n            continue;\n        }\n        lept_free(fullname);\n\n            /* Make and store the thumbnail images */\n        pixGetDimensions(pix, &w, NULL, &d);\n        factor = (l_float32)thumbwidth / (l_float32)w;\n        pixthumb = pixScale(pix, factor, factor);\n        sprintf(charbuf, \"%s_thumb_%03d\", rootname, index);\n        sarrayAddString(sathumbs, charbuf, L_COPY);\n        outname = genPathname(dirout, charbuf);\n        WriteFormattedPix(outname, pixthumb);\n        lept_free(outname);\n        pixDestroy(&pixthumb);\n\n            /* Make and store the view images */\n        factor = (l_float32)viewwidth / (l_float32)w;\n        if (factor >= 1.0)\n            pixview = pixClone(pix);   /* no upscaling */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    if (ret) {\n        L_ERROR(\"output directory %s not made\\n\", procName, dirout);\n        return 1;\n    }\n\n        /* Capture the filenames in the input directory */\n    if ((safiles = getFilenamesInDirectory(dirin)) == NULL)\n        return ERROR_INT(\"safiles not made\", procName, 1);\n\n        /* Generate output text file names */\n    snprintf(charbuf, sizeof(charbuf), \"%s/%s.html\", dirout, rootname);\n    mainname = stringNew(charbuf);\n    snprintf(charbuf, sizeof(charbuf), \"%s/%s-links.html\", dirout, rootname);\n    linkname = stringNew(charbuf);\n    linknameshort = stringJoin(rootname, \"-links.html\");\n\n        /* Generate the thumbs and views */\n    sathumbs = sarrayCreate(0);\n    saviews = sarrayCreate(0);\n    nfiles = sarrayGetCount(safiles);\n    index = 0;\n    for (i = 0; i < nfiles; i++) {\n        fname = sarrayGetString(safiles, i, L_NOCOPY);\n            fprintf(stderr, \"file %s not a readable image\\n\", fullname);\n            lept_free(fullname);\n            continue;\n        }\n        lept_free(fullname);\n\n            /* Make and store the thumbnail images */\n        pixGetDimensions(pix, &w, NULL, &d);\n        factor = (l_float32)thumbwidth / (l_float32)w;\n        pixthumb = pixScale(pix, factor, factor);\n        snprintf(charbuf, sizeof(charbuf), \"%s_thumb_%03d\", rootname, index);\n        sarrayAddString(sathumbs, charbuf, L_COPY);\n        outname = genPathname(dirout, charbuf);\n        WriteFormattedPix(outname, pixthumb);\n        lept_free(outname);\n        pixDestroy(&pixthumb);\n\n            /* Make and store the view images */\n        factor = (l_float32)viewwidth / (l_float32)w;\n        if (factor >= 1.0)\n            pixview = pixClone(pix);   /* no upscaling */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "AllocateCudnnConvolutionBackwardDataWorkspace(\n    Stream* stream, const CudnnHandle& cudnn,\n    const CudnnTensorDescriptor& input_nd, const CudnnFilterDescriptor& filter,\n    const CudnnConvolutionDescriptor& conv,\n    const CudnnTensorDescriptor& output_nd,\n    const dnn::AlgorithmDesc& algorithm_desc,\n    ScratchAllocator* scratch_allocator) {\n  if (IsTensorMathOpSet(conv) != algorithm_desc.tensor_ops_enabled()) {\n    return tsl::Status(\n        port::error::INTERNAL,\n        \"Mismatch between cudnn conv and algorithm descriptors.\");\n  }\n\n  // Query the size of the workspace and allocate it.\n  size_t size_in_bytes;\n  if (algorithm_desc.workspace_size()) {\n    size_in_bytes = *algorithm_desc.workspace_size();\n  } else {\n    RETURN_IF_CUDNN_ERROR(cudnnGetConvolutionBackwardDataWorkspaceSize(\n        cudnn.handle(),\n        /*convDesc=*/conv.handle(),\n        /*dxDesc=*/input_nd.handle(),\n        /*algo=*/ToConvBackwardDataAlgo(algorithm_desc),\n        /*sizeInBytes=*/&size_in_bytes));\n  }\n\n  int64_t size_in_bytes_int64_t = size_in_bytes;\n\n  if (ABSL_PREDICT_FALSE(size_in_bytes_int64_t < 0)) {\n    return tsl::Status(\n        port::error::INTERNAL,\n        \"cudnnGetConvolutionBackwardDataWorkspaceSize() returned \"\n        \"negative sizeInBytes value. This could be a cudnn bug.\");\n  }\n\n  if (size_in_bytes_int64_t == 0) {\n    return DeviceMemory<uint8_t>();\n  }\n\n  if (ABSL_PREDICT_FALSE(!scratch_allocator)) {\n    return tsl::Status(port::error::INVALID_ARGUMENT,\n                       \"No scratch allocator provided\");\n  }\n\n  return scratch_allocator->AllocateBytes(size_in_bytes);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "AllocateCudnnConvolutionBackwardDataWorkspace(\n    Stream* stream, const CudnnHandle& cudnn,\n    const CudnnTensorDescriptor& input_nd, const CudnnFilterDescriptor& filter,\n    const CudnnConvolutionDescriptor& conv,\n    const CudnnTensorDescriptor& output_nd,\n    const dnn::AlgorithmDesc& algorithm_desc,\n    ScratchAllocator* scratch_allocator) {\n  if (IsTensorMathOpSet(conv) != algorithm_desc.tensor_ops_enabled()) {\n    return tsl::Status(\n        tsl::error::INTERNAL,\n        \"Mismatch between cudnn conv and algorithm descriptors.\");\n  }\n\n  // Query the size of the workspace and allocate it.\n  size_t size_in_bytes;\n  if (algorithm_desc.workspace_size()) {\n    size_in_bytes = *algorithm_desc.workspace_size();\n  } else {\n    RETURN_IF_CUDNN_ERROR(cudnnGetConvolutionBackwardDataWorkspaceSize(\n        cudnn.handle(),\n        /*convDesc=*/conv.handle(),\n        /*dxDesc=*/input_nd.handle(),\n        /*algo=*/ToConvBackwardDataAlgo(algorithm_desc),\n        /*sizeInBytes=*/&size_in_bytes));\n  }\n\n  int64_t size_in_bytes_int64_t = size_in_bytes;\n\n  if (ABSL_PREDICT_FALSE(size_in_bytes_int64_t < 0)) {\n    return tsl::Status(\n        tsl::error::INTERNAL,\n        \"cudnnGetConvolutionBackwardDataWorkspaceSize() returned \"\n        \"negative sizeInBytes value. This could be a cudnn bug.\");\n  }\n\n  if (size_in_bytes_int64_t == 0) {\n    return DeviceMemory<uint8_t>();\n  }\n\n  if (ABSL_PREDICT_FALSE(!scratch_allocator)) {\n    return tsl::Status(tsl::error::INVALID_ARGUMENT,\n                       \"No scratch allocator provided\");\n  }\n\n  return scratch_allocator->AllocateBytes(size_in_bytes);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "rs_filter_graph(RSFilter *filter)\n{\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\tGString *str = g_string_new(\"digraph G {\\n\");\n\n\trs_filter_graph_helper(str, filter);\n\n\tg_string_append_printf(str, \"}\\n\");\n\tg_file_set_contents(\"/tmp/rs-filter-graph\", str->str, str->len, NULL);\n\n\tif (0 != system(\"dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\"))\n\t\tg_warning(\"Calling dot failed\");\n\tif (0 != system(\"gnome-open /tmp/rs-filter-graph.png\"))\n\t\tg_warning(\"Calling gnome-open failed.\");\n\n\tg_string_free(str, TRUE);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "rs_filter_graph(RSFilter *filter)\n{\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\tgchar *dot_filename;\n\tgchar *png_filename;\n\tgchar *command_line;\n\tGString *str = g_string_new(\"digraph G {\\n\");\n\n\trs_filter_graph_helper(str, filter);\n\n\tg_string_append_printf(str, \"}\\n\");\n\n\t/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */\n\tdot_filename = g_strdup_printf(\"/tmp/rs-filter-graph.%u\", g_random_int());\n\tpng_filename = g_strdup_printf(\"%s.%u.png\", dot_filename, g_random_int());\n\n\tg_file_set_contents(dot_filename, str->str, str->len, NULL);\n\n\tcommand_line = g_strdup_printf(\"dot -Tpng >%s <%s\", png_filename, dot_filename);\n\tif (0 != system(command_line))\n\t\tg_warning(\"Calling dot failed\");\n\tg_free(command_line);\n\n\tcommand_line = g_strdup_printf(\"gnome-open %s\", png_filename);\n\tif (0 != system(command_line))\n\t\tg_warning(\"Calling gnome-open failed.\");\n\tg_free(command_line);\n\n\tg_free(dot_filename);\n\tg_free(png_filename);\n\tg_string_free(str, TRUE);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void HeaderMapImpl::insertByKey(HeaderString&& key, HeaderString&& value) {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.getStringView());\n  if (cb) {\n    key.clear();\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    if (*ref_lookup_response.entry_ == nullptr) {\n      maybeCreateInline(ref_lookup_response.entry_, *ref_lookup_response.key_, std::move(value));\n    } else {\n      appendToHeader((*ref_lookup_response.entry_)->value(), value.getStringView());\n      value.clear();\n    }\n  } else {\n    std::list<HeaderEntryImpl>::iterator i = headers_.insert(std::move(key), std::move(value));\n    i->entry_ = i;\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void HeaderMapImpl::insertByKey(HeaderString&& key, HeaderString&& value) {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.getStringView());\n  if (cb) {\n    key.clear();\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    if (*ref_lookup_response.entry_ == nullptr) {\n      maybeCreateInline(ref_lookup_response.entry_, *ref_lookup_response.key_, std::move(value));\n    } else {\n      const uint64_t added_size =\n          appendToHeader((*ref_lookup_response.entry_)->value(), value.getStringView());\n      addSize(added_size);\n      value.clear();\n    }\n  } else {\n    addSize(key.size() + value.size());\n    std::list<HeaderEntryImpl>::iterator i = headers_.insert(std::move(key), std::move(value));\n    i->entry_ = i;\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  STI = &Fn.getSubtarget<ARMSubtarget>();\n  TL = STI->getTargetLowering();\n  AFI = Fn.getInfo<ARMFunctionInfo>();\n  TII = STI->getInstrInfo();\n  TRI = STI->getRegisterInfo();\n\n  RegClassInfoValid = false;\n  isThumb2 = AFI->isThumb2Function();\n  isThumb1 = AFI->isThumbFunction() && !isThumb2;\n\n  bool Modified = false;\n  for (MachineBasicBlock &MBB : Fn) {\n    Modified |= LoadStoreMultipleOpti(MBB);\n    if (STI->hasV5TOps() && !AFI->shouldSignReturnAddress())\n      Modified |= MergeReturnIntoLDM(MBB);\n    if (isThumb1)\n      Modified |= CombineMovBx(MBB);\n  }\n\n  Allocator.DestroyAll();\n  return Modified;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  STI = &Fn.getSubtarget<ARMSubtarget>();\n  TL = STI->getTargetLowering();\n  AFI = Fn.getInfo<ARMFunctionInfo>();\n  TII = STI->getInstrInfo();\n  TRI = STI->getRegisterInfo();\n\n  RegClassInfoValid = false;\n  isThumb2 = AFI->isThumb2Function();\n  isThumb1 = AFI->isThumbFunction() && !isThumb2;\n\n  bool Modified = false, ModifiedLDMReturn = false;\n  for (MachineBasicBlock &MBB : Fn) {\n    Modified |= LoadStoreMultipleOpti(MBB);\n    if (STI->hasV5TOps() && !AFI->shouldSignReturnAddress())\n      ModifiedLDMReturn |= MergeReturnIntoLDM(MBB);\n    if (isThumb1)\n      Modified |= CombineMovBx(MBB);\n  }\n  Modified |= ModifiedLDMReturn;\n\n  // If we merged a BX instruction into an LDM, we need to re-calculate whether\n  // LR is restored. This check needs to consider the whole function, not just\n  // the instruction(s) we changed, because there may be other BX returns which\n  // still need LR to be restored.\n  if (ModifiedLDMReturn)\n    ARMFrameLowering::updateLRRestored(Fn);\n\n  Allocator.DestroyAll();\n  return Modified;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )\":mongo:\", 7 );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, strlen( pass ) );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, ( int )strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )\":mongo:\", 7 );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, ( int )strlen( pass ) );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  void *uidl;\n  char buf[LONG_STRING];\n  char path[_POSIX_PATH_MAX];\n  progress_t progressbar;\n  POP_DATA *pop_data = (POP_DATA *)ctx->data;\n  POP_CACHE *cache;\n  HEADER *h = ctx->hdrs[msgno];\n  unsigned short bcache = 1;\n\n  /* see if we already have the message in body cache */\n  if ((msg->fp = mutt_bcache_get (pop_data->bcache, h->data)))\n    return 0;\n\n  /*\n   * see if we already have the message in our cache in\n   * case $message_cachedir is unset\n   */\n  cache = &pop_data->cache[h->index % POP_CACHE_LEN];\n\n  if (cache->path)\n  {\n    {\n      mutt_error _(\"The message index is incorrect. Try reopening the mailbox.\");\n      mutt_sleep (2);\n      return -1;\n    }\n\n    mutt_progress_init (&progressbar, _(\"Fetching message...\"),\n\t\t\tMUTT_PROGRESS_SIZE, NetInc, h->content->length + h->content->offset - 1);\n\n    /* see if we can put in body cache; use our cache as fallback */\n    if (!(msg->fp = mutt_bcache_put (pop_data->bcache, h->data, 1)))\n    {\n      /* no */\n      bcache = 0;\n      mutt_mktemp (path, sizeof (path));\n      if (!(msg->fp = safe_fopen (path, \"w+\")))\n      {\n\tmutt_perror (path);\n\tmutt_sleep (2);\n\treturn -1;\n      }\n      mutt_error _(\"Can't write message to temporary file!\");\n      mutt_sleep (2);\n      return -1;\n    }\n  }\n\n  /* Update the header information.  Previously, we only downloaded a\n   * portion of the headers, those required for the main display.\n   */\n  if (bcache)\n    mutt_bcache_commit (pop_data->bcache, h->data);\n  else\n  {\n    cache->index = h->index;\n    cache->path = safe_strdup (path);\n  }\n  rewind (msg->fp);\n  uidl = h->data;\n\n  /* we replace envelop, key in subj_hash has to be updated as well */\n  if (ctx->subj_hash && h->env->real_subj)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  void *uidl;\n  char buf[LONG_STRING];\n  char path[_POSIX_PATH_MAX];\n  progress_t progressbar;\n  POP_DATA *pop_data = (POP_DATA *)ctx->data;\n  POP_CACHE *cache;\n  HEADER *h = ctx->hdrs[msgno];\n  unsigned short bcache = 1;\n\n  /* see if we already have the message in body cache */\n  if ((msg->fp = mutt_bcache_get (pop_data->bcache, cache_id (h->data))))\n    return 0;\n\n  /*\n   * see if we already have the message in our cache in\n   * case $message_cachedir is unset\n   */\n  cache = &pop_data->cache[h->index % POP_CACHE_LEN];\n\n  if (cache->path)\n  {\n    {\n      mutt_error _(\"The message index is incorrect. Try reopening the mailbox.\");\n      mutt_sleep (2);\n      return -1;\n    }\n\n    mutt_progress_init (&progressbar, _(\"Fetching message...\"),\n\t\t\tMUTT_PROGRESS_SIZE, NetInc, h->content->length + h->content->offset - 1);\n\n    /* see if we can put in body cache; use our cache as fallback */\n    if (!(msg->fp = mutt_bcache_put (pop_data->bcache, cache_id (h->data), 1)))\n    {\n      /* no */\n      bcache = 0;\n      mutt_mktemp (path, sizeof (path));\n      if (!(msg->fp = safe_fopen (path, \"w+\")))\n      {\n\tmutt_perror (path);\n\tmutt_sleep (2);\n\treturn -1;\n      }\n      mutt_error _(\"Can't write message to temporary file!\");\n      mutt_sleep (2);\n      return -1;\n    }\n  }\n\n  /* Update the header information.  Previously, we only downloaded a\n   * portion of the headers, those required for the main display.\n   */\n  if (bcache)\n    mutt_bcache_commit (pop_data->bcache, cache_id (h->data));\n  else\n  {\n    cache->index = h->index;\n    cache->path = safe_strdup (path);\n  }\n  rewind (msg->fp);\n  uidl = h->data;\n\n  /* we replace envelop, key in subj_hash has to be updated as well */\n  if (ctx->subj_hash && h->env->real_subj)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "inline typename V::VariantType FBUnserializer<V>::unserializeThing() {\n  size_t code = nextCode();\n\n  switch (code) {\n    case FB_SERIALIZE_BYTE:\n    case FB_SERIALIZE_I16:\n    case FB_SERIALIZE_I32:\n    case FB_SERIALIZE_I64:\n      return V::fromInt64(unserializeInt64());\n    case FB_SERIALIZE_VARCHAR:\n    case FB_SERIALIZE_STRING:\n      return V::fromString(unserializeString());\n    case FB_SERIALIZE_STRUCT:\n      return V::fromMap(unserializeMap());\n    case FB_SERIALIZE_NULL:\n      ++p_;\n      return V::createNull();\n    case FB_SERIALIZE_DOUBLE:\n      return V::fromDouble(unserializeDouble());\n    case FB_SERIALIZE_BOOLEAN:\n      return V::fromBool(unserializeBoolean());\n    case FB_SERIALIZE_VECTOR:\n      return V::fromVector(unserializeVector());\n    case FB_SERIALIZE_LIST:\n      return V::fromVector(unserializeList());\n    case FB_SERIALIZE_SET:\n      return V::fromSet(unserializeSet());\n    default:\n      throw UnserializeError(\"Invalid code: \" + folly::to<std::string>(code)\n                             + \" at location \" + folly::to<std::string>(p_));\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "FBUnserializer<V>::unserializeThing(size_t depth) {\n  if (UNLIKELY(depth > 1024)) {\n    throw UnserializeError(\"depth > 1024\");\n  }\n\n  size_t code = nextCode();\n\n  switch (code) {\n    case FB_SERIALIZE_BYTE:\n    case FB_SERIALIZE_I16:\n    case FB_SERIALIZE_I32:\n    case FB_SERIALIZE_I64:\n      return V::fromInt64(unserializeInt64());\n    case FB_SERIALIZE_VARCHAR:\n    case FB_SERIALIZE_STRING:\n      return V::fromString(unserializeString());\n    case FB_SERIALIZE_STRUCT:\n      return V::fromMap(unserializeMap(depth));\n    case FB_SERIALIZE_NULL:\n      ++p_;\n      return V::createNull();\n    case FB_SERIALIZE_DOUBLE:\n      return V::fromDouble(unserializeDouble());\n    case FB_SERIALIZE_BOOLEAN:\n      return V::fromBool(unserializeBoolean());\n    case FB_SERIALIZE_VECTOR:\n      return V::fromVector(unserializeVector(depth));\n    case FB_SERIALIZE_LIST:\n      return V::fromVector(unserializeList(depth));\n    case FB_SERIALIZE_SET:\n      return V::fromSet(unserializeSet(depth));\n    default:\n      throw UnserializeError(\"Invalid code: \" + folly::to<std::string>(code)\n                             + \" at location \" + folly::to<std::string>(p_));\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void svhandler_flash_erase_sector(void) {\n  uint32_t sector = _param_1;\n\n  // Do not allow firmware to erase bootstrap or bootloader sectors.\n  if ((sector == FLASH_BOOTSTRAP_SECTOR) ||\n      (sector >= FLASH_BOOT_SECTOR_FIRST && sector <= FLASH_BOOT_SECTOR_LAST)) {\n    return;\n  }\n\n  // Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n\n  // Erase the sector.\n  flash_erase_sector(sector, FLASH_CR_PROGRAM_X32);\n\n  // Return flash status.\n  _param_1 = !!flash_chk_status();",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void svhandler_flash_erase_sector(void) {\n  uint8_t sector = _param_1;\n\n  // Verify requested sector is allowed.\n  if (!allow_svhandler_flash_sector_num(sector)) return;\n\n  // Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n\n  // Erase the sector.\n  flash_erase_sector(sector, FLASH_CR_PROGRAM_X32);\n\n  // Return flash status.\n  _param_1 = !!flash_chk_status();",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\n\tif (submodule_url_is_relative(url)) {\n\t\t/*\n\t\t * This could be appended to an http URL and url-decoded;\n\t\t * check for malicious characters.\n\t\t */\n\t\tchar *decoded = url_decode(url);\n\t\tint has_nl = !!strchr(decoded, '\\n');\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\t}\n\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\n\tif (submodule_url_is_relative(url)) {\n\t\tchar *decoded;\n\t\tconst char *next;\n\t\tint has_nl;\n\n\t\t/*\n\t\t * This could be appended to an http URL and url-decoded;\n\t\t * check for malicious characters.\n\t\t */\n\t\tdecoded = url_decode(url);\n\t\thas_nl = !!strchr(decoded, '\\n');\n\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * URLs which escape their root via \"../\" can overwrite\n\t\t * the host field and previous components, resolving to\n\t\t * URLs like https::example.com/submodule.git that were\n\t\t * susceptible to CVE-2020-11008.\n\t\t */\n\t\tif (count_leading_dotdots(url, &next) > 0 &&\n\t\t    *next == ':')\n\t\t\treturn -1;\n\t}\n\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n  init_graph->AddEdge(init_handle, 0, init_assign, 0);\n  init_graph->AddEdge(init_const, 0, init_assign, 1);\n  FHandle fhandle;\n  const string fname =\n      strings::StrCat(ndef->name(), \"_init_ord_\", device_ordinal);\n\n  TF_RETURN_IF_ERROR(\n      InstantiatePartition(*init_graph, fname, device, &fhandle, nullptr));\n\n  FunctionLibraryRuntime::Options opts;\n  opts.step_container = ctx->step_container();\n  opts.cancellation_manager = ctx->cancellation_manager();\n  opts.stats_collector = ctx->stats_collector();\n\n  // Blocking on threads in the same thread pool is disallowed because\n  // concurrent warm-up requests can exhaust the default thread pool.\n  // Create a new thread pool to initialize variables on TPU.\n  std::function<void(std::function<void()>)> runner =\n      [this](std::function<void()> fn) { pool_.Schedule(fn); };\n  opts.runner = &runner;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n  init_graph->AddEdge(init_handle, 0, init_assign, 0);\n  init_graph->AddEdge(init_const, 0, init_assign, 1);\n  FHandle fhandle;\n  const string fname =\n      strings::StrCat(ndef->name(), \"_init_ord_\", device_ordinal);\n\n  TF_RETURN_IF_ERROR(\n      InstantiatePartition(*init_graph, fname, device, &fhandle, nullptr));\n\n  FunctionLibraryRuntime::Options opts(ctx->step_id());\n  opts.step_container = ctx->step_container();\n  opts.cancellation_manager = ctx->cancellation_manager();\n  opts.stats_collector = ctx->stats_collector();\n\n  // Blocking on threads in the same thread pool is disallowed because\n  // concurrent warm-up requests can exhaust the default thread pool.\n  // Create a new thread pool to initialize variables on TPU.\n  std::function<void(std::function<void()>)> runner =\n      [this](std::function<void()> fn) { pool_.Schedule(fn); };\n  opts.runner = &runner;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": " /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;  /* initialize mysql_enable_utf8 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    do_error(dbh, mysql_errno(imp_dbh->pmysql),\n            mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": " /* Safer we flip this to TRUE perl side if we detect a mod_perl env. */\n  imp_dbh->auto_reconnect = FALSE;\n\n  /* HELMUT */\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;  /* initialize mysql_enable_utf8 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    if(imp_dbh->pmysql)\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     */\n    DBIc_ACTIVE_on(imp_dbh);\n\n    /* Tell DBI, that dbh->destroy should be called for this handle */\n    DBIc_on(imp_dbh, DBIcf_IMPSET);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    {\n\n        if (buffer == NULL)\n        {\n            http_instance->is_io_error = 1;\n            LogError(\"NULL pointer error\");\n        }\n        else\n        {\n            /* Here we got some bytes so we'll buffer them so the receive functions can consumer it */\n            new_received_bytes = (unsigned char*)realloc(http_instance->received_bytes, http_instance->received_bytes_count + size);\n            if (new_received_bytes == NULL)\n            {\n                http_instance->is_io_error = 1;\n                LogError(\"Error allocating memory for received data\");\n            }\n            else\n            {\n                http_instance->received_bytes = new_received_bytes;\n                if (memcpy(http_instance->received_bytes + http_instance->received_bytes_count, buffer, size) == NULL)\n                {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    {\n\n        if (buffer == NULL)\n        {\n            http_instance->is_io_error = 1;\n            LogError(\"NULL pointer error\");\n        }\n        else\n        {\n            /* Here we got some bytes so we'll buffer them so the receive functions can consumer it */\n            size_t malloc_size = http_instance->received_bytes_count + size;\n            if (malloc_size < size)\n            {\n                // check for int overflow\n                new_received_bytes = NULL;\n                LogError(\"Invalid size parameter\");\n            }\n            else\n            {\n                new_received_bytes = (unsigned char*)realloc(http_instance->received_bytes, malloc_size);\n            }\n\n            if (new_received_bytes == NULL)\n            {\n                http_instance->is_io_error = 1;\n                LogError(\"Error allocating memory for received data\");\n            }\n            else\n            {\n                http_instance->received_bytes = new_received_bytes;\n                if (memcpy(http_instance->received_bytes + http_instance->received_bytes_count, buffer, size) == NULL)\n                {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void MSG_WriteBits( msg_t *msg, int value, int bits ) {\n\tint\ti;\n\n\toldsize += bits;\n\n\t// this isn't an exact overflow check, but close enough\n\tif ( msg->maxsize - msg->cursize < 4 ) {\n\t\tmsg->overflowed = qtrue;\n\t\treturn;\n\t}\n\n\tif ( bits == 0 || bits < -31 || bits > 32 ) {\n\t\tCom_Error( ERR_DROP, \"MSG_WriteBits: bad bits %i\", bits );\n\t}\n\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t}\n\n\tif ( msg->oob ) {\n\t\tif ( bits == 8 ) {\n\t\t\tmsg->data[msg->cursize] = value;\n\t\t\tmsg->cursize += 1;\n\t\t\tmsg->bit += 8;\n\t\t} else if ( bits == 16 ) {\n\t\t\tshort temp = value;\n\n\t\t\tCopyLittleShort( &msg->data[msg->cursize], &temp );\n\t\t\tmsg->cursize += 2;\n\t\t\tmsg->bit += 16;\n\t\t\tCopyLittleLong( &msg->data[msg->cursize], &value );\n\t\t\tmsg->cursize += 4;\n\t\t\tmsg->bit += 32;\n\t\t} else {\n\t\t\tCom_Error( ERR_DROP, \"can't write %d bits\", bits );\n\t\t}\n\t} else {\n\t\tvalue &= (0xffffffff >> (32 - bits));\n\t\tif ( bits&7 ) {\n\t\t\tint nbits;\n\t\t\tnbits = bits&7;\n\t\t\tfor( i = 0; i < nbits; i++ ) {\n\t\t\t\tHuff_putBit( (value & 1), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 1);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif ( bits ) {\n\t\t\tfor( i = 0; i < bits; i += 8 ) {\n\t\t\t\tHuff_offsetTransmit( &msgHuff.compressor, (value & 0xff), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 8);\n\t\t\t}\n\t\t}\n\t\tmsg->cursize = (msg->bit >> 3) + 1;\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void MSG_WriteBits( msg_t *msg, int value, int bits ) {\n\tint\ti;\n\n\toldsize += bits;\n\n\tif ( msg->overflowed ) {\n\t\treturn;\n\t}\n\n\tif ( bits == 0 || bits < -31 || bits > 32 ) {\n\t\tCom_Error( ERR_DROP, \"MSG_WriteBits: bad bits %i\", bits );\n\t}\n\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t}\n\n\tif ( msg->oob ) {\n\t\tif ( msg->cursize + ( bits >> 3 ) > msg->maxsize ) {\n\t\t\tmsg->overflowed = qtrue;\n\t\t\treturn;\n\t\t}\n\n\t\tif ( bits == 8 ) {\n\t\t\tmsg->data[msg->cursize] = value;\n\t\t\tmsg->cursize += 1;\n\t\t\tmsg->bit += 8;\n\t\t} else if ( bits == 16 ) {\n\t\t\tshort temp = value;\n\n\t\t\tCopyLittleShort( &msg->data[msg->cursize], &temp );\n\t\t\tmsg->cursize += 2;\n\t\t\tmsg->bit += 16;\n\t\t\tmsg->cursize += 4;\n\t\t\tmsg->bit += 32;\n\t\t} else {\n\t\t\tCom_Error( ERR_DROP, \"can't write %d bits\", bits );\n\t\t}\n\t} else {\n\t\tvalue &= (0xffffffff >> (32 - bits));\n\t\tif ( bits&7 ) {\n\t\t\tint nbits;\n\t\t\tnbits = bits&7;\n\t\t\tif ( msg->bit + nbits > msg->maxsize << 3 ) {\n\t\t\t\tmsg->overflowed = qtrue;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor( i = 0; i < nbits; i++ ) {\n\t\t\t\tHuff_putBit( (value & 1), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 1);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif ( bits ) {\n\t\t\tfor( i = 0; i < bits; i += 8 ) {\n\t\t\t\tHuff_offsetTransmit( &msgHuff.compressor, (value & 0xff), msg->data, &msg->bit, msg->maxsize << 3 );\n\t\t\t\tvalue = (value >> 8);\n\n\t\t\t\tif ( msg->bit > msg->maxsize << 3 ) {\n\t\t\t\t\tmsg->overflowed = qtrue;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsg->cursize = (msg->bit >> 3) + 1;\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    for(j = 0; j < 3; j++) {\n      /* Reverse the neighboring facets if necessary. */\n      if(stl->neighbors_start[facet_num].which_vertex_not[j] > 2) {\n        /* If the facet has a neighbor that is -1, it means that edge isn't shared by another facet */\n        if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n          stl_reverse_facet\n          (stl, stl->neighbors_start[facet_num].neighbor[j]);\n        }\n      }\n      /* If this edge of the facet is connected: */\n      if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n        /* If we haven't fixed this facet yet, add it to the list: */\n        if(norm_sw[stl->neighbors_start[facet_num].neighbor[j]] != 1) {\n          /* Add node to beginning of list. */\n          newn = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n          if(newn == NULL) perror(\"stl_fix_normal_directions\");\n          newn->facet_num = stl->neighbors_start[facet_num].neighbor[j];\n          newn->next = head->next;\n          head->next = newn;\n        }\n      }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    for(j = 0; j < 3; j++) {\n      /* Reverse the neighboring facets if necessary. */\n      if(stl->neighbors_start[facet_num].which_vertex_not[j] > 2) {\n        /* If the facet has a neighbor that is -1, it means that edge isn't shared by another facet */\n        if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n          stl_reverse_facet\n          (stl, stl->neighbors_start[facet_num].neighbor[j]);\n        }\n      }\n      /* If this edge of the facet is connected: */\n      if(stl->neighbors_start[facet_num].neighbor[j] != -1 &&\n         stl->neighbors_start[facet_num].neighbor[j] < stl->stats.number_of_facets*sizeof(char)) {\n        /* If we haven't fixed this facet yet, add it to the list: */\n        if(norm_sw[stl->neighbors_start[facet_num].neighbor[j]] != 1) {\n          /* Add node to beginning of list. */\n          newn = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n          if(newn == NULL) perror(\"stl_fix_normal_directions\");\n          newn->facet_num = stl->neighbors_start[facet_num].neighbor[j];\n          newn->next = head->next;\n          head->next = newn;\n        }\n      }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length, \n                                         uint32 width, uint16 spp,\n                                         struct dump_opts *dump)\n  {\n  int i, j, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;\n  int32  bytes_read = 0;\n  uint16 bps, nstrips, planar, strips_per_sample;\n  uint32 src_rowsize, dst_rowsize, rows_processed, rps;\n  uint32 rows_this_strip = 0;\n  tsample_t s;\n  tstrip_t  strip;\n  tsize_t scanlinesize = TIFFScanlineSize(in);\n  tsize_t stripsize    = TIFFStripSize(in);\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *buff = NULL;\n  unsigned char *dst = NULL;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length, \n                                         uint32 width, uint16 spp,\n                                         struct dump_opts *dump)\n  {\n  int i, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;\n  uint32 j;\n  int32  bytes_read = 0;\n  uint16 bps, planar;\n  uint32 nstrips;\n  uint32 strips_per_sample;\n  uint32 src_rowsize, dst_rowsize, rows_processed, rps;\n  uint32 rows_this_strip = 0;\n  tsample_t s;\n  tstrip_t  strip;\n  tsize_t scanlinesize = TIFFScanlineSize(in);\n  tsize_t stripsize    = TIFFStripSize(in);\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *buff = NULL;\n  unsigned char *dst = NULL;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    // attributes as type variables.\n    // See https://www.tensorflow.org/guide/create_op#type_polymorphism.\n    // Once the op signature can be defined entirely in FullType, this\n    // convention can be deprecated.\n    //\n    // Note: While this code performs some basic verifications, it generally\n    // assumes consistent op defs and attributes. If more complete\n    // verifications are needed, they should be done by separately, and in a\n    // way that can be reused for type inference.\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        if (attr == nullptr) {\n          return Status(\n              error::INVALID_ARGUMENT,\n              absl::StrCat(\"Could not find an attribute for key \", arg->s()));\n        }\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    // attributes as type variables.\n    // See https://www.tensorflow.org/guide/create_op#type_polymorphism.\n    // Once the op signature can be defined entirely in FullType, this\n    // convention can be deprecated.\n    //\n    // Note: While this code performs some basic verifications, it generally\n    // assumes consistent op defs and attributes. If more complete\n    // verifications are needed, they should be done by separately, and in a\n    // way that can be reused for type inference.\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(j);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        if (attr == nullptr) {\n          return Status(\n              error::INVALID_ARGUMENT,\n              absl::StrCat(\"Could not find an attribute for key \", arg->s()));\n        }\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int lmf_header_load(lmf_header *lmfh, RBuffer *buf, Sdb *db) {\n\tif (r_buf_size (buf) < sizeof (lmf_header)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, \"iiiiiiiicccciiiicc\", 1) < QNX_HDR_SIZE) {\n\t\treturn false;\n\t}\n\tr_strf_buffer (32);\n\tsdb_set (db, \"qnx.version\", r_strf (\"0x%xH\", lmfh->version), 0);\n\tsdb_set (db, \"qnx.cflags\", r_strf (\"0x%xH\", lmfh->cflags), 0);\n\tsdb_set (db, \"qnx.cpu\", r_strf (\"0x%xH\", lmfh->cpu), 0);\n\tsdb_set (db, \"qnx.fpu\", r_strf (\"0x%xH\", lmfh->fpu), 0);\n\tsdb_set (db, \"qnx.code_index\", r_strf (\"0x%x\", lmfh->code_index), 0);\n\tsdb_set (db, \"qnx.stack_index\", r_strf (\"0x%x\", lmfh->stack_index), 0);\n\tsdb_set (db, \"qnx.heap_index\", r_strf (\"0x%x\", lmfh->heap_index), 0);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int lmf_header_load(lmf_header *lmfh, RBuffer *buf, Sdb *db) {\n\tif (r_buf_size (buf) < sizeof (lmf_header)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, \"iiiiiiiicccciiiicc\", 1) != QNX_HDR_SIZE) {\n\t\treturn false;\n\t}\n\tr_strf_buffer (32);\n\tsdb_set (db, \"qnx.version\", r_strf (\"0x%xH\", lmfh->version), 0);\n\tsdb_set (db, \"qnx.cflags\", r_strf (\"0x%xH\", lmfh->cflags), 0);\n\tsdb_set (db, \"qnx.cpu\", r_strf (\"0x%xH\", lmfh->cpu), 0);\n\tsdb_set (db, \"qnx.fpu\", r_strf (\"0x%xH\", lmfh->fpu), 0);\n\tsdb_set (db, \"qnx.code_index\", r_strf (\"0x%x\", lmfh->code_index), 0);\n\tsdb_set (db, \"qnx.stack_index\", r_strf (\"0x%x\", lmfh->stack_index), 0);\n\tsdb_set (db, \"qnx.heap_index\", r_strf (\"0x%x\", lmfh->heap_index), 0);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int jas_matrix_resize(jas_matrix_t *matrix, int numrows, int numcols)\n{\n\tint size;\n\tint i;\n\n\tsize = numrows * numcols;\n\tif (size > matrix->datasize_ || numrows > matrix->maxrows_) {\n\t\treturn -1;\n\t}\n\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\n\tfor (i = 0; i < numrows; ++i) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int jas_matrix_resize(jas_matrix_t *matrix, jas_matind_t numrows,\n  jas_matind_t numcols)\n{\n\tjas_matind_t size;\n\tjas_matind_t i;\n\n\tsize = numrows * numcols;\n\tif (size > matrix->datasize_ || numrows > matrix->maxrows_) {\n\t\treturn -1;\n\t}\n\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\n\tfor (i = 0; i < numrows; ++i) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  string body;\n  if (reqHeaders->count(\"Cookie\") != 0) {\n    string cookies = (*reqHeaders)[\"Cookie\"];\n    string sessionIdString = cookies.substr(cookies.find(\"=\") + 1);\n    sessionId = stoll(sessionIdString, nullptr);\n    auto usersessionIt = sessionMap.find(sessionId);\n    if (usersessionIt == sessionMap.end()){\n      cout << \"Bad session ID, redirecting to login.\" << endl;\n      body = getLogin();\n    } else\n      uid = sessionMap[sessionId];\n  }\n  map<string, string> resHeaders;\n  resHeaders[\"Server\"] = \"CSE461\";\n  resHeaders[\"Content-Type\"] = \"text/html; charset=UTF-8\";\n\n  if (uri.compare(\"/cal\") == 0 && uid == -1) {\n    cout << \"login page\" << endl;\n    // login page\n    body = getLogin();\n  } else if (uri.compare(\"/cal\") == 0 && uid != -1) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  string body;\n  if (reqHeaders->count(\"Cookie\") != 0) {\n    string cookies = (*reqHeaders)[\"Cookie\"];\n    string sessionIdString = cookies.substr(cookies.find(\"=\") + 1);\n    sessionId = stoll(sessionIdString, nullptr);\n    auto usersessionIt = sessionMap.find(sessionId);\n    if (usersessionIt == sessionMap.end()){\n      cout << \"Bad session ID, redirecting to login.\" << endl;\n      body = getLogin();\n    } else\n      uid = usersessionIt->second;\n  }\n  map<string, string> resHeaders;\n  resHeaders[\"Server\"] = \"CSE461\";\n  resHeaders[\"Content-Type\"] = \"text/html; charset=UTF-8\";\n\n  if (uri.compare(\"/cal\") == 0 && uid == -1) {\n    cout << \"login page\" << endl;\n    // login page\n    body = getLogin();\n  } else if (uri.compare(\"/cal\") == 0 && uid != -1) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    struct Dwarf_Line_Registers_s * regs,\n    Dwarf_Bool is_single_table, Dwarf_Bool is_actuals_table)\n{\n    dwarfstring m1;\n\n    dwarfstring_constructor_static(&m1,locallinebuf,\n        sizeof(locallinebuf));\n    if(!is_single_table && is_actuals_table) {\n        dwarfstring_append_printf_s(&m1,\"%-15s \",(char *)prefix);\n        dwarfstring_append_printf_i(&m1,\"%3d \",opcode);\n        dwarfstring_append_printf_u(&m1,\"0x%\" DW_PR_XZEROS DW_PR_DUx ,\n            regs->lr_address);\n        dwarfstring_append_printf_u(&m1,\"/%01u\",regs->lr_op_index);\n        dwarfstring_append_printf_u(&m1,\" %5lu\", regs->lr_line);\n        dwarfstring_append_printf_u(&m1,\" %3d\",regs->lr_isa);\n        dwarfstring_append_printf_i(&m1,\"   %1d\", regs->lr_basic_block);\n        dwarfstring_append_printf_i(&m1,\"%1d\\n\",  regs->lr_end_sequence);\n        _dwarf_printf(dbg,dwarfstring_string(&m1));\n        dwarfstring_destructor(&m1);\n        return;\n    }\n    if(!is_single_table && !is_actuals_table) {\n        dwarfstring_append_printf_i(&m1,\n            \"[%3d] \"  /* row number */, curr_line);\n        dwarfstring_append_printf_s(&m1,\n            \"%-15s \",(char *)prefix);\n        dwarfstring_append_printf_i(&m1,\n            regs->lr_prologue_end ||\n            regs->lr_epilogue_begin ||\n            regs->lr_isa ||\n            regs->lr_is_stmt ||\n            regs->lr_call_context ||\n            regs->lr_subprogram) {\n            dwarfstring_append_printf_u(&m1,\n                \"   x%02\" DW_PR_DUx ,\n                regs->lr_discriminator); /* DWARF4 */\n            dwarfstring_append_printf_u(&m1,\n                \"  x%02\" DW_PR_DUx , regs->lr_call_context); /* EXPERIMENTAL */\n            dwarfstring_append_printf_u(&m1,\n                \"  x%02\" DW_PR_DUx , regs->lr_subprogram); /* EXPERIMENTAL */\n            dwarfstring_append_printf_i(&m1,\n                \"  %1d\", regs->lr_is_stmt);\n            dwarfstring_append_printf_i(&m1,\n                \"%1d\", (int) regs->lr_isa);\n            dwarfstring_append_printf_i(&m1,\n                \"%1d\", regs->lr_prologue_end); /* DWARF3 */\n            dwarfstring_append_printf_i(&m1,\n                \"%1d\", regs->lr_epilogue_begin); /* DWARF3 */\n        }\n        dwarfstring_append(&m1,\"\\n\");",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    struct Dwarf_Line_Registers_s * regs,\n    Dwarf_Bool is_single_table, Dwarf_Bool is_actuals_table)\n{\n    dwarfstring m1;\n\n    dwarfstring_constructor_static(&m1,locallinebuf,\n        sizeof(locallinebuf));\n    if(!is_single_table && is_actuals_table) {\n        dwarfstring_append_printf_s(&m1,\"%-15s \",(char *)prefix);\n        dwarfstring_append_printf_i(&m1,\"%3d \",opcode);\n        dwarfstring_append_printf_u(&m1,\"0x%\" DW_PR_XZEROS DW_PR_DUx,\n            regs->lr_address);\n        dwarfstring_append_printf_u(&m1,\"/%01u\",regs->lr_op_index);\n        dwarfstring_append_printf_u(&m1,\" %5lu\", regs->lr_line);\n        dwarfstring_append_printf_u(&m1,\" %3d\",regs->lr_isa);\n        dwarfstring_append_printf_i(&m1,\"   %1d\",\n            regs->lr_basic_block);\n        dwarfstring_append_printf_i(&m1,\"%1d\\n\",\n            regs->lr_end_sequence);\n        _dwarf_printf(dbg,dwarfstring_string(&m1));\n        dwarfstring_destructor(&m1);\n        return;\n    }\n    if(!is_single_table && !is_actuals_table) {\n        dwarfstring_append_printf_i(&m1,\n            \"[%3d] \"  /* row number */, curr_line);\n        dwarfstring_append_printf_s(&m1,\n            \"%-15s \",(char *)prefix);\n        dwarfstring_append_printf_i(&m1,\n            regs->lr_prologue_end ||\n            regs->lr_epilogue_begin ||\n            regs->lr_isa ||\n            regs->lr_is_stmt ||\n            regs->lr_call_context ||\n            regs->lr_subprogram) {\n            dwarfstring_append_printf_u(&m1,\n                \"   x%02\" DW_PR_DUx ,\n                regs->lr_discriminator); /* DWARF4 */\n            dwarfstring_append_printf_u(&m1,\n                \"  x%02\" DW_PR_DUx,\n                regs->lr_call_context); /* EXPERIMENTAL */\n            dwarfstring_append_printf_u(&m1,\n                \"  x%02\" DW_PR_DUx ,\n                regs->lr_subprogram); /* EXPERIMENTAL */\n            dwarfstring_append_printf_i(&m1,\n                \"  %1d\", regs->lr_is_stmt);\n            dwarfstring_append_printf_i(&m1,\n                \"%1d\", (int) regs->lr_isa);\n            dwarfstring_append_printf_i(&m1,\n                \"%1d\", regs->lr_prologue_end); /* DWARF3 */\n            dwarfstring_append_printf_i(&m1,\n                \"%1d\", regs->lr_epilogue_begin); /* DWARF3 */\n        }\n        dwarfstring_append(&m1,\"\\n\");",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static inline u32 net_hash_mix(const struct net *net)\n{\n#ifdef CONFIG_NET_NS\n\treturn (u32)(((unsigned long)net) >> ilog2(sizeof(*net)));\n#else\n\treturn 0;\n#endif\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static inline u32 net_hash_mix(const struct net *net)\n{\n\treturn net->hash_mix;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tDBG_dump(\"verify_sh decrypted SIG1:\", s, sig_len));\n    DBG(DBG_CRYPT, DBG_log(\"pad_len calculated: %d hash_len: %d\", padlen, (int)hash_len));\n\n    /* skip padding */\n    if(s[0]    != 0x00\n       || s[1] != 0x01\n       || s[padlen+2] != 0x00) {\n\treturn \"3\"\"SIG padding does not check out\";\n    }\n\n    s += padlen + 3;\n    (*psig) = s;\n\n    /* return SUCCESS */\n    return NULL;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tDBG_dump(\"verify_sh decrypted SIG1:\", s, sig_len));\n    DBG(DBG_CRYPT, DBG_log(\"pad_len calculated: %d hash_len: %d\", padlen, (int)hash_len));\n\n    /* skip padding */\n    if(s[0]    != 0x00\n       || s[1] != 0x01\n       || s[padlen+2] != 0x00) {\n\treturn \"3\"\"SIG padding does not check out\";\n    }\n\n    /* signature starts after ASN wrapped padding [00,01,FF..FF,00] */\n    (*psig) = s + padlen + 3;\n\n    /* verify padding contents */\n    {\n        const u_char *p;\n        size_t cnt_ffs = 0;\n\n        for (p = s+2; p < s+padlen+2; p++)\n            if (*p == 0xFF)\n                cnt_ffs ++;\n\n        if (cnt_ffs != padlen)\n            return \"4\" \"invalid Padding String\";\n    }\n\n    /* return SUCCESS */\n    return NULL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void pp_mil_k8(fp8_t r, ep2_t *t, ep2_t *q, ep_t *p, int m, bn_t a) {\n\tfp8_t l;\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep2_t *_q = RLC_ALLOCA(ep2_t, m);\n\tint i, j, len = bn_bits(a) + 1;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tif (m == 0) {\n\t\treturn;\n\t}\n\n\tfp8_null(l);\n\n\tRLC_TRY {\n\t\tfp8_new(l);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void pp_mil_k8(fp8_t r, ep2_t *t, ep2_t *q, ep_t *p, int m, bn_t a) {\n\tfp8_t l;\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep2_t *_q = RLC_ALLOCA(ep2_t, m);\n\tsize_t len = bn_bits(a) + 1;\n\tint i, j;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tif (m == 0) {\n\t\treturn;\n\t}\n\n\tfp8_null(l);\n\n\tRLC_TRY {\n\t\tfp8_new(l);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\nstatic void bfq_idle_slice_timer_body(struct bfq_queue *bfqq)\n{\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tenum bfqq_expiration reason;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\tbfq_clear_bfqq_wait_request(bfqq);\n\n\tif (bfqq != bfqd->in_service_queue) {\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t\treturn;\n\t}\n\n\tif (bfq_bfqq_budget_timeout(bfqq))\n\t\t/*\n\t\t * Also here the queue can be safely expired\n\t\t * for budget timeout without wasting\n\t\t * guarantees\n\t\t */\n\t\treason = BFQQE_BUDGET_TIMEOUT;\n\telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n\t\t/*\n\t\t * The queue may not be empty upon timer expiration,\n\t\t * because we may not disable the timer when the\n\t\t * first request of the in-service queue arrives\n\t\t * during disk idling.\n\t\t */\n\t\treason = BFQQE_TOO_IDLE;\n\telse\n\t\tgoto schedule_dispatch;\n\n\tbfq_bfqq_expire(bfqd, bfqq, true, reason);\n\nschedule_dispatch:\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\tbfq_schedule_dispatch(bfqd);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void\nbfq_idle_slice_timer_body(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\tenum bfqq_expiration reason;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\n\t/*\n\t * Considering that bfqq may be in race, we should firstly check\n\t * whether bfqq is in service before doing something on it. If\n\t * the bfqq in race is not in service, it has already been expired\n\t * through __bfq_bfqq_expire func and its wait_request flags has\n\t * been cleared in __bfq_bfqd_reset_in_service func.\n\t */\n\tif (bfqq != bfqd->in_service_queue) {\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t\treturn;\n\t}\n\n\tbfq_clear_bfqq_wait_request(bfqq);\n\n\tif (bfq_bfqq_budget_timeout(bfqq))\n\t\t/*\n\t\t * Also here the queue can be safely expired\n\t\t * for budget timeout without wasting\n\t\t * guarantees\n\t\t */\n\t\treason = BFQQE_BUDGET_TIMEOUT;\n\telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n\t\t/*\n\t\t * The queue may not be empty upon timer expiration,\n\t\t * because we may not disable the timer when the\n\t\t * first request of the in-service queue arrives\n\t\t * during disk idling.\n\t\t */\n\t\treason = BFQQE_TOO_IDLE;\n\telse\n\t\tgoto schedule_dispatch;\n\n\tbfq_bfqq_expire(bfqd, bfqq, true, reason);\n\nschedule_dispatch:\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\tbfq_schedule_dispatch(bfqd);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tif (ms->search.s == NULL)\n\t\t\treturn 0;\n\n\t\tl = 0;\n\t\trc = file_regcomp(&rx, m->value.s,\n\t\t    REG_EXTENDED|REG_NEWLINE|\n\t\t    ((m->str_flags & STRING_IGNORE_CASE) ? REG_ICASE : 0));\n\t\tif (rc) {\n\t\t\tfile_regerror(&rx, rc, ms);\n\t\t\tv = (uint64_t)-1;\n\t\t} else {\n\t\t\tregmatch_t pmatch[1];\n#ifndef REG_STARTEND\n#define\tREG_STARTEND\t0\n\t\t\tsize_t l = ms->search.s_len - 1;\n\t\t\tchar c = ms->search.s[l];\n\t\t\t((char *)(intptr_t)ms->search.s)[l] = '\\0';\n#else\n\t\t\tpmatch[0].rm_so = 0;\n\t\t\tpmatch[0].rm_eo = ms->search.s_len;\n#endif\n\t\t\trc = file_regexec(&rx, (const char *)ms->search.s,\n\t\t\t    1, pmatch, REG_STARTEND);\n#if REG_STARTEND == 0\n\t\t\t((char *)(intptr_t)ms->search.s)[l] = c;\n#endif\n\t\t\tswitch (rc) {\n\t\t\tcase 0:\n\t\t\t\tms->search.s += (int)pmatch[0].rm_so;\n\t\t\t\tms->search.offset += (size_t)pmatch[0].rm_so;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\treturn 0;\n\n\t\tl = 0;\n\t\trc = file_regcomp(&rx, m->value.s,\n\t\t    REG_EXTENDED|REG_NEWLINE|\n\t\t    ((m->str_flags & STRING_IGNORE_CASE) ? REG_ICASE : 0));\n\t\tif (rc) {\n\t\t\tfile_regerror(&rx, rc, ms);\n\t\t\tv = (uint64_t)-1;\n\t\t} else {\n#ifndef REG_STARTEND\n\t\t\tchar c;\n#endif\n\t\t\tregmatch_t pmatch[1];\n\t\t\tsize_t slen = ms->search.s_len;\n\t\t\t/* Limit by offset if requested */\n\t\t\tif (m->str_range > 0)\n\t\t\t\tslen = MIN(slen, m->str_range);\n#ifndef REG_STARTEND\n#define\tREG_STARTEND\t0\n\t\t\tif (slen != 0)\n\t\t\t\tslen--;\n\t\t\tc = ms->search.s[slen];\n\t\t\t((char *)(intptr_t)ms->search.s)[slen] = '\\0';\n#else\n\t\t\tpmatch[0].rm_so = 0;\n\t\t\tpmatch[0].rm_eo = slen;\n#endif\n\t\t\trc = file_regexec(&rx, (const char *)ms->search.s,\n\t\t\t    1, pmatch, REG_STARTEND);\n#if REG_STARTEND == 0\n\t\t\t((char *)(intptr_t)ms->search.s)[l] = c;\n#endif\n\t\t\tswitch (rc) {\n\t\t\tcase 0:\n\t\t\t\tms->search.s += (int)pmatch[0].rm_so;\n\t\t\t\tms->search.offset += (size_t)pmatch[0].rm_so;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "mm_answer_pam_free_ctx(int sock, Buffer *m)\n{\n\n\tdebug3(\"%s\", __func__);\n\t(sshpam_device.free_ctx)(sshpam_ctxt);\n\tbuffer_clear(m);\n\tmm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"pam\";\n\treturn (sshpam_authok == sshpam_ctxt);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "mm_answer_pam_free_ctx(int sock, Buffer *m)\n{\n\tint r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;\n\n\tdebug3(\"%s\", __func__);\n\t(sshpam_device.free_ctx)(sshpam_ctxt);\n\tsshpam_ctxt = sshpam_authok = NULL;\n\tbuffer_clear(m);\n\tmm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"pam\";\n\treturn r;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "WRITE_JSON_ELEMENT(ArrStart) {\n    /* increase depth, save: before first array entry no comma needed. */\n    ctx->commaNeeded[++ctx->depth] = false;\n    return writeChar(ctx, '[');\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "WRITE_JSON_ELEMENT(ObjStart) {\n    /* increase depth, save: before first key-value no comma needed. */\n    if(ctx->depth >= UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    ctx->depth++;\n    ctx->commaNeeded[ctx->depth] = false;\n    return writeChar(ctx, '{');\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_TARGET_INDEX])\n\t\treturn -EINVAL;\n\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      TF_RETURN_IF_ERROR(context->allocate_output(kEmptyRowIndicatorOutput,\n                                                  TensorShape({dense_rows}),\n                                                  &empty_row_indicator_t_ptr));\n      empty_row_indicator = empty_row_indicator_t_ptr->vec<bool>().data();\n    } else {\n      TF_RETURN_IF_ERROR(context->allocate_temp(\n          DT_BOOL, TensorShape({dense_rows}), &empty_row_indicator_t));\n      empty_row_indicator = empty_row_indicator_t.vec<bool>().data();\n    }\n\n    TF_RETURN_IF_ERROR(wrap_kernel_call(ComputeEmptyRowIndicatorKernel<Tindex>,\n                                        /*device=*/device, /*size=*/dense_rows,\n                                        elements_per_row, empty_row_indicator));\n\n    // For each row, the number of empty rows up to and including that row.\n    Tensor num_empty_rows_through_t;\n    TF_RETURN_IF_ERROR(context->allocate_temp(\n        index_type, TensorShape({dense_rows}), &num_empty_rows_through_t));\n    auto num_empty_rows_through = num_empty_rows_through_t.flat<Tindex>();\n\n    gpuprim::TransformInputIterator<Tindex, CastFunctor<Tindex>, bool*>\n        empty_row_indicator_cast(empty_row_indicator, {});\n\n        OP_REQUIRES_OK_ASYNC(\n            context,\n            wrap_kernel_call(ScatterInputElementsKernel<T, Tindex>,\n                             /*device=*/device, /*size=*/N, dense_rows, rank,\n                             input_index_map, indices, values,\n                             num_empty_rows_through, output_indices,\n                             output_values, reverse_index_map),\n            done);\n      }\n\n      OP_REQUIRES_OK_ASYNC(\n          context,\n          wrap_kernel_call(ScatterNewElementsKernel<T, Tindex>,\n                           /*device=*/device, /*size=*/dense_rows, rank,\n                           default_value, num_empty_rows_through,\n                           input_row_ends, empty_row_indicator, output_indices,\n                           output_values),\n          done);\n\n      done();\n    };\n\n    context->device()\n        ->tensorflow_accelerator_device_info()\n        ->event_mgr->ThenExecute(stream, async_finish_computation);\n    return OkStatus();\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      TF_RETURN_IF_ERROR(context->allocate_output(kEmptyRowIndicatorOutput,\n                                                  TensorShape({dense_rows}),\n                                                  &empty_row_indicator_t_ptr));\n      empty_row_indicator = empty_row_indicator_t_ptr->vec<bool>().data();\n    } else {\n      TF_RETURN_IF_ERROR(context->allocate_temp(\n          DT_BOOL, TensorShape({dense_rows}), &empty_row_indicator_t));\n      empty_row_indicator = empty_row_indicator_t.vec<bool>().data();\n    }\n\n    if (dense_rows > 0) {\n      TF_RETURN_IF_ERROR(\n          wrap_kernel_call(ComputeEmptyRowIndicatorKernel<Tindex>,\n                           /*device=*/device, /*size=*/dense_rows,\n                           elements_per_row, empty_row_indicator));\n    }\n\n    // For each row, the number of empty rows up to and including that row.\n    Tensor num_empty_rows_through_t;\n    TF_RETURN_IF_ERROR(context->allocate_temp(\n        index_type, TensorShape({dense_rows}), &num_empty_rows_through_t));\n    auto num_empty_rows_through = num_empty_rows_through_t.flat<Tindex>();\n\n    gpuprim::TransformInputIterator<Tindex, CastFunctor<Tindex>, bool*>\n        empty_row_indicator_cast(empty_row_indicator, {});\n\n        OP_REQUIRES_OK_ASYNC(\n            context,\n            wrap_kernel_call(ScatterInputElementsKernel<T, Tindex>,\n                             /*device=*/device, /*size=*/N, dense_rows, rank,\n                             input_index_map, indices, values,\n                             num_empty_rows_through, output_indices,\n                             output_values, reverse_index_map),\n            done);\n      }\n\n      if (dense_rows > 0) {\n        OP_REQUIRES_OK_ASYNC(\n            context,\n            wrap_kernel_call(ScatterNewElementsKernel<T, Tindex>,\n                             /*device=*/device, /*size=*/dense_rows, rank,\n                             default_value, num_empty_rows_through,\n                             input_row_ends, empty_row_indicator,\n                             output_indices, output_values),\n            done);\n      }\n\n      done();\n    };\n\n    context->device()\n        ->tensorflow_accelerator_device_info()\n        ->event_mgr->ThenExecute(stream, async_finish_computation);\n    return OkStatus();\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\t */\n\t\t\t\tif (sk->af ==\n\t\t\t\t    (*stp)->key[PF_SK_WIRE]->af &&\n\t\t\t\t    (((*stp)->direction == PF_OUT &&\n\t\t\t\t    PF_AEQ(&sn->addr, &sk->addr[1], sk->af)) ||\n\t\t\t\t    ((*stp)->direction == PF_IN &&\n\t\t\t\t    PF_AEQ(&sn->addr, &sk->addr[0], sk->af))) &&\n\t\t\t\t    ((*stp)->rule.ptr->flush &\n\t\t\t\t    PF_FLUSH_GLOBAL ||\n\t\t\t\t    (*stp)->rule.ptr == st->rule.ptr)) {\n\t\t\t\t\tst->timeout = PFTM_PURGE;\n\t\t\t\t\tpf_set_protostate(st, PF_PEER_BOTH,\n\t\t\t\t\t    TCPS_CLOSED);\n\t\t\t\t\tkilled++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pf_status.debug >= LOG_NOTICE)\n\t\t\t\taddlog(\", %u states killed\", killed);\n\t\t}\n\t\tif (pf_status.debug >= LOG_NOTICE)\n\t\t\taddlog(\"\\n\");\n\t}\n\n\t/* kill this state */\n\t(*stp)->timeout = PFTM_PURGE;\n\tpf_set_protostate(*stp, PF_PEER_BOTH, TCPS_CLOSED);\n\treturn (1);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\t */\n\t\t\t\tif (sk->af ==\n\t\t\t\t    (*stp)->key[PF_SK_WIRE]->af &&\n\t\t\t\t    (((*stp)->direction == PF_OUT &&\n\t\t\t\t    PF_AEQ(&sn->addr, &sk->addr[1], sk->af)) ||\n\t\t\t\t    ((*stp)->direction == PF_IN &&\n\t\t\t\t    PF_AEQ(&sn->addr, &sk->addr[0], sk->af))) &&\n\t\t\t\t    ((*stp)->rule.ptr->flush &\n\t\t\t\t    PF_FLUSH_GLOBAL ||\n\t\t\t\t    (*stp)->rule.ptr == st->rule.ptr)) {\n\t\t\t\t\tpf_update_state_timeout(st, PFTM_PURGE);\n\t\t\t\t\tpf_set_protostate(st, PF_PEER_BOTH,\n\t\t\t\t\t    TCPS_CLOSED);\n\t\t\t\t\tkilled++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pf_status.debug >= LOG_NOTICE)\n\t\t\t\taddlog(\", %u states killed\", killed);\n\t\t}\n\t\tif (pf_status.debug >= LOG_NOTICE)\n\t\t\taddlog(\"\\n\");\n\t}\n\n\t/* kill this state */\n\tpf_update_state_timeout(*stp, PFTM_PURGE);\n\tpf_set_protostate(*stp, PF_PEER_BOTH, TCPS_CLOSED);\n\treturn (1);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain <= 0) {\n\t\t\t/* 2.0.34: EOF is incorrect. We use 0 for\n\t\t\t * errors and EOF, just like fileGetbuf,\n\t\t\t * which is a simple fread() wrapper.\n\t\t\t * TBB. Original bug report: Daniel Cowgill. */\n\t\t\treturn 0; /* NOT EOF */\n\t\t}\n\n\t\trlen = remain;\n\t}\n\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\n\treturn rlen;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tif (dp->pos < 0 || dp->pos >= dp->realSize) {\n\t\treturn 0;\n\t}\n\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain <= 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\trlen = remain;\n\t}\n\n\tif (dp->pos + rlen > dp->realSize) {\n\t\trlen = dp->realSize - dp->pos;\n\t}\n\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\n\treturn rlen;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int crxParamInit(CrxBandParam **param, uint64_t subbandMdatOffset,\n                 uint64_t subbandDataSize, uint32_t subbandWidth,\n                 uint32_t subbandHeight, int32_t supportsPartial,\n                 uint32_t roundedBitsMask, LibRaw_abstract_datastream *input)\n{\n  int32_t progrDataSize = supportsPartial ? 0 : sizeof(int32_t) * subbandWidth;\n  int32_t paramLength = 2 * subbandWidth + 4;\n  uint8_t *paramBuf = (uint8_t *)calloc(\n      1, sizeof(CrxBandParam) + sizeof(int32_t) * paramLength + progrDataSize);\n\n  if (!paramBuf)\n    return -1;\n\n  *param = (CrxBandParam *)paramBuf;\n\n  paramBuf += sizeof(CrxBandParam);\n\n  (*param)->paramData = (int32_t *)paramBuf;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int crxParamInit(\n#ifdef LIBRAW_CR3_MEMPOOL\n\tlibraw_memmgr&  mm,\n#endif\t\n\tCrxBandParam **param, uint64_t subbandMdatOffset,\n                 uint64_t subbandDataSize, uint32_t subbandWidth,\n                 uint32_t subbandHeight, int32_t supportsPartial,\n                 uint32_t roundedBitsMask, LibRaw_abstract_datastream *input)\n{\n  int32_t progrDataSize = supportsPartial ? 0 : sizeof(int32_t) * subbandWidth;\n  int32_t paramLength = 2 * subbandWidth + 4;\n  uint8_t *paramBuf = (uint8_t *)\n#ifdef LIBRAW_CR3_MEMPOOL\n\t  mm.\n#endif\n\t  calloc(\n      1, sizeof(CrxBandParam) + sizeof(int32_t) * paramLength + progrDataSize);\n\n  if (!paramBuf)\n    return -1;\n\n  *param = (CrxBandParam *)paramBuf;\n\n  paramBuf += sizeof(CrxBandParam);\n\n  (*param)->paramData = (int32_t *)paramBuf;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "HexInStream::HexInStream(InStream& is, int bufSize_)\n: bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_LEN), offset(0), in_stream(is)\n{\n  ptr = end = start = new U8[bufSize];\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "HexInStream::HexInStream(InStream& is, size_t bufSize_)\n: bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_LEN), offset(0), in_stream(is)\n{\n  ptr = end = start = new U8[bufSize];\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t    case '_':\n\t      us[j++] = '_';\n\t      break;\n\t    default:\n\t      us[j++] = '_';\n\t      i--;\n\t      break;\n\t    }\n\t}\n      else\n\tus[j++] = caprtl_to_unicode[(int) s[i]];\n    }\n\n  return j;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t    case '_':\n\t      us[j++] = '_';\n\t      break;\n\t    default:\n\t      us[j++] = '_';\n\t      i--;\n\t      break;\n\t    }\n\t}\n      else\n      {\n        if ((int)s[i] < 0)\n          us[j++] = '?';\n        else\n          us[j++] = caprtl_to_unicode[(int) s[i]];\n      }\n    }\n\n  return j;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      printf(\"%s\\n\", *argv);\n      if ((chm = chmd->open(chmd, *argv))) {\n\n\t/* build an ordered list of files for maximum extraction speed */\n\tfor (numf=0, file=chm->files; file; file = file->next) numf++;\n\tif ((f = (struct mschmd_file **) calloc(numf, sizeof(struct mschmd_file *)))) {\n\t  for (i=0, file=chm->files; file; file = file->next) f[i++] = file;\n\t  qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);\n\n\t  for (i = 0; i < numf; i++) {\n\t    char *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0);\n\t    printf(\"Extracting %s\\n\", outname);\n\t    ensure_filepath(outname);\n\t    if (chmd->extract(chmd, f[i], outname)) {\n\t      printf(\"%s: extract error on \\\"%s\\\": %s\\n\",\n\t\t     *argv, f[i]->filename, ERROR(chmd));\n\t    }\n\t    free(outname);\n\t  }\n\t  free(f);\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      printf(\"%s\\n\", *argv);\n      if ((chm = chmd->open(chmd, *argv))) {\n\n\t/* build an ordered list of files for maximum extraction speed */\n\tfor (numf=0, file=chm->files; file; file = file->next) numf++;\n\tif ((f = (struct mschmd_file **) calloc(numf, sizeof(struct mschmd_file *)))) {\n\t  for (i=0, file=chm->files; file; file = file->next) f[i++] = file;\n\t  qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);\n\n\t  for (i = 0; i < numf; i++) {\n\t    char *outname = create_output_name(f[i]->filename);\n\t    printf(\"Extracting %s\\n\", outname);\n\t    ensure_filepath(outname);\n\t    if (chmd->extract(chmd, f[i], outname)) {\n\t      printf(\"%s: extract error on \\\"%s\\\": %s\\n\",\n\t\t     *argv, f[i]->filename, ERROR(chmd));\n\t    }\n\t    free(outname);\n\t  }\n\t  free(f);\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    size_t count,\n    int flags,\n    const struct oe_sockaddr* dest_addr,\n    oe_socklen_t addrlen)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    if (!sock || (count && !buf))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_sendto_ocall(\n            &ret,\n            sock->host_fd,\n            buf,\n            count,\n            flags,\n            (struct oe_sockaddr*)dest_addr,\n            addrlen) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    size_t count,\n    int flags,\n    const struct oe_sockaddr* dest_addr,\n    oe_socklen_t addrlen)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    /*\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendto.html\n     * for more detail.\n     */\n    if (!sock || (count && !buf) || count > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_sendto_ocall(\n            &ret,\n            sock->host_fd,\n            buf,\n            count,\n            flags,\n            (struct oe_sockaddr*)dest_addr,\n            addrlen) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The return value should not exceed count.\n     */\n    if (ret > (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t\tdefault:\n\t\t\tif (hint)\n\t\t\t\tbreak;\n\n\t\t\tresult = L2CAP_CONF_UNKNOWN;\n\t\t\t*((u8 *) ptr++) = type;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (result == L2CAP_CONF_SUCCESS) {\n\t\t/* Configure output options and let the other side know\n\t\t * which ones we don't like. */\n\n\t\tif (rfc.mode == L2CAP_MODE_BASIC) {\n\t\t\tif (mtu < pi->omtu)\n\t\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\t\telse {\n\t\t\t\tpi->omtu = mtu;\n\t\t\t\tpi->conf_state |= L2CAP_CONF_OUTPUT_DONE;\n\t\t\t}\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);\n\t\t} else {\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\tmemset(&rfc, 0, sizeof(rfc));\n\t\t\trfc.mode = L2CAP_MODE_BASIC;\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\t\t}\n\t}\n\n\trsp->scid   = cpu_to_le16(pi->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(0x0000);\n\n\treturn ptr - data;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tdefault:\n\t\t\tif (hint)\n\t\t\t\tbreak;\n\n\t\t\tresult = L2CAP_CONF_UNKNOWN;\n\t\t\t*((u8 *) ptr++) = type;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pi->num_conf_rsp || pi->num_conf_req)\n\t\tgoto done;\n\n\tswitch (pi->mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tpi->conf_state |= L2CAP_CONF_STATE2_DEVICE;\n\t\tif (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask))\n\t\t\treturn -ECONNREFUSED;\n\t\tbreak;\n\tdefault:\n\t\tpi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);\n\t\tbreak;\n\t}\n\ndone:\n\tif (pi->mode != rfc.mode) {\n\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\trfc.mode = pi->mode;\n\n\t\tif (pi->num_conf_rsp == 1)\n\t\t\treturn -ECONNREFUSED;\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\t}\n\n\n\tif (result == L2CAP_CONF_SUCCESS) {\n\t\t/* Configure output options and let the other side know\n\t\t * which ones we don't like. */\n\n\t\tif (mtu < L2CAP_DEFAULT_MIN_MTU)\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\telse {\n\t\t\tpi->omtu = mtu;\n\t\t\tpi->conf_state |= L2CAP_CONF_MTU_DONE;\n\t\t}\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);\n\n\t\tswitch (rfc.mode) {\n\t\tcase L2CAP_MODE_BASIC:\n\t\t\tpi->fcs = L2CAP_FCS_NONE;\n\t\t\tpi->conf_state |= L2CAP_CONF_MODE_DONE;\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_ERTM:\n\t\t\tpi->remote_tx_win = rfc.txwin_size;\n\t\t\tpi->remote_max_tx = rfc.max_transmit;\n\t\t\tpi->max_pdu_size = rfc.max_pdu_size;\n\n\t\t\trfc.retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;\n\t\t\trfc.monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;\n\n\t\t\tpi->conf_state |= L2CAP_CONF_MODE_DONE;\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tpi->remote_tx_win = rfc.txwin_size;\n\t\t\tpi->max_pdu_size = rfc.max_pdu_size;\n\n\t\t\tpi->conf_state |= L2CAP_CONF_MODE_DONE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\tmemset(&rfc, 0, sizeof(rfc));\n\t\t\trfc.mode = pi->mode;\n\t\t}\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\n\t\tif (result == L2CAP_CONF_SUCCESS)\n\t\t\tpi->conf_state |= L2CAP_CONF_OUTPUT_DONE;\n\t}\n\trsp->scid   = cpu_to_le16(pi->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(0x0000);\n\n\treturn ptr - data;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tut8 *buf = calloc (section->size, 1);\n\t\tif (!buf) {\n\t\t\tbreak;\n\t\t}\n\t\tif (r_buf_read_at (obj->cache_buf, section->paddr + paddr, buf, section->size) < section->size) {\n\t\t\tfree (buf);\n\t\t\tbreak;\n\t\t}\n\t\tint j;\n\t\tint count = 0;\n\t\tfor (j = 0; j < section->size; j += 8) {\n\t\t\tut64 addr64 = K_RPTR (buf + j);\n\t\t\tut64 paddr64 = section->paddr + paddr + j;\n\t\t\tif (mode == R_K_CONSTRUCTOR_TO_ENTRY) {\n\t\t\t\tRBinAddr *ba = newEntry (paddr64, addr64, type);\n\t\t\t\tr_list_append (ret, ba);\n\t\t\t} else if (mode == R_K_CONSTRUCTOR_TO_SYMBOL) {\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tif (!sym) {\n\t\t\t\t\tbreak;\n\t\t\t\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tut8 *buf = calloc (section->size, 1);\n\t\tif (!buf) {\n\t\t\tbreak;\n\t\t}\n\t\tif (r_buf_read_at (obj->cache_buf, section->paddr + paddr, buf, section->size) < section->size) {\n\t\t\tfree (buf);\n\t\t\tbreak;\n\t\t}\n\t\tint j;\n\t\tint count = 0;\n\t\tfor (j = 0; j + 7 < section->size; j += 8) {\n\t\t\tut64 addr64 = K_RPTR (buf + j);\n\t\t\tut64 paddr64 = section->paddr + paddr + j;\n\t\t\tif (mode == R_K_CONSTRUCTOR_TO_ENTRY) {\n\t\t\t\tRBinAddr *ba = newEntry (paddr64, addr64, type);\n\t\t\t\tr_list_append (ret, ba);\n\t\t\t} else if (mode == R_K_CONSTRUCTOR_TO_SYMBOL) {\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tif (!sym) {\n\t\t\t\t\tbreak;\n\t\t\t\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n\tstruct thread_struct *prev = &prev_p->thread;\n\tstruct thread_struct *next = &next_p->thread;\n\tint cpu = smp_processor_id();\n\tstruct tss_struct *tss = &per_cpu(init_tss, cpu);\n\tunsigned fsindex, gsindex;\n\tfpu_switch_t fpu;\n\n\tfpu = switch_fpu_prepare(prev_p, next_p, cpu);\n\n\t/*\n\t * Reload esp0, LDT and the page table pointer:\n\t */\n\tload_sp0(tss, next);\n\n\t/*\n\t * Switch DS and ES.\n\t * This won't pick up thread selector changes, but I guess that is ok.\n\t */\n\tsavesegment(es, prev->es);\n\tif (unlikely(next->es | prev->es))\n\t\tloadsegment(es, next->es);\n\n\tsavesegment(ds, prev->ds);\n\tif (unlikely(next->ds | prev->ds))\n\t\tloadsegment(ds, next->ds);\n\n\n\t/* We must save %fs and %gs before load_TLS() because\n\t * %fs and %gs may be cleared by load_TLS().\n\t *\n\t * (e.g. xen_load_tls())\n\t */\n\tsavesegment(fs, fsindex);\n\tsavesegment(gs, gsindex);\n\n\tload_TLS(next, cpu);\n\n\t/*\n\t * Leave lazy mode, flushing any hypercalls made here.\n\t * This must be done before restoring TLS segments so\n\t * the GDT and LDT are properly updated, and must be\n\t * done before math_state_restore, so the TS bit is up\n\t * to date.\n\t */\n\tarch_end_context_switch(next_p);\n\n\t/*\n\t * Switch FS and GS.\n\t *\n\t * Segment register != 0 always requires a reload.  Also\n\t * reload when it has changed.  When prev process used 64bit\n\t * base always reload to avoid an information leak.\n\t */\n\tif (unlikely(fsindex | next->fsindex | prev->fs)) {\n\t\tloadsegment(fs, next->fsindex);\n\t\t/*\n\t\t * Check if the user used a selector != 0; if yes\n\t\t *  clear 64bit base, since overloaded base is always\n\t\t *  mapped to the Null selector\n\t\t */\n\t\tif (fsindex)\n\t\t\tprev->fs = 0;\n\t}\n\t/* when next process has a 64bit base use it */\n\tif (next->fs)\n\t\twrmsrl(MSR_FS_BASE, next->fs);\n\tprev->fsindex = fsindex;\n\n\tif (unlikely(gsindex | next->gsindex | prev->gs)) {\n\t\tload_gs_index(next->gsindex);\n\t\tif (gsindex)\n\t\t\tprev->gs = 0;\n\t}\n\tif (next->gs)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, next->gs);\n\tprev->gsindex = gsindex;\n\n\tswitch_fpu_finish(next_p, fpu);\n\n\t/*",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n\tstruct thread_struct *prev = &prev_p->thread;\n\tstruct thread_struct *next = &next_p->thread;\n\tint cpu = smp_processor_id();\n\tstruct tss_struct *tss = &per_cpu(init_tss, cpu);\n\tunsigned fsindex, gsindex;\n\tfpu_switch_t fpu;\n\n\tfpu = switch_fpu_prepare(prev_p, next_p, cpu);\n\n\t/* Reload esp0 and ss1. */\n\tload_sp0(tss, next);\n\n\t/* We must save %fs and %gs before load_TLS() because\n\t * %fs and %gs may be cleared by load_TLS().\n\t *\n\t * (e.g. xen_load_tls())\n\t */\n\tsavesegment(fs, fsindex);\n\tsavesegment(gs, gsindex);\n\n\t/*\n\t * Load TLS before restoring any segments so that segment loads\n\t * reference the correct GDT entries.\n\t */\n\tload_TLS(next, cpu);\n\n\t/*\n\t * Leave lazy mode, flushing any hypercalls made here.  This\n\t * must be done after loading TLS entries in the GDT but before\n\t * loading segments that might reference them, and and it must\n\t * be done before math_state_restore, so the TS bit is up to\n\t * date.\n\t */\n\tarch_end_context_switch(next_p);\n\n\t/* Switch DS and ES.\n\t *\n\t * Reading them only returns the selectors, but writing them (if\n\t * nonzero) loads the full descriptor from the GDT or LDT.  The\n\t * LDT for next is loaded in switch_mm, and the GDT is loaded\n\t * above.\n\t *\n\t * We therefore need to write new values to the segment\n\t * registers on every context switch unless both the new and old\n\t * values are zero.\n\t *\n\t * Note that we don't need to do anything for CS and SS, as\n\t * those are saved and restored as part of pt_regs.\n\t */\n\tsavesegment(es, prev->es);\n\tif (unlikely(next->es | prev->es))\n\t\tloadsegment(es, next->es);\n\n\tsavesegment(ds, prev->ds);\n\tif (unlikely(next->ds | prev->ds))\n\t\tloadsegment(ds, next->ds);\n\n\t/*\n\t * Switch FS and GS.\n\t *\n\t * These are even more complicated than FS and GS: they have\n\t * 64-bit bases are that controlled by arch_prctl.  Those bases\n\t * only differ from the values in the GDT or LDT if the selector\n\t * is 0.\n\t *\n\t * Loading the segment register resets the hidden base part of\n\t * the register to 0 or the value from the GDT / LDT.  If the\n\t * next base address zero, writing 0 to the segment register is\n\t * much faster than using wrmsr to explicitly zero the base.\n\t *\n\t * The thread_struct.fs and thread_struct.gs values are 0\n\t * if the fs and gs bases respectively are not overridden\n\t * from the values implied by fsindex and gsindex.  They\n\t * are nonzero, and store the nonzero base addresses, if\n\t * the bases are overridden.\n\t *\n\t * (fs != 0 && fsindex != 0) || (gs != 0 && gsindex != 0) should\n\t * be impossible.\n\t *\n\t * Therefore we need to reload the segment registers if either\n\t * the old or new selector is nonzero, and we need to override\n\t * the base address if next thread expects it to be overridden.\n\t *\n\t * This code is unnecessarily slow in the case where the old and\n\t * new indexes are zero and the new base is nonzero -- it will\n\t * unnecessarily write 0 to the selector before writing the new\n\t * base address.\n\t *\n\t * Note: This all depends on arch_prctl being the only way that\n\t * user code can override the segment base.  Once wrfsbase and\n\t * wrgsbase are enabled, most of this code will need to change.\n\t */\n\tif (unlikely(fsindex | next->fsindex | prev->fs)) {\n\t\tloadsegment(fs, next->fsindex);\n\n\t\t/*\n\t\t * If user code wrote a nonzero value to FS, then it also\n\t\t * cleared the overridden base address.\n\t\t *\n\t\t * XXX: if user code wrote 0 to FS and cleared the base\n\t\t * address itself, we won't notice and we'll incorrectly\n\t\t * restore the prior base address next time we reschdule\n\t\t * the process.\n\t\t */\n\t\tif (fsindex)\n\t\t\tprev->fs = 0;\n\t}\n\tif (next->fs)\n\t\twrmsrl(MSR_FS_BASE, next->fs);\n\tprev->fsindex = fsindex;\n\n\tif (unlikely(gsindex | next->gsindex | prev->gs)) {\n\t\tload_gs_index(next->gsindex);\n\n\t\t/* This works (and fails) the same way as fsindex above. */\n\t\tif (gsindex)\n\t\t\tprev->gs = 0;\n\t}\n\tif (next->gs)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, next->gs);\n\tprev->gsindex = gsindex;\n\n\tswitch_fpu_finish(next_p, fpu);\n\n\t/*",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int TLSInStream::readTLS(U8* buf, int len, bool wait)\n{\n  int n;\n\n  n = in->check(1, 1, wait);\n  if (n == 0)\n    return 0;\n\n  n = gnutls_record_recv(session, (void *) buf, len);\n  if (n == GNUTLS_E_INTERRUPTED || n == GNUTLS_E_AGAIN)\n    return 0;\n\n  if (n < 0) throw TLSException(\"readTLS\", n);\n\n  return n;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "size_t TLSInStream::readTLS(U8* buf, size_t len, bool wait)\n{\n  int n;\n\n  n = in->check(1, 1, wait);\n  if (n == 0)\n    return 0;\n\n  n = gnutls_record_recv(session, (void *) buf, len);\n  if (n == GNUTLS_E_INTERRUPTED || n == GNUTLS_E_AGAIN)\n    return 0;\n\n  if (n < 0) throw TLSException(\"readTLS\", n);\n\n  return n;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static s16 swf_get_s16(SWFReader *read)\n{\n\ts16 val;\n\tu8 v1;\n\tv1 = swf_read_int(read, 8);\n\tval = swf_read_sint(read, 8);\n\tval = (val<<8)&0xFF00;\n\tval |= (v1&0xFF);\n\treturn val;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static s16 swf_get_s16(SWFReader *read)\n{\n\treturn (s16) gf_bs_read_u16_le(read->bs);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      {\n         //Decrypt the Base64-encoded string\n         error = base64Decode(token, osStrlen(token), token, &n);\n\n         //Successful decoding?\n         if(!error)\n         {\n            //Properly terminate the string\n            token[n] = '\\0';\n            //Check whether a separator is present\n            separator = strchr(token, ':');\n\n            //Separator found?\n            if(separator != NULL)\n            {\n               //Split the line\n               *separator = '\\0';\n\n               //Save user name\n               strSafeCopy(connection->request.auth.user,\n                  token, HTTP_SERVER_USERNAME_MAX_LEN);\n\n      //Use the relevant authentication scheme\n      connection->request.auth.mode = HTTP_AUTH_MODE_DIGEST;\n      //Get the first parameter\n      token = osStrtok_r(NULL, \",\", &p);\n\n      //Parse the Authorization header field\n      while(token != NULL)\n      {\n         //Check whether a separator is present\n         separator = strchr(token, '=');\n\n         //Separator found?\n         if(separator != NULL)\n         {\n            //Split the string\n            *separator = '\\0';\n\n            //Get field name and value\n            name = strTrimWhitespace(token);\n            value = strTrimWhitespace(separator + 1);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      {\n         //Decrypt the Base64-encoded string\n         error = base64Decode(token, osStrlen(token), token, &n);\n\n         //Successful decoding?\n         if(!error)\n         {\n            //Properly terminate the string\n            token[n] = '\\0';\n            //Check whether a separator is present\n            separator = osStrchr(token, ':');\n\n            //Separator found?\n            if(separator != NULL)\n            {\n               //Split the line\n               *separator = '\\0';\n\n               //Save user name\n               strSafeCopy(connection->request.auth.user,\n                  token, HTTP_SERVER_USERNAME_MAX_LEN);\n\n      //Use the relevant authentication scheme\n      connection->request.auth.mode = HTTP_AUTH_MODE_DIGEST;\n      //Get the first parameter\n      token = osStrtok_r(NULL, \",\", &p);\n\n      //Parse the Authorization header field\n      while(token != NULL)\n      {\n         //Check whether a separator is present\n         separator = osStrchr(token, '=');\n\n         //Separator found?\n         if(separator != NULL)\n         {\n            //Split the string\n            *separator = '\\0';\n\n            //Get field name and value\n            name = strTrimWhitespace(token);\n            value = strTrimWhitespace(separator + 1);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);\n        if (!hashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \"bad DT_HASH %#x\", v_hsh);\n            throwCantPack(msg);\n        }\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket]; (void)chains;\n\n        unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        if (!nbucket\n        || (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)  // FIXME: weak\n        || ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2  // headers\n                + sizeof(*buckets)*nbucket  // buckets\n                + sizeof(*chains) *nbucket  // chains\n           ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \"bad DT_HASH nbucket=%#x  len=%#x\",\n                nbucket, (v_sym - v_hsh));\n            throwCantPack(msg);\n            throwCantPack(msg);\n        }\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;\n      //unsigned     const *const gashend = &hasharr[n_bucket];  // minimum\n\n        upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);\n        if (!n_bucket || !n_bitmask\n        || (-1+ n_bitmask) & n_bitmask  // not a power of 2\n        || 8*sizeof(upx_uint64_t) <= gnu_shift  // shifted result always == 0\n        || (n_bucket>>30)  // fie on fuzzers\n        || (n_bitmask>>30)\n        || (file_size/sizeof(unsigned)) <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)  // FIXME: weak\n        // FIXME: next test does work for Android?\n        || ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4  // headers\n                + sizeof(*bitmask)*n_bitmask  // bitmask\n                + sizeof(*buckets)*n_bucket  // buckets\n                + sizeof(*hasharr)*n_bucket  // hasharr",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);\n        if (!hashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \"bad DT_HASH %#x\", v_hsh);\n            throwCantPack(msg);\n        }\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket]; (void)chains;\n\n        unsigned const v_sym = !x_sym ? 0 : get_te32(&dynp0[-1+ x_sym].d_val);\n        if (!nbucket || !v_sym\n        || (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)  // FIXME: weak\n        || ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2  // headers\n                + sizeof(*buckets)*nbucket  // buckets\n                + sizeof(*chains) *nbucket  // chains\n           ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \"bad DT_HASH nbucket=%#x  len=%#x\",\n                nbucket, (v_sym - v_hsh));\n            throwCantPack(msg);\n            throwCantPack(msg);\n        }\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;\n      //unsigned     const *const gashend = &hasharr[n_bucket];  // minimum\n\n        upx_uint64_t const v_sym = !x_sym ? 0 : get_te64(&dynp0[-1+ x_sym].d_val);\n        if (!n_bucket || !n_bitmask || !v_sym\n        || (-1+ n_bitmask) & n_bitmask  // not a power of 2\n        || 8*sizeof(upx_uint64_t) <= gnu_shift  // shifted result always == 0\n        || (n_bucket>>30)  // fie on fuzzers\n        || (n_bitmask>>30)\n        || (file_size/sizeof(unsigned)) <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)  // FIXME: weak\n        // FIXME: next test does work for Android?\n        || ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4  // headers\n                + sizeof(*bitmask)*n_bitmask  // bitmask\n                + sizeof(*buckets)*n_bucket  // buckets\n                + sizeof(*hasharr)*n_bucket  // hasharr",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n\tint count, i;\n\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > XFS_ACL_MAX_ENTRIES)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n\tunsigned int count, i;\n\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > XFS_ACL_MAX_ENTRIES)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t/*\n\t * Log the unexpected fixups, and then pass them on to perf.\n\t *\n\t * We intentionally don't report the expected cases to perf as\n\t * otherwise the trapped I/O case will skew the results too much\n\t * to be useful.\n\t */\n\tif (!expected) {\n\t\tunaligned_fixups_notify(current, instruction, regs);\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0,\n\t\t\t      regs, address);\n\t}\n\n\tret = -EFAULT;\n\tswitch (instruction&0xF000) {\n\tcase 0x0000:\n\t\tif (instruction==0x000B) {\n\t\t\t/* rts */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\t/*\n\t * Log the unexpected fixups, and then pass them on to perf.\n\t *\n\t * We intentionally don't report the expected cases to perf as\n\t * otherwise the trapped I/O case will skew the results too much\n\t * to be useful.\n\t */\n\tif (!expected) {\n\t\tunaligned_fixups_notify(current, instruction, regs);\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1,\n\t\t\t      regs, address);\n\t}\n\n\tret = -EFAULT;\n\tswitch (instruction&0xF000) {\n\tcase 0x0000:\n\t\tif (instruction==0x000B) {\n\t\t\t/* rts */\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int DSA_verify(int type, const unsigned char *dgst, int dgst_len,\n\t     const unsigned char *sigbuf, int siglen, DSA *dsa)\n\t{\n\tDSA_SIG *s;\n\tint ret=-1;\n\n\ts = DSA_SIG_new();\n\tif (s == NULL) return(ret);\n\tif (d2i_DSA_SIG(&s,&sigbuf,siglen) == NULL) goto err;\n\tret=DSA_do_verify(dgst,dgst_len,s,dsa);\nerr:\n\tDSA_SIG_free(s);\n\treturn(ret);\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int DSA_verify(int type, const unsigned char *dgst, int dgst_len,\n\t     const unsigned char *sigbuf, int siglen, DSA *dsa)\n\t{\n\tDSA_SIG *s;\n\tconst unsigned char *p = sigbuf;\n\tunsigned char *der = NULL;\n\tint derlen = -1;\n\tint ret=-1;\n\n\ts = DSA_SIG_new();\n\tif (s == NULL) return(ret);\n\tif (d2i_DSA_SIG(&s,&p,siglen) == NULL) goto err;\n\t/* Ensure signature uses DER and doesn't have trailing garbage */\n\tderlen = i2d_DSA_SIG(s, &der);\n\tif (derlen != siglen || memcmp(sigbuf, der, derlen))\n\t\tgoto err;\n\tret=DSA_do_verify(dgst,dgst_len,s,dsa);\nerr:\n\tif (derlen > 0)\n\t\t{\n\t\tOPENSSL_cleanse(der, derlen);\n\t\tOPENSSL_free(der);\n\t\t}\n\tDSA_SIG_free(s);\n\treturn(ret);\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "getlogin_r (name, name_len)\n     char *name;\n     size_t name_len;\n{\n  char tty_pathname[2 + 2 * NAME_MAX];\n  char *real_tty_path = tty_pathname;\n  int result = 0;\n  struct utmp *ut, line, buffer;\n\n  {\n    int d = __open (\"/dev/tty\", 0);\n    if (d < 0)\n      return errno;\n\n    result = __ttyname_r (d, real_tty_path, sizeof (tty_pathname));\n    (void) __close (d);\n\n    if (result != 0)\n      {\n\t__set_errno (result);\n\treturn result;\n      }\n  }\n\n  real_tty_path += 5;\t\t/* Remove \"/dev/\".  */\n\n  __setutent ();\n  strncpy (line.ut_line, real_tty_path, sizeof line.ut_line);\n  if (__getutline_r (&line, &buffer, &ut) < 0)\n    {\n      if (errno == ESRCH)\n\t/* The caller expects ENOENT if nothing is found.  */\n\tresult = ENOENT;\n      else\n\tresult = errno;\n    }\n  else\n    {\n      size_t needed = strlen (ut->ut_line) + 1;\n\n      if (needed < name_len)\n\t{\n\t  __set_errno (ERANGE);\n\t  result = ERANGE;\n\t}\n      else\n\t{\n\t  memcpy (name, ut->ut_line, needed);\n\t  result = 0;\n\t}\n    }\n  __endutent ();\n\n  return result;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "getlogin_r (name, name_len)\n     char *name;\n     size_t name_len;\n{\n  char tty_pathname[2 + 2 * NAME_MAX];\n  char *real_tty_path = tty_pathname;\n  int result = 0;\n  struct utmp *ut, line, buffer;\n\n  /* Get name of tty connected to fd 0.  Return if not a tty or\n     if fd 0 isn't open.  Note that a lot of documentation says that\n     getlogin() is based on the controlling terminal---what they\n     really mean is \"the terminal connected to standard input\".  The\n     getlogin() implementation of DEC Unix, SunOS, Solaris, HP-UX all\n     return NULL if fd 0 has been closed, so this is the compatible\n     thing to do.  Note that ttyname(open(\"/dev/tty\")) on those\n     systems returns /dev/tty, so that is not a possible solution for\n     getlogin().  */\n\n  result = __ttyname_r (0, real_tty_path, sizeof (tty_pathname));\n  \n  if (result != 0)\n    return result;\n\n  real_tty_path += 5;\t\t/* Remove \"/dev/\".  */\n\n  __setutent ();\n  strncpy (line.ut_line, real_tty_path, sizeof line.ut_line);\n  if (__getutline_r (&line, &buffer, &ut) < 0)\n    {\n      if (errno == ESRCH)\n\t/* The caller expects ENOENT if nothing is found.  */\n\tresult = ENOENT;\n      else\n\tresult = errno;\n    }\n  else\n    {\n      size_t needed = strlen (ut->ut_user) + 1;\n\n      if (needed > name_len)\n\t{\n\t  __set_errno (ERANGE);\n\t  result = ERANGE;\n\t}\n      else\n\t{\n\t  memcpy (name, ut->ut_user, needed);\n\t  result = 0;\n\t}\n    }\n  __endutent ();\n\n  return result;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {\n\tD eprintf (\"Dragons at 0x%x\\n\", off);\n\tut64 size = r_buf_size (buf);\n\tif (off >= size) {\n\t\treturn NULL;\n\t}\n\tsize -= off;\n\tif (!size) {\n\t\treturn NULL;\n\t}\n\tut8 *b = malloc (size);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tint available = r_buf_read_at (buf, off, b, size);\n\tif (available != size) {\n\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\treturn NULL;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {\n\tD eprintf (\"Dragons at 0x%x\\n\", off);\n\tst64 size = r_buf_size (buf);\n\tif (off >= size) {\n\t\treturn NULL;\n\t}\n\tsize -= off;\n\tif (!size) {\n\t\treturn NULL;\n\t}\n\tif (size < 32) {\n\t\treturn NULL;\n\t}\n\tut8 *b = malloc (size);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tint available = r_buf_read_at (buf, off, b, size);\n\tif (available != size) {\n\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\treturn NULL;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tireq->snd_wscale\t= tcp_opt.snd_wscale;\n\tireq->sack_ok\t\t= tcp_opt.sack_ok;\n\tireq->wscale_ok\t\t= tcp_opt.wscale_ok;\n\tireq->tstamp_ok\t\t= tcp_opt.saw_tstamp;\n\treq->ts_recent\t\t= tcp_opt.saw_tstamp ? tcp_opt.rcv_tsval : 0;\n\n\t/* We throwed the options of the initial SYN away, so we hope\n\t * the ACK carries the same options again (see RFC1122 4.2.3.8)\n\t */\n\tif (opt && opt->optlen) {\n\t\tint opt_size = sizeof(struct ip_options) + opt->optlen;\n\n\t\tireq->opt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (ireq->opt != NULL && ip_options_echo(ireq->opt, skb)) {\n\t\t\tkfree(ireq->opt);\n\t\t\tireq->opt = NULL;\n\t\t}\n\t}\n\n\tif (security_inet_conn_request(sk, skb, req)) {\n\t\treqsk_free(req);\n\t\tgoto out;\n\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tireq->snd_wscale\t= tcp_opt.snd_wscale;\n\tireq->sack_ok\t\t= tcp_opt.sack_ok;\n\tireq->wscale_ok\t\t= tcp_opt.wscale_ok;\n\tireq->tstamp_ok\t\t= tcp_opt.saw_tstamp;\n\treq->ts_recent\t\t= tcp_opt.saw_tstamp ? tcp_opt.rcv_tsval : 0;\n\n\t/* We throwed the options of the initial SYN away, so we hope\n\t * the ACK carries the same options again (see RFC1122 4.2.3.8)\n\t */\n\tif (opt && opt->optlen) {\n\t\tint opt_size = sizeof(struct ip_options_rcu) + opt->optlen;\n\n\t\tireq->opt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (ireq->opt != NULL && ip_options_echo(&ireq->opt->opt, skb)) {\n\t\t\tkfree(ireq->opt);\n\t\t\tireq->opt = NULL;\n\t\t}\n\t}\n\n\tif (security_inet_conn_request(sk, skb, req)) {\n\t\treqsk_free(req);\n\t\tgoto out;\n\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "mrb_proc_init_copy(mrb_state *mrb, mrb_value self)\n{\n  mrb_value proc = mrb_get_arg1(mrb);\n\n  if (!mrb_proc_p(proc)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"not a proc\");\n  }\n  mrb_proc_copy(mrb_proc_ptr(self), mrb_proc_ptr(proc));\n  return self;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "mrb_proc_init_copy(mrb_state *mrb, mrb_value self)\n{\n  mrb_value proc = mrb_get_arg1(mrb);\n\n  if (!mrb_proc_p(proc)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"not a proc\");\n  }\n  mrb_proc_copy(mrb, mrb_proc_ptr(self), mrb_proc_ptr(proc));\n  return self;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "           this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        dialog.setCheckBox(new QCheckBox(tr(\"Do not show this anymore.\", \"Automatic upgrade check dialog\")));\n        Settings.setCheckUpgradeAutomatic(dialog.exec() == QMessageBox::Yes);\n        if (dialog.checkBox()->isChecked())\n            Settings.setAskUpgradeAutomatic(false);\n    }\n    showStatusMessage(\"Checking for upgrade...\");\n    m_network.get(QNetworkRequest(QUrl(\"http://check.shotcut.org/version.json\")));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "           this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        dialog.setCheckBox(new QCheckBox(tr(\"Do not show this anymore.\", \"Automatic upgrade check dialog\")));\n        Settings.setCheckUpgradeAutomatic(dialog.exec() == QMessageBox::Yes);\n        if (dialog.checkBox()->isChecked())\n            Settings.setAskUpgradeAutomatic(false);\n    }\n    showStatusMessage(\"Checking for upgrade...\");\n    m_network.get(QNetworkRequest(QUrl(\"https://check.shotcut.org/version.json\")));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "            goto end;\n        }\n    } else {\n        sixel_allocator_ref(allocator);\n    }\n\n    if (ncolors < 0) {\n        ncolors = 256;\n        quality_mode = SIXEL_QUALITY_HIGHCOLOR;\n    } else {\n        if (ncolors > SIXEL_PALETTE_MAX) {\n            ncolors = 256;\n        } else if (ncolors < 2) {\n            ncolors = 2;\n        }\n        quality_mode = SIXEL_QUALITY_LOW;\n    }\n    headsize = sizeof(sixel_dither_t);\n    datasize = (size_t)(ncolors * 3);\n    wholesize = headsize + datasize;\n\n    *ppdither = (sixel_dither_t *)sixel_allocator_malloc(allocator, wholesize);\n    if (*ppdither == NULL) {\n        sixel_allocator_unref(allocator);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        }\n    } else {\n        sixel_allocator_ref(allocator);\n    }\n\n    if (ncolors < 0) {\n        ncolors = 256;\n        quality_mode = SIXEL_QUALITY_HIGHCOLOR;\n    } else {\n        if (ncolors > SIXEL_PALETTE_MAX) {\n            status = SIXEL_BAD_INPUT;\n            ncolors = 256;\n        } else if (ncolors < 1) {\n            status = SIXEL_BAD_INPUT;\n            sixel_helper_set_additional_message(\n                \"sixel_dither_new: palette colors must be more than 0\");\n            goto end;\n        }\n        quality_mode = SIXEL_QUALITY_LOW;\n    }\n    headsize = sizeof(sixel_dither_t);\n    datasize = (size_t)(ncolors * 3);\n    wholesize = headsize + datasize;\n\n    *ppdither = (sixel_dither_t *)sixel_allocator_malloc(allocator, wholesize);\n    if (*ppdither == NULL) {\n        sixel_allocator_unref(allocator);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tmutex_lock(&key_construction_mutex);\n\n\t/* can't instantiate twice */\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\t/* instantiate the key */\n\t\tret = key->type->instantiate(key, prep);\n\n\t\tif (ret == 0) {\n\t\t\t/* mark the key as being instantiated */\n\t\t\tatomic_inc(&key->user->nikeys);\n\t\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\n\t\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\t\tawaken = 1;\n\n\t\t\t/* and link it into the destination keyring */\n\t\t\tif (keyring) {\n\t\t\t\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\t\t\t\tset_bit(KEY_FLAG_KEEP, &key->flags);\n\n\t\t\t\t__key_link(key, _edit);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tmutex_lock(&key_construction_mutex);\n\n\t/* can't instantiate twice */\n\tif (key->state == KEY_IS_UNINSTANTIATED) {\n\t\t/* instantiate the key */\n\t\tret = key->type->instantiate(key, prep);\n\n\t\tif (ret == 0) {\n\t\t\t/* mark the key as being instantiated */\n\t\t\tatomic_inc(&key->user->nikeys);\n\t\t\tmark_key_instantiated(key, 0);\n\n\t\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\t\tawaken = 1;\n\n\t\t\t/* and link it into the destination keyring */\n\t\t\tif (keyring) {\n\t\t\t\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\t\t\t\tset_bit(KEY_FLAG_KEEP, &key->flags);\n\n\t\t\t\t__key_link(key, _edit);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    case HEVC_NAL_BLA_N_LP:\n    case HEVC_NAL_IDR_W_RADL:\n    case HEVC_NAL_IDR_N_LP:\n    case HEVC_NAL_CRA_NUT:\n    case HEVC_NAL_RADL_N:\n    case HEVC_NAL_RADL_R:\n    case HEVC_NAL_RASL_N:\n    case HEVC_NAL_RASL_R:\n        ret = hls_slice_header(s);\n        if (ret < 0)\n            return ret;\n\n        if (\n            (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONINTRA && s->sh.slice_type != HEVC_SLICE_I) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONKEY && !IS_IRAP(s))) {\n            break;\n        }\n\n        if (s->sh.first_slice_in_pic_flag) {\n            if (s->ref) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Two slices reporting being the first in the same frame.\\n\");\n                goto fail;\n            }\n            if (s->max_ra == INT_MAX) {\n                if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {\n                    s->max_ra = s->poc;\n                } else {\n                    if (IS_IDR(s))\n                        s->max_ra = INT_MIN;\n                }\n            }\n\n            if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    case HEVC_NAL_IDR_W_RADL:\n    case HEVC_NAL_IDR_N_LP:\n    case HEVC_NAL_CRA_NUT:\n    case HEVC_NAL_RADL_N:\n    case HEVC_NAL_RADL_R:\n    case HEVC_NAL_RASL_N:\n    case HEVC_NAL_RASL_R:\n        ret = hls_slice_header(s);\n        if (ret < 0)\n            return ret;\n        if (ret == 1) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n\n        if (\n            (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONINTRA && s->sh.slice_type != HEVC_SLICE_I) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONKEY && !IS_IRAP(s))) {\n            break;\n        }\n\n        if (s->sh.first_slice_in_pic_flag) {\n            if (s->max_ra == INT_MAX) {\n                if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {\n                    s->max_ra = s->poc;\n                } else {\n                    if (IS_IDR(s))\n                        s->max_ra = INT_MIN;\n                }\n            }\n\n            if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "uint16_t enc28j60ReadPhyReg(NetInterface *interface, uint16_t address)\n{\n   uint16_t data;\n\n   //Write register address\n   enc28j60WriteReg(interface, ENC28J60_REG_MIREGADR, address & REG_ADDR_MASK);\n\n   //Start read operation\n   enc28j60WriteReg(interface, ENC28J60_REG_MICMD, MICMD_MIIRD);\n   //Wait for the read operation to complete\n   while((enc28j60ReadReg(interface, ENC28J60_REG_MISTAT) & MISTAT_BUSY) != 0)\n   {\n   }\n\n   //Clear command register\n   enc28j60WriteReg(interface, ENC28J60_REG_MICMD, 0);\n\n   //Read the lower 8 bits\n   data = enc28j60ReadReg(interface, ENC28J60_REG_MIRDL);\n   //Read the upper 8 bits\n   data |= enc28j60ReadReg(interface, ENC28J60_REG_MIRDH) << 8;\n\n   //Return register contents\n   return data;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "uint16_t enc28j60ReadPhyReg(NetInterface *interface, uint16_t address)\n{\n   uint16_t data;\n\n   //Write register address\n   enc28j60WriteReg(interface, ENC28J60_MIREGADR, address & REG_ADDR_MASK);\n\n   //Start read operation\n   enc28j60WriteReg(interface, ENC28J60_MICMD, ENC28J60_MICMD_MIIRD);\n   //Wait for the read operation to complete\n   while((enc28j60ReadReg(interface, ENC28J60_MISTAT) & ENC28J60_MISTAT_BUSY) != 0)\n   {\n   }\n\n   //Clear command register\n   enc28j60WriteReg(interface, ENC28J60_MICMD, 0);\n\n   //Read the lower 8 bits\n   data = enc28j60ReadReg(interface, ENC28J60_MIRDL);\n   //Read the upper 8 bits\n   data |= enc28j60ReadReg(interface, ENC28J60_MIRDH) << 8;\n\n   //Return register contents\n   return data;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static bool new_idmap_permitted(const struct file *file, \n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\t/* Allow mapping to your own filesystem ids */\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, current_fsuid()))\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, current_fsgid()))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* Allow anyone to set a mapping that doesn't require privilege */\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\n\t/* Allow the specified ids if we have the appropriate capability\n\t * (CAP_SETUID or CAP_SETGID) over the parent user namespace.",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static bool new_idmap_permitted(const struct file *file, \n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\t/* Allow mapping to your own filesystem ids */\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, file->f_cred->fsuid))\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, file->f_cred->fsgid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* Allow anyone to set a mapping that doesn't require privilege */\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\n\t/* Allow the specified ids if we have the appropriate capability\n\t * (CAP_SETUID or CAP_SETGID) over the parent user namespace.",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "R_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAnnotation *annotation = NULL;\n\tRBinJavaElementValuePair *evps = NULL;\n\tut64 offset = 0;\n\tannotation = R_NEW0 (RBinJavaAnnotation);\n\tif (!annotation) {\n\t\treturn NULL;\n\t}\n\t// (ut16) read and set annotation_value.type_idx;\n\tannotation->type_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\t// (ut16) read and set annotation_value.num_element_value_pairs;\n\tannotation->num_element_value_pairs = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tannotation->element_value_pairs = r_list_newf (r_bin_java_element_pair_free);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "R_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaElementValuePair *evps = NULL;\n\tut64 offset = 0;\n\tif (sz < 8) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAnnotation *annotation = R_NEW0 (RBinJavaAnnotation);\n\tif (!annotation) {\n\t\treturn NULL;\n\t}\n\t// (ut16) read and set annotation_value.type_idx;\n\tannotation->type_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\t// (ut16) read and set annotation_value.num_element_value_pairs;\n\tannotation->num_element_value_pairs = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tannotation->element_value_pairs = r_list_newf (r_bin_java_element_pair_free);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si)\n{\n\ts32 pps_id, num_ref_idx_l0_active_minus1 = 0, num_ref_idx_l1_active_minus1 = 0;\n\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif (pps_id > 255) return -1;\n\tsi->pps = &avc->pps[pps_id];\n\tif (!si->pps->slice_group_count) return -2;\n\tsi->sps = &avc->sps[si->pps->sps_id];\n\tif (!si->sps->log2_max_frame_num) return -2;\n\tavc->sps_active_idx = si->pps->sps_id;\n\tavc->pps_active_idx = pps_id;\n\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");\n\n\tsi->field_pic_flag = 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si)\n{\n\ts32 pps_id, num_ref_idx_l0_active_minus1 = 0, num_ref_idx_l1_active_minus1 = 0;\n\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id > 255)) return -1;\n\tsi->pps = &avc->pps[pps_id];\n\tif (!si->pps->slice_group_count) return -2;\n\tsi->sps = &avc->sps[si->pps->sps_id];\n\tif (!si->sps->log2_max_frame_num) return -2;\n\tavc->sps_active_idx = si->pps->sps_id;\n\tavc->pps_active_idx = pps_id;\n\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");\n\n\tsi->field_pic_flag = 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tcase SO_RCVLOWAT:\n\t\tv.val = sk->sk_rcvlowat;\n\t\tbreak;\n\n\tcase SO_SNDLOWAT:\n\t\tv.val = 1;\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tv.val = test_bit(SOCK_PASSCRED, &sock->flags) ? 1 : 0;\n\t\tbreak;\n\n\tcase SO_PEERCRED:\n\t{\n\t\tstruct ucred peercred;\n\t\tif (len > sizeof(peercred))\n\t\t\tlen = sizeof(peercred);\n\t\tcred_to_ucred(sk->sk_peer_pid, sk->sk_peer_cred, &peercred);\n\t\tif (copy_to_user(optval, &peercred, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/* Dubious BSD thing... Probably nobody even uses it, but\n\t * the UNIX standard wants it for whatever reason... -DaveM\n\t */\n\tcase SO_ACCEPTCONN:\n\t\tv.val = sk->sk_state == TCP_LISTEN;\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tv.val = test_bit(SOCK_PASSSEC, &sock->flags) ? 1 : 0;\n\t\tbreak;\n\n\tcase SO_PEERSEC:\n\t\treturn security_socket_getpeersec_stream(sock, optval, optlen, len);\n\n\tcase SO_MARK:\n\t\tv.val = sk->sk_mark;\n\t\tbreak;\n\n\tcase SO_RXQ_OVFL:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tcase SO_RCVLOWAT:\n\t\tv.val = sk->sk_rcvlowat;\n\t\tbreak;\n\n\tcase SO_SNDLOWAT:\n\t\tv.val = 1;\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tv.val = !!test_bit(SOCK_PASSCRED, &sock->flags);\n\t\tbreak;\n\n\tcase SO_PEERCRED:\n\t{\n\t\tstruct ucred peercred;\n\t\tif (len > sizeof(peercred))\n\t\t\tlen = sizeof(peercred);\n\t\tcred_to_ucred(sk->sk_peer_pid, sk->sk_peer_cred, &peercred);\n\t\tif (copy_to_user(optval, &peercred, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t/* Dubious BSD thing... Probably nobody even uses it, but\n\t * the UNIX standard wants it for whatever reason... -DaveM\n\t */\n\tcase SO_ACCEPTCONN:\n\t\tv.val = sk->sk_state == TCP_LISTEN;\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tv.val = !!test_bit(SOCK_PASSSEC, &sock->flags);\n\t\tbreak;\n\n\tcase SO_PEERSEC:\n\t\treturn security_socket_getpeersec_stream(sock, optval, optlen, len);\n\n\tcase SO_MARK:\n\t\tv.val = sk->sk_mark;\n\t\tbreak;\n\n\tcase SO_RXQ_OVFL:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int crxReadImageHeaders(crx_data_header_t *hdr, CrxImage *img, uint8_t *mdatPtr,\n                        uint32_t mdatSize)\n{\n  int nTiles = img->tileRows * img->tileCols;\n\n  if (!nTiles)\n    return -1;\n\n  if (!img->tiles)\n  {\n    img->tiles = (CrxTile *)malloc(\n        sizeof(CrxTile) * nTiles +\n        sizeof(CrxPlaneComp) * nTiles * img->nPlanes +\n        sizeof(CrxSubband) * nTiles * img->nPlanes * img->subbandCount);\n    if (!img->tiles)\n      return -1;\n\n    // memory areas in allocated chunk\n    CrxTile *tile = img->tiles;\n    CrxPlaneComp *comps = (CrxPlaneComp *)(tile + nTiles);\n    CrxSubband *bands = (CrxSubband *)(comps + img->nPlanes * nTiles);\n\n    for (int curTile = 0; curTile < nTiles; curTile++, tile++)\n    {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int crxReadImageHeaders(crx_data_header_t *hdr, CrxImage *img, uint8_t *mdatPtr,\n                        uint32_t mdatSize)\n{\n  int nTiles = img->tileRows * img->tileCols;\n\n  if (!nTiles)\n    return -1;\n\n  if (!img->tiles)\n  {\n    img->tiles = (CrxTile *)\n#ifdef LIBRAW_CR3_MEMPOOL\n\t\timg->memmgr.\n#endif\n\t\tcalloc(\n        sizeof(CrxTile) * nTiles +\n        sizeof(CrxPlaneComp) * nTiles * img->nPlanes +\n        sizeof(CrxSubband) * nTiles * img->nPlanes * img->subbandCount,1);\n    if (!img->tiles)\n      return -1;\n\n    // memory areas in allocated chunk\n    CrxTile *tile = img->tiles;\n    CrxPlaneComp *comps = (CrxPlaneComp *)(tile + nTiles);\n    CrxSubband *bands = (CrxSubband *)(comps + img->nPlanes * nTiles);\n\n    for (int curTile = 0; curTile < nTiles; curTile++, tile++)\n    {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t/*reset global QP*/\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t/*register global QP*/\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\n\t/*register TWICE: once for the command, and for the scenegraph globalQP*/\n\tnode->sgprivate->num_instances = 2;\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t/*reset global QP*/\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\t//if node was just created (num_instances == 0), unregister\n\t\t//otherwise (USE node) don't do anything\n\t\tif (!node->sgprivate->num_instances) {\n\t\t\tnode->sgprivate->num_instances = 1;\n\t\t\tgf_node_unregister(node, NULL);\n\t\t}\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t/*register global QP*/\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\n\t/*register TWICE: once for the command, and for the scenegraph globalQP*/\n\tgf_node_unregister(node, NULL);\n\tgf_node_unregister(node, NULL);\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tkey2 = FUTEX_KEY_INIT;\n\tret = get_futex_key(uaddr2, fshared, &key2);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = &rt_waiter;\n\tq.requeue_pi_key = &key2;\n\n\t/* Prepare to wait on uaddr. */\n\tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n\tif (ret)\n\t\tgoto out_key2;\n\n\t/* Queue the futex_q, drop the hb lock, wait for wakeup. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\tspin_lock(&hb->lock);\n\tret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);\n\tspin_unlock(&hb->lock);\n\tif (ret)\n\t\tgoto out_put_keys;\n\n\t/*\n\t * In order for us to be here, we know our q.key == key2, and since\n\t * we took the hb->lock above, we also know that futex_requeue() has\n\t * completed and we no longer have to concern ourselves with a wakeup\n\t * race with the atomic proxy lock acquition by the requeue code.\n\t */\n\n\t/* Check if the requeue code acquired the second futex for us. */\n\tif (!q.rt_waiter) {\n\t\t/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case.\n\t\t */\n\t\tif (q.pi_state && (q.pi_state->owner != current)) {\n\t\t\tspin_lock(q.lock_ptr);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tkey2 = FUTEX_KEY_INIT;\n\tret = get_futex_key(uaddr2, fshared, &key2);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = &rt_waiter;\n\tq.requeue_pi_key = &key2;\n\n\t/*\n\t * Prepare to wait on uaddr. On success, increments q.key (key1) ref\n\t * count.\n\t */\n\tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n\tif (ret)\n\t\tgoto out_key2;\n\n\t/* Queue the futex_q, drop the hb lock, wait for wakeup. */\n\tfutex_wait_queue_me(hb, &q, to);\n\n\tspin_lock(&hb->lock);\n\tret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);\n\tspin_unlock(&hb->lock);\n\tif (ret)\n\t\tgoto out_put_keys;\n\n\t/*\n\t * In order for us to be here, we know our q.key == key2, and since\n\t * we took the hb->lock above, we also know that futex_requeue() has\n\t * completed and we no longer have to concern ourselves with a wakeup\n\t * race with the atomic proxy lock acquisition by the requeue code. The\n\t * futex_requeue dropped our key1 reference and incremented our key2\n\t * reference count.\n\t */\n\n\t/* Check if the requeue code acquired the second futex for us. */\n\tif (!q.rt_waiter) {\n\t\t/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case.\n\t\t */\n\t\tif (q.pi_state && (q.pi_state->owner != current)) {\n\t\t\tspin_lock(q.lock_ptr);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_sli(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tunsigned *sli_cnt,\n\t\t\t\t\tpjmedia_rtcp_fb_sli sli[])\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    unsigned cnt, i;\n\n    PJ_ASSERT_RETURN(buf && sli_cnt && sli, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n\n    /* PLI uses pt==RTCP_PSFB and FMT==2 */\n    if (hdr->pt != RTCP_PSFB || hdr->count != 2)\n\treturn PJ_ENOTFOUND;\n\n    cnt = pj_ntohs((pj_uint16_t)hdr->length) - 2;\n    if (length < (cnt+3)*4)\n\treturn PJ_ETOOSMALL;\n\n    *sli_cnt = PJ_MIN(*sli_cnt, cnt);\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < *sli_cnt; ++i) {\n\t/* 'first' takes 13 bit */\n\tsli[i].first = (p[0] << 5) + ((p[1] & 0xF8) >> 3);\n\t/* 'number' takes 13 bit */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_sli(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tunsigned *sli_cnt,\n\t\t\t\t\tpjmedia_rtcp_fb_sli sli[])\n{\n    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;\n    pj_uint8_t *p;\n    unsigned cnt, i;\n\n    PJ_ASSERT_RETURN(buf && sli_cnt && sli, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_fb_common), PJ_ETOOSMALL);\n\n    /* PLI uses pt==RTCP_PSFB and FMT==2 */\n    if (hdr->rtcp_common.pt != RTCP_PSFB || hdr->rtcp_common.count != 2)\n\treturn PJ_ENOTFOUND;\n\n    cnt = pj_ntohs((pj_uint16_t)hdr->rtcp_common.length) - 2;\n    if (length < (cnt+3)*4)\n\treturn PJ_ETOOSMALL;\n\n    *sli_cnt = PJ_MIN(*sli_cnt, cnt);\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < *sli_cnt; ++i) {\n\t/* 'first' takes 13 bit */\n\tsli[i].first = (p[0] << 5) + ((p[1] & 0xF8) >> 3);\n\t/* 'number' takes 13 bit */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\n\tif (PageDirty(page)) {\n\t\tclear_page_dirty_for_io(page);\n\t\t/*\n\t\t * Want to mark the page and the radix tree as dirty, and\n\t\t * redo the accounting that clear_page_dirty_for_io undid,\n\t\t * but we can't use set_page_dirty because that function\n\t\t * is actually a signal that all of the page has become dirty.\n\t\t * Whereas only part of our page may be dirty.\n\t\t */\n\t\tif (PageSwapBacked(page))\n\t\t\tSetPageDirty(newpage);\n\t\telse\n\t\t\t__set_page_dirty_nobuffers(newpage);\n \t}\n\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\n\t/*\n\t * Copy NUMA information to the new page, to prevent over-eager\n\t * future migrations of this same page.\n\t */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\n\t/* Move dirty on pages not done by migrate_page_move_mapping() */\n\tif (PageDirty(page))\n\t\tSetPageDirty(newpage);\n\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\n\t/*\n\t * Copy NUMA information to the new page, to prevent over-eager\n\t * future migrations of this same page.\n\t */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    if (indexObj == nullptr)\n    {\n        // Default\n        indices.push_back(static_cast<int64_t>(0));\n        indices.push_back(size);\n    }\n    else\n    {\n        const PdfArray* arr;\n        if (!indexObj->TryGetArray(arr))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n\n        for (auto index : *arr)\n            indices.push_back(index.GetNumber());\n    }\n\n    // indices must be a multiple of 2\n    if (indices.size() % 2 != 0)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    if (indexObj == nullptr)\n    {\n        // Default\n        indices.push_back(static_cast<int64_t>(0));\n        indices.push_back(size);\n    }\n    else\n    {\n        const PdfArray* arr;\n        if (!indexObj->TryGetArray(arr))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream, \"Invalid XRef Stream /Index\");\n\n        for (auto index : *arr)\n            indices.push_back(index.GetNumber());\n    }\n\n    // indices must be a multiple of 2\n    if (indices.size() % 2 != 0)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream, \"Invalid XRef Stream /Index\");\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "dn2ancestor(\n    Slapi_Backend *be,\n    const Slapi_DN\t*sdn,\n\tSlapi_DN *ancestordn,\n    back_txn\t\t*txn,\n    int\t\t\t*err\n)\n{\n\tstruct backentry *e = NULL;\n\n\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> dn2ancestor \\\"%s\\\"\\n\", slapi_sdn_get_dn(sdn), 0, 0 );\n\n    /* first, check to see if the given sdn is empty or a root suffix of the\n       given backend - if so, it has no parent */\n    if (!slapi_sdn_isempty(sdn) && !slapi_be_issuffix( be, sdn )) {\n        Slapi_DN ancestorndn;\n        const char *ptr;\n\n        /* assign ancestordn to the parent of the given dn */\n        ptr = slapi_dn_find_parent(slapi_sdn_get_dn(sdn));\n        /* assign the ancestordn dn pointer to the parent of dn from sdn - sdn \"owns\"\n          the dn and ndn byref at the same time.  Whenever you call set_dn or set_ndn,\n          it calls slapi_sdn_done which wipes out the previous contents.  I suppose I\n          could have added another API to allow you to pass them both in.  Also, using\n          slapi_sdn_get_ndn(ancestordn) every time would result in making a copy then\n          normalizing the copy every time - not efficient.\n          So, why not just use a char* for the ancestorndn?  Because dn2entry requires\n          a Slapi_DN with the normalized dn.\n        */\n\n        /* stop when we get to \"\", or a backend suffix point */\n        while (!e && !slapi_sdn_isempty(&ancestorndn) && !slapi_be_issuffix( be, &ancestorndn )) {\n            /* find the entry - it uses the ndn, so no further conversion is necessary */\n            e= dn2entry(be,&ancestorndn,txn,err);\n            if (!e) {\n                /* not found, so set ancestordn to its parent and try again */\n                ptr = slapi_dn_find_parent(slapi_sdn_get_ndn(&ancestorndn));\n                /* keep in mind that ptr points to the raw ndn pointer inside\n                   ancestorndn which is still the ndn string \"owned\" by sdn, the\n                   original dn we started with - we are careful not to touch\n                   or change it */\n                slapi_sdn_set_ndn_byref(&ancestorndn, ptr); /* wipe out the previous contents */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "dn2ancestor(\n    Slapi_Backend *be,\n    const Slapi_DN\t*sdn,\n    Slapi_DN *ancestordn,\n    back_txn\t\t*txn,\n    int\t\t\t*err,\n    int allow_suffix\n)\n{\n    struct backentry *e = NULL;\n\n    LDAPDebug( LDAP_DEBUG_TRACE, \"=> dn2ancestor \\\"%s\\\"\\n\", slapi_sdn_get_dn(sdn), 0, 0 );\n\n    /* first, check to see if the given sdn is empty or a root suffix of the\n       given backend - if so, it has no parent */\n    if (!slapi_sdn_isempty(sdn) && !slapi_be_issuffix( be, sdn )) {\n        Slapi_DN ancestorndn;\n        const char *ptr;\n\n        /* assign ancestordn to the parent of the given dn */\n        ptr = slapi_dn_find_parent(slapi_sdn_get_dn(sdn));\n        /* assign the ancestordn dn pointer to the parent of dn from sdn - sdn \"owns\"\n          the dn and ndn byref at the same time.  Whenever you call set_dn or set_ndn,\n          it calls slapi_sdn_done which wipes out the previous contents.  I suppose I\n          could have added another API to allow you to pass them both in.  Also, using\n          slapi_sdn_get_ndn(ancestordn) every time would result in making a copy then\n          normalizing the copy every time - not efficient.\n          So, why not just use a char* for the ancestorndn?  Because dn2entry requires\n          a Slapi_DN with the normalized dn.\n        */\n\n        /* stop when we get to \"\", or a backend suffix point */\n        while (!e && !slapi_sdn_isempty(&ancestorndn)) {\n            if (!allow_suffix) {\n                /* Original behavior. */\n                if (slapi_be_issuffix(be, &ancestorndn)) {\n                    break;\n                }\n            }\n            /* find the entry - it uses the ndn, so no further conversion is necessary */\n            e= dn2entry(be,&ancestorndn,txn,err);\n            if (!e) {\n                /* not found, so set ancestordn to its parent and try again */\n                ptr = slapi_dn_find_parent(slapi_sdn_get_ndn(&ancestorndn));\n                /* keep in mind that ptr points to the raw ndn pointer inside\n                   ancestorndn which is still the ndn string \"owned\" by sdn, the\n                   original dn we started with - we are careful not to touch\n                   or change it */\n                slapi_sdn_set_ndn_byref(&ancestorndn, ptr); /* wipe out the previous contents */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n\tint err;\n\tint noblock;\n\tstruct vmci_datagram *dg;\n\tsize_t payload_len;\n\tstruct sk_buff *skb;\n\n\tnoblock = flags & MSG_DONTWAIT;\n\n\tif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Retrieve the head sk_buff from the socket's receive queue. */\n\terr = 0;\n\tskb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);\n\tif (err)\n\t\treturn err;\n\n\tif (!skb)\n\t\treturn -EAGAIN;\n\n\t\tpayload_len = len;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\t/* Place the datagram payload in the user's iovec. */\n\terr = skb_copy_datagram_iovec(skb, sizeof(*dg), msg->msg_iov,\n\t\tpayload_len);\n\tif (err)\n\t\tgoto out;\n\n\tmsg->msg_namelen = 0;\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_vm *vm_addr;\n\n\t\t/* Provide the address of the sender. */\n\t\tvm_addr = (struct sockaddr_vm *)msg->msg_name;\n\t\tvsock_addr_init(vm_addr, dg->src.context, dg->src.resource);\n\t\tmsg->msg_namelen = sizeof(*vm_addr);\n\t}\n\terr = payload_len;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tint err;\n\tint noblock;\n\tstruct vmci_datagram *dg;\n\tsize_t payload_len;\n\tstruct sk_buff *skb;\n\n\tnoblock = flags & MSG_DONTWAIT;\n\n\tif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg->msg_namelen = 0;\n\n\t/* Retrieve the head sk_buff from the socket's receive queue. */\n\terr = 0;\n\tskb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);\n\tif (err)\n\t\treturn err;\n\n\tif (!skb)\n\t\treturn -EAGAIN;\n\n\tif (payload_len > len) {\n\t\tpayload_len = len;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\t/* Place the datagram payload in the user's iovec. */\n\terr = skb_copy_datagram_iovec(skb, sizeof(*dg), msg->msg_iov,\n\t\tpayload_len);\n\tif (err)\n\t\tgoto out;\n\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_vm *vm_addr;\n\n\t\t/* Provide the address of the sender. */\n\t\tvm_addr = (struct sockaddr_vm *)msg->msg_name;\n\t\tvsock_addr_init(vm_addr, dg->src.context, dg->src.resource);\n\t\tmsg->msg_namelen = sizeof(*vm_addr);\n\t}\n\terr = payload_len;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "server_partial_file_request(struct httpd *env, struct client *clt, char *path,\n    struct stat *st, char *range_str)\n{\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct media_type\t*media, multipart_media;\n\tstruct range\t\t*range;\n\tstruct evbuffer\t\t*evb = NULL;\n\tsize_t\t\t\t content_length;\n\tint\t\t\t code = 500, fd = -1, i, nranges, ret;\n\tuint32_t\t\t boundary;\n\tchar\t\t\t content_range[64];\n\tconst char\t\t*errstr = NULL;\n\n\t/* Ignore range request for methods other than GET */\n\tif (desc->http_method != HTTP_METHOD_GET)\n\t\treturn server_file_request(env, clt, path, st);\n\n\tif ((range = parse_range(range_str, st->st_size, &nranges)) == NULL) {\n\t\tcode = 416;\n\t\t(void)snprintf(content_range, sizeof(content_range),\n\t\t    \"bytes */%lld\", st->st_size);\n\t\terrstr = content_range;\n\t\tgoto abort;\n\t}\n\n\t/* Now open the file, should be readable or we have another problem */\n\tif ((fd = open(path, O_RDONLY)) == -1)\n\t\tgoto abort;\n\n\tmedia = media_find_config(env, srv_conf, path);\n\tif ((evb = evbuffer_new()) == NULL) {\n\t\terrstr = \"failed to allocate file buffer\";\n\t\tgoto abort;\n\t}\n\n\tif (nranges == 1) {\n\t\t(void)snprintf(content_range, sizeof(content_range),\n\t\t    \"bytes %lld-%lld/%lld\", range->start, range->end,\n\t\t    st->st_size);\n\t\tif (kv_add(&resp->http_headers, \"Content-Range\",\n\t\t    content_range) == NULL)\n\t\t\tgoto abort;\n\n\t\tcontent_length = range->end - range->start + 1;\n\t\tif (buffer_add_range(fd, evb, range) == 0)\n\t\t\tgoto abort;\n\n\t} else {\n\t\tcontent_length = 0;\n\t\tboundary = arc4random();\n\t\t/* Generate a multipart payload of byteranges */\n\t\twhile (nranges--) {\n\t\t\tif ((i = evbuffer_add_printf(evb, \"\\r\\n--%ud\\r\\n\",\n\t\t\t    boundary)) == -1)\n\t\t\t\tgoto abort;\n\n\t\t\tcontent_length += i;\n\t\t\tif ((i = evbuffer_add_printf(evb,\n\t\t\t    \"Content-Type: %s/%s\\r\\n\",\n\t\t\t    media->media_type, media->media_subtype)) == -1)\n\t\t\t\tgoto abort;\n\n\t\t\tcontent_length += i;\n\t\t\tif ((i = evbuffer_add_printf(evb,\n\t\t\t    \"Content-Range: bytes %lld-%lld/%lld\\r\\n\\r\\n\",\n\t\t\t    range->start, range->end, st->st_size)) == -1)\n\t\t\t\tgoto abort;\n\n\t\t\tcontent_length += i;\n\t\t\tif (buffer_add_range(fd, evb, range) == 0)\n\t\t\t\tgoto abort;\n\n\t\t\tcontent_length += range->end - range->start + 1;\n\t\t\trange++;\n\t\t}\n\n\t\tif ((i = evbuffer_add_printf(evb, \"\\r\\n--%ud--\\r\\n\",\n\t\t    boundary)) == -1)\n\t\t\tgoto abort;\n\n\t\tcontent_length += i;\n\n\t\t/* prepare multipart/byteranges media type */\n\t\t(void)strlcpy(multipart_media.media_type, \"multipart\",\n\t\t    sizeof(multipart_media.media_type));\n\t\t(void)snprintf(multipart_media.media_subtype,\n\t\t    sizeof(multipart_media.media_subtype),\n\t\t    \"byteranges; boundary=%ud\", boundary);\n\t\tmedia = &multipart_media;\n\t}\n\n\tclose(fd);\n\tfd = -1;\n\n\tret = server_response_http(clt, 206, media, content_length,\n\t    MINIMUM(time(NULL), st->st_mtim.tv_sec));\n\tswitch (ret) {\n\tcase -1:\n\t\tgoto fail;\n\tcase 0:\n\t\t/* Connection is already finished */\n\t\tgoto done;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (server_bufferevent_write_buffer(clt, evb) == -1)\n\t\tgoto fail;\n\n\tbufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);\n\tif (clt->clt_persist)\n\t\tclt->clt_toread = TOREAD_HTTP_HEADER;\n\telse\n\t\tclt->clt_toread = TOREAD_HTTP_NONE;\n\tclt->clt_done = 0;\n\n done:\n\tevbuffer_free(evb);\n\tserver_reset_http(clt);\n\treturn (0);\n fail:\n\tbufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);\n\tbufferevent_free(clt->clt_bev);\n\tclt->clt_bev = NULL;\n abort:\n\tif (evb != NULL)\n\t\tevbuffer_free(evb);\n\tif (fd != -1)\n\t\tclose(fd);\n\tif (errstr == NULL)\n\t\terrstr = strerror(errno);\n\tserver_abort_http(clt, code, errstr);\n\treturn (-1);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "server_partial_file_request(struct httpd *env, struct client *clt, char *path,\n    struct stat *st, char *range_str)\n{\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct media_type\t*media, multipart_media;\n\tstruct range_data\t*r = &clt->clt_ranges;\n\tstruct range\t\t*range;\n\tsize_t\t\t\t content_length = 0;\n\tint\t\t\t code = 500, fd = -1, i, nranges, ret;\n\tchar\t\t\t content_range[64];\n\tconst char\t\t*errstr = NULL;\n\n\t/* Ignore range request for methods other than GET */\n\tif (desc->http_method != HTTP_METHOD_GET)\n\t\treturn server_file_request(env, clt, path, st);\n\n\tif ((nranges = parse_ranges(clt, range_str, st->st_size)) < 1) {\n\t\tcode = 416;\n\t\t(void)snprintf(content_range, sizeof(content_range),\n\t\t    \"bytes */%lld\", st->st_size);\n\t\terrstr = content_range;\n\t\tgoto abort;\n\t}\n\n\t/* Now open the file, should be readable or we have another problem */\n\tif ((fd = open(path, O_RDONLY)) == -1)\n\t\tgoto abort;\n\n\tmedia = media_find_config(env, srv_conf, path);\n\tr->range_media = media;\n\n\tif (nranges == 1) {\n\t\trange = &r->range[0];\n\t\t(void)snprintf(content_range, sizeof(content_range),\n\t\t    \"bytes %lld-%lld/%lld\", range->start, range->end,\n\t\t    st->st_size);\n\t\tif (kv_add(&resp->http_headers, \"Content-Range\",\n\t\t    content_range) == NULL)\n\t\t\tgoto abort;\n\n\t\trange = &r->range[0];\n\t\tcontent_length += range->end - range->start + 1;\n\t} else {\n\t\t/* Add boundary, all parts will be handled by the callback */\n\t\tarc4random_buf(&clt->clt_boundary, sizeof(clt->clt_boundary));\n\n\t\t/* Calculate Content-Length of the complete multipart body */\n\t\tfor (i = 0; i < nranges; i++) {\n\t\t\trange = &r->range[i];\n\n\t\t\t/* calculate Content-Length of the complete body */\n\t\t\tif ((ret = snprintf(NULL, 0,\n\t\t\t    \"\\r\\n--%llu\\r\\n\"\n\t\t\t    \"Content-Type: %s/%s\\r\\n\"\n\t\t\t    \"Content-Range: bytes %lld-%lld/%lld\\r\\n\\r\\n\",\n\t\t\t    clt->clt_boundary,\n\t\t\t    media->media_type, media->media_subtype,\n\t\t\t    range->start, range->end, st->st_size)) < 0)\n\t\t\t\tgoto abort;\n\n\t\t\t/* Add data length */\n\t\t\tcontent_length += ret + range->end - range->start + 1;\n\n\t\t}\n\t\tif ((ret = snprintf(NULL, 0, \"\\r\\n--%llu--\\r\\n\",\n\t\t    clt->clt_boundary)) < 0)\n\t\t\tgoto abort;\n\t\tcontent_length += ret;\n\n\t\t/* prepare multipart/byteranges media type */\n\t\t(void)strlcpy(multipart_media.media_type, \"multipart\",\n\t\t    sizeof(multipart_media.media_type));\n\t\t(void)snprintf(multipart_media.media_subtype,\n\t\t    sizeof(multipart_media.media_subtype),\n\t\t    \"byteranges; boundary=%llu\", clt->clt_boundary);\n\t\tmedia = &multipart_media;\n\t}\n\n\t/* Start with first range */\n\tr->range_toread = TOREAD_HTTP_RANGE;\n\n\tret = server_response_http(clt, 206, media, content_length,\n\t    MINIMUM(time(NULL), st->st_mtim.tv_sec));\n\tswitch (ret) {\n\tcase -1:\n\t\tgoto fail;\n\tcase 0:\n\t\t/* Connection is already finished */\n\t\tclose(fd);\n\t\tgoto done;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tclt->clt_fd = fd;\n\tif (clt->clt_srvbev != NULL)\n\t\tbufferevent_free(clt->clt_srvbev);\n\n\tclt->clt_srvbev_throttled = 0;\n\tclt->clt_srvbev = bufferevent_new(clt->clt_fd, server_read_httprange,\n\t    server_write, server_file_error, clt);\n\tif (clt->clt_srvbev == NULL) {\n\t\terrstr = \"failed to allocate file buffer event\";\n\t\tgoto fail;\n\t}\n\n\t/* Adjust read watermark to the socket output buffer size */\n\tbufferevent_setwatermark(clt->clt_srvbev, EV_READ, 0,\n\t    clt->clt_sndbufsiz);\n\n\tbufferevent_settimeout(clt->clt_srvbev,\n\t    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);\n\tbufferevent_enable(clt->clt_srvbev, EV_READ);\n\tbufferevent_disable(clt->clt_bev, EV_READ);\n\n done:\n\tserver_reset_http(clt);\n\treturn (0);\n fail:\n\tbufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);\n\tbufferevent_free(clt->clt_bev);\n\tclt->clt_bev = NULL;\n abort:\n\tif (fd != -1)\n\t\tclose(fd);\n\tif (errstr == NULL)\n\t\terrstr = strerror(errno);\n\tserver_abort_http(clt, code, errstr);\n\treturn (-1);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\n\t\tcb->args[0] = 1;\n\n\t\terr = nlmsg_parse(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t  xfrma_policy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (attrs[XFRMA_ADDRESS_FILTER]) {\n\t\t\tfilter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),\n\t\t\t\t\t sizeof(*filter), GFP_KERNEL);\n\t\t\tif (filter == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t}\n\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\n\treturn skb->len;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\n\t\terr = nlmsg_parse(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t  xfrma_policy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (attrs[XFRMA_ADDRESS_FILTER]) {\n\t\t\tfilter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),\n\t\t\t\t\t sizeof(*filter), GFP_KERNEL);\n\t\t\tif (filter == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t\tcb->args[0] = 1;\n\t}\n\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\n\treturn skb->len;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tretpoline_generic:\n\t\tmode = retp_compiler() ? SPECTRE_V2_RETPOLINE_GENERIC :\n\t\t\t\t\t SPECTRE_V2_RETPOLINE_MINIMAL;\n\t\tsetup_force_cpu_cap(X86_FEATURE_RETPOLINE);\n\t}\n\n\tspectre_v2_enabled = mode;\n\tpr_info(\"%s\\n\", spectre_v2_strings[mode]);\n\n\t/*\n\t * If neither SMEP nor PTI are available, there is a risk of\n\t * hitting userspace addresses in the RSB after a context switch\n\t * from a shallow call stack to a deeper one. To prevent this fill\n\t * the entire RSB, even when using IBRS.\n\t *\n\t * Skylake era CPUs have a separate issue with *underflow* of the\n\t * RSB, when they will predict 'ret' targets from the generic BTB.\n\t * The proper mitigation for this is IBRS. If IBRS is not supported\n\t * or deactivated in favour of retpolines the RSB fill on context\n\t * switch is required.\n\t */\n\tif ((!boot_cpu_has(X86_FEATURE_PTI) &&\n\t     !boot_cpu_has(X86_FEATURE_SMEP)) || is_skylake_era()) {\n\t\tsetup_force_cpu_cap(X86_FEATURE_RSB_CTXSW);\n\t\tpr_info(\"Spectre v2 mitigation: Filling RSB on context switch\\n\");\n\t}\n\n\t/* Initialize Indirect Branch Prediction Barrier if supported */\n\tif (boot_cpu_has(X86_FEATURE_IBPB)) {\n\t\tsetup_force_cpu_cap(X86_FEATURE_USE_IBPB);\n\t\tpr_info(\"Spectre v2 mitigation: Enabling Indirect Branch Prediction Barrier\\n\");\n\t}\n\n\t/*\n\t * Retpoline means the kernel is safe because it has no indirect\n\t * branches. But firmware isn't, so use IBRS to protect that.",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tretpoline_generic:\n\t\tmode = retp_compiler() ? SPECTRE_V2_RETPOLINE_GENERIC :\n\t\t\t\t\t SPECTRE_V2_RETPOLINE_MINIMAL;\n\t\tsetup_force_cpu_cap(X86_FEATURE_RETPOLINE);\n\t}\n\n\tspectre_v2_enabled = mode;\n\tpr_info(\"%s\\n\", spectre_v2_strings[mode]);\n\n\t/*\n\t * If spectre v2 protection has been enabled, unconditionally fill\n\t * RSB during a context switch; this protects against two independent\n\t * issues:\n\t *\n\t *\t- RSB underflow (and switch to BTB) on Skylake+\n\t *\t- SpectreRSB variant of spectre v2 on X86_BUG_SPECTRE_V2 CPUs\n\t */\n\tsetup_force_cpu_cap(X86_FEATURE_RSB_CTXSW);\n\tpr_info(\"Spectre v2 / SpectreRSB mitigation: Filling RSB on context switch\\n\");\n\n\t/* Initialize Indirect Branch Prediction Barrier if supported */\n\tif (boot_cpu_has(X86_FEATURE_IBPB)) {\n\t\tsetup_force_cpu_cap(X86_FEATURE_USE_IBPB);\n\t\tpr_info(\"Spectre v2 mitigation: Enabling Indirect Branch Prediction Barrier\\n\");\n\t}\n\n\t/*\n\t * Retpoline means the kernel is safe because it has no indirect\n\t * branches. But firmware isn't, so use IBRS to protect that.",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tfor (auth = auth_switch; auth->name; auth++) {\n\t    if (IS_DISABLED(auth))\n\t\tcontinue;\n\t    num_methods++;\n\t    if (auth->setup != NULL) {\n\t\tstatus = (auth->setup)(ctx, pw, &prompt, auth);\n\t\tif (status == AUTH_FAILURE)\n\t\t    SET(auth->flags, FLAG_DISABLED);\n\t\telse if (status == AUTH_NONINTERACTIVE)\n\t\t    goto done;\n\t\telse if (status == AUTH_ERROR || user_interrupted())\n\t\t    goto done;\t\t/* assume error msg already printed */\n\t    }\n\t}\n\tif (num_methods == 0) {\n\t    audit_failure(ctx, ctx->runas.argv,\n\t\tN_(\"no authentication methods\"));\n\t    log_warningx(ctx, SLOG_SEND_MAIL,\n\t\tN_(\"Unable to initialize authentication methods.\"));\n\t    debug_return_int(-1);\n\t}\n\tcase AUTH_INTR:\n\tcase AUTH_FAILURE:\n\t    if (ntries != 0)\n\t\tSET(validated, FLAG_BAD_PASSWORD);\n\t    log_auth_failure(ctx, validated, ntries);\n\t    ret = false;\n\t    break;\n\tcase AUTH_NONINTERACTIVE:\n\t    SET(validated, FLAG_NO_USER_INPUT);\n\t    FALLTHROUGH;\n\tcase AUTH_ERROR:\n\tdefault:\n\t    log_auth_failure(ctx, validated, 0);\n\t    ret = -1;\n\t    break;\n    }\n\n    debug_return_int(ret);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tfor (auth = auth_switch; auth->name; auth++) {\n\t    if (IS_DISABLED(auth))\n\t\tcontinue;\n\t    num_methods++;\n\t    if (auth->setup != NULL) {\n\t\tstatus = (auth->setup)(ctx, pw, &prompt, auth);\n\t\tif (status == AUTH_FAILURE)\n\t\t    SET(auth->flags, FLAG_DISABLED);\n\t\telse if (status == AUTH_NONINTERACTIVE)\n\t\t    goto done;\n\t\telse if (status != AUTH_SUCCESS || user_interrupted())\n\t\t    goto done;\t\t/* assume error msg already printed */\n\t    }\n\t}\n\tif (num_methods == 0) {\n\t    audit_failure(ctx, ctx->runas.argv,\n\t\tN_(\"no authentication methods\"));\n\t    log_warningx(ctx, SLOG_SEND_MAIL,\n\t\tN_(\"Unable to initialize authentication methods.\"));\n\t    debug_return_int(-1);\n\t}\n\t    break;\n\tcase AUTH_INTR:\n\tcase AUTH_FAILURE:\n\t    if (ntries != 0)\n\t\tSET(validated, FLAG_BAD_PASSWORD);\n\t    log_auth_failure(ctx, validated, ntries);\n\t    ret = false;\n\t    break;\n\tcase AUTH_NONINTERACTIVE:\n\t    SET(validated, FLAG_NO_USER_INPUT);\n\t    FALLTHROUGH;\n\tdefault:\n\t    log_auth_failure(ctx, validated, 0);\n\t    ret = -1;\n\t    break;\n    }\n\n    debug_return_int(ret);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "forbidden_name(struct compiling *c, identifier name, const node *n,\n               int full_checks)\n{\n    assert(PyUnicode_Check(name));\n    if (PyUnicode_CompareWithASCIIString(name, \"__debug__\") == 0) {\n        ast_error(c, n, \"assignment to keyword\");\n        return 1;\n    }\n    if (full_checks) {\n        const char * const *p;\n        for (p = FORBIDDEN; *p; p++) {\n            if (PyUnicode_CompareWithASCIIString(name, *p) == 0) {\n                ast_error(c, n, \"assignment to keyword\");\n                return 1;\n            }\n        }\n    }\n    return 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "forbidden_name(struct compiling *c, identifier name, const node *n,\n               int full_checks)\n{\n    assert(PyUnicode_Check(name));\n    if (_PyUnicode_EqualToASCIIString(name, \"__debug__\")) {\n        ast_error(c, n, \"assignment to keyword\");\n        return 1;\n    }\n    if (full_checks) {\n        const char * const *p;\n        for (p = FORBIDDEN; *p; p++) {\n            if (_PyUnicode_EqualToASCIIString(name, *p)) {\n                ast_error(c, n, \"assignment to keyword\");\n                return 1;\n            }\n        }\n    }\n    return 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\toptions |= MBREX(regex_default_options);\n\t\t\tsyntax = MBREX(regex_default_syntax);\n\t\t}\n\t}\n\tif (Z_TYPE_PP(arg_pattern_zval) == IS_STRING) {\n\t\targ_pattern = Z_STRVAL_PP(arg_pattern_zval);\n\t\targ_pattern_len = Z_STRLEN_PP(arg_pattern_zval);\n\t} else {\n\t\t/* FIXME: this code is not multibyte aware! */\n\t\tconvert_to_long_ex(arg_pattern_zval);\n\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\t\n\t\tpat_buf[1] = '\\0';\n\n\t\targ_pattern = pat_buf;\n\t\targ_pattern_len = 1;\t\n\t}\n\t/* create regex pattern buffer */\n\tre = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);\n\tif (re == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (eval || is_callable) {\n\t\tpbuf = &eval_buf;\n\t\tdescription = zend_make_compiled_string_description(\"mbregex replace\" TSRMLS_CC);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsmart_str_appendl(pbuf, p, fwd);\n\t\t\t\t\t\tp += fwd;\n\t\t\t\t\t\ti += fwd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\tif (eval) {\n\t\t\t\tzval v;\n\t\t\t\t/* null terminate buffer */\n\t\t\t\tsmart_str_0(&eval_buf);\n\t\t\t\t/* do eval */\n\t\t\t\tif (zend_eval_stringl(eval_buf.c, eval_buf.len, &v, description TSRMLS_CC) == FAILURE) {\n\t\t\t\t\tefree(description);\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC,E_ERROR, \"Failed evaluating code: %s%s\", PHP_EOL, eval_buf.c);\n\t\t\t\t\t/* zend_error() does not return in this case */\n\t\t\t\t}\n\n\t\t\t\t/* result of eval */\n\t\t\t\tconvert_to_string(&v);\n\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL(v), Z_STRLEN(v));\n\t\t\t\t/* Clean up */\n\t\t\t\teval_buf.len = 0;\n\t\t\t\tzval_dtor(&v);\n\t\t\t} else if (is_callable) {\n\t\t\t\tzval *retval_ptr;\n\t\t\t\tzval **args[1];\n\t\t\t\tzval *subpats;\n\t\t\t\tint i;\n\t\t\t\t\n\t\t\t\tMAKE_STD_ZVAL(subpats);\n\t\t\t\tarray_init(subpats);\n\t\t\t\t\n\t\t\t\tfor (i = 0; i < regs->num_regs; i++) {\n\t\t\t\t\tadd_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);\n\t\t\t\t}\t\t\t\t\n\t\t\t\t\n\t\t\t\targs[0] = &subpats;\n\t\t\t\t/* null terminate buffer */\n\t\t\t\tsmart_str_0(&eval_buf);\n\t\t\t\t\n\t\t\t\targ_replace_fci.param_count = 1;\n\t\t\t\targ_replace_fci.params = args;\n\t\t\t\targ_replace_fci.retval_ptr_ptr = &retval_ptr;\n\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {\n\t\t\t\t\tconvert_to_string_ex(&retval_ptr);\n\t\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));\n\t\t\t\t\teval_buf.len = 0;\n\t\t\t\t\tzval_ptr_dtor(&retval_ptr);\n\t\t\t\t} else {\n\t\t\t\t\tefree(description);\n\t\t\t\t\tif (!EG(exception)) {\n\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call custom replacement function\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tzval_ptr_dtor(&subpats);\n\t\t\t}\n\n\t\t\tn = regs->end[0];\n\t\t\tif ((pos - (OnigUChar *)string) < n) {\n\t\t\t\tpos = (OnigUChar *)string + n;\n\t\t\t} else {\n\t\t\t\tif (pos < string_lim) {\n\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1); \n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t} else { /* nomatch */\n\t\t\t/* stick that last bit of string on our output */\n\t\t\tif (string_lim - pos > 0) {\n\t\t\t\tsmart_str_appendl(&out_buf, pos, string_lim - pos);\n\t\t\t}\n\t\t}\n\t\tonig_region_free(regs, 0);\n\n\tif (description) {\n\t\tefree(description);\n\t}\n\tif (regs != NULL) {\n\t\tonig_region_free(regs, 1);\n\t}\n\tsmart_str_free(&eval_buf);\n\n\tif (err <= -2) {\n\t\tsmart_str_free(&out_buf);\t\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tsmart_str_appendc(&out_buf, '\\0');\n\t\tRETVAL_STRINGL((char *)out_buf.c, out_buf.len - 1, 0);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\toptions |= MBREX(regex_default_options);\n\t\t\tsyntax = MBREX(regex_default_syntax);\n\t\t}\n\t}\n\tif (Z_TYPE_PP(arg_pattern_zval) == IS_STRING) {\n\t\targ_pattern = Z_STRVAL_PP(arg_pattern_zval);\n\t\targ_pattern_len = Z_STRLEN_PP(arg_pattern_zval);\n\t} else {\n\t\t/* FIXME: this code is not multibyte aware! */\n\t\tconvert_to_long_ex(arg_pattern_zval);\n\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\n\t\tpat_buf[1] = '\\0';\n\n\t\targ_pattern = pat_buf;\n\t\targ_pattern_len = 1;\n\t}\n\t/* create regex pattern buffer */\n\tre = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);\n\tif (re == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (eval || is_callable) {\n\t\tpbuf = &eval_buf;\n\t\tdescription = zend_make_compiled_string_description(\"mbregex replace\" TSRMLS_CC);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsmart_str_appendl(pbuf, p, fwd);\n\t\t\t\t\t\tp += fwd;\n\t\t\t\t\t\ti += fwd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (eval) {\n\t\t\t\tzval v;\n\t\t\t\t/* null terminate buffer */\n\t\t\t\tsmart_str_0(&eval_buf);\n\t\t\t\t/* do eval */\n\t\t\t\tif (zend_eval_stringl(eval_buf.c, eval_buf.len, &v, description TSRMLS_CC) == FAILURE) {\n\t\t\t\t\tefree(description);\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC,E_ERROR, \"Failed evaluating code: %s%s\", PHP_EOL, eval_buf.c);\n\t\t\t\t\t/* zend_error() does not return in this case */\n\t\t\t\t}\n\n\t\t\t\t/* result of eval */\n\t\t\t\tconvert_to_string(&v);\n\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL(v), Z_STRLEN(v));\n\t\t\t\t/* Clean up */\n\t\t\t\teval_buf.len = 0;\n\t\t\t\tzval_dtor(&v);\n\t\t\t} else if (is_callable) {\n\t\t\t\tzval *retval_ptr = NULL;\n\t\t\t\tzval **args[1];\n\t\t\t\tzval *subpats;\n\t\t\t\tint i;\n\n\t\t\t\tMAKE_STD_ZVAL(subpats);\n\t\t\t\tarray_init(subpats);\n\n\t\t\t\tfor (i = 0; i < regs->num_regs; i++) {\n\t\t\t\t\tadd_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);\n\t\t\t\t}\n\n\t\t\t\targs[0] = &subpats;\n\t\t\t\t/* null terminate buffer */\n\t\t\t\tsmart_str_0(&eval_buf);\n\n\t\t\t\targ_replace_fci.param_count = 1;\n\t\t\t\targ_replace_fci.params = args;\n\t\t\t\targ_replace_fci.retval_ptr_ptr = &retval_ptr;\n\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {\n\t\t\t\t\tconvert_to_string_ex(&retval_ptr);\n\t\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));\n\t\t\t\t\teval_buf.len = 0;\n\t\t\t\t\tzval_ptr_dtor(&retval_ptr);\n\t\t\t\t} else {\n\t\t\t\t\tif (!EG(exception)) {\n\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call custom replacement function\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tzval_ptr_dtor(&subpats);\n\t\t\t}\n\n\t\t\tn = regs->end[0];\n\t\t\tif ((pos - (OnigUChar *)string) < n) {\n\t\t\t\tpos = (OnigUChar *)string + n;\n\t\t\t} else {\n\t\t\t\tif (pos < string_lim) {\n\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1);\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t} else { /* nomatch */\n\t\t\t/* stick that last bit of string on our output */\n\t\t\tif (string_lim - pos > 0) {\n\t\t\t\tsmart_str_appendl(&out_buf, pos, string_lim - pos);\n\t\t\t}\n\t\t}\n\t\tonig_region_free(regs, 0);\n\n\tif (description) {\n\t\tefree(description);\n\t}\n\tif (regs != NULL) {\n\t\tonig_region_free(regs, 1);\n\t}\n\tsmart_str_free(&eval_buf);\n\n\tif (err <= -2) {\n\t\tsmart_str_free(&out_buf);\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tsmart_str_appendc(&out_buf, '\\0');\n\t\tRETVAL_STRINGL((char *)out_buf.c, out_buf.len - 1, 0);\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t// section for deletion - when it is a file\n\t\t\t// that got some data again. We can do it\n\t\t\t// because we only erase the files afterwards.\n\t\t\tdeleted_sections.erase (filename);\n\n\t\t\tif (!s.isDirty ()) {\n\t\t\t    y2debug (\"Skipping file %s that was not changed.\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\ts.initReadBy ();\n\t\t\t// ensure that the directories exist\n\t\t\tPathname pn (filename);\n\t\t\tPathInfo::assert_dir (pn.dirname ());\n\t\t\tofstream of(filename.c_str());\n\t\t\tif (!of.good())\n\t\t\t{\n\t\t\t    bugs++;\n\t\t\t    y2error (\"Can not open file %s for write\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\twrite_helper (s, of, 0);\n\t\t\ts.clean();\n\t\t\tof.close ();\n\t\t    }\n\t\telse\n\t\t    {\n\t\t\ty2error (\"Value %s encountered at multifile top level\",\n\t\t\t\t ci->e ().getName ());\n\t\t    }\n\t    }\n\n\t// FIXME: update time stamps of files...\n\n\t// erase removed files...\n\tfor (set<string>::iterator i = deleted_sections.begin (); i!=deleted_sections.end();i++)\n\t    if (multi_files.find (*i) != multi_files.end ()) {\n\t\ty2debug (\"Removing file %s\\n\", (*i).c_str());\n\t\tunlink ((*i).c_str());\n\t    }\n    }\n    else\n    {\n\t// ensure that the directories exist\n\tPathname pn (file);\n\tPathInfo::assert_dir (pn.dirname ());\n\tofstream of(file.c_str());\n\tif (!of.good())\n\t{\n\t    y2error (\"Can not open file %s for write\", file.c_str());\n\t    return -1;\n\t}\n\n\twrite_helper (inifile, of, 0);\n\n\tof.close();\n\ttimestamp = getTimeStamp ();\n    }\n    inifile.clean ();\n    return bugs ? -1 : 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t// section for deletion - when it is a file\n\t\t\t// that got some data again. We can do it\n\t\t\t// because we only erase the files afterwards.\n\t\t\tdeleted_sections.erase (filename);\n\n\t\t\tif (!s.isDirty ()) {\n\t\t\t    y2debug (\"Skipping file %s that was not changed.\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\ts.initReadBy ();\n                        bugs += write_file(filename, s);\n\t\t    }\n\t\telse\n\t\t    {\n\t\t\ty2error (\"Value %s encountered at multifile top level\",\n\t\t\t\t ci->e ().getName ());\n\t\t    }\n\t    }\n\n\t// FIXME: update time stamps of files...\n\n\t// erase removed files...\n\tfor (set<string>::iterator i = deleted_sections.begin (); i!=deleted_sections.end();i++)\n\t    if (multi_files.find (*i) != multi_files.end ()) {\n\t\ty2debug (\"Removing file %s\\n\", (*i).c_str());\n\t\tunlink ((*i).c_str());\n\t    }\n    }\n    else\n    {\n        bugs += write_file(file, inifile);\n\ttimestamp = getTimeStamp ();\n    }\n    return bugs ? -1 : 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  */\n  buff_size= 33 + USERNAME_LENGTH + data_len + 9 + NAME_LEN + NAME_LEN + connect_attrs_len + 9;\n  buff= my_alloca(buff_size);\n\n  mysql->client_flag|= mysql->options.client_flag;\n  mysql->client_flag|= CLIENT_CAPABILITIES;\n\n  if (mysql->client_flag & CLIENT_MULTI_STATEMENTS)\n    mysql->client_flag|= CLIENT_MULTI_RESULTS;\n\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  if (mysql->options.ssl_key || mysql->options.ssl_cert ||\n      mysql->options.ssl_ca || mysql->options.ssl_capath ||\n      mysql->options.ssl_cipher ||\n      (mysql->options.extension && mysql->options.extension->ssl_crl) || \n      (mysql->options.extension && mysql->options.extension->ssl_crlpath))\n    mysql->options.use_ssl= 1;\n  if (mysql->options.use_ssl)\n    mysql->client_flag|= CLIENT_SSL;\n#endif /* HAVE_OPENSSL && !EMBEDDED_LIBRARY*/\n  if (mpvio->db)\n    mysql->client_flag|= CLIENT_CONNECT_WITH_DB;\n  else\n    mysql->client_flag&= ~CLIENT_CONNECT_WITH_DB;\n\n  /* Remove options that server doesn't support */\n  mysql->client_flag= mysql->client_flag &\n                       (~(CLIENT_COMPRESS | CLIENT_SSL | CLIENT_PROTOCOL_41) \n                       | mysql->server_capabilities);\n    memset(buff+9, 0, 32-9);\n    end= buff+32;\n  }\n  else\n  {\n    int2store(buff, mysql->client_flag);\n    int3store(buff+2, net->max_packet_size);\n    end= buff+5;\n  }\n#ifdef HAVE_OPENSSL\n  if (mysql->client_flag & CLIENT_SSL)\n  {\n    /* Do the SSL layering. */\n    struct st_mysql_options *options= &mysql->options;\n    struct st_VioSSLFd *ssl_fd;\n    enum enum_ssl_init_error ssl_init_error;\n    const char *cert_error;\n    unsigned long ssl_error;\n\n    /*\n      Send mysql->client_flag, max_packet_size - unencrypted otherwise\n      the server does not know we want to do SSL\n    */\n    MYSQL_TRACE(SEND_SSL_REQUEST, mysql, (end - buff, (const unsigned char*)buff));\n    if (my_net_write(net, (uchar*)buff, (size_t) (end-buff)) || net_flush(net))\n    {\n      set_mysql_extended_error(mysql, CR_SERVER_LOST, unknown_sqlstate,\n                               ER(CR_SERVER_LOST_EXTENDED),\n    if ((mysql->client_flag & CLIENT_SSL_VERIFY_SERVER_CERT) &&\n        ssl_verify_server_cert(net->vio, mysql->host, &cert_error))\n    {\n      set_mysql_extended_error(mysql, CR_SSL_CONNECTION_ERROR, unknown_sqlstate,\n                               ER(CR_SSL_CONNECTION_ERROR), cert_error);\n      goto error;\n    }\n\n    MYSQL_TRACE(SSL_CONNECTED, mysql, ());\n    MYSQL_TRACE_STAGE(mysql, AUTHENTICATE);\n  }\n#endif /* HAVE_OPENSSL */\n\n  DBUG_PRINT(\"info\",(\"Server version = '%s'  capabilites: %lu  status: %u  client_flag: %lu\",\n\t\t     mysql->server_version, mysql->server_capabilities,\n\t\t     mysql->server_status, mysql->client_flag));\n\n  compile_time_assert(MYSQL_USERNAME_LENGTH == USERNAME_LENGTH);\n\n  /* This needs to be changed as it's not useful with big packets */\n  if (mysql->user[0])",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  buff_size= 33 + USERNAME_LENGTH + data_len + 9 + NAME_LEN + NAME_LEN + connect_attrs_len + 9;\n  buff= my_alloca(buff_size);\n\n  mysql->client_flag|= mysql->options.client_flag;\n  mysql->client_flag|= CLIENT_CAPABILITIES;\n\n  if (mysql->client_flag & CLIENT_MULTI_STATEMENTS)\n    mysql->client_flag|= CLIENT_MULTI_RESULTS;\n\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  /* consider SSL if any of the SSL mysql_options() is issued */\n  if (mysql->options.ssl_key || mysql->options.ssl_cert ||\n      mysql->options.ssl_ca || mysql->options.ssl_capath ||\n      mysql->options.ssl_cipher ||\n      (mysql->options.extension && mysql->options.extension->ssl_crl) ||\n      (mysql->options.extension && mysql->options.extension->ssl_crlpath) ||\n      (mysql->options.extension && mysql->options.extension->ssl_enforce))\n    mysql->options.use_ssl = TRUE;\n  if (mysql->options.use_ssl)\n    mysql->client_flag |= CLIENT_SSL;\n#endif /* HAVE_OPENSSL && !EMBEDDED_LIBRARY*/\n  if (mpvio->db)\n    mysql->client_flag|= CLIENT_CONNECT_WITH_DB;\n  else\n    mysql->client_flag&= ~CLIENT_CONNECT_WITH_DB;\n\n  /* Remove options that server doesn't support */\n  mysql->client_flag= mysql->client_flag &\n                       (~(CLIENT_COMPRESS | CLIENT_SSL | CLIENT_PROTOCOL_41) \n                       | mysql->server_capabilities);\n    memset(buff+9, 0, 32-9);\n    end= buff+32;\n  }\n  else\n  {\n    int2store(buff, mysql->client_flag);\n    int3store(buff+2, net->max_packet_size);\n    end= buff+5;\n  }\n#ifdef HAVE_OPENSSL\n\n  if (mysql->options.extension && mysql->options.extension->ssl_enforce)\n  {\n    /*\n      ssl_enforce=1 means enforce ssl\n      Don't fallback on unencrypted connection.\n    */\n    /* can't turn enforce on without turning on use_ssl too */\n    DBUG_ASSERT(mysql->options.use_ssl);\n    /* enforce=true takes precendence over use=false */\n    if (!(mysql->server_capabilities & CLIENT_SSL))\n    {\n      set_mysql_extended_error(mysql, CR_SSL_CONNECTION_ERROR, unknown_sqlstate,\n                               ER(CR_SSL_CONNECTION_ERROR),\n                               \"SSL is required but the server doesn't \"\n                               \"support it\"\n                               );\n      goto error;\n    }\n  }\n\n  /*\n\n   use_ssl=0 => Disable ssl and connect using unencrypted channel if server\n     allows it\n\n   use_ssl=1, ssl_enforce=0 (default) => attempt ssl connection if possible but\n     fallback on unencrypted connection if possible.\n\n  */\n  if ((mysql->server_capabilities & CLIENT_SSL) && mysql->options.use_ssl)\n  {\n    /* Do the SSL layering. */\n    struct st_mysql_options *options= &mysql->options;\n    struct st_VioSSLFd *ssl_fd;\n    enum enum_ssl_init_error ssl_init_error;\n    const char *cert_error;\n    unsigned long ssl_error;\n\n    if (!mysql->options.ssl_cipher)\n    {\n      SET_OPTION(ssl_cipher, default_ssl_cipher);\n    }\n\n    /*\n      Send mysql->client_flag, max_packet_size - unencrypted otherwise\n      the server does not know we want to do SSL\n    */\n    MYSQL_TRACE(SEND_SSL_REQUEST, mysql, (end - buff, (const unsigned char*)buff));\n    if (my_net_write(net, (uchar*)buff, (size_t) (end-buff)) || net_flush(net))\n    {\n      set_mysql_extended_error(mysql, CR_SERVER_LOST, unknown_sqlstate,\n                               ER(CR_SERVER_LOST_EXTENDED),\n        ssl_verify_server_cert(net->vio, mysql->host, &cert_error))\n    {\n      set_mysql_extended_error(mysql, CR_SSL_CONNECTION_ERROR, unknown_sqlstate,\n                               ER(CR_SSL_CONNECTION_ERROR), cert_error);\n      goto error;\n    }\n\n    MYSQL_TRACE(SSL_CONNECTED, mysql, ());\n    MYSQL_TRACE_STAGE(mysql, AUTHENTICATE);\n  }\n\n#endif /* HAVE_OPENSSL */\n\n  DBUG_PRINT(\"info\",(\"Server version = '%s'  capabilites: %lu  status: %u  client_flag: %lu\",\n\t\t     mysql->server_version, mysql->server_capabilities,\n\t\t     mysql->server_status, mysql->client_flag));\n\n  compile_time_assert(MYSQL_USERNAME_LENGTH == USERNAME_LENGTH);\n\n  /* This needs to be changed as it's not useful with big packets */\n  if (mysql->user[0])",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  lua_CFunction f;\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  /* C closure */\n      f = clCvalue(s2v(func))->f;\n      goto Cfunc;\n    case LUA_VLCF:  /* light C function */\n      f = fvalue(s2v(func));\n     Cfunc: {\n      int n;  /* number of returns */\n      CallInfo *ci = next_ci(L);\n      checkstackp(L, LUA_MINSTACK, func);  /* ensure minimum stack size */\n      ci->nresults = nresults;\n      ci->callstatus = CIST_C;\n      ci->top = L->top + LUA_MINSTACK;\n      ci->func = func;\n      L->ci = ci;\n      lua_assert(ci->top <= L->stack_last);\n      if (L->hookmask & LUA_MASKCALL) {\n        int narg = cast_int(L->top - func) - 1;\n        luaD_hook(L, LUA_HOOKCALL, -1, 1, narg);\n      }\n      lua_unlock(L);\n      n = (*f)(L);  /* do the actual call */\n      lua_lock(L);\n      api_checknelems(L, n);\n      luaD_poscall(L, ci, n);\n      break;\n    }\n    case LUA_VLCL: {  /* Lua function */\n      CallInfo *ci = next_ci(L);\n      Proto *p = clLvalue(s2v(func))->p;\n      int narg = cast_int(L->top - func) - 1;  /* number of real arguments */\n      int nfixparams = p->numparams;\n      int fsize = p->maxstacksize;  /* frame size */\n      checkstackp(L, fsize, func);\n      ci->nresults = nresults;\n      ci->u.l.savedpc = p->code;  /* starting point */\n      ci->callstatus = 0;\n      ci->top = func + 1 + fsize;\n      ci->func = func;\n      L->ci = ci;\n      for (; narg < nfixparams; narg++)\n        setnilvalue(s2v(L->top++));  /* complete missing arguments */\n      lua_assert(ci->top <= L->stack_last);\n      luaV_execute(L, ci);  /* run the function */\n      break;\n    }\n    default: {  /* not a function */\n      checkstackp(L, 1, func);  /* space for metamethod */\n      luaD_tryfuncTM(L, func);  /* try to get '__call' metamethod */\n      goto retry;  /* try again with metamethod */\n    }\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  lua_CFunction f;\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  /* C closure */\n      f = clCvalue(s2v(func))->f;\n      goto Cfunc;\n    case LUA_VLCF:  /* light C function */\n      f = fvalue(s2v(func));\n     Cfunc: {\n      int n;  /* number of returns */\n      CallInfo *ci;\n      checkstackGCp(L, LUA_MINSTACK, func);  /* ensure minimum stack size */\n      L->ci = ci = next_ci(L);\n      ci->nresults = nresults;\n      ci->callstatus = CIST_C;\n      ci->top = L->top + LUA_MINSTACK;\n      ci->func = func;\n      lua_assert(ci->top <= L->stack_last);\n      if (L->hookmask & LUA_MASKCALL) {\n        int narg = cast_int(L->top - func) - 1;\n        luaD_hook(L, LUA_HOOKCALL, -1, 1, narg);\n      }\n      lua_unlock(L);\n      n = (*f)(L);  /* do the actual call */\n      lua_lock(L);\n      api_checknelems(L, n);\n      luaD_poscall(L, ci, n);\n      break;\n    }\n    case LUA_VLCL: {  /* Lua function */\n      CallInfo *ci;\n      Proto *p = clLvalue(s2v(func))->p;\n      int narg = cast_int(L->top - func) - 1;  /* number of real arguments */\n      int nfixparams = p->numparams;\n      int fsize = p->maxstacksize;  /* frame size */\n      checkstackGCp(L, fsize, func);\n      L->ci = ci = next_ci(L);\n      ci->nresults = nresults;\n      ci->u.l.savedpc = p->code;  /* starting point */\n      ci->callstatus = 0;\n      ci->top = func + 1 + fsize;\n      ci->func = func;\n      L->ci = ci;\n      for (; narg < nfixparams; narg++)\n        setnilvalue(s2v(L->top++));  /* complete missing arguments */\n      lua_assert(ci->top <= L->stack_last);\n      luaV_execute(L, ci);  /* run the function */\n      break;\n    }\n    default: {  /* not a function */\n      checkstackGCp(L, 1, func);  /* space for metamethod */\n      luaD_tryfuncTM(L, func);  /* try to get '__call' metamethod */\n      goto retry;  /* try again with metamethod */\n    }\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                                          {batch_size}, &output_debug_info_t));\n    // Will contain serialized protos, per example.\n    auto output_debug_info = output_debug_info_t->flat<tstring>();\n    const int32 last_tree = resource->num_trees() - 1;\n\n    // For each given example, traverse through all trees keeping track of the\n    // features used to split and the associated logits at each point along the\n    // path. Note: feature_ids has one less value than logits_path because the\n    // first value of each logit path will be the bias.\n    auto do_work = [&resource, &bucketized_features, &output_debug_info,\n                    last_tree](int32 start, int32 end) {\n      for (int32 i = start; i < end; ++i) {\n        // Proto to store debug outputs, per example.\n        boosted_trees::DebugOutput example_debug_info;\n        // Initial bias prediction. E.g., prediction based off training mean.\n        const auto& tree_logits = resource->node_value(0, 0);\n        DCHECK_EQ(tree_logits.size(), 1);\n        float tree_logit = resource->GetTreeWeight(0) * tree_logits[0];\n        example_debug_info.add_logits_path(tree_logit);\n        int32 node_id = 0;\n        int32 tree_id = 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                                          {batch_size}, &output_debug_info_t));\n    // Will contain serialized protos, per example.\n    auto output_debug_info = output_debug_info_t->flat<tstring>();\n    const int32 last_tree = resource->num_trees() - 1;\n\n    // For each given example, traverse through all trees keeping track of the\n    // features used to split and the associated logits at each point along the\n    // path. Note: feature_ids has one less value than logits_path because the\n    // first value of each logit path will be the bias.\n    auto do_work = [&resource, &bucketized_features, &output_debug_info,\n                    last_tree](int64 start, int64 end) {\n      for (int32 i = start; i < end; ++i) {\n        // Proto to store debug outputs, per example.\n        boosted_trees::DebugOutput example_debug_info;\n        // Initial bias prediction. E.g., prediction based off training mean.\n        const auto& tree_logits = resource->node_value(0, 0);\n        DCHECK_EQ(tree_logits.size(), 1);\n        float tree_logit = resource->GetTreeWeight(0) * tree_logits[0];\n        example_debug_info.add_logits_path(tree_logit);\n        int32 node_id = 0;\n        int32 tree_id = 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n{\n    struct yyguts_t dummy_yyguts;\n\n    re_yyset_extra (yy_user_defined, &dummy_yyguts);\n\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n\t\n    *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n\t\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n    \n    /* By setting to 0xAA, we expose bugs in\n    yy_init_globals. Leave at 0x00 for releases. */\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n    \n    re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n    \n    return yy_init_globals ( *ptr_yy_globals );",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n{\n    struct yyguts_t dummy_yyguts;\n\n    re_yyset_extra (yy_user_defined, &dummy_yyguts);\n\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n\n    *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n\n    /* By setting to 0xAA, we expose bugs in\n    yy_init_globals. Leave at 0x00 for releases. */\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n\n    re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n\n    return yy_init_globals ( *ptr_yy_globals );",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tsize_t skblen;\n\tint err;\n\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\n\t\treturn err;\n\t}\n\n\tskblen = skb->len;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\n\t\tif (test_bit(BT_SK_PKT_STATUS, &bt_sk(sk)->flags)) {\n\t\t\tu8 pkt_status = hci_skb_pkt_status(skb);\n\n\t\t\tput_cmsg(msg, SOL_BLUETOOTH, BT_SCM_PKT_STATUS,\n\t\t\t\t sizeof(pkt_status), &pkt_status);\n\t\t}\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skblen;\n\n\treturn err ? : copied;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tstruct sk_buff *skb;\n\tsize_t copied;\n\tsize_t skblen;\n\tint err;\n\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tlock_sock(sk);\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\terr = 0;\n\n\t\trelease_sock(sk);\n\t\treturn err;\n\t}\n\n\tskblen = skb->len;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\t\tif (test_bit(BT_SK_PKT_STATUS, &bt_sk(sk)->flags)) {\n\t\t\tu8 pkt_status = hci_skb_pkt_status(skb);\n\n\t\t\tput_cmsg(msg, SOL_BLUETOOTH, BT_SCM_PKT_STATUS,\n\t\t\t\t sizeof(pkt_status), &pkt_status);\n\t\t}\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\trelease_sock(sk);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skblen;\n\n\treturn err ? : copied;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "            d = div_result.quotient;\n            div_result = d.divided_by(2);\n            ++r;\n        }\n    }\n    if (r == 0) {\n        // n - 1 is odd, so n was even. But there is only one even prime:\n        return n == 2;\n    }\n\n    for (auto a : tests) {\n        // Technically: ASSERT(2 <= a && a <= n - 2)\n        ASSERT(a < n);\n        auto x = ModularPower(a, d, n);\n        if (x == 1 || x == predecessor)\n            continue;\n        bool skip_this_witness = false;\n        // r \u2212 1 iterations.\n        for (size_t i = 0; i < r - 1; ++i) {\n            x = ModularPower(x, 2, n);\n            if (x == predecessor) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "            d = div_result.quotient;\n            div_result = d.divided_by(2);\n            ++r;\n        }\n    }\n    if (r == 0) {\n        // n - 1 is odd, so n was even. But there is only one even prime:\n        return n == 2;\n    }\n\n    for (auto& a : tests) {\n        // Technically: ASSERT(2 <= a && a <= n - 2)\n        ASSERT(a < n);\n        auto x = ModularPower(a, d, n);\n        if (x == 1 || x == predecessor)\n            continue;\n        bool skip_this_witness = false;\n        // r \u2212 1 iterations.\n        for (size_t i = 0; i < r - 1; ++i) {\n            x = ModularPower(x, 2, n);\n            if (x == predecessor) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    all_nodes_.insert(std::make_pair(div_node->name(), div_node));\n    *apply_gradients_node->mutable_input(gradient_pos[apply_gradients_op]) =\n        div_node->name();\n  }\n  LOG(INFO) << \"Graph size after adding div nodes: \" << all_nodes_.size();\n\n  std::vector<const NodeDef*> train_nodes;\n  TF_RETURN_IF_ERROR(ComputeTransitiveFanin(graph_, item.fetch, &train_nodes));\n  LOG(INFO) << \"Number of training nodes: \" << train_nodes.size();\n\n  const NodeDef* dequeue_node;\n  for (const auto& train_node : train_nodes) {\n    if (IsDequeueOp(*train_node)) {\n      dequeue_node = train_node;\n      break;\n    }\n  }\n\n  std::vector<const NodeDef*> input_nodes;\n  if (dequeue_node) {\n    LOG(INFO) << \"Dequeue node: \" << dequeue_node->name();",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    all_nodes_.insert(std::make_pair(div_node->name(), div_node));\n    *apply_gradients_node->mutable_input(gradient_pos[apply_gradients_op]) =\n        div_node->name();\n  }\n  LOG(INFO) << \"Graph size after adding div nodes: \" << all_nodes_.size();\n\n  std::vector<const NodeDef*> train_nodes;\n  TF_RETURN_IF_ERROR(ComputeTransitiveFanin(graph_, item.fetch, &train_nodes));\n  LOG(INFO) << \"Number of training nodes: \" << train_nodes.size();\n\n  const NodeDef* dequeue_node = nullptr;\n  for (const auto& train_node : train_nodes) {\n    if (IsDequeueOp(*train_node)) {\n      dequeue_node = train_node;\n      break;\n    }\n  }\n\n  std::vector<const NodeDef*> input_nodes;\n  if (dequeue_node) {\n    LOG(INFO) << \"Dequeue node: \" << dequeue_node->name();",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (fd >= fdt->max_fds)\n\t\tgoto out_unlock;\n\tfile = fdt->fd[fd];\n\tif (!file)\n\t\tgoto out_unlock;\n\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n\tget_file(file);\n\t*res = file;\n\treturn filp_close(file, files);\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\t*res = NULL;\n\treturn -ENOENT;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (fd >= fdt->max_fds)\n\t\tgoto out_unlock;\n\tfile = fdt->fd[fd];\n\tif (!file)\n\t\tgoto out_unlock;\n\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n\tget_file(file);\n\t*res = file;\n\treturn 0;\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\t*res = NULL;\n\treturn -ENOENT;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ast_for_async_stmt(struct compiling *c, const node *n)\n{\n    /* async_stmt: ASYNC (funcdef | with_stmt | for_stmt) */\n    REQ(n, async_stmt);\n    REQ(CHILD(n, 0), ASYNC);\n\n    switch (TYPE(CHILD(n, 1))) {\n        case funcdef:\n            return ast_for_funcdef_impl(c, CHILD(n, 1), NULL,\n                                        1 /* is_async */);\n        case with_stmt:\n            return ast_for_with_stmt(c, CHILD(n, 1),\n                                     1 /* is_async */);\n\n        case for_stmt:\n            return ast_for_for_stmt(c, CHILD(n, 1),\n                                    1 /* is_async */);\n\n        default:\n            PyErr_Format(PyExc_SystemError,\n                         \"invalid async stament: %s\",\n                         STR(CHILD(n, 1)));\n            return NULL;\n    }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ast_for_async_stmt(struct compiling *c, const node *n)\n{\n    /* async_stmt: 'async' (funcdef | with_stmt | for_stmt) */\n    REQ(n, async_stmt);\n    REQ(CHILD(n, 0), NAME);\n    assert(strcmp(STR(CHILD(n, 0)), \"async\") == 0);\n\n    switch (TYPE(CHILD(n, 1))) {\n        case funcdef:\n            return ast_for_funcdef_impl(c, n, NULL,\n                                        true /* is_async */);\n        case with_stmt:\n            return ast_for_with_stmt(c, n,\n                                     true /* is_async */);\n\n        case for_stmt:\n            return ast_for_for_stmt(c, n,\n                                    true /* is_async */);\n\n        default:\n            PyErr_Format(PyExc_SystemError,\n                         \"invalid async stament: %s\",\n                         STR(CHILD(n, 1)));\n            return NULL;\n    }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tvoid *kbuf;\n\tint ret;\n\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\n\tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_kbuf;\n\t}\n\n\tif (!eptdev->ept) {\n\t\tret = -EPIPE;\n\t\tgoto unlock_eptdev;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tvoid *kbuf;\n\tint ret;\n\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from)) {\n\t\tret = -EFAULT;\n\t\tgoto free_kbuf;\n\t}\n\n\tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_kbuf;\n\t}\n\n\tif (!eptdev->ept) {\n\t\tret = -EPIPE;\n\t\tgoto unlock_eptdev;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "net_bind(short unsigned *port, int type, const char *log_service_name)\n{\n  struct addrinfo hints = { 0 };\n  struct addrinfo *servinfo;\n  struct addrinfo *ptr;\n  const char *cfgaddr;\n  char addr[INET6_ADDRSTRLEN];\n  char strport[8];\n  int yes = 1;\n  int no = 0;\n  int fd;\n  int ret;\n\n  cfgaddr = cfg_getstr(cfg_getsec(cfg, \"general\"), \"bind_address\");\n\n    }\n\n  freeaddrinfo(servinfo);\n\n  if (!ptr)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not create service '%s' with address %s, port %hu: %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", *port, strerror(errno));\n      goto error;\n    }\n\n  // Get the port that was assigned\n  ret = getsockname(fd, ptr->ai_addr, &ptr->ai_addrlen);\n  if (ret < 0)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not find address of service '%s': %s\\n\", log_service_name, strerror(errno));\n      goto error;\n    }\n\n  net_port_get(port, (union net_sockaddr *)ptr->ai_addr);\n  net_address_get(addr, sizeof(addr), (union net_sockaddr *)ptr->ai_addr);\n\n  DPRINTF(E_DBG, L_MISC, \"Service '%s' bound to %s, port %hu, socket %d\\n\", log_service_name, addr, *port, fd);\n\n  return fd;\n\n error:\n  close(fd);\n  return -1;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "net_bind(short unsigned *port, int type, const char *log_service_name)\n{\n  struct addrinfo hints = { 0 };\n  struct addrinfo *servinfo;\n  struct addrinfo *ptr;\n  union net_sockaddr naddr = { 0 };\n  socklen_t naddr_len = sizeof(naddr);\n  const char *cfgaddr;\n  char addr[INET6_ADDRSTRLEN];\n  char strport[8];\n  int yes = 1;\n  int no = 0;\n  int fd;\n  int ret;\n\n  cfgaddr = cfg_getstr(cfg_getsec(cfg, \"general\"), \"bind_address\");\n\n    }\n\n  freeaddrinfo(servinfo);\n\n  if (!ptr)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not create service '%s' with address %s, port %hu: %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", *port, strerror(errno));\n      goto error;\n    }\n\n  // Get our address (as string) and the port that was assigned (necessary when\n  // caller didn't specify a port)\n  ret = getsockname(fd, &naddr.sa, &naddr_len);\n  if (ret < 0)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Error finding address of service '%s': %s\\n\", log_service_name, strerror(errno));\n      goto error;\n    }\n  else if (naddr_len > sizeof(naddr))\n    {\n      DPRINTF(E_LOG, L_MISC, \"Unexpected address length of service '%s'\\n\", log_service_name);\n      goto error;\n    }\n\n  net_port_get(port, &naddr);\n  net_address_get(addr, sizeof(addr), &naddr);\n\n  DPRINTF(E_DBG, L_MISC, \"Service '%s' bound to %s, port %hu, socket %d\\n\", log_service_name, addr, *port, fd);\n\n  return fd;\n\n error:\n  close(fd);\n  return -1;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void TPUPartitionedCallOp::ExecuteFunctions(\n    const std::vector<DeviceAndFHandle>& functions, OpKernelContext* ctx,\n    int device_ordinal, int64_t ordinal_selector_req_id, DoneCallback done) {\n  profiler::TraceMe trace_me(\"TPUPartitionedCallOp-ExecuteFunctions\");\n  FunctionLibraryRuntime::Options opts;\n  opts.step_container = ctx->step_container();\n  opts.stats_collector = ctx->stats_collector();\n  // TODO(akshayka): Consider selecting a runner on a per-device basis,\n  // i.e., using device-specific threadpools when available.\n  opts.runner = ctx->runner();\n  opts.source_device = local_device_name_;\n  opts.run_all_kernels_inline = ctx->run_all_kernels_inline();\n\n  OpInputList arguments;\n  OP_REQUIRES_OK_ASYNC(ctx, ctx->input_list(\"args\", &arguments), done);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void TPUPartitionedCallOp::ExecuteFunctions(\n    const std::vector<DeviceAndFHandle>& functions, OpKernelContext* ctx,\n    int device_ordinal, int64_t ordinal_selector_req_id, DoneCallback done) {\n  profiler::TraceMe trace_me(\"TPUPartitionedCallOp-ExecuteFunctions\");\n  FunctionLibraryRuntime::Options opts(ctx->step_id());\n  opts.step_container = ctx->step_container();\n  opts.stats_collector = ctx->stats_collector();\n  // TODO(akshayka): Consider selecting a runner on a per-device basis,\n  // i.e., using device-specific threadpools when available.\n  opts.runner = ctx->runner();\n  opts.source_device = local_device_name_;\n  opts.run_all_kernels_inline = ctx->run_all_kernels_inline();\n\n  OpInputList arguments;\n  OP_REQUIRES_OK_ASYNC(ctx, ctx->input_list(\"args\", &arguments), done);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ast_for_for_stmt(struct compiling *c, const node *n0, bool is_async)\n{\n    const node * const n = is_async ? CHILD(n0, 1) : n0;\n    asdl_seq *_target, *seq = NULL, *suite_seq;\n    expr_ty expression;\n    expr_ty target, first;\n    const node *node_target;\n    int end_lineno, end_col_offset;\n    /* for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite] */\n    REQ(n, for_stmt);\n\n    if (NCH(n) == 9) {\n        seq = ast_for_suite(c, CHILD(n, 8));\n        if (!seq)\n            return NULL;\n    }\n\n    node_target = CHILD(n, 1);\n    _target = ast_for_exprlist(c, node_target, Store);\n    if (!_target)\n        return NULL;\n    /* Check the # of children rather than the length of _target, since\n       for x, in ... has 1 element in _target, but still requires a Tuple. */\n    if (NCH(node_target) == 1)\n        target = first;\n    else\n        target = Tuple(_target, Store, first->lineno, first->col_offset,\n                       node_target->n_end_lineno, node_target->n_end_col_offset,\n                       c->c_arena);\n\n    expression = ast_for_testlist(c, CHILD(n, 3));\n    if (!expression)\n        return NULL;\n    suite_seq = ast_for_suite(c, CHILD(n, 5));\n    if (!suite_seq)\n        return NULL;\n\n    if (seq != NULL) {\n        get_last_end_pos(seq, &end_lineno, &end_col_offset);\n    } else {\n        get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n    }\n    if (is_async)\n        return AsyncFor(target, expression, suite_seq, seq,\n                        LINENO(n0), n0->n_col_offset,\n                        end_lineno, end_col_offset, c->c_arena);\n    else\n        return For(target, expression, suite_seq, seq,\n                   LINENO(n), n->n_col_offset,\n                   end_lineno, end_col_offset, c->c_arena);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ast_for_for_stmt(struct compiling *c, const node *n0, bool is_async)\n{\n    const node * const n = is_async ? CHILD(n0, 1) : n0;\n    asdl_seq *_target, *seq = NULL, *suite_seq;\n    expr_ty expression;\n    expr_ty target, first;\n    const node *node_target;\n    int end_lineno, end_col_offset;\n    int has_type_comment;\n    string type_comment;\n    /* for_stmt: 'for' exprlist 'in' testlist ':' [TYPE_COMMENT] suite ['else' ':' suite] */\n    REQ(n, for_stmt);\n\n    has_type_comment = TYPE(CHILD(n, 5)) == TYPE_COMMENT;\n\n    if (NCH(n) == 9 + has_type_comment) {\n        seq = ast_for_suite(c, CHILD(n, 8 + has_type_comment));\n        if (!seq)\n            return NULL;\n    }\n\n    node_target = CHILD(n, 1);\n    _target = ast_for_exprlist(c, node_target, Store);\n    if (!_target)\n        return NULL;\n    /* Check the # of children rather than the length of _target, since\n       for x, in ... has 1 element in _target, but still requires a Tuple. */\n    if (NCH(node_target) == 1)\n        target = first;\n    else\n        target = Tuple(_target, Store, first->lineno, first->col_offset,\n                       node_target->n_end_lineno, node_target->n_end_col_offset,\n                       c->c_arena);\n\n    expression = ast_for_testlist(c, CHILD(n, 3));\n    if (!expression)\n        return NULL;\n    suite_seq = ast_for_suite(c, CHILD(n, 5 + has_type_comment));\n    if (!suite_seq)\n        return NULL;\n\n    if (seq != NULL) {\n        get_last_end_pos(seq, &end_lineno, &end_col_offset);\n    } else {\n        get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n    }\n\n    if (has_type_comment) {\n        type_comment = NEW_TYPE_COMMENT(CHILD(n, 5));\n        if (!type_comment)\n            return NULL;\n    }\n    else\n        type_comment = NULL;\n\n    if (is_async)\n        return AsyncFor(target, expression, suite_seq, seq, type_comment,\n                        LINENO(n0), n0->n_col_offset,\n                        end_lineno, end_col_offset, c->c_arena);\n    else\n        return For(target, expression, suite_seq, seq, type_comment,\n                   LINENO(n), n->n_col_offset,\n                   end_lineno, end_col_offset, c->c_arena);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "              fclose(file2);\n\n            if (file1)\n              fclose(file1);\n          }\n          else\n          {\n            ismatch = 1;\n          }\n\n          if (ismatch && remove(groups[g].files[f].file->d_name) == 0)\n          {\n            set_file_action(&groups[g].files[f], FILEACTION_DELIST, deletiontally);\n\n            deletedbytes += groups[g].files[f].file->size;\n            ++totaldeleted;\n\n            if (loginfo)\n              log_file_deleted(loginfo, groups[g].files[f].file->d_name);\n          }\n          else",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "              fclose(file2);\n\n            if (file1)\n              fclose(file1);\n          }\n          else\n          {\n            ismatch = 1;\n          }\n\n          if (ismatch && removeifnotchanged(groups[g].files[f].file, 0) == 0)\n          {\n            set_file_action(&groups[g].files[f], FILEACTION_DELIST, deletiontally);\n\n            deletedbytes += groups[g].files[f].file->size;\n            ++totaldeleted;\n\n            if (loginfo)\n              log_file_deleted(loginfo, groups[g].files[f].file->d_name);\n          }\n          else",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    }\n    printf(\"Media byte 0x%02x (%s)\\n\", b->media, get_media_descr(b->media));\n    printf(\"%10d bytes per logical sector\\n\", GET_UNALIGNED_W(b->sector_size));\n    printf(\"%10d bytes per cluster\\n\", fs->cluster_size);\n    printf(\"%10d reserved sector%s\\n\", le16toh(b->reserved),\n\t   le16toh(b->reserved) == 1 ? \"\" : \"s\");\n    printf(\"First FAT starts at byte %llu (sector %llu)\\n\",\n\t   (unsigned long long)fs->fat_start,\n\t   (unsigned long long)fs->fat_start / lss);\n    printf(\"%10d FATs, %d bit entries\\n\", b->fats, fs->fat_bits);\n    printf(\"%10d bytes per FAT (= %u sectors)\\n\", fs->fat_size,\n\t   fs->fat_size / lss);\n    if (!fs->root_cluster) {\n\tprintf(\"Root directory starts at byte %llu (sector %llu)\\n\",\n\t       (unsigned long long)fs->root_start,\n\t       (unsigned long long)fs->root_start / lss);\n\tprintf(\"%10d root directory entries\\n\", fs->root_entries);\n    } else {\n\tprintf(\"Root directory start at cluster %lu (arbitrary size)\\n\",\n\t       (unsigned long)fs->root_cluster);\n    }\n    printf(\"Data area starts at byte %llu (sector %llu)\\n\",",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    }\n    printf(\"Media byte 0x%02x (%s)\\n\", b->media, get_media_descr(b->media));\n    printf(\"%10d bytes per logical sector\\n\", GET_UNALIGNED_W(b->sector_size));\n    printf(\"%10d bytes per cluster\\n\", fs->cluster_size);\n    printf(\"%10d reserved sector%s\\n\", le16toh(b->reserved),\n\t   le16toh(b->reserved) == 1 ? \"\" : \"s\");\n    printf(\"First FAT starts at byte %llu (sector %llu)\\n\",\n\t   (unsigned long long)fs->fat_start,\n\t   (unsigned long long)fs->fat_start / lss);\n    printf(\"%10d FATs, %d bit entries\\n\", b->fats, fs->fat_bits);\n    printf(\"%10lld bytes per FAT (= %llu sectors)\\n\", (long long)fs->fat_size,\n\t   (long long)fs->fat_size / lss);\n    if (!fs->root_cluster) {\n\tprintf(\"Root directory starts at byte %llu (sector %llu)\\n\",\n\t       (unsigned long long)fs->root_start,\n\t       (unsigned long long)fs->root_start / lss);\n\tprintf(\"%10d root directory entries\\n\", fs->root_entries);\n    } else {\n\tprintf(\"Root directory start at cluster %lu (arbitrary size)\\n\",\n\t       (unsigned long)fs->root_cluster);\n    }\n    printf(\"Data area starts at byte %llu (sector %llu)\\n\",",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void ep4_mul_sim_plain(ep4_t r, const ep4_t p, const bn_t k,\n\t\tconst ep4_t q, const bn_t m, ep4_t *t) {\n\tint i, l, l0, l1, n0, n1, w, gen;\n\tint8_t naf0[2 * RLC_FP_BITS + 1], naf1[2 * RLC_FP_BITS + 1], *_k, *_m;\n\tep4_t t0[1 << (EP_WIDTH - 2)];\n\tep4_t t1[1 << (EP_WIDTH - 2)];\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\t\tep4_null(t0[i]);\n\t\t\t\tep4_new(t0[i]);\n\t\t\t}\n\t\t\tep4_tab(t0, p, EP_WIDTH);\n\t\t\tt = (ep4_t *)t0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void ep4_mul_sim_plain(ep4_t r, const ep4_t p, const bn_t k,\n\t\tconst ep4_t q, const bn_t m, ep4_t *t) {\n\tint i, n0, n1, w, gen;\n\tint8_t naf0[2 * RLC_FP_BITS + 1], naf1[2 * RLC_FP_BITS + 1], *_k, *_m;\n\tep4_t t0[1 << (EP_WIDTH - 2)];\n\tep4_t t1[1 << (EP_WIDTH - 2)];\n\tsize_t l, l0, l1;\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\t\tep4_null(t0[i]);\n\t\t\t\tep4_new(t0[i]);\n\t\t\t}\n\t\t\tep4_tab(t0, p, EP_WIDTH);\n\t\t\tt = (ep4_t *)t0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        (i + buffersStolen + 1 == count);\n    bytes = eorAwareSSLWrite(ssl_, sslWriteBuf, int(len), trackEor);\n\n    if (bytes <= 0) {\n      int error = SSL_get_error(ssl_.get(), int(bytes));\n      if (error == SSL_ERROR_WANT_WRITE) {\n        // The caller will register for write event if not already.\n        *partialWritten = uint32_t(offset);\n        return WriteResult(totalWritten);\n      }\n      auto writeResult = interpretSSLError(int(bytes), error);\n      if (writeResult.writeReturn < 0) {\n        return writeResult;\n      } // else fall through to below to correctly record totalWritten\n    }\n\n    totalWritten += bytes;\n\n    if (bytes == (ssize_t)len) {\n      // The full iovec is written.\n      (*countWritten) += 1 + buffersStolen;\n      i += buffersStolen;\n      // continue\n    } else {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        (i + buffersStolen + 1 == count);\n    bytes = eorAwareSSLWrite(ssl_, sslWriteBuf, int(len), trackEor);\n\n    if (bytes <= 0) {\n      int error = SSL_get_error(ssl_.get(), int(bytes));\n      if (error == SSL_ERROR_WANT_WRITE) {\n        // The caller will register for write event if not already.\n        *partialWritten = uint32_t(offset);\n        return WriteResult(totalWritten);\n      }\n      return interpretSSLError(int(bytes), error);\n    }\n\n    totalWritten += bytes;\n\n    if (bytes == (ssize_t)len) {\n      // The full iovec is written.\n      (*countWritten) += 1 + buffersStolen;\n      i += buffersStolen;\n      // continue\n    } else {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\n\tif (url_len < 1)\n\t\treturn false;\n\n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n\n\tif (port_len) {\n\t\tchar *slash;\n\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\n\tif (url_len < 1)\n\t\treturn false;\n\n\tsnprintf(url_address, 254, \"%.*s\", url_len, url_begin);\n\n\tif (port_len) {\n\t\tchar *slash;\n\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    // convention can be deprecated.\n    //\n    // Note: While this code performs some basic verifications, it generally\n    // assumes consistent op defs and attributes. If more complete\n    // verifications are needed, they should be done by separately, and in a\n    // way that can be reused for type inference.\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        DCHECK(attr != nullptr);\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());\n          }\n\n        } else if (attr->value_case() == AttrValue::kType) {\n          map_dtype_to_tensor(attr->type(), arg);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    // convention can be deprecated.\n    //\n    // Note: While this code performs some basic verifications, it generally\n    // assumes consistent op defs and attributes. If more complete\n    // verifications are needed, they should be done by separately, and in a\n    // way that can be reused for type inference.\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        if (attr == nullptr) {\n          return Status(\n              error::INVALID_ARGUMENT,\n              absl::StrCat(\"Could not find an attribute for key \", arg->s()));\n        }\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());\n          }\n\n        } else if (attr->value_case() == AttrValue::kType) {\n          map_dtype_to_tensor(attr->type(), arg);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void do_free_keypair(struct rsa_keypair *key)\n{\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->d);\n\tcrypto_bignum_free(key->n);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->q);\n\tcrypto_bignum_free(key->qp);\n\tcrypto_bignum_free(key->dp);\n\tcrypto_bignum_free(key->dq);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void do_free_keypair(struct rsa_keypair *key)\n{\n\tcrypto_bignum_free(&key->e);\n\tcrypto_bignum_free(&key->d);\n\tcrypto_bignum_free(&key->n);\n\tcrypto_bignum_free(&key->p);\n\tcrypto_bignum_free(&key->q);\n\tcrypto_bignum_free(&key->qp);\n\tcrypto_bignum_free(&key->dp);\n\tcrypto_bignum_free(&key->dq);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int xmkstemp(char **tmpname, char *dir)\n{\n\tchar *localtmp;\n\tchar *tmpenv;\n\tmode_t old_mode;\n\tint fd, rc;\n\n\t/* Some use cases must be capable of being moved atomically\n\t * with rename(2), which is the reason why dir is here.  */\n\tif (dir != NULL)\n\t\ttmpenv = dir;\n\telse\n\t\ttmpenv = getenv(\"TMPDIR\");\n\n\tif (tmpenv)\n\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", tmpenv,\n\t\t\t  program_invocation_short_name);\n\telse\n\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", _PATH_TMP,\n\t\t\t  program_invocation_short_name);\n\n\tif (rc < 0)\n\t\treturn -1;\n\n\told_mode = umask(077);\n\tfd = mkostemp(localtmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);\n\tumask(old_mode);\n\tif (fd == -1) {\n\t\tfree(localtmp);\n\t\tlocaltmp = NULL;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int xmkstemp(char **tmpname, const char *dir, const char *prefix)\n{\n\tchar *localtmp;\n\tconst char *tmpenv;\n\tmode_t old_mode;\n\tint fd, rc;\n\n\t/* Some use cases must be capable of being moved atomically\n\t * with rename(2), which is the reason why dir is here.  */\n\ttmpenv = dir ? dir : getenv(\"TMPDIR\");\n\tif (!tmpenv)\n\t\ttmpenv = _PATH_TMP;\n\n\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", tmpenv, prefix);\n\tif (rc < 0)\n\t\treturn -1;\n\n\told_mode = umask(077);\n\tfd = mkostemp(localtmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);\n\tumask(old_mode);\n\tif (fd == -1) {\n\t\tfree(localtmp);\n\t\tlocaltmp = NULL;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "const char* Jsi_ValueToString(Jsi_Interp *interp, Jsi_Value *v, int *lenPtr)\n{\n    Jsi_Number d;\n    const char *ntxt = \"undefined\";\n    int kflag = 1;\n    int isKey = 0;\n    char *key = NULL;\n    if (!v)\n        goto done;\n    if (lenPtr) *lenPtr = 0;\n    char unibuf[200];\n    switch(v->vt) {\n        case JSI_VT_STRING:\n            ntxt = v->d.s.str;\n            goto done;\n        case JSI_VT_UNDEF:\n            break;\n        case JSI_VT_BOOL:\n            ntxt = v->d.val ? \"true\":\"false\";\n            break;\n        case JSI_VT_NULL:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "const char* Jsi_ValueToString(Jsi_Interp *interp, Jsi_Value *v, int *lenPtr)\n{\n    Jsi_Number d;\n    const char *ntxt = \"undefined\";\n    int kflag = 1;\n    int isKey = 0;\n    char *key = NULL;\n    if (!v)\n        goto done;\n    if (lenPtr) *lenPtr = 0;\n    char unibuf[JSI_MAX_NUMBER_STRING*2];\n    switch(v->vt) {\n        case JSI_VT_STRING:\n            ntxt = v->d.s.str;\n            goto done;\n        case JSI_VT_UNDEF:\n            break;\n        case JSI_VT_BOOL:\n            ntxt = v->d.val ? \"true\":\"false\";\n            break;\n        case JSI_VT_NULL:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tlen = netlink_send(fd, message);\n\tif (len < 0) {\n\t\tsyslog(LOG_ERR, \"netlink_send failed; error:%d\", len);\n\t\tclose(fd);\n\t\texit(-1);\n\t}\n\n\tpfd.fd = fd;\n\n\twhile (1) {\n\t\tpfd.events = POLLIN;\n\t\tpfd.revents = 0;\n\t\tpoll(&pfd, 1, -1);\n\n\t\tlen = recv(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0);\n\n\t\tif (len < 0) {\n\t\t\tsyslog(LOG_ERR, \"recv failed; error:%d\", len);\n\t\t\tclose(fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tincoming_msg = (struct nlmsghdr *)kvp_recv_buffer;\n\t\tincoming_cn_msg = (struct cn_msg *)NLMSG_DATA(incoming_msg);\n\t\thv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data;\n\n\t\tswitch (hv_msg->kvp_hdr.operation) {\n\t\tcase KVP_OP_REGISTER:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tlen = netlink_send(fd, message);\n\tif (len < 0) {\n\t\tsyslog(LOG_ERR, \"netlink_send failed; error:%d\", len);\n\t\tclose(fd);\n\t\texit(-1);\n\t}\n\n\tpfd.fd = fd;\n\n\twhile (1) {\n\t\tstruct sockaddr *addr_p = (struct sockaddr *) &addr;\n\t\tsocklen_t addr_l = sizeof(addr);\n\t\tpfd.events = POLLIN;\n\t\tpfd.revents = 0;\n\t\tpoll(&pfd, 1, -1);\n\n\t\tlen = recvfrom(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0,\n\t\t\t\taddr_p, &addr_l);\n\n\t\tif (len < 0 || addr.nl_pid) {\n\t\t\tsyslog(LOG_ERR, \"recvfrom failed; pid:%u error:%d %s\",\n\t\t\t\t\taddr.nl_pid, errno, strerror(errno));\n\t\t\tclose(fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tincoming_msg = (struct nlmsghdr *)kvp_recv_buffer;\n\t\tincoming_cn_msg = (struct cn_msg *)NLMSG_DATA(incoming_msg);\n\t\thv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data;\n\n\t\tswitch (hv_msg->kvp_hdr.operation) {\n\t\tcase KVP_OP_REGISTER:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si)\n{\n\ts32 pps_id;\n\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif (pps_id > 255)\n\t\treturn -1;\n\tsi->pps = &avc->pps[pps_id];\n\tsi->pps->id = pps_id;\n\tif (!si->pps->slice_group_count)\n\t\treturn -2;\n\tsi->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT];\n\tif (!si->sps->log2_max_frame_num)\n\t\treturn -2;\n\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si)\n{\n\ts32 pps_id;\n\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id > 255))\n\t\treturn -1;\n\tsi->pps = &avc->pps[pps_id];\n\tsi->pps->id = pps_id;\n\tif (!si->pps->slice_group_count)\n\t\treturn -2;\n\tsi->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT];\n\tif (!si->sps->log2_max_frame_num)\n\t\treturn -2;\n\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    memset(&stt, 0, sizeof (StreamTcpThread));\n    memset(&tcph, 0, sizeof (TCPHdr));\n    FLOW_INITIALIZE(&f);\n    p->flow = &f;\n\n    StreamTcpUTInit(&stt.ra_ctx);\n    stream_config.async_oneside = TRUE;\n\n    tcph.th_win = htons(5480);\n    tcph.th_seq = htonl(10);\n    tcph.th_ack = htonl(11);\n    tcph.th_flags = TH_SYN;\n    p->tcph = &tcph;\n\n    FAIL_IF(StreamTcpPacket(&tv, p, &stt, &pq) == -1);\n\n    p->tcph->th_seq = htonl(11);\n    p->tcph->th_ack = htonl(11);\n    p->tcph->th_flags = TH_ACK;\n    p->flowflags = FLOW_PKT_TOSERVER;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    memset(&stt, 0, sizeof (StreamTcpThread));\n    memset(&tcph, 0, sizeof (TCPHdr));\n    FLOW_INITIALIZE(&f);\n    p->flow = &f;\n\n    StreamTcpUTInit(&stt.ra_ctx);\n    stream_config.async_oneside = TRUE;\n\n    tcph.th_win = htons(5480);\n    tcph.th_seq = htonl(10);\n    tcph.th_ack = 0;\n    tcph.th_flags = TH_SYN;\n    p->tcph = &tcph;\n\n    FAIL_IF(StreamTcpPacket(&tv, p, &stt, &pq) == -1);\n\n    p->tcph->th_seq = htonl(11);\n    p->tcph->th_ack = htonl(11);\n    p->tcph->th_flags = TH_ACK;\n    p->flowflags = FLOW_PKT_TOSERVER;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t\tunsigned int dataoff, unsigned int *timeouts)\n{\n\treturn true;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t\tunsigned int dataoff, unsigned int *timeouts)\n{\n\treturn nf_generic_should_process(nf_ct_protonum(ct));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tff = (float) (ff / FMAXINT); /* shift radix point by 32 bits */\n\tf = (uint32_t) (ff * 1000000000.0);  /* treat fraction as parts per\n\t\t\t\t\t\tbillion */\n\tND_PRINT(\"%u.%09d\", i, f);\n\n\t/*\n\t * print the time in human-readable format.\n\t */\n\tif (i) {\n\t\ttime_t seconds = i - JAN_1970;\n\t\tstruct tm *tm;\n\t\tchar time_buf[128];\n\n\t\ttm = localtime(&seconds);\n\t\tstrftime(time_buf, sizeof (time_buf), \"%Y/%m/%d %H:%M:%S\", tm);\n\t\tND_PRINT(\" (%s)\", time_buf);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tff += FMAXINT;\n\tff = (float) (ff / FMAXINT); /* shift radix point by 32 bits */\n\tf = (uint32_t) (ff * 1000000000.0);  /* treat fraction as parts per\n\t\t\t\t\t\tbillion */\n\tND_PRINT(\"%u.%09d\", i, f);\n\n\t/*\n\t * print the time in human-readable format.\n\t */\n\tif (i) {\n\t\ttime_t seconds = i - JAN_1970;\n\t\tchar time_buf[128];\n\n\t\tND_PRINT(\" (%s)\",\n\t\t    nd_format_time(time_buf, sizeof (time_buf), \"%Y/%m/%d %H:%M:%S\",\n\t\t      localtime(&seconds)));\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int snd_timer_start_slave(struct snd_timer_instance *timeri)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&slave_active_lock, flags);\n\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\tif (timeri->master)\n\t\tlist_add_tail(&timeri->active_list,\n\t\t\t      &timeri->master->slave_active_head);\n\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\treturn 1; /* delayed start */\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int snd_timer_start_slave(struct snd_timer_instance *timeri)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&slave_active_lock, flags);\n\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\tif (timeri->master && timeri->timer) {\n\t\tspin_lock(&timeri->timer->lock);\n\t\tlist_add_tail(&timeri->active_list,\n\t\t\t      &timeri->master->slave_active_head);\n\t\tspin_unlock(&timeri->timer->lock);\n\t}\n\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\treturn 1; /* delayed start */\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\tres = -EBUSY;\n\t\t\t\tgoto err_undo_flags;\n\t\t\t}\n\n\t\t\t/* Flush unicast and multicast addresses */\n\t\t\tdev_uc_flush(bond_dev);\n\t\t\tdev_mc_flush(bond_dev);\n\n\t\t\tif (slave_dev->type != ARPHRD_ETHER)\n\t\t\t\tbond_setup_by_slave(bond_dev, slave_dev);\n\t\t\telse\n\t\t\t\tether_setup(bond_dev);\n\n\t\t\tnetdev_bonding_change(bond_dev,\n\t\t\t\t\t      NETDEV_POST_TYPE_CHANGE);\n\t\t}\n\t} else if (bond_dev->type != slave_dev->type) {\n\t\tpr_err(\"%s ether type (%d) is different from other slaves (%d), can not enslave it.\\n\",\n\t\t       slave_dev->name,\n\t\t       slave_dev->type, bond_dev->type);\n\t\tres = -EINVAL;\n\t\tgoto err_undo_flags;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\tres = -EBUSY;\n\t\t\t\tgoto err_undo_flags;\n\t\t\t}\n\n\t\t\t/* Flush unicast and multicast addresses */\n\t\t\tdev_uc_flush(bond_dev);\n\t\t\tdev_mc_flush(bond_dev);\n\n\t\t\tif (slave_dev->type != ARPHRD_ETHER)\n\t\t\t\tbond_setup_by_slave(bond_dev, slave_dev);\n\t\t\telse {\n\t\t\t\tether_setup(bond_dev);\n\t\t\t\tbond_dev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\t\t\t}\n\n\t\t\tnetdev_bonding_change(bond_dev,\n\t\t\t\t\t      NETDEV_POST_TYPE_CHANGE);\n\t\t}\n\t} else if (bond_dev->type != slave_dev->type) {\n\t\tpr_err(\"%s ether type (%d) is different from other slaves (%d), can not enslave it.\\n\",\n\t\t       slave_dev->name,\n\t\t       slave_dev->type, bond_dev->type);\n\t\tres = -EINVAL;\n\t\tgoto err_undo_flags;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static struct page *alloc_huge_page(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long addr, int avoid_reserve)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *page;\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tlong chg;\n\n\t/*\n\t * Processes that did not create the mapping will have no reserves and\n\t * will not have accounted against quota. Check that the quota can be\n\t * made before satisfying the allocation\n\t * MAP_NORESERVE mappings may also need pages and quota allocated\n\t * if no reserve mapping overlaps.\n\t */\n\tchg = vma_needs_reservation(h, vma, addr);\n\tif (chg < 0)\n\t\treturn ERR_PTR(-VM_FAULT_OOM);\n\tif (chg)\n\t\tif (hugetlb_get_quota(inode->i_mapping, chg))\n\t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n\n\tspin_lock(&hugetlb_lock);\n\tpage = dequeue_huge_page_vma(h, vma, addr, avoid_reserve);\n\tspin_unlock(&hugetlb_lock);\n\n\tif (!page) {\n\t\tpage = alloc_buddy_huge_page(h, NUMA_NO_NODE);\n\t\tif (!page) {\n\t\t\thugetlb_put_quota(inode->i_mapping, chg);\n\t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n\t\t}\n\t}\n\n\tset_page_private(page, (unsigned long) mapping);\n\n\tvma_commit_reservation(h, vma, addr);\n\n\treturn page;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static struct page *alloc_huge_page(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long addr, int avoid_reserve)\n{\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *page;\n\tlong chg;\n\n\t/*\n\t * Processes that did not create the mapping will have no\n\t * reserves and will not have accounted against subpool\n\t * limit. Check that the subpool limit can be made before\n\t * satisfying the allocation MAP_NORESERVE mappings may also\n\t * need pages and subpool limit allocated allocated if no reserve\n\t * mapping overlaps.\n\t */\n\tchg = vma_needs_reservation(h, vma, addr);\n\tif (chg < 0)\n\t\treturn ERR_PTR(-VM_FAULT_OOM);\n\tif (chg)\n\t\tif (hugepage_subpool_get_pages(spool, chg))\n\t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n\n\tspin_lock(&hugetlb_lock);\n\tpage = dequeue_huge_page_vma(h, vma, addr, avoid_reserve);\n\tspin_unlock(&hugetlb_lock);\n\n\tif (!page) {\n\t\tpage = alloc_buddy_huge_page(h, NUMA_NO_NODE);\n\t\tif (!page) {\n\t\t\thugepage_subpool_put_pages(spool, chg);\n\t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n\t\t}\n\t}\n\n\tset_page_private(page, (unsigned long)spool);\n\n\tvma_commit_reservation(h, vma, addr);\n\n\treturn page;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n    /* Parse report rpt_types */\n    while ((pj_int32_t*)rb_hdr < (pj_int32_t*)pkt + pkt_len)\n    {\t\n\trb_len = pj_ntohs((pj_uint16_t)rb_hdr->length);\n\n\t/* Just skip any block with length == 0 (no report content) */\n\tif (rb_len) {\n\t    switch (rb_hdr->bt) {\n\t\tcase BT_RR_TIME:\n\t\t    rb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*) rb_hdr;\n\t\t    break;\n\t\tcase BT_DLRR:\n\t\t    rb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*) rb_hdr;\n\t\t    break;\n\t\tcase BT_STATS:\n\t\t    rb_stats = (pjmedia_rtcp_xr_rb_stats*) rb_hdr;\n\t\t    break;\n\t\tcase BT_VOIP_METRICS:\n\t\t    rb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*) rb_hdr;\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t}\n\trb_hdr = (pjmedia_rtcp_xr_rb_header*)\n\t\t ((pj_int32_t*)rb_hdr + rb_len + 1);\n    }\n\n    /* Receiving RR Time */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n    /* Parse report rpt_types */\n    while ((pj_int32_t*)rb_hdr < (pj_int32_t*)pkt + pkt_len)\n    {\t\n\trb_len = pj_ntohs((pj_uint16_t)rb_hdr->length);\n\n\t/* Just skip any block with length == 0 (no report content) */\n\tif (rb_len) {\n\t    switch (rb_hdr->bt) {\n\t\tcase BT_RR_TIME:\n\t\t    if ((char*)rb_hdr + sizeof(*rb_rr_time) <=\n\t\t\t(char*)pkt + size) \n\t\t    {\n\t\t\trb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*)rb_hdr;\n\t\t    }\n\t\t    break;\n\t\tcase BT_DLRR:\n\t\t    if ((char*)rb_hdr + sizeof(*rb_dlrr) <=\n\t\t\t(char*)pkt + size)\n\t\t    {\n\t\t\trb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*)rb_hdr;\n\t\t    }\n\t\t    break;\n\t\tcase BT_STATS:\n\t\t    if ((char*)rb_hdr + sizeof(*rb_stats) <=\n\t\t\t(char*)pkt + size)\n\t\t    {\n\t\t\trb_stats = (pjmedia_rtcp_xr_rb_stats*)rb_hdr;\n\t\t    }\n\t\t    break;\n\t\tcase BT_VOIP_METRICS:\n\t\t    if ((char*)rb_hdr + sizeof(*rb_voip_mtc) <=\n\t\t\t(char*)pkt + size)\n\t\t    {\n\t\t\trb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*)rb_hdr;\n\t\t    }\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t}\n\trb_hdr = (pjmedia_rtcp_xr_rb_header*)\n\t\t ((pj_int32_t*)rb_hdr + rb_len + 1);\n    }\n\n    /* Receiving RR Time */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void Logger::addPeer(const QString &ip, bool blocked, const QString &reason)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), ip, blocked, reason };\n    m_peers.push_back(temp);\n\n    if (m_peers.size() >= MAX_LOG_MESSAGES)\n        m_peers.pop_front();\n\n    emit newLogPeer(temp);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void Logger::addPeer(const QString &ip, bool blocked, const QString &reason)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), Utils::String::toHtmlEscaped(ip), blocked, Utils::String::toHtmlEscaped(reason) };\n    m_peers.push_back(temp);\n\n    if (m_peers.size() >= MAX_LOG_MESSAGES)\n        m_peers.pop_front();\n\n    emit newLogPeer(temp);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t/* Copy the address and add cmsg data. */\n\tif (family == AF_INET) {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_port = 0 /* skb->h.uh->source */;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\n\t\tif (isk->cmsg_flags)\n\t\t\tip_cmsg_recv(msg, skb);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (family == AF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tstruct ipv6hdr *ip6 = ipv6_hdr(skb);\n\t\tstruct sockaddr_in6 *sin6 =\n\t\t\t(struct sockaddr_in6 *)msg->msg_name;\n\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = 0;\n\t\tsin6->sin6_addr = ip6->saddr;\n\t\tsin6->sin6_flowinfo = 0;\n\t\tif (np->sndflow)\n\t\t\tsin6->sin6_flowinfo = ip6_flowinfo(ip6);\n\n\t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t\t  IP6CB(skb)->iif);\n\t\t*addr_len = sizeof(*sin6);\n\n\t\tif (inet6_sk(sk)->rxopt.all)\n\t\t\tpingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);\n#endif\n\t} else {\n\t\tBUG();\n\t}\n\n\terr = copied;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t/* Copy the address and add cmsg data. */\n\tif (family == AF_INET) {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\n\t\tif (sin) {\n\t\t\tsin->sin_family = AF_INET;\n\t\t\tsin->sin_port = 0 /* skb->h.uh->source */;\n\t\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t\t*addr_len = sizeof(*sin);\n\t\t}\n\n\t\tif (isk->cmsg_flags)\n\t\t\tip_cmsg_recv(msg, skb);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (family == AF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tstruct ipv6hdr *ip6 = ipv6_hdr(skb);\n\t\tstruct sockaddr_in6 *sin6 =\n\t\t\t(struct sockaddr_in6 *)msg->msg_name;\n\n\t\tif (sin6) {\n\t\t\tsin6->sin6_family = AF_INET6;\n\t\t\tsin6->sin6_port = 0;\n\t\t\tsin6->sin6_addr = ip6->saddr;\n\t\t\tsin6->sin6_flowinfo = 0;\n\t\t\tif (np->sndflow)\n\t\t\t\tsin6->sin6_flowinfo = ip6_flowinfo(ip6);\n\t\t\tsin6->sin6_scope_id =\n\t\t\t\tipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t    IP6CB(skb)->iif);\n\t\t\t*addr_len = sizeof(*sin6);\n\t\t}\n\n\t\tif (inet6_sk(sk)->rxopt.all)\n\t\t\tpingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);\n#endif\n\t} else {\n\t\tBUG();\n\t}\n\n\terr = copied;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tast_log(LOG_WARNING, \"midget packet received (%d of %d min)\\n\", res, (int) sizeof(*mh));\n\t\treturn 1;\n\t}\n\tif ((vh->zeros == 0) && (ntohs(vh->callno) & 0x8000)) {\n\t\tif (res < sizeof(*vh)) {\n\t\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\\n\", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* This is a video frame, get call number */\n\t\tfr->callno = find_callno(ntohs(vh->callno) & ~0x8000, dcallno, &sin, new, fd);\n\t\tminivid = 1;\n\t} else if ((meta->zeros == 0) && !(ntohs(meta->metacmd) & 0x8000))\n\t\treturn socket_process_meta(res, meta, &sin, fd, fr);\n\n#ifdef DEBUG_SUPPORT\n\tif (iaxdebug && (res >= sizeof(*fh)))\n\t\tiax_showframe(NULL, fh, 1, &sin, res - sizeof(*fh));\n#endif\n\tif (ntohs(mh->callno) & IAX_FLAG_FULL) {\n\t\tif (res < sizeof(*fh)) {\n\t\t\t\t\t\t       (f.subclass == IAX_COMMAND_POKE) || (f.subclass == IAX_COMMAND_FWDOWNL) ||\n\t\t\t\t\t\t       (f.subclass == IAX_COMMAND_REGREL)))\n\t\t\tnew = NEW_ALLOW;\n\t} else {\n\t\t/* Don't know anything about it yet */\n\t\tf.frametype = AST_FRAME_NULL;\n\t\tf.subclass = 0;\n\t}\n\n\tif (!fr->callno)\n\t\tfr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, new, fd);\n\n\tif (fr->callno > 0)\n\t\tast_mutex_lock(&iaxsl[fr->callno]);\n\n\tif (!fr->callno || !iaxs[fr->callno]) {\n\t\t/* A call arrived for a nonexistent destination.  Unless it's an \"inval\"\n\t\t   frame, reply with an inval */\n\t\tif (ntohs(mh->callno) & IAX_FLAG_FULL) {\n\t\t\t/* We can only raw hangup control frames */\n\t\t\tif (((f.subclass != IAX_COMMAND_INVAL) &&",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tast_log(LOG_WARNING, \"midget packet received (%d of %d min)\\n\", res, (int) sizeof(*mh));\n\t\treturn 1;\n\t}\n\tif ((vh->zeros == 0) && (ntohs(vh->callno) & 0x8000)) {\n\t\tif (res < sizeof(*vh)) {\n\t\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\\n\", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* This is a video frame, get call number */\n\t\tfr->callno = find_callno(ntohs(vh->callno) & ~0x8000, dcallno, &sin, new, fd, 0);\n\t\tminivid = 1;\n\t} else if ((meta->zeros == 0) && !(ntohs(meta->metacmd) & 0x8000))\n\t\treturn socket_process_meta(res, meta, &sin, fd, fr);\n\n#ifdef DEBUG_SUPPORT\n\tif (iaxdebug && (res >= sizeof(*fh)))\n\t\tiax_showframe(NULL, fh, 1, &sin, res - sizeof(*fh));\n#endif\n\tif (ntohs(mh->callno) & IAX_FLAG_FULL) {\n\t\tif (res < sizeof(*fh)) {\n\t\t\t\t\t\t       (f.subclass == IAX_COMMAND_POKE) || (f.subclass == IAX_COMMAND_FWDOWNL) ||\n\t\t\t\t\t\t       (f.subclass == IAX_COMMAND_REGREL)))\n\t\t\tnew = NEW_ALLOW;\n\t} else {\n\t\t/* Don't know anything about it yet */\n\t\tf.frametype = AST_FRAME_NULL;\n\t\tf.subclass = 0;\n\t}\n\n\tif (!fr->callno)\n\t\tfr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, new, fd, ntohs(mh->callno) & IAX_FLAG_FULL);\n\n\tif (fr->callno > 0)\n\t\tast_mutex_lock(&iaxsl[fr->callno]);\n\n\tif (!fr->callno || !iaxs[fr->callno]) {\n\t\t/* A call arrived for a nonexistent destination.  Unless it's an \"inval\"\n\t\t   frame, reply with an inval */\n\t\tif (ntohs(mh->callno) & IAX_FLAG_FULL) {\n\t\t\t/* We can only raw hangup control frames */\n\t\t\tif (((f.subclass != IAX_COMMAND_INVAL) &&",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t/* search the beginning of the number */\n\twhile ( p<end && (*p==' ' || *p=='\\t' || (*p=='\\r' && *(p+1)=='\\n') ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)\n\t\tgoto error;\n\t/* parse the number */\n\tsize = 0;\n\tnumber = 0;\n\twhile (p<end && *p>='0' && *p<='9') {\n\t\tnumber = number*10 + (*p)-'0';\n\t\tif (number<0) {\n\t\t\tLM_ERR(\"number overflow at pos %d in len number [%.*s]\\n\",\n\t\t\t\t(int)(p-buffer),(int)(end-buffer), buffer);\n\t\t\treturn 0;\n\t\t}\n\t\tsize ++;\n\t\tp++;\n\t}\n\tif (p==end || size==0)\n\t\tgoto error;\n\t/* now we should have only spaces at the end */\n\twhile ( p<end && (*p==' ' || *p=='\\t' ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t/* search the beginning of the number */\n\twhile ( p<end && (*p==' ' || *p=='\\t' || (*p=='\\r' && *(p+1)=='\\n') ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)\n\t\tgoto error;\n\t/* parse the number */\n\tsize = 0;\n\tnumber = 0;\n\twhile (p<end && *p>='0' && *p<='9') {\n\t\t/* do not actually cause an integer overflow, as it is UB! --liviu */\n\t\tif (number > 214748363) {\n\t\t\tLM_ERR(\"integer overflow risk at pos %d in len number [%.*s]\\n\",\n\t\t\t\t(int)(p-buffer),(int)(end-buffer), buffer);\n\t\t\treturn 0;\n\t\t}\n\n\t\tnumber = number*10 + (*p)-'0';\n\t\tsize ++;\n\t\tp++;\n\t}\n\tif (p==end || size==0)\n\t\tgoto error;\n\t/* now we should have only spaces at the end */\n\twhile ( p<end && (*p==' ' || *p=='\\t' ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        positive result.  It differs from  % or fmod() which returns a\n        'truncated modulus' result, where floor() is replaced by trunc()\n        and could return a negative result (which is clipped).\n      */\n      result=pixel+value;\n      result-=(QuantumRange+1.0)*floor((double) result/(QuantumRange+1.0));\n      break;\n    }\n    case AndEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel & (size_t) (value+0.5));\n      break;\n    }\n    case CosineEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*(0.5*cos((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case DivideEvaluateOperator:\n    {\n      break;\n    }\n    case LaplacianNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        LaplacianNoise,value);\n      break;\n    }\n    case LeftShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel << (size_t) (value+0.5));\n      break;\n    }\n    case LogEvaluateOperator:\n    {\n      if ((QuantumScale*pixel) >= MagickEpsilon)\n        result=(MagickRealType) (QuantumRange*log((double) (QuantumScale*value*\n          pixel+1.0))/log((double) (value+1.0)));\n      break;\n    }\n    case MaxEvaluateOperator:\n        MultiplicativeGaussianNoise,value);\n      break;\n    }\n    case MultiplyEvaluateOperator:\n    {\n      result=(MagickRealType) (value*pixel);\n      break;\n    }\n    case OrEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel | (size_t) (value+0.5));\n      break;\n    }\n    case PoissonNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        PoissonNoise,value);\n      break;\n    }\n    case PowEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*pow((double) (QuantumScale*pixel),\n        (double) value));\n      break;\n    }\n    case RightShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel >> (size_t) (value+0.5));\n      break;\n    }\n    case RootMeanSquareEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel*pixel+value);\n      break;\n    }\n    case SetEvaluateOperator:\n    {\n      result=value;\n      break;\n    }\n    case UniformNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        UniformNoise,value);\n      break;\n    }\n    case XorEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel ^ (size_t) (value+0.5));\n      break;\n    }\n  }\n  return(result);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        positive result.  It differs from  % or fmod() which returns a\n        'truncated modulus' result, where floor() is replaced by trunc()\n        and could return a negative result (which is clipped).\n      */\n      result=pixel+value;\n      result-=(QuantumRange+1.0)*floor((double) result/(QuantumRange+1.0));\n      break;\n    }\n    case AndEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel & (ssize_t) (value+0.5));\n      break;\n    }\n    case CosineEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*(0.5*cos((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case DivideEvaluateOperator:\n    {\n      break;\n    }\n    case LaplacianNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        LaplacianNoise,value);\n      break;\n    }\n    case LeftShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel << (ssize_t) (value+0.5));\n      break;\n    }\n    case LogEvaluateOperator:\n    {\n      if ((QuantumScale*pixel) >= MagickEpsilon)\n        result=(MagickRealType) (QuantumRange*log((double) (QuantumScale*value*\n          pixel+1.0))/log((double) (value+1.0)));\n      break;\n    }\n    case MaxEvaluateOperator:\n        MultiplicativeGaussianNoise,value);\n      break;\n    }\n    case MultiplyEvaluateOperator:\n    {\n      result=(MagickRealType) (value*pixel);\n      break;\n    }\n    case OrEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel | (ssize_t) (value+0.5));\n      break;\n    }\n    case PoissonNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        PoissonNoise,value);\n      break;\n    }\n    case PowEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*pow((double) (QuantumScale*pixel),\n        (double) value));\n      break;\n    }\n    case RightShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel >> (ssize_t) (value+0.5));\n      break;\n    }\n    case RootMeanSquareEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel*pixel+value);\n      break;\n    }\n    case SetEvaluateOperator:\n    {\n      result=value;\n      break;\n    }\n    case UniformNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        UniformNoise,value);\n      break;\n    }\n    case XorEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel ^ (ssize_t) (value+0.5));\n      break;\n    }\n  }\n  return(result);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static u16 read_16(cdk_stream_t s)\n{\n\tbyte buf[2];\n\tsize_t nread;\n\n\tassert(s != NULL);\n\n\tstream_read(s, buf, 2, &nread);\n\tif (nread != 2)\n\t\treturn (u16) - 1;\n\treturn buf[0] << 8 | buf[1];\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static u16 read_16(cdk_stream_t s)\n{\n\tbyte buf[2];\n\tsize_t nread = 0;\n\n\tassert(s != NULL);\n\n\tstream_read(s, buf, 2, &nread);\n\tif (nread != 2)\n\t\treturn (u16) - 1;\n\treturn buf[0] << 8 | buf[1];\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n{\n\tstatic u32 ip6_proxy_idents_hashrnd __read_mostly;\n\tstruct in6_addr buf[2];\n\tstruct in6_addr *addrs;\n\tu32 id;\n\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n\tif (!addrs)\n\t\treturn 0;\n\n\tnet_get_random_once(&ip6_proxy_idents_hashrnd,\n\t\t\t    sizeof(ip6_proxy_idents_hashrnd));\n\n\tid = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,\n\t\t\t\t &addrs[1], &addrs[0]);\n\treturn htonl(id);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n{\n\tstruct in6_addr buf[2];\n\tstruct in6_addr *addrs;\n\tu32 id;\n\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n\tif (!addrs)\n\t\treturn 0;\n\n\tid = __ipv6_select_ident(net, &addrs[1], &addrs[0]);\n\treturn htonl(id);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void fb_read_bin(fb_t a, const uint8_t *bin, int len) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tif (len != RLC_FB_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tRLC_TRY {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void fb_read_bin(fb_t a, const uint8_t *bin, size_t len) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tif (len != RLC_FB_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tRLC_TRY {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void outbound_phy_packet_callback(struct fw_packet *packet,\n\t\t\t\t\t struct fw_card *card, int status)\n{\n\tstruct outbound_phy_packet_event *e =\n\t\tcontainer_of(packet, struct outbound_phy_packet_event, p);\n\n\tswitch (status) {\n\t/* expected: */\n\tcase ACK_COMPLETE:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\t/* should never happen with PHY packets: */\n\tcase ACK_PENDING:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\tcase ACK_BUSY_X:\n\tcase ACK_BUSY_A:\n\tcase ACK_BUSY_B:\te->phy_packet.rcode = RCODE_BUSY;\tbreak;\n\tcase ACK_DATA_ERROR:\te->phy_packet.rcode = RCODE_DATA_ERROR;\tbreak;\n\tcase ACK_TYPE_ERROR:\te->phy_packet.rcode = RCODE_TYPE_ERROR;\tbreak;\n\t/* stale generation; cancelled; on certain controllers: no ack */\n\tdefault:\t\te->phy_packet.rcode = status;\t\tbreak;\n\t}\n\te->phy_packet.data[0] = packet->timestamp;\n\n\tqueue_event(e->client, &e->event, &e->phy_packet,\n\t\t    sizeof(e->phy_packet) + e->phy_packet.length, NULL, 0);\n\tclient_put(e->client);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void outbound_phy_packet_callback(struct fw_packet *packet,\n\t\t\t\t\t struct fw_card *card, int status)\n{\n\tstruct outbound_phy_packet_event *e =\n\t\tcontainer_of(packet, struct outbound_phy_packet_event, p);\n\tstruct client *e_client;\n\n\tswitch (status) {\n\t/* expected: */\n\tcase ACK_COMPLETE:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\t/* should never happen with PHY packets: */\n\tcase ACK_PENDING:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\tcase ACK_BUSY_X:\n\tcase ACK_BUSY_A:\n\tcase ACK_BUSY_B:\te->phy_packet.rcode = RCODE_BUSY;\tbreak;\n\tcase ACK_DATA_ERROR:\te->phy_packet.rcode = RCODE_DATA_ERROR;\tbreak;\n\tcase ACK_TYPE_ERROR:\te->phy_packet.rcode = RCODE_TYPE_ERROR;\tbreak;\n\t/* stale generation; cancelled; on certain controllers: no ack */\n\tdefault:\t\te->phy_packet.rcode = status;\t\tbreak;\n\t}\n\te->phy_packet.data[0] = packet->timestamp;\n\n\te_client = e->client;\n\tqueue_event(e->client, &e->event, &e->phy_packet,\n\t\t    sizeof(e->phy_packet) + e->phy_packet.length, NULL, 0);\n\tclient_put(e_client);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t}\n\tif (!drop)\n\t{\n\t    switch (mode)\n\t    {\n\t\tcase PASTE_CMDLINE:\n\t\t    put_on_cmdline(buf, idx, TRUE);\n\t\t    break;\n\n\t\tcase PASTE_EX:\n\t\t    if (gap != NULL && ga_grow(gap, idx) == OK)\n\t\t    {\n\t\t\tmch_memmove((char *)gap->ga_data + gap->ga_len,\n\t\t\t\t\t\t\t     buf, (size_t)idx);\n\t\t\tgap->ga_len += idx;\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_INSERT:\n\t\t    if (stop_arrow() == OK)\n\t\t    {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t}\n\tif (!drop)\n\t{\n\t    switch (mode)\n\t    {\n\t\tcase PASTE_CMDLINE:\n\t\t    put_on_cmdline(buf, idx, TRUE);\n\t\t    break;\n\n\t\tcase PASTE_EX:\n\t\t    // add one for the NUL that is going to be appended\n\t\t    if (gap != NULL && ga_grow(gap, idx + 1) == OK)\n\t\t    {\n\t\t\tmch_memmove((char *)gap->ga_data + gap->ga_len,\n\t\t\t\t\t\t\t     buf, (size_t)idx);\n\t\t\tgap->ga_len += idx;\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_INSERT:\n\t\t    if (stop_arrow() == OK)\n\t\t    {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int ZlibInStream::pos()\n{\n  return offset + ptr - start;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "size_t ZlibInStream::pos()\n{\n  return offset + ptr - start;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int udpv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions opt_space;\n\tstruct udp_sock *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n\tstruct in6_addr *daddr, *final_p, final;\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_len = msg->msg_namelen;\n\tint ulen = len;\n\tint hlimit = -1;\n\tint tclass = -1;\n\tint dontfrag = -1;\n\tint corkreq = up->corkflag || msg->msg_flags&MSG_MORE;\n\tint err;\n\t\t}\n\t\tif ((fl6.flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (!flowlabel)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t\tconnected = 0;\n\t}\n\tif (!opt)\n\t\topt = np->opt;\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tif (!ipv6_addr_any(daddr))\n\t\tfl6.daddr = *daddr;\n\telse\n\t\tfl6.daddr.s6_addr[15] = 0x1; /* :: means loopback (BSD'ism) */\n\tif (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))\n#endif\n\t\t\t\t      NULL);\n\t\t} else {\n\t\t\tdst_release(dst);\n\t\t}\n\t\tdst = NULL;\n\t}\n\nout:\n\tdst_release(dst);\n\tfl6_sock_release(flowlabel);\n\tif (!err)\n\t\treturn len;\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t */\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int udpv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions opt_space;\n\tstruct udp_sock *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n\tstruct in6_addr *daddr, *final_p, final;\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ipv6_txoptions *opt_to_free = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_len = msg->msg_namelen;\n\tint ulen = len;\n\tint hlimit = -1;\n\tint tclass = -1;\n\tint dontfrag = -1;\n\tint corkreq = up->corkflag || msg->msg_flags&MSG_MORE;\n\tint err;\n\t\t}\n\t\tif ((fl6.flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (!flowlabel)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t\tconnected = 0;\n\t}\n\tif (!opt) {\n\t\topt = txopt_get(np);\n\t\topt_to_free = opt;\n\t}\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tif (!ipv6_addr_any(daddr))\n\t\tfl6.daddr = *daddr;\n\telse\n\t\tfl6.daddr.s6_addr[15] = 0x1; /* :: means loopback (BSD'ism) */\n\tif (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))\n\t\t\t\t      NULL);\n\t\t} else {\n\t\t\tdst_release(dst);\n\t\t}\n\t\tdst = NULL;\n\t}\n\nout:\n\tdst_release(dst);\n\tfl6_sock_release(flowlabel);\n\ttxopt_put(opt_to_free);\n\tif (!err)\n\t\treturn len;\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t */\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        if (pindex->pprev)\n            pindex->pprev->pnext = NULL;\n\n    // Connect longer branch\n    BOOST_FOREACH(CBlockIndex* pindex, vConnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = pindex;\n\n    // Resurrect memory transactions that were in the disconnected branch\n    BOOST_FOREACH(CTransaction& tx, vResurrect)\n        tx.AcceptToMemoryPool(txdb, false);\n\n    // Delete redundant memory transactions that are in the connected branch\n    BOOST_FOREACH(CTransaction &tx, vDelete) {\n        mempool.remove(tx);\n        mempool.removeConflicts(tx);\n    }\n\n    printf(\"REORGANIZE: done\\n\");\n\n    return true;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        if (pindex->pprev)\n            pindex->pprev->pnext = NULL;\n\n    // Connect longer branch\n    BOOST_FOREACH(CBlockIndex* pindex, vConnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = pindex;\n\n    // Resurrect memory transactions that were in the disconnected branch\n    BOOST_FOREACH(CTransaction& tx, vResurrect)\n      tx.AcceptToMemoryPool(txdb, true, false);\n\n    // Delete redundant memory transactions that are in the connected branch\n    BOOST_FOREACH(CTransaction &tx, vDelete) {\n        mempool.remove(tx);\n        mempool.removeConflicts(tx);\n    }\n\n    printf(\"REORGANIZE: done\\n\");\n\n    return true;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n\t       sizeof(ualg->cru_driver_name));\n\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n\t       CRYPTO_MAX_ALG_NAME);\n\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\n\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"larval\");\n\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n\t\t\t    sizeof(struct crypto_report_larval), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tstrncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrncpy(ualg->cru_driver_name, alg->cra_driver_name,\n\t\tsizeof(ualg->cru_driver_name));\n\tstrncpy(ualg->cru_module_name, module_name(alg->cra_module),\n\t\tsizeof(ualg->cru_module_name));\n\n\tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\n\t\tstrncpy(rl.type, \"larval\", sizeof(rl.type));\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n\t\t\t    sizeof(struct crypto_report_larval), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\ttimes.nb_items = names.nb_items = count;\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 di;\n\t\tGF_ISOSample *s = gf_isom_get_sample(file, chap_tk, i+1, &di);\n\t\tif (!s) continue;\n\t\tGF_BitStream *bs = gf_bs_new(s->data, s->dataLength, GF_BITSTREAM_READ);\n\t\tGF_TextSample *txt = gf_isom_parse_text_sample(bs);\n\t\tif (txt) {\n\t\t\ttimes.vals[i] = (u32) s->DTS;\n\t\t\tnames.vals[i] = gf_strdup(txt->text);\n\t\t\tgf_isom_delete_text_sample(txt);\n\t\t}\n\t\tgf_bs_del(bs);\n\t\tgf_isom_sample_del(&s);\n\t}\n\tp.type = GF_PROP_UINT_LIST;\n\tp.value.uint_list = times;\n\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_TIMES, &p);\n\tgf_free(times.vals);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\ttimes.nb_items = names.nb_items = count;\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 di;\n\t\tGF_ISOSample *s = gf_isom_get_sample(file, chap_tk, i+1, &di);\n\t\tif (!s) continue;\n\t\tGF_BitStream *bs = gf_bs_new(s->data, s->dataLength, GF_BITSTREAM_READ);\n\t\tGF_TextSample *txt = gf_isom_parse_text_sample(bs);\n\t\tif (txt) {\n\t\t\ttimes.vals[i] = (u32) s->DTS;\n\t\t\tnames.vals[i] = gf_strdup(txt->text ? txt->text : \"\");\n\t\t\tgf_isom_delete_text_sample(txt);\n\t\t}\n\t\tgf_bs_del(bs);\n\t\tgf_isom_sample_del(&s);\n\t}\n\tp.type = GF_PROP_UINT_LIST;\n\tp.value.uint_list = times;\n\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_TIMES, &p);\n\tgf_free(times.vals);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "tvb_get_manuf_name(tvbuff_t *tvb, gint offset)\n{\n    return get_manuf_name(tvb_get_ptr(tvb, offset, 3));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "tvb_get_manuf_name(tvbuff_t *tvb, gint offset)\n{\n    guint8 buf[6] = { 0 };\n    tvb_memcpy(tvb, buf, offset, 3);\n    return get_manuf_name(buf, sizeof(buf));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int jas_memdump(FILE *out, void *data, size_t len)\n{\n\tsize_t i;\n\tsize_t j;\n\tuchar *dp;\n\tdp = data;\n\tfor (i = 0; i < len; i += 16) {\n\t\tfprintf(out, \"%04zx:\", i);\n\t\tfor (j = 0; j < 16; ++j) {\n\t\t\tif (i + j < len) {\n\t\t\t\tfprintf(out, \" %02x\", dp[i + j]);\n\t\t\t}\n\t\t}\n\t\tfprintf(out, \"\\n\");\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int jas_memdump(FILE *out, void *data, size_t len)\n{\n\tsize_t i;\n\tsize_t j;\n\tjas_uchar *dp;\n\tdp = data;\n\tfor (i = 0; i < len; i += 16) {\n\t\tfprintf(out, \"%04zx:\", i);\n\t\tfor (j = 0; j < 16; ++j) {\n\t\t\tif (i + j < len) {\n\t\t\t\tfprintf(out, \" %02x\", dp[i + j]);\n\t\t\t}\n\t\t}\n\t\tfprintf(out, \"\\n\");\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n      if (C_SslForceTls)\n        ans = MUTT_YES;\n      else if ((ans = query_quadoption(C_SslStarttls,\n                                       _(\"Secure connection with TLS?\"))) == MUTT_ABORT)\n      {\n        goto err_close_conn;\n      }\n      if (ans == MUTT_YES)\n      {\n        enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_NO_FLAGS);\n        if (rc == IMAP_EXEC_FATAL)\n          goto bail;\n        if (rc != IMAP_EXEC_ERROR)\n        {\n          if (mutt_ssl_starttls(adata->conn))\n          {\n            mutt_error(_(\"Could not negotiate TLS connection\"));\n            goto err_close_conn;\n          }\n          else",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n      if (C_SslForceTls)\n        ans = MUTT_YES;\n      else if ((ans = query_quadoption(C_SslStarttls,\n                                       _(\"Secure connection with TLS?\"))) == MUTT_ABORT)\n      {\n        goto err_close_conn;\n      }\n      if (ans == MUTT_YES)\n      {\n        enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_SINGLE);\n        // Clear any data after the STARTTLS acknowledgement\n        mutt_socket_empty(adata->conn);\n\n        if (rc == IMAP_EXEC_FATAL)\n          goto bail;\n        if (rc != IMAP_EXEC_ERROR)\n        {\n          if (mutt_ssl_starttls(adata->conn))\n          {\n            mutt_error(_(\"Could not negotiate TLS connection\"));\n            goto err_close_conn;\n          }\n          else",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n\n    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in));\n\n    const Tensor* num_buckets_t;\n    OP_REQUIRES_OK(context, context->input(\"num_buckets\", &num_buckets_t));\n    const int64 num_buckets = num_buckets_t->scalar<int64>()();\n\n    const Tensor* strong_hash_t;\n    OP_REQUIRES_OK(context, context->input(\"strong_hash\", &strong_hash_t));\n    const bool strong_hash = strong_hash_t->scalar<bool>()();\n\n    const Tensor* salt_t;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n\n    // Set internal_type to invalid_type so that the check will be ignored.\n    DataType internal_type = DT_INVALID;\n    OP_REQUIRES_OK(\n        context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,\n                               dense_list_in, internal_type));\n\n    const Tensor* num_buckets_t;\n    OP_REQUIRES_OK(context, context->input(\"num_buckets\", &num_buckets_t));\n    const int64 num_buckets = num_buckets_t->scalar<int64>()();\n\n    const Tensor* strong_hash_t;\n    OP_REQUIRES_OK(context, context->input(\"strong_hash\", &strong_hash_t));\n    const bool strong_hash = strong_hash_t->scalar<bool>()();\n\n    const Tensor* salt_t;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n  int new_mi_size;\n\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n  }\n\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    // Create the segmentation map structure and set to 0.\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n\n  if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n    if (!cm->above_context) goto fail;\n\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n\n  return 0;\n\nfail:\n  // clear the mi_* values to force a realloc on resync\n  vp9_set_mb_mi(cm, 0, 0);\n  vp9_free_context_buffers(cm);\n  return 1;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n  int new_mi_size;\n\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n  }\n  if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n    if (!cm->above_context) goto fail;\n\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    // Create the segmentation map structure and set to 0.\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n\n  return 0;\n\nfail:\n  // clear the mi_* values to force a realloc on resync\n  vp9_set_mb_mi(cm, 0, 0);\n  vp9_free_context_buffers(cm);\n  return 1;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tif (edp->nargs > SUN_EMUL_NARGS - 1) {\n\t\t\tbcopy(edp->args + 1, edp->args,\n\t\t\t    (SUN_EMUL_NARGS - 1) * sizeof(edp->args[0]));\n\t\t\tedp->args[edp->nargs = SUN_EMUL_NARGS - 1] = 0;\n\t\t}\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\n\tcase ';':\t\t/* argument terminator */\n\t\tedp->nargs++;\n\t\tbreak;\n\n\tdefault:\t\t/* end of escape sequence */\n\t\toargs = edp->nargs++;\n\t\tif (edp->nargs > SUN_EMUL_NARGS)\n\t\t\tedp->nargs = SUN_EMUL_NARGS;\n\t\trc = wsemul_sun_control(edp, instate);\n\t\tif (rc != 0) {\n\t\t\t/* undo nargs progress */\n\t\t\tedp->nargs = oargs;\n\n\t\t\treturn rc;\n\t\t}\n\t\tedp->state = SUN_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tif (edp->nargs > SUN_EMUL_NARGS - 1) {\n\t\t\tbcopy(edp->args + 1, edp->args,\n\t\t\t    (SUN_EMUL_NARGS - 1) * sizeof(edp->args[0]));\n\t\t\tedp->args[edp->nargs = SUN_EMUL_NARGS - 1] = 0;\n\t\t}\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\n\tcase ';':\t\t/* argument terminator */\n\t\tif (edp->nargs < SUN_EMUL_NARGS)\n\t\t\tedp->nargs++;\n\t\tbreak;\n\n\tdefault:\t\t/* end of escape sequence */\n\t\toargs = edp->nargs;\n\t\tif (edp->nargs < SUN_EMUL_NARGS)\n\t\t\tedp->nargs++;\n\t\trc = wsemul_sun_control(edp, instate);\n\t\tif (rc != 0) {\n\t\t\t/* undo nargs progress */\n\t\t\tedp->nargs = oargs;\n\n\t\t\treturn rc;\n\t\t}\n\t\tedp->state = SUN_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn Boolean::New(Isolate::GetCurrent(), result);\n\t\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn Undefined(Isolate::GetCurrent());\n\t\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (!BIO_dgram_is_sctp(SSL_get_rbio(s)))\n  \t\t{\n#endif\n\t\t/* Check whether this is a repeat, or aged record.\n\t\t * Don't check if we're listening and this message is\n\t\t * a ClientHello. They can look as if they're replayed,\n\t\t * since they arrive from different connections and\n\t\t * would be dropped unnecessarily.\n\t\t */\n\t\tif (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&\n\t\t    *p == SSL3_MT_CLIENT_HELLO) &&\n\t\t    !dtls1_record_replay_check(s, bitmap))\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\ts->packet_length=0; /* dump this record */\n\t\t\tgoto again;     /* get another record */\n\t\t\t}\n#ifndef OPENSSL_NO_SCTP\n  \t\t}\n#endif\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (!BIO_dgram_is_sctp(SSL_get_rbio(s)))\n  \t\t{\n#endif\n\t\t/* Check whether this is a repeat, or aged record.\n\t\t * Don't check if we're listening and this message is\n\t\t * a ClientHello. They can look as if they're replayed,\n\t\t * since they arrive from different connections and\n\t\t * would be dropped unnecessarily.\n\t\t */\n\t\tif (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&\n\t\t    s->packet_length > DTLS1_RT_HEADER_LENGTH &&\n\t\t    s->packet[DTLS1_RT_HEADER_LENGTH] == SSL3_MT_CLIENT_HELLO) &&\n\t\t    !dtls1_record_replay_check(s, bitmap))\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\ts->packet_length=0; /* dump this record */\n\t\t\tgoto again;     /* get another record */\n\t\t\t}\n#ifndef OPENSSL_NO_SCTP\n  \t\t}\n#endif\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t//here we have to handle that in a clever way\n\tto_read = (u32) ptr->size;\n\ttmpName = (char*)gf_malloc(sizeof(char) * to_read);\n\tif (!tmpName) return GF_OUT_OF_MEM;\n\t//get the data\n\tgf_bs_read_data(bs, tmpName, to_read);\n\n\t//then get the break\n\ti = 0;\n\twhile ( (tmpName[i] != 0) && (i < to_read) ) {\n\t\ti++;\n\t}\n\t//check the data is consistent\n\tif (i == to_read) {\n\t\tgf_free(tmpName);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t//no NULL char, URL is not specified\n\tif (i == to_read - 1) {\n\t\tptr->nameURN = tmpName;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\t//here we have to handle that in a clever way\n\tto_read = (u32) ptr->size;\n\ttmpName = (char*)gf_malloc(sizeof(char) * to_read);\n\tif (!tmpName) return GF_OUT_OF_MEM;\n\t//get the data\n\tgf_bs_read_data(bs, tmpName, to_read);\n\n\t//then get the break\n\ti = 0;\n\twhile ( (i < to_read) && (tmpName[i] != 0) ) {\n\t\ti++;\n\t}\n\t//check the data is consistent\n\tif (i == to_read) {\n\t\tgf_free(tmpName);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t//no NULL char, URL is not specified\n\tif (i == to_read - 1) {\n\t\tptr->nameURN = tmpName;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {\n\t\tr_asn1_free_object (object);\n\t\tfree (container);\n\t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects ||\n\t\t!object->list.objects[0] || !object->list.objects[1] ||\n\t\tobject->list.objects[1]->list.length != 1) {\n\t\tr_asn1_free_object (object);\n\t\tfree (container);\n\t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "parse_memory(VALUE klass, VALUE data)\n{\n  xmlParserCtxtPtr ctxt;\n\n  if (NIL_P(data)) {\n    rb_raise(rb_eArgError, \"data cannot be nil\");\n  }\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n\n  ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                   (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "parse_memory(VALUE klass, VALUE data)\n{\n  xmlParserCtxtPtr ctxt;\n\n  Check_Type(data, T_STRING);\n\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n\n  ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                   (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      if (low_prev) {\n        if (*low > s)\n          *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);\n        else\n          *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                 (pprev ? pprev : str), p);\n      }\n    }\n    else {\n      if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n        *low = p - reg->dmax;\n        if (*low > s) {\n          *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n                                          *low, (const UChar** )low_prev);\n          if (low_prev && IS_NULL(*low_prev))\n            *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                   (pprev ? pprev : s), *low);\n        }\n        else {\n          if (low_prev)\n            *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                   (pprev ? pprev : str), *low);\n        }\n      }\n    }\n    /* no needs to adjust *high, *high is used as range check only */\n    *high = p - reg->dmin;\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr,\n    \"forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\\n\",\n\t    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      if (low_prev) {\n        if (*low > s)\n          *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);\n        else\n          *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                 (pprev ? pprev : str), p);\n      }\n    }\n    else {\n      if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n        if (p - str < reg->dmax) {\n          *low = (UChar* )str;\n          if (low_prev)\n            *low_prev = onigenc_get_prev_char_head(reg->enc, str, *low);\n        }\n        else {\n          *low = p - reg->dmax;\n          if (*low > s) {\n            *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n                                                 *low, (const UChar** )low_prev);\n            if (low_prev && IS_NULL(*low_prev))\n              *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : s), *low);\n          }\n          else {\n            if (low_prev)\n              *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : str), *low);\n          }\n        }\n      }\n    }\n    /* no needs to adjust *high, *high is used as range check only */\n    *high = p - reg->dmin;\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr,\n    \"forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\\n\",\n\t    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n      if(buffer && row < screen->rows && col < screen->cols)\n        *new_cell = buffer[row * screen->cols + col];\n      else {\n        new_cell->chars[0] = 0;\n        new_cell->pen = screen->pen;\n      }\n    }\n  }\n\n  if(buffer)\n    vterm_allocator_free(screen->vt, buffer);\n\n  return new_buffer;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n      if(buffer && row < screen->rows && col < screen->cols)\n        *new_cell = buffer[row * screen->cols + col];\n      else {\n        new_cell->chars[0] = 0;\n        new_cell->pen = screen->pen;\n      }\n    }\n  }\n\n  vterm_allocator_free(screen->vt, buffer);\n\n  return new_buffer;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "find_auth_end (FlatpakProxyClient *client, Buffer *buffer)\n{\n  guchar *match;\n  int i;\n\n  /* First try to match any leftover at the start */\n  if (client->auth_end_offset > 0)\n    {\n      gsize left = strlen (AUTH_END_STRING) - client->auth_end_offset;\n      gsize to_match = MIN (left, buffer->pos);\n      /* Matched at least up to to_match */\n      if (memcmp (buffer->data, &AUTH_END_STRING[client->auth_end_offset], to_match) == 0)\n        {\n          client->auth_end_offset += to_match;\n\n          /* Matched all */\n          if (client->auth_end_offset == strlen (AUTH_END_STRING))\n            return to_match;\n\n          /* Matched to end of buffer */\n          return -1;\n        }\n\n      /* Did not actually match at start */\n      client->auth_end_offset = -1;\n    }\n\n  /* Look for whole match inside buffer */\n  match = memmem (buffer, buffer->pos,\n                  AUTH_END_STRING, strlen (AUTH_END_STRING));\n  if (match != NULL)\n    return match - buffer->data + strlen (AUTH_END_STRING);\n\n  /* Record longest prefix match at the end */\n  for (i = MIN (strlen (AUTH_END_STRING) - 1, buffer->pos); i > 0; i--)\n    {\n      if (memcmp (buffer->data + buffer->pos - i, AUTH_END_STRING, i) == 0)\n        {\n          client->auth_end_offset = i;\n          break;\n        }\n    }\n\n  return -1;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "find_auth_end (FlatpakProxyClient *client, Buffer *buffer)\n{\n  goffset offset = 0;\n  gsize original_size = client->auth_buffer->len;\n\n  /* Add the new data to the remaining data from last iteration */\n  g_byte_array_append (client->auth_buffer, buffer->data, buffer->pos);\n\n  while (TRUE)\n    {\n      guint8 *line_start = client->auth_buffer->data + offset;\n      gsize remaining_data = client->auth_buffer->len - offset;\n      guint8 *line_end;\n\n      line_end = memmem (line_start, remaining_data,\n                         AUTH_LINE_SENTINEL, strlen (AUTH_LINE_SENTINEL));\n      if (line_end) /* Found end of line */\n        {\n          offset = (line_end + strlen (AUTH_LINE_SENTINEL) - line_start);\n\n          if (!auth_line_is_valid (line_start, line_end))\n            return FIND_AUTH_END_ABORT;\n\n          *line_end = 0;\n          if (auth_line_is_begin (line_start))\n            return offset - original_size;\n\n          /* continue with next line */\n        }\n      else\n        {\n          /* No end-of-line in this buffer */\n          g_byte_array_remove_range (client->auth_buffer, 0, offset);\n\n          /* Abort if more than 16k before newline, similar to what dbus-daemon does */\n          if (client->auth_buffer->len >= 16*1024)\n            return FIND_AUTH_END_ABORT;\n\n          return FIND_AUTH_END_CONTINUE;\n        }\n    }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tibuf->ops = NULL;\n\t\t\topipe->nrbufs++;\n\t\t\tipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);\n\t\t\tipipe->nrbufs--;\n\t\t\tinput_wakeup = true;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Get a reference to this pipe buffer,\n\t\t\t * so we can copy the contents over.\n\t\t\t */\n\t\t\tpipe_buf_get(ipipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\n\t\t\t/*\n\t\t\t * Don't inherit the gift flag, we need to\n\t\t\t * prevent multiple steals of this page.\n\t\t\t */\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\t\tobuf->len = len;\n\t\t\topipe->nrbufs++;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tibuf->ops = NULL;\n\t\t\topipe->nrbufs++;\n\t\t\tipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);\n\t\t\tipipe->nrbufs--;\n\t\t\tinput_wakeup = true;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Get a reference to this pipe buffer,\n\t\t\t * so we can copy the contents over.\n\t\t\t */\n\t\t\tif (!pipe_buf_get(ipipe, ibuf)) {\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*obuf = *ibuf;\n\n\t\t\t/*\n\t\t\t * Don't inherit the gift flag, we need to\n\t\t\t * prevent multiple steals of this page.\n\t\t\t */\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\t\tobuf->len = len;\n\t\t\topipe->nrbufs++;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n    int ret = 0;\n    int id = 1;\n    Packet *p1 = NULL;\n    DefragTracker *tracker1 = NULL, *tracker2 = NULL;\n\n    DefragInit();\n\n    /* Build a packet, its not a fragment but shouldn't matter for\n     * this test. */\n    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n    if (p1 == NULL) {\n        goto end;\n    }\n\n    /* Get a tracker. It shouldn't look like its already in use. */\n    tracker1 = DefragGetTracker(NULL, NULL, p1);\n    if (tracker1 == NULL) {\n        goto end;\n    }\n    if (tracker1->seen_last) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n    int ret = 0;\n    int id = 1;\n    Packet *p1 = NULL;\n    DefragTracker *tracker1 = NULL, *tracker2 = NULL;\n\n    DefragInit();\n\n    /* Build a packet, its not a fragment but shouldn't matter for\n     * this test. */\n    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n    if (p1 == NULL) {\n        goto end;\n    }\n\n    /* Get a tracker. It shouldn't look like its already in use. */\n    tracker1 = DefragGetTracker(NULL, NULL, p1);\n    if (tracker1 == NULL) {\n        goto end;\n    }\n    if (tracker1->seen_last) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void xen_irq_lateeoi_locked(struct irq_info *info)\n{\n\tevtchn_port_t evtchn;\n\n\tevtchn = info->evtchn;\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn;\n\n\tunmask_evtchn(evtchn);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void xen_irq_lateeoi_locked(struct irq_info *info)\n{\n\tevtchn_port_t evtchn;\n\tunsigned int cpu;\n\n\tevtchn = info->evtchn;\n\tif (!VALID_EVTCHN(evtchn) || !list_empty(&info->eoi_list))\n\t\treturn;\n\n\tcpu = info->eoi_cpu;\n\tif (info->eoi_time && info->irq_epoch == per_cpu(irq_epoch, cpu)) {\n\t\tlateeoi_list_add(info);\n\t\treturn;\n\t}\n\n\tinfo->eoi_time = 0;\n\tunmask_evtchn(evtchn);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int context_init(SERVICE_OPTIONS *section) { /* init TLS context */\n    /* create TLS context */\n#if OPENSSL_VERSION_NUMBER>=0x10100000L\n    if(section->option.client)\n        section->ctx=SSL_CTX_new(TLS_client_method());\n    else /* server mode */\n        section->ctx=SSL_CTX_new(TLS_server_method());\n    if(!SSL_CTX_set_min_proto_version(section->ctx,\n            section->min_proto_version)) {\n        s_log(LOG_ERR, \"Failed to set the minimum protocol version 0x%X\",\n            section->min_proto_version);\n        return 1; /* FAILED */\n#else /* OPENSSL_VERSION_NUMBER<0x10100000L */\n    if(section->option.client)\n        section->ctx=SSL_CTX_new(section->client_method);\n    else /* server mode */\n        section->ctx=SSL_CTX_new(section->server_method);\n#endif /* OPENSSL_VERSION_NUMBER<0x10100000L */\n    if(!section->ctx) {\n        sslerror(\"SSL_CTX_new\");\n        return 1; /* FAILED */\n    }\n    /* for callbacks */\n    if(!SSL_CTX_set_ex_data(section->ctx, index_ssl_ctx_opt, section)) {\n        sslerror(\"SSL_CTX_set_ex_data\");\n        return 1; /* FAILED */\n    }\n    current_section=section; /* setup current section for callbacks */\n\n    /* ciphers */\n    if(section->cipher_list) {\n        s_log(LOG_DEBUG, \"Ciphers: %s\", section->cipher_list);\n        if(!SSL_CTX_set_cipher_list(section->ctx, section->cipher_list)) {\n            sslerror(\"SSL_CTX_set_cipher_list\");\n            return 1; /* FAILED */\n        }\n    }\n\n        section->ssl_options_set, section->ssl_options_clear);\n#else /* OpenSSL older than 0.9.8m */\n    s_log(LOG_DEBUG, \"TLS options: 0x%08lX (+0x%08lX)\",\n        SSL_CTX_get_options(section->ctx), section->ssl_options_set);\n#endif /* OpenSSL 0.9.8m or later */\n\n    /* initialize OpenSSL CONF options */\n    if(conf_init(section))\n        return 1; /* FAILED */\n\n    /* mode */\n#ifdef SSL_MODE_RELEASE_BUFFERS\n    SSL_CTX_set_mode(section->ctx,\n        SSL_MODE_ENABLE_PARTIAL_WRITE |\n        SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER |\n        SSL_MODE_RELEASE_BUFFERS);\n#else\n    SSL_CTX_set_mode(section->ctx,\n        SSL_MODE_ENABLE_PARTIAL_WRITE |\n        SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);\n#endif\n    SSL_CTX_set_info_callback(section->ctx, info_callback);\n\n    /* load certificate and private key to be verified by the peer server */\n    if(auth_init(section))\n        return 1; /* FAILED */\n\n    /* initialize verification of the peer server certificate */\n    if(verify_init(section))\n        return 1; /* FAILED */\n\n    /* initialize the DH/ECDH key agreement in the server mode */\n    if(!section->option.client) {\n#ifndef OPENSSL_NO_TLSEXT\n        SSL_CTX_set_tlsext_servername_callback(section->ctx, servername_cb);\n#endif /* OPENSSL_NO_TLSEXT */\n#ifndef OPENSSL_NO_DH\n        dh_init(section); /* ignore the result (errors are not critical) */\n#endif /* OPENSSL_NO_DH */\n#ifndef OPENSSL_NO_ECDH\n        ecdh_init(section); /* ignore the result (errors are not critical) */\n#endif /* OPENSSL_NO_ECDH */\n    }\n\n    return 0; /* OK */\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int context_init(SERVICE_OPTIONS *section) { /* init TLS context */\n    /* create a new TLS context */\n#if OPENSSL_VERSION_NUMBER>=0x10100000L\n    if(section->option.client)\n        section->ctx=SSL_CTX_new(TLS_client_method());\n    else /* server mode */\n        section->ctx=SSL_CTX_new(TLS_server_method());\n    if(!SSL_CTX_set_min_proto_version(section->ctx,\n            section->min_proto_version)) {\n        s_log(LOG_ERR, \"Failed to set the minimum protocol version 0x%X\",\n            section->min_proto_version);\n        return 1; /* FAILED */\n#else /* OPENSSL_VERSION_NUMBER<0x10100000L */\n    if(section->option.client)\n        section->ctx=SSL_CTX_new(section->client_method);\n    else /* server mode */\n        section->ctx=SSL_CTX_new(section->server_method);\n#endif /* OPENSSL_VERSION_NUMBER<0x10100000L */\n    if(!section->ctx) {\n        sslerror(\"SSL_CTX_new\");\n        return 1; /* FAILED */\n    }\n\n    /* allow callbacks to access their SERVICE_OPTIONS structure */\n    if(!SSL_CTX_set_ex_data(section->ctx, index_ssl_ctx_opt, section)) {\n        sslerror(\"SSL_CTX_set_ex_data\");\n        return 1; /* FAILED */\n    }\n    current_section=section; /* setup current section for callbacks */\n\n#if OPENSSL_VERSION_NUMBER>=0x10100000L\n    /* set the security level */\n    if(section->security_level>=0) {\n        /* set the user-specified value */\n        SSL_CTX_set_security_level(section->ctx, section->security_level);\n        s_log(LOG_INFO, \"User-specified security level set: %d\",\n            section->security_level);\n    } else if(SSL_CTX_get_security_level(section->ctx)<DEFAULT_SECURITY_LEVEL) {\n        /* set our default, as it is more secure than the OpenSSL default */\n        SSL_CTX_set_security_level(section->ctx, DEFAULT_SECURITY_LEVEL);\n        s_log(LOG_INFO, \"stunnel default security level set: %d\",\n            DEFAULT_SECURITY_LEVEL);\n    } else { /* our default is not more secure than the OpenSSL default */\n        s_log(LOG_INFO, \"OpenSSL security level is used: %d\",\n            SSL_CTX_get_security_level(section->ctx));\n    }\n#endif /* OpenSSL 1.1.0 or later */\n\n    /* ciphers */\n    if(section->cipher_list) {\n        s_log(LOG_DEBUG, \"Ciphers: %s\", section->cipher_list);\n        if(!SSL_CTX_set_cipher_list(section->ctx, section->cipher_list)) {\n            sslerror(\"SSL_CTX_set_cipher_list\");\n            return 1; /* FAILED */\n        }\n    }\n\n        section->ssl_options_set, section->ssl_options_clear);\n#else /* OpenSSL older than 0.9.8m */\n    s_log(LOG_DEBUG, \"TLS options: 0x%08lX (+0x%08lX)\",\n        SSL_CTX_get_options(section->ctx), section->ssl_options_set);\n#endif /* OpenSSL 0.9.8m or later */\n\n    /* initialize OpenSSL CONF options */\n    if(conf_init(section))\n        return 1; /* FAILED */\n\n    /* setup mode of operation for the TLS state machine */\n#ifdef SSL_MODE_RELEASE_BUFFERS\n    SSL_CTX_set_mode(section->ctx,\n        SSL_MODE_ENABLE_PARTIAL_WRITE |\n        SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER |\n        SSL_MODE_RELEASE_BUFFERS);\n#else\n    SSL_CTX_set_mode(section->ctx,\n        SSL_MODE_ENABLE_PARTIAL_WRITE |\n        SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);\n#endif\n    SSL_CTX_set_info_callback(section->ctx, info_callback);\n\n    /* load certificate and private key to be verified by the peer server */\n    if(auth_init(section))\n        return 1; /* FAILED */\n\n    /* initialize verification of the peer server certificate */\n    if(verify_init(section))\n        return 1; /* FAILED */\n\n    /* initialize the DH/ECDH key agreement */\n#ifndef OPENSSL_NO_TLSEXT\n    if(!section->option.client)\n        SSL_CTX_set_tlsext_servername_callback(section->ctx, servername_cb);\n#endif /* OPENSSL_NO_TLSEXT */\n#ifndef OPENSSL_NO_DH\n    dh_init(section); /* ignore the result (errors are not critical) */\n#endif /* OPENSSL_NO_DH */\n#ifndef OPENSSL_NO_ECDH\n    ecdh_init(section); /* ignore the result (errors are not critical) */\n#endif /* OPENSSL_NO_ECDH */\n\n    return 0; /* OK */\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "sudo_passwd_verify(const struct sudoers_context *ctx, struct passwd *pw,\n    const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback)\n{\n    char des_pass[9], *epass;\n    char *pw_epasswd = auth->data;\n    size_t pw_len;\n    int matched = 0;\n    debug_decl(sudo_passwd_verify, SUDOERS_DEBUG_AUTH);\n\n    /* An empty plain-text password must match an empty encrypted password. */\n    if (pass[0] == '\\0')\n\tdebug_return_int(pw_epasswd[0] ? AUTH_FAILURE : AUTH_SUCCESS);\n\n    /*\n     * Truncate to 8 chars if standard DES since not all crypt()'s do this.\n     */\n    pw_len = strlen(pw_epasswd);\n    if (pw_len == DESLEN || HAS_AGEINFO(pw_epasswd, pw_len)) {\n\tstrlcpy(des_pass, pass, sizeof(des_pass));\n\tpass = des_pass;\n    }\n\n    /*\n     * Normal UN*X password check.\n     * HP-UX may add aging info (separated by a ',') at the end so\n     * only compare the first DESLEN characters in that case.\n     */\n    epass = (char *) crypt(pass, pw_epasswd);\n    if (epass != NULL) {\n\tif (HAS_AGEINFO(pw_epasswd, pw_len) && strlen(epass) == DESLEN)\n\t    matched = !strncmp(pw_epasswd, epass, DESLEN);\n\telse\n\t    matched = !strcmp(pw_epasswd, epass);\n    }\n\n    explicit_bzero(des_pass, sizeof(des_pass));\n\n    debug_return_int(matched ? AUTH_SUCCESS : AUTH_FAILURE);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "sudo_passwd_verify(const struct sudoers_context *ctx, struct passwd *pw,\n    const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback)\n{\n    char des_pass[9], *epass;\n    char *pw_epasswd = auth->data;\n    size_t pw_len;\n    int ret;\n    debug_decl(sudo_passwd_verify, SUDOERS_DEBUG_AUTH);\n\n    /* An empty plain-text password must match an empty encrypted password. */\n    if (pass[0] == '\\0')\n\tdebug_return_int(pw_epasswd[0] ? AUTH_FAILURE : AUTH_SUCCESS);\n\n    /*\n     * Truncate to 8 chars if standard DES since not all crypt()'s do this.\n     */\n    pw_len = strlen(pw_epasswd);\n    if (pw_len == DESLEN || HAS_AGEINFO(pw_epasswd, pw_len)) {\n\t(void)strlcpy(des_pass, pass, sizeof(des_pass));\n\tpass = des_pass;\n    }\n\n    /*\n     * Normal UN*X password check.\n     * HP-UX may add aging info (separated by a ',') at the end so\n     * only compare the first DESLEN characters in that case.\n     */\n    epass = (char *) crypt(pass, pw_epasswd);\n    ret = AUTH_FAILURE;\n    if (epass != NULL) {\n\tif (HAS_AGEINFO(pw_epasswd, pw_len) && strlen(epass) == DESLEN) {\n\t    if (strncmp(pw_epasswd, epass, DESLEN) == 0)\n\t\tret = AUTH_SUCCESS;\n\t} else {\n\t    if (strcmp(pw_epasswd, epass) == 0)\n\t\tret = AUTH_SUCCESS;\n\t}\n    }\n\n    explicit_bzero(des_pass, sizeof(des_pass));\n\n    debug_return_int(ret);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (es) {\n\t\t\tts->ess[es->pid] = es;\n\t\t\tgf_list_add(pmt->program->streams, es);\n\t\t\tif (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);\n\n\t\t\tnb_es++;\n\t\t}\n\n\t\tif (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;\n\t}\n\n\t//Table 2-139, implied hierarchy indexes\n\tif (nb_hevc_temp + nb_shvc + nb_shvc_temp + nb_mhvc+ nb_mhvc_temp) {\n\t\tfor (i=0; i<gf_list_count(pmt->program->streams); i++) {\n\t\t\tGF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);\n\t\t\tif ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;\n\t\t\tif (es->depends_on_pid) continue;\n\n\t\t\tswitch (es->stream_type) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (es) {\n\t\t\tts->ess[es->pid] = es;\n\t\t\tgf_list_add(pmt->program->streams, es);\n\t\t\tif (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);\n\n\t\t\tnb_es++;\n\n\t\t\tif (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;\n\t\t}\n\t}\n\n\t//Table 2-139, implied hierarchy indexes\n\tif (nb_hevc_temp + nb_shvc + nb_shvc_temp + nb_mhvc+ nb_mhvc_temp) {\n\t\tfor (i=0; i<gf_list_count(pmt->program->streams); i++) {\n\t\t\tGF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);\n\t\t\tif ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;\n\t\t\tif (es->depends_on_pid) continue;\n\n\t\t\tswitch (es->stream_type) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "/* static */ tsl::Status GpuDriver::GetGpuISAVersion(int* version,\n                                                     CUdevice device) {\n  return tsl::Status{\n      port::error::INTERNAL,\n      \"Feature not supported on CUDA platform (GetGpuISAVersion)\"};\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "/* static */ tsl::Status GpuDriver::GetGpuISAVersion(int* version,\n                                                     CUdevice device) {\n  return tsl::Status{\n      tsl::error::INTERNAL,\n      \"Feature not supported on CUDA platform (GetGpuISAVersion)\"};\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int Archive::Read(void *Data,size_t Size)\n{\n  size_t Result;\n  if (QOpen.Read(Data,Size,Result))\n    return (int)Result;\n  return File::Read(Data,Size);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int Archive::Read(void *Data,size_t Size)\n{\n#ifdef USE_QOPEN\n  size_t QResult;\n  if (QOpen.Read(Data,Size,QResult))\n    return (int)QResult;\n#endif\n#ifdef USE_ARCMEM\n  size_t AResult;\n  if (ArcMem.Read(Data,Size,AResult))\n    return (int)AResult;\n#endif\n  return File::Read(Data,Size);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    char_u\t*s;\n\n    // check if it is a valid value for 'complete' -- Acevedo\n    for (s = *varp; *s;)\n    {\n\twhile (*s == ',' || *s == ' ')\n\t    s++;\n\tif (!*s)\n\t    break;\n\tif (vim_strchr((char_u *)\".wbuksid]tU\", *s) == NULL)\n\t    return illegal_char(args->os_errbuf, *s);\n\tif (*++s != NUL && *s != ',' && *s != ' ')\n\t{\n\t    if (s[-1] == 'k' || s[-1] == 's')\n\t    {\n\t\t// skip optional filename after 'k' and 's'\n\t\twhile (*s && *s != ',' && *s != ' ')\n\t\t{\n\t\t    if (*s == '\\\\' && s[1] != NUL)\n\t\t\t++s;\n\t\t    ++s;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (args->os_errbuf != NULL)\n\t\t{\n\t\t    sprintf((char *)args->os_errbuf,\n\t\t\t    _(e_illegal_character_after_chr), *--s);\n\t\t    return args->os_errbuf;\n\t\t}\n\t\treturn \"\";\n\t    }\n\t}\n    }\n\n    return NULL;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    char_u\t*s;\n\n    // check if it is a valid value for 'complete' -- Acevedo\n    for (s = *varp; *s;)\n    {\n\twhile (*s == ',' || *s == ' ')\n\t    s++;\n\tif (!*s)\n\t    break;\n\tif (vim_strchr((char_u *)\".wbuksid]tU\", *s) == NULL)\n\t    return illegal_char(args->os_errbuf, args->os_errbuflen, *s);\n\tif (*++s != NUL && *s != ',' && *s != ' ')\n\t{\n\t    if (s[-1] == 'k' || s[-1] == 's')\n\t    {\n\t\t// skip optional filename after 'k' and 's'\n\t\twhile (*s && *s != ',' && *s != ' ')\n\t\t{\n\t\t    if (*s == '\\\\' && s[1] != NUL)\n\t\t\t++s;\n\t\t    ++s;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (args->os_errbuf != NULL)\n\t\t{\n\t\t    snprintf((char *)args->os_errbuf, args->os_errbuflen,\n\t\t\t    _(e_illegal_character_after_chr), *--s);\n\t\t    return args->os_errbuf;\n\t\t}\n\t\treturn \"\";\n\t    }\n\t}\n    }\n\n    return NULL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    void runTest() override\n    {\n        beginTest (\"ZIP\");\n\n        ZipFile::Builder builder;\n        StringArray entryNames { \"first\", \"second\", \"third\" };\n        HashMap<String, MemoryBlock> blocks;\n\n        for (auto& entryName : entryNames)\n        {\n            auto& block = blocks.getReference (entryName);\n            MemoryOutputStream mo (block, false);\n            mo << entryName;\n            mo.flush();\n            builder.addEntry (new MemoryInputStream (block, false), 9, entryName, Time::getCurrentTime());\n        }\n\n        MemoryBlock data;\n        MemoryOutputStream mo (data, false);\n        builder.writeToStream (mo, nullptr);\n        MemoryInputStream mi (data, false);\n\n        ZipFile zip (mi);\n\n        expectEquals (zip.getNumEntries(), entryNames.size());\n\n        for (auto& entryName : entryNames)\n        {\n            auto* entry = zip.getEntry (entryName);\n            std::unique_ptr<InputStream> input (zip.createStreamForEntry (*entry));\n            expectEquals (input->readEntireStreamAsString(), entryName);\n        }\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    void runTest() override\n    {\n        beginTest (\"ZIP\");\n\n        StringArray entryNames { \"first\", \"second\", \"third\" };\n        auto data = createZipMemoryBlock (entryNames);\n        MemoryInputStream mi (data, false);\n        ZipFile zip (mi);\n\n        expectEquals (zip.getNumEntries(), entryNames.size());\n\n        for (auto& entryName : entryNames)\n        {\n            auto* entry = zip.getEntry (entryName);\n            std::unique_ptr<InputStream> input (zip.createStreamForEntry (*entry));\n            expectEquals (input->readEntireStreamAsString(), entryName);\n        }\n\n        beginTest (\"ZipSlip\");\n        runZipSlipTest();\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_set(args);\n\n\t/*\n\t * Find a \"hole\" in the attribute address space large enough for\n\t * us to drop the new attribute's value into. Because CRC enable\n\t * attributes have headers, we can't just do a straight byte to FSB\n\t * conversion and have to take the header space into account.\n\t */\n\tblkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\terror = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,\n\t\t\t\t\t\t   XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\n\targs->rmtblkno = lblkno = (xfs_dablk_t)lfileoff;\n\targs->rmtblkcnt = blkcnt;\n\n\t/*\n\t * Roll through the \"value\", allocating blocks on disk as required.\n\t}\n\n\t/*\n\t * Roll through the \"value\", copying the attribute value to the\n\t * already-allocated blocks.  Blocks are written synchronously\n\t * so that we can know they are all on disk before we turn off\n\t * the INCOMPLETE flag.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tvaluelen = args->valuelen;\n\twhile (valuelen > 0) {\n\t\tstruct xfs_buf\t*bp;\n\t\txfs_daddr_t\tdblkno;\n\t\tint\t\tdblkcnt;\n\n\t\tASSERT(blkcnt > 0);\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)lblkno,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_set(args);\n\n\t/*\n\t * Find a \"hole\" in the attribute address space large enough for\n\t * us to drop the new attribute's value into. Because CRC enable\n\t * attributes have headers, we can't just do a straight byte to FSB\n\t * conversion and have to take the header space into account.\n\t */\n\tblkcnt = xfs_attr3_rmt_blocks(mp, args->rmtvaluelen);\n\terror = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,\n\t\t\t\t\t\t   XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\n\targs->rmtblkno = lblkno = (xfs_dablk_t)lfileoff;\n\targs->rmtblkcnt = blkcnt;\n\n\t/*\n\t * Roll through the \"value\", allocating blocks on disk as required.\n\t}\n\n\t/*\n\t * Roll through the \"value\", copying the attribute value to the\n\t * already-allocated blocks.  Blocks are written synchronously\n\t * so that we can know they are all on disk before we turn off\n\t * the INCOMPLETE flag.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tstruct xfs_buf\t*bp;\n\t\txfs_daddr_t\tdblkno;\n\t\tint\t\tdblkcnt;\n\n\t\tASSERT(blkcnt > 0);\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)lblkno,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,\n        bigint *modulus, bigint *pub_exp)\n{\n    int i, size;\n    bigint *decrypted_bi, *dat_bi;\n    bigint *bir = NULL;\n    uint8_t *block = (uint8_t *)malloc(sig_len);\n\n    /* decrypt */\n    dat_bi = bi_import(ctx, sig, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    /* convert to a normal block */\n    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);\n\n    bi_export(ctx, decrypted_bi, block, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    i = 10; /* start at the first possible non-padded byte */\n    while (block[i++] && i < sig_len);\n    size = sig_len - i;\n\n    /* get only the bit we want */\n    if (size > 0)\n    {\n        int len;\n        const uint8_t *sig_ptr = get_signature(&block[i], &len);\n\n        if (sig_ptr)\n        {\n            bir = bi_import(ctx, sig_ptr, len);\n        }\n    }\n    free(block);\n    /* save a few bytes of memory */\n    bi_clear_cache(ctx);\n    return bir;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len, uint8_t sig_type,\n        bigint *modulus, bigint *pub_exp)\n{\n    int i;\n    bigint *decrypted_bi, *dat_bi;\n    bigint *bir = NULL;\n    uint8_t *block = (uint8_t *)malloc(sig_len);\n\n    const uint8_t *sig_prefix = NULL;\n    uint8_t sig_prefix_size = 0, hash_len = 0;\n    /* adjust our expections */\n    switch (sig_type)\n    {\n        case SIG_TYPE_MD5:\n            sig_prefix = sig_prefix_md5;\n            sig_prefix_size = sizeof(sig_prefix_md5);\n        break;\n        case SIG_TYPE_SHA1:\n            sig_prefix = sig_prefix_sha1;\n            sig_prefix_size = sizeof(sig_prefix_sha1);\n        break;\n        case SIG_TYPE_SHA256:\n            sig_prefix = sig_prefix_sha256;\n            sig_prefix_size = sizeof(sig_prefix_sha256);\n        break;\n        case SIG_TYPE_SHA384:\n            sig_prefix = sig_prefix_sha384;\n            sig_prefix_size = sizeof(sig_prefix_sha384);\n        break;\n        case SIG_TYPE_SHA512:\n            sig_prefix = sig_prefix_sha512;\n            sig_prefix_size = sizeof(sig_prefix_sha512);\n        break;\n    }\n    if (sig_prefix)\n        hash_len = sig_prefix[sig_prefix_size - 1];\n\n    /* check length (#A) */\n    if (sig_len < 2 + 8 + 1 + sig_prefix_size + hash_len)\n        goto err;\n\n    /* decrypt */\n    dat_bi = bi_import(ctx, sig, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    /* convert to a normal block */\n    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);\n\n    bi_export(ctx, decrypted_bi, block, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    /* check the first 2 bytes */\n    if (block[0] != 0 || block[1] != 1)\n        goto err;\n\n    /* check the padding */\n    i = 2; /* start at the first padding byte */\n    while (i < sig_len - 1 - sig_prefix_size - hash_len)\n    { /* together with (#A), we require at least 8 bytes of padding */\n        if (block[i++] != 0xFF)\n            goto err;\n    }\n\n    /* check end of padding */\n    if (block[i++] != 0)\n        goto err;\n\n    /* check the ASN.1 metadata */\n    if (memcmp_P(block+i, sig_prefix, sig_prefix_size))\n        goto err;\n\n    /* now we can get the hash we need */\n    bir = bi_import(ctx, block + i + sig_prefix_size, hash_len);\n\nerr:\n    free(block);\n    /* save a few bytes of memory */\n    bi_clear_cache(ctx);\n    return bir;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                errors::InvalidArgument(\"pooling_ratio field must \"\n                                        \"specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional max pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      // If both seeds are not set when deterministic_ is true, force set seeds.\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                errors::InvalidArgument(\"pooling_ratio field must \"\n                                        \"specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional max pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      // If both seeds are not set when deterministic_ is true, force set seeds.\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\texfat_debug(\"failed to get stream dentry\\n\");\n\t\t*skip_dentries = 2;\n\t\tgoto skip_dset;\n\t}\n\n\t*new_node = NULL;\n\tnode = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tfor (i = 2; i <= file_de->file_num_ext; i++) {\n\t\tret = exfat_de_iter_get(iter, i, &dentry);\n\t\tif (ret || dentry->type != EXFAT_NAME)\n\t\t\tbreak;\n\t\tmemcpy(node->name +\n\t\t       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,\n\t\t       sizeof(dentry->name_unicode));\n\t}\n\n\tnode->first_clus = le32_to_cpu(stream_de->stream_start_clu);\n\tnode->is_contiguous =",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\texfat_debug(\"failed to get stream dentry\\n\");\n\t\t*skip_dentries = 2;\n\t\tgoto skip_dset;\n\t}\n\n\t*new_node = NULL;\n\tnode = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tfor (i = 2; i <= MIN(file_de->file_num_ext, 1 + MAX_NAME_DENTRIES); i++) {\n\t\tret = exfat_de_iter_get(iter, i, &dentry);\n\t\tif (ret || dentry->type != EXFAT_NAME)\n\t\t\tbreak;\n\t\tmemcpy(node->name +\n\t\t       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,\n\t\t       sizeof(dentry->name_unicode));\n\t}\n\n\tnode->first_clus = le32_to_cpu(stream_de->stream_start_clu);\n\tnode->is_contiguous =",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t}\n\n\t/* On a TCP-style socket, block for at most linger_time if set. */\n\tif (sctp_style(sk, TCP) && timeout)\n\t\tsctp_wait_for_close(sk, timeout);\n\n\t/* This will run the backlog queue.  */\n\trelease_sock(sk);\n\n\t/* Supposedly, no process has access to the socket, but\n\t * the net layers still may.\n\t */\n\tlocal_bh_disable();\n\tbh_lock_sock(sk);\n\n\t/* Hold the sock, since sk_common_release() will put sock_put()\n\t * and we have just a little more cleanup.\n\t */\n\tsock_hold(sk);\n\tsk_common_release(sk);\n\n\tbh_unlock_sock(sk);\n\tlocal_bh_enable();\n\n\tsock_put(sk);\n\n\tSCTP_DBG_OBJCNT_DEC(sock);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\t/* On a TCP-style socket, block for at most linger_time if set. */\n\tif (sctp_style(sk, TCP) && timeout)\n\t\tsctp_wait_for_close(sk, timeout);\n\n\t/* This will run the backlog queue.  */\n\trelease_sock(sk);\n\n\t/* Supposedly, no process has access to the socket, but\n\t * the net layers still may.\n\t * Also, sctp_destroy_sock() needs to be called with addr_wq_lock\n\t * held and that should be grabbed before socket lock.\n\t */\n\tspin_lock_bh(&net->sctp.addr_wq_lock);\n\tbh_lock_sock(sk);\n\n\t/* Hold the sock, since sk_common_release() will put sock_put()\n\t * and we have just a little more cleanup.\n\t */\n\tsock_hold(sk);\n\tsk_common_release(sk);\n\n\tbh_unlock_sock(sk);\n\tspin_unlock_bh(&net->sctp.addr_wq_lock);\n\n\tsock_put(sk);\n\n\tSCTP_DBG_OBJCNT_DEC(sock);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static pyc_object *get_list_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (list size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_LIST;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static pyc_object *get_list_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (list size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_LIST;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tlog_warn(\"sonmp\", \"failed to allocate remote port\");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\tif (length < SONMP_SIZE) {\n\t\tlog_warnx(\"sonmp\", \"too short SONMP frame received on %s\", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (PEEK_CMP(mcastaddr, sizeof(mcastaddr)) != 0)\n\t\t/* There is two multicast address. We just handle only one of\n\t\t * them. */\n\t\tgoto malformed;\n\t/* We skip to LLC PID */\n\tPEEK_DISCARD(ETHER_ADDR_LEN); PEEK_DISCARD_UINT16;\n\tPEEK_DISCARD(6);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tlog_warn(\"sonmp\", \"failed to allocate remote port\");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\tif (length < SONMP_SIZE + 2*ETHER_ADDR_LEN + sizeof(u_int16_t)) {\n\t\tlog_warnx(\"sonmp\", \"too short SONMP frame received on %s\", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (PEEK_CMP(mcastaddr, sizeof(mcastaddr)) != 0)\n\t\t/* There is two multicast address. We just handle only one of\n\t\t * them. */\n\t\tgoto malformed;\n\t/* We skip to LLC PID */\n\tPEEK_DISCARD(ETHER_ADDR_LEN); PEEK_DISCARD_UINT16;\n\tPEEK_DISCARD(6);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "unsigned char *base64decode(const char *buf, size_t *size)\n{\n\tif (!buf || !size) return NULL;\n\tsize_t len = (*size > 0) ? *size : strlen(buf);\n\tif (len <= 0) return NULL;\n\tunsigned char *outbuf = (unsigned char*)malloc((len/4)*3+3);\n\tconst char *ptr = buf;\n\tint p = 0;\n\tsize_t l = 0;\n\n\tdo {\n\t\tptr += strspn(ptr, \"\\r\\n\\t \");\n\t\tif (*ptr == '\\0' || ptr >= buf+len) {\n\t\t\tbreak;\n\t\t}\n\t\tl = strcspn(ptr, \"\\r\\n\\t \");\n\t\tif (l > 3 && ptr+l <= buf+len) {\n\t\t\tp+=base64decode_block(outbuf+p, ptr, l);\n\t\t\tptr += l;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t} while (1);\n\n\toutbuf[p] = 0;\n\t*size = p;\n\treturn outbuf;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "unsigned char *base64decode(const char *buf, size_t *size)\n{\n\tif (!buf || !size) return NULL;\n\tsize_t len = (*size > 0) ? *size : strlen(buf);\n\tif (len <= 0) return NULL;\n\tunsigned char *outbuf = (unsigned char*)malloc((len/4)*3+3);\n\tconst char *ptr = buf;\n\tint p = 0;\n\tint wv, w1, w2, w3, w4;\n\tint tmpval[4];\n\tint tmpcnt = 0;\n\n\tdo {\n\t\twhile (ptr < buf+len && (*ptr == ' ' || *ptr == '\\t' || *ptr == '\\n' || *ptr == '\\r')) {\n\t\t\tptr++;\n\t\t}\n\t\tif (*ptr == '\\0' || ptr >= buf+len) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((wv = base64_table[(int)(unsigned char)*ptr++]) == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\ttmpval[tmpcnt++] = wv;\n\t\tif (tmpcnt == 4) {\n\t\t\ttmpcnt = 0;\n\t\t\tw1 = tmpval[0];\n\t\t\tw2 = tmpval[1];\n\t\t\tw3 = tmpval[2];\n\t\t\tw4 = tmpval[3];\n\n\t\t\tif (w2 >= 0) {\n\t\t\t\toutbuf[p++] = (unsigned char)(((w1 << 2) + (w2 >> 4)) & 0xFF);\n\t\t\t}\n\t\t\tif (w3 >= 0) {\n\t\t\t\toutbuf[p++] = (unsigned char)(((w2 << 4) + (w3 >> 2)) & 0xFF);\n\t\t\t}\n\t\t\tif (w4 >= 0) {\n\t\t\t\toutbuf[p++] = (unsigned char)(((w3 << 6) + w4) & 0xFF);\n\t\t\t}\n\t\t}\n\t} while (1);\n\n\toutbuf[p] = 0;\n\t*size = p;\n\treturn outbuf;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t */\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\t/* Fallback to buffered I/O if we do not support append dio. */\n\tif (iocb->ki_pos + iter->count > i_size_read(inode) &&\n\t    !ocfs2_supports_append_dio(osb))\n\t\treturn 0;\n\n\tif (iov_iter_rw(iter) == READ)\n\t\tget_block = ocfs2_get_block;\n\telse\n\t\tget_block = ocfs2_dio_get_block;\n\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t    iter, get_block,\n\t\t\t\t    ocfs2_dio_end_io, NULL, 0);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t */\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\t/* Fallback to buffered I/O if we do not support append dio. */\n\tif (iocb->ki_pos + iter->count > i_size_read(inode) &&\n\t    !ocfs2_supports_append_dio(osb))\n\t\treturn 0;\n\n\tif (iov_iter_rw(iter) == READ)\n\t\tget_block = ocfs2_lock_get_block;\n\telse\n\t\tget_block = ocfs2_dio_wr_get_block;\n\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t    iter, get_block,\n\t\t\t\t    ocfs2_dio_end_io, NULL, 0);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void __net_random_once_deferred(struct work_struct *w)\n{\n\tstruct __net_random_once_work *work =\n\t\tcontainer_of(w, struct __net_random_once_work, work);\n\tif (!static_key_enabled(work->key))\n\t\tstatic_key_slow_inc(work->key);\n\tkfree(work);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void __net_random_once_deferred(struct work_struct *w)\n{\n\tstruct __net_random_once_work *work =\n\t\tcontainer_of(w, struct __net_random_once_work, work);\n\tBUG_ON(!static_key_enabled(work->key));\n\tstatic_key_slow_dec(work->key);\n\tkfree(work);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tstruct rt6_info *rt)\n\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\t/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t */\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\n\t\t/* reserve space for Hardware header */\n\t\tskb_reserve(skb, hh_len);\n\n\t\t/* create space for UDP/IP header */\n\n\t\t/* initialize network header pointer */\n\t\tskb_reset_network_header(skb);\n\n\t\t/* initialize protocol header pointer */\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\t}\n\n\terr = skb_append_datato_frags(sk,skb, getfrag, from,\n\t\t\t\t      (length - transhdrlen));\n\tif (!err) {\n\t\tstruct frag_hdr fhdr;\n\n\t\t/* Specify the length of each IPv6 datagram fragment.\n\t\t * It has to be a multiple of 8.\n\t\t */\n\t\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\tipv6_select_ident(&fhdr, rt);\n\t\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\n\t\treturn 0;\n\t}\n\t/* There is not enough support do UPD LSO,\n\t * so follow normal path\n\t */\n\tkfree_skb(skb);\n\n\treturn err;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\t/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t */\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tstruct frag_hdr fhdr;\n\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\n\t\t/* reserve space for Hardware header */\n\t\tskb_reserve(skb, hh_len);\n\n\t\t/* create space for UDP/IP header */\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\n\t\t/* initialize network header pointer */\n\t\tskb_reset_network_header(skb);\n\n\t\t/* initialize protocol header pointer */\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\n\t\t/* Specify the length of each IPv6 datagram fragment.\n\t\t * It has to be a multiple of 8.\n\t\t */\n\t\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\tipv6_select_ident(&fhdr, rt);\n\t\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t}\n\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to non-matching domain url '%s'\",\n\t\t\t\tpool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tport = (char *)json_string_value(json_array_get(val, 1));\n\tif (!port)\n\t\tport = pool->stratum_port;\n\n\tsprintf(address, \"%s:%s\", url, port);\n\n\tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n\t\treturn false;\n\n\tapplog(LOG_WARNING, \"Stratum reconnect requested from pool %d to %s\", pool->pool_no, address);\n\n\tclear_pool_work(pool);\n\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to non-matching domain url '%s'\",\n\t\t\t\tpool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tport = (char *)json_string_value(json_array_get(val, 1));\n\tif (!port)\n\t\tport = pool->stratum_port;\n\n\tsnprintf(address, 254, \"%s:%s\", url, port);\n\n\tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n\t\treturn false;\n\n\tapplog(LOG_WARNING, \"Stratum reconnect requested from pool %d to %s\", pool->pool_no, address);\n\n\tclear_pool_work(pool);\n\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "Status GetMatchingPaths(FileSystem* fs, Env* env, const string& pattern,\n                        std::vector<string>* results) {\n  results->clear();\n  if (pattern.empty()) {\n    return Status::OK();\n  }\n\n  string fixed_prefix = pattern.substr(0, pattern.find_first_of(\"*?[\\\\\"));\n  string eval_pattern = pattern;\n  string dir(io::Dirname(fixed_prefix));\n  // If dir is empty then we need to fix up fixed_prefix and eval_pattern to\n  // include . as the top level directory.\n  if (dir.empty()) {\n    dir = \".\";\n    fixed_prefix = io::JoinPath(dir, fixed_prefix);\n    eval_pattern = io::JoinPath(dir, eval_pattern);\n  }\n  bool is_directory = pattern[pattern.size() - 1] == '/';\n#ifdef PLATFORM_WINDOWS\n  is_directory = is_directory || pattern[pattern.size() - 1] == '\\\\';\n#endif\n  std::vector<string> dirs;\n  if (!is_directory) {\n    dirs.emplace_back(eval_pattern);\n  }\n  StringPiece tmp_dir(io::Dirname(eval_pattern));\n  while (tmp_dir.size() > dir.size()) {\n    dirs.emplace_back(string(tmp_dir));\n    tmp_dir = io::Dirname(tmp_dir);\n  }\n  dirs.emplace_back(dir);\n  std::reverse(dirs.begin(), dirs.end());\n  // Setup a parallel BFS to explore everything under dir.\n  std::deque<std::pair<string, int>> dir_q;\n  std::deque<std::pair<string, int>> next_dir_q;\n  dir_q.emplace_back(std::make_pair(dirs[0], 0));\n  Status ret;  // Status to return.\n  mutex results_mutex;\n  condition_variable results_cond;\n  mutex next_que_mutex;\n  condition_variable next_que_cond;\n  while (!dir_q.empty()) {\n    next_dir_q.clear();\n    std::vector<Status> new_rets(dir_q.size());\n    auto handle_level = [fs, &results, &dir_q, &next_dir_q, &new_rets,\n                         &is_directory, &dirs, &results_mutex, &results_cond,\n                         &next_que_mutex, &next_que_cond](int i) {\n      string current_dir = dir_q.at(i).first;\n      int dir_index = dir_q.at(i).second;\n      dir_index++;\n      std::vector<string> children;\n      Status s = fs->GetChildren(current_dir, &children);\n      // In case PERMISSION_DENIED is encountered, we bail here.\n      if (s.code() == tensorflow::error::PERMISSION_DENIED) {\n        return;\n      }\n      new_rets[i] = s;\n      if (children.empty()) return;\n\n      // children_dir_status holds is_dir status for children. It can have three\n      // possible values: OK for true; FAILED_PRECONDITION for false; CANCELLED\n      // if we don't calculate IsDirectory (we might do that because there isn't\n      // any point in exploring that child path).\n      std::vector<Status> children_dir_status;\n\n      // This IsDirectory call can be expensive for some FS. Parallelizing it.\n      children_dir_status.resize(children.size());\n      auto handle_children = [fs, &current_dir, &children, &dirs, dir_index,\n                              is_directory, &children_dir_status](int j) {\n        const string child_path = io::JoinPath(current_dir, children[j]);\n        if (!fs->Match(child_path, dirs[dir_index])) {\n          children_dir_status[j] =\n              Status(tensorflow::error::CANCELLED, \"Operation not needed\");\n        } else if (dir_index != dirs.size() - 1) {\n          children_dir_status[j] = fs->IsDirectory(child_path);\n        } else {\n          children_dir_status[j] =\n              is_directory ? fs->IsDirectory(child_path) : Status::OK();\n        }\n      };\n      ForEach(0, children.size(), handle_children);\n\n      for (size_t j = 0; j < children.size(); ++j) {\n        const string child_path = io::JoinPath(current_dir, children[j]);\n        // If the IsDirectory call was cancelled we bail.\n        if (children_dir_status[j].code() == tensorflow::error::CANCELLED) {\n          continue;\n        }\n        if (children_dir_status[j].ok()) {\n          if (dir_index != dirs.size() - 1) {\n            mutex_lock lk(next_que_mutex);\n            next_dir_q.emplace_back(std::make_pair(child_path, dir_index));\n            next_que_cond.notify_one();\n          } else {\n            mutex_lock lk(results_mutex);\n            results->emplace_back(child_path);\n            results_cond.notify_one();\n          }\n        }\n      }\n    };\n    ForEach(0, dir_q.size(), handle_level);\n\n    ret.Update(new_rets[dir_q.size() - 1]);\n    std::swap(dir_q, next_dir_q);\n  }\n  return ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "Status GetMatchingPaths(FileSystem* fs, Env* env, const string& pattern,\n                        std::vector<string>* results) {\n  // Check that `fs`, `env` and `results` are non-null.\n  if (fs == nullptr || env == nullptr || results == nullptr) {\n    return Status(tensorflow::error::INVALID_ARGUMENT,\n                  \"Filesystem calls GetMatchingPaths with nullptr arguments\");\n  }\n\n  // By design, we don't match anything on empty pattern\n  results->clear();\n  if (pattern.empty()) {\n    return Status::OK();\n  }\n\n  // The pattern can contain globbing characters at multiple levels, e.g.:\n  //\n  //   foo/ba?/baz/f*r\n  //\n  // To match the full pattern, we must match every prefix subpattern and then\n  // operate on the children for each match. Thus, we separate all subpatterns\n  // in the `dirs` vector below.\n  std::vector<std::string> dirs = AllDirectoryPrefixes(pattern);\n\n  // We can have patterns that have several parents where no globbing is being\n  // done, for example, `foo/bar/baz/*`. We don't need to expand the directories\n  // which don't contain the globbing characters.\n  int matching_index = GetFirstGlobbingEntry(dirs);\n\n  // If we don't have globbing characters in the pattern then it specifies a\n  // path in the filesystem. We add it to the result set if it exists.\n  if (matching_index == dirs.size()) {\n    if (fs->FileExists(pattern).ok()) {\n      results->emplace_back(pattern);\n    }\n    return Status::OK();\n  }\n\n  // To expand the globbing, we do a BFS from `dirs[matching_index-1]`.\n  // At every step, we work on a pair `{dir, ix}` such that `dir` is a real\n  // directory, `ix < dirs.size() - 1` and `dirs[ix+1]` is a globbing pattern.\n  // To expand the pattern, we select from all the children of `dir` only those\n  // that match against `dirs[ix+1]`.\n  // If there are more entries in `dirs` after `dirs[ix+1]` this mean we have\n  // more patterns to match. So, we add to the queue only those children that\n  // are also directories, paired with `ix+1`.\n  // If there are no more entries in `dirs`, we return all children as part of\n  // the answer.\n  // Since we can get into a combinatorial explosion issue (e.g., pattern\n  // `/*/*/*`), we process the queue in parallel. Each parallel processing takes\n  // elements from `expand_queue` and adds them to `next_expand_queue`, after\n  // which we swap these two queues (similar to double buffering algorithms).\n  // PRECONDITION: `IsGlobbingPattern(dirs[0]) == false`\n  // PRECONDITION: `matching_index > 0`\n  // INVARIANT: If `{d, ix}` is in queue, then `d` and `dirs[ix]` are at the\n  //            same level in the filesystem tree.\n  // INVARIANT: If `{d, _}` is in queue, then `IsGlobbingPattern(d) == false`.\n  // INVARIANT: If `{d, _}` is in queue, then `d` is a real directory.\n  // INVARIANT: If `{_, ix}` is in queue, then `ix < dirs.size() - 1`.\n  // INVARIANT: If `{_, ix}` is in queue, `IsGlobbingPattern(dirs[ix + 1])`.\n  std::deque<std::pair<string, int>> expand_queue;\n  std::deque<std::pair<string, int>> next_expand_queue;\n  expand_queue.emplace_back(dirs[matching_index - 1], matching_index - 1);\n\n  // Adding to `result` or `new_expand_queue` need to be protected by mutexes\n  // since there are multiple threads writing to these.\n  mutex result_mutex;\n  mutex queue_mutex;\n\n  while (!expand_queue.empty()) {\n    next_expand_queue.clear();\n\n    // The work item for every item in `expand_queue`.\n    // pattern, we process them in parallel.\n    auto handle_level = [&fs, &results, &dirs, &expand_queue,\n                         &next_expand_queue, &result_mutex,\n                         &queue_mutex](int i) {\n      // See invariants above, all of these are valid accesses.\n      const auto& queue_item = expand_queue.at(i);\n      const std::string& parent = queue_item.first;\n      const int index = queue_item.second + 1;\n      const std::string& match_pattern = dirs[index];\n\n      // Get all children of `parent`. If this fails, return early.\n      std::vector<std::string> children;\n      Status s = fs->GetChildren(parent, &children);\n      if (s.code() == tensorflow::error::PERMISSION_DENIED) {\n        return;\n      }\n\n      // Also return early if we don't have any children\n      if (children.empty()) {\n        return;\n      }\n\n      // Since we can get extremely many children here and on some filesystems\n      // `IsDirectory` is expensive, we process the children in parallel.\n      // We also check that children match the pattern in parallel, for speedup.\n      // We store the status of the match and `IsDirectory` in\n      // `children_status` array, one element for each children.\n      std::vector<Status> children_status(children.size());\n      auto handle_children = [&fs, &match_pattern, &parent, &children,\n                              &children_status](int j) {\n        const std::string path = io::JoinPath(parent, children[j]);\n        if (!fs->Match(path, match_pattern)) {\n          children_status[j] =\n              Status(tensorflow::error::CANCELLED, \"Operation not needed\");\n        } else {\n          children_status[j] = fs->IsDirectory(path);\n        }\n      };\n      ForEach(0, children.size(), handle_children);\n\n      // At this point, pairing `children` with `children_status` will tell us\n      // if a children:\n      //   * does not match the pattern\n      //   * matches the pattern and is a directory\n      //   * matches the pattern and is not a directory\n      // We fully ignore the first case.\n      // If we matched the last pattern (`index == dirs.size() - 1`) then all\n      // remaining children get added to the result.\n      // Otherwise, only the directories get added to the next queue.\n      for (size_t j = 0; j < children.size(); j++) {\n        if (children_status[j].code() == tensorflow::error::CANCELLED) {\n          continue;\n        }\n\n        const std::string path = io::JoinPath(parent, children[j]);\n        if (index == dirs.size() - 1) {\n          mutex_lock l(result_mutex);\n          results->emplace_back(path);\n        } else if (children_status[j].ok()) {\n          mutex_lock l(queue_mutex);\n          next_expand_queue.emplace_back(path, index);\n        }\n      }\n    };\n    ForEach(0, expand_queue.size(), handle_level);\n\n    // After evaluating one level, swap the \"buffers\"\n    std::swap(expand_queue, next_expand_queue);\n  }\n\n  return Status::OK();\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\treturn;\n\ttsk->sysvsem.undo_list = NULL;\n\n\tif (!atomic_dec_and_test(&ulp->refcnt))\n\t\treturn;\n\n\tfor (;;) {\n\t\tstruct sem_array *sma;\n\t\tstruct sem_undo *un;\n\t\tstruct list_head tasks;\n\t\tint semid;\n\t\tint i;\n\n\t\trcu_read_lock();\n\t\tun = list_entry_rcu(ulp->list_proc.next,\n\t\t\t\t    struct sem_undo, list_proc);\n\t\tif (&un->list_proc == &ulp->list_proc)\n\t\t\tsemid = -1;\n\t\t else\n\t\t\tsemid = un->semid;\n\t\trcu_read_unlock();\n\n\t\tif (semid == -1)\n\t\t\tbreak;\n\n\t\tsma = sem_lock_check(tsk->nsproxy->ipc_ns, un->semid);\n\n\t\t/* exit_sem raced with IPC_RMID, nothing to do */\n\t\tif (IS_ERR(sma))\n\t\t\tcontinue;\n\n\t\tun = __lookup_undo(ulp, semid);\n\t\tif (un == NULL) {\n\t\t\t/* exit_sem raced with IPC_RMID+semget() that created\n\t\t\t * exactly the same semid. Nothing to do.\n\t\t\t */\n\t\t\tsem_unlock(sma);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* remove un from the linked lists */\n\t\tassert_spin_locked(&sma->sem_perm.lock);\n\t\tlist_del(&un->list_id);\n\n\t\tspin_lock(&ulp->lock);\n\t\tlist_del_rcu(&un->list_proc);\n\t\tspin_unlock(&ulp->lock);\n\t\t\t\tif (semaphore->semval < 0)\n\t\t\t\t\tsemaphore->semval = 0;\n\t\t\t\tif (semaphore->semval > SEMVMX)\n\t\t\t\t\tsemaphore->semval = SEMVMX;\n\t\t\t\tsemaphore->sempid = task_tgid_vnr(current);\n\t\t\t}\n\t\t}\n\t\t/* maybe some queued-up processes were waiting for this */\n\t\tINIT_LIST_HEAD(&tasks);\n\t\tdo_smart_update(sma, NULL, 0, 1, &tasks);\n\t\tsem_unlock(sma);\n\t\twake_up_sem_queue_do(&tasks);\n\n\t\tkfree_rcu(un, rcu);\n\t}\n\tkfree(ulp);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\treturn;\n\ttsk->sysvsem.undo_list = NULL;\n\n\tif (!atomic_dec_and_test(&ulp->refcnt))\n\t\treturn;\n\n\tfor (;;) {\n\t\tstruct sem_array *sma;\n\t\tstruct sem_undo *un;\n\t\tstruct list_head tasks;\n\t\tint semid, i;\n\n\t\trcu_read_lock();\n\t\tun = list_entry_rcu(ulp->list_proc.next,\n\t\t\t\t    struct sem_undo, list_proc);\n\t\tif (&un->list_proc == &ulp->list_proc)\n\t\t\tsemid = -1;\n\t\t else\n\t\t\tsemid = un->semid;\n\n\t\tif (semid == -1) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\n\t\tsma = sem_obtain_object_check(tsk->nsproxy->ipc_ns, un->semid);\n\t\t/* exit_sem raced with IPC_RMID, nothing to do */\n\t\tif (IS_ERR(sma)) {\n\t\t\trcu_read_unlock();\n\t\t\tcontinue;\n\t\t}\n\n\t\tsem_lock(sma, NULL, -1);\n\t\tun = __lookup_undo(ulp, semid);\n\t\tif (un == NULL) {\n\t\t\t/* exit_sem raced with IPC_RMID+semget() that created\n\t\t\t * exactly the same semid. Nothing to do.\n\t\t\t */\n\t\t\tsem_unlock(sma, -1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* remove un from the linked lists */\n\t\tassert_spin_locked(&sma->sem_perm.lock);\n\t\tlist_del(&un->list_id);\n\n\t\tspin_lock(&ulp->lock);\n\t\tlist_del_rcu(&un->list_proc);\n\t\tspin_unlock(&ulp->lock);\n\t\t\t\tif (semaphore->semval < 0)\n\t\t\t\t\tsemaphore->semval = 0;\n\t\t\t\tif (semaphore->semval > SEMVMX)\n\t\t\t\t\tsemaphore->semval = SEMVMX;\n\t\t\t\tsemaphore->sempid = task_tgid_vnr(current);\n\t\t\t}\n\t\t}\n\t\t/* maybe some queued-up processes were waiting for this */\n\t\tINIT_LIST_HEAD(&tasks);\n\t\tdo_smart_update(sma, NULL, 0, 1, &tasks);\n\t\tsem_unlock(sma, -1);\n\t\twake_up_sem_queue_do(&tasks);\n\n\t\tkfree_rcu(un, rcu);\n\t}\n\tkfree(ulp);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\n/* Eliminate warning about unused variable. */\nbox = 0;\nout = 0;\n\treturn -1;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\n\t/* Eliminate warning about unused variable. */\n\tbox = 0;\n\tout = 0;\n\treturn -1;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n\tstruct nlattr *tb[NFTA_EXPR_MAX + 1];\n\tconst struct nft_expr_type *type;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,\n\t\t\t\t\t  nft_expr_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_EXPR_DATA])\n\t\treturn -EINVAL;\n\n\ttype = __nft_expr_type_get(ctx->family, tb[NFTA_EXPR_NAME]);\n\tif (!type)\n\t\treturn -ENOENT;\n\n\tif (!type->inner_ops)\n\t\treturn -EOPNOTSUPP;\n\n\terr = nla_parse_nested_deprecated(info->tb, type->maxattr,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n\tstruct nlattr *tb[NFTA_EXPR_MAX + 1];\n\tconst struct nft_expr_type *type;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,\n\t\t\t\t\t  nft_expr_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_EXPR_DATA] || !tb[NFTA_EXPR_NAME])\n\t\treturn -EINVAL;\n\n\ttype = __nft_expr_type_get(ctx->family, tb[NFTA_EXPR_NAME]);\n\tif (!type)\n\t\treturn -ENOENT;\n\n\tif (!type->inner_ops)\n\t\treturn -EOPNOTSUPP;\n\n\terr = nla_parse_nested_deprecated(info->tb, type->maxattr,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void mt_init(mtrand *mt, uint32_t seed) {\n  int i;\n  mt->mt_buffer_[0] = seed;\n  mt->mt_index_ = MT_LEN;\n  for (i = 1; i < MT_LEN; i++) {\n    /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n    /* In the previous versions, MSBs of the seed affect   */\n    /* only MSBs of the array mt[].                        */\n    /* 2002/01/09 modified by Makoto Matsumoto             */\n    mt->mt_buffer_[i] =\n\t(1812433253UL * (mt->mt_buffer_[i-1] ^ \n\t\t\t (mt->mt_buffer_[i-1] >> 30)) + i);\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void mt_init(mtrand *mt, uint32_t seed) {\n  int i;\n  mt->mt_buffer_[0] = seed;\n  mt->mt_index_ = MT_LEN;\n  for (i = 1; i < MT_LEN; i++) {\n    /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n    /* In the previous versions, MSBs of the seed affect   */\n    /* only MSBs of the array mt[].                        */\n    /* 2002/01/09 modified by Makoto Matsumoto             */\n    mt->mt_buffer_[i] =\n\t(1812433253UL * (mt->mt_buffer_[i-1] ^\n\t\t\t (mt->mt_buffer_[i-1] >> 30)) + i);\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void exif_process_APP12(image_info_type *ImageInfo,\n                               char *buffer, size_t length) {\n  size_t l1, l2=0;\n  if ((l1 = php_strnlen(buffer+2, length-2)) > 0) {\n    exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Company\",\n                     TAG_NONE, TAG_FMT_STRING, l1, buffer+2);\n    if (length > 2+l1+1) {\n      l2 = php_strnlen(buffer+2+l1+1, length-2-l1+1);\n      exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Info\",\n                       TAG_NONE, TAG_FMT_STRING, l2, buffer+2+l1+1);\n    }\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void exif_process_APP12(image_info_type *ImageInfo,\n                               char *buffer, size_t length) {\n  size_t l1, l2=0;\n  if ((l1 = php_strnlen(buffer+2, length-2)) > 0) {\n    exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Company\",\n                     TAG_NONE, TAG_FMT_STRING, l1, buffer+2);\n    if (length > 2+l1+1) {\n      l2 = php_strnlen(buffer+2+l1+1, length-2-l1-1);\n      exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Info\",\n                       TAG_NONE, TAG_FMT_STRING, l2, buffer+2+l1+1);\n    }\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)\n\t/*\n\t * write op is only supported for ipc_flood_count or\n\t * ipc_flood_duration_ms debugfs entries atm.\n\t * ipc_flood_count floods the DSP with the number of IPC's specified.\n\t * ipc_duration_ms test floods the DSP for the time specified\n\t * in the debugfs entry.\n\t */\n\tdentry = file->f_path.dentry;\n\tif (strcmp(dentry->d_name.name, \"ipc_flood_count\") &&\n\t    strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\"))\n\t\treturn -EINVAL;\n\n\tif (!strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\"))\n\t\tflood_duration_test = true;\n\n\t/* test completion criterion */\n\tif (flood_duration_test)\n\t\tret = kstrtoul(string, 0, &ipc_duration_ms);\n\telse\n\t\tret = kstrtoul(string, 0, &ipc_count);\n\tif (ret < 0)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)\n\t/*\n\t * write op is only supported for ipc_flood_count or\n\t * ipc_flood_duration_ms debugfs entries atm.\n\t * ipc_flood_count floods the DSP with the number of IPC's specified.\n\t * ipc_duration_ms test floods the DSP for the time specified\n\t * in the debugfs entry.\n\t */\n\tdentry = file->f_path.dentry;\n\tif (strcmp(dentry->d_name.name, \"ipc_flood_count\") &&\n\t    strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\")) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\"))\n\t\tflood_duration_test = true;\n\n\t/* test completion criterion */\n\tif (flood_duration_test)\n\t\tret = kstrtoul(string, 0, &ipc_duration_ms);\n\telse\n\t\tret = kstrtoul(string, 0, &ipc_count);\n\tif (ret < 0)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TEST_CASE_METHOD(TestFixture, \"ECDSA AES keygen and signature test\", \"[ecdsa-aes-key-sig-gen]\") {\n    vector<char> errMsg(BUF_LEN, 0);\n    int errStatus = 0;\n    vector <uint8_t> encrPrivKey(BUF_LEN, 0);\n    vector<char> pubKeyX(BUF_LEN, 0);\n    vector<char> pubKeyY(BUF_LEN, 0);\n\n    uint32_t encLen = 0;\n    PRINT_SRC_LINE\n    auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), &encLen,\n                                             pubKeyX.data(),\n                                             pubKeyY.data());\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    string hex = SAMPLE_HEX_HASH;\n    vector<char> signatureR(BUF_LEN, 0);\n    vector<char> signatureS(BUF_LEN, 0);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TEST_CASE_METHOD(TestFixture, \"ECDSA AES keygen and signature test\", \"[ecdsa-aes-key-sig-gen]\") {\n    vector<char> errMsg(BUF_LEN, 0);\n    int errStatus = 0;\n    vector <uint8_t> encrPrivKey(BUF_LEN, 0);\n    vector<char> pubKeyX(BUF_LEN, 0);\n    vector<char> pubKeyY(BUF_LEN, 0);\n\n    uint64_t encLen = 0;\n    PRINT_SRC_LINE\n    auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), &encLen,\n                                             pubKeyX.data(),\n                                             pubKeyY.data());\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    string hex = SAMPLE_HEX_HASH;\n    vector<char> signatureR(BUF_LEN, 0);\n    vector<char> signatureS(BUF_LEN, 0);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n\n\tif (timeout == NULL)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n\n\tif (get_compat_timespec(&ktspec, timeout))\n\t\treturn -EFAULT;\n\n\tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n\t\tdatagrams = -EFAULT;\n\n\treturn datagrams;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\n\tif (timeout == NULL)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n\n\tif (compat_get_timespec(&ktspec, timeout))\n\t\treturn -EFAULT;\n\n\tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && compat_put_timespec(&ktspec, timeout))\n\t\tdatagrams = -EFAULT;\n\n\treturn datagrams;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int jas_iccgetuint32(jas_stream_t *in, jas_iccuint32_t *val)\n{\n\tulonglong tmp;\n\tif (jas_iccgetuint(in, 4, &tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int jas_iccgetuint32(jas_stream_t *in, jas_iccuint32_t *val)\n{\n\tjas_ulonglong tmp;\n\tif (jas_iccgetuint(in, 4, &tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  int ret;\n\n  test_setup ();\n\n  if ((ret = test_make_inputs (stream, has_source ? & ssize : NULL, & tsize)))\n    {\n      return ret;\n    }\n\n  /* First encode */\n  snprintf_func (ecmd, TESTBUFSIZE, \"%s %s -f %s %s %s %s %s %s %s\", \n\t    program_name, test_softcfg_str,\n\t    has_adler32 ? \"\" : \"-n \",\n\t    has_apphead ? \"-A=encode_apphead \" : \"-A= \",\n\t    has_secondary ? \"-S djw \" : \"-S none \",\n\t    has_source ? \"-s \" : \"\",\n\t    has_source ? TEST_SOURCE_FILE : \"\",\n\t    TEST_TARGET_FILE,\n\t    TEST_DELTA_FILE);\n\n  if ((ret = system (ecmd)) != 0)\n    {\n      XPR(NT \"encode command: %s\\n\", ecmd);\n      stream->msg = \"encode cmd failed\";\n      return XD3_INTERNAL;\n    }\n\n  /* Now recode */\n  snprintf_func (recmd, TESTBUFSIZE,\n\t    \"%s recode %s -f %s %s %s %s %s\", program_name, test_softcfg_str,\n\t    recoded_adler32 ? \"\" : \"-n \",\n\t    !change_apphead ? \"\" : \n\t        (recoded_apphead ? \"-A=recode_apphead \" : \"-A= \"),\n\t    recoded_secondary ? \"-S djw \" : \"-S none \",\n\t    TEST_DELTA_FILE,\n\t    TEST_COPY_FILE);\n\n  if ((ret = system (recmd)) != 0)\n    {\n      XPR(NT \"recode command: %s\\n\", recmd);\n      stream->msg = \"recode cmd failed\";\n      return XD3_INTERNAL;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  int ret;\n\n  test_setup ();\n\n  if ((ret = test_make_inputs (stream, has_source ? & ssize : NULL, & tsize)))\n    {\n      return ret;\n    }\n\n  /* First encode */\n  snprintf_func (ecmd, TESTBUFSIZE, \"%s %s -f %s %s %s %s %s %s %s\",\n\t    program_name, test_softcfg_str,\n\t    has_adler32 ? \"\" : \"-n \",\n\t    has_apphead ? \"-A=encode_apphead \" : \"-A= \",\n\t    has_secondary ? \"-S djw \" : \"-S none \",\n\t    has_source ? \"-s \" : \"\",\n\t    has_source ? TEST_SOURCE_FILE : \"\",\n\t    TEST_TARGET_FILE,\n\t    TEST_DELTA_FILE);\n\n  if ((ret = system (ecmd)) != 0)\n    {\n      XPR(NT \"encode command: %s\\n\", ecmd);\n      stream->msg = \"encode cmd failed\";\n      return XD3_INTERNAL;\n    }\n\n  /* Now recode */\n  snprintf_func (recmd, TESTBUFSIZE,\n\t    \"%s recode %s -f %s %s %s %s %s\", program_name, test_softcfg_str,\n\t    recoded_adler32 ? \"\" : \"-n \",\n\t    !change_apphead ? \"\" :\n\t        (recoded_apphead ? \"-A=recode_apphead \" : \"-A= \"),\n\t    recoded_secondary ? \"-S djw \" : \"-S none \",\n\t    TEST_DELTA_FILE,\n\t    TEST_COPY_FILE);\n\n  if ((ret = system (recmd)) != 0)\n    {\n      XPR(NT \"recode command: %s\\n\", recmd);\n      stream->msg = \"recode cmd failed\";\n      return XD3_INTERNAL;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tmd->page_order = req_schp->page_order;\n\t\tmd->nr_entries = req_schp->k_use_sg;\n\t\tmd->offset = 0;\n\t\tmd->null_mapped = hp->dxferp ? 0 : 1;\n\t\tif (dxfer_dir == SG_DXFER_TO_FROM_DEV)\n\t\t\tmd->from_user = 1;\n\t\telse\n\t\t\tmd->from_user = 0;\n\t}\n\n\tif (unlikely(iov_count > MAX_UIOVEC))\n\t\treturn -EINVAL;\n\n\tif (iov_count) {\n\t\tint size = sizeof(struct iovec) * iov_count;\n\t\tstruct iovec *iov;\n\t\tstruct iov_iter i;\n\n\t\tiov = memdup_user(hp->dxferp, size);\n\t\tif (IS_ERR(iov))\n\t\t\treturn PTR_ERR(iov);\n\n\t\tiov_iter_init(&i, rw, iov, iov_count,\n\t\t\t      min_t(size_t, hp->dxfer_len,\n\t\t\t\t    iov_length(iov, iov_count)));\n\n\t\tres = blk_rq_map_user_iov(q, rq, md, &i, GFP_ATOMIC);\n\t\tkfree(iov);\n\t} else\n\t\tres = blk_rq_map_user(q, rq, md, hp->dxferp,\n\t\t\t\t      hp->dxfer_len, GFP_ATOMIC);\n\n\tif (!res) {\n\t\tsrp->bio = rq->bio;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tmd->pages = req_schp->pages;\n\t\tmd->page_order = req_schp->page_order;\n\t\tmd->nr_entries = req_schp->k_use_sg;\n\t\tmd->offset = 0;\n\t\tmd->null_mapped = hp->dxferp ? 0 : 1;\n\t\tif (dxfer_dir == SG_DXFER_TO_FROM_DEV)\n\t\t\tmd->from_user = 1;\n\t\telse\n\t\t\tmd->from_user = 0;\n\t}\n\n\tif (iov_count) {\n\t\tstruct iovec *iov = NULL;\n\t\tstruct iov_iter i;\n\n\t\tres = import_iovec(rw, hp->dxferp, iov_count, 0, &iov, &i);\n\t\tif (res < 0)\n\t\t\treturn res;\n\n\t\tiov_iter_truncate(&i, hp->dxfer_len);\n\n\t\tres = blk_rq_map_user_iov(q, rq, md, &i, GFP_ATOMIC);\n\t\tkfree(iov);\n\t} else\n\t\tres = blk_rq_map_user(q, rq, md, hp->dxferp,\n\t\t\t\t      hp->dxfer_len, GFP_ATOMIC);\n\n\tif (!res) {\n\t\tsrp->bio = rq->bio;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tconst struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\t__be16 orig_sport, orig_dport;\n\t__be32 daddr, nexthop;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\tint err;\n\n\tdp->dccps_role = DCCP_ROLE_CLIENT;\n\n\tif (addr_len < sizeof(struct sockaddr_in))\n\t\treturn -EINVAL;\n\n\tif (usin->sin_family != AF_INET)\n\t\treturn -EAFNOSUPPORT;\n\n\tnexthop = daddr = usin->sin_addr.s_addr;\n\tif (inet->opt != NULL && inet->opt->srr) {\n\t\tif (daddr == 0)\n\t\t\treturn -EINVAL;\n\t\tnexthop = inet->opt->faddr;\n\t}\n\n\torig_sport = inet->inet_sport;\n\torig_dport = usin->sin_port;\n\trt = ip_route_connect(&fl4, nexthop, inet->inet_saddr,\n\t\t\t      RT_CONN_FLAGS(sk), sk->sk_bound_dev_if,\n\t\t\t      IPPROTO_DCCP,\n\t\t\t      orig_sport, orig_dport, sk, true);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\tif (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {\n\t\tip_rt_put(rt);\n\t\treturn -ENETUNREACH;\n\t}\n\n\tif (inet->opt == NULL || !inet->opt->srr)\n\t\tdaddr = rt->rt_dst;\n\n\tif (inet->inet_saddr == 0)\n\t\tinet->inet_saddr = rt->rt_src;\n\tinet->inet_rcv_saddr = inet->inet_saddr;\n\n\tinet->inet_dport = usin->sin_port;\n\tinet->inet_daddr = daddr;\n\n\tinet_csk(sk)->icsk_ext_hdr_len = 0;\n\tif (inet->opt != NULL)\n\t\tinet_csk(sk)->icsk_ext_hdr_len = inet->opt->optlen;\n\t/*\n\t * Socket identity is still unknown (sport may be zero).\n\t * However we set state to DCCP_REQUESTING and not releasing socket\n\t * lock select source port, enter ourselves into the hash tables and\n\t * complete initialization after this.\n\t */\n\tdccp_set_state(sk, DCCP_REQUESTING);\n\terr = inet_hash_connect(&dccp_death_row, sk);\n\tif (err != 0)\n\t\tgoto failure;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tconst struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\t__be16 orig_sport, orig_dport;\n\t__be32 daddr, nexthop;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\tint err;\n\tstruct ip_options_rcu *inet_opt;\n\n\tdp->dccps_role = DCCP_ROLE_CLIENT;\n\n\tif (addr_len < sizeof(struct sockaddr_in))\n\t\treturn -EINVAL;\n\n\tif (usin->sin_family != AF_INET)\n\t\treturn -EAFNOSUPPORT;\n\n\tnexthop = daddr = usin->sin_addr.s_addr;\n\n\tinet_opt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t     sock_owned_by_user(sk));\n\tif (inet_opt != NULL && inet_opt->opt.srr) {\n\t\tif (daddr == 0)\n\t\t\treturn -EINVAL;\n\t\tnexthop = inet_opt->opt.faddr;\n\t}\n\n\torig_sport = inet->inet_sport;\n\torig_dport = usin->sin_port;\n\trt = ip_route_connect(&fl4, nexthop, inet->inet_saddr,\n\t\t\t      RT_CONN_FLAGS(sk), sk->sk_bound_dev_if,\n\t\t\t      IPPROTO_DCCP,\n\t\t\t      orig_sport, orig_dport, sk, true);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\tif (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {\n\t\tip_rt_put(rt);\n\t\treturn -ENETUNREACH;\n\t}\n\n\tif (inet_opt == NULL || !inet_opt->opt.srr)\n\t\tdaddr = rt->rt_dst;\n\n\tif (inet->inet_saddr == 0)\n\t\tinet->inet_saddr = rt->rt_src;\n\tinet->inet_rcv_saddr = inet->inet_saddr;\n\n\tinet->inet_dport = usin->sin_port;\n\tinet->inet_daddr = daddr;\n\n\tinet_csk(sk)->icsk_ext_hdr_len = 0;\n\tif (inet_opt)\n\t\tinet_csk(sk)->icsk_ext_hdr_len = inet_opt->opt.optlen;\n\t/*\n\t * Socket identity is still unknown (sport may be zero).\n\t * However we set state to DCCP_REQUESTING and not releasing socket\n\t * lock select source port, enter ourselves into the hash tables and\n\t * complete initialization after this.\n\t */\n\tdccp_set_state(sk, DCCP_REQUESTING);\n\terr = inet_hash_connect(&dccp_death_row, sk);\n\tif (err != 0)\n\t\tgoto failure;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void trustedEncryptKeyAES(int *errStatus, char *errString, const char *key,\n                          uint8_t *encryptedPrivateKey, uint32_t *enc_len) {\n    LOG_INFO(__FUNCTION__);\n\n    *errString = 0;\n    *errStatus = UNKNOWN_ERROR;\n\n    CHECK_STATE(key);\n    CHECK_STATE(encryptedPrivateKey);\n\n    *errStatus = UNKNOWN_ERROR;\n\n    int status = AES_encrypt_DH((char *)key, encryptedPrivateKey, BUF_LEN);\n\n    CHECK_STATUS2(\"AES encrypt failed with status %d\");\n\n    *enc_len = strlen(key) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n    SAFE_CHAR_BUF(decryptedKey, BUF_LEN);\n\n    status = AES_decrypt_DH(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);\n\n    CHECK_STATUS2(\"trustedDecryptKey failed with status %d\");\n\n    uint64_t decryptedKeyLen = strnlen(decryptedKey, MAX_KEY_LENGTH);\n\n    if (decryptedKeyLen == MAX_KEY_LENGTH) {\n        snprintf(errString, BUF_LEN, \"Decrypted key is not null terminated\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    *errStatus = -8;\n\n    if (strncmp(key, decryptedKey, MAX_KEY_LENGTH) != 0) {\n        snprintf(errString, BUF_LEN, \"Decrypted key does not match original key\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    SET_SUCCESS\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void trustedEncryptKeyAES(int *errStatus, char *errString, const char *key,\n                          uint8_t *encryptedPrivateKey, uint64_t *enc_len) {\n    LOG_INFO(__FUNCTION__);\n\n    *errString = 0;\n    *errStatus = UNKNOWN_ERROR;\n\n    CHECK_STATE(key);\n    CHECK_STATE(encryptedPrivateKey);\n\n    *errStatus = UNKNOWN_ERROR;\n\n    int status = AES_encrypt((char *)key, encryptedPrivateKey, BUF_LEN,\n                             DKG, DECRYPTABLE, enc_len);\n\n    CHECK_STATUS2(\"AES encrypt failed with status %d\");\n\n    SAFE_CHAR_BUF(decryptedKey, BUF_LEN);\n\n    status = AES_decrypt(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);\n\n    CHECK_STATUS2(\"trustedDecryptKey failed with status %d\");\n\n    uint64_t decryptedKeyLen = strnlen(decryptedKey, MAX_KEY_LENGTH);\n\n    if (decryptedKeyLen == MAX_KEY_LENGTH) {\n        snprintf(errString, BUF_LEN, \"Decrypted key is not null terminated\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    *errStatus = -8;\n\n    if (strncmp(key, decryptedKey, MAX_KEY_LENGTH) != 0) {\n        snprintf(errString, BUF_LEN, \"Decrypted key does not match original key\");\n        LOG_ERROR(key);\n        LOG_ERROR(decryptedKey);\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    SET_SUCCESS\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "string sanitize_proprietary_tags(string input_string)\n{\n  unsigned int i;\n  size_t input_string_size;\n  bool strip = false;\n  bool tag_open = false;\n  int tag_open_idx = 0; //Are we within < > ?\n  bool closing_tag_open = false; //Are we within </ > ?\n  int orig_tag_open_idx = 0;\n  bool proprietary_tag = false; //Are we within a proprietary element?\n  bool proprietary_closing_tag = false;\n  int crop_end_idx = 0;\n  char buffer[READ_BUFFER_SIZE] = \"\";\n  char tagname[READ_BUFFER_SIZE] = \"\";\n  int tagname_idx = 0;\n  char close_tagname[READ_BUFFER_SIZE] = \"\";\n\n  for (i = 0; i < READ_BUFFER_SIZE; i++)\n  {\n    buffer[i] = 0;\n    tagname[i] = 0;\n    close_tagname[i] = 0;\n  }\n\n  input_string_size = input_string.size();\n\n  for (i = 0; i < input_string_size; i++)\n  {\n    if (input_string.c_str()[i] == '<')\n    {\n      tag_open = true;\n      tag_open_idx = i;\n      if (proprietary_tag == true && input_string.c_str()[i+1] == '/')\n      {\n        //We are now in a closing tag\n        closing_tag_open = true;\n        //cout<<\"Comparaison: \"<<tagname<<\"|\"<<&(input_string.c_str()[i+2])<<\"|\"<<strlen(tagname)<<endl;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "string sanitize_proprietary_tags(string input_string)\n{\n  unsigned int i;\n  bool strip = false;\n  bool tag_open = false;\n  int tag_open_idx = 0; //Are we within < > ?\n  bool closing_tag_open = false; //Are we within </ > ?\n  int orig_tag_open_idx = 0;\n  bool proprietary_tag = false; //Are we within a proprietary element?\n  bool proprietary_closing_tag = false;\n  int crop_end_idx = 0;\n  char buffer[READ_BUFFER_SIZE] = \"\";\n  char tagname[READ_BUFFER_SIZE] = \"\";\n  int tagname_idx = 0;\n  char close_tagname[READ_BUFFER_SIZE] = \"\";\n\n  for (i = 0; i < READ_BUFFER_SIZE; i++)\n  {\n    buffer[i] = 0;\n    tagname[i] = 0;\n    close_tagname[i] = 0;\n  }\n\n  size_t input_string_size = input_string.size();\n\n  // Minimum workaround to prevent buffer overflow: Stop iterating\n  // once the (fixed!) size of the output buffers is reached. In\n  // response to\n  // https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0317\n  //\n  // However, this code is a huge mess anyway and is in no way\n  // anything like up-to-date C++ code. Please, anyone, replace it\n  // with something more modern. Thanks. - cstim, 2017-09-17.\n  for (i = 0; i < std::min(input_string_size, size_t(READ_BUFFER_SIZE)); i++)\n  {\n    if (input_string.c_str()[i] == '<')\n    {\n      tag_open = true;\n      tag_open_idx = i;\n      if (proprietary_tag == true && input_string.c_str()[i+1] == '/')\n      {\n        //We are now in a closing tag\n        closing_tag_open = true;\n        //cout<<\"Comparaison: \"<<tagname<<\"|\"<<&(input_string.c_str()[i+2])<<\"|\"<<strlen(tagname)<<endl;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    }\n    /* XmlPrologTok has now set the encoding based on the BOM it found, and we\n       must move s and nextPtr forward to consume the BOM.\n\n       If we didn't, and got XML_TOK_NONE from the next XmlPrologTok call, we\n       would leave the BOM in the buffer and return. On the next call to this\n       function, our XmlPrologTok call would return XML_TOK_INVALID, since it\n       is not valid to have multiple BOMs.\n    */\n    else if (tok == XML_TOK_BOM) {\n#  ifdef XML_DTD\n      if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                    XML_ACCOUNT_DIRECT)) {\n        accountingOnAbort(parser);\n        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      }\n#  endif\n\n      *nextPtr = next;\n      s = next;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    }\n    /* XmlPrologTok has now set the encoding based on the BOM it found, and we\n       must move s and nextPtr forward to consume the BOM.\n\n       If we didn't, and got XML_TOK_NONE from the next XmlPrologTok call, we\n       would leave the BOM in the buffer and return. On the next call to this\n       function, our XmlPrologTok call would return XML_TOK_INVALID, since it\n       is not valid to have multiple BOMs.\n    */\n    else if (tok == XML_TOK_BOM) {\n#  if defined(XML_DTD) || XML_GE == 1\n      if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                    XML_ACCOUNT_DIRECT)) {\n        accountingOnAbort(parser);\n        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      }\n#  endif\n\n      *nextPtr = next;\n      s = next;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t/* Before first pass, make a rough estimation of addrs[]\n\t * each bpf instruction is translated to less than 64 bytes\n\t */\n\tfor (proglen = 0, i = 0; i < prog->len; i++) {\n\t\tproglen += 64;\n\t\taddrs[i] = proglen;\n\t}\n\tctx.cleanup_addr = proglen;\n\n\tfor (pass = 0; pass < 10; pass++) {\n\t\tproglen = do_jit(prog, addrs, image, oldproglen, &ctx);\n\t\tif (proglen <= 0) {\n\t\t\timage = NULL;\n\t\t\tif (header)\n\t\t\t\tbpf_jit_binary_free(header);\n\t\t\tgoto out;\n\t\t}\n\t\tif (image) {\n\t\t\tif (proglen != oldproglen) {\n\t\t\t\tpr_err(\"bpf_jit: proglen=%d != oldproglen=%d\\n\",",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\t/* Before first pass, make a rough estimation of addrs[]\n\t * each bpf instruction is translated to less than 64 bytes\n\t */\n\tfor (proglen = 0, i = 0; i < prog->len; i++) {\n\t\tproglen += 64;\n\t\taddrs[i] = proglen;\n\t}\n\tctx.cleanup_addr = proglen;\n\n\t/* JITed image shrinks with every pass and the loop iterates\n\t * until the image stops shrinking. Very large bpf programs\n\t * may converge on the last pass. In such case do one more\n\t * pass to emit the final image\n\t */\n\tfor (pass = 0; pass < 10 || image; pass++) {\n\t\tproglen = do_jit(prog, addrs, image, oldproglen, &ctx);\n\t\tif (proglen <= 0) {\n\t\t\timage = NULL;\n\t\t\tif (header)\n\t\t\t\tbpf_jit_binary_free(header);\n\t\t\tgoto out;\n\t\t}\n\t\tif (image) {\n\t\t\tif (proglen != oldproglen) {\n\t\t\t\tpr_err(\"bpf_jit: proglen=%d != oldproglen=%d\\n\",",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int mi_repair_parallel(MI_CHECK *param, register MI_INFO *info,\n\t\t\tconst char * name, int rep_quick)\n{\n  int got_error;\n  uint i,key, total_key_length, istep;\n  ulong rec_length;\n  ha_rows start_records;\n  my_off_t new_header_length,del;\n  File new_file;\n  MI_SORT_PARAM *sort_param=0;\n  MYISAM_SHARE *share=info->s;\n  ulong   *rec_per_key_part;\n    threads did either detach from the share by remove_io_thread()\n    already or they were not yet started (if the error happend before\n    creating the threads).\n  */\n  if (!rep_quick)\n    (void) end_io_cache(&new_data_cache);\n  if (!got_error)\n  {\n    /* Replace the actual file with the temporary file */\n    if (new_file >= 0)\n    {\n      mysql_file_close(new_file, MYF(0));\n      info->dfile=new_file= -1;\n      if (change_to_newfile(share->data_file_name, MI_NAME_DEXT, DATA_TMP_EXT,\n\t\t\t    (param->testflag & T_BACKUP_DATA ?\n\t\t\t     MYF(MY_REDEL_MAKE_BACKUP): MYF(0))) ||\n\t  mi_open_datafile(info,share,name,-1))\n\tgot_error=1;\n    }\n  }\n  if (got_error)\n  {\n    if (! param->error_printed)\n      mi_check_print_error(param,\"%d when fixing table\",my_errno);\n    if (new_file >= 0)\n    {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int mi_repair_parallel(MI_CHECK *param, register MI_INFO *info,\n                       const char * name, int rep_quick, my_bool no_copy_stat)\n{\n  int got_error;\n  uint i,key, total_key_length, istep;\n  ulong rec_length;\n  ha_rows start_records;\n  my_off_t new_header_length,del;\n  File new_file;\n  MI_SORT_PARAM *sort_param=0;\n  MYISAM_SHARE *share=info->s;\n  ulong   *rec_per_key_part;\n    already or they were not yet started (if the error happend before\n    creating the threads).\n  */\n  if (!rep_quick)\n    (void) end_io_cache(&new_data_cache);\n  if (!got_error)\n  {\n    /* Replace the actual file with the temporary file */\n    if (new_file >= 0)\n    {\n      myf flags= 0;\n      if (param->testflag & T_BACKUP_DATA)\n        flags |= MY_REDEL_MAKE_BACKUP;\n      if (no_copy_stat)\n        flags |= MY_REDEL_NO_COPY_STAT;\n      mysql_file_close(new_file, MYF(0));\n      info->dfile=new_file= -1;\n      if (change_to_newfile(share->data_file_name, MI_NAME_DEXT, DATA_TMP_EXT,\n\t\t\t    flags) ||\n\t  mi_open_datafile(info,share,name,-1))\n\tgot_error=1;\n    }\n  }\n  if (got_error)\n  {\n    if (! param->error_printed)\n      mi_check_print_error(param,\"%d when fixing table\",my_errno);\n    if (new_file >= 0)\n    {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrlcpy(extra_response->key, key, sizeof(extra_response->key));\n\tstrlcpy(extra_response->value, NOTUNDERSTOOD,\n\t\tsizeof(extra_response->value));\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, const bn_t d) {\n\tint i, l, n0, n1, l0, l1;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;\n\tfp24_t r, t0[1 << (EP_WIDTH - 2)];\n\tfp24_t s, t1[1 << (EP_WIDTH - 2)];\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp24_exp_cyc(e, c, d);\n\t}\n\n\tif (bn_is_zero(d)) {\n\t\treturn fp24_exp_cyc(e, a, b);\n\t}\n\n\tfp24_null(r);\n\tfp24_null(s);\n\n\tRLC_TRY {\n\t\tfp24_new(r);\n\t\tfp24_new(s);\n\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n\t\t\tfp24_null(t0[i]);\n\t\t\tfp24_null(t1[i]);\n\t\t\tfp24_new(t0[i]);\n\t\t\tfp24_new(t1[i]);\n\t\t}\n\n#if FP_WIDTH > 2\n\t\tfp24_sqr(t0[0], a);\n\t\tfp24_mul(t0[1], t0[0], a);\n\t\tfor (int i = 2; i < (1 << (FP_WIDTH - 2)); i++) {\n#endif\n\t\tfp24_copy(t0[0], a);\n\t\tfp24_copy(t1[0], c);\n\n\t\tl0 = l1 = RLC_FP_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, b, FP_WIDTH);\n\t\tbn_rec_naf(naf1, &l1, d, FP_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfor (i = 0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(d) == RLC_NEG) {\n\t\t\tfor (i = 0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\n\t\t_k = naf0 + l - 1;\n\t\t_m = naf1 + l - 1;\n\n\t\tfp24_set_dig(r, 1);\n\t\tfor (i = l - 1; i >= 0; i--, _k--, _m--) {\n\t\t\tfp24_sqr(r, r);\n\n\t\t\tn0 = *_k;\n\t\t\tn1 = *_m;\n\n\t\t\tif (n0 > 0) {\n\t\t\t\tfp24_mul(r, r, t0[n0 / 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\tfp24_inv_cyc(s, t0[-n0 / 2]);\n\t\t}\n\n\t\tfp24_copy(e, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp24_free(r);\n\t\tfp24_free(s);\n\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp24_free(t0[i]);\n\t\t\tfp24_free(t1[i]);\n\t\t}\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, const bn_t d) {\n\tint n0, n1;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;\n\tfp24_t r, t0[1 << (EP_WIDTH - 2)];\n\tfp24_t s, t1[1 << (EP_WIDTH - 2)];\n\tsize_t l, l0, l1;\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp24_exp_cyc(e, c, d);\n\t}\n\n\tif (bn_is_zero(d)) {\n\t\treturn fp24_exp_cyc(e, a, b);\n\t}\n\n\tfp24_null(r);\n\tfp24_null(s);\n\n\tRLC_TRY {\n\t\tfp24_new(r);\n\t\tfp24_new(s);\n\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n\t\t\tfp24_null(t0[i]);\n\t\t\tfp24_null(t1[i]);\n\t\t\tfp24_new(t0[i]);\n\t\t\tfp24_new(t1[i]);\n\t\t}\n\n#if FP_WIDTH > 2\n\t\tfp24_sqr(t0[0], a);\n\t\tfp24_mul(t0[1], t0[0], a);\n\t\tfor (int i = 2; i < (1 << (FP_WIDTH - 2)); i++) {\n#endif\n\t\tfp24_copy(t0[0], a);\n\t\tfp24_copy(t1[0], c);\n\n\t\tl0 = l1 = RLC_FP_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, b, FP_WIDTH);\n\t\tbn_rec_naf(naf1, &l1, d, FP_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfor (size_t i = 0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(d) == RLC_NEG) {\n\t\t\tfor (size_t i = 0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\n\t\t_k = naf0 + l - 1;\n\t\t_m = naf1 + l - 1;\n\n\t\tfp24_set_dig(r, 1);\n\t\tfor (int i = l - 1; i >= 0; i--, _k--, _m--) {\n\t\t\tfp24_sqr(r, r);\n\n\t\t\tn0 = *_k;\n\t\t\tn1 = *_m;\n\n\t\t\tif (n0 > 0) {\n\t\t\t\tfp24_mul(r, r, t0[n0 / 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\tfp24_inv_cyc(s, t0[-n0 / 2]);\n\t\t}\n\n\t\tfp24_copy(e, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp24_free(r);\n\t\tfp24_free(s);\n\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp24_free(t0[i]);\n\t\t\tfp24_free(t1[i]);\n\t\t}\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  /* access to vararg values? */\n      return findvararg(ci, -n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) {  /* is 'n' inside 'ci' stack? */\n      /* generic name for any valid slot */\n      name = isLua(ci) ? \"(temporary)\" : \"(C temporary)\";\n    }\n    else",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  /* access to vararg values? */\n      return findvararg(ci, n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) {  /* is 'n' inside 'ci' stack? */\n      /* generic name for any valid slot */\n      name = isLua(ci) ? \"(temporary)\" : \"(C temporary)\";\n    }\n    else",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tunsigned long base;\n\t\tunsigned long truesize;\n\n\t\tlen = from->iov_len - offset;\n\t\tif (!len) {\n\t\t\toffset = 0;\n\t\t\t++from;\n\t\t\tcontinue;\n\t\t}\n\t\tbase = (unsigned long)from->iov_base + offset;\n\t\tsize = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;\n\t\tnum_pages = get_user_pages_fast(base, size, 0, &page[i]);\n\t\tif ((num_pages != size) ||\n\t\t    (num_pages > MAX_SKB_FRAGS - skb_shinfo(skb)->nr_frags)) {\n\t\t\tfor (i = 0; i < num_pages; i++)\n\t\t\t\tput_page(page[i]);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\ttruesize = size * PAGE_SIZE;\n\t\tskb->data_len += len;\n\t\tskb->len += len;\n\t\tskb->truesize += truesize;\n\t\tatomic_add(truesize, &skb->sk->sk_wmem_alloc);\n\t\twhile (len) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tunsigned long truesize;\n\n\t\tlen = from->iov_len - offset;\n\t\tif (!len) {\n\t\t\toffset = 0;\n\t\t\t++from;\n\t\t\tcontinue;\n\t\t}\n\t\tbase = (unsigned long)from->iov_base + offset;\n\t\tsize = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;\n\t\tif (i + size > MAX_SKB_FRAGS)\n\t\t\treturn -EMSGSIZE;\n\t\tnum_pages = get_user_pages_fast(base, size, 0, &page[i]);\n\t\tif (num_pages != size) {\n\t\t\tfor (i = 0; i < num_pages; i++)\n\t\t\t\tput_page(page[i]);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\ttruesize = size * PAGE_SIZE;\n\t\tskb->data_len += len;\n\t\tskb->len += len;\n\t\tskb->truesize += truesize;\n\t\tatomic_add(truesize, &skb->sk->sk_wmem_alloc);\n\t\twhile (len) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    \n    int i, n = 0, len = Jsi_ObjGetLength(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = Jsi_ObjGetLength(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))\n            Jsi_ObjArrayAdd(interp, nobj, t);\n        if ((++n + clen)>interp->maxArrayList)\n            return Jsi_LogError(\"array size exceeded\");\n    }\n    return rc;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    \n    int i, n = 0, len = jsi_SizeOfArray(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = jsi_SizeOfArray(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))\n            Jsi_ObjArrayAdd(interp, nobj, t);\n        if ((++n + clen)>interp->maxArrayList)\n            return Jsi_LogError(\"array size exceeded\");\n    }\n    return rc;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        n = ( (unsigned int) ssl->in_msg[i + 1] << 8 )\n            | (unsigned int) ssl->in_msg[i + 2];\n        i += 3;\n\n        if( n < 128 || i + n > ssl->in_hslen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n            return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        ret = x509parse_crt( ssl->session_negotiate->peer_cert, ssl->in_msg + i,\n                             n );\n        if( ret != 0 )\n        {\n            SSL_DEBUG_RET( 1, \" x509parse_crt\", ret );\n            return( ret );\n        }\n\n        i += n;\n    }\n\n    SSL_DEBUG_CRT( 3, \"peer certificate\", ssl->session_negotiate->peer_cert );",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        n = ( (unsigned int) ssl->in_msg[i + 1] << 8 )\n            | (unsigned int) ssl->in_msg[i + 2];\n        i += 3;\n\n        if( n < 128 || i + n > ssl->in_hslen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n            return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        ret = x509parse_crt_der( ssl->session_negotiate->peer_cert,\n                                 ssl->in_msg + i, n );\n        if( ret != 0 )\n        {\n            SSL_DEBUG_RET( 1, \" x509parse_crt\", ret );\n            return( ret );\n        }\n\n        i += n;\n    }\n\n    SSL_DEBUG_CRT( 3, \"peer certificate\", ssl->session_negotiate->peer_cert );",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "bool ActiveStreamDecoderFilter::complete() { return parent_.state_.remote_complete_; }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "bool ActiveStreamDecoderFilter::complete() { return parent_.state_.remote_decode_complete_; }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\td = M_malloc_zero(len);\n\t/* Return is length without NULL. */\n\tif (GetTempPath((DWORD)len, d) >= len) {\n\t\tM_free(d);\n\t\td = NULL;\n\t}\n#elif defined(__APPLE__)\n\td = M_fs_path_mac_tmpdir();\n#else\n\tconst char *const_temp;\n\t/* Try Unix env var. */\n#  ifdef HAVE_SECURE_GETENV\n\tconst_temp = secure_getenv(\"TMPDIR\");\n#  else\n\tconst_temp = getenv(\"TMPDIR\");\n#  endif\n\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\td = M_strdup(const_temp);\n\t}\n\t/* Fallback to some \"standard\" system paths. */\n\tif (d == NULL) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\td = M_malloc_zero(len);\n\t/* Return is length without NULL. */\n\tif (GetTempPath((DWORD)len, d) >= len) {\n\t\tM_free(d);\n\t\td = NULL;\n\t}\n#elif defined(__APPLE__)\n\td = M_fs_path_mac_tmpdir();\n#else\n\tconst char *const_temp;\n\t/* Unix doens't have a fancy function to get the standard\n\t * temporary directory an application can use. Instead there\n\t * is a convoluted set of possible paths that could be used.\n\t *\n\t * We're going to go though each one in a priority order and\n\t * verify if we can read and write the directory. If so then\n\t * that's the one that will be used. We are fine using access\n\t * here because it doesn't matter if the path ends up being\n\t * changed out from underneath us later on. When it's used\n\t * at that time it will fail. Right now we just want to get\n\t * a path that can be tried. */\n\n\t/* Try Unix env vars.\n\t *\n\t * This is not ideal but a valid way to set the temporary directory\n\t * for a user. Per Single Unix Specification 4 and probably other things.\n\t */\n#  ifdef HAVE_SECURE_GETENV\n\tconst_temp = secure_getenv(\"TMPDIR\");\n#  else\n\tconst_temp = getenv(\"TMPDIR\");\n#  endif\n\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\td = M_strdup(const_temp);\n\t}\n\t/* Fallback to some \"standard\" system paths. */\n\tif (d == NULL) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, int open_flags)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *deleg_cur;\n\tint ret = 0;\n\n\topen_flags &= (FMODE_READ|FMODE_WRITE);\n\n\trcu_read_lock();\n\tdeleg_cur = rcu_dereference(nfsi->delegation);\n\tif (deleg_cur == NULL)\n\t\tgoto no_delegation;\n\n\tspin_lock(&deleg_cur->lock);\n\tif (nfsi->delegation != deleg_cur ||\n\t    (deleg_cur->type & open_flags) != open_flags)\n\t\tgoto no_delegation_unlock;\n\n\tif (delegation == NULL)\n\t\tdelegation = &deleg_cur->stateid;\n\telse if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)\n\t\tgoto no_delegation_unlock;\n\n\tnfs_mark_delegation_referenced(deleg_cur);\n\t__update_open_stateid(state, open_stateid, &deleg_cur->stateid, open_flags);\n\tret = 1;\nno_delegation_unlock:\n\tspin_unlock(&deleg_cur->lock);\nno_delegation:\n\trcu_read_unlock();\n\n\tif (!ret && open_stateid != NULL) {\n\t\t__update_open_stateid(state, open_stateid, NULL, open_flags);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, fmode_t fmode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *deleg_cur;\n\tint ret = 0;\n\n\tfmode &= (FMODE_READ|FMODE_WRITE);\n\n\trcu_read_lock();\n\tdeleg_cur = rcu_dereference(nfsi->delegation);\n\tif (deleg_cur == NULL)\n\t\tgoto no_delegation;\n\n\tspin_lock(&deleg_cur->lock);\n\tif (nfsi->delegation != deleg_cur ||\n\t    (deleg_cur->type & fmode) != fmode)\n\t\tgoto no_delegation_unlock;\n\n\tif (delegation == NULL)\n\t\tdelegation = &deleg_cur->stateid;\n\telse if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)\n\t\tgoto no_delegation_unlock;\n\n\tnfs_mark_delegation_referenced(deleg_cur);\n\t__update_open_stateid(state, open_stateid, &deleg_cur->stateid, fmode);\n\tret = 1;\nno_delegation_unlock:\n\tspin_unlock(&deleg_cur->lock);\nno_delegation:\n\trcu_read_unlock();\n\n\tif (!ret && open_stateid != NULL) {\n\t\t__update_open_stateid(state, open_stateid, NULL, fmode);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n    const bool is_profiling = profile_result != nullptr;\n\n    std::unique_ptr<GpuTimer, GpuTimerDeleter> timer;\n    if (is_profiling) {\n      timer.reset(new GpuTimer(parent_));  // NOLINT\n      // The start and stop of the timer should be as close to the Cudnn call as\n      // possible. It is still possible for other threads to issue workload on\n      // to this stream. So it could take multiple profiling measurements.\n      if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n        return tsl::Status(port::error::INTERNAL, \"Failed to start timer\");\n      }\n    }\n\n    cudnnStatus_t status = cudnnBackendExecute(\n        cudnn.handle(), plan_.get_raw_desc(), variantPack.get_raw_desc());\n    RETURN_IF_CUDNN_ERROR(status);\n\n    if (is_profiling) {\n      if (!timer->Stop(AsGpuStream(stream))) {\n        return tsl::Status(port::error::INTERNAL, \"Failed to stop timer\");\n      }\n      TF_ASSIGN_OR_RETURN(auto desc, ToAlgorithmDesc());\n      profile_result->set_algorithm(desc);\n      profile_result->set_elapsed_time_in_ms(timer->GetElapsedMilliseconds());\n      profile_result->set_scratch_size(scratch_memory.size());\n\n      VLOG(4) << \"cudnn op with plan \" << plan_.getTag()\n              << \", workspace_size=\" << workspace_size << \" -> \"\n              << CudnnStatusToString(status) << \" in \"\n              << timer->GetElapsedMilliseconds() << \"ms\";",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n    const bool is_profiling = profile_result != nullptr;\n\n    std::unique_ptr<GpuTimer, GpuTimerDeleter> timer;\n    if (is_profiling) {\n      timer.reset(new GpuTimer(parent_));  // NOLINT\n      // The start and stop of the timer should be as close to the Cudnn call as\n      // possible. It is still possible for other threads to issue workload on\n      // to this stream. So it could take multiple profiling measurements.\n      if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n        return tsl::Status(tsl::error::INTERNAL, \"Failed to start timer\");\n      }\n    }\n\n    cudnnStatus_t status = cudnnBackendExecute(\n        cudnn.handle(), plan_.get_raw_desc(), variantPack.get_raw_desc());\n    RETURN_IF_CUDNN_ERROR(status);\n\n    if (is_profiling) {\n      if (!timer->Stop(AsGpuStream(stream))) {\n        return tsl::Status(tsl::error::INTERNAL, \"Failed to stop timer\");\n      }\n      TF_ASSIGN_OR_RETURN(auto desc, ToAlgorithmDesc());\n      profile_result->set_algorithm(desc);\n      profile_result->set_elapsed_time_in_ms(timer->GetElapsedMilliseconds());\n      profile_result->set_scratch_size(scratch_memory.size());\n\n      VLOG(4) << \"cudnn op with plan \" << plan_.getTag()\n              << \", workspace_size=\" << workspace_size << \" -> \"\n              << CudnnStatusToString(status) << \" in \"\n              << timer->GetElapsedMilliseconds() << \"ms\";",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      void Init(void)\n      {\n        for(int i = 0;i < 18;i++) {\n          X[i].Init();\n          M[i].Init();\n        }\n      }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      void Init(void)\n      {\n        for(int i = 0;i < MagnitudeContexts;i++) {\n          X[i].Init();\n          M[i].Init();\n        }\n      }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        getComputedSlotValue(propObj.get(), runtime, desc));\n    if (!accessor->getter)\n      return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n    // Execute the accessor on this object.\n    return accessor->getter.get(runtime)->executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    SymbolID id{};\n    LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n    auto propRes = vmcast<HostObject>(selfHandle.get())->get(id);\n    if (propRes == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return createPseudoHandle(*propRes);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return JSProxy::getComputed(propObj, runtime, *key, receiver);\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        getComputedSlotValue(propObj.get(), runtime, desc));\n    if (!accessor->getter)\n      return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n    // Execute the accessor on this object.\n    return accessor->getter.get(runtime)->executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    SymbolID id{};\n    LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n    auto propRes = vmcast<HostObject>(propObj.get())->get(id);\n    if (propRes == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return createPseudoHandle(*propRes);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return JSProxy::getComputed(propObj, runtime, *key, receiver);\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n            if (tls_io_instance->certificate != NULL)\n            {\n                // Free the memory if it has been previously allocated\n                free(tls_io_instance->certificate);\n                tls_io_instance->certificate = NULL;\n            }\n\n            // Store the certificate\n            len = strlen(cert);\n            tls_io_instance->certificate = malloc(len + 1);\n            if (tls_io_instance->certificate == NULL)\n            {\n                result = MU_FAILURE;\n            }\n            else\n            {\n                strcpy(tls_io_instance->certificate, cert);\n                result = 0;\n            }\n\n            // If we're previously connected then add the cert to the context\n            if (tls_io_instance->ssl_context != NULL)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n            if (tls_io_instance->certificate != NULL)\n            {\n                // Free the memory if it has been previously allocated\n                free(tls_io_instance->certificate);\n                tls_io_instance->certificate = NULL;\n            }\n\n            // Store the certificate\n            len = strlen(cert);\n            size_t malloc_size = safe_add_size_t(len, 1);\n            if (malloc_size == SIZE_MAX ||\n                (tls_io_instance->certificate = malloc(malloc_size)) == NULL)\n            {\n                LogError(\"malloc failure, size:%zu\", malloc_size);\n                result = MU_FAILURE;\n            }\n            else\n            {\n                strcpy(tls_io_instance->certificate, cert);\n                result = 0;\n            }\n\n            // If we're previously connected then add the cert to the context\n            if (tls_io_instance->ssl_context != NULL)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "list_dbs(MYSQL *mysql,const char *wild)\n{\n  const char *header;\n  uint length, counter = 0;\n  ulong rowcount = 0L;\n  char tables[NAME_LEN+1], rows[NAME_LEN+1];\n  char query[255];\n  MYSQL_FIELD *field;\n  MYSQL_RES *result;\n  MYSQL_ROW row= NULL, rrow;\n\n  if (!(result=mysql_list_dbs(mysql,wild)))\n  {\n    fprintf(stderr,\"%s: Cannot list databases: %s\\n\",my_progname,\n\t    mysql_error(mysql));\n    return 1;\n  }\n\tif (mysql_affected_rows(mysql) > 0)\n\t{\n\t  sprintf(tables,\"%6lu\",(ulong) mysql_affected_rows(mysql));\n\t  rowcount = 0;\n\t  if (opt_verbose > 1)\n\t  {\n            /* Print the count of tables and rows for each database */\n            MYSQL_ROW trow;\n\t    while ((trow = mysql_fetch_row(tresult)))\n\t    {\n\t      sprintf(query,\"SELECT COUNT(*) FROM `%s`\",trow[0]);\n\t      if (!(mysql_query(mysql,query)))\n\t      {\n\t\tMYSQL_RES *rresult;\n\t\tif ((rresult = mysql_store_result(mysql)))\n\t\t{\n\t\t  rrow = mysql_fetch_row(rresult);\n\t\t  rowcount += (ulong) strtoull(rrow[0], (char**) 0, 10);\n\t\t  mysql_free_result(rresult);\n\t\t}\n\t      }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "list_dbs(MYSQL *mysql,const char *wild)\n{\n  const char *header;\n  uint length, counter = 0;\n  ulong rowcount = 0L;\n  char tables[NAME_LEN+1], rows[NAME_LEN+1];\n  char query[NAME_LEN + 100];\n  MYSQL_FIELD *field;\n  MYSQL_RES *result;\n  MYSQL_ROW row= NULL, rrow;\n\n  if (!(result=mysql_list_dbs(mysql,wild)))\n  {\n    fprintf(stderr,\"%s: Cannot list databases: %s\\n\",my_progname,\n\t    mysql_error(mysql));\n    return 1;\n  }\n\tif (mysql_affected_rows(mysql) > 0)\n\t{\n\t  sprintf(tables,\"%6lu\",(ulong) mysql_affected_rows(mysql));\n\t  rowcount = 0;\n\t  if (opt_verbose > 1)\n\t  {\n            /* Print the count of tables and rows for each database */\n            MYSQL_ROW trow;\n\t    while ((trow = mysql_fetch_row(tresult)))\n\t    {\n              my_snprintf(query, sizeof(query),\n                          \"SELECT COUNT(*) FROM `%s`\", trow[0]);\n\t      if (!(mysql_query(mysql,query)))\n\t      {\n\t\tMYSQL_RES *rresult;\n\t\tif ((rresult = mysql_store_result(mysql)))\n\t\t{\n\t\t  rrow = mysql_fetch_row(rresult);\n\t\t  rowcount += (ulong) strtoull(rrow[0], (char**) 0, 10);\n\t\t  mysql_free_result(rresult);\n\t\t}\n\t      }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tM_fs_file_t   *fd_old;\n\tM_fs_file_t   *fd_new;\n\tM_fs_info_t   *info         = NULL;\n\tunsigned char  temp[M_FS_BUF_SIZE];\n\tsize_t         read_len;\n\tsize_t         wrote_len;\n\tsize_t         wrote_total  = 0;\n\tsize_t         offset;\n\tM_fs_error_t   res;\n\n\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n \t * to new file. */\n\tif (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n\t\t/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without\n \t\t * any permissions and to ensure that anything that has the file already open won't be able to read the new\n\t\t * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition\n\t\t * between deleting and creating the file where someone could create the file and have access. However,\n\t\t * depending on the OS they may have access even if the file is created with no perms... */\n\t\tres = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\treturn res;\n\t\t}\n\t}\n\t/* Open the old file */\n\tres = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\treturn res;\n\t}\n\n\tif (perms == NULL && mode & M_FS_FILE_MODE_PRESERVE_PERMS) {\n\t\tres = M_fs_info_file(&info, fd_old, M_FS_PATH_INFO_FLAGS_NONE);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tM_fs_file_close(fd_old);\n\t\t\treturn res;\n\t\t}\n\t\tperms = M_fs_info_get_perms(info);\n\t}\n\tres = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);\n\tM_fs_info_destroy(info);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_fs_file_close(fd_old);\n\t\treturn res;\n\t}\n\n\t/* Copy the contents of old into new. */\n\twhile ((res = M_fs_file_read(fd_old, temp, sizeof(temp), &read_len, M_FS_FILE_RW_NORMAL)) == M_FS_ERROR_SUCCESS && read_len != 0) {\n\t\toffset = 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n\tM_fs_file_t   *fd_old;\n\tM_fs_file_t   *fd_new;\n\tM_fs_info_t   *info         = NULL;\n\tunsigned char  temp[M_FS_BUF_SIZE];\n\tsize_t         read_len;\n\tsize_t         wrote_len;\n\tsize_t         wrote_total  = 0;\n\tsize_t         offset;\n\tM_fs_error_t   res;\n\n\t/* Open the old file */\n\tres = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\treturn res;\n\t}\n\n\tif (perms == NULL && mode & M_FS_FILE_MODE_PRESERVE_PERMS) {\n\t\tres = M_fs_info_file(&info, fd_old, M_FS_PATH_INFO_FLAGS_NONE);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tM_fs_file_close(fd_old);\n\t\t\treturn res;\n\t\t}\n\t\tperms = M_fs_info_get_perms(info);\n\t}\n\n\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n\t * to new file. */\n\tres = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);\n\tM_fs_info_destroy(info);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_fs_file_close(fd_old);\n\t\treturn res;\n\t}\n\n\t/* Copy the contents of old into new. */\n\twhile ((res = M_fs_file_read(fd_old, temp, sizeof(temp), &read_len, M_FS_FILE_RW_NORMAL)) == M_FS_ERROR_SUCCESS && read_len != 0) {\n\t\toffset = 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tint j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tmemcpy(file->name, d, len);\n\t\t\tfile->namelen = len;\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tsize_t j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tfile->namelen = MIN(sizeof file->name, len);\n\t\t\tmemcpy(file->name, d, file->namelen);\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n      \n      /*\n        Mipmapcount includes the main image, so start from one\n      */\n      for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) w * h * pixel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n        \n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n      \n      /*\n        Mipmapcount includes the main image, so start from one\n      */\n      for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) w * h * pixel_size;\n        if (SeekBlob(image, offset, SEEK_CUR) < 0)\n          break;\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t.id\t\t= primary_event_id(event),\n\t\t.stream_id\t= event->id,\n\t};\n\n\tif (enable)\n\t\tthrottle_event.header.type = PERF_RECORD_UNTHROTTLE;\n\n\tperf_event_header__init_id(&throttle_event.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tthrottle_event.header.size, 1, 0);\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, throttle_event);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\tperf_output_end(&handle);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t.id\t\t= primary_event_id(event),\n\t\t.stream_id\t= event->id,\n\t};\n\n\tif (enable)\n\t\tthrottle_event.header.type = PERF_RECORD_UNTHROTTLE;\n\n\tperf_event_header__init_id(&throttle_event.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tthrottle_event.header.size, 0);\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, throttle_event);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\tperf_output_end(&handle);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "            }\n\n            bytes = GetDigestSize( session->authHash );\n\n            if( key.t.size == 0 )\n            {\n                session->sessionKey.t.size = 0;\n            }\n            else\n            {\n                rval = tpm_kdfa(sapi_context, session->authHash, &(key.b), label, &( session->nonceNewer.b ),\n                        &( session->nonceOlder.b ), bytes * 8, (TPM2B_MAX_BUFFER *)&( session->sessionKey ) );\n            }\n\n            if( rval != TPM_RC_SUCCESS )\n            {\n                return( TSS2_APP_RC_CREATE_SESSION_KEY_FAILED );\n            }\n        }\n\n        session->nonceTpmDecrypt.b.size = 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "            }\n\n            bytes = GetDigestSize( session->authHash );\n\n            if( key.t.size == 0 )\n            {\n                session->sessionKey.t.size = 0;\n            }\n            else\n            {\n                rval = tpm_kdfa(session->authHash, &(key.b), label, &( session->nonceNewer.b ),\n                        &( session->nonceOlder.b ), bytes * 8, (TPM2B_MAX_BUFFER *)&( session->sessionKey ) );\n            }\n\n            if( rval != TPM_RC_SUCCESS )\n            {\n                return( TSS2_APP_RC_CREATE_SESSION_KEY_FAILED );\n            }\n        }\n\n        session->nonceTpmDecrypt.b.size = 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tvoid *vapic;\n\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\t*(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr)) = data;\n\tkunmap_atomic(vapic);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\tsizeof(u32));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\t/* Throw away the key data */\n\t\tif (key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tsecurity_key_free(key);\n\n\t\t/* deal with the user's key tracking and quota */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\t/* Throw away the key data if the key is instantiated */\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n\t\t    key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tsecurity_key_free(key);\n\n\t\t/* deal with the user's key tracking and quota */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tvirtual ~CxFile() { };",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tvirtual ~CxFile() { }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  ** ends in '/' it is an error. */\n  if( bIsDir==0 ){\n    if( zName[nName-1]=='/' ){\n      zErr = sqlite3_mprintf(\"non-directory name must not end with /\");\n      rc = SQLITE_ERROR;\n      goto zipfile_step_out;\n    }\n  }else{\n    if( zName[nName-1]!='/' ){\n      zName = zFree = sqlite3_mprintf(\"%s/\", zName);\n      nName++;\n      if( zName==0 ){\n        rc = SQLITE_NOMEM;\n        goto zipfile_step_out;\n      }\n    }else{\n      while( nName>1 && zName[nName-2]=='/' ) nName--;\n    }\n  }\n\n  /* Assemble the ZipfileEntry object for the new zip archive entry */\n  e.cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;\n  e.cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;\n  e.cds.flags = ZIPFILE_NEWENTRY_FLAGS;\n  e.cds.iCompression = (u16)iMethod;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  ** at the end of the path. Or, if this is not a directory and the path\n  ** ends in '/' it is an error. */\n  if( bIsDir==0 ){\n    if( zName[nName-1]=='/' ){\n      zErr = sqlite3_mprintf(\"non-directory name must not end with /\");\n      rc = SQLITE_ERROR;\n      goto zipfile_step_out;\n    }\n  }else{\n    if( zName[nName-1]!='/' ){\n      zName = zFree = sqlite3_mprintf(\"%s/\", zName);\n      if( zName==0 ){\n        rc = SQLITE_NOMEM;\n        goto zipfile_step_out;\n      }\n      nName = (int)strlen(zName);\n    }else{\n      while( nName>1 && zName[nName-2]=='/' ) nName--;\n    }\n  }\n\n  /* Assemble the ZipfileEntry object for the new zip archive entry */\n  e.cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;\n  e.cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;\n  e.cds.flags = ZIPFILE_NEWENTRY_FLAGS;\n  e.cds.iCompression = (u16)iMethod;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "write_link_file(const NetplanNetDefinition* def, const char* rootdir, const char* path)\n{\n    GString* s = NULL;\n    mode_t orig_umask;\n\n    /* Don't write .link files for virtual devices; they use .netdev instead.\n     * Don't write .link files for MODEM devices, as they aren't supported by networkd.\n     */\n    if (def->type >= NETPLAN_DEF_TYPE_VIRTUAL || def->type == NETPLAN_DEF_TYPE_MODEM)\n        return;\n\n    /* do we need to write a .link file? */\n    if (!def->set_name &&\n        !def->wake_on_lan &&\n        (def->generic_segmentation_offload ? \"true\" : \"false\"));\n\n    if (def->generic_receive_offload != NETPLAN_TRISTATE_UNSET)\n        g_string_append_printf(s, \"GenericReceiveOffload=%s\\n\",\n        (def->generic_receive_offload ? \"true\" : \"false\"));\n\n    if (def->large_receive_offload != NETPLAN_TRISTATE_UNSET)\n        g_string_append_printf(s, \"LargeReceiveOffload=%s\\n\",\n        (def->large_receive_offload ? \"true\" : \"false\"));\n\n    orig_umask = umask(022);\n    _netplan_g_string_free_to_file(s, rootdir, path, \".link\");\n    umask(orig_umask);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "write_link_file(const NetplanNetDefinition* def, const char* rootdir, const char* path)\n{\n    GString* s = NULL;\n\n    /* Don't write .link files for virtual devices; they use .netdev instead.\n     * Don't write .link files for MODEM devices, as they aren't supported by networkd.\n     */\n    if (def->type >= NETPLAN_DEF_TYPE_VIRTUAL || def->type == NETPLAN_DEF_TYPE_MODEM)\n        return;\n\n    /* do we need to write a .link file? */\n    if (!def->set_name &&\n        !def->wake_on_lan &&\n        (def->generic_segmentation_offload ? \"true\" : \"false\"));\n\n    if (def->generic_receive_offload != NETPLAN_TRISTATE_UNSET)\n        g_string_append_printf(s, \"GenericReceiveOffload=%s\\n\",\n        (def->generic_receive_offload ? \"true\" : \"false\"));\n\n    if (def->large_receive_offload != NETPLAN_TRISTATE_UNSET)\n        g_string_append_printf(s, \"LargeReceiveOffload=%s\\n\",\n        (def->large_receive_offload ? \"true\" : \"false\"));\n\n    _netplan_g_string_free_to_file_with_permissions(s, rootdir, path, \".link\", \"root\", \"root\", 0640);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void parse_generic_line(pj_scanner *scanner, pj_str_t *str,\n\t\t\t       volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINSDP;\n\n    /* check equal sign */\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* x= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* get anything until newline (including whitespaces). */\n    pj_scan_get_until_chr(scanner, \"\\r\\n\", str);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void parse_generic_line(pj_scanner *scanner, pj_str_t *str,\n\t\t\t       volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINSDP;\n\n    /* check equal sign */\n    if ((scanner->curptr+1 >= scanner->end) || *(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* x= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* get anything until newline (including whitespaces). */\n    pj_scan_get_until_chr(scanner, \"\\r\\n\", str);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\txfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd;\n\t\tif ( xfr_cmd[0] == '\\0' ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** command disabled ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tfname = read_filename();\n\t\tif (fname == NULL) {\n\t\t\tfd_printf(STO, \"*** cannot read filename ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\trun_cmd(tty_fd, xfr_cmd, fname, NULL);\n\t\tfree(fname);\n\t\tbreak;\n\tcase KEY_BREAK:\n\t\tterm_break(tty_fd);\n\t\tfd_printf(STO, \"\\r\\n*** break sent ***\\r\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\txfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd;\n\t\tif ( xfr_cmd[0] == '\\0' ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** command disabled ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tfname = read_filename();\n\t\tif (fname == NULL) {\n\t\t\tfd_printf(STO, \"*** cannot read filename ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\trun_cmd(tty_fd, xfr_cmd, fname);\n\t\tfree(fname);\n\t\tbreak;\n\tcase KEY_BREAK:\n\t\tterm_break(tty_fd);\n\t\tfd_printf(STO, \"\\r\\n*** break sent ***\\r\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\taddr_t offset;\n\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask) {\n\t\t\tunsigned long mask = PSW_MASK_USER;\n\n\t\t\tmask |= is_ri_task(child) ? PSW_MASK_RI : 0;\n\t\t\tif ((data & ~mask) != PSW_USER_BITS)\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW_MASK_EA) && !(data & PSW_MASK_BA))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\taddr_t offset;\n\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\t/*\n\t\t * psw and gprs are stored on the stack\n\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask) {\n\t\t\tunsigned long mask = PSW_MASK_USER;\n\n\t\t\tmask |= is_ri_task(child) ? PSW_MASK_RI : 0;\n\t\t\tif ((data ^ PSW_USER_BITS) & ~mask)\n\t\t\t\t/* Invalid psw mask. */\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW_MASK_ASC) == PSW_ASC_HOME)\n\t\t\t\t/* Invalid address-space-control bits */\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW_MASK_EA) && !(data & PSW_MASK_BA))\n\t\t\t\t/* Invalid addressing mode bits */\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {\n\t\t/*\n\t\t * access registers are stored in the thread structure\n\t\t */\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "               tidx = i;\n               break;\n            }\n        }\n    }\n\n    if (src_end - src < 2)\n        return 0;\n    zsize = (src[0] << 8) | src[1]; src += 2;\n\n    if (src_end - src < zsize)\n        return AVERROR_INVALIDDATA;\n\n    ret = uncompress(c->kempf_buf, &dlen, src, zsize);\n    if (ret)\n        return AVERROR_INVALIDDATA;\n    src += zsize;\n\n    if (sub_type == 2) {\n        kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,\n                          NULL, 0, width, height, pal, npal, tidx);\n        return 0;\n    }\n\n    nblocks = *src++ + 1;\n    cblocks = 0;\n    bstride = FFALIGN(width, 16) >> 4;\n    // blocks are coded LSB and we need normal bitreader for JPEG data\n    bits = 0;\n    for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {\n        for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {\n            if (!bits) {\n                bitbuf = *src++;\n                bits   = 8;\n            }\n            coded = bitbuf & 1;\n            bits--;\n            bitbuf >>= 1;\n            cblocks += coded;\n            if (cblocks > nblocks)\n                return AVERROR_INVALIDDATA;\n            c->kempf_flags[j + i * bstride] = coded;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "               tidx = i;\n               break;\n            }\n        }\n    }\n\n    if (src_end - src < 2)\n        return 0;\n    zsize = (src[0] << 8) | src[1]; src += 2;\n\n    if (src_end - src < zsize + (sub_type != 2))\n        return AVERROR_INVALIDDATA;\n\n    ret = uncompress(c->kempf_buf, &dlen, src, zsize);\n    if (ret)\n        return AVERROR_INVALIDDATA;\n    src += zsize;\n\n    if (sub_type == 2) {\n        kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,\n                          NULL, 0, width, height, pal, npal, tidx);\n    }\n\n    nblocks = *src++ + 1;\n    cblocks = 0;\n    bstride = FFALIGN(width, 16) >> 4;\n    // blocks are coded LSB and we need normal bitreader for JPEG data\n    bits = 0;\n    for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {\n        for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {\n            if (!bits) {\n                if (src >= src_end)\n                    return AVERROR_INVALIDDATA;\n                bitbuf = *src++;\n                bits   = 8;\n            }\n            coded = bitbuf & 1;\n            bits--;\n            bitbuf >>= 1;\n            cblocks += coded;\n            if (cblocks > nblocks)\n                return AVERROR_INVALIDDATA;\n            c->kempf_flags[j + i * bstride] = coded;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n    int *err, gchar **err_info)\n{\n\tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n\tchar\tline[TOSHIBA_LINE_LENGTH];\n\tint\tnum_items_scanned;\n\tint\tpkt_len, pktnum, hr, min, sec, csec;\n\tchar\tchannel[10], direction[10];\n\tint\ti, hex_lines;\n\tguint8\t*pd;\n\n\t/* Our file pointer should be on the line containing the\n\t * summary information for a packet. Read in that line and\n\t * extract the useful information\n\t */\n\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t*err = file_error(fh, err_info);\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* Check for \"OFFSET 0001-0203\" at beginning of line */\n\t\tline[16] = '\\0';\n\n\t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n\n\tnum_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);\n\tif (num_items_scanned != 1) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n\t\treturn FALSE;\n\t}\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\tphdr->ts.secs = hr * 3600 + min * 60 + sec;\n\tphdr->ts.nsecs = csec * 10000000;\n\tphdr->caplen = pkt_len;\n\tphdr->len = pkt_len;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\t\t/* XXX - is there an FCS in the frame? */\n\t\t\tpseudo_header->eth.fcs_len = -1;\n\t\t\tbreak;\n\t}\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, TOSHIBA_MAX_PACKET_LEN);\n\tpd = ws_buffer_start_ptr(buf);\n\n\t/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data */\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n    int *err, gchar **err_info)\n{\n\tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n\tchar\tline[TOSHIBA_LINE_LENGTH];\n\tint\tnum_items_scanned;\n\tguint\tpkt_len;\n\tint\tpktnum, hr, min, sec, csec;\n\tchar\tchannel[10], direction[10];\n\tint\ti, hex_lines;\n\tguint8\t*pd;\n\n\t/* Our file pointer should be on the line containing the\n\t * summary information for a packet. Read in that line and\n\t * extract the useful information\n\t */\n\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t*err = file_error(fh, err_info);\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t/* Check for \"OFFSET 0001-0203\" at beginning of line */\n\t\tline[16] = '\\0';\n\n\t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n\n\tnum_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);\n\tif (num_items_scanned != 1) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n\t\treturn FALSE;\n\t}\n\tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n\t\t/*\n\t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"toshiba: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n\t\treturn FALSE;\n\t}\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\tphdr->ts.secs = hr * 3600 + min * 60 + sec;\n\tphdr->ts.nsecs = csec * 10000000;\n\tphdr->caplen = pkt_len;\n\tphdr->len = pkt_len;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\t\t/* XXX - is there an FCS in the frame? */\n\t\t\tpseudo_header->eth.fcs_len = -1;\n\t\t\tbreak;\n\t}\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, pkt_len);\n\tpd = ws_buffer_start_ptr(buf);\n\n\t/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data */\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "char *string_crypt(const char *key, const char *salt) {\n  assert(key);\n  assert(salt);\n\n  char random_salt[12];\n  if (!*salt) {\n    memcpy(random_salt,\"$1$\",3);\n    ito64(random_salt+3,rand(),8);\n    random_salt[11] = '\\0';\n    return string_crypt(key, random_salt);\n  }\n\n  if ((strlen(salt) > sizeof(\"$2X$00$\")) &&\n    (salt[0] == '$') &&\n    (salt[1] == '2') &&\n    (salt[2] >= 'a') && (salt[2] <= 'z') &&\n    (salt[3] == '$') &&\n    (salt[4] >= '0') && (salt[4] <= '3') &&\n    (salt[5] >= '0') && (salt[5] <= '9') &&\n    (salt[6] == '$')) {\n    // Bundled blowfish crypt()\n    char output[61];\n    if (php_crypt_blowfish_rn(key, salt, output, sizeof(output))) {\n      return strdup(output);\n    }\n\n  } else {\n    // System crypt() function\n#ifdef USE_PHP_CRYPT_R\n    return php_crypt_r(key, salt);\n#else\n    static Mutex mutex;\n    Lock lock(mutex);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "char *string_crypt(const char *key, const char *salt) {\n  assertx(key);\n  assertx(salt);\n\n  char random_salt[12];\n  if (!*salt) {\n    memcpy(random_salt,\"$1$\",3);\n    ito64(random_salt+3,rand(),8);\n    random_salt[11] = '\\0';\n    return string_crypt(key, random_salt);\n  }\n\n  auto const saltLen = strlen(salt);\n  if ((saltLen > sizeof(\"$2X$00$\")) &&\n    (salt[0] == '$') &&\n    (salt[1] == '2') &&\n    (salt[2] >= 'a') && (salt[2] <= 'z') &&\n    (salt[3] == '$') &&\n    (salt[4] >= '0') && (salt[4] <= '3') &&\n    (salt[5] >= '0') && (salt[5] <= '9') &&\n    (salt[6] == '$')) {\n    // Bundled blowfish crypt()\n    char output[61];\n\n    static constexpr size_t maxSaltLength = 123;\n    char paddedSalt[maxSaltLength + 1];\n    paddedSalt[0] = paddedSalt[maxSaltLength] = '\\0';\n\n    memset(&paddedSalt[1], '$', maxSaltLength - 1);\n    memcpy(paddedSalt, salt, std::min(maxSaltLength, saltLen));\n    paddedSalt[saltLen] = '\\0';\n\n    if (php_crypt_blowfish_rn(key, paddedSalt, output, sizeof(output))) {\n      return strdup(output);\n    }\n\n  } else {\n    // System crypt() function\n#ifdef USE_PHP_CRYPT_R\n    return php_crypt_r(key, salt);\n#else\n    static Mutex mutex;\n    Lock lock(mutex);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void gdImageCopyResized (gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int dstW, int dstH, int srcW, int srcH)\n{\n\tint c;\n\tint x, y;\n\tint tox, toy;\n\tint ydest;\n\tint i;\n\tint colorMap[gdMaxColors];\n\t/* Stretch vectors */\n\tint *stx, *sty;\n\t\n\tif (overflow2(sizeof(int), srcW)) {\n\t\treturn;\n\t}\n\tif (overflow2(sizeof(int), srcH)) {\n\t\treturn;\n\t}\n\n\tstx = (int *) gdMalloc (sizeof (int) * srcW);\n\tsty = (int *) gdMalloc (sizeof (int) * srcH);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void gdImageCopyResized (gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int dstW, int dstH, int srcW, int srcH)\n{\n\tint c;\n\tint x, y;\n\tint tox, toy;\n\tint ydest;\n\tint i;\n\tint colorMap[gdMaxColors];\n\t/* Stretch vectors */\n\tint *stx, *sty;\n\n\tif (overflow2(sizeof(int), srcW)) {\n\t\treturn;\n\t}\n\tif (overflow2(sizeof(int), srcH)) {\n\t\treturn;\n\t}\n\n\tstx = (int *) gdMalloc (sizeof (int) * srcW);\n\tsty = (int *) gdMalloc (sizeof (int) * srcH);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "         * report success to client, but return\n         * SLAPI_BIND_FAIL so we don't\n         * authorize based on noauth credentials\n         */\n        slapi_send_ldap_result(pb, LDAP_SUCCESS, NULL, NULL, 0, NULL);\n        return (SLAPI_BIND_FAIL);\n    }\n\n    ec = dse_get_entry_copy(pdse, sdn, DSE_USE_LOCK);\n    if (ec == NULL) {\n        slapi_send_ldap_result(pb, LDAP_NO_SUCH_OBJECT, NULL, NULL, 0, NULL);\n        return (SLAPI_BIND_FAIL);\n    }\n\n    switch (method) {\n    case LDAP_AUTH_SIMPLE: {\n        Slapi_Value cv;\n        if (slapi_entry_attr_find(ec, \"userpassword\", &attr) != 0) {\n            slapi_send_ldap_result(pb, LDAP_INAPPROPRIATE_AUTH, NULL, NULL, 0, NULL);\n            slapi_entry_free(ec);\n            return SLAPI_BIND_FAIL;\n        }\n        bvals = attr_get_present_values(attr);\n\n        slapi_value_init_berval(&cv, cred);\n        if (slapi_pw_find_sv(bvals, &cv) != 0) {\n            slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n            slapi_entry_free(ec);\n            value_done(&cv);\n            return SLAPI_BIND_FAIL;\n        }\n        value_done(&cv);\n    } break;\n\n    default:\n        slapi_send_ldap_result(pb, LDAP_STRONG_AUTH_NOT_SUPPORTED, NULL, \"auth method not supported\", 0, NULL);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "         * report success to client, but return\n         * SLAPI_BIND_FAIL so we don't\n         * authorize based on noauth credentials\n         */\n        slapi_send_ldap_result(pb, LDAP_SUCCESS, NULL, NULL, 0, NULL);\n        return (SLAPI_BIND_FAIL);\n    }\n\n    ec = dse_get_entry_copy(pdse, sdn, DSE_USE_LOCK);\n    if (ec == NULL) {\n        slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Entry does not exist\");\n        slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n        return (SLAPI_BIND_FAIL);\n    }\n\n    switch (method) {\n    case LDAP_AUTH_SIMPLE: {\n        Slapi_Value cv;\n        if (slapi_entry_attr_find(ec, \"userpassword\", &attr) != 0) {\n            slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Entry does not have userpassword set\");\n            slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n            slapi_entry_free(ec);\n            return SLAPI_BIND_FAIL;\n        }\n        bvals = attr_get_present_values(attr);\n\n        slapi_value_init_berval(&cv, cred);\n        if (slapi_pw_find_sv(bvals, &cv) != 0) {\n            slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Invalid credentials\");\n            slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n            slapi_entry_free(ec);\n            value_done(&cv);\n            return SLAPI_BIND_FAIL;\n        }\n        value_done(&cv);\n    } break;\n\n    default:\n        slapi_send_ldap_result(pb, LDAP_STRONG_AUTH_NOT_SUPPORTED, NULL, \"auth method not supported\", 0, NULL);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ex_function(exarg_T *eap)\n{\n    (void)define_function(eap, NULL);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ex_function(exarg_T *eap)\n{\n    char_u *line_to_free = NULL;\n\n    (void)define_function(eap, NULL, &line_to_free);\n    vim_free(line_to_free);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void ed_mul_sim_lot(ed_t r, const ed_t p[], const bn_t k[], int n) {\n\tint i, j, l, *_l = RLC_ALLOCA(int, n);\n\ted_t *_p = RLC_ALLOCA(ed_t, n);\n\tint8_t *naf = NULL;\n\n\tRLC_TRY {\n\t\tl = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tl = RLC_MAX(l, bn_bits(k[i]) + 1);\n\t\t}\n\t\tnaf = RLC_ALLOCA(int8_t, n * l);\n\t\tif (naf == NULL || _p == NULL || _l == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void ed_mul_sim_lot(ed_t r, const ed_t p[], const bn_t k[], int n) {\n\tint i, j;\n\tint8_t *naf = NULL;\n\ted_t *_p = RLC_ALLOCA(ed_t, n);\n\tsize_t l, *_l = RLC_ALLOCA(size_t, n);\n\n\tRLC_TRY {\n\t\tl = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tl = RLC_MAX(l, bn_bits(k[i]) + 1);\n\t\t}\n\t\tnaf = RLC_ALLOCA(int8_t, n * l);\n\t\tif (naf == NULL || _p == NULL || _l == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void ext4_free_io_end(ext4_io_end_t *io)\n{\n\tBUG_ON(!io);\n\tiput(io->inode);\n\tkfree(io);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void ext4_free_io_end(ext4_io_end_t *io)\n{\n\tBUG_ON(!io);\n\tif (io->page)\n\t\tput_page(io->page);\n\tiput(io->inode);\n\tkfree(io);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tradlog_request(L_AUTH, 0, request, \"[%s]: invalid shell [%s]\",\n\t\t       name, pwd->pw_shell);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n#endif /* OSFC2 */\n\n#if defined(HAVE_GETSPNAM) && !defined(M_UNIX)\n\t/*\n\t *      Check if password has expired.\n\t */\n\tif (spwd && spwd->sp_expire > 0 &&\n\t    (request->timestamp / 86400) > spwd->sp_expire) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: password has expired\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n#if defined(__FreeBSD__) || defined(bsdi) || defined(_PWF_EXPIRE)\n\t/*\n\t *\tCheck if password has expired.\n\t */\n\tif ((pwd->pw_expire > 0) &&\n\t    (request->timestamp > pwd->pw_expire)) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t       name, pwd->pw_shell);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n#endif /* OSFC2 */\n\n#if defined(HAVE_GETSPNAM) && !defined(M_UNIX)\n\t/*\n\t *      Check if password has expired.\n\t */\n\tif (spwd && spwd->sp_lstchg > 0 && spwd->sp_max >= 0 &&\n\t    (request->timestamp / 86400) > (spwd->sp_lstchg + spwd->sp_max)) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: password has expired\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n\t/*\n\t *      Check if account has expired.\n\t */\n\tif (spwd && spwd->sp_expire > 0 &&\n\t    (request->timestamp / 86400) > spwd->sp_expire) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: account has expired\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n#if defined(__FreeBSD__) || defined(bsdi) || defined(_PWF_EXPIRE)\n\t/*\n\t *\tCheck if password has expired.\n\t */\n\tif ((pwd->pw_expire > 0) &&\n\t    (request->timestamp > pwd->pw_expire)) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    // we want to \"parse in place\" as much as possible, which allows us to\n    // forward an unmodified request without having to rebuild it.\n\n    const char *cm = command;\n    size_t cl = 0;\n    // min command length is 2, plus the \"\\r\\n\"\n    if (cmdlen < 4) {\n        return -1;\n    }\n\n    const char *s = memchr(command, ' ', cmdlen-2);\n    if (s != NULL) {\n        cl = s - command;\n    } else {\n        cl = cmdlen - 2;\n    }\n    pr->keytoken = 0;\n    pr->has_space = false;\n    pr->parsed = cl + 1;\n    pr->request = command;\n    pr->reqlen = cmdlen;\n    int token_max = PARSER_MAX_TOKENS;\n\n    int cmd = -1;\n    int type = CMD_TYPE_GENERIC;\n    int ret = 0;\n\n    switch (cl) {\n        case 0:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    // we want to \"parse in place\" as much as possible, which allows us to\n    // forward an unmodified request without having to rebuild it.\n\n    const char *cm = command;\n    size_t cl = 0;\n    // min command length is 2, plus the \"\\r\\n\"\n    if (cmdlen < 4) {\n        return -1;\n    }\n\n    // Commands can end with bare '\\n's. Depressingly I intended to be strict\n    // with a \\r\\n requirement but never did this and need backcompat.\n    // In this case we _know_ \\n is at cmdlen because we can't enter this\n    // function otherwise.\n    if (cm[cmdlen-2] == '\\r') {\n        pr->endlen = cmdlen - 2;\n    } else {\n        pr->endlen = cmdlen - 1;\n    }\n\n    const char *s = memchr(command, ' ', pr->endlen);\n    if (s != NULL) {\n        cl = s - command;\n    } else {\n        cl = pr->endlen;\n    }\n    pr->keytoken = 0;\n    pr->has_space = false;\n    pr->parsed = cl;\n    pr->request = command;\n    pr->reqlen = cmdlen;\n    int token_max = PARSER_MAX_TOKENS;\n\n    int cmd = -1;\n    int type = CMD_TYPE_GENERIC;\n    int ret = 0;\n\n    switch (cl) {\n        case 0:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ast2obj_alias(void* _o)\n{\n    alias_ty o = (alias_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    result = PyType_GenericNew(alias_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_identifier(o->name);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_identifier(o->asname);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ast2obj_alias(void* _o)\n{\n    alias_ty o = (alias_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_RETURN_NONE;\n    }\n\n    result = PyType_GenericNew(alias_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_identifier(o->name);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_identifier(o->asname);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static pj_status_t ssl_flush_wbio(dtls_srtp *ds, unsigned idx)\n{\n    pj_size_t len;\n    pj_status_t status = PJ_SUCCESS;\n\n    pj_lock_acquire(ds->ossl_lock);\n\n    if (!ds->ossl_wbio[idx]) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_EGONE;\n    }\n\n    /* Check whether there is data to send */\n    if (BIO_ctrl_pending(ds->ossl_wbio[idx]) > 0) {\n        /* Yes, get and send it */\n        len = BIO_read(ds->ossl_wbio[idx], ds->buf[idx], sizeof(ds->buf));\n        if (len > 0) {\n            pj_lock_release(ds->ossl_lock);\n\n            status = send_raw(ds, idx, ds->buf[idx], len);\n            if (status != PJ_SUCCESS) {\n#if DTLS_DEBUG\n                pj_perror(2, ds->base.name, status, \"Send error\");\n#endif\n                /* This error should be recoverable, remote will retransmit\n                 * its packet when not receiving from us.\n                 */\n            }\n            pj_lock_acquire(ds->ossl_lock);\n        }\n    }\n\n    if (!ds->ossl_ssl[idx]) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_EGONE;\n    }\n\n    /* Just return if handshake completion procedure (key parsing, fingerprint\n     * verification, etc) has been done or handshake is still in progress.\n     */\n    if (ds->nego_completed[idx] || !SSL_is_init_finished(ds->ossl_ssl[idx])) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_SUCCESS;\n    }\n\n    /* Yes, SSL handshake is done! */\n    ds->nego_completed[idx] = PJ_TRUE;\n    PJ_LOG(2,(ds->base.name, \"DTLS-SRTP negotiation for %s completed!\",\n                             CHANNEL_TO_STRING(idx)));\n\n    pj_lock_release(ds->ossl_lock);\n\n    /* Stop the retransmission clock. Note that the clock may not be stopped\n     * if this function is called from clock thread context. We'll try again\n     * later in socket context.\n     */\n    if (ds->clock[idx])\n        pjmedia_clock_stop(ds->clock[idx]);\n\n    /* Get SRTP key material */\n    status = ssl_get_srtp_material(ds, idx);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static pj_status_t ssl_flush_wbio(dtls_srtp *ds, unsigned idx)\n{\n    pj_size_t len;\n    pj_status_t status = PJ_SUCCESS;\n\n    DTLS_LOCK(ds);\n\n    if (!ds->ossl_wbio[idx]) {\n        DTLS_UNLOCK(ds);\n        return PJ_EGONE;\n    }\n\n    /* Check whether there is data to send */\n    if (BIO_ctrl_pending(ds->ossl_wbio[idx]) > 0) {\n        /* Yes, get and send it */\n        len = BIO_read(ds->ossl_wbio[idx], ds->buf[idx], sizeof(ds->buf));\n        if (len > 0) {\n            DTLS_UNLOCK(ds);\n\n            status = send_raw(ds, idx, ds->buf[idx], len);\n            if (status != PJ_SUCCESS) {\n#if DTLS_DEBUG\n                pj_perror(2, ds->base.name, status, \"Send error\");\n#endif\n                /* This error should be recoverable, remote will retransmit\n                 * its packet when not receiving from us.\n                 */\n            }\n            DTLS_LOCK(ds);\n        }\n    }\n\n    if (!ds->ossl_ssl[idx]) {\n        DTLS_UNLOCK(ds);\n        return PJ_EGONE;\n    }\n\n    /* Just return if handshake completion procedure (key parsing, fingerprint\n     * verification, etc) has been done or handshake is still in progress.\n     */\n    if (ds->nego_completed[idx] || !SSL_is_init_finished(ds->ossl_ssl[idx])) {\n        DTLS_UNLOCK(ds);\n        return PJ_SUCCESS;\n    }\n\n    /* Yes, SSL handshake is done! */\n    ds->nego_completed[idx] = PJ_TRUE;\n    PJ_LOG(2,(ds->base.name, \"DTLS-SRTP negotiation for %s completed!\",\n                             CHANNEL_TO_STRING(idx)));\n\n    DTLS_UNLOCK(ds);\n\n    /* Stop the retransmission clock. Note that the clock may not be stopped\n     * if this function is called from clock thread context. We'll try again\n     * later in socket context.\n     */\n    if (ds->clock[idx])\n        pjmedia_clock_stop(ds->clock[idx]);\n\n    /* Get SRTP key material */\n    status = ssl_get_srtp_material(ds, idx);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "header_put_be_int (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} /* header_put_be_int */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "header_put_be_int (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = x ;\n} /* header_put_be_int */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t       size_t len, int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (addr_len)\n\t\t*addr_len = sizeof(*sin);\n\n\tif (flags & MSG_ERRQUEUE) {\n\t\terr = ip_recv_error(sk, msg, len);\n\t\tgoto out;\n\t}\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tsin->sin_port = 0;\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t}\n\tif (inet->cmsg_flags)\n\t\tip_cmsg_recv(msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int raw_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\t       size_t len, int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (flags & MSG_ERRQUEUE) {\n\t\terr = ip_recv_error(sk, msg, len);\n\t\tgoto out;\n\t}\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\t\tgoto done;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t/* Copy the address. */\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tsin->sin_port = 0;\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\t}\n\tif (inet->cmsg_flags)\n\t\tip_cmsg_recv(msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tu16 offset = sizeof(struct ipv6hdr);\n\tstruct ipv6_opt_hdr *exthdr =\n\t\t\t\t(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\n\twhile (offset + 1 <= packet_len) {\n\n\t\tswitch (**nexthdr) {\n\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\n\t\toffset += ipv6_optlen(exthdr);\n\t\t*nexthdr = &exthdr->nexthdr;\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t}\n\n\treturn offset;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tu16 offset = sizeof(struct ipv6hdr);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\n\twhile (offset <= packet_len) {\n\t\tstruct ipv6_opt_hdr *exthdr;\n\n\t\tswitch (**nexthdr) {\n\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\n\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n\t\t\treturn -EINVAL;\n\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t\toffset += ipv6_optlen(exthdr);\n\t\t*nexthdr = &exthdr->nexthdr;\n\t}\n\n\treturn -EINVAL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "          << device_src.opaque() << \", size=\" << size\n          << \", host_dst=\" << host_dst << \")\" << StackTraceIfVLOG10();\n\n  tsl::Status result;\n  SCOPED_TRACE(TraceListener::SynchronousMemcpyD2H, &result, device_src, size,\n               host_dst);\n\n  result = implementation_->SynchronousMemcpy(host_dst, device_src, size);\n  if (!result.ok()) {\n    result = tsl::Status(\n        port::error::INTERNAL,\n        absl::StrFormat(\"failed to synchronously memcpy device-to-host: device \"\n                        \"%p to host %p size %d: %s\",\n                        device_src.opaque(), host_dst, size,\n                        result.ToString()));\n  }\n\n  return result;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "          << device_src.opaque() << \", size=\" << size\n          << \", host_dst=\" << host_dst << \")\" << StackTraceIfVLOG10();\n\n  tsl::Status result;\n  SCOPED_TRACE(TraceListener::SynchronousMemcpyD2H, &result, device_src, size,\n               host_dst);\n\n  result = implementation_->SynchronousMemcpy(host_dst, device_src, size);\n  if (!result.ok()) {\n    result = tsl::Status(\n        tsl::error::INTERNAL,\n        absl::StrFormat(\"failed to synchronously memcpy device-to-host: device \"\n                        \"%p to host %p size %d: %s\",\n                        device_src.opaque(), host_dst, size,\n                        result.ToString()));\n  }\n\n  return result;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void fp24_exp_dig(fp24_t c, const fp24_t a, dig_t b) {\n\tbn_t _b;\n\tfp24_t t, v;\n\tint8_t u, naf[RLC_DIG + 1];\n\tint l;\n\n\tif (b == 0) {\n\t\tfp24_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(_b);\n\tfp24_null(t);\n\tfp24_null(v);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void fp24_exp_dig(fp24_t c, const fp24_t a, dig_t b) {\n\tbn_t _b;\n\tfp24_t t, v;\n\tint8_t u, naf[RLC_DIG + 1];\n\tsize_t l;\n\n\tif (b == 0) {\n\t\tfp24_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(_b);\n\tfp24_null(t);\n\tfp24_null(v);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tint err;\n\n\terr = crypto_ahash_export(req, state);\n\tif (err)\n\t\treturn err;\n\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = 1;\n\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\n\treturn err;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tbool more;\n\tint err;\n\n\tlock_sock(sk);\n\tmore = ctx->more;\n\terr = more ? crypto_ahash_export(req, state) : 0;\n\trelease_sock(sk);\n\n\tif (err)\n\t\treturn err;\n\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = more;\n\n\tif (!more)\n\t\treturn err;\n\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\n\treturn err;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static CURLcode ossl_connect_step1(struct Curl_easy *data,\n                                   struct connectdata *conn, int sockindex)\n{\n  CURLcode result = CURLE_OK;\n  char *ciphers;\n  SSL_METHOD_QUAL SSL_METHOD *req_method = NULL;\n  X509_LOOKUP *lookup = NULL;\n  curl_socket_t sockfd = conn->sock[sockindex];\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  ctx_option_t ctx_options = 0;\n\n#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n  bool sni;\n  const char * const hostname = SSL_HOST_NAME();\n\n#ifdef ENABLE_IPV6\n  struct in6_addr addr;\n#else\n  struct in_addr addr;\n#endif\n       send the data lowercase and subsequently there are now numerous servers\n       out there that don't work unless the name is lowercased */\n    Curl_strntolower(data->state.buffer, hostname, nlen);\n    data->state.buffer[nlen] = 0;\n    if(!SSL_set_tlsext_host_name(backend->handle, data->state.buffer))\n      infof(data, \"WARNING: failed to configure server name indication (SNI) \"\n            \"TLS extension\\n\");\n  }\n#endif\n\n  /* Check if there's a cached ID we can/should use here! */\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    void *ssl_sessionid = NULL;\n    int data_idx = ossl_get_ssl_data_index();\n    int connectdata_idx = ossl_get_ssl_conn_index();\n    int sockindex_idx = ossl_get_ssl_sockindex_index();\n    int proxy_idx = ossl_get_proxy_index();\n\n    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&\n       proxy_idx >= 0) {\n      /* Store the data needed for the \"new session\" callback.\n       * The sockindex is stored as a pointer to an array element. */\n      SSL_set_ex_data(backend->handle, data_idx, data);\n      SSL_set_ex_data(backend->handle, connectdata_idx, conn);\n      SSL_set_ex_data(backend->handle, sockindex_idx, conn->sock + sockindex);\n#ifndef CURL_DISABLE_PROXY\n      SSL_set_ex_data(backend->handle, proxy_idx, SSL_IS_PROXY() ? (void *) 1:\n                      NULL);\n#else\n      SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n#endif\n\n    }\n\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn, SSL_IS_PROXY() ? TRUE : FALSE,\n                              &ssl_sessionid, NULL, sockindex)) {\n      /* we got a session id, use it! */\n      if(!SSL_set_session(backend->handle, ssl_sessionid)) {\n        Curl_ssl_sessionid_unlock(data);\n        failf(data, \"SSL: SSL_set_session failed: %s\",\n              ossl_strerror(ERR_get_error(), error_buffer,\n                            sizeof(error_buffer)));\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      /* Informational message */\n      infof(data, \"SSL re-using session ID\\n\");\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n#ifndef CURL_DISABLE_PROXY\n  if(conn->proxy_ssl[sockindex].use) {\n    BIO *const bio = BIO_new(BIO_f_ssl());\n    SSL *handle = conn->proxy_ssl[sockindex].backend->handle;\n    DEBUGASSERT(ssl_connection_complete == conn->proxy_ssl[sockindex].state);\n    DEBUGASSERT(handle != NULL);\n    DEBUGASSERT(bio != NULL);\n    BIO_set_ssl(bio, handle, FALSE);\n    SSL_set_bio(backend->handle, bio, bio);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static CURLcode ossl_connect_step1(struct Curl_easy *data,\n                                   struct connectdata *conn, int sockindex)\n{\n  CURLcode result = CURLE_OK;\n  char *ciphers;\n  SSL_METHOD_QUAL SSL_METHOD *req_method = NULL;\n  X509_LOOKUP *lookup = NULL;\n  curl_socket_t sockfd = conn->sock[sockindex];\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  ctx_option_t ctx_options = 0;\n  void *ssl_sessionid = NULL;\n\n#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n  bool sni;\n  const char * const hostname = SSL_HOST_NAME();\n\n#ifdef ENABLE_IPV6\n  struct in6_addr addr;\n#else\n  struct in_addr addr;\n#endif\n       send the data lowercase and subsequently there are now numerous servers\n       out there that don't work unless the name is lowercased */\n    Curl_strntolower(data->state.buffer, hostname, nlen);\n    data->state.buffer[nlen] = 0;\n    if(!SSL_set_tlsext_host_name(backend->handle, data->state.buffer))\n      infof(data, \"WARNING: failed to configure server name indication (SNI) \"\n            \"TLS extension\\n\");\n  }\n#endif\n\n  ossl_associate_connection(data, conn, sockindex);\n\n  Curl_ssl_sessionid_lock(data);\n  if(!Curl_ssl_getsessionid(data, conn, SSL_IS_PROXY() ? TRUE : FALSE,\n                            &ssl_sessionid, NULL, sockindex)) {\n    /* we got a session id, use it! */\n    if(!SSL_set_session(backend->handle, ssl_sessionid)) {\n      Curl_ssl_sessionid_unlock(data);\n      failf(data, \"SSL: SSL_set_session failed: %s\",\n            ossl_strerror(ERR_get_error(), error_buffer,\n                          sizeof(error_buffer)));\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    /* Informational message */\n    infof(data, \"SSL re-using session ID\\n\");\n  }\n  Curl_ssl_sessionid_unlock(data);\n\n#ifndef CURL_DISABLE_PROXY\n  if(conn->proxy_ssl[sockindex].use) {\n    BIO *const bio = BIO_new(BIO_f_ssl());\n    SSL *handle = conn->proxy_ssl[sockindex].backend->handle;\n    DEBUGASSERT(ssl_connection_complete == conn->proxy_ssl[sockindex].state);\n    DEBUGASSERT(handle != NULL);\n    DEBUGASSERT(bio != NULL);\n    BIO_set_ssl(bio, handle, FALSE);\n    SSL_set_bio(backend->handle, bio, bio);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "R_API bool r_socket_connect(RSocket *s, const char *host, const char *port, int proto, unsigned int timeout) {\n\tr_return_val_if_fail (s, false);\n#if __WINDOWS__\n\tstruct sockaddr_in sa;\n\tstruct hostent *he;\n\tWSADATA wsadata;\n\tTIMEVAL Timeout;\n\tTimeout.tv_sec = timeout;\n\tTimeout.tv_usec = 0;\n\n\tif (WSAStartup (MAKEWORD (1, 1), &wsadata) == SOCKET_ERROR) {\n\t\teprintf (\"Error creating socket.\");\n\t\treturn false;\n\t}\n\ts->fd = socket (AF_INET, SOCK_STREAM, 0);\n\tif (s->fd == R_INVALID_SOCKET) {\n\t\treturn false;\n\t}\n\n\tunsigned long iMode = 1;\n\tint iResult = ioctlsocket (s->fd, FIONBIO, &iMode);\n\tif (iResult != NO_ERROR) {\n\t\teprintf (\"ioctlsocket error: %d\\n\", iResult);\n\t}\n\tmemset (&sa, 0, sizeof (sa));\n\tsa.sin_family = AF_INET;\n\the = (struct hostent *)gethostbyname (host);\n\tif (he == (struct hostent*)0) {\n#ifdef _MSC_VER\n\t\tclosesocket (s->fd);\n#else\n\t\tclose (s->fd);\n#endif\n\t\treturn false;\n\t}\n\tsa.sin_addr = *((struct in_addr *)he->h_addr);\n\ts->port = r_socket_port_by_name (port);\n\ts->proto = proto;\n\tsa.sin_port = htons (s->port);\n\tif (!connect (s->fd, (const struct sockaddr*)&sa, sizeof (struct sockaddr))) {\n#ifdef _MSC_VER\n\t\tclosesocket (s->fd);\n#else\n\t\tclose (s->fd);\n#endif\n\t\treturn false;\n\t}\n\tiMode = 0;\n\tiResult = ioctlsocket (s->fd, FIONBIO, &iMode);\n\tif (iResult != NO_ERROR) {\n\t\teprintf (\"ioctlsocket error: %d\\n\", iResult);\n\t}\n\tif (timeout > 0) {\n\t\tr_socket_block_time (s, 1, timeout, 0);\n\t}\n\tfd_set Write, Err;\n\tFD_ZERO (&Write);\n\tFD_ZERO (&Err);\n\tFD_SET (s->fd, &Write);\n\tFD_SET (s->fd, &Err);\n\tselect (0, NULL, &Write, &Err, &Timeout);\n\tif (FD_ISSET (s->fd, &Write)) {\n\t\treturn true;\n\t}\n\treturn false;\n#elif __UNIX__\n\tint ret;\n\tstruct addrinfo hints = {0};\n\tstruct addrinfo *res, *rp;\n\tif (!proto) {\n\t\tproto = R_SOCKET_PROTO_TCP;\n\t}\n\tr_sys_signal (SIGPIPE, SIG_IGN);\n\tif (proto == R_SOCKET_PROTO_UNIX) {\n\t\tif (!__connect_unix (s, host)) {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\thints.ai_family = AF_UNSPEC; /* Allow IPv4 or IPv6 */\n\t\thints.ai_protocol = proto;\n\t\tint gai = getaddrinfo (host, port, &hints, &res);\n\t\tif (gai != 0) {\n\t\t\teprintf (\"r_socket_connect: Error in getaddrinfo: %s (%s:%s)\\n\",\n\t\t\t\tgai_strerror (gai), host, port);\n\t\t\treturn false;\n\t\t}\n\t\tfor (rp = res; rp != NULL; rp = rp->ai_next) {\n\t\t\t}\n\n\t\t\tr_socket_block_time (s, 0, 0, 0);\n\t\t\tret = connect (s->fd, rp->ai_addr, rp->ai_addrlen);\n\n\t\t\tif (ret == 0) {\n\t\t\t\tfreeaddrinfo (res);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (errno == EINPROGRESS) {\n\t\t\t\tstruct timeval tv;\n\t\t\t\ttv.tv_sec = timeout;\n\t\t\t\ttv.tv_usec = 0;\n\t\t\t\tfd_set wfds;\n\t\t\t\tFD_ZERO(&wfds);\n\t\t\t\tFD_SET(s->fd, &wfds);\n\n\t\t\t\tif ((ret = select (s->fd + 1, NULL, &wfds, NULL, &tv)) != -1) {\n\t\t\t\t\tif (r_socket_is_connected (s)) {\n\t\t\t\t\t\tfreeaddrinfo (res);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tperror (\"connect\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_socket_close (s);\n\t\t}\n\t\tfreeaddrinfo (res);\n\t\tif (!rp) {\n\t\t\teprintf (\"Could not resolve address '%s' or failed to connect\\n\", host);\n\t\t\treturn false;\n\t\t}\n\t}\n#endif\n#if HAVE_LIB_SSL\n\tif (s->is_ssl) {\n\t\ts->ctx = SSL_CTX_new (SSLv23_client_method ());\n\t\tif (!s->ctx) {\n\t\t\tr_socket_free (s);\n\t\t\treturn false;\n\t\t}\n\t\ts->sfd = SSL_new (s->ctx);\n\t\tSSL_set_fd (s->sfd, s->fd);\n\t\tif (SSL_connect (s->sfd) != 1) {\n\t\t\tr_socket_free (s);\n\t\t\treturn false;\n\t\t}\n\t}\n#endif\n\treturn true;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "R_API bool r_socket_connect(RSocket *s, const char *host, const char *port, int proto, unsigned int timeout) {\n\tr_return_val_if_fail (s, false);\n#if __WINDOWS__\n#define gai_strerror gai_strerrorA\n\tstruct sockaddr_in sa;\n\tWSADATA wsadata;\n\n\tif (WSAStartup (MAKEWORD (1, 1), &wsadata) == SOCKET_ERROR) {\n\t\teprintf (\"Error creating socket.\");\n\t\treturn false;\n\t}\n#endif\n\tint ret;\n\tstruct addrinfo hints = { 0 };\n\tstruct addrinfo *res, *rp;\n\tif (!proto) {\n\t\tproto = R_SOCKET_PROTO_TCP;\n\t}\n#if __UNIX__\n\tr_sys_signal (SIGPIPE, SIG_IGN);\n#endif\n\tif (proto == R_SOCKET_PROTO_UNIX) {\n#if __UNIX__\n\t\tif (!__connect_unix (s, host)) {\n\t\t\treturn false;\n\t\t}\n#endif\n\t} else {\n\t\thints.ai_family = AF_UNSPEC; /* Allow IPv4 or IPv6 */\n\t\thints.ai_protocol = proto;\n\t\tint gai = getaddrinfo (host, port, &hints, &res);\n\t\tif (gai != 0) {\n\t\t\teprintf (\"r_socket_connect: Error in getaddrinfo: %s (%s:%s)\\n\",\n\t\t\t\tgai_strerror (gai), host, port);\n\t\t\treturn false;\n\t\t}\n\t\tfor (rp = res; rp != NULL; rp = rp->ai_next) {\n\t\t\t}\n\n\t\t\tr_socket_block_time (s, 0, 0, 0);\n\t\t\tret = connect (s->fd, rp->ai_addr, rp->ai_addrlen);\n\n\t\t\tif (ret == 0) {\n\t\t\t\tfreeaddrinfo (res);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (errno == EINPROGRESS) {\n\t\t\t\tstruct timeval tv = {timeout, 0};\n\t\t\t\tfd_set wfds;\n\t\t\t\tFD_ZERO (&wfds);\n\t\t\t\tFD_SET (s->fd, &wfds);\n\n\t\t\t\tif ((ret = select (s->fd + 1, NULL, &wfds, NULL, &tv)) != -1) {\n\t\t\t\t\tif (r_socket_is_connected (s)) {\n\t\t\t\t\t\tfreeaddrinfo (res);\n\t\t\t\t\t\tgoto success;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tperror (\"connect\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_socket_close (s);\n\t\t}\n\t\tfreeaddrinfo (res);\n\t\tif (!rp) {\n\t\t\teprintf (\"Could not resolve address '%s' or failed to connect\\n\", host);\n\t\t\treturn false;\n\t\t}\n\t}\nsuccess:\n#if HAVE_LIB_SSL\n\tif (s->is_ssl) {\n\t\ts->ctx = SSL_CTX_new (SSLv23_client_method ());\n\t\tif (!s->ctx) {\n\t\t\tr_socket_close (s);\n\t\t\treturn false;\n\t\t}\n\t\ts->sfd = SSL_new (s->ctx);\n\t\tSSL_set_fd (s->sfd, s->fd);\n\t\tint ret = SSL_connect (s->sfd);\n\t\tif (ret != 1) {\n\t\t\tint error = SSL_get_error (s->sfd, ret);\n\t\t\tint tries = 10;\n\t\t\twhile (tries && ret && (error == SSL_ERROR_WANT_READ || error == SSL_ERROR_WANT_WRITE)) {\n\t\t\t\tstruct timeval tv = {1, 0};\n\t\t\t\tfd_set rfds, wfds;\n\t\t\t\tFD_ZERO (&rfds);\n\t\t\t\tFD_ZERO (&wfds);\n\t\t\t\tif (error == SSL_ERROR_WANT_READ) {\n\t\t\t\t\tFD_SET (s->fd, &rfds);\n\t\t\t\t} else {\n\t\t\t\t\tFD_SET (s->fd, &wfds);\n\t\t\t\t}\n\t\t\t\tif ((ret = select (s->fd + 1, &rfds, &wfds, NULL, &tv)) < 1) {\n\t\t\t\t\tr_socket_close (s);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tret = SSL_connect (s->sfd);\n\t\t\t\tif (ret == 1) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\terror = SSL_get_error (s->sfd, ret);\n\t\t\t\ttries--;\n\t\t\t}\n\t\t\tr_socket_close (s);\n\t\t\treturn false;\n\t\t}\n\t}\n#endif\n\treturn true;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t&& check_changed(curbuf, (p_awa ? CCGD_AW : 0)\n\t\t\t       | (other_file ? 0 : CCGD_MULTWIN)\n\t\t\t       | ((flags & ECMD_FORCEIT) ? CCGD_FORCEIT : 0)\n\t\t\t       | (eap == NULL ? 0 : CCGD_EXCMD)))\n    {\n\tif (fnum == 0 && other_file && ffname != NULL)\n\t    (void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);\n\tgoto theend;\n    }\n\n    /*\n     * End Visual mode before switching to another buffer, so the text can be\n     * copied into the GUI selection buffer.\n     */\n    reset_VIsual();\n\n#if defined(FEAT_EVAL)\n    if ((command != NULL || newlnum > (linenr_T)0)\n\t    && *get_vim_var_str(VV_SWAPCOMMAND) == NUL)\n    {\n\tint\tlen;\n\tchar_u\t*p;\n\n\t// Set v:swapcommand for the SwapExists autocommands.\n\tif (command != NULL)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t&& check_changed(curbuf, (p_awa ? CCGD_AW : 0)\n\t\t\t       | (other_file ? 0 : CCGD_MULTWIN)\n\t\t\t       | ((flags & ECMD_FORCEIT) ? CCGD_FORCEIT : 0)\n\t\t\t       | (eap == NULL ? 0 : CCGD_EXCMD)))\n    {\n\tif (fnum == 0 && other_file && ffname != NULL)\n\t    (void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);\n\tgoto theend;\n    }\n\n    \n     // End Visual mode before switching to another buffer, so the text can be\n     // copied into the GUI selection buffer.\n     // Careful: may trigger ModeChanged() autocommand\n     \n    // Should we block autocommands here?\n    reset_VIsual();\n\n    // autocommands freed window :(\n    if (oldwin != NULL && !win_valid(oldwin))\n\toldwin = NULL;\n\n#if defined(FEAT_EVAL)\n    if ((command != NULL || newlnum > (linenr_T)0)\n\t    && *get_vim_var_str(VV_SWAPCOMMAND) == NUL)\n    {\n\tint\tlen;\n\tchar_u\t*p;\n\n\t// Set v:swapcommand for the SwapExists autocommands.\n\tif (command != NULL)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "raptor_libxml_getEntity(void* user_data, const xmlChar *name) {\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_getEntity(sax2->xc, name);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "raptor_libxml_getEntity(void* user_data, const xmlChar *name)\n{\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  xmlParserCtxtPtr xc = sax2->xc;\n  xmlEntityPtr ret = NULL;\n\n  if(!xc)\n    return NULL;\n\n  if(!xc->inSubset) {\n    /* looks for hardcoded set of entity names - lt, gt etc. */\n    ret = xmlGetPredefinedEntity(name);\n    if(ret) {\n      RAPTOR_DEBUG2(\"Entity '%s' found in predefined set\\n\", name);\n      return ret;\n    }\n  }\n\n  /* This section uses xmlGetDocEntity which looks for entities in\n   * memory only, never from a file or URI \n   */\n  if(xc->myDoc && (xc->myDoc->standalone == 1)) {\n    RAPTOR_DEBUG2(\"Entity '%s' document is standalone\\n\", name);\n    /* Document is standalone: no entities are required to interpret doc */\n    if(xc->inSubset == 2) {\n      xc->myDoc->standalone = 0;\n      ret = xmlGetDocEntity(xc->myDoc, name);\n      xc->myDoc->standalone = 1;\n    } else {\n      ret = xmlGetDocEntity(xc->myDoc, name);\n      if(!ret) {\n        xc->myDoc->standalone = 0;\n        ret = xmlGetDocEntity(xc->myDoc, name);\n        xc->myDoc->standalone = 1;\n      }\n    }\n  } else {\n    ret = xmlGetDocEntity(xc->myDoc, name);\n  }\n\n  if(ret && !ret->children &&\n    (ret->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {\n    /* Entity is an external general parsed entity. It may be in a\n     * catalog file, user file or user URI\n     */\n    int val = 0;\n    xmlNodePtr children;\n    int load_entity = 0;\n\n    load_entity = RAPTOR_OPTIONS_GET_NUMERIC(sax2, RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES);\n    if(load_entity)\n      load_entity = raptor_sax2_check_load_uri_string(sax2, ret->URI);\n\n    if(!load_entity) {\n      RAPTOR_DEBUG2(\"Not getting entity URI %s by policy\\n\", ret->URI);\n      children = xmlNewText((const xmlChar*)\"\");\n    } else {\n      /* Disable SAX2 handlers so that the SAX2 events do not all get\n       * sent to callbacks during dealing with the entity parsing.\n       */\n      sax2->enabled = 0;\n      val = xmlParseCtxtExternalEntity(xc, ret->URI, ret->ExternalID, &children);\n      sax2->enabled = 1;\n    }\n    \n    if(!val) {\n      xmlAddChildList((xmlNodePtr)ret, children);\n    } else {\n      xc->validate = 0;\n      return NULL;\n    }\n    \n    ret->owner = 1;\n\n    /* Mark this entity as having been checked - never do this again */\n    if(!ret->checked)\n      ret->checked = 1;\n  }\n\n  return ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void svhandler_flash_pgm_word(void) {\n  uint32_t dst = _param_1;\n  uint32_t src = _param_2;\n\n  // Do not allow firmware to erase bootstrap or bootloader sectors.\n  if ((dst >= BSTRP_FLASH_SECT_START) &&\n      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {\n    return;\n  }\n\n  if ((dst >= BLDR_FLASH_SECT_START) &&\n      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {\n    return;\n  }\n\n  // Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n\n  // Flash write.\n  flash_program_word(dst, src);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void svhandler_flash_pgm_word(void) {\n  uint32_t dst = _param_1;\n  uint32_t src = _param_2;\n\n  // Verify requested address range is allowed.\n  if (!allow_svhandler_flash_range(dst, dst + sizeof(uint32_t))) return;\n\n  // Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n\n  // Flash write.\n  flash_program_word(dst, src);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                }\n        }\n    for(int i=0; i< S.height*S.width; i++)\n        {\n            imgdata.image[i][0] = lut[imgdata.image[i][0]];\n            imgdata.image[i][1] = lut[imgdata.image[i][1]];\n            imgdata.image[i][2] = lut[imgdata.image[i][2]];\n            imgdata.image[i][3] = lut[imgdata.image[i][3]];\n        }\n\n    C.data_maximum = lut[C.data_maximum];\n    C.maximum = lut[C.maximum];\n    // no need to adjust the minumum, black is already subtracted\n    free(lut);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                }\n        }\n    for(int i=0; i< S.height*S.width; i++)\n        {\n            imgdata.image[i][0] = lut[imgdata.image[i][0]];\n            imgdata.image[i][1] = lut[imgdata.image[i][1]];\n            imgdata.image[i][2] = lut[imgdata.image[i][2]];\n            imgdata.image[i][3] = lut[imgdata.image[i][3]];\n        }\n\n\tif(C.data_maximum <=TBLN)\n\t\tC.data_maximum = lut[C.data_maximum];\n\tif(C.maximum <= TBLN)\n\t\tC.maximum = lut[C.maximum];\n    // no need to adjust the minumum, black is already subtracted\n    free(lut);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ext4_xattr_block_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_entry *entry;\n\tsize_t size;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\n\terror = -ENODATA;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ext4_xattr_block_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_entry *entry;\n\tsize_t size;\n\tint error;\n\tstruct mb2_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\n\terror = -ENODATA;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\t\ti += 8;\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char *)hdrl_data+i,\"strf\",4)==0)\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n\t\t\t\t\tif(lasttag == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\talBITMAPINFOHEADER bih;\n\n\t\t\t\t\t\tmemcpy(&bih, hdrl_data + i, sizeof(alBITMAPINFOHEADER));\n\t\t\t\t\t\tAVI->bitmap_info_header = (alBITMAPINFOHEADER *)\n\t\t\t\t\t\t                          gf_malloc(str2ulong((unsigned char *)&bih.bi_size));\n\t\t\t\t\t\tif (AVI->bitmap_info_header != NULL)\n\t\t\t\t\t\t\tmemcpy(AVI->bitmap_info_header, hdrl_data + i,\n\t\t\t\t\t\t\t       str2ulong((unsigned char *)&bih.bi_size));\n\n\t\t\t\t\t\tAVI->width  = str2ulong(hdrl_data+i+4);\n\t\t\t\t\t\tAVI->height = str2ulong(hdrl_data+i+8);\n\t\t\t\t\t\tvids_strf_seen = 1;\n\t\t\t\t\t\t//ThOe\n\t\t\t\t\t\tAVI->v_codecf_off = header_offset + i+16;\n\n\t\t\t\t\t\tmemcpy(AVI->compressor2, hdrl_data+i+16, 4);\n\t\t\t\t\t\tAVI->compressor2[4] = 0;\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_bits  = str2ushort(hdrl_data+i+14);\n\t\t\t\t\t\t//            auds_strf_seen = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char*)hdrl_data+i,\"indx\",4) == 0) {\n\t\t\t\t\tchar *a;\n\n\t\t\t\t\tif(lasttag == 1) // V I D E O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*)hdrl_data+i;\n\n\t\t\t\t\t\tAVI->video_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemset(AVI->video_superindex, 0, sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->dwSize = str2ulong((unsigned char *)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->wLongsPerEntry = str2ushort((unsigned char *)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->video_superindex->bIndexSubType = *a;\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->dwChunkId, a, 4);\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t// 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->video_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->video_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t                                gf_malloc (AVI->video_superindex->wLongsPerEntry * AVI->video_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->video_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] dwChunkId \\\"%c%c%c%c\\\"\\n\", AVI->video_superindex->dwChunkId[0], AVI->video_superindex->dwChunkId[1],\n\t\t\t\t\t\t                                        AVI->video_superindex->dwChunkId[2], AVI->video_superindex->dwChunkId[3]));\n#endif\n\n\t\t\t\t\t\tAVI->is_opendml = 1;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2) // A U D I O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*) hdrl_data+i;\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->dwSize = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->wLongsPerEntry = str2ushort((unsigned char*)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->dwChunkId, a, 4);\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t// 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->track[AVI->aptr].audio_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t        gf_malloc (AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry *\n\t\t\t\t\t\t                   AVI->track[AVI->aptr].audio_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->track[AVI->aptr].audio_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\t\ti += 8;\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char *)hdrl_data+i,\"strf\",4)==0)\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n\t\t\t\t\tif(lasttag == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\talBITMAPINFOHEADER bih;\n\n\t\t\t\t\t\tmemcpy(&bih, hdrl_data + i, sizeof(alBITMAPINFOHEADER));\n\t\t\t\t\t\tbih.bi_size = str2ulong((unsigned char *)&bih.bi_size);\n\n\t\t\t\t\t\tif (i + bih.bi_size > hdrl_len) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->bitmap_info_header = (alBITMAPINFOHEADER *) gf_malloc(bih.bi_size);\n\t\t\t\t\t\tif (AVI->bitmap_info_header != NULL)\n\t\t\t\t\t\t\tmemcpy(AVI->bitmap_info_header, hdrl_data + i, bih.bi_size);\n\n\t\t\t\t\t\tAVI->width  = str2ulong(hdrl_data+i+4);\n\t\t\t\t\t\tAVI->height = str2ulong(hdrl_data+i+8);\n\t\t\t\t\t\tvids_strf_seen = 1;\n\t\t\t\t\t\t//ThOe\n\t\t\t\t\t\tAVI->v_codecf_off = header_offset + i+16;\n\n\t\t\t\t\t\tmemcpy(AVI->compressor2, hdrl_data+i+16, 4);\n\t\t\t\t\t\tAVI->compressor2[4] = 0;\n\n\t\t\t\t\t\t//            auds_strf_seen = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char*)hdrl_data+i,\"indx\",4) == 0) {\n\t\t\t\t\tchar *a;\n\n\t\t\t\t\tif(lasttag == 1) // V I D E O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*)hdrl_data+i;\n\t\t\t\t\t\tint avail = hdrl_len-i;\n\t\t\t\t\t\tif (avail<32) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->video_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemset(AVI->video_superindex, 0, sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->dwSize = str2ulong((unsigned char *)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->wLongsPerEntry = str2ushort((unsigned char *)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->video_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t// 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->video_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tavail -= 32;\n\t\t\t\t\t\tif (avail < AVI->video_superindex->nEntriesInUse*16) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->video_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t                                gf_malloc (AVI->video_superindex->wLongsPerEntry * AVI->video_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->video_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\t                                        AVI->video_superindex->dwChunkId[2], AVI->video_superindex->dwChunkId[3]));\n#endif\n\n\t\t\t\t\t\tAVI->is_opendml = 1;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2) // A U D I O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*) hdrl_data+i;\n\t\t\t\t\t\tint avail = hdrl_len-i;\n\t\t\t\t\t\tif (avail<32) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->dwSize = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->wLongsPerEntry = str2ushort((unsigned char*)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t// 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->track[AVI->aptr].audio_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tavail -= 32;\n\t\t\t\t\t\tif (avail < AVI->track[AVI->aptr].audio_superindex->nEntriesInUse*16) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t        gf_malloc (AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry *\n\t\t\t\t\t\t                   AVI->track[AVI->aptr].audio_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->track[AVI->aptr].audio_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void binder_deferred_fd_close(int fd)\n{\n\tstruct binder_task_work_cb *twcb;\n\n\ttwcb = kzalloc(sizeof(*twcb), GFP_KERNEL);\n\tif (!twcb)\n\t\treturn;\n\tinit_task_work(&twcb->twork, binder_do_fd_close);\n\t__close_fd_get_file(fd, &twcb->file);\n\tif (twcb->file)\n\t\ttask_work_add(current, &twcb->twork, TWA_RESUME);\n\telse\n\t\tkfree(twcb);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void binder_deferred_fd_close(int fd)\n{\n\tstruct binder_task_work_cb *twcb;\n\n\ttwcb = kzalloc(sizeof(*twcb), GFP_KERNEL);\n\tif (!twcb)\n\t\treturn;\n\tinit_task_work(&twcb->twork, binder_do_fd_close);\n\t__close_fd_get_file(fd, &twcb->file);\n\tif (twcb->file) {\n\t\tfilp_close(twcb->file, current->files);\n\t\ttask_work_add(current, &twcb->twork, TWA_RESUME);\n\t} else {\n\t\tkfree(twcb);\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const auto* params = reinterpret_cast<TfLiteBidirectionalSequenceRNNParams*>(\n      node->builtin_data);\n\n  // Check we have all the inputs and outputs we need.\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 12);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size,\n                    params->merge_outputs ? 1 : 2);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* fw_input_weights =\n      GetInput(context, node, kFwWeightsTensor);\n  const TfLiteTensor* fw_recurrent_weights =\n      GetInput(context, node, kFwRecurrentWeightsTensor);\n  const TfLiteTensor* fw_bias = GetInput(context, node, kFwBiasTensor);\n  const TfLiteTensor* fw_hidden_state =\n      GetInput(context, node, kFwHiddenStateTensor);\n  const TfLiteTensor* bw_input_weights =\n      GetInput(context, node, kBwWeightsTensor);\n  const TfLiteTensor* bw_recurrent_weights =\n      GetInput(context, node, kBwRecurrentWeightsTensor);\n  const TfLiteTensor* bw_bias = GetInput(context, node, kBwBiasTensor);\n  const TfLiteTensor* bw_hidden_state =\n      GetInput(context, node, kBwHiddenStateTensor);\n\n  const TfLiteTensor* aux_input =\n      GetOptionalInputTensor(context, node, kAuxInputTensor);\n  const TfLiteTensor* fw_aux_input_weights =\n      GetOptionalInputTensor(context, node, kFwAuxWeightsTensor);\n  const TfLiteTensor* bw_aux_input_weights =\n      GetOptionalInputTensor(context, node, kBwAuxWeightsTensor);\n\n  const bool aux_inputs_weights_or_none =\n      ((fw_aux_input_weights != nullptr) &&\n    TfLiteIntArrayFree(node->temporaries);\n    if (has_aux_input) {\n      node->temporaries = TfLiteIntArrayCreate(kNumTemporaryTensors);\n    } else {\n      // No need to create a temporary tensor for the non-existent aux_input.\n      node->temporaries = TfLiteIntArrayCreate(kNumTemporaryTensors - 1);\n    }\n\n    node->temporaries->data[kInputQuantized] =\n        op_data->scratch_tensor_index + kInputQuantized;\n    TfLiteTensor* input_quantized =\n        GetTemporary(context, node, kInputQuantized);\n    input_quantized->type = fw_input_weights->type;\n    input_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {\n      TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                       input_quantized_size));\n    }\n\n    node->temporaries->data[kFwHiddenStateQuantized] =\n        op_data->scratch_tensor_index + kFwHiddenStateQuantized;\n    TfLiteTensor* fw_hidden_state_quantized =\n        GetTemporary(context, node, kFwHiddenStateQuantized);\n    fw_hidden_state_quantized->type = fw_input_weights->type;\n    fw_hidden_state_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(fw_hidden_state_quantized->dims,\n                             fw_hidden_state->dims)) {\n      TfLiteIntArray* fw_hidden_state_quantized_size =\n          TfLiteIntArrayCopy(fw_hidden_state->dims);\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, fw_hidden_state_quantized,\n                                         fw_hidden_state_quantized_size));\n    }\n\n    node->temporaries->data[kBwHiddenStateQuantized] =\n        op_data->scratch_tensor_index + kBwHiddenStateQuantized;\n    TfLiteTensor* bw_hidden_state_quantized =\n        GetTemporary(context, node, kBwHiddenStateQuantized);\n    bw_hidden_state_quantized->type = fw_input_weights->type;\n    bw_hidden_state_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(bw_hidden_state_quantized->dims,\n                             bw_hidden_state->dims)) {\n      TfLiteIntArray* bw_hidden_state_quantized_size =\n          TfLiteIntArrayCopy(bw_hidden_state->dims);\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, bw_hidden_state_quantized,\n                                         bw_hidden_state_quantized_size));\n    }\n\n    // Allocate temporary tensors to store scaling factors of quantization.\n    node->temporaries->data[kScalingFactors] =\n        op_data->scratch_tensor_index + kScalingFactors;\n    TfLiteTensor* scaling_factors =\n        GetTemporary(context, node, kScalingFactors);\n    scaling_factors->type = kTfLiteFloat32;\n    scaling_factors->allocation_type = kTfLiteArenaRw;\n    int scaling_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {\n      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);\n      scaling_factors_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,\n                                                       scaling_factors_size));\n    }\n    node->temporaries->data[kAccumScratch] =\n        op_data->scratch_tensor_index + kAccumScratch;\n    TfLiteTensor* accum_scratch = GetTemporary(context, node, kAccumScratch);\n    accum_scratch->type = kTfLiteInt32;\n    accum_scratch->allocation_type = kTfLiteArenaRw;\n    int accum_scratch_dims[2] = {std::max(fw_num_units, bw_num_units),\n                                 batch_size};\n    if (!TfLiteIntArrayEqualsArray(accum_scratch->dims, 2,\n                                   accum_scratch_dims)) {\n      TfLiteIntArray* accum_scratch_size = TfLiteIntArrayCreate(2);\n      accum_scratch_size->data[0] = accum_scratch_dims[0];\n      accum_scratch_size->data[1] = accum_scratch_dims[1];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, accum_scratch,\n                                                       accum_scratch_size));\n    }\n    node->temporaries->data[kZeroPoints] =\n        op_data->scratch_tensor_index + kZeroPoints;\n    TfLiteTensor* zero_points =\n        GetTemporary(context, node, /*index=*/kZeroPoints);\n    zero_points->type = kTfLiteInt32;\n    zero_points->allocation_type = kTfLiteArenaRw;\n    int zero_points_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(zero_points->dims, 1, zero_points_dims)) {\n      TfLiteIntArray* zero_points_size = TfLiteIntArrayCreate(1);\n      zero_points_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, zero_points,\n                                                       zero_points_size));\n    }\n    const int num_row_sums = has_aux_input ? 3 : 2;\n    node->temporaries->data[kFwRowSums] =\n        op_data->scratch_tensor_index + kFwRowSums;\n    TfLiteTensor* fw_row_sums =\n        GetTemporary(context, node, /*index=*/kFwRowSums);\n    fw_row_sums->type = kTfLiteInt32;\n    fw_row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int fw_row_sums_dims[2] = {num_row_sums, fw_num_units};\n    if (!TfLiteIntArrayEqualsArray(fw_row_sums->dims, 2, fw_row_sums_dims)) {\n      TfLiteIntArray* fw_row_sums_size = TfLiteIntArrayCreate(2);\n      fw_row_sums_size->data[0] = fw_row_sums_dims[0];\n      fw_row_sums_size->data[1] = fw_row_sums_dims[1];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, fw_row_sums,\n                                                       fw_row_sums_size));\n    }\n    node->temporaries->data[kBwRowSums] =\n        op_data->scratch_tensor_index + kBwRowSums;\n    TfLiteTensor* bw_row_sums = GetTemporary(context, node,\n                                             /*index=*/kBwRowSums);\n    bw_row_sums->type = kTfLiteInt32;\n    bw_row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int bw_row_sums_dims[2] = {num_row_sums, bw_num_units};\n    if (!TfLiteIntArrayEqualsArray(bw_row_sums->dims, 2, bw_row_sums_dims)) {\n      TfLiteIntArray* bw_row_sums_size = TfLiteIntArrayCreate(2);\n      bw_row_sums_size->data[0] = bw_row_sums_dims[0];\n      bw_row_sums_size->data[1] = bw_row_sums_dims[1];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, bw_row_sums,\n                                                       bw_row_sums_size));\n    }\n    if (has_aux_input) {\n      node->temporaries->data[kAuxInputQuantized] =\n          op_data->scratch_tensor_index + kAuxInputQuantized;\n      TfLiteTensor* aux_input_quantized =\n          GetTemporary(context, node, kAuxInputQuantized);\n      aux_input_quantized->type = fw_input_weights->type;\n      aux_input_quantized->allocation_type = kTfLiteArenaRw;\n      if (!TfLiteIntArrayEqual(aux_input_quantized->dims, aux_input->dims)) {\n        TfLiteIntArray* aux_input_quantized_size =\n            TfLiteIntArrayCopy(aux_input->dims);\n        TF_LITE_ENSURE_OK(context,\n                          context->ResizeTensor(context, aux_input_quantized,\n                                                aux_input_quantized_size));\n      }\n    }\n  }\n\n  // Resize outputs.\n  TfLiteTensor* fw_output = GetOutput(context, node, kFwOutputTensor);\n  TfLiteIntArray* fw_output_size_array = TfLiteIntArrayCreate(3);\n  fw_output_size_array->data[0] = (time_major) ? max_time : batch_size;\n  fw_output_size_array->data[1] = (time_major) ? batch_size : max_time;\n  fw_output_size_array->data[2] =\n      params->merge_outputs ? fw_num_units + bw_num_units : fw_num_units;\n  TF_LITE_ENSURE_OK(\n      context, context->ResizeTensor(context, fw_output, fw_output_size_array));\n  if (!params->merge_outputs) {\n    TfLiteTensor* bw_output = GetOutput(context, node, kBwOutputTensor);\n    TfLiteIntArray* bw_output_size_array = TfLiteIntArrayCreate(3);\n    bw_output_size_array->data[0] = batch_size;\n    bw_output_size_array->data[1] = max_time;\n    bw_output_size_array->data[2] = bw_num_units;\n    TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, bw_output,\n                                                     bw_output_size_array));\n  }\n\n  return kTfLiteOk;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const auto* params = reinterpret_cast<TfLiteBidirectionalSequenceRNNParams*>(\n      node->builtin_data);\n\n  // Check we have all the inputs and outputs we need.\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 12);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size,\n                    params->merge_outputs ? 1 : 2);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  const TfLiteTensor* fw_input_weights;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kFwWeightsTensor,\n                                          &fw_input_weights));\n  const TfLiteTensor* fw_recurrent_weights;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kFwRecurrentWeightsTensor,\n                                 &fw_recurrent_weights));\n  const TfLiteTensor* fw_bias;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kFwBiasTensor, &fw_bias));\n  const TfLiteTensor* fw_hidden_state;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kFwHiddenStateTensor,\n                                          &fw_hidden_state));\n  const TfLiteTensor* bw_input_weights;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kBwWeightsTensor,\n                                          &bw_input_weights));\n  const TfLiteTensor* bw_recurrent_weights;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kBwRecurrentWeightsTensor,\n                                 &bw_recurrent_weights));\n  const TfLiteTensor* bw_bias;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kBwBiasTensor, &bw_bias));\n  const TfLiteTensor* bw_hidden_state;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kBwHiddenStateTensor,\n                                          &bw_hidden_state));\n\n  const TfLiteTensor* aux_input =\n      GetOptionalInputTensor(context, node, kAuxInputTensor);\n  const TfLiteTensor* fw_aux_input_weights =\n      GetOptionalInputTensor(context, node, kFwAuxWeightsTensor);\n  const TfLiteTensor* bw_aux_input_weights =\n      GetOptionalInputTensor(context, node, kBwAuxWeightsTensor);\n\n  const bool aux_inputs_weights_or_none =\n      ((fw_aux_input_weights != nullptr) &&\n    TfLiteIntArrayFree(node->temporaries);\n    if (has_aux_input) {\n      node->temporaries = TfLiteIntArrayCreate(kNumTemporaryTensors);\n    } else {\n      // No need to create a temporary tensor for the non-existent aux_input.\n      node->temporaries = TfLiteIntArrayCreate(kNumTemporaryTensors - 1);\n    }\n\n    node->temporaries->data[kInputQuantized] =\n        op_data->scratch_tensor_index + kInputQuantized;\n    TfLiteTensor* input_quantized;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, kInputQuantized,\n                                                &input_quantized));\n    input_quantized->type = fw_input_weights->type;\n    input_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {\n      TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                       input_quantized_size));\n    }\n\n    node->temporaries->data[kFwHiddenStateQuantized] =\n        op_data->scratch_tensor_index + kFwHiddenStateQuantized;\n    TfLiteTensor* fw_hidden_state_quantized;\n    TF_LITE_ENSURE_OK(context,\n                      GetTemporarySafe(context, node, kFwHiddenStateQuantized,\n                                       &fw_hidden_state_quantized));\n    fw_hidden_state_quantized->type = fw_input_weights->type;\n    fw_hidden_state_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(fw_hidden_state_quantized->dims,\n                             fw_hidden_state->dims)) {\n      TfLiteIntArray* fw_hidden_state_quantized_size =\n          TfLiteIntArrayCopy(fw_hidden_state->dims);\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, fw_hidden_state_quantized,\n                                         fw_hidden_state_quantized_size));\n    }\n\n    node->temporaries->data[kBwHiddenStateQuantized] =\n        op_data->scratch_tensor_index + kBwHiddenStateQuantized;\n    TfLiteTensor* bw_hidden_state_quantized;\n    TF_LITE_ENSURE_OK(context,\n                      GetTemporarySafe(context, node, kBwHiddenStateQuantized,\n                                       &bw_hidden_state_quantized));\n    bw_hidden_state_quantized->type = fw_input_weights->type;\n    bw_hidden_state_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(bw_hidden_state_quantized->dims,\n                             bw_hidden_state->dims)) {\n      TfLiteIntArray* bw_hidden_state_quantized_size =\n          TfLiteIntArrayCopy(bw_hidden_state->dims);\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, bw_hidden_state_quantized,\n                                         bw_hidden_state_quantized_size));\n    }\n\n    // Allocate temporary tensors to store scaling factors of quantization.\n    node->temporaries->data[kScalingFactors] =\n        op_data->scratch_tensor_index + kScalingFactors;\n    TfLiteTensor* scaling_factors;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, kScalingFactors,\n                                                &scaling_factors));\n    scaling_factors->type = kTfLiteFloat32;\n    scaling_factors->allocation_type = kTfLiteArenaRw;\n    int scaling_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {\n      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);\n      scaling_factors_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,\n                                                       scaling_factors_size));\n    }\n    node->temporaries->data[kAccumScratch] =\n        op_data->scratch_tensor_index + kAccumScratch;\n    TfLiteTensor* accum_scratch;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, kAccumScratch,\n                                                &accum_scratch));\n    accum_scratch->type = kTfLiteInt32;\n    accum_scratch->allocation_type = kTfLiteArenaRw;\n    int accum_scratch_dims[2] = {std::max(fw_num_units, bw_num_units),\n                                 batch_size};\n    if (!TfLiteIntArrayEqualsArray(accum_scratch->dims, 2,\n                                   accum_scratch_dims)) {\n      TfLiteIntArray* accum_scratch_size = TfLiteIntArrayCreate(2);\n      accum_scratch_size->data[0] = accum_scratch_dims[0];\n      accum_scratch_size->data[1] = accum_scratch_dims[1];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, accum_scratch,\n                                                       accum_scratch_size));\n    }\n    node->temporaries->data[kZeroPoints] =\n        op_data->scratch_tensor_index + kZeroPoints;\n    TfLiteTensor* zero_points;\n    TF_LITE_ENSURE_OK(\n        context,\n        GetTemporarySafe(context, node, /*index=*/kZeroPoints, &zero_points));\n    zero_points->type = kTfLiteInt32;\n    zero_points->allocation_type = kTfLiteArenaRw;\n    int zero_points_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(zero_points->dims, 1, zero_points_dims)) {\n      TfLiteIntArray* zero_points_size = TfLiteIntArrayCreate(1);\n      zero_points_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, zero_points,\n                                                       zero_points_size));\n    }\n    const int num_row_sums = has_aux_input ? 3 : 2;\n    node->temporaries->data[kFwRowSums] =\n        op_data->scratch_tensor_index + kFwRowSums;\n    TfLiteTensor* fw_row_sums;\n    TF_LITE_ENSURE_OK(\n        context,\n        GetTemporarySafe(context, node, /*index=*/kFwRowSums, &fw_row_sums));\n    fw_row_sums->type = kTfLiteInt32;\n    fw_row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int fw_row_sums_dims[2] = {num_row_sums, fw_num_units};\n    if (!TfLiteIntArrayEqualsArray(fw_row_sums->dims, 2, fw_row_sums_dims)) {\n      TfLiteIntArray* fw_row_sums_size = TfLiteIntArrayCreate(2);\n      fw_row_sums_size->data[0] = fw_row_sums_dims[0];\n      fw_row_sums_size->data[1] = fw_row_sums_dims[1];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, fw_row_sums,\n                                                       fw_row_sums_size));\n    }\n    node->temporaries->data[kBwRowSums] =\n        op_data->scratch_tensor_index + kBwRowSums;\n    TfLiteTensor* bw_row_sums;\n    TF_LITE_ENSURE_OK(\n        context,\n        GetTemporarySafe(context, node, /*index=*/kBwRowSums, &bw_row_sums));\n    bw_row_sums->type = kTfLiteInt32;\n    bw_row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int bw_row_sums_dims[2] = {num_row_sums, bw_num_units};\n    if (!TfLiteIntArrayEqualsArray(bw_row_sums->dims, 2, bw_row_sums_dims)) {\n      TfLiteIntArray* bw_row_sums_size = TfLiteIntArrayCreate(2);\n      bw_row_sums_size->data[0] = bw_row_sums_dims[0];\n      bw_row_sums_size->data[1] = bw_row_sums_dims[1];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, bw_row_sums,\n                                                       bw_row_sums_size));\n    }\n    if (has_aux_input) {\n      node->temporaries->data[kAuxInputQuantized] =\n          op_data->scratch_tensor_index + kAuxInputQuantized;\n      TfLiteTensor* aux_input_quantized;\n      TF_LITE_ENSURE_OK(context,\n                        GetTemporarySafe(context, node, kAuxInputQuantized,\n                                         &aux_input_quantized));\n      aux_input_quantized->type = fw_input_weights->type;\n      aux_input_quantized->allocation_type = kTfLiteArenaRw;\n      if (!TfLiteIntArrayEqual(aux_input_quantized->dims, aux_input->dims)) {\n        TfLiteIntArray* aux_input_quantized_size =\n            TfLiteIntArrayCopy(aux_input->dims);\n        TF_LITE_ENSURE_OK(context,\n                          context->ResizeTensor(context, aux_input_quantized,\n                                                aux_input_quantized_size));\n      }\n    }\n  }\n\n  // Resize outputs.\n  TfLiteTensor* fw_output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kFwOutputTensor, &fw_output));\n  TfLiteIntArray* fw_output_size_array = TfLiteIntArrayCreate(3);\n  fw_output_size_array->data[0] = (time_major) ? max_time : batch_size;\n  fw_output_size_array->data[1] = (time_major) ? batch_size : max_time;\n  fw_output_size_array->data[2] =\n      params->merge_outputs ? fw_num_units + bw_num_units : fw_num_units;\n  TF_LITE_ENSURE_OK(\n      context, context->ResizeTensor(context, fw_output, fw_output_size_array));\n  if (!params->merge_outputs) {\n    TfLiteTensor* bw_output;\n    TF_LITE_ENSURE_OK(\n        context, GetOutputSafe(context, node, kBwOutputTensor, &bw_output));\n    TfLiteIntArray* bw_output_size_array = TfLiteIntArrayCreate(3);\n    bw_output_size_array->data[0] = batch_size;\n    bw_output_size_array->data[1] = max_time;\n    bw_output_size_array->data[2] = bw_num_units;\n    TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, bw_output,\n                                                     bw_output_size_array));\n  }\n\n  return kTfLiteOk;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "R_API RBinJavaAttrInfo *r_bin_java_read_next_attr_from_buffer(ut8 *buffer, st64 sz, st64 buf_offset) {\n\tRBinJavaAttrInfo *attr = NULL;\n\tchar *name = NULL;\n\tut64 offset = 0;\n\tut16 name_idx;\n\tst64 nsz;\n\tRBinJavaAttrMetas *type_info = NULL;\n\n\tif (!buffer || ((int) sz) < 4 || buf_offset < 0) {\n\t\teprintf (\"r_bin_Java_read_next_attr_from_buffer: invalid buffer size %d\\n\", (int) sz);\n\t\treturn NULL;\n\t}\n\tname_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tnsz = R_BIN_JAVA_UINT (buffer, offset);\n\toffset += 4;\n\tname = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, name_idx);\n\tif (!name) {\n\t\tname = strdup (\"unknown\");\n\t}\n\tIFDBG eprintf(\"r_bin_java_read_next_attr: name_idx = %d is %s\\n\", name_idx, name);\n\ttype_info = r_bin_java_get_attr_type_by_name (name);\n\tif (type_info) {\n\t\tIFDBG eprintf(\"Typeinfo: %s, was %s\\n\", type_info->name, name);\n\t\t// printf (\"SZ %d %d %d\\n\", nsz, sz, buf_offset);\n\t\tif (nsz > sz) {\n\t\t\tfree (name);\n\t\t\treturn NULL;\n\t\t}\n\t\tif ((attr = type_info->allocs->new_obj (buffer, nsz, buf_offset))) {\n\t\t\tattr->metas->ord = (R_BIN_JAVA_GLOBAL_BIN->attr_idx++);\n\t\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "R_API RBinJavaAttrInfo *r_bin_java_read_next_attr_from_buffer(ut8 *buffer, st64 sz, st64 buf_offset) {\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 offset = 0;\n\tut16 name_idx;\n\tst64 nsz;\n\n\tif (!buffer || ((int) sz) < 4 || buf_offset < 0) {\n\t\teprintf (\"r_bin_Java_read_next_attr_from_buffer: invalid buffer size %d\\n\", (int) sz);\n\t\treturn NULL;\n\t}\n\tname_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tnsz = R_BIN_JAVA_UINT (buffer, offset);\n\toffset += 4;\n\n\tchar *name = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, name_idx);\n\tif (!name) {\n\t\tname = strdup (\"unknown\");\n\t}\n\tIFDBG eprintf(\"r_bin_java_read_next_attr: name_idx = %d is %s\\n\", name_idx, name);\n\tRBinJavaAttrMetas *type_info = r_bin_java_get_attr_type_by_name (name);\n\tif (type_info) {\n\t\tIFDBG eprintf(\"Typeinfo: %s, was %s\\n\", type_info->name, name);\n\t\t// printf (\"SZ %d %d %d\\n\", nsz, sz, buf_offset);\n\t\tif (nsz > sz) {\n\t\t\tfree (name);\n\t\t\treturn NULL;\n\t\t}\n\t\tif ((attr = type_info->allocs->new_obj (buffer, nsz, buf_offset))) {\n\t\t\tattr->metas->ord = (R_BIN_JAVA_GLOBAL_BIN->attr_idx++);\n\t\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void fp3_write_bin(uint8_t *bin, int len, const fp3_t a) {\n\tif (len != 3 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp_write_bin(bin, RLC_FP_BYTES, a[0]);\n\tfp_write_bin(bin + RLC_FP_BYTES, RLC_FP_BYTES, a[1]);\n\tfp_write_bin(bin + 2 * RLC_FP_BYTES, RLC_FP_BYTES, a[2]);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void fp3_write_bin(uint8_t *bin, size_t len, const fp3_t a) {\n\tif (len != 3 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp_write_bin(bin, RLC_FP_BYTES, a[0]);\n\tfp_write_bin(bin + RLC_FP_BYTES, RLC_FP_BYTES, a[1]);\n\tfp_write_bin(bin + 2 * RLC_FP_BYTES, RLC_FP_BYTES, a[2]);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t    goto end;\n\n\tif (generic_gss_copy_oid(&temp_minor_status, selected_mech,\n\t\t\t\t &union_ctx_id->mech_type) != GSS_S_COMPLETE) {\n\t    free(union_ctx_id);\n\t    goto end;\n\t}\n\n\t/* copy the supplied context handle */\n\tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n    } else\n\tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n\n    /*\n     * get the appropriate cred handle from the union cred struct.\n     * defaults to GSS_C_NO_CREDENTIAL if there is no cred, which will\n     * use the default credential.\n     */\n    union_cred = (gss_union_cred_t) claimant_cred_handle;\n    input_cred_handle = gssint_get_mechanism_cred(union_cred, selected_mech);\n\n    /*\n\ttime_req,\n\tinput_chan_bindings,\n\tinput_token,\n\tactual_mech_type,\n\toutput_token,\n\tret_flags,\n\ttime_rec);\n\n    if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n\t/*\n\t * The spec says the preferred method is to delete all context info on\n\t * the first call to init, and on all subsequent calls make the caller\n\t * responsible for calling gss_delete_sec_context.  However, if the\n\t * mechanism decided to delete the internal context, we should also\n\t * delete the union context.\n\t */\n\tmap_error(minor_status, mech);\n\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n\t    *context_handle = GSS_C_NO_CONTEXT;\n\tif (*context_handle == GSS_C_NO_CONTEXT) {\n\t    free(union_ctx_id->mech_type->elements);\n\t    free(union_ctx_id->mech_type);\n\t    free(union_ctx_id);\n\t}\n    } else if (*context_handle == GSS_C_NO_CONTEXT) {\n\tunion_ctx_id->loopback = union_ctx_id;\n\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n    }\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t    goto end;\n\n\tif (generic_gss_copy_oid(&temp_minor_status, selected_mech,\n\t\t\t\t &union_ctx_id->mech_type) != GSS_S_COMPLETE) {\n\t    free(union_ctx_id);\n\t    goto end;\n\t}\n\n\t/* copy the supplied context handle */\n\tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n    } else {\n\tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n\t    status = GSS_S_NO_CONTEXT;\n\t    goto end;\n\t}\n    }\n\n    /*\n     * get the appropriate cred handle from the union cred struct.\n     * defaults to GSS_C_NO_CREDENTIAL if there is no cred, which will\n     * use the default credential.\n     */\n    union_cred = (gss_union_cred_t) claimant_cred_handle;\n    input_cred_handle = gssint_get_mechanism_cred(union_cred, selected_mech);\n\n    /*\n\ttime_req,\n\tinput_chan_bindings,\n\tinput_token,\n\tactual_mech_type,\n\toutput_token,\n\tret_flags,\n\ttime_rec);\n\n    if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n\t/*\n\t * RFC 2744 5.19 requires that we not create a context on a failed\n\t * first call to init, and recommends that on a failed subsequent call\n\t * we make the caller responsible for calling gss_delete_sec_context.\n\t * Even if the mech deleted its context, keep the union context around\n\t * for the caller to delete.\n\t */\n\tmap_error(minor_status, mech);\n\tif (*context_handle == GSS_C_NO_CONTEXT) {\n\t    free(union_ctx_id->mech_type->elements);\n\t    free(union_ctx_id->mech_type);\n\t    free(union_ctx_id);\n\t}\n    } else if (*context_handle == GSS_C_NO_CONTEXT) {\n\tunion_ctx_id->loopback = union_ctx_id;\n\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n    }\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    g_string_append(s, \"Before=network-pre.target\\n\");\n\n    g_hash_table_iter_init(&iter, pfs);\n    while (g_hash_table_iter_next (&iter, &key, NULL)) {\n        g_string_append_printf(s, \"After=sys-subsystem-net-devices-%s.device\\n\", (gchar*) key);\n    }\n\n    g_string_append(s, \"\\n[Service]\\nType=oneshot\\n\");\n    g_string_append_printf(s, \"ExecStart=\" SBINDIR \"/netplan apply --sriov-only\\n\");\n\n    _netplan_g_string_free_to_file(s, rootdir, path, NULL);\n\n    _netplan_safe_mkdir_p_dir(link);\n    if (symlink(path, link) < 0 && errno != EEXIST) {\n        // LCOV_EXCL_START\n        g_set_error(error, G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT,\n                    \"failed to create enablement symlink: %m\");\n        return FALSE;\n        // LCOV_EXCL_STOP\n    }\n    return TRUE;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    g_string_append(s, \"Before=network-pre.target\\n\");\n\n    g_hash_table_iter_init(&iter, pfs);\n    while (g_hash_table_iter_next (&iter, &key, NULL)) {\n        g_string_append_printf(s, \"After=sys-subsystem-net-devices-%s.device\\n\", (gchar*) key);\n    }\n\n    g_string_append(s, \"\\n[Service]\\nType=oneshot\\n\");\n    g_string_append_printf(s, \"ExecStart=\" SBINDIR \"/netplan apply --sriov-only\\n\");\n\n    _netplan_g_string_free_to_file_with_permissions(s, rootdir, path, NULL, \"root\", \"root\", 0640);\n\n    _netplan_safe_mkdir_p_dir(link);\n    if (symlink(path, link) < 0 && errno != EEXIST) {\n        // LCOV_EXCL_START\n        g_set_error(error, G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT,\n                    \"failed to create enablement symlink: %m\");\n        return FALSE;\n        // LCOV_EXCL_STOP\n    }\n    return TRUE;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "usm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval = (struct usmStateReference *)\n        calloc(1, sizeof(struct usmStateReference));\n\n    return retval;\n}                               /* end usm_malloc_usmStateReference() */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "usm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval;\n\n    retval = calloc(1, sizeof(struct usmStateReference));\n    if (retval)\n        retval->refcnt = 1;\n\n    return retval;\n}                               /* end usm_malloc_usmStateReference() */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(\n    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,\n    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {\n  ASSERT(codec_client_ != nullptr);\n  // Send the request to Envoy.\n  IntegrationStreamDecoderPtr response;\n  if (request_body_size) {\n    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);\n  } else {\n    response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  }\n  waitForNextUpstreamRequest(upstream_index);\n  // Send response headers, and end_stream if there is no response body.\n  upstream_request_->encodeHeaders(response_headers, response_size == 0);\n  // Send any response data, with end_stream true.\n  if (response_size) {\n    upstream_request_->encodeData(response_size, true);\n  }\n  // Wait for the response to be read by the codec client.\n  response->waitForEndStream();\n  return response;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(\n    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,\n    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index,\n    std::chrono::milliseconds time) {\n  ASSERT(codec_client_ != nullptr);\n  // Send the request to Envoy.\n  IntegrationStreamDecoderPtr response;\n  if (request_body_size) {\n    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);\n  } else {\n    response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  }\n  waitForNextUpstreamRequest(upstream_index, time);\n  // Send response headers, and end_stream if there is no response body.\n  upstream_request_->encodeHeaders(response_headers, response_size == 0);\n  // Send any response data, with end_stream true.\n  if (response_size) {\n    upstream_request_->encodeData(response_size, true);\n  }\n  // Wait for the response to be read by the codec client.\n  response->waitForEndStream();\n  return response;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tif (!nPlugins) \n\t\t\t{\n\t\t\t\tSendMessage(hPlugins, CB_ADDSTRING, 0, (LPARAM) sz_ID_NO_PLUGIN_DETECT);\n\t\t\t\tSendMessage(hPlugins, CB_SETCURSEL, 0, 0);\n\t\t\t}\n\t\t\telse\n\t\t\t\tSendMessage(hPlugins, CB_SELECTSTRING, 0, (LPARAM)_this->m_server->GetDSMPluginName());\n\n\t\t\t// Modif sf@2002\n\t\t\tSendMessage(GetDlgItem(hwnd, IDC_PLUGIN_CHECK), BM_SETCHECK, _this->m_server->IsDSMPluginEnabled(), 0);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_PLUGIN_BUTTON), _this->m_server->IsDSMPluginEnabled());\n\n\t\t\t// Query window option - Taken from TightVNC advanced properties \n\t\t\tBOOL queryEnabled = (_this->m_server->QuerySetting() == 4);\n\t\t\tSendMessage(GetDlgItem(hwnd, IDQUERY), BM_SETCHECK, queryEnabled, 0);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDQUERYTIMEOUT), queryEnabled);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_QUERYDISABLETIME), queryEnabled);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_DREFUSE), queryEnabled);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_DACCEPT), queryEnabled);\n\n\t\t\tSetDlgItemText(hwnd, IDC_SERVICE_COMMANDLINE, _this->service_commandline);\n\t\t\t\tif (newconn)\n\t\t\t\t{\n\t\t\t\t\tnewconn->DoDialog(true);\n\t\t\t\t\t// delete newconn; // NO ! Already done in vncConnDialog.\n\t\t\t\t}\n\t\t\t}\n\n\t\t// sf@2002 - DSM Plugin\n\t\tcase IDC_PLUGIN_CHECK:\n\t\t\t{\n\t\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_PLUGIN_BUTTON),\n\t\t\t\t\tSendMessage(GetDlgItem(hwnd, IDC_PLUGIN_CHECK), BM_GETCHECK, 0, 0) == BST_CHECKED);\n\t\t\t}\n\t\t\treturn TRUE;\n\t\t\t// Marscha@2004 - authSSP: moved MSLogon checkbox back to admin props page\n\t\t\t// Reason: Different UI for old and new mslogon group config.\n\t\tcase IDC_MSLOGON_CHECKD:\n\t\t\t{\n\t\t\t\tBOOL bMSLogonChecked =\n\t\t\t\t(SendDlgItemMessage(hwnd, IDC_MSLOGON_CHECKD,\n\t\t\t\t\t\t\t\t\t\tBM_GETCHECK, 0, 0) == BST_CHECKED);\n\n\t\t\t{\n\t\t\t\tCheckVideoDriver(1);\n\t\t\t}\n\t\t\treturn TRUE;\n\t\tcase IDC_PLUGIN_BUTTON:\n\t\t\t{\n\t\t\t\tHWND hPlugin = GetDlgItem(hwnd, IDC_PLUGIN_CHECK);\n\t\t\t\tif (SendMessage(hPlugin, BM_GETCHECK, 0, 0) == BST_CHECKED)\n\t\t\t\t{\n\t\t\t\t\tTCHAR szPlugin[MAX_PATH];\n\t\t\t\t\tGetDlgItemText(hwnd, IDC_PLUGINS_COMBO, szPlugin, MAX_PATH);\n\t\t\t\t\tif (!_this->m_server->GetDSMPluginPointer()->IsLoaded())\n\t\t\t\t\t\t_this->m_server->GetDSMPluginPointer()->LoadPlugin(szPlugin, false);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// sf@2003 - We check if the loaded plugin is the same than\n\t\t\t\t\t\t// the currently selected one or not\n\t\t\t\t\t\t_this->m_server->GetDSMPluginPointer()->DescribePlugin();\n\t\t\t\t\t\tif (_stricmp(_this->m_server->GetDSMPluginPointer()->GetPluginFileName(), szPlugin))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_this->m_server->GetDSMPluginPointer()->UnloadPlugin();",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tif (!nPlugins) \n\t\t\t{\n\t\t\t\tSendMessage(hPlugins, CB_ADDSTRING, 0, (LPARAM) sz_ID_NO_PLUGIN_DETECT);\n\t\t\t\tSendMessage(hPlugins, CB_SETCURSEL, 0, 0);\n\t\t\t}\n\t\t\telse\n\t\t\t\tSendMessage(hPlugins, CB_SELECTSTRING, 0, (LPARAM)_this->m_server->GetDSMPluginName());\n\n\t\t\t// Modif sf@2002\n\t\t\tSendMessage(GetDlgItem(hwnd, IDC_PLUGIN_CHECK), BM_SETCHECK, _this->m_server->IsDSMPluginEnabled(), 0);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_PLUGIN_BUTTON),  (_this->m_server->AuthClientCount() == 0 ? _this->m_server->IsDSMPluginEnabled(): false));\n\n\t\t\t// Query window option - Taken from TightVNC advanced properties \n\t\t\tBOOL queryEnabled = (_this->m_server->QuerySetting() == 4);\n\t\t\tSendMessage(GetDlgItem(hwnd, IDQUERY), BM_SETCHECK, queryEnabled, 0);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDQUERYTIMEOUT), queryEnabled);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_QUERYDISABLETIME), queryEnabled);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_DREFUSE), queryEnabled);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_DACCEPT), queryEnabled);\n\n\t\t\tSetDlgItemText(hwnd, IDC_SERVICE_COMMANDLINE, _this->service_commandline);\n\t\t\t\tif (newconn)\n\t\t\t\t{\n\t\t\t\t\tnewconn->DoDialog(true);\n\t\t\t\t\t// delete newconn; // NO ! Already done in vncConnDialog.\n\t\t\t\t}\n\t\t\t}\n\n\t\t// sf@2002 - DSM Plugin\n\t\tcase IDC_PLUGIN_CHECK:\n\t\t\t{\n\t\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_PLUGIN_BUTTON), _this->m_server->AuthClientCount() == 0 \n\t\t\t\t\t\t? SendMessage(GetDlgItem(hwnd, IDC_PLUGIN_CHECK), BM_GETCHECK, 0, 0) == BST_CHECKED \n\t\t\t\t\t\t: BST_UNCHECKED);\n\t\t\t}\n\t\t\treturn TRUE;\n\t\t\t// Marscha@2004 - authSSP: moved MSLogon checkbox back to admin props page\n\t\t\t// Reason: Different UI for old and new mslogon group config.\n\t\tcase IDC_MSLOGON_CHECKD:\n\t\t\t{\n\t\t\t\tBOOL bMSLogonChecked =\n\t\t\t\t(SendDlgItemMessage(hwnd, IDC_MSLOGON_CHECKD,\n\t\t\t\t\t\t\t\t\t\tBM_GETCHECK, 0, 0) == BST_CHECKED);\n\n\t\t\t\tCheckVideoDriver(1);\n\t\t\t}\n\t\t\treturn TRUE;\n\t\tcase IDC_PLUGIN_BUTTON:\n\t\t\t{\n\t\t\t\tHWND hPlugin = GetDlgItem(hwnd, IDC_PLUGIN_CHECK);\n\t\t\t\tif (SendMessage(hPlugin, BM_GETCHECK, 0, 0) == BST_CHECKED)\n\t\t\t\t{\n\t\t\t\t\tTCHAR szPlugin[MAX_PATH];\n\t\t\t\t\tGetDlgItemText(hwnd, IDC_PLUGINS_COMBO, szPlugin, MAX_PATH);\n\t\t\t\t\tPathStripPathA(szPlugin);\n\n\t\t\t\t\tif (!_this->m_server->GetDSMPluginPointer()->IsLoaded())\n\t\t\t\t\t\t_this->m_server->GetDSMPluginPointer()->LoadPlugin(szPlugin, false);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// sf@2003 - We check if the loaded plugin is the same than\n\t\t\t\t\t\t// the currently selected one or not\n\t\t\t\t\t\t_this->m_server->GetDSMPluginPointer()->DescribePlugin();\n\t\t\t\t\t\tif (_stricmp(_this->m_server->GetDSMPluginPointer()->GetPluginFileName(), szPlugin))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_this->m_server->GetDSMPluginPointer()->UnloadPlugin();",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void ZlibInStream::deinit()\n{\n  assert(zs != NULL);\n  removeUnderlying();\n  inflateEnd(zs);\n  delete zs;\n  zs = NULL;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void ZlibInStream::deinit()\n{\n  assert(zs != NULL);\n  setUnderlying(NULL, 0);\n  inflateEnd(zs);\n  delete zs;\n  zs = NULL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      rc = imap_cmd_step (idata);\n    while (rc == IMAP_CMD_CONTINUE);\n\n    if (rc != IMAP_CMD_RESPOND)\n    {\n      dprint (1, (debugfile, \"Error receiving server response.\\n\"));\n      gss_release_name (&min_stat, &target_name);\n      goto bail;\n    }\n\n    request_buf.length = mutt_from_base64 (buf2, idata->buf + 2);\n    request_buf.value = buf2;\n    sec_token = &request_buf;\n\n    /* Write client data */\n    maj_stat = gss_init_sec_context (&min_stat, GSS_C_NO_CREDENTIAL, &context,\n      target_name, GSS_C_NO_OID, GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG, 0, \n      GSS_C_NO_CHANNEL_BINDINGS, sec_token, NULL, &send_token,\n      (unsigned int*) &cflags, NULL);\n    if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED)\n    {\n  /* get security flags and buffer size */\n  do\n    rc = imap_cmd_step (idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc != IMAP_CMD_RESPOND)\n  {\n    dprint (1, (debugfile, \"Error receiving server response.\\n\"));\n    goto bail;\n  }\n  request_buf.length = mutt_from_base64 (buf2, idata->buf + 2);\n  request_buf.value = buf2;\n\n  maj_stat = gss_unwrap (&min_stat, context, &request_buf, &send_token,\n    &cflags, &quality);\n  if (maj_stat != GSS_S_COMPLETE)\n  {\n    print_gss_error(maj_stat, min_stat);\n    dprint (2, (debugfile, \"Couldn't unwrap security level data\\n\"));\n    gss_release_buffer (&min_stat, &send_token);\n    goto err_abort_cmd;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      rc = imap_cmd_step (idata);\n    while (rc == IMAP_CMD_CONTINUE);\n\n    if (rc != IMAP_CMD_RESPOND)\n    {\n      dprint (1, (debugfile, \"Error receiving server response.\\n\"));\n      gss_release_name (&min_stat, &target_name);\n      goto bail;\n    }\n\n    request_buf.length = mutt_from_base64 (buf2, idata->buf + 2, sizeof(buf2));\n    request_buf.value = buf2;\n    sec_token = &request_buf;\n\n    /* Write client data */\n    maj_stat = gss_init_sec_context (&min_stat, GSS_C_NO_CREDENTIAL, &context,\n      target_name, GSS_C_NO_OID, GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG, 0, \n      GSS_C_NO_CHANNEL_BINDINGS, sec_token, NULL, &send_token,\n      (unsigned int*) &cflags, NULL);\n    if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED)\n    {\n  /* get security flags and buffer size */\n  do\n    rc = imap_cmd_step (idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc != IMAP_CMD_RESPOND)\n  {\n    dprint (1, (debugfile, \"Error receiving server response.\\n\"));\n    goto bail;\n  }\n  request_buf.length = mutt_from_base64 (buf2, idata->buf + 2, sizeof(buf2));\n  request_buf.value = buf2;\n\n  maj_stat = gss_unwrap (&min_stat, context, &request_buf, &send_token,\n    &cflags, &quality);\n  if (maj_stat != GSS_S_COMPLETE)\n  {\n    print_gss_error(maj_stat, min_stat);\n    dprint (2, (debugfile, \"Couldn't unwrap security level data\\n\"));\n    gss_release_buffer (&min_stat, &send_token);\n    goto err_abort_cmd;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t/* The following check ensures vaddr is a valid address in the VMA */\n\tgts = gru_find_thread_state(vma, TSID(vaddr, vma));\n\tif (!gts)\n\t\treturn VM_FAULT_SIGBUS;\n\nagain:\n\tmutex_lock(&gts->ts_ctxlock);\n\tpreempt_disable();\n\n\tgru_check_context_placement(gts);\n\n\tif (!gts->ts_gru) {\n\t\tSTAT(load_user_context);\n\t\tif (!gru_assign_gru_context(gts)) {\n\t\t\tpreempt_enable();\n\t\t\tmutex_unlock(&gts->ts_ctxlock);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule_timeout(GRU_ASSIGN_DELAY);  /* true hack ZZZ */\n\t\t\texpires = gts->ts_steal_jiffies + GRU_STEAL_DELAY;\n\t\t\tif (time_before(expires, jiffies))",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\t/* The following check ensures vaddr is a valid address in the VMA */\n\tgts = gru_find_thread_state(vma, TSID(vaddr, vma));\n\tif (!gts)\n\t\treturn VM_FAULT_SIGBUS;\n\nagain:\n\tmutex_lock(&gts->ts_ctxlock);\n\tpreempt_disable();\n\n\tif (gru_check_context_placement(gts)) {\n\t\tpreempt_enable();\n\t\tmutex_unlock(&gts->ts_ctxlock);\n\t\tgru_unload_context(gts, 1);\n\t\treturn VM_FAULT_NOPAGE;\n\t}\n\n\tif (!gts->ts_gru) {\n\t\tSTAT(load_user_context);\n\t\tif (!gru_assign_gru_context(gts)) {\n\t\t\tpreempt_enable();\n\t\t\tmutex_unlock(&gts->ts_ctxlock);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule_timeout(GRU_ASSIGN_DELAY);  /* true hack ZZZ */\n\t\t\texpires = gts->ts_steal_jiffies + GRU_STEAL_DELAY;\n\t\t\tif (time_before(expires, jiffies))",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    int\t\tcurline,\n    hlf_T\t*attrp)\t\t// return: attributes of bad word or NULL\n\t\t\t\t// (only when \"dir\" is FORWARD)\n{\n    linenr_T\tlnum;\n    pos_T\tfound_pos;\n    int\t\tfound_len = 0;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\t*endp;\n    hlf_T\tattr;\n    int\t\tlen;\n#ifdef FEAT_SYN_HL\n    int\t\thas_syntax = syntax_present(wp);\n#endif\n    int\t\tcol;\n    int\t\tcan_spell;\n    char_u\t*buf = NULL;\n    int\t\tbuflen = 0;\n    int\t\tskip = 0;\n    int\t\tcapcol = -1;\n     * bad word (in the cursor line: before the cursor).\n     *\n     * We concatenate the start of the next line, so that wrapped words work\n     * (e.g. \"et<line-break>cetera\").  Doesn't work when searching backwards\n     * though...\n     */\n    lnum = wp->w_cursor.lnum;\n    CLEAR_POS(&found_pos);\n\n    while (!got_int)\n    {\n\tline = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\n\tlen = (int)STRLEN(line);\n\tif (buflen < len + MAXWLEN + 2)\n\t{\n\t    vim_free(buf);\n\t    buflen = len + MAXWLEN + 2;\n\t    buf = alloc(buflen);\n\t    if (buf == NULL)\n\t\tbreak;\n\t    col = getwhitecols(line);\n\t    if (check_need_cap(lnum, col))\n\t\tcapcol = col;\n\n\t    // Need to get the line again, may have looked at the previous\n\t    // one.\n\t    line = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\t}\n\n\t// Copy the line into \"buf\" and append the start of the next line if\n\t// possible.\n\tSTRCPY(buf, line);\n\tif (lnum < wp->w_buffer->b_ml.ml_line_count)\n\t    spell_cat_line(buf + STRLEN(buf),\n\t\t\t  ml_get_buf(wp->w_buffer, lnum + 1, FALSE), MAXWLEN);\n\n\tp = buf + skip;\n\tendp = buf + len;\n\twhile (p < endp)\n\t{\n\t    // When searching backward don't search after the cursor.  Unless\n\t    // included in a match crossing line boundaries.\n\t    if (attr == HLF_COUNT)\n\t\tskip = (int)(p - endp);\n\t    else\n\t\tskip = 0;\n\n\t    // Capcol skips over the inserted space.\n\t    --capcol;\n\n\t    // But after empty line check first word in next line\n\t    if (*skipwhite(line) == NUL)\n\t\tcapcol = 0;\n\t}\n\n\tline_breakcheck();\n    }\n\n    vim_free(buf);\n    return 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    int\t\tcurline,\n    hlf_T\t*attrp)\t\t// return: attributes of bad word or NULL\n\t\t\t\t// (only when \"dir\" is FORWARD)\n{\n    linenr_T\tlnum;\n    pos_T\tfound_pos;\n    int\t\tfound_len = 0;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\t*endp;\n    hlf_T\tattr = 0;\n    int\t\tlen;\n#ifdef FEAT_SYN_HL\n    int\t\thas_syntax = syntax_present(wp);\n#endif\n    int\t\tcol;\n    int\t\tcan_spell;\n    char_u\t*buf = NULL;\n    int\t\tbuflen = 0;\n    int\t\tskip = 0;\n    int\t\tcapcol = -1;\n     *\n     * We concatenate the start of the next line, so that wrapped words work\n     * (e.g. \"et<line-break>cetera\").  Doesn't work when searching backwards\n     * though...\n     */\n    lnum = wp->w_cursor.lnum;\n    CLEAR_POS(&found_pos);\n\n    while (!got_int)\n    {\n\tint empty_line;\n\n\tline = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\n\tlen = (int)STRLEN(line);\n\tif (buflen < len + MAXWLEN + 2)\n\t{\n\t    vim_free(buf);\n\t    buflen = len + MAXWLEN + 2;\n\t    buf = alloc(buflen);\n\t    if (buf == NULL)\n\t\tbreak;\n\t    col = getwhitecols(line);\n\t    if (check_need_cap(lnum, col))\n\t\tcapcol = col;\n\n\t    // Need to get the line again, may have looked at the previous\n\t    // one.\n\t    line = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\t}\n\n\t// Copy the line into \"buf\" and append the start of the next line if\n\t// possible.  Note: this ml_get_buf() may make \"line\" invalid, check\n\t// for empty line first.\n\tempty_line = *skipwhite(line) == NUL;\n\tSTRCPY(buf, line);\n\tif (lnum < wp->w_buffer->b_ml.ml_line_count)\n\t    spell_cat_line(buf + STRLEN(buf),\n\t\t\t  ml_get_buf(wp->w_buffer, lnum + 1, FALSE), MAXWLEN);\n\n\tp = buf + skip;\n\tendp = buf + len;\n\twhile (p < endp)\n\t{\n\t    // When searching backward don't search after the cursor.  Unless\n\t    // included in a match crossing line boundaries.\n\t    if (attr == HLF_COUNT)\n\t\tskip = (int)(p - endp);\n\t    else\n\t\tskip = 0;\n\n\t    // Capcol skips over the inserted space.\n\t    --capcol;\n\n\t    // But after empty line check first word in next line\n\t    if (empty_line)\n\t\tcapcol = 0;\n\t}\n\n\tline_breakcheck();\n    }\n\n    vim_free(buf);\n    return 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tif (dontfrag && (proto == IPPROTO_UDP || proto == IPPROTO_RAW)){\n\t\t\tipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\n\t\tif (proto == IPPROTO_UDP &&\n\t\t    (rt->dst.dev->features & NETIF_F_UFO)) {\n\n\t\t\terr = ip6_ufo_append_data(sk, getfrag, from, length,\n\t\t\t\t\t\t  hh_len, fragheaderlen,\n\t\t\t\t\t\t  transhdrlen, mtu, flags);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL)\n\t\tgoto alloc_new_skb;\n\n\twhile (length > 0) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tif (dontfrag && (proto == IPPROTO_UDP || proto == IPPROTO_RAW)){\n\t\t\tipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\n\t\tif (proto == IPPROTO_UDP &&\n\t\t    (rt->dst.dev->features & NETIF_F_UFO)) {\n\n\t\t\terr = ip6_ufo_append_data(sk, getfrag, from, length,\n\t\t\t\t\t\t  hh_len, fragheaderlen,\n\t\t\t\t\t\t  transhdrlen, mtu, flags, rt);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL)\n\t\tgoto alloc_new_skb;\n\n\twhile (length > 0) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "DWORD NSISCALL CreateRestrictedDirectory(LPCTSTR path)\n{\n  const SECURITY_INFORMATION si = OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION|DACL_SECURITY_INFORMATION|PROTECTED_DACL_SECURITY_INFORMATION;\n  PSID admingrpsid = GetAdminGrpSid();\n  SECURITY_DESCRIPTOR sd = { 1, 0, SE_DACL_PRESENT, admingrpsid, admingrpsid, NULL, GetAdminGrpAcl() };\n  SECURITY_ATTRIBUTES sa = { sizeof(SECURITY_ATTRIBUTES), &sd, FALSE };\n  DWORD ec = CreateDirectory(path, &sa) ? ERROR_SUCCESS : GetLastError();\n  if (ERROR_ALREADY_EXISTS == ec)\n    ec = SetFileSecurity(path, si, &sd) ? ERROR_SUCCESS : GetLastError();\n  return ec;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "DWORD NSISCALL CreateRestrictedDirectory(LPCTSTR path)\n{\n  PSID admingrpsid = GetAdminGrpSid();\n  SECURITY_DESCRIPTOR sd = { 1, 0, SE_DACL_PRESENT, admingrpsid, admingrpsid, NULL, GetAdminGrpAcl() };\n  SECURITY_ATTRIBUTES sa = { sizeof(SECURITY_ATTRIBUTES), &sd, FALSE };\n  return CreateDirectory(path, &sa) ? ERROR_SUCCESS : GetLastError();\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n    if (p7->d.ptr == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);\n        return NULL;\n    }\n\n    i = OBJ_obj2nid(p7->type);\n    p7->state = PKCS7_S_HEADER;\n\n    switch (i) {\n    case NID_pkcs7_signed:\n        data_body = PKCS7_get_octet_string(p7->d.sign->contents);\n        if (!PKCS7_is_detached(p7) && data_body == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_INVALID_SIGNED_DATA_TYPE);\n            goto err;\n        }\n        md_sk = p7->d.sign->md_algs;\n        break;\n    case NID_pkcs7_signedAndEnveloped:\n        rsk = p7->d.signed_and_enveloped->recipientinfo;\n        md_sk = p7->d.signed_and_enveloped->md_algs;\n        data_body = p7->d.signed_and_enveloped->enc_data->enc_data;\n        enc_alg = p7->d.signed_and_enveloped->enc_data->algorithm;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    case NID_pkcs7_enveloped:\n        rsk = p7->d.enveloped->recipientinfo;\n        enc_alg = p7->d.enveloped->enc_data->algorithm;\n        data_body = p7->d.enveloped->enc_data->enc_data;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    default:\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\n        goto err;\n    }\n\n    /* We will be checking the signature */\n    if (md_sk != NULL) {\n        for (i = 0; i < sk_X509_ALGOR_num(md_sk); i++) {\n            xa = sk_X509_ALGOR_value(md_sk, i);\n            if ((btmp = BIO_new(BIO_f_md())) == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB);\n                goto err;\n        ek = NULL;\n        OPENSSL_clear_free(tkey, tkeylen);\n        tkey = NULL;\n\n        if (out == NULL)\n            out = etmp;\n        else\n            BIO_push(out, etmp);\n        etmp = NULL;\n    }\n    if (PKCS7_is_detached(p7) || (in_bio != NULL)) {\n        bio = in_bio;\n    } else {\n        if (data_body->length > 0)\n            bio = BIO_new_mem_buf(data_body->data, data_body->length);\n        else {\n            bio = BIO_new(BIO_s_mem());\n            BIO_set_mem_eof_return(bio, 0);\n        }\n        if (bio == NULL)\n            goto err;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    if (p7->d.ptr == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);\n        return NULL;\n    }\n\n    i = OBJ_obj2nid(p7->type);\n    p7->state = PKCS7_S_HEADER;\n\n    switch (i) {\n    case NID_pkcs7_signed:\n        /*\n         * p7->d.sign->contents is a PKCS7 structure consisting of a contentType\n         * field and optional content.\n         * data_body is NULL if that structure has no (=detached) content\n         * or if the contentType is wrong (i.e., not \"data\").\n         */\n        data_body = PKCS7_get_octet_string(p7->d.sign->contents);\n        if (!PKCS7_is_detached(p7) && data_body == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_INVALID_SIGNED_DATA_TYPE);\n            goto err;\n        }\n        md_sk = p7->d.sign->md_algs;\n        break;\n    case NID_pkcs7_signedAndEnveloped:\n        rsk = p7->d.signed_and_enveloped->recipientinfo;\n        md_sk = p7->d.signed_and_enveloped->md_algs;\n        /* data_body is NULL if the optional EncryptedContent is missing. */\n        data_body = p7->d.signed_and_enveloped->enc_data->enc_data;\n        enc_alg = p7->d.signed_and_enveloped->enc_data->algorithm;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    case NID_pkcs7_enveloped:\n        rsk = p7->d.enveloped->recipientinfo;\n        enc_alg = p7->d.enveloped->enc_data->algorithm;\n        /* data_body is NULL if the optional EncryptedContent is missing. */\n        data_body = p7->d.enveloped->enc_data->enc_data;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    default:\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\n        goto err;\n    }\n\n    /* Detached content must be supplied via in_bio instead. */\n    if (data_body == NULL && in_bio == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);\n        goto err;\n    }\n\n    /* We will be checking the signature */\n    if (md_sk != NULL) {\n        for (i = 0; i < sk_X509_ALGOR_num(md_sk); i++) {\n            xa = sk_X509_ALGOR_value(md_sk, i);\n            if ((btmp = BIO_new(BIO_f_md())) == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB);\n                goto err;\n        ek = NULL;\n        OPENSSL_clear_free(tkey, tkeylen);\n        tkey = NULL;\n\n        if (out == NULL)\n            out = etmp;\n        else\n            BIO_push(out, etmp);\n        etmp = NULL;\n    }\n    if (in_bio != NULL) {\n        bio = in_bio;\n    } else {\n        if (data_body->length > 0)\n            bio = BIO_new_mem_buf(data_body->data, data_body->length);\n        else {\n            bio = BIO_new(BIO_s_mem());\n            BIO_set_mem_eof_return(bio, 0);\n        }\n        if (bio == NULL)\n            goto err;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tstruct files_struct *fd, *new_fd = NULL;\n\tstruct cred *new_cred = NULL;\n\tstruct nsproxy *new_nsproxy = NULL;\n\tint do_sysvsem = 0;\n\tint err;\n\n\t/*\n\t * If unsharing a user namespace must also unshare the thread.\n\t */\n\tif (unshare_flags & CLONE_NEWUSER)\n\t\tunshare_flags |= CLONE_THREAD;\n\t/*\n\t * If unsharing a pid namespace must also unshare the thread.\n\t */\n\tif (unshare_flags & CLONE_NEWPID)\n\t\tunshare_flags |= CLONE_THREAD;\n\t/*\n\t * If unsharing a thread from a thread group, must also unshare vm.\n\t */\n\tif (unshare_flags & CLONE_THREAD)\n\t\tunshare_flags |= CLONE_VM;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tstruct files_struct *fd, *new_fd = NULL;\n\tstruct cred *new_cred = NULL;\n\tstruct nsproxy *new_nsproxy = NULL;\n\tint do_sysvsem = 0;\n\tint err;\n\n\t/*\n\t * If unsharing a user namespace must also unshare the thread.\n\t */\n\tif (unshare_flags & CLONE_NEWUSER)\n\t\tunshare_flags |= CLONE_THREAD | CLONE_FS;\n\t/*\n\t * If unsharing a pid namespace must also unshare the thread.\n\t */\n\tif (unshare_flags & CLONE_NEWPID)\n\t\tunshare_flags |= CLONE_THREAD;\n\t/*\n\t * If unsharing a thread from a thread group, must also unshare vm.\n\t */\n\tif (unshare_flags & CLONE_THREAD)\n\t\tunshare_flags |= CLONE_VM;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static u32 crc32sum(u32 crc, u8 * RESTRICT buf, size_t size) {\n    while (size--) crc = crc32Table[(crc ^ *(buf++)) & 0xff] ^ (crc >> 8);\n    return crc;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static u32 crc32sum(u32 crc, u8 * RESTRICT buf, size_t size) {\n    // Test endianness. The code needs to be different for LE and BE systems.\n    u32 test = 1;\n    if (*(u8 *) &test) {\n        while (size--) crc = crc32Table[(crc ^ *(buf++)) & 0xff] ^ (crc >> 8);\n        return crc;\n    } else {\n        while (size--) crc = crc32Table[((crc >> 24) ^ *(buf++)) & 0xff] ^ (crc << 8);\n        return crc;\n    }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "#ifdef WIN32\n\tint addr_len;\n#else\n\tsocklen_t addr_len;\n#endif\n\tint result;\n\tstruct sockaddr_in addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(port);\n\n\taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n\n\treturn result;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "#ifdef WIN32\n\tint addr_len;\n#else\n\tsocklen_t addr_len;\n#endif\n\tint result;\n\tstruct sockaddr_in addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\taddr.sin_port = htons(port);\n\n\taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n\n\treturn result;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static bcon_error_t bson_append_bcon_with_state(bson *b, const bcon *bc, bcon_state_t start_state) {\n    bcon_error_t ret = BCON_OK;\n    bcon_state_t state = start_state;\n    char *key = 0;\n    char *typespec = 0;\n    unsigned char doc_stack[DOC_STACK_SIZE];\n    size_t doc_stack_pointer = 0;\n    size_t array_index = 0;\n    unsigned int array_index_stack[ARRAY_INDEX_STACK_SIZE];\n    size_t array_index_stack_pointer = 0;\n    char array_index_buffer[ARRAY_INDEX_BUFFER_SIZE]; /* max BSON size */\n    int end_of_data;\n    const bcon *bcp;\n    for (end_of_data = 0, bcp = bc; ret == BCON_OK && !end_of_data; bcp++) {\n        bcon bci = *bcp;\n        char *s = bci.s;\n        switch (state) {\n        case State_Element:\n            switch (bcon_token(s)) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static bcon_error_t bson_append_bcon_with_state(bson *b, const bcon *bc, bcon_state_t start_state) {\n    bcon_error_t ret = BCON_OK;\n    bcon_state_t state = start_state;\n    char *key = 0;\n    char *typespec = 0;\n    unsigned char doc_stack[DOC_STACK_SIZE];\n    size_t doc_stack_pointer = 0;\n    size_t array_index = 0;\n    size_t array_index_stack[ARRAY_INDEX_STACK_SIZE];\n    size_t array_index_stack_pointer = 0;\n    char array_index_buffer[ARRAY_INDEX_BUFFER_SIZE]; /* max BSON size */\n    int end_of_data;\n    const bcon *bcp;\n    for (end_of_data = 0, bcp = bc; ret == BCON_OK && !end_of_data; bcp++) {\n        bcon bci = *bcp;\n        char *s = bci.s;\n        switch (state) {\n        case State_Element:\n            switch (bcon_token(s)) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n\n    //if (block->host) {\n    //    ram_block_notify_remove(block->host, block->max_length);\n    //}\n\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    /* Write list before version */\n    //smp_wmb();\n    // call_rcu(block, reclaim_ramblock, rcu);\n    reclaim_ramblock(uc, block);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n\n    //if (block->host) {\n    //    ram_block_notify_remove(block->host, block->max_length);\n    //}\n\n    QLIST_REMOVE_RCU(block, next);\n    uc->ram_list.mru_block = NULL;\n    /* Write list before version */\n    //smp_wmb();\n    // call_rcu(block, reclaim_ramblock, rcu);\n    reclaim_ramblock(uc, block);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tswitch(tga->bits) {\n\tcase 8:\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\tgd_error(\"bps %i not supported\", tga->bits);\n\t\treturn -1;\n\t\tbreak;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tif (!((tga->bits == TGA_BPP_24 && tga->alphabits == 0)\n\t\t|| (tga->bits == TGA_BPP_32 && tga->alphabits == 8)))\n\t{\n\t\tgd_error_ex(GD_WARNING, \"gd-tga: %u bits per pixel with %u alpha bits not supported\\n\",\n\t\t\ttga->bits, tga->alphabits);\n\t\treturn -1;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tHEVC_SPS *sps;\n\tHEVC_VPS *vps;\n\tHEVC_ProfileTierLevel ptl;\n\tBool multiLayerExtSpsFlag;\n\tu8 sps_ext_or_max_sub_layers_minus1, max_sub_layers_minus1;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif (vps_id >= 16) {\n\t\treturn -1;\n\t}\n\tmemset(&ptl, 0, sizeof(ptl));\n\tmax_sub_layers_minus1 = 0;\n\tsps_ext_or_max_sub_layers_minus1 = 0;\n\tif (layer_id == 0)\n\t\tmax_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\");\n\telse\n\t\tsps_ext_or_max_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \"sps_ext_or_max_sub_layers_minus1\");\n\tmultiLayerExtSpsFlag = (layer_id != 0) && (sps_ext_or_max_sub_layers_minus1 == 7);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tHEVC_SPS *sps;\n\tHEVC_VPS *vps;\n\tHEVC_ProfileTierLevel ptl;\n\tBool multiLayerExtSpsFlag;\n\tu8 sps_ext_or_max_sub_layers_minus1, max_sub_layers_minus1;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif ((vps_id<0) || (vps_id >= 16)) {\n\t\treturn -1;\n\t}\n\tmemset(&ptl, 0, sizeof(ptl));\n\tmax_sub_layers_minus1 = 0;\n\tsps_ext_or_max_sub_layers_minus1 = 0;\n\tif (layer_id == 0)\n\t\tmax_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\");\n\telse\n\t\tsps_ext_or_max_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \"sps_ext_or_max_sub_layers_minus1\");\n\tmultiLayerExtSpsFlag = (layer_id != 0) && (sps_ext_or_max_sub_layers_minus1 == 7);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "_isBidi (const uint32_t *label, size_t llen)\n{\n  while (llen-- > 0) {\n    int bc = uc_bidi_category (*label++);\n\n    if (bc == UC_BIDI_R || bc == UC_BIDI_AL || bc == UC_BIDI_AN)\n      return 1;\n  }\n\n  return 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "_isBidi (const uint32_t *label, size_t llen)\n{\n  for (; (ssize_t) llen > 0; llen--) {\n    int bc = uc_bidi_category (*label++);\n\n    if (bc == UC_BIDI_R || bc == UC_BIDI_AL || bc == UC_BIDI_AN)\n      return 1;\n  }\n\n  return 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tint err = 0;\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\n\t/*\n\t * Use xrstors to restore context if it is enabled. xrstors supports\n\t * compacted format of xsave area which is not supported by xrstor.\n\t */\n\talternative_input(\n\t\t\"1: \" XRSTOR,\n\t\t\"1: \" XRSTORS,\n\t\tX86_FEATURE_XSAVES,\n\t\t\"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t: \"memory\");\n\n\tasm volatile(\"2:\\n\"\n\t\t     xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\n\treturn err;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tint err = 0;\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\n\t/*\n\t * Use xrstors to restore context if it is enabled. xrstors supports\n\t * compacted format of xsave area which is not supported by xrstor.\n\t */\n\talternative_input(\n\t\t\"1: \" XRSTOR,\n\t\tXRSTORS,\n\t\tX86_FEATURE_XSAVES,\n\t\t\"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t: \"memory\");\n\n\tasm volatile(\"2:\\n\"\n\t\t     xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\n\treturn err;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "tsl::StatusOr<Platform*> MultiPlatformManagerImpl::LookupByIdLocked(\n    const Platform::Id& id) {\n  auto it = id_map_.find(id);\n  if (it == id_map_.end()) {\n    return tsl::Status(\n        port::error::NOT_FOUND,\n        absl::StrFormat(\"could not find registered platform with id: %p\", id));\n  }\n  return it->second;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "tsl::StatusOr<Platform*> MultiPlatformManagerImpl::LookupByIdLocked(\n    const Platform::Id& id) {\n  auto it = id_map_.find(id);\n  if (it == id_map_.end()) {\n    return tsl::Status(\n        tsl::error::NOT_FOUND,\n        absl::StrFormat(\"could not find registered platform with id: %p\", id));\n  }\n  return it->second;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "PJ_DEF(void) pjsip_auth_create_digest( pj_str_t *result,\n\t\t\t\t       const pj_str_t *nonce,\n\t\t\t\t       const pj_str_t *nc,\n\t\t\t\t       const pj_str_t *cnonce,\n\t\t\t\t       const pj_str_t *qop,\n\t\t\t\t       const pj_str_t *uri,\n\t\t\t\t       const pj_str_t *realm,\n\t\t\t\t       const pjsip_cred_info *cred_info,\n\t\t\t\t       const pj_str_t *method)\n{\n    char ha1[PJSIP_MD5STRLEN];\n    char ha2[PJSIP_MD5STRLEN];\n    unsigned char digest[16];\n    pj_md5_context pms;\n\n    pj_assert(result->slen >= PJSIP_MD5STRLEN);\n\n    AUTH_TRACE_((THIS_FILE, \"Begin creating digest\"));\n\n\tMD5_APPEND( &pms, cred_info->username.ptr, cred_info->username.slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, realm->ptr, realm->slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, cred_info->data.ptr, cred_info->data.slen);\n\tpj_md5_final(&pms, digest);\n\n\tdigestNtoStr(digest, 16, ha1);\n\n    } else if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_DIGEST) {\n\tpj_assert(cred_info->data.slen == 32);\n\tpj_memcpy( ha1, cred_info->data.ptr, cred_info->data.slen );\n    } else {\n\tpj_assert(!\"Invalid data_type\");\n    }\n\n    AUTH_TRACE_((THIS_FILE, \"  ha1=%.32s\", ha1));\n\n    /***\n     *** ha2 = MD5(method \":\" req_uri)\n     ***/\n    pj_md5_init(&pms);\n    MD5_APPEND( &pms, method->ptr, method->slen);\n    MD5_APPEND( &pms, \":\", 1);\n    MD5_APPEND( &pms, ha2, PJSIP_MD5STRLEN);\n\n    /* This is the final response digest. */\n    pj_md5_final(&pms, digest);\n\n    /* Convert digest to string and store in chal->response. */\n    result->slen = PJSIP_MD5STRLEN;\n    digestNtoStr(digest, 16, result->ptr);\n\n    AUTH_TRACE_((THIS_FILE, \"  digest=%.32s\", result->ptr));\n    AUTH_TRACE_((THIS_FILE, \"Digest created\"));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "PJ_DEF(pj_status_t) pjsip_auth_create_digest( pj_str_t *result,\n\t\t\t\t\t      const pj_str_t *nonce,\n\t\t\t\t\t      const pj_str_t *nc,\n\t\t\t\t\t      const pj_str_t *cnonce,\n\t\t\t\t\t      const pj_str_t *qop,\n\t\t\t\t\t      const pj_str_t *uri,\n\t\t\t\t\t      const pj_str_t *realm,\n\t\t\t\t\t      const pjsip_cred_info *cred_info,\n\t\t\t\t\t      const pj_str_t *method)\n{\n    char ha1[PJSIP_MD5STRLEN];\n    char ha2[PJSIP_MD5STRLEN];\n    unsigned char digest[16];\n    pj_md5_context pms;\n\n    pj_assert(result->slen >= PJSIP_MD5STRLEN);\n\n    AUTH_TRACE_((THIS_FILE, \"Begin creating digest\"));\n\n\tMD5_APPEND( &pms, cred_info->username.ptr, cred_info->username.slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, realm->ptr, realm->slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, cred_info->data.ptr, cred_info->data.slen);\n\tpj_md5_final(&pms, digest);\n\n\tdigestNtoStr(digest, 16, ha1);\n\n    } else if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_DIGEST) {\n\tif (cred_info->data.slen != 32) {\n\t    pj_assert(!\"Invalid cred_info data length\");\n\t    pj_bzero(result->ptr, result->slen);\n\t    result->slen = 0;\n\t    return PJ_EINVAL;\n\t}\n\tpj_memcpy( ha1, cred_info->data.ptr, cred_info->data.slen );\n    } else {\n\tpj_assert(!\"Invalid data_type\");\n\tpj_bzero(result->ptr, result->slen);\n\tresult->slen = 0;\n\treturn PJ_EINVAL;\n    }\n\n    AUTH_TRACE_((THIS_FILE, \"  ha1=%.32s\", ha1));\n\n    /***\n     *** ha2 = MD5(method \":\" req_uri)\n     ***/\n    pj_md5_init(&pms);\n    MD5_APPEND( &pms, method->ptr, method->slen);\n    MD5_APPEND( &pms, \":\", 1);\n\n    /* This is the final response digest. */\n    pj_md5_final(&pms, digest);\n\n    /* Convert digest to string and store in chal->response. */\n    result->slen = PJSIP_MD5STRLEN;\n    digestNtoStr(digest, 16, result->ptr);\n\n    AUTH_TRACE_((THIS_FILE, \"  digest=%.32s\", result->ptr));\n    AUTH_TRACE_((THIS_FILE, \"Digest created\"));\n    return PJ_SUCCESS;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    const std::unordered_map<std::string, std::string> &getCookies() const\n    {\n        return cookies();\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "            &getCookies() const\n    {\n        return cookies();\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\terr = -ENOMEM;\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tflush_dcache_page(page);\n\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = tmp;\n\t\treq->num_pages++;\n\n\t\tiov_iter_advance(ii, tmp);\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < req->max_pages && offset == 0);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tflush_dcache_page(page);\n\n\t\tiov_iter_advance(ii, tmp);\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = tmp;\n\t\treq->num_pages++;\n\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < req->max_pages && offset == 0);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void ep2_mul_sim_endom(ep2_t r, const ep2_t p, const bn_t k, ep2_t q,\n\t\tconst bn_t m) {\n\tint i, j, l, _l[4];\n\tbn_t _k[4], _m[4], n, u;\n\tint8_t naf0[4][RLC_FP_BITS + 1];\n\tint8_t naf1[4][RLC_FP_BITS + 1];\n\tep2_t _p[4], _q[4];\n\n\tbn_null(n);\n\tbn_null(u);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(u);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbn_null(_k[i]);\n\t\t\tbn_new(_k[i]);\n\t\t\tbn_null(_m[i]);\n\t\t\tbn_new(_m[i]);\n\t\t\tep2_null(_p[i]);\n\t\t\tep2_null(_q[i]);\n\t\t\tep2_new(_p[i]);\n\t\t\tep2_new(_q[i]);\n\t\t}\n\n\t\tep2_frb(_q[3], _q[2], 1);\n\n\t\tep2_curve_get_ord(n);\n\t\tfp_prime_get_par(u);\n\t\tbn_mod(_k[0], k, n);\n\t\tbn_rec_frb(_k, 4, _k[0], u, n, ep_curve_is_pairf() == EP_BN);\n\t\tbn_mod(_m[0], m, n);\n\t\tbn_rec_frb(_m, 4, _m[0], u, n, ep_curve_is_pairf() == EP_BN);\n\n\t\tl = 0;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\tbn_rec_naf(naf0[i], &_l[i], _k[i], 2);\n\t\t\tif (bn_sign(_k[i]) == RLC_NEG) {\n\t\t\t\tep2_neg(_p[i], _p[i]);\n\t\t\t}\n\t\t\tl = RLC_MAX(l, _l[i]);\n\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\tbn_rec_naf(naf1[i], &_l[i], _m[i], 2);\n\t\t\tif (bn_sign(_m[i]) == RLC_NEG) {\n\t\t\t\tep2_neg(_q[i], _q[i]);\n\t\t\t}\n\t\t\tl = RLC_MAX(l, _l[i]);\n\t\t}\n\n\t\tep2_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tep2_dbl(r, r);\n\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\tif (naf0[j][i] > 0) {\n\t\t\t\t\tep2_add(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t\tif (naf0[j][i] < 0) {\n\t\t\t\t\tep2_sub(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t\tif (naf1[j][i] > 0) {\n\t\t\t\t\tep2_add(r, r, _q[j]);\n\t\t\t\t}\n\t\t\t\tif (naf1[j][i] < 0) {\n\t\t\t}\n\t\t}\n\n\t\t/* Convert r to affine coordinates. */\n\t\tep2_norm(r, r);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(u);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbn_free(_k[i]);\n\t\t\tbn_free(_m[i]);\n\t\t\tep2_free(_p[i]);\n\t\t\tep2_free(_q[i]);\n\t\t}\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void ep2_mul_sim_endom(ep2_t r, const ep2_t p, const bn_t k, ep2_t q,\n\t\tconst bn_t m) {\n\tsize_t l, _l[4];\n\tbn_t _k[4], _m[4], n, u;\n\tint8_t naf0[4][RLC_FP_BITS + 1];\n\tint8_t naf1[4][RLC_FP_BITS + 1];\n\tep2_t _p[4], _q[4];\n\n\tbn_null(n);\n\tbn_null(u);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(u);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tbn_null(_k[i]);\n\t\t\tbn_new(_k[i]);\n\t\t\tbn_null(_m[i]);\n\t\t\tbn_new(_m[i]);\n\t\t\tep2_null(_p[i]);\n\t\t\tep2_null(_q[i]);\n\t\t\tep2_new(_p[i]);\n\t\t\tep2_new(_q[i]);\n\t\t}\n\n\t\tep2_frb(_q[3], _q[2], 1);\n\n\t\tep2_curve_get_ord(n);\n\t\tfp_prime_get_par(u);\n\t\tbn_mod(_k[0], k, n);\n\t\tbn_rec_frb(_k, 4, _k[0], u, n, ep_curve_is_pairf() == EP_BN);\n\t\tbn_mod(_m[0], m, n);\n\t\tbn_rec_frb(_m, 4, _m[0], u, n, ep_curve_is_pairf() == EP_BN);\n\n\t\tl = 0;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\tbn_rec_naf(naf0[i], &_l[i], _k[i], 2);\n\t\t\tif (bn_sign(_k[i]) == RLC_NEG) {\n\t\t\t\tep2_neg(_p[i], _p[i]);\n\t\t\t}\n\t\t\tl = RLC_MAX(l, _l[i]);\n\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\tbn_rec_naf(naf1[i], &_l[i], _m[i], 2);\n\t\t\tif (bn_sign(_m[i]) == RLC_NEG) {\n\t\t\t\tep2_neg(_q[i], _q[i]);\n\t\t\t}\n\t\t\tl = RLC_MAX(l, _l[i]);\n\t\t}\n\n\t\tep2_set_infty(r);\n\t\tfor (int i = l - 1; i >= 0; i--) {\n\t\t\tep2_dbl(r, r);\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tif (naf0[j][i] > 0) {\n\t\t\t\t\tep2_add(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t\tif (naf0[j][i] < 0) {\n\t\t\t\t\tep2_sub(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t\tif (naf1[j][i] > 0) {\n\t\t\t\t\tep2_add(r, r, _q[j]);\n\t\t\t\t}\n\t\t\t\tif (naf1[j][i] < 0) {\n\t\t\t}\n\t\t}\n\n\t\t/* Convert r to affine coordinates. */\n\t\tep2_norm(r, r);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(u);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tbn_free(_k[i]);\n\t\t\tbn_free(_m[i]);\n\t\t\tep2_free(_p[i]);\n\t\t\tep2_free(_q[i]);\n\t\t}\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteSpaceToDepthParams*>(node->builtin_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n#define TF_LITE_SPACE_TO_DEPTH(type, scalar)                               \\\n  tflite::SpaceToDepthParams op_params;                                    \\\n  op_params.block_size = params->block_size;                               \\\n  type::SpaceToDepth(op_params, GetTensorShape(input),                     \\\n                     GetTensorData<scalar>(input), GetTensorShape(output), \\\n                     GetTensorData<scalar>(output))\n  switch (input->type) {  // Already know in/out types are same.\n    case kTfLiteFloat32:\n      if (kernel_type == kReference) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteSpaceToDepthParams*>(node->builtin_data);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n#define TF_LITE_SPACE_TO_DEPTH(type, scalar)                               \\\n  tflite::SpaceToDepthParams op_params;                                    \\\n  op_params.block_size = params->block_size;                               \\\n  type::SpaceToDepth(op_params, GetTensorShape(input),                     \\\n                     GetTensorData<scalar>(input), GetTensorShape(output), \\\n                     GetTensorData<scalar>(output))\n  switch (input->type) {  // Already know in/out types are same.\n    case kTfLiteFloat32:\n      if (kernel_type == kReference) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static size_t ntlm_av_pair_get_next_offset(NTLM_AV_PAIR* pAvPair)\n{\n\treturn ntlm_av_pair_get_len(pAvPair) + sizeof(NTLM_AV_PAIR);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static BOOL ntlm_av_pair_get_next_offset(const NTLM_AV_PAIR* pAvPair, size_t size, size_t* pOffset)\n{\n\tsize_t avLen;\n\tif (!pOffset)\n\t\treturn FALSE;\n\n\tif (!ntlm_av_pair_get_len(pAvPair, size, &avLen))\n\t\treturn FALSE;\n\t*pOffset = avLen + sizeof(NTLM_AV_PAIR);\n\treturn TRUE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long debugctlmsr;\n\n\t/* Record the guest's net vcpu time for enforced NMI injections. */\n\tif (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked))\n\t\tvmx->entry_time = ktime_get();\n\n\t/* Don't enter VMX if guest state is invalid, let the exit handler\n\t   start emulation until we arrive back to a valid state */\n\tif (vmx->emulation_required)\n\t\treturn;\n\n\t}\n\n\tif (vmx->nested.sync_shadow_vmcs) {\n\t\tcopy_vmcs12_to_shadow(vmx);\n\t\tvmx->nested.sync_shadow_vmcs = false;\n\t}\n\n\tif (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n\tif (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n\n\t/* When single-stepping over STI and MOV SS, we must clear the\n\t * corresponding interruptibility bits in the guest state. Otherwise\n\t * vmentry fails as it then expects bit 14 (BS) in pending debug\n\t * exceptions being set, but that's not correct for the guest debugging\n\t * case. */\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvmx_set_interrupt_shadow(vcpu, 0);\n\n\tatomic_switch_perf_msrs(vmx);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long debugctlmsr, cr4;\n\n\t/* Record the guest's net vcpu time for enforced NMI injections. */\n\tif (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked))\n\t\tvmx->entry_time = ktime_get();\n\n\t/* Don't enter VMX if guest state is invalid, let the exit handler\n\t   start emulation until we arrive back to a valid state */\n\tif (vmx->emulation_required)\n\t\treturn;\n\n\n\tif (vmx->nested.sync_shadow_vmcs) {\n\t\tcopy_vmcs12_to_shadow(vmx);\n\t\tvmx->nested.sync_shadow_vmcs = false;\n\t}\n\n\tif (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n\tif (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n\n\tcr4 = read_cr4();\n\tif (unlikely(cr4 != vmx->host_state.vmcs_host_cr4)) {\n\t\tvmcs_writel(HOST_CR4, cr4);\n\t\tvmx->host_state.vmcs_host_cr4 = cr4;\n\t}\n\n\t/* When single-stepping over STI and MOV SS, we must clear the\n\t * corresponding interruptibility bits in the guest state. Otherwise\n\t * vmentry fails as it then expects bit 14 (BS) in pending debug\n\t * exceptions being set, but that's not correct for the guest debugging\n\t * case. */\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvmx_set_interrupt_shadow(vcpu, 0);\n\n\tatomic_switch_perf_msrs(vmx);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    case CURL_SSLVERSION_SSLv3:\n    case CURL_SSLVERSION_SSLv2:\n      failf(data, \"SSL versions not supported\");\n      return CURLE_NOT_BUILT_IN;\n    default:\n      failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    if(SSL_CONN_CONFIG(cipher_list)) {\n      result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list));\n      if(CURLE_OK != result) {\n        failf(data, \"Unable to set ciphers to passed via SSL_CONN_CONFIG\");\n        return result;\n      }\n    }\n\n\n#ifdef HAS_CLIENT_CERT_PATH\n    /* client certificate */\n    if(data->set.ssl.primary.clientcert || data->set.ssl.primary.cert_blob) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    case CURL_SSLVERSION_SSLv3:\n    case CURL_SSLVERSION_SSLv2:\n      failf(data, \"SSL versions not supported\");\n      return CURLE_NOT_BUILT_IN;\n    default:\n      failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    if(SSL_CONN_CONFIG(cipher_list)) {\n      result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list),\n                               BACKEND->algIds);\n      if(CURLE_OK != result) {\n        failf(data, \"Unable to set ciphers to passed via SSL_CONN_CONFIG\");\n        return result;\n      }\n    }\n\n\n#ifdef HAS_CLIENT_CERT_PATH\n    /* client certificate */\n    if(data->set.ssl.primary.clientcert || data->set.ssl.primary.cert_blob) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "raw_copy_to_user(void __user *dst, const void *src, unsigned long size)\n{\n\tint ret = 0;\n\n\tif (!__builtin_constant_p(size))\n\t\treturn copy_user_generic((__force void *)dst, src, size);\n\tswitch (size) {\n\tcase 1:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u8 *)src, (u8 __user *)dst,\n\t\t\t      ret, \"b\", \"b\", \"iq\", 1);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 2:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u16 *)src, (u16 __user *)dst,\n\t\t\t      ret, \"w\", \"w\", \"ir\", 2);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 4:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u32 *)src, (u32 __user *)dst,\n\t\t\t      ret, \"l\", \"k\", \"ir\", 4);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 8:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u64 *)src, (u64 __user *)dst,\n\t\t\t      ret, \"q\", \"\", \"er\", 8);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 10:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u64 *)src, (u64 __user *)dst,\n\t\t\t       ret, \"q\", \"\", \"er\", 10);\n\t\tif (likely(!ret)) {\n\t\t\tasm(\"\":::\"memory\");\n\t\t\t__put_user_asm(4[(u16 *)src], 4 + (u16 __user *)dst,\n\t\t\t\t       ret, \"w\", \"w\", \"ir\", 2);\n\t\t}\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 16:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u64 *)src, (u64 __user *)dst,\n\t\t\t       ret, \"q\", \"\", \"er\", 16);\n\t\tif (likely(!ret)) {\n\t\t\tasm(\"\":::\"memory\");\n\t\t\t__put_user_asm(1[(u64 *)src], 1 + (u64 __user *)dst,\n\t\t\t\t       ret, \"q\", \"\", \"er\", 8);\n\t\t}\n\t\t__uaccess_end();\n\t\treturn ret;\n\tdefault:\n\t\treturn copy_user_generic((__force void *)dst, src, size);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "raw_copy_to_user(void __user *dst, const void *src, unsigned long size)\n{\n\treturn copy_user_generic((__force void *)dst, src, size);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n    char *s, *inbuffer;\n    int length, error = 0;\n    long num,i;\n\n    Inivars();\n    argc--;\n    axohelp = *argv++;\n    if ( argc <= 0 ) {\n        PrintHelp(axohelp);\n\treturn -1;\n    }\n    while ( (*argv)[0] == '-' ) {   /* we have options */\n        s = *argv;\n        if ( s[1] == '-' ) {\n  \t    /* Double \"--\", treat as \"-\" */\n\t    s++;\n        }\n        if ( ( strcmp(s,\"-h\") == 0) || ( strcmp(s,\"-help\") == 0 ) ) {\n  \t    PrintHelp(axohelp);\n\t    return 0;\n                    \"There is NO WARRANTY, to the extent permitted by law.\\n\",\n\t\t    axohelp, VERSION, SUBVERSION, VERSIONDATE);\n   \t    return 0;\n\t}\n        else if ( strcmp( s, \"-V\" ) == 0 ) {\n            VerboseFlag = 1;\n        }\n        else {\n \t    fprintf(stderr,\"%s: Illegal option %s\\n\", axohelp, *argv);\n            PrintHelpPrompt(axohelp);\n\t    return -1;\n        }\n        argc--; argv++;\n        if ( argc <= 0 ) {\n            fprintf(stderr,\"%s: Not enough arguments\\n\",axohelp);\n            PrintHelpPrompt(axohelp);\n\t    return -1;\n        }\n    }\n    if ( argc != 1 ) {\n        fprintf(stderr,\"%s: Too many arguments\\n\",axohelp);\n        PrintHelpPrompt(axohelp);\n        return -1;\n    }\n/*\n    The filename is now in s. We copy it to a separate string and\n    paste on the extension .ax1 (if needed), and construct the\n    name of the output file.\n*/\n    s = *argv;\n    length = strlen(s);\n    inname  = strcpy(malloc((length+5)*sizeof(char)),s);\n    outname = strcpy(malloc((length+5)*sizeof(char)),s);\n    if ( (length > 4) && (strcmp(s+length-4, \".ax1\") == 0) ) {\n        outname[length-1] = '2';\n    }\n    else {\n        strcpy( inname+length, \".ax1\" );\n        strcpy( outname+length, \".ax2\" );\n    }\n    if ( ( inbuffer = ReadInput(inname) ) == 0 ) return(-1);\n    if ( ( outfile = fopen(outname,\"w\") ) == 0 ) {\n        fprintf(stderr,\"%s: Cannot create file %s\\n\",axohelp,outname);\n        exit(-1);\n    }\n    num = ScanForObjects(inbuffer);\n    for ( i = 0; i < num; i++ ) {\n        numobject = i+1;\n        if ( DoOneObject(inputs[i]) < 0 ) { error++; }\n    }\n    fclose(outfile);\n    if ( error > 0 ) {\n        fprintf(stderr,\"%s: %d objects in %s were not translated correctly.\\n\",\n            axohelp,error,inname);\n        return(-1);\n    }\n    return(0);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n    char *s, *inbuffer;\n    int length, error = 0;\n    long num,i;\n\n    Inivars();\n    argc--;\n    axohelp = *argv++;\n    if ( argc <= 0 ) {\n        PrintHelp(axohelp);\n\treturn 1;\n    }\n    while ( (*argv)[0] == '-' ) {   /* we have options */\n        s = *argv;\n        if ( s[1] == '-' ) {\n  \t    /* Double \"--\", treat as \"-\" */\n\t    s++;\n        }\n        if ( ( strcmp(s,\"-h\") == 0) || ( strcmp(s,\"-help\") == 0 ) ) {\n  \t    PrintHelp(axohelp);\n\t    return 0;\n                    \"There is NO WARRANTY, to the extent permitted by law.\\n\",\n\t\t    axohelp, VERSION, SUBVERSION, VERSIONDATE);\n   \t    return 0;\n\t}\n        else if ( strcmp( s, \"-V\" ) == 0 ) {\n            VerboseFlag = 1;\n        }\n        else {\n \t    fprintf(stderr,\"%s: Illegal option %s\\n\", axohelp, *argv);\n            PrintHelpPrompt(axohelp);\n\t    return 1;\n        }\n        argc--; argv++;\n        if ( argc <= 0 ) {\n            fprintf(stderr,\"%s: Not enough arguments\\n\",axohelp);\n            PrintHelpPrompt(axohelp);\n\t    return 1;\n        }\n    }\n    if ( argc != 1 ) {\n        fprintf(stderr,\"%s: Too many arguments\\n\",axohelp);\n        PrintHelpPrompt(axohelp);\n        return 1;\n    }\n/*\n    The filename is now in s. We copy it to a separate string and\n    paste on the extension .ax1 (if needed), and construct the\n    name of the output file.\n*/\n    s = *argv;\n    length = strlen(s);\n    inname  = strcpy(malloc((length+5)*sizeof(char)),s);\n    outname = strcpy(malloc((length+5)*sizeof(char)),s);\n    if ( (length > 4) && (strcmp(s+length-4, \".ax1\") == 0) ) {\n        outname[length-1] = '2';\n    }\n    else {\n        strcpy( inname+length, \".ax1\" );\n        strcpy( outname+length, \".ax2\" );\n    }\n    if ( ( inbuffer = ReadInput(inname) ) == 0 ) return(1);\n    if ( ( outfile = fopen(outname,\"w\") ) == 0 ) {\n        fprintf(stderr,\"%s: Cannot create file %s\\n\",axohelp,outname);\n        exit(1);\n    }\n    num = ScanForObjects(inbuffer);\n    for ( i = 0; i < num; i++ ) {\n        numobject = i+1;\n        if ( DoOneObject(inputs[i]) < 0 ) { error++; }\n    }\n    fclose(outfile);\n    if ( error > 0 ) {\n        fprintf(stderr,\"%s: %d objects in %s were not translated correctly.\\n\",\n            axohelp,error,inname);\n        return(1);\n    }\n    return(0);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint retval = 0;\n\tint bytes_read = 0;\n\tchar in_buffer[20];\n\tunsigned long flags;\n\n\tdev = file->private_data;\n\n\tmutex_lock(&dev->io_mutex);\n\tif (!dev->interface) {\t\t/* already disconnected */\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tbytes_read = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (*ppos < bytes_read) {\n\t\tif (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))\n\t\t\tretval = -EFAULT;\n\t\telse {\n\t\t\tretval = bytes_read - *ppos;\n\t\t\t*ppos += bytes_read;\n\t\t}\n\t}\n\nexit:\n\tmutex_unlock(&dev->io_mutex);\n\treturn retval;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint len = 0;\n\tchar in_buffer[20];\n\tunsigned long flags;\n\n\tdev = file->private_data;\n\n\tmutex_lock(&dev->io_mutex);\n\tif (!dev->interface) {\t\t/* already disconnected */\n\t\tmutex_unlock(&dev->io_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tlen = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tmutex_unlock(&dev->io_mutex);\n\n\treturn simple_read_from_buffer(buffer, count, ppos, in_buffer, len);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"ablkcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_ablkcipher.geniv ?: \"<default>\");\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tstrncpy(rblkcipher.type, \"ablkcipher\", sizeof(rblkcipher.type));\n\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \"<default>\",\n\t\tsizeof(rblkcipher.geniv));\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n                    return NJS_ERROR;\n                }\n\n                p--;\n            }\n\n        } else {\n            /* UTF-8 string. */\n\n            p = njs_string_offset(string_prop.start, end, from);\n            p = njs_utf8_next(p, end);\n\n            i = from + 1;\n\n            while (i-- > to) {\n                pos = njs_utf8_prev(p);\n\n                /* This cannot fail. */\n                (void) njs_string_new(vm, &character, pos, p - pos , 1);\n\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n                    return NJS_ERROR;\n                }\n\n                p--;\n            }\n\n        } else {\n            /* UTF-8 string. */\n\n            p = NULL;\n            i = from + 1;\n\n            if (i > to) {\n                p = njs_string_offset(string_prop.start, end, from);\n                p = njs_utf8_next(p, end);\n            }\n\n            while (i-- > to) {\n                pos = njs_utf8_prev(p);\n\n                /* This cannot fail. */\n                (void) njs_string_new(vm, &character, pos, p - pos , 1);\n\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\nskipabs:\n\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s\", rootfs->mount,\n\t\t aux + offset);\n\tif (r < 0 || r >= MAXPATHLEN) {\n\t\tWARN(\"pathnme too long for '%s'\", mntent->mnt_dir);\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\nskipabs:\n\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s\", rootfs->mount,\n\t\t aux + offset);\n\tif (r < 0 || r >= MAXPATHLEN) {\n\t\tWARN(\"pathnme too long for '%s'\", mntent->mnt_dir);\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, rootfs->mount);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int ref_pic_list_struct(GetBitContext *gb, RefPicListStruct *rpl)\n{\n    uint32_t delta_poc_st, strp_entry_sign_flag = 0;\n    rpl->ref_pic_num = get_ue_golomb_long(gb);\n    if (rpl->ref_pic_num > 0) {\n        delta_poc_st = get_ue_golomb_long(gb);\n\n        rpl->ref_pics[0] = delta_poc_st;\n        if (rpl->ref_pics[0] != 0) {\n            strp_entry_sign_flag = get_bits(gb, 1);\n\n            rpl->ref_pics[0] *= 1 - (strp_entry_sign_flag << 1);\n        }\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int ref_pic_list_struct(EVCParserSPS *sps, GetBitContext *gb, RefPicListStruct *rpl)\n{\n    uint32_t delta_poc_st, strp_entry_sign_flag = 0;\n    rpl->ref_pic_num = get_ue_golomb_long(gb);\n\n    if ((unsigned)rpl->ref_pic_num  > sps->sps_max_dec_pic_buffering_minus1)\n        return AVERROR_INVALIDDATA;\n\n    if (rpl->ref_pic_num > 0) {\n        delta_poc_st = get_ue_golomb_long(gb);\n\n        rpl->ref_pics[0] = delta_poc_st;\n        if (rpl->ref_pics[0] != 0) {\n            strp_entry_sign_flag = get_bits(gb, 1);\n\n            rpl->ref_pics[0] *= 1 - (strp_entry_sign_flag << 1);\n        }\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n\n    /* we have an error following */\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    reason = malloc((uint64_t)reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    if(reasonLen > 1<<20) {\n      rfbClientLog(\"VNC connection failed, but sent reason length of %u exceeds limit of 1MB\",(unsigned int)reasonLen);\n      return;\n    }\n    reason = malloc(reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "mptctl_readtest (unsigned long arg)\n{\n\tstruct mpt_ioctl_test __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_test\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to read in mpt_ioctl_test struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_readtest() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_readtest called.\\n\",\n\t    ioc->name));\n\t/* Fill in the data and return the structure to the calling\n\t * program\n\t */\n\n#ifdef MFCNT\n\tkarg.chip_type = ioc->mfcnt;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "mptctl_readtest (MPT_ADAPTER *ioc, unsigned long arg)\n{\n\tstruct mpt_ioctl_test __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_test\t karg;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to read in mpt_ioctl_test struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_readtest called.\\n\",\n\t    ioc->name));\n\t/* Fill in the data and return the structure to the calling\n\t * program\n\t */\n\n#ifdef MFCNT\n\tkarg.chip_type = ioc->mfcnt;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "NOEXPORT void reload_config() {\n    static int delay=10; /* 10ms */\n#ifdef HAVE_CHROOT\n    struct stat sb;\n#endif /* HAVE_CHROOT */\n\n    if(options_parse(CONF_RELOAD)) {\n        s_log(LOG_ERR, \"Failed to reload the configuration file\");\n        return;\n    }\n    unbind_ports();\n    log_flush(LOG_MODE_BUFFER);\n    /* we don't close SINK_SYSLOG if chroot is enabled and\n     * there is no /dev/log inside it, which could allow\n     * openlog(3) to reopen the syslog socket later */\n    if(global_options.chroot_dir && stat(\"/dev/log\", &sb))\n        log_close(SINK_OUTFILE);\n    else\n#endif /* HAVE_CHROOT */\n        log_close(SINK_SYSLOG|SINK_OUTFILE);\n    /* there is no race condition here:\n     * client threads are not allowed to use global options */\n    options_free();\n    options_apply();\n    /* we hope that a sane openlog(3) implementation won't\n     * attempt to reopen /dev/log if it's already open */\n    log_open(SINK_SYSLOG|SINK_OUTFILE);\n    log_flush(LOG_MODE_CONFIGURED);\n    ui_config_reloaded();\n    /* we use \"|\" instead of \"||\" to attempt initialization of both subsystems */\n    if(bind_ports() | exec_connect_start()) {\n        s_poll_sleep(delay/1000, delay%1000); /* sleep to avoid log trashing */\n        signal_post(SIGNAL_RELOAD_CONFIG); /* retry */\n        delay*=2;\n        if(delay > 10000) /* 10s */\n            delay=10000;\n    } else {\n        delay=10; /* 10ms */\n    }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "NOEXPORT void reload_config() {\n    static int delay=10; /* default of 10ms */\n#ifdef HAVE_CHROOT\n    struct stat sb;\n#endif /* HAVE_CHROOT */\n\n    if(options_parse(CONF_RELOAD)) {\n        s_log(LOG_ERR, \"Failed to reload the configuration file\");\n        return;\n    }\n    unbind_ports();\n    log_flush(LOG_MODE_BUFFER);\n    /* we don't close SINK_SYSLOG if chroot is enabled and\n     * there is no /dev/log inside it, which could allow\n     * openlog(3) to reopen the syslog socket later */\n    if(global_options.chroot_dir && stat(\"/dev/log\", &sb))\n        log_close(SINK_OUTFILE);\n    else\n#endif /* HAVE_CHROOT */\n        log_close(SINK_SYSLOG|SINK_OUTFILE);\n    /* there is no race condition here:\n     * client threads are not allowed to use global options */\n    options_free(1); /* free the current options */\n    options_apply(); /* apply the new options */\n    /* we hope that a sane openlog(3) implementation won't\n     * attempt to reopen /dev/log if it's already open */\n    log_open(SINK_SYSLOG|SINK_OUTFILE);\n    log_flush(LOG_MODE_CONFIGURED);\n    ui_config_reloaded();\n    /* we use \"|\" instead of \"||\" to attempt initialization of both subsystems */\n    if(bind_ports() | exec_connect_start()) { /* failed */\n        unbind_ports();\n        s_poll_sleep(delay/1000, delay%1000); /* sleep to avoid log trashing */\n        signal_post(SIGNAL_RELOAD_CONFIG); /* retry */\n        delay*=2;\n        if(delay > 10000) /* limit to 10s */\n            delay=10000;\n    } else { /* success */\n        delay=10; /* reset back to 10ms */\n    }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    flb_sds_t out_buf;\n    msgpack_sbuffer mp_sbuf;\n    msgpack_packer mp_pck;\n    int ret;\n    char *buf = NULL;\n    size_t buf_size;\n    int root_type = MSGPACK_OBJECT_ARRAY;\n    msgpack_unpacked result;\n    flb_sds_t error_msg = NULL;\n    int response = 200;\n    flb_sds_t input_name;\n    msgpack_object_array *inputs = NULL;\n    size_t off = 0;\n    int i;\n    \n\n    /* initialize buffers */\n    msgpack_sbuffer_init(&mp_sbuf);\n    msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);\n\n    msgpack_unpacked_init(&result);\n    ret = flb_pack_json(request->data.data, request->data.len, &buf, &buf_size,\n                        &root_type, NULL);\n    if (ret == -1) {\n        goto unpack_error;\n        goto unpack_error;\n    }\n\n    for (i = 0; i < result.data.via.map.size; i++) {\n        if (result.data.via.map.ptr[i].val.type != MSGPACK_OBJECT_ARRAY) {\n            continue;\n        }\n        if (result.data.via.map.ptr[i].key.type != MSGPACK_OBJECT_STR) {\n            continue;\n        }\n        if (result.data.via.map.ptr[i].key.via.str.size < strlen(\"inputs\")) {\n            continue;\n        }\n        if (strncmp(result.data.via.map.ptr[i].key.via.str.ptr, \"inputs\", strlen(\"inputs\"))) {\n            continue;\n        }\n        inputs = &result.data.via.map.ptr[i].val.via.array;\n    }\n\n    if (inputs == NULL) {\n        response = 503;\n        error_msg = flb_sds_create(\"inputs not found\");\n        goto unpack_error;\n    }\n    \n    msgpack_pack_map(&mp_pck, 2);\n\n    msgpack_pack_str_with_body(&mp_pck, \"inputs\", strlen(\"inputs\"));\n    msgpack_pack_map(&mp_pck, inputs->size);\n\n    for (i = 0; i < inputs->size; i++) {\n        input_name = flb_sds_create_len(inputs->ptr[i].via.str.ptr, inputs->ptr[i].via.str.size);\n        msgpack_pack_str_with_body(&mp_pck, input_name, flb_sds_len(input_name));\n\n        if (inputs->ptr[i].type != MSGPACK_OBJECT_STR) {\n            msgpack_pack_map(&mp_pck, 1);\n            msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n            msgpack_pack_str_with_body(&mp_pck, \"error\", strlen(\"error\"));\n        }\n        else {\n            if (request->method == MK_METHOD_POST || request->method == MK_METHOD_GET) {\n                ret = msgpack_params_enable_trace((struct flb_hs *)data, &result, input_name);\n                if (ret != 0) {\n                    msgpack_pack_map(&mp_pck, 2);\n                    msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n                    msgpack_pack_str_with_body(&mp_pck, \"error\", strlen(\"error\"));\n                    msgpack_pack_str_with_body(&mp_pck, \"returncode\", strlen(\"returncode\"));\n                    msgpack_pack_int64(&mp_pck, ret);\n                }\n                else {\n                    msgpack_pack_map(&mp_pck, 1);\n                    msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n                    msgpack_pack_str_with_body(&mp_pck, \"ok\", strlen(\"ok\"));\n                }\n            }\n            else if (request->method == MK_METHOD_DELETE) {\n                disable_trace_input((struct flb_hs *)data, input_name);\n            }\n            else {\n                msgpack_pack_map(&mp_pck, 2);\n                msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n                msgpack_pack_str_with_body(&mp_pck, \"error\", strlen(\"error\"));\n                msgpack_pack_str_with_body(&mp_pck, \"message\", strlen(\"message\"));\n                msgpack_pack_str_with_body(&mp_pck, \"method not allowed\", strlen(\"method not allowed\"));\n            }\n        }\n    }\n\n    msgpack_pack_str_with_body(&mp_pck, \"result\", strlen(\"result\"));\nunpack_error:\n    if (buf != NULL) {\n        flb_free(buf);\n    }\n    msgpack_unpacked_destroy(&result);\n    if (response == 404) {\n        msgpack_pack_map(&mp_pck, 1);\n        msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n        msgpack_pack_str_with_body(&mp_pck, \"not found\", strlen(\"not found\"));\n    }\n    else if (response == 503) {\n        msgpack_pack_map(&mp_pck, 2);\n        msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n        msgpack_pack_str_with_body(&mp_pck, \"error\", strlen(\"error\"));\n        msgpack_pack_str_with_body(&mp_pck, \"message\", strlen(\"message\"));\n        if (error_msg) {\n            msgpack_pack_str_with_body(&mp_pck, error_msg, flb_sds_len(error_msg));\n            flb_sds_destroy(error_msg);\n        }\n        else {\n            msgpack_pack_str_with_body(&mp_pck, \"unknown error\", strlen(\"unknown error\"));\n        }\n    }\n    else {\n        msgpack_pack_map(&mp_pck, 1);\n        msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n        msgpack_pack_str_with_body(&mp_pck, \"ok\", strlen(\"ok\"));\n    }\n\n    /* Export to JSON */\n    out_buf = flb_msgpack_raw_to_json_sds(mp_sbuf.data, mp_sbuf.size);\n    if (out_buf == NULL) {\n        out_buf = flb_sds_create(\"serialization error\");\n    }\n    msgpack_sbuffer_destroy(&mp_sbuf);\n\n    mk_http_status(request, response);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    flb_sds_t out_buf;\n    msgpack_sbuffer mp_sbuf;\n    msgpack_packer mp_pck;\n    int ret;\n    char *buf = NULL;\n    size_t buf_size;\n    int root_type = MSGPACK_OBJECT_ARRAY;\n    msgpack_unpacked result;\n    flb_sds_t error_msg = NULL;\n    int response = 200;\n    const char *input_name;\n    ssize_t input_nlen;\n    msgpack_object_array *inputs = NULL;\n    size_t off = 0;\n    int i;\n\n    /* initialize buffers */\n    msgpack_sbuffer_init(&mp_sbuf);\n    msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);\n\n    msgpack_unpacked_init(&result);\n    ret = flb_pack_json(request->data.data, request->data.len, &buf, &buf_size,\n                        &root_type, NULL);\n    if (ret == -1) {\n        goto unpack_error;\n        goto unpack_error;\n    }\n\n    for (i = 0; i < result.data.via.map.size; i++) {\n        if (result.data.via.map.ptr[i].val.type != MSGPACK_OBJECT_ARRAY) {\n            continue;\n        }\n        if (result.data.via.map.ptr[i].key.type != MSGPACK_OBJECT_STR) {\n            continue;\n        }\n        if (result.data.via.map.ptr[i].key.via.str.size < STR_INPUTS_LEN) {\n            continue;\n        }\n        if (strncmp(result.data.via.map.ptr[i].key.via.str.ptr, STR_INPUTS, STR_INPUTS_LEN)) {\n            continue;\n        }\n        inputs = &result.data.via.map.ptr[i].val.via.array;\n    }\n\n    if (inputs == NULL) {\n        response = 503;\n        error_msg = flb_sds_create(\"inputs not found\");\n        goto unpack_error;\n    }\n\n    msgpack_pack_map(&mp_pck, 2);\n\n    msgpack_pack_str_with_body(&mp_pck, STR_INPUTS, STR_INPUTS_LEN);\n    msgpack_pack_map(&mp_pck, inputs->size);\n\n    for (i = 0; i < inputs->size; i++) {\n\n        if (inputs->ptr[i].type != MSGPACK_OBJECT_STR || inputs->ptr[i].via.str.ptr == NULL) {\n            response = 503;\n            error_msg = flb_sds_create(\"invalid input\");\n            msgpack_sbuffer_clear(&mp_sbuf);\n            goto unpack_error;\n        }\n    }\n\n    for (i = 0; i < inputs->size; i++) {\n\n        input_name = inputs->ptr[i].via.str.ptr;\n        input_nlen = inputs->ptr[i].via.str.size;\n\n        msgpack_pack_str_with_body(&mp_pck, input_name, input_nlen);\n\n        if (request->method == MK_METHOD_POST) {\n\n            ret = msgpack_params_enable_trace((struct flb_hs *)data, &result,\n                                              input_name, input_nlen);\n\n            if (ret != 0) {\n                msgpack_pack_map(&mp_pck, 2);\n                msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n                msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_ERROR, HTTP_RESULT_ERROR_LEN);\n                msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_RETURNCODE,\n                                           HTTP_FIELD_RETURNCODE_LEN);\n                msgpack_pack_int64(&mp_pck, ret);\n            }\n            else {\n                msgpack_pack_map(&mp_pck, 1);\n                msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n                msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n            }\n        }\n        else if (request->method == MK_METHOD_DELETE) {\n            disable_trace_input((struct flb_hs *)data, input_name, input_nlen);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n        }\n        else {\n            msgpack_pack_map(&mp_pck, 2);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_ERROR, HTTP_RESULT_ERROR_LEN);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_MESSAGE, HTTP_FIELD_MESSAGE_LEN);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_METHODNOTALLOWED,\n                                       HTTP_RESULT_METHODNOTALLOWED_LEN);\n        }\n    }\n\n    msgpack_pack_str_with_body(&mp_pck, \"result\", strlen(\"result\"));\nunpack_error:\n    if (buf != NULL) {\n        flb_free(buf);\n    }\n    msgpack_unpacked_destroy(&result);\n    if (response == 404) {\n        msgpack_pack_map(&mp_pck, 1);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_NOTFOUND, HTTP_RESULT_NOTFOUND_LEN);\n    }\n    else if (response == 503) {\n        msgpack_pack_map(&mp_pck, 2);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_MESSAGE, HTTP_FIELD_MESSAGE_LEN);\n        if (error_msg) {\n            msgpack_pack_str_with_body(&mp_pck, error_msg, flb_sds_len(error_msg));\n            flb_sds_destroy(error_msg);\n        }\n        else {\n            msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_UNKNOWNERROR,\n                                       HTTP_RESULT_UNKNOWNERROR_LEN);\n        }\n    }\n    else {\n        msgpack_pack_map(&mp_pck, 1);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n    }\n\n    /* Export to JSON */\n    out_buf = flb_msgpack_raw_to_json_sds(mp_sbuf.data, mp_sbuf.size);\n    if (out_buf == NULL) {\n        out_buf = flb_sds_create(\"serialization error\");\n    }\n    msgpack_sbuffer_destroy(&mp_sbuf);\n\n    mk_http_status(request, response);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "bool SecurityManager::discovered_participant(IdentityToken&& remote_identity_token,\n        const GUID_t& remote_participant_key)\n{\n    IdentityHandle* remote_identity_handle = nullptr;\n    SecurityException exception;\n    AuthenticationStatus auth_status = AUTHENTICATION_INIT;\n\n    // Find information\n    mutex_.lock();\n    auto dp_it = discovered_participants_.find(remote_participant_key);\n\n    if(dp_it == discovered_participants_.end())\n    {\n            return false;\n        }\n    }\n    else\n    {\n        auth_status = dp_it->second.get_auth_status();\n\n        if(auth_status == AUTHENTICATION_INIT)\n            return false;\n    }\n\n    if(auth_status == AUTHENTICATION_REQUEST_NOT_SEND)\n    {\n        remote_identity_handle = dp_it->second.get_identity_handle();\n        assert(remote_identity_handle);\n    }\n    mutex_.unlock();\n\n    bool returnedValue = true;\n\n    // Maybe send request.\n    if(remote_identity_handle != nullptr)\n    {\n        returnedValue = on_request_not_send(remote_participant_key, remote_identity_handle);\n    }\n\n    return returnedValue;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "bool SecurityManager::discovered_participant(IdentityToken&& remote_identity_token,\n        const GUID_t& remote_participant_key)\n{\n    if(authentication_plugin_ == nullptr)\n        return true;\n\n    IdentityHandle* remote_identity_handle = nullptr;\n    SecurityException exception;\n    AuthenticationStatus auth_status = AUTHENTICATION_INIT;\n\n    // Find information\n    mutex_.lock();\n    auto dp_it = discovered_participants_.find(remote_participant_key);\n\n    if(dp_it == discovered_participants_.end())\n    {\n        }\n    }\n    else\n    {\n        auth_status = dp_it->second.get_auth_status();\n\n        if(auth_status == AUTHENTICATION_INIT)\n            return false;\n    }\n\n    int64_t last_sequence_number = 0;\n\n    if(auth_status == AUTHENTICATION_REQUEST_NOT_SEND)\n    {\n        remote_identity_handle = dp_it->second.get_identity_handle();\n        assert(remote_identity_handle);\n        last_sequence_number = dp_it->second.get_last_sequence_number();\n\n    }\n    mutex_.unlock();\n\n    bool returnedValue = true;\n\n    // Maybe send request.\n    if(remote_identity_handle != nullptr)\n    {\n        returnedValue = on_process_handshake(remote_participant_key, AUTHENTICATION_REQUEST_NOT_SEND,\n                MessageIdentity(), HandshakeMessageToken(),\n                remote_identity_handle, nullptr, last_sequence_number);\n    }\n\n    return returnedValue;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "spnego_gss_inquire_sec_context_by_oid(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_OID desired_object,\n\t\tgss_buffer_set_t *data_set)\n{\n\tOM_uint32 ret;\n\tret = gss_inquire_sec_context_by_oid(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    data_set);\n\treturn (ret);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "spnego_gss_inquire_sec_context_by_oid(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_OID desired_object,\n\t\tgss_buffer_set_t *data_set)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\t/* There are no SPNEGO-specific OIDs for this function. */\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_UNAVAILABLE);\n\n\tret = gss_inquire_sec_context_by_oid(minor_status,\n\t\t\t    sc->ctx_handle,\n\t\t\t    desired_object,\n\t\t\t    data_set);\n\treturn (ret);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "inline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0) {\n      return 4;\n    }\n  }\n  return 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "inline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0 && l >= 2) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0 && l >= 3) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0 && l >= 4) {\n      return 4;\n    }\n  }\n  return 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void TestJlCompress::extractDir_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::newRow(\"simple\") << \"jlextdir.zip\" << (\n            QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\");\n    QTest::newRow(\"separate dir\") << \"sepdir.zip\" << (\n            QStringList() << \"laj/\" << \"laj/lajfile.txt\");\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void TestJlCompress::extractDir_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::addColumn<QStringList>(\"expectedExtracted\");\n    QTest::newRow(\"simple\") << \"jlextdir.zip\"\n        << (QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\")\n        << (QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\");\n    QTest::newRow(\"separate dir\") << \"sepdir.zip\"\n        << (QStringList() << \"laj/\" << \"laj/lajfile.txt\")\n        << (QStringList() << \"laj/\" << \"laj/lajfile.txt\");\n    QTest::newRow(\"Zip Slip\") << \"zipslip.zip\"\n        << (QStringList() << \"test0.txt\" << \"../zipslip.txt\")\n        << (QStringList() << \"test0.txt\");\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tif (ctx->might_cancel) {\n\t\tctx->might_cancel = false;\n\t\tspin_lock(&cancel_lock);\n\t\tlist_del_rcu(&ctx->clist);\n\t\tspin_unlock(&cancel_lock);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tspin_lock(&ctx->cancel_lock);\n\t__timerfd_remove_cancel(ctx);\n\tspin_unlock(&ctx->cancel_lock);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static inline __attribute__((unused)) ssize_t fiobj_send_free(intptr_t uuid,\n                                                              FIOBJ o) {\n  fio_str_info_s s = fiobj_obj2cstr(o);\n  return fio_write2(uuid, .data.buffer = (void *)(o),\n                    .offset = (((intptr_t)s.data) - ((intptr_t)(o))),\n                    .length = s.len, .after.dealloc = fiobj4sock_dealloc);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static inline __attribute__((unused)) ssize_t fiobj_send_free(intptr_t uuid,\n                                                              FIOBJ o) {\n  fio_str_info_s s = fiobj_obj2cstr(o);\n  return fio_write2(uuid, .data.buffer = (void *)(o),\n                    .offset = (uintptr_t)(((intptr_t)s.data) - ((intptr_t)(o))),\n                    .length = s.len, .after.dealloc = fiobj4sock_dealloc);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rpcomp;\n\n\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"pcomp\");\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rpcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rpcomp;\n\n\tstrncpy(rpcomp.type, \"pcomp\", sizeof(rpcomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rpcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "   if(index < CPSW_ALE_MAX_ENTRIES)\n   {\n      //Clear the contents of the entry\n      entry.word2 = 0;\n      entry.word1 = 0;\n      entry.word0 = 0;\n\n      //Update the ALE table\n      am335xEthWriteEntry(index, &entry);\n\n      //Sucessful processing\n      error = NO_ERROR;\n   }\n   else\n   {\n      //Entry not found\n      error = ERROR_NOT_FOUND;\n   }\n\n   //Return status code\n   return error;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "   if(index < CPSW_ALE_MAX_ENTRIES)\n   {\n      //Clear the contents of the entry\n      entry.word2 = 0;\n      entry.word1 = 0;\n      entry.word0 = 0;\n\n      //Update the ALE table\n      am335xEthWriteEntry(index, &entry);\n\n      //Successful processing\n      error = NO_ERROR;\n   }\n   else\n   {\n      //Entry not found\n      error = ERROR_NOT_FOUND;\n   }\n\n   //Return status code\n   return error;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int cp_cmlhs_onv(const g1_t r, const g2_t s, const g1_t sig[], const g2_t z[],\n\t\tconst g1_t a[], const g1_t c[], const bn_t msg, const char *data,\n\t\tconst g1_t h, const gt_t vk, const g2_t y[], const g2_t pk[],\n\t\tsize_t slen, int bls) {\n\tg1_t g1;\n\tg2_t g2;\n\tgt_t e, u, v;\n\tbn_t k, n;\n\tint len, dlen = strlen(data), result = 1;\n\tuint8_t *buf = RLC_ALLOCA(uint8_t, 1 + 8 * RLC_FP_BYTES + dlen);\n\n\tg1_null(g1);\n\tg2_null(g2);\n\tgt_null(e);\n\tgt_null(u);\n\tgt_null(v);\n\tbn_null(k);\n\tbn_null(n);\n\n\tRLC_TRY {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int cp_cmlhs_onv(const g1_t r, const g2_t s, const g1_t sig[], const g2_t z[],\n\t\tconst g1_t a[], const g1_t c[], const bn_t msg, const char *data,\n\t\tconst g1_t h, const gt_t vk, const g2_t y[], const g2_t pk[],\n\t\tsize_t slen, int bls) {\n\tg1_t g1;\n\tg2_t g2;\n\tgt_t e, u, v;\n\tbn_t k, n;\n\tsize_t len, dlen = strlen(data);\n\tuint8_t *buf = RLC_ALLOCA(uint8_t, 1 + 8 * RLC_FP_BYTES + dlen);\n\tint result = 1;\n\n\tg1_null(g1);\n\tg2_null(g2);\n\tgt_null(e);\n\tgt_null(u);\n\tgt_null(v);\n\tbn_null(k);\n\tbn_null(n);\n\n\tRLC_TRY {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n        r = dlopen_elf();\n        if (r < 0)\n                return r;\n\n        r = RET_NERRNO(pipe2(error_pipe, O_CLOEXEC|O_NONBLOCK));\n        if (r < 0)\n                return r;\n\n        if (ret) {\n                r = RET_NERRNO(pipe2(return_pipe, O_CLOEXEC));\n                if (r < 0)\n                        return r;\n        }\n\n        if (ret_package_metadata) {\n                r = RET_NERRNO(pipe2(json_pipe, O_CLOEXEC));\n                if (r < 0)\n                        return r;\n        }\n\n        /* Parsing possibly malformed data is crash-happy, so fork. In case we crash,\n         * the core file will not be lost, and the messages will still be attached to\n         * the journal. Reading the elf object might be slow, but it still has an upper\n         * bound since the core files have an upper size limit. It's also not doing any\n         * system call or interacting with the system in any way, besides reading from\n         * the file descriptor and writing into these four pipes. */\n                        r = RET_NERRNO(prctl(PR_SET_DUMPABLE, 0));\n                        if (r < 0)\n                                goto child_fail;\n                }\n\n                r = parse_elf(fd, executable, ret ? &buf : NULL, ret_package_metadata ? &package_metadata : NULL);\n                if (r < 0)\n                        goto child_fail;\n\n                if (buf) {\n                        r = loop_write(return_pipe[1], buf, strlen(buf), false);\n                        if (r < 0)\n                                goto child_fail;\n\n                        return_pipe[1] = safe_close(return_pipe[1]);\n                }\n\n                if (package_metadata) {\n                        _cleanup_fclose_ FILE *json_out = NULL;\n\n                        json_out = take_fdopen(&json_pipe[1], \"w\");\n                        if (!json_out) {\n                                r = -errno;\n                                goto child_fail;\n                        }\n\n                        json_variant_dump(package_metadata, JSON_FORMAT_FLUSH, json_out, NULL);\n                }\n\n                _exit(EXIT_SUCCESS);\n\n        child_fail:\n                (void) write(error_pipe[1], &r, sizeof(r));\n                _exit(EXIT_FAILURE);\n        }\n\n        error_pipe[1] = safe_close(error_pipe[1]);\n\n        if (ret_package_metadata) {\n                _cleanup_fclose_ FILE *json_in = NULL;\n\n                json_in = take_fdopen(&json_pipe[0], \"r\");\n                if (!json_in)\n                        return -errno;\n\n                r = json_parse_file(json_in, NULL, 0, &package_metadata, NULL, NULL);\n                if (r < 0 && r != -ENODATA) /* ENODATA: json was empty, so we got nothing, but that's ok */\n                        return r;\n        }\n\n        if (ret)\n                *ret = TAKE_PTR(buf);\n        if (ret_package_metadata)\n                *ret_package_metadata = TAKE_PTR(package_metadata);\n\n        return 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n        r = dlopen_elf();\n        if (r < 0)\n                return r;\n\n        r = RET_NERRNO(pipe2(error_pipe, O_CLOEXEC|O_NONBLOCK));\n        if (r < 0)\n                return r;\n\n        if (ret) {\n                r = RET_NERRNO(pipe2(return_pipe, O_CLOEXEC|O_NONBLOCK));\n                if (r < 0)\n                        return r;\n        }\n\n        if (ret_package_metadata) {\n                r = RET_NERRNO(pipe2(json_pipe, O_CLOEXEC|O_NONBLOCK));\n                if (r < 0)\n                        return r;\n        }\n\n        /* Parsing possibly malformed data is crash-happy, so fork. In case we crash,\n         * the core file will not be lost, and the messages will still be attached to\n         * the journal. Reading the elf object might be slow, but it still has an upper\n         * bound since the core files have an upper size limit. It's also not doing any\n         * system call or interacting with the system in any way, besides reading from\n         * the file descriptor and writing into these four pipes. */\n                        r = RET_NERRNO(prctl(PR_SET_DUMPABLE, 0));\n                        if (r < 0)\n                                goto child_fail;\n                }\n\n                r = parse_elf(fd, executable, ret ? &buf : NULL, ret_package_metadata ? &package_metadata : NULL);\n                if (r < 0)\n                        goto child_fail;\n\n                if (buf) {\n                        size_t len = strlen(buf);\n\n                        if (len > COREDUMP_PIPE_MAX) {\n                                /* This is iffy. A backtrace can be a few hundred kilobytes, but too much is\n                                 * too much. Let's log a warning and ignore the rest. */\n                                log_warning(\"Generated backtrace is %zu bytes (more than the limit of %u bytes), backtrace will be truncated.\",\n                                            len, COREDUMP_PIPE_MAX);\n                                len = COREDUMP_PIPE_MAX;\n                        }\n\n                        /* Bump the space for the returned string.\n                         * Failure is ignored, because partial output is still useful. */\n                        (void) fcntl(return_pipe[1], F_SETPIPE_SZ, len);\n\n                        r = loop_write(return_pipe[1], buf, len, false);\n                        if (r == -EAGAIN)\n                                log_warning(\"Write failed, backtrace will be truncated.\");\n                        else if (r < 0)\n                                goto child_fail;\n\n                        return_pipe[1] = safe_close(return_pipe[1]);\n                }\n\n                if (package_metadata) {\n                        _cleanup_fclose_ FILE *json_out = NULL;\n\n                        /* Bump the space for the returned string. We don't know how much space we'll need in\n                         * advance, so we'll just try to write as much as possible and maybe fail later. */\n                        (void) fcntl(json_pipe[1], F_SETPIPE_SZ, COREDUMP_PIPE_MAX);\n\n                        json_out = take_fdopen(&json_pipe[1], \"w\");\n                        if (!json_out) {\n                                r = -errno;\n                                goto child_fail;\n                        }\n\n                        r = json_variant_dump(package_metadata, JSON_FORMAT_FLUSH, json_out, NULL);\n                        if (r < 0)\n                                log_warning_errno(r, \"Failed to write JSON package metadata, ignoring: %m\");\n                }\n\n                _exit(EXIT_SUCCESS);\n\n        child_fail:\n                (void) write(error_pipe[1], &r, sizeof(r));\n                _exit(EXIT_FAILURE);\n        }\n\n        error_pipe[1] = safe_close(error_pipe[1]);\n\n        if (ret_package_metadata) {\n                _cleanup_fclose_ FILE *json_in = NULL;\n\n                json_in = take_fdopen(&json_pipe[0], \"r\");\n                if (!json_in)\n                        return -errno;\n\n                r = json_parse_file(json_in, NULL, 0, &package_metadata, NULL, NULL);\n                if (r < 0 && r != -ENODATA) /* ENODATA: json was empty, so we got nothing, but that's ok */\n                        log_warning_errno(r, \"Failed to read or parse json metadata, ignoring: %m\");\n        }\n\n        if (ret)\n                *ret = TAKE_PTR(buf);\n        if (ret_package_metadata)\n                *ret_package_metadata = TAKE_PTR(package_metadata);\n\n        return 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void SmallVectorBase::grow_pod(void *FirstEl, size_t MinCapacity,\n                               size_t TSize) {\n  // Ensure we can fit the new capacity in 32 bits.\n  if (MinCapacity > UINT32_MAX)\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n\n  size_t NewCapacity = 2 * capacity() + 1; // Always grow.\n  NewCapacity =\n      std::min(std::max(NewCapacity, MinCapacity), size_t(UINT32_MAX));\n\n  void *NewElts;\n  if (BeginX == FirstEl) {\n    NewElts = safe_malloc(NewCapacity * TSize);\n\n    // Copy the elements over.  No need to run dtors on PODs.\n    memcpy(NewElts, this->BeginX, size() * TSize);\n  } else {\n    // If this wasn't grown from the inline copy, grow the allocated space.\n    NewElts = safe_realloc(this->BeginX, NewCapacity * TSize);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void SmallVectorBase::grow_pod(void *FirstEl, size_t MinCapacity,\n                               size_t TSize) {\n  constexpr size_t MinGrowth = 1;\n  size_t NewCapacity = 2 * capacity() + MinGrowth; // Always grow.\n  NewCapacity = static_cast<unsigned>(std::max(NewCapacity, MinCapacity));\n\n  // Ensure that NewCapacity did not overflow an unsigned int,\n  // and that the capacity in bytes will not overflow a size_t.\n  if (NewCapacity <= this->capacity() ||\n      NewCapacity < MinCapacity ||\n      NewCapacity > size_t(-1) / TSize)\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n\n  void *NewElts;\n  if (BeginX == FirstEl) {\n    NewElts = safe_malloc(NewCapacity * TSize);\n\n    // Copy the elements over.  No need to run dtors on PODs.\n    memcpy(NewElts, this->BeginX, size() * TSize);\n  } else {\n    // If this wasn't grown from the inline copy, grow the allocated space.\n    NewElts = safe_realloc(this->BeginX, NewCapacity * TSize);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\n\t/* check the quota and attach the new data */\n\tzap = upayload;\n\n\tret = key_payload_reserve(key, datalen);\n\n\tif (ret == 0) {\n\t\t/* attach the new data, displacing the old */\n\t\tzap = key->payload.data[0];\n\t\trcu_assign_keypointer(key, upayload);\n\t\tkey->expiry = 0;\n\t}\n\n\tif (zap)\n\t\tkfree_rcu(zap, rcu);\n\nerror:\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\n\t/* check the quota and attach the new data */\n\tzap = upayload;\n\n\tret = key_payload_reserve(key, datalen);\n\n\tif (ret == 0) {\n\t\t/* attach the new data, displacing the old */\n\t\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\t\tzap = key->payload.data[0];\n\t\telse\n\t\t\tzap = NULL;\n\t\trcu_assign_keypointer(key, upayload);\n\t\tkey->expiry = 0;\n\t}\n\n\tif (zap)\n\t\tkfree_rcu(zap, rcu);\n\nerror:\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "size_t compile_tree(struct filter_op **fop)\n{\n   int i = 1;\n   struct filter_op *array = NULL;\n   struct unfold_elm *ue;\n\n   BUG_IF(tree_root == NULL);\n  \n   fprintf(stdout, \" Unfolding the meta-tree \");\n   fflush(stdout);\n     \n   /* start the recursion on the tree */\n   unfold_blk(&tree_root);\n\n   fprintf(stdout, \" done.\\n\\n\");\n\n   /* substitute the virtual labels with real offsets */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "size_t compile_tree(struct filter_op **fop)\n{\n   int i = 1;\n   struct filter_op *array = NULL;\n   struct unfold_elm *ue;\n\n   // invalid file\n   if (tree_root == NULL)\n      return 0;\n  \n   fprintf(stdout, \" Unfolding the meta-tree \");\n   fflush(stdout);\n     \n   /* start the recursion on the tree */\n   unfold_blk(&tree_root);\n\n   fprintf(stdout, \" done.\\n\\n\");\n\n   /* substitute the virtual labels with real offsets */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "modify_principal_2_svc(mprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    restriction_t                   *rp;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n                                          arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_modify_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "modify_principal_2_svc(mprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    restriction_t                   *rp;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_modify_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\torder = get_order(num);\nretry:\n\tret_sz = 1 << (PAGE_SHIFT + order);\n\n\tfor (k = 0, rem_sz = blk_size; rem_sz > 0 && k < mx_sc_elems;\n\t     k++, rem_sz -= ret_sz) {\n\n\t\tnum = (rem_sz > scatter_elem_sz_prev) ?\n\t\t\tscatter_elem_sz_prev : rem_sz;\n\n\t\tschp->pages[k] = alloc_pages(gfp_mask, order);\n\t\tif (!schp->pages[k])\n\t\t\tgoto out;\n\n\t\tif (num == scatter_elem_sz_prev) {\n\t\t\tif (unlikely(ret_sz > scatter_elem_sz_prev)) {\n\t\t\t\tscatter_elem_sz = ret_sz;\n\t\t\t\tscatter_elem_sz_prev = ret_sz;\n\t\t\t}\n\t\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\torder = get_order(num);\nretry:\n\tret_sz = 1 << (PAGE_SHIFT + order);\n\n\tfor (k = 0, rem_sz = blk_size; rem_sz > 0 && k < mx_sc_elems;\n\t     k++, rem_sz -= ret_sz) {\n\n\t\tnum = (rem_sz > scatter_elem_sz_prev) ?\n\t\t\tscatter_elem_sz_prev : rem_sz;\n\n\t\tschp->pages[k] = alloc_pages(gfp_mask | __GFP_ZERO, order);\n\t\tif (!schp->pages[k])\n\t\t\tgoto out;\n\n\t\tif (num == scatter_elem_sz_prev) {\n\t\t\tif (unlikely(ret_sz > scatter_elem_sz_prev)) {\n\t\t\t\tscatter_elem_sz = ret_sz;\n\t\t\t\tscatter_elem_sz_prev = ret_sz;\n\t\t\t}\n\t\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n  /* The argument should consist of 2 comma separated values:\n     1) resolution\n     2) tile number\n     3) pixel index in x direction\n     4) pixel index in y direction\n  */\n\n  if( session->loglevel >= 3 ) (*session->logfile) << \"SPECTRA handler reached\" << endl;\n\n  int resolution, tile, x, y;\n\n\n  // Time this command\n  if( session->loglevel >= 2 ) command_timer.start();\n\n\n  // Parse the argument list\n  string arg = argument;\n  int delimitter = arg.find( \",\" );\n  resolution = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  tile = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  x = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  y = atoi( arg.substr(0,arg.length()).c_str() );\n\n  if( session->loglevel >= 5 ){ \n    (*session->logfile) << \"SPECTRA :: resolution: \" << resolution\n\t\t\t<< \", tile: \" << tile\n\t\t\t<< \", x: \" << x\n\t\t\t<< \", y: \" << y << endl;\n  }\n\n  // Make sure our x,y coordinates are within the tile dimensions\n  if( x < 0 || x >= (int)(*session->image)->getTileWidth() ||",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n  /* The argument should consist of 2 comma separated values:\n     1) resolution\n     2) tile number\n     3) pixel index in x direction\n     4) pixel index in y direction\n  */\n\n  if( session->loglevel >= 3 ) (*session->logfile) << \"SPECTRA handler reached\" << endl;\n\n\n  // Make sure we have set our image\n  this->session = session;\n  checkImage();\n\n\n  // Time this command\n  if( session->loglevel >= 2 ) command_timer.start();\n\n\n  // Parse the argument list\n  string arg = argument;\n  int delimitter = arg.find( \",\" );\n  int resolution = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  int tile = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  int x = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  int y = atoi( arg.substr(0,arg.length()).c_str() );\n\n  if( session->loglevel >= 5 ){ \n    (*session->logfile) << \"SPECTRA :: resolution: \" << resolution\n\t\t\t<< \", tile: \" << tile\n\t\t\t<< \", x: \" << x\n\t\t\t<< \", y: \" << y << endl;\n  }\n\n  // Make sure our x,y coordinates are within the tile dimensions\n  if( x < 0 || x >= (int)(*session->image)->getTileWidth() ||",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tmnt->mnt_group_id = old->mnt_group_id;\n\n\tif ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {\n\t\terr = mnt_alloc_group_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);\n\t/* Don't allow unprivileged users to change mount flags */\n\tif ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n\n\t/* Don't allow unprivileged users to reveal what is under a mount */\n\tif ((flag & CL_UNPRIVILEGED) && list_empty(&old->mnt_expire))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCKED;\n\n\tatomic_inc(&sb->s_active);\n\tmnt->mnt.mnt_sb = sb;\n\tmnt->mnt.mnt_root = dget(root);\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tmnt->mnt_group_id = old->mnt_group_id;\n\n\tif ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {\n\t\terr = mnt_alloc_group_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);\n\t/* Don't allow unprivileged users to change mount flags */\n\tif (flag & CL_UNPRIVILEGED) {\n\t\tmnt->mnt.mnt_flags |= MNT_LOCK_ATIME;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_READONLY)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NODEV)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NODEV;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOSUID)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOSUID;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOEXEC)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOEXEC;\n\t}\n\n\t/* Don't allow unprivileged users to reveal what is under a mount */\n\tif ((flag & CL_UNPRIVILEGED) && list_empty(&old->mnt_expire))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCKED;\n\n\tatomic_inc(&sb->s_active);\n\tmnt->mnt.mnt_sb = sb;\n\tmnt->mnt.mnt_root = dget(root);\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n\t\tconst void *data, size_t datalen)\n{\n\tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n\t__be32 *pdata = (__be32 *)data;\n\n\tif (*pdata == ctx->from) {\n\t\tpr_debug(\"%s: %pI4 to %pI4\\n\", __func__,\n\t\t\t (void *)&ctx->from, (void *)&ctx->to);\n\n\t\tif (*ctx->check)\n\t\t\tfast_csum(ctx, (unsigned char *)data - ctx->begin);\n\t\t*pdata = ctx->to;\n\t}\n\n\treturn 1;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n\t\tconst void *data, size_t datalen)\n{\n\tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n\t__be32 *pdata;\n\n\tif (datalen != 4)\n\t\treturn -EINVAL;\n\tpdata = (__be32 *)data;\n\tif (*pdata == ctx->from) {\n\t\tpr_debug(\"%s: %pI4 to %pI4\\n\", __func__,\n\t\t\t (void *)&ctx->from, (void *)&ctx->to);\n\n\t\tif (*ctx->check)\n\t\t\tfast_csum(ctx, (unsigned char *)data - ctx->begin);\n\t\t*pdata = ctx->to;\n\t}\n\n\treturn 1;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        case YYJSON_TYPE_OBJ: {\n            usize len = unsafe_yyjson_get_len(lhs);\n            if (len != unsafe_yyjson_get_len(rhs)) return false;\n            if (len > 0) {\n                yyjson_obj_iter iter;\n                yyjson_obj_iter_init(rhs, &iter);\n                lhs = unsafe_yyjson_get_first(lhs);\n                while (len-- > 0) {\n                    rhs = yyjson_obj_iter_getn(&iter, lhs->uni.str,\n                                               unsafe_yyjson_get_len(lhs));\n                    if (!rhs || !unsafe_yyjson_equals(lhs + 1, rhs))\n                        return false;\n                    lhs = unsafe_yyjson_get_next(lhs + 1);\n                }\n            }\n            /* yyjson allows duplicate keys, so the check may be inaccurate */\n            return true;\n        }\n        \n        case YYJSON_TYPE_ARR: {\n            usize len = unsafe_yyjson_get_len(lhs);\n            if (len != unsafe_yyjson_get_len(rhs)) return false;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        case YYJSON_TYPE_OBJ: {\n            usize len = unsafe_yyjson_get_len(lhs);\n            if (len != unsafe_yyjson_get_len(rhs)) return false;\n            if (len > 0) {\n                yyjson_obj_iter iter;\n                yyjson_obj_iter_init(rhs, &iter);\n                lhs = unsafe_yyjson_get_first(lhs);\n                while (len-- > 0) {\n                    rhs = yyjson_obj_iter_getn(&iter, lhs->uni.str,\n                                               unsafe_yyjson_get_len(lhs));\n                    if (!rhs) return false;\n                    if (!unsafe_yyjson_equals(lhs + 1, rhs)) return false;\n                    lhs = unsafe_yyjson_get_next(lhs + 1);\n                }\n            }\n            /* yyjson allows duplicate keys, so the check may be inaccurate */\n            return true;\n        }\n        \n        case YYJSON_TYPE_ARR: {\n            usize len = unsafe_yyjson_get_len(lhs);\n            if (len != unsafe_yyjson_get_len(rhs)) return false;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                                      return_list, return_size,\n                                      persistent ? 1 : 0);\n  } else {\n    String enc = encoding.toString();\n    ret = php_mb_parse_encoding_list(enc.data(), enc.size(),\n                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list && *return_list) {\n      free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                                      return_list, return_size,\n                                      persistent ? 1 : 0);\n  } else {\n    String enc = encoding.toString();\n    ret = php_mb_parse_encoding_list(enc.data(), enc.size(),\n                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list && *return_list) {\n      req::free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static s32 gf_media_vvc_read_sps_bs_internal(GF_BitStream *bs, VVCState *vvc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id;\n\tu32 i, CtbSizeY;\n\tVVC_SPS *sps;\n\tu8 sps_ptl_dpb_hrd_params_present_flag;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\tsps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif (sps_id >= 16) {\n\t\treturn -1;\n\t}\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif (vps_id >= 16) {\n\t\treturn -1;\n\t}\n\tif (!vps_id && !vvc->vps[0].state) {\n\t\tvvc->vps[0].state = 1;\n\t\tvvc->vps[0].num_ptl = 1;\n\t\tvvc->vps[0].max_layers = 1;\n\t\tvvc->vps[0].all_layers_independent = 1;\n\t}\n\n\tsps = &vvc->sps[sps_id];",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static s32 gf_media_vvc_read_sps_bs_internal(GF_BitStream *bs, VVCState *vvc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id;\n\tu32 i, CtbSizeY;\n\tVVC_SPS *sps;\n\tu8 sps_ptl_dpb_hrd_params_present_flag;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\tsps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif ((sps_id<0) || (sps_id >= 16)) {\n\t\treturn -1;\n\t}\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif ((vps_id<0) || (vps_id >= 16)) {\n\t\treturn -1;\n\t}\n\tif (!vps_id && !vvc->vps[0].state) {\n\t\tvvc->vps[0].state = 1;\n\t\tvvc->vps[0].num_ptl = 1;\n\t\tvvc->vps[0].max_layers = 1;\n\t\tvvc->vps[0].all_layers_independent = 1;\n\t}\n\n\tsps = &vvc->sps[sps_id];",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tif (!controller)\n\t\t\treturn -EIO;\n\n\t\tcgroup = find_cgroup_in_path(path);\n\t\tif (!cgroup) {\n\t\t\t/* this is just /cgroup/controller, return its contents */\n\t\t\tcgroup = \"/\";\n\t\t}\n\t}\n\n\tif (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {\n\t\treturn -EACCES;\n\t}\n\n\t/* we'll free this at cg_releasedir */\n\tdir_info = malloc(sizeof(*dir_info));\n\tif (!dir_info)\n\t\treturn -ENOMEM;\n\tdir_info->controller = must_copy_string(controller);\n\tdir_info->cgroup = must_copy_string(cgroup);\n\tdir_info->type = LXC_TYPE_CGDIR;\n\tdir_info->buf = NULL;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tif (!controller)\n\t\t\treturn -EIO;\n\n\t\tcgroup = find_cgroup_in_path(path);\n\t\tif (!cgroup) {\n\t\t\t/* this is just /cgroup/controller, return its contents */\n\t\t\tcgroup = \"/\";\n\t\t}\n\t}\n\n\tif (cgroup) {\n\t\tif (!caller_may_see_dir(fc->pid, controller, cgroup))\n\t\t\treturn -ENOENT;\n\t\tif (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))\n\t\t\treturn -EACCES;\n\t}\n\n\t/* we'll free this at cg_releasedir */\n\tdir_info = malloc(sizeof(*dir_info));\n\tif (!dir_info)\n\t\treturn -ENOMEM;\n\tdir_info->controller = must_copy_string(controller);\n\tdir_info->cgroup = must_copy_string(cgroup);\n\tdir_info->type = LXC_TYPE_CGDIR;\n\tdir_info->buf = NULL;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tint ret;\n\tint i;\n\n\t*rcmd = NULL;\n\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tif (ret)\n\t\treturn -EFAULT;\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > 33)\n\t\t\t/* the command may now also take up the space\n\t\t\t * initially intended for the reply & the\n\t\t\t * reply count. Needed for long 82078 commands\n\t\t\t * such as RESTORE, which takes ... 17 command\n\t\t\t * bytes. Murphy's law #137: When you reserve\n\t\t\t * 16 bytes for a structure, you'll one day\n\t\t\t * discover that you really need 17...\n\t\t\t */\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < 16; i++)\n\t\tptr->reply[i] = 0;\n\tptr->resultcode = 0;\n\tptr->kernel_data = NULL;\n\n\tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tint i;\n\n\t*rcmd = NULL;\n\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tptr->kernel_data = NULL;\n\tif (ret)\n\t\treturn -EFAULT;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > 33)\n\t\t\t/* the command may now also take up the space\n\t\t\t * initially intended for the reply & the\n\t\t\t * reply count. Needed for long 82078 commands\n\t\t\t * such as RESTORE, which takes ... 17 command\n\t\t\t * bytes. Murphy's law #137: When you reserve\n\t\t\t * 16 bytes for a structure, you'll one day\n\t\t\t * discover that you really need 17...\n\t\t\t */\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < 16; i++)\n\t\tptr->reply[i] = 0;\n\tptr->resultcode = 0;\n\n\tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,\n\t\tv4l2_kioctl func)\n{\n\tchar\tsbuf[128];\n\tvoid    *mbuf = NULL;\n\tvoid\t*parg = NULL;\n\tlong\terr  = -EINVAL;\n\tint     is_ext_ctrl;\n\tsize_t  ctrls_size = 0;\n\tvoid __user *user_ptr = NULL;\n\n\tis_ext_ctrl = (cmd == VIDIOC_S_EXT_CTRLS || cmd == VIDIOC_G_EXT_CTRLS ||\n\t\t       cmd == VIDIOC_TRY_EXT_CTRLS);\n\n\t/*  Copy arguments into temp kernel buffer  */\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_NONE:\n\t\tparg = NULL;\n\t\tbreak;\n\tcase _IOC_READ:\n\tcase _IOC_WRITE:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n\t\t\tparg = sbuf;\n\t\t} else {\n\t\t\t/* too big to allocate from stack */\n\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\n\t\t\tif (NULL == mbuf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tparg = mbuf;\n\t\t}\n\n\t\terr = -EFAULT;\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE)\n\t\t\tif (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tif (is_ext_ctrl) {\n\t\tstruct v4l2_ext_controls *p = parg;\n\n\t\t/* In case of an error, tell the caller that it wasn't\n\t\t   a specific control that caused it. */\n\t\tp->error_idx = p->count;\n\t\tuser_ptr = (void __user *)p->controls;\n\t\tif (p->count) {\n\t\t\tctrls_size = sizeof(struct v4l2_ext_control) * p->count;\n\t\t\t/* Note: v4l2_ext_controls fits in sbuf[] so mbuf is still NULL. */\n\t\t\tmbuf = kmalloc(ctrls_size, GFP_KERNEL);\n\t\t\terr = -ENOMEM;\n\t\t\tif (NULL == mbuf)\n\t\t\t\tgoto out_ext_ctrl;\n\t\t\terr = -EFAULT;\n\t\t\tif (copy_from_user(mbuf, user_ptr, ctrls_size))\n\t\t\t\tgoto out_ext_ctrl;\n\t\t\tp->controls = mbuf;\n\t\t}\n\t}\n\n\t/* call driver */\n\terr = func(file, cmd, parg);\n\tif (err == -ENOIOCTLCMD)\n\t\terr = -EINVAL;\n\tif (is_ext_ctrl) {\n\t\tstruct v4l2_ext_controls *p = parg;\n\n\t\tp->controls = (void *)user_ptr;\n\t\tif (p->count && err == 0 && copy_to_user(user_ptr, mbuf, ctrls_size))\n\t\t\terr = -EFAULT;\n\t\tgoto out_ext_ctrl;\n\t}\n\tif (err < 0)\n\t\tgoto out;\n\nout_ext_ctrl:\n\t/*  Copy results into user buffer  */\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_READ:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\t}\n\nout:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,\n\t       v4l2_kioctl func)\n{\n\tchar\tsbuf[128];\n\tvoid    *mbuf = NULL;\n\tvoid\t*parg = (void *)arg;\n\tlong\terr  = -EINVAL;\n\tbool\thas_array_args;\n\tsize_t  array_size = 0;\n\tvoid __user *user_ptr = NULL;\n\tvoid\t**kernel_ptr = NULL;\n\n\t/*  Copy arguments into temp kernel buffer  */\n\tif (_IOC_DIR(cmd) != _IOC_NONE) {\n\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n\t\t\tparg = sbuf;\n\t\t} else {\n\t\t\t/* too big to allocate from stack */\n\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\n\t\t\tif (NULL == mbuf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tparg = mbuf;\n\t\t}\n\n\t\terr = -EFAULT;\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tunsigned long n = cmd_input_size(cmd);\n\n\t\t\tif (copy_from_user(parg, (void __user *)arg, n))\n\t\t\t\tgoto out;\n\n\t\t\t/* zero out anything we don't copy from userspace */\n\t\t\tif (n < _IOC_SIZE(cmd))\n\t\t\t\tmemset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n);\n\t\t} else {\n\t\t\t/* read-only ioctl */\n\t\t\tmemset(parg, 0, _IOC_SIZE(cmd));\n\t\t}\n\t}\n\n\terr = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr);\n\tif (err < 0)\n\t\tgoto out;\n\thas_array_args = err;\n\n\tif (has_array_args) {\n\t\t/*\n\t\t * When adding new types of array args, make sure that the\n\t\t * parent argument to ioctl (which contains the pointer to the\n\t\t * array) fits into sbuf (so that mbuf will still remain\n\t\t * unused up to here).\n\t\t */\n\t\tmbuf = kmalloc(array_size, GFP_KERNEL);\n\t\terr = -ENOMEM;\n\t\tif (NULL == mbuf)\n\t\t\tgoto out_array_args;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(mbuf, user_ptr, array_size))\n\t\t\tgoto out_array_args;\n\t\t*kernel_ptr = mbuf;\n\t}\n\n\t/* Handles IOCTL */\n\terr = func(file, cmd, parg);\n\tif (err == -ENOIOCTLCMD)\n\t\terr = -EINVAL;\n\n\tif (has_array_args) {\n\t\t*kernel_ptr = user_ptr;\n\t\tif (copy_to_user(user_ptr, mbuf, array_size))\n\t\t\terr = -EFAULT;\n\t\tgoto out_array_args;\n\t}\n\tif (err < 0)\n\t\tgoto out;\n\nout_array_args:\n\t/*  Copy results into user buffer  */\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_READ:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\t}\n\nout:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (type == kGenericOptimized) {\n    optimized_ops::Floor(GetTensorShape(input), GetTensorData<float>(input),\n                         GetTensorShape(output), GetTensorData<float>(output));\n  } else {\n    reference_ops::Floor(GetTensorShape(input), GetTensorData<float>(input),\n                         GetTensorShape(output), GetTensorData<float>(output));\n  }\n\n  return kTfLiteOk;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  if (type == kGenericOptimized) {\n    optimized_ops::Floor(GetTensorShape(input), GetTensorData<float>(input),\n                         GetTensorShape(output), GetTensorData<float>(output));\n  } else {\n    reference_ops::Floor(GetTensorShape(input), GetTensorData<float>(input),\n                         GetTensorShape(output), GetTensorData<float>(output));\n  }\n\n  return kTfLiteOk;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void fp54_exp_cyc_sps(fp54_t c, const fp54_t a, const int *b, int len, int sign) {\n\tint i, j, k, w = len;\n    fp54_t t, *u = RLC_ALLOCA(fp54_t, w);\n\n\tif (len == 0) {\n\t\tRLC_FREE(u);\n\t\tfp54_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp54_null(t);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void fp54_exp_cyc_sps(fp54_t c, const fp54_t a, const int *b, size_t len,\n\t\tint sign) {\n\tsize_t i, j, k, w = len;\n    fp54_t t, *u = RLC_ALLOCA(fp54_t, w);\n\n\tif (len == 0) {\n\t\tRLC_FREE(u);\n\t\tfp54_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp54_null(t);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "NTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,\n                               size_t* pcbAvPairListRemaining)\n{\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\tpAvPair = NULL;\n\n\twhile (pAvPair)\n\t{\n\t\tUINT16 id = ntlm_av_pair_get_id(pAvPair);\n\n\t\tif (id == AvId)\n\t\t\tbreak;\n\t\tif (id == MsvAvEOL)\n\t\t{\n\t\t\tpAvPair = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "NTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,\n                               size_t* pcbAvPairListRemaining)\n{\n\tUINT16 id;\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\tpAvPair = NULL;\n\n\twhile (pAvPair && ntlm_av_pair_get_id(pAvPair, cbAvPair, &id))\n\t{\n\t\tif (id == AvId)\n\t\t\tbreak;\n\t\tif (id == MsvAvEOL)\n\t\t{\n\t\t\tpAvPair = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t\t/* create space for UDP/IP header */\n\t\tskb_put(skb, fragheaderlen + transhdrlen);\n\n\t\t/* initialize network header pointer */\n\t\tskb_reset_network_header(skb);\n\n\t\t/* initialize protocol header pointer */\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\n\t\t/* specify the length of each IP datagram fragment */\n\t\tskb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\t__skb_queue_tail(queue, skb);\n\t}\n\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tskb_reserve(skb, hh_len);\n\n\t\t/* create space for UDP/IP header */\n\t\tskb_put(skb, fragheaderlen + transhdrlen);\n\n\t\t/* initialize network header pointer */\n\t\tskb_reset_network_header(skb);\n\n\t\t/* initialize protocol header pointer */\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->csum = 0;\n\n\n\t\t__skb_queue_tail(queue, skb);\n\t} else if (skb_is_gso(skb)) {\n\t\tgoto append;\n\t}\n\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t/* specify the length of each IP datagram fragment */\n\tskb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;\n\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\nappend:\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)\n{\n    int\t\tj;\n    int\t\tc;\n    int\t\tsaved_did_emsg;\n    char_u\t*name = name_arg;\n    int\t\tis_global = FALSE;\n    char_u\t*p;\n    char_u\t*arg;\n    char_u\t*whitep;\n    char_u\t*line_arg = NULL;\n\t    goto ret_free;\n\t}\n    }\n\n    // This may get more lines and make the pointers into the first line\n    // invalid.\n    ++p;\n    if (get_function_args(&p, ')', &newargs,\n\t\t\teap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,\n\t\t\t NULL, &varargs, &default_args, eap->skip,\n\t\t\t eap, line_to_free) == FAIL)\n\tgoto errret_2;\n    whitep = p;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\t// find the return type: :def Func(): type\n\tif (*skipwhite(p) == ':')\n\t{\n\t    if (*p != ':')\n\t    {\n\n\tmsg_putchar('\\n');\t    // don't overwrite the function name\n\tcmdline_row = msg_row;\n    }\n\n    // Save the starting line number.\n    sourcing_lnum_top = SOURCING_LNUM;\n\n    // Do not define the function when getting the body fails and when\n    // skipping.\n    if (get_function_body(eap, &newlines, line_arg, line_to_free) == FAIL\n\t    || eap->skip)\n\tgoto erret;\n\n    /*\n     * If there are no errors, add the function\n     */\n    if (fudi.fd_dict == NULL)\n    {\n\thashtab_T\t*ht;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free)\n{\n    int\t\tj;\n    int\t\tc;\n    int\t\tsaved_did_emsg;\n    char_u\t*name = name_arg;\n    int\t\tis_global = FALSE;\n    char_u\t*p;\n    char_u\t*arg;\n    char_u\t*whitep;\n    char_u\t*line_arg = NULL;\n\t    goto ret_free;\n\t}\n    }\n\n    // This may get more lines and make the pointers into the first line\n    // invalid.\n    ++p;\n    if (get_function_args(&p, ')', &newargs,\n\t\t\teap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,\n\t\t\t NULL, &varargs, &default_args, eap->skip,\n\t\t\t eap, lines_to_free) == FAIL)\n\tgoto errret_2;\n    whitep = p;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\t// find the return type: :def Func(): type\n\tif (*skipwhite(p) == ':')\n\t{\n\t    if (*p != ':')\n\t    {\n\n\tmsg_putchar('\\n');\t    // don't overwrite the function name\n\tcmdline_row = msg_row;\n    }\n\n    // Save the starting line number.\n    sourcing_lnum_top = SOURCING_LNUM;\n\n    // Do not define the function when getting the body fails and when\n    // skipping.\n    if (get_function_body(eap, &newlines, line_arg, lines_to_free) == FAIL\n\t    || eap->skip)\n\tgoto erret;\n\n    /*\n     * If there are no errors, add the function\n     */\n    if (fudi.fd_dict == NULL)\n    {\n\thashtab_T\t*ht;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (!np)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpdev = of_find_device_by_node(np);\n\tof_node_put(np);\n\tif (!pdev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tqmp = platform_get_drvdata(pdev);\n\n\treturn qmp ? qmp : ERR_PTR(-EPROBE_DEFER);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (!np)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpdev = of_find_device_by_node(np);\n\tof_node_put(np);\n\tif (!pdev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tqmp = platform_get_drvdata(pdev);\n\n\tif (!qmp) {\n\t\tput_device(&pdev->dev);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\treturn qmp;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "PJ_DEF(pj_status_t) pjmedia_wav_player_port_create( pj_pool_t *pool,\n\t\t\t\t\t\t     const char *filename,\n\t\t\t\t\t\t     unsigned ptime,\n\t\t\t\t\t\t     unsigned options,\n\t\t\t\t\t\t     pj_ssize_t buff_size,\n\t\t\t\t\t\t     pjmedia_port **p_port )\n{\n    pjmedia_wave_hdr wave_hdr;\n    pj_ssize_t size_to_read, size_read;\n    struct file_reader_port *fport;\n    pjmedia_audio_format_detail *ad;\n    pj_off_t pos;\n    pj_str_t name;\n    unsigned samples_per_frame;\n    pj_status_t status = PJ_SUCCESS;\n\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && filename && p_port, PJ_EINVAL);\n    if (fport->fsize <= sizeof(pjmedia_wave_hdr)) {\n\treturn PJMEDIA_ENOTVALIDWAVE;\n    }\n\n    /* Open file. */\n    status = pj_file_open( pool, filename, PJ_O_RDONLY, &fport->fd);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Read the file header plus fmt header only. */\n    size_read = size_to_read = sizeof(wave_hdr) - 8;\n    status = pj_file_read( fport->fd, &wave_hdr, &size_read);\n    if (status != PJ_SUCCESS) {\n\tpj_file_close(fport->fd);\n\treturn status;\n    }\n    if (size_read != size_to_read) {\n\tpj_file_close(fport->fd);\n\treturn PJMEDIA_ENOTVALIDWAVE;\n    }\n\n    }\n\n    fport->fmt_tag = (pjmedia_wave_fmt_tag)wave_hdr.fmt_hdr.fmt_tag;\n    fport->bytes_per_sample = (pj_uint16_t) \n\t\t\t      (wave_hdr.fmt_hdr.bits_per_sample / 8);\n\n    /* If length of fmt_header is greater than 16, skip the remaining\n     * fmt header data.\n     */\n    if (wave_hdr.fmt_hdr.len > 16) {\n\tsize_to_read = wave_hdr.fmt_hdr.len - 16;\n\tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n\t    pj_file_close(fport->fd);\n\t    return status;\n\t}\n    }\n\n    /* Repeat reading the WAVE file until we have 'data' chunk */\n    for (;;) {\n\tpjmedia_wave_subchunk subchunk;\n\t/* Normalize endianness */\n\tPJMEDIA_WAVE_NORMALIZE_SUBCHUNK(&subchunk);\n\n\t/* Break if this is \"data\" chunk */\n\tif (subchunk.id == PJMEDIA_DATA_TAG) {\n\t    wave_hdr.data_hdr.data = PJMEDIA_DATA_TAG;\n\t    wave_hdr.data_hdr.len = subchunk.len;\n\t    break;\n\t}\n\n\t/* Otherwise skip the chunk contents */\n\tsize_to_read = subchunk.len;\n\tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n\t    pj_file_close(fport->fd);\n\t    return status;\n\t}\n    }\n\n    /* Current file position now points to start of data */\n    status = pj_file_getpos(fport->fd, &pos);\n    fport->start_data = (unsigned)pos;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "PJ_DEF(pj_status_t) pjmedia_wav_player_port_create( pj_pool_t *pool,\n\t\t\t\t\t\t     const char *filename,\n\t\t\t\t\t\t     unsigned ptime,\n\t\t\t\t\t\t     unsigned options,\n\t\t\t\t\t\t     pj_ssize_t buff_size,\n\t\t\t\t\t\t     pjmedia_port **p_port )\n{\n    pjmedia_wave_hdr wave_hdr;\n    pj_ssize_t size_read;\n    pj_off_t size_to_read;\n    struct file_reader_port *fport;\n    pjmedia_audio_format_detail *ad;\n    pj_off_t pos;\n    pj_str_t name;\n    unsigned samples_per_frame;\n    pj_status_t status = PJ_SUCCESS;\n\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && filename && p_port, PJ_EINVAL);\n    if (fport->fsize <= sizeof(pjmedia_wave_hdr)) {\n\treturn PJMEDIA_ENOTVALIDWAVE;\n    }\n\n    /* Open file. */\n    status = pj_file_open( pool, filename, PJ_O_RDONLY, &fport->fd);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Read the file header plus fmt header only. */\n    size_to_read = size_read = sizeof(wave_hdr) - 8;\n    status = pj_file_read( fport->fd, &wave_hdr, &size_read);\n    if (status != PJ_SUCCESS) {\n\tpj_file_close(fport->fd);\n\treturn status;\n    }\n    if (size_read != size_to_read) {\n\tpj_file_close(fport->fd);\n\treturn PJMEDIA_ENOTVALIDWAVE;\n    }\n\n    }\n\n    fport->fmt_tag = (pjmedia_wave_fmt_tag)wave_hdr.fmt_hdr.fmt_tag;\n    fport->bytes_per_sample = (pj_uint16_t) \n\t\t\t      (wave_hdr.fmt_hdr.bits_per_sample / 8);\n\n    /* If length of fmt_header is greater than 16, skip the remaining\n     * fmt header data.\n     */\n    if (wave_hdr.fmt_hdr.len > 16) {\n\tPJ_CHECK_OVERFLOW_UINT32_TO_LONG(wave_hdr.fmt_hdr.len - 16,\n\t\t      pj_file_close(fport->fd); return PJMEDIA_ENOTVALIDWAVE;);\n\tsize_to_read = (pj_off_t)wave_hdr.fmt_hdr.len - 16;\n\tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n\t    pj_file_close(fport->fd);\n\t    return status;\n\t}\n    }\n\n    /* Repeat reading the WAVE file until we have 'data' chunk */\n    for (;;) {\n\tpjmedia_wave_subchunk subchunk;\n\tPJMEDIA_WAVE_NORMALIZE_SUBCHUNK(&subchunk);\n\n\t/* Break if this is \"data\" chunk */\n\tif (subchunk.id == PJMEDIA_DATA_TAG) {\n\t    wave_hdr.data_hdr.data = PJMEDIA_DATA_TAG;\n\t    wave_hdr.data_hdr.len = subchunk.len;\n\t    break;\n\t}\n\n\t/* Otherwise skip the chunk contents */\n\tPJ_CHECK_OVERFLOW_UINT32_TO_LONG(subchunk.len, \n\t\t      pj_file_close(fport->fd); return PJMEDIA_ENOTVALIDWAVE;);\n\tsize_to_read = subchunk.len;\n\n\tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n\t    pj_file_close(fport->fd);\n\t    return status;\n\t}\n    }\n\n    /* Current file position now points to start of data */\n    status = pj_file_getpos(fport->fd, &pos);\n    fport->start_data = (unsigned)pos;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    /*\n      Rewind list, removing any empty images while rewinding.\n    */\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          if (tmp == image2)\n            image2=(Image *) NULL;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    /*\n      Fix scene numbers\n    */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n  TestUtility::loadFromYaml(TestEnvironment::substitute(yaml_plain), tls_context);\n  auto* common_context = tls_context.mutable_common_tls_context();\n\n  if (options.alpn_) {\n    common_context->add_alpn_protocols(Http::Utility::AlpnNames::get().Http2);\n    common_context->add_alpn_protocols(Http::Utility::AlpnNames::get().Http11);\n    common_context->add_alpn_protocols(Http::Utility::AlpnNames::get().Http3);\n  }\n  if (!options.san_.empty()) {\n    common_context->mutable_validation_context()->add_match_subject_alt_names()->set_exact(\n        options.san_);\n  }\n  for (const std::string& cipher_suite : options.cipher_suites_) {\n    common_context->mutable_tls_params()->add_cipher_suites(cipher_suite);\n  }\n  if (!options.sni_.empty()) {\n    tls_context.set_sni(options.sni_);\n  }\n\n  common_context->mutable_tls_params()->set_tls_minimum_protocol_version(options.tls_version_);\n  common_context->mutable_tls_params()->set_tls_maximum_protocol_version(options.tls_version_);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n  TestUtility::loadFromYaml(TestEnvironment::substitute(yaml_plain), tls_context);\n  auto* common_context = tls_context.mutable_common_tls_context();\n\n  if (options.alpn_) {\n    common_context->add_alpn_protocols(Http::Utility::AlpnNames::get().Http2);\n    common_context->add_alpn_protocols(Http::Utility::AlpnNames::get().Http11);\n    common_context->add_alpn_protocols(Http::Utility::AlpnNames::get().Http3);\n  }\n  if (!options.san_.empty()) {\n    envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher* matcher =\n        common_context->mutable_validation_context()->add_match_typed_subject_alt_names();\n    matcher->mutable_matcher()->set_exact(options.san_);\n    matcher->set_san_type(\n        envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS);\n    matcher = common_context->mutable_validation_context()->add_match_typed_subject_alt_names();\n    matcher->mutable_matcher()->set_exact(options.san_);\n    matcher->set_san_type(\n        envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI);\n    matcher = common_context->mutable_validation_context()->add_match_typed_subject_alt_names();\n    matcher->mutable_matcher()->set_exact(options.san_);\n    matcher->set_san_type(\n        envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL);\n    matcher = common_context->mutable_validation_context()->add_match_typed_subject_alt_names();\n    matcher->mutable_matcher()->set_exact(options.san_);\n    matcher->set_san_type(\n        envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS);\n  }\n  for (const std::string& cipher_suite : options.cipher_suites_) {\n    common_context->mutable_tls_params()->add_cipher_suites(cipher_suite);\n  }\n  if (!options.sni_.empty()) {\n    tls_context.set_sni(options.sni_);\n  }\n\n  common_context->mutable_tls_params()->set_tls_minimum_protocol_version(options.tls_version_);\n  common_context->mutable_tls_params()->set_tls_maximum_protocol_version(options.tls_version_);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void Context::onLog() {\n  if (wasm_->onLog_) {\n    wasm_->onLog_(this, id_);\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void Context::onLog() {\n  if (in_vm_context_created_ && wasm_->onLog_) {\n    wasm_->onLog_(this, id_);\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int may_create_in_sticky(struct dentry * const dir,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir->d_inode->i_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir->d_inode->i_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\n\tif (likely(dir->d_inode->i_mode & 0002) ||\n\t    (dir->d_inode->i_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int may_create_in_sticky(umode_t dir_mode, kuid_t dir_uid,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\n\tif (likely(dir_mode & 0002) ||\n\t    (dir_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned int\n    depth;\n\n\n  (void) SeekBlob(image,0,SEEK_SET);\n  while (EOFBlob(image) != MagickFalse)\n  {\n    /*\n     Object parser loop.\n    */\n    ldblk=ReadBlobLSBLong(image);\n    if ((ldblk > 9999) || (ldblk < 0))\n      break;\n    HDR.Type[3]=ldblk % 10; ldblk /= 10;  /* T digit */\n          Read complex pixels.\n        */\n        count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n        if (count == -1)\n          break;\n        if (HDR.Type[1] == 0)\n          InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);\n        else\n          InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);\n      }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    rotate_image=RotateImage(image,90.0,exception);\n    if (rotate_image != (Image *) NULL)\n      {\n        image=DestroyImage(image);\n        image=rotate_image;\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned int\n    depth;\n\n\n  quantum_info=(QuantumInfo *) NULL;\n  (void) SeekBlob(image,0,SEEK_SET);\n  while (EOFBlob(image) != MagickFalse)\n  {\n    /*\n     Object parser loop.\n    */\n    ldblk=ReadBlobLSBLong(image);\n    if ((ldblk > 9999) || (ldblk < 0))\n      break;\n    HDR.Type[3]=ldblk % 10; ldblk /= 10;  /* T digit */\n          Read complex pixels.\n        */\n        count=ReadBlob(image,depth/8*image->columns,(char *) pixels);\n        if (count == -1)\n          break;\n        if (HDR.Type[1] == 0)\n          InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);\n        else\n          InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);\n      }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    rotate_image=RotateImage(image,90.0,exception);\n    if (rotate_image != (Image *) NULL)\n      {\n        image=DestroyImage(image);\n        image=rotate_image;\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "pf_remove_state(struct pf_state *st)\n{\n\tPF_ASSERT_LOCKED();\n\n\tif (st->timeout == PFTM_UNLINKED)\n\t\treturn;\n\n\tst->timeout = PFTM_UNLINKED;\n\n\t/* handle load balancing related tasks */\n\tpf_postprocess_addr(st);\n\n\tif (st->src.state == PF_TCPS_PROXY_DST) {\n\t\tpf_send_tcp(st->rule.ptr, st->key[PF_SK_WIRE]->af,\n\t\t    &st->key[PF_SK_WIRE]->addr[1],\n\t\t    &st->key[PF_SK_WIRE]->addr[0],\n\t\t    st->key[PF_SK_WIRE]->port[1],\n\t\t    st->key[PF_SK_WIRE]->port[0],",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "pf_remove_state(struct pf_state *st)\n{\n\tPF_ASSERT_LOCKED();\n\n\tmtx_enter(&st->mtx);\n\tif (st->timeout == PFTM_UNLINKED) {\n\t\tmtx_leave(&st->mtx);\n\t\treturn;\n\t}\n\tst->timeout = PFTM_UNLINKED;\n\tmtx_leave(&st->mtx);\n\n\t/* handle load balancing related tasks */\n\tpf_postprocess_addr(st);\n\n\tif (st->src.state == PF_TCPS_PROXY_DST) {\n\t\tpf_send_tcp(st->rule.ptr, st->key[PF_SK_WIRE]->af,\n\t\t    &st->key[PF_SK_WIRE]->addr[1],\n\t\t    &st->key[PF_SK_WIRE]->addr[0],\n\t\t    st->key[PF_SK_WIRE]->port[1],\n\t\t    st->key[PF_SK_WIRE]->port[0],",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void TLSOutStream::flush()\n{\n  U8* sentUpTo = start;\n  while (sentUpTo < ptr) {\n    int n = writeTLS(sentUpTo, ptr - sentUpTo);\n    sentUpTo += n;\n    offset += n;\n  }\n\n  ptr = start;\n  out->flush();\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void TLSOutStream::flush()\n{\n  U8* sentUpTo = start;\n  while (sentUpTo < ptr) {\n    size_t n = writeTLS(sentUpTo, ptr - sentUpTo);\n    sentUpTo += n;\n    offset += n;\n  }\n\n  ptr = start;\n  out->flush();\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\tT.pidfile = strdup(args[1]);\n\t\t\t}\n\t\t} else if (!strcasecmp (args[0], \"interfaces\")) {\n\t\t\tint i;\n\n\t\t\tif (argcnt < 2) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: interfaces <ifa> <ifb> ...\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t}\n\n\t\t\tfor (i = 0; T.iflist[i] && i < MAXINTERFACES; i++);\n\n\t\t \tif (i + argcnt-1 > MAXINTERFACES) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: to many interfaces, more than %d\", linenum, MAXINTERFACES);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n\t\t\t\tsyslog (LOG_DEBUG, \"line %d: %d interfaces listed, no wildcard socket\", linenum, argcnt-1);\n\n\t\t\t\tT.iflist[i + argcnt--] = NULL;\n\t\t\t\twhile (argcnt) {\n\t\t\t\t\tif (!strcmp(args[argcnt], \"*\")) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\tT.pidfile = strdup(args[1]);\n\t\t\t}\n\t\t} else if (!strcasecmp (args[0], \"interfaces\")) {\n\t\t\tint i;\n\n\t\t\tif (argcnt < 2) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: interfaces <ifa> <ifb> ...\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t}\n\n\t\t\tfor (i = 0; T.iflist[i] && i < MAXINTERFACES; i++) { \n                        };\n\n\t\t \tif (i + argcnt-1 > MAXINTERFACES) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: to many interfaces, more than %d\", linenum, MAXINTERFACES);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n\t\t\t\tsyslog (LOG_DEBUG, \"line %d: %d interfaces listed, no wildcard socket\", linenum, argcnt-1);\n\n\t\t\t\tT.iflist[i + argcnt--] = NULL;\n\t\t\t\twhile (argcnt) {\n\t\t\t\t\tif (!strcmp(args[argcnt], \"*\")) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static CURLcode pop3_parse_url_path(struct connectdata *conn)\n{\n  /* the pop3 struct is already inited in pop3_connect() */\n  struct pop3_conn *pop3c = &conn->proto.pop3c;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n\n  /* url decode the path and use this mailbox */\n  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n  if(!pop3c->mailbox)\n    return CURLE_OUT_OF_MEMORY;\n\n  return CURLE_OK;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static CURLcode pop3_parse_url_path(struct connectdata *conn)\n{\n  /* the pop3 struct is already inited in pop3_connect() */\n  struct pop3_conn *pop3c = &conn->proto.pop3c;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n\n  /* url decode the path and use this mailbox */\n  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  if (u_map_get(request->map_url, \"state\") != NULL) {\n    state_encoded = ulfius_url_encode(u_map_get(request->map_url, \"state\"));\n    state_param = msprintf(\"&state=%s\", state_encoded);\n    o_free(state_encoded);\n  } else {\n    state_param = o_strdup(\"\");\n  }\n  // Check if client is allowed to perform this request\n  if (check_result_value(j_client, G_OK)) {\n    // Client is allowed to use auth_code grant with this redirection_uri\n    if (u_map_has_key(request->map_url, \"g_continue\")) {\n      if (!o_strnullempty(u_map_get(request->map_url, \"scope\"))) {\n        j_session = validate_session_client_scope(config, request, u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"));\n        if (check_result_value(j_session, G_OK)) {\n          if (json_object_get(json_object_get(j_session, \"session\"), \"authorization_required\") == json_false()) {\n            // User has granted access to the cleaned scope list for this client\n            // Generate code, generate the url and redirect to it\n            issued_for = get_client_hostname(request, config->glewlwyd_config->glewlwyd_config->originating_ip_header);\n            if (issued_for != NULL) {\n              if (config->glewlwyd_config->glewlwyd_callback_trigger_session_used(config->glewlwyd_config, request, json_string_value(json_object_get(json_object_get(j_session, \"session\"), \"scope_filtered\"))) == G_OK) {\n                if ((res = is_code_challenge_valid(config, u_map_get(request->map_url, \"code_challenge\"), u_map_get(request->map_url, \"code_challenge_method\"), code_challenge_stored)) == G_OK) {\n                  if ((authorization_code = generate_authorization_code(config, json_string_value(json_object_get(json_object_get(json_object_get(j_session, \"session\"), \"user\"), \"username\")), u_map_get(request->map_url, \"client_id\"), json_string_value(json_object_get(json_object_get(j_session, \"session\"), \"scope_filtered\")), u_map_get(request->map_url, \"redirect_uri\"), issued_for, u_map_get_case(request->map_header, \"user-agent\"), code_challenge_stored)) != NULL) {\n          o_free(redirect_url);\n        } else {\n          redirect_url = msprintf(\"%s%serror=server_error\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"));\n          ulfius_add_header_to_response(response, \"Location\", redirect_url);\n          o_free(redirect_url);\n          y_log_message(Y_LOG_LEVEL_ERROR, \"check_auth_type_auth_code_grant - oauth2 - Error validate_session_client_scope\");\n          response->status = 302;\n        }\n        json_decref(j_session);\n      } else {\n        // Scope is not allowed for this user\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_auth_type_auth_code_grant - oauth2 - scope list is missing or empty, origin: %s\", ip_source);\n        response->status = 302;\n        redirect_url = msprintf(\"%s%serror=invalid_scope%s\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"), state_param);\n        ulfius_add_header_to_response(response, \"Location\", redirect_url);\n        o_free(redirect_url);\n      }\n    } else {\n      // Redirect to login page\n      redirect_url = get_login_url(config, request, \"auth\", u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"), NULL);\n      ulfius_add_header_to_response(response, \"Location\", redirect_url);\n      o_free(redirect_url);\n      response->status = 302;\n    }\n  } else {\n    // client is not authorized\n    response->status = 302;\n    redirect_url = msprintf(\"%s%serror=unauthorized_client%s%s\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"), (u_map_get(request->map_url, \"state\")!=NULL?\"&state=\":\"\"), (u_map_get(request->map_url, \"state\")!=NULL?u_map_get(request->map_url, \"state\"):\"\"));\n    ulfius_add_header_to_response(response, \"Location\", redirect_url);\n    o_free(redirect_url);\n    config->glewlwyd_config->glewlwyd_plugin_callback_metrics_increment_counter(config->glewlwyd_config, GLWD_METRICS_OAUTH2_UNAUTHORIZED_CLIENT, 1, \"plugin\", config->name, NULL);\n  }\n  o_free(state_param);\n  json_decref(j_client);\n  return U_CALLBACK_CONTINUE;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  if (u_map_get(request->map_url, \"state\") != NULL) {\n    state_encoded = ulfius_url_encode(u_map_get(request->map_url, \"state\"));\n    state_param = msprintf(\"&state=%s\", state_encoded);\n    o_free(state_encoded);\n  } else {\n    state_param = o_strdup(\"\");\n  }\n  // Check if client is allowed to perform this request\n  if (check_result_value(j_client, G_OK)) {\n    // Client is allowed to use auth_code grant with this redirection_uri\n    if (!o_strnullempty(u_map_get(request->map_url, \"scope\"))) {\n      if (u_map_has_key(request->map_url, \"g_continue\")) {\n        j_session = validate_session_client_scope(config, request, u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"));\n        if (check_result_value(j_session, G_OK)) {\n          if (json_object_get(json_object_get(j_session, \"session\"), \"authorization_required\") == json_false()) {\n            // User has granted access to the cleaned scope list for this client\n            // Generate code, generate the url and redirect to it\n            issued_for = get_client_hostname(request, config->glewlwyd_config->glewlwyd_config->originating_ip_header);\n            if (issued_for != NULL) {\n              if (config->glewlwyd_config->glewlwyd_callback_trigger_session_used(config->glewlwyd_config, request, json_string_value(json_object_get(json_object_get(j_session, \"session\"), \"scope_filtered\"))) == G_OK) {\n                if ((res = is_code_challenge_valid(config, u_map_get(request->map_url, \"code_challenge\"), u_map_get(request->map_url, \"code_challenge_method\"), code_challenge_stored)) == G_OK) {\n                  if ((authorization_code = generate_authorization_code(config, json_string_value(json_object_get(json_object_get(json_object_get(j_session, \"session\"), \"user\"), \"username\")), u_map_get(request->map_url, \"client_id\"), json_string_value(json_object_get(json_object_get(j_session, \"session\"), \"scope_filtered\")), u_map_get(request->map_url, \"redirect_uri\"), issued_for, u_map_get_case(request->map_header, \"user-agent\"), code_challenge_stored)) != NULL) {\n          o_free(redirect_url);\n        } else {\n          redirect_url = msprintf(\"%s%serror=server_error\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"));\n          ulfius_add_header_to_response(response, \"Location\", redirect_url);\n          o_free(redirect_url);\n          y_log_message(Y_LOG_LEVEL_ERROR, \"check_auth_type_auth_code_grant - oauth2 - Error validate_session_client_scope\");\n          response->status = 302;\n        }\n        json_decref(j_session);\n      } else {\n        // Redirect to login page\n        redirect_url = get_login_url(config, request, \"auth\", u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"), NULL);\n        ulfius_add_header_to_response(response, \"Location\", redirect_url);\n        o_free(redirect_url);\n        response->status = 302;\n      }\n    } else {\n      // Scope is not allowed for this user\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"check_auth_type_auth_code_grant - oauth2 - scope list is missing or empty, origin: %s\", ip_source);\n      response->status = 403;\n    }\n  } else {\n    // client is not authorized\n    response->status = 403;\n    config->glewlwyd_config->glewlwyd_plugin_callback_metrics_increment_counter(config->glewlwyd_config, GLWD_METRICS_OAUTH2_UNAUTHORIZED_CLIENT, 1, \"plugin\", config->name, NULL);\n  }\n  o_free(state_param);\n  json_decref(j_client);\n  return U_CALLBACK_CONTINUE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "obj2ast_keyword(PyObject* obj, keyword_ty* out, PyArena* arena)\n{\n    PyObject* tmp = NULL;\n    identifier arg;\n    expr_ty value;\n\n    if (exists_not_none(obj, &PyId_arg)) {\n        int res;\n        tmp = _PyObject_GetAttrId(obj, &PyId_arg);\n        if (tmp == NULL) goto failed;\n        res = obj2ast_identifier(tmp, &arg, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    } else {\n        arg = NULL;\n    }\n    if (_PyObject_HasAttrId(obj, &PyId_value)) {\n        int res;\n        tmp = _PyObject_GetAttrId(obj, &PyId_value);\n        if (tmp == NULL) goto failed;\n        res = obj2ast_expr(tmp, &value, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    } else {\n        PyErr_SetString(PyExc_TypeError, \"required field \\\"value\\\" missing from keyword\");\n        return 1;\n    }\n    *out = keyword(arg, value, arena);\n    return 0;\nfailed:\n    Py_XDECREF(tmp);\n    return 1;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "obj2ast_keyword(PyObject* obj, keyword_ty* out, PyArena* arena)\n{\n    PyObject* tmp = NULL;\n    identifier arg;\n    expr_ty value;\n\n    if (lookup_attr_id(obj, &PyId_arg, &tmp) < 0) {\n        return 1;\n    }\n    if (tmp == NULL || tmp == Py_None) {\n        Py_CLEAR(tmp);\n        arg = NULL;\n    }\n    else {\n        int res;\n        res = obj2ast_identifier(tmp, &arg, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    }\n    if (lookup_attr_id(obj, &PyId_value, &tmp) < 0) {\n        return 1;\n    }\n    if (tmp == NULL) {\n        PyErr_SetString(PyExc_TypeError, \"required field \\\"value\\\" missing from keyword\");\n        return 1;\n    }\n    else {\n        int res;\n        res = obj2ast_expr(tmp, &value, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    }\n    *out = keyword(arg, value, arena);\n    return 0;\nfailed:\n    Py_XDECREF(tmp);\n    return 1;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void dbEvalSetColumn(DbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[200];\n\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n\n    switch( sqlite3_column_type(pStmt, iCol) ) {\n    case SQLITE_BLOB: {\n        int bytes = sqlite3_column_bytes(pStmt, iCol);\n        const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol);\n        if( !zBlob ) {\n            return;\n        }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void dbEvalSetColumn(DbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[JSI_MAX_NUMBER_STRING];\n\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n\n    switch( sqlite3_column_type(pStmt, iCol) ) {\n    case SQLITE_BLOB: {\n        int bytes = sqlite3_column_bytes(pStmt, iCol);\n        const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol);\n        if( !zBlob ) {\n            return;\n        }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "FontData::FontData(FontData* data, int32_t offset) {\n  Init(data->array_);\n  Bound(data->bound_offset_ + offset,\n        (data->bound_length_ == GROWABLE_SIZE)\n            ? GROWABLE_SIZE : data->bound_length_ - offset);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "FontData::FontData(FontData* data, int32_t offset) {\n  Init(data->array_);\n  Bound(data->bound_offset_ + offset,\n        (data->bound_length_ == GROWABLE_SIZE)\n        ? GROWABLE_SIZE : data->bound_length_ - offset);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_test(&ucounts->count)) {\n\t\tspin_lock_irqsave(&ucounts_lock, flags);\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\n\t\tkfree(ucounts);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ucounts_lock, flags);\n\tucounts->count -= 1;\n\tif (!ucounts->count)\n\t\thlist_del_init(&ucounts->node);\n\telse\n\t\tucounts = NULL;\n\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\n\tkfree(ucounts);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void CZNC::ForceEncoding() {\n    m_uiForceEncoding++;\n#ifdef HAVE_ICU\n    for (Csock* pSock : GetManager()) {\n        if (pSock->GetEncoding().empty()) {\n            pSock->SetEncoding(\"UTF-8\");\n        }\n    }\n#endif\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void CZNC::ForceEncoding() {\n    m_uiForceEncoding++;\n#ifdef HAVE_ICU\n    for (Csock* pSock : GetManager()) {\n        pSock->SetEncoding(FixupEncoding(pSock->GetEncoding()));\n    }\n#endif\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t}\n      }\n      if (!error)\n      {\n\tif ((param->testflag & (T_REP_BY_SORT | T_REP_PARALLEL)) &&\n\t    (mi_is_any_key_active(share->state.key_map) ||\n\t     (rep_quick && !param->keys_in_use && !recreate)) &&\n\t    mi_test_if_sort_rep(info, info->state->records,\n\t\t\t\tinfo->s->state.key_map,\n\t\t\t\tparam->force_sort))\n\t{\n          if (param->testflag & T_REP_BY_SORT)\n            error=mi_repair_by_sort(param,info,filename,rep_quick);\n          else\n            error=mi_repair_parallel(param,info,filename,rep_quick);\n\t  state_updated=1;\n\t}\n\telse if (param->testflag & T_REP_ANY)\n\t  error=mi_repair(param, info,filename,rep_quick);\n      }\n      if (!error && param->testflag & T_SORT_RECORDS)\n      {\n\t/*\n\t  The data file is nowadays reopened in the repair code so we should\n\t  soon remove the following reopen-code\n\t*/\n#ifndef TO_BE_REMOVED\n\tif (param->out_flag & O_NEW_DATA)\n\t{\t\t\t/* Change temp file to org file */\n\n\t  error=mi_sort_records(param,info,filename,param->opt_sort_key,\n                             /* what is the following parameter for ? */\n\t\t\t\t(my_bool) !(param->testflag & T_REP),\n\t\t\t\tupdate_index);\n\t  datafile=info->dfile;\t/* This is now locked */\n\t  if (!error && !update_index)\n\t  {\n\t    if (param->verbose)\n\t      puts(\"Table had a compressed index;  We must now recreate the index\");\n\t    error=mi_repair_by_sort(param,info,filename,1);\n\t  }\n\t}\n      }\n      if (!error && param->testflag & T_SORT_INDEX)\n\terror=mi_sort_index(param,info,filename);\n      if (!error)\n\tshare->state.changed&= ~(STATE_CHANGED | STATE_CRASHED |\n\t\t\t\t STATE_CRASHED_ON_REPAIR);\n      else\n\tmi_mark_crashed(info);\n    }\n    else if ((param->testflag & T_CHECK) || !(param->testflag & T_AUTO_INC))\n    {\n      if (!(param->testflag & T_SILENT) || param->testflag & T_INFO)\n\tprintf(\"Checking MyISAM file: %s\\n\",filename);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      }\n      if (!error)\n      {\n\tif ((param->testflag & (T_REP_BY_SORT | T_REP_PARALLEL)) &&\n\t    (mi_is_any_key_active(share->state.key_map) ||\n\t     (rep_quick && !param->keys_in_use && !recreate)) &&\n\t    mi_test_if_sort_rep(info, info->state->records,\n\t\t\t\tinfo->s->state.key_map,\n\t\t\t\tparam->force_sort))\n\t{\n          /*\n            The new file might not be created with the right stats depending\n            on how myisamchk is run, so we must copy file stats from old to new.\n          */\n          if (param->testflag & T_REP_BY_SORT)\n            error= mi_repair_by_sort(param, info, filename, rep_quick, FALSE);\n          else\n            error= mi_repair_parallel(param, info, filename, rep_quick, FALSE);\n\t  state_updated=1;\n\t}\n\telse if (param->testflag & T_REP_ANY)\n\t  error= mi_repair(param, info, filename, rep_quick, FALSE);\n      }\n      if (!error && param->testflag & T_SORT_RECORDS)\n      {\n\t/*\n\t  The data file is nowadays reopened in the repair code so we should\n\t  soon remove the following reopen-code\n\t*/\n#ifndef TO_BE_REMOVED\n\tif (param->out_flag & O_NEW_DATA)\n\t{\t\t\t/* Change temp file to org file */\n\n\t  error=mi_sort_records(param,info,filename,param->opt_sort_key,\n                             /* what is the following parameter for ? */\n\t\t\t\t(my_bool) !(param->testflag & T_REP),\n\t\t\t\tupdate_index);\n\t  datafile=info->dfile;\t/* This is now locked */\n\t  if (!error && !update_index)\n\t  {\n\t    if (param->verbose)\n\t      puts(\"Table had a compressed index;  We must now recreate the index\");\n\t    error= mi_repair_by_sort(param, info, filename, 1, FALSE);\n\t  }\n\t}\n      }\n      if (!error && param->testflag & T_SORT_INDEX)\n\terror= mi_sort_index(param, info, filename, FALSE);\n      if (!error)\n\tshare->state.changed&= ~(STATE_CHANGED | STATE_CRASHED |\n\t\t\t\t STATE_CRASHED_ON_REPAIR);\n      else\n\tmi_mark_crashed(info);\n    }\n    else if ((param->testflag & T_CHECK) || !(param->testflag & T_AUTO_INC))\n    {\n      if (!(param->testflag & T_SILENT) || param->testflag & T_INFO)\n\tprintf(\"Checking MyISAM file: %s\\n\",filename);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;\n  if (goodsize > LUAI_MAXSTACK)\n    goodsize = LUAI_MAXSTACK;  /* respect stack limit */\n  /* if thread is currently not handling a stack overflow and its\n     good size is smaller than current size, shrink its stack */\n  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) &&\n      goodsize < L->stacksize)\n    luaD_reallocstack(L, goodsize, 0);  /* ok if that fails */\n  else  /* don't change stack */\n    condmovestack(L,{},{});  /* (change only for debugging) */\n  luaE_shrinkCI(L);  /* shrink CI list */\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + BASIC_STACK_SIZE;\n  if (goodsize > LUAI_MAXSTACK)\n    goodsize = LUAI_MAXSTACK;  /* respect stack limit */\n  /* if thread is currently not handling a stack overflow and its\n     good size is smaller than current size, shrink its stack */\n  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) && goodsize < L->stacksize)\n    luaD_reallocstack(L, goodsize, 0);  /* ok if that fails */\n  else  /* don't change stack */\n    condmovestack(L,{},{});  /* (change only for debugging) */\n  luaE_shrinkCI(L);  /* shrink CI list */\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "            }\n        } else if (!strcasecmp(argv[0],\"slowlog-max-len\") && argc == 2) {\n            server.slowlog_max_len = strtoll(argv[1],NULL,10);\n        } else if (!strcasecmp(argv[0],\"client-output-buffer-limit\") &&\n                   argc == 5)\n        {\n            int class = getClientTypeByName(argv[1]);\n            unsigned long long hard, soft;\n            int soft_seconds;\n\n            if (class == -1) {\n                err = \"Unrecognized client limit class\";\n                goto loaderr;\n            }\n            hard = memtoll(argv[2],NULL);\n            soft = memtoll(argv[3],NULL);\n            soft_seconds = atoi(argv[4]);\n            if (soft_seconds < 0) {\n                err = \"Negative number of seconds in soft limit is invalid\";\n                goto loaderr;\n            }\n            server.client_obuf_limits[class].hard_limit_bytes = hard;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "            }\n        } else if (!strcasecmp(argv[0],\"slowlog-max-len\") && argc == 2) {\n            server.slowlog_max_len = strtoll(argv[1],NULL,10);\n        } else if (!strcasecmp(argv[0],\"client-output-buffer-limit\") &&\n                   argc == 5)\n        {\n            int class = getClientTypeByName(argv[1]);\n            unsigned long long hard, soft;\n            int soft_seconds;\n\n            if (class == -1 || class == CLIENT_TYPE_MASTER) {\n                err = \"Unrecognized client limit class: the user specified \"\n                \"an invalid one, or 'master' which has no buffer limits.\";\n                goto loaderr;\n            }\n            hard = memtoll(argv[2],NULL);\n            soft = memtoll(argv[3],NULL);\n            soft_seconds = atoi(argv[4]);\n            if (soft_seconds < 0) {\n                err = \"Negative number of seconds in soft limit is invalid\";\n                goto loaderr;\n            }\n            server.client_obuf_limits[class].hard_limit_bytes = hard;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  const struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\n\tif (!dst)\n\t\tgoto out;\n\n\t/* Yes, checking route validity in not connected\n\t * case is not very simple. Take into account,\n\t * that we do not support routing by source, TOS,\n\t * and MSG_DONTROUTE \t\t--ANK (980726)\n\t *\n\t * 1. ip6_rt_check(): If route was host route,\n\t *    check that cached destination is current.\n\t *    If it is network route, we still may\n\t *    check its validity using saved pointer\n\t *    to the last used address: daddr_cache.",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  const struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt;\n\n\tif (!dst)\n\t\tgoto out;\n\n\tif (dst->ops->family != AF_INET6) {\n\t\tdst_release(dst);\n\t\treturn NULL;\n\t}\n\n\trt = (struct rt6_info *)dst;\n\t/* Yes, checking route validity in not connected\n\t * case is not very simple. Take into account,\n\t * that we do not support routing by source, TOS,\n\t * and MSG_DONTROUTE \t\t--ANK (980726)\n\t *\n\t * 1. ip6_rt_check(): If route was host route,\n\t *    check that cached destination is current.\n\t *    If it is network route, we still may\n\t *    check its validity using saved pointer\n\t *    to the last used address: daddr_cache.",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t{\n\t  xd3_rinst *inst = xd3_rlist_pop_front (& stream->iopt_used);\n\n\t  switch (inst->type)\n\t    {\n\t    case XD3_RUN: *rptr++ = 'R'; break;\n\t    case XD3_CPY: *rptr++ = 'C'; break;\n\t    default: CHECK(0);\n\t    }\n\n\t  snprintf_func (rptr, rbuf+TESTBUFSIZE-rptr, \"%d/%d\", \n\t\t\t inst->pos, inst->size);\n\t  rptr += strlen (rptr);\n\n\t  if (inst->type == XD3_CPY)\n\t    {\n\t      *rptr++ = '@';\n\t      snprintf_func (rptr, rbuf+TESTBUFSIZE-rptr, \"%\"Q\"d\", inst->addr);\n\t      rptr += strlen (rptr);\n\t    }\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t{\n\t  xd3_rinst *inst = xd3_rlist_pop_front (& stream->iopt_used);\n\n\t  switch (inst->type)\n\t    {\n\t    case XD3_RUN: *rptr++ = 'R'; break;\n\t    case XD3_CPY: *rptr++ = 'C'; break;\n\t    default: CHECK(0);\n\t    }\n\n\t  snprintf_func (rptr, rbuf+TESTBUFSIZE-rptr, \"%d/%d\",\n\t\t\t inst->pos, inst->size);\n\t  rptr += strlen (rptr);\n\n\t  if (inst->type == XD3_CPY)\n\t    {\n\t      *rptr++ = '@';\n\t      snprintf_func (rptr, rbuf+TESTBUFSIZE-rptr, \"%\"Q\"d\", inst->addr);\n\t      rptr += strlen (rptr);\n\t    }\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "zfs_groupmember(zfsvfs_t *zfsvfs, uint64_t id, cred_t *cr)\n{\n#ifdef HAVE_KSID\n\tksid_t\t\t*ksid = crgetsid(cr, KSID_GROUP);\n\tksidlist_t\t*ksidlist = crgetsidlist(cr);\n\tuid_t\t\tgid;\n\n\tif (ksid && ksidlist) {\n\t\tint\t\ti;\n\t\tksid_t\t\t*ksid_groups;\n\t\tuint32_t\tidx = FUID_INDEX(id);\n\t\tuint32_t\trid = FUID_RID(id);\n\n\t\tksid_groups = ksidlist->ksl_sids;\n\n\t\tfor (i = 0; i != ksidlist->ksl_nsid; i++) {\n\t\t\t\tif (strcmp(domain,\n\t\t\t\t    IDMAP_WK_CREATOR_SID_AUTHORITY) == 0)\n\t\t\t\t\treturn (B_FALSE);\n\n\t\t\t\tif ((strcmp(domain,\n\t\t\t\t    ksid_groups[i].ks_domain->kd_name) == 0) &&\n\t\t\t\t    rid == ksid_groups[i].ks_rid)\n\t\t\t\t\treturn (B_TRUE);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Not found in ksidlist, check posix groups\n\t */\n\tgid = zfs_fuid_map_id(zfsvfs, id, cr, ZFS_GROUP);\n\treturn (groupmember(gid, cr));\n#else\n\treturn (B_TRUE);\n#endif\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "zfs_groupmember(zfsvfs_t *zfsvfs, uint64_t id, cred_t *cr)\n{\n#ifdef HAVE_KSID\n\tuid_t\t\tgid;\n\n#ifdef illumos\n\tksid_t\t\t*ksid = crgetsid(cr, KSID_GROUP);\n\tksidlist_t\t*ksidlist = crgetsidlist(cr);\n\n\tif (ksid && ksidlist) {\n\t\tint\t\ti;\n\t\tksid_t\t\t*ksid_groups;\n\t\tuint32_t\tidx = FUID_INDEX(id);\n\t\tuint32_t\trid = FUID_RID(id);\n\n\t\tksid_groups = ksidlist->ksl_sids;\n\n\t\tfor (i = 0; i != ksidlist->ksl_nsid; i++) {\n\t\t\t\t    IDMAP_WK_CREATOR_SID_AUTHORITY) == 0)\n\t\t\t\t\treturn (B_FALSE);\n\n\t\t\t\tif ((strcmp(domain,\n\t\t\t\t    ksid_groups[i].ks_domain->kd_name) == 0) &&\n\t\t\t\t    rid == ksid_groups[i].ks_rid)\n\t\t\t\t\treturn (B_TRUE);\n\t\t\t}\n\t\t}\n\t}\n#endif /* illumos */\n\n\t/*\n\t * Not found in ksidlist, check posix groups\n\t */\n\tgid = zfs_fuid_map_id(zfsvfs, id, cr, ZFS_GROUP);\n\treturn (groupmember(gid, cr));\n#else\n\treturn (B_TRUE);\n#endif\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t     struct path *path,\n\t\t     unsigned int uid, unsigned int gid)\n{\n\tconst struct smb_sid *psid, *creator = NULL;\n\tstruct smb_ace *parent_aces, *aces;\n\tstruct smb_acl *parent_pdacl;\n\tstruct smb_ntsd *parent_pntsd = NULL;\n\tstruct smb_sid owner_sid, group_sid;\n\tstruct dentry *parent = path->dentry->d_parent;\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0;\n\tint rc = 0, num_aces, dacloffset, pntsd_type, acl_len;\n\tchar *aces_base;\n\tbool is_dir = S_ISDIR(d_inode(path->dentry)->i_mode);\n\n\tacl_len = ksmbd_vfs_get_sd_xattr(conn, user_ns,\n\t\t\t\t\t parent, &parent_pntsd);\n\tif (acl_len <= 0)\n\t\treturn -ENOENT;\n\tdacloffset = le32_to_cpu(parent_pntsd->dacloffset);\n\tif (!dacloffset) {\n\t\trc = -EINVAL;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\tparent_pdacl = (struct smb_acl *)((char *)parent_pntsd + dacloffset);\n\tnum_aces = le32_to_cpu(parent_pdacl->num_aces);\n\tpntsd_type = le16_to_cpu(parent_pntsd->type);\n\n\taces_base = kmalloc(sizeof(struct smb_ace) * num_aces * 2, GFP_KERNEL);\n\tif (!aces_base) {\n\t\trc = -ENOMEM;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\taces = (struct smb_ace *)aces_base;\n\tparent_aces = (struct smb_ace *)((char *)parent_pdacl +\n\t\t\tsizeof(struct smb_acl));\n\n\tif (pntsd_type & DACL_AUTO_INHERITED)\n\t\tinherited_flags = INHERITED_ACE;\n\n\tfor (i = 0; i < num_aces; i++) {\n\t\tflags = parent_aces->flags;\n\t\tif (!smb_inherit_flags(flags, is_dir))\n\t\t\tgoto pass;\n\t\tif (is_dir) {\n\t\t\tflags &= ~(INHERIT_ONLY_ACE | INHERITED_ACE);\n\t\t\tif (!(flags & CONTAINER_INHERIT_ACE))\n\t\t\t\tflags |= INHERIT_ONLY_ACE;\n\t\t\tif (flags & NO_PROPAGATE_INHERIT_ACE)\n\t\t\t\tflags = 0;\n\t\t} else {\n\t\t} else if (is_dir && !(parent_aces->flags & NO_PROPAGATE_INHERIT_ACE)) {\n\t\t\tpsid = &parent_aces->sid;\n\t\t}\n\n\t\tsmb_set_ace(aces, psid, parent_aces->type, flags | inherited_flags,\n\t\t\t    parent_aces->access_req);\n\t\tnt_size += le16_to_cpu(aces->size);\n\t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n\t\tace_cnt++;\npass:\n\t\tparent_aces =\n\t\t\t(struct smb_ace *)((char *)parent_aces + le16_to_cpu(parent_aces->size));\n\t}\n\n\tif (nt_size > 0) {\n\t\tstruct smb_ntsd *pntsd;\n\t\tstruct smb_acl *pdacl;\n\t\tstruct smb_sid *powner_sid = NULL, *pgroup_sid = NULL;\n\t\tint powner_sid_size = 0, pgroup_sid_size = 0, pntsd_size;\n\n\t\tif (parent_pntsd->osidoffset) {\n\t\t\tpowner_sid = (struct smb_sid *)((char *)parent_pntsd +",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t     struct path *path,\n\t\t     unsigned int uid, unsigned int gid)\n{\n\tconst struct smb_sid *psid, *creator = NULL;\n\tstruct smb_ace *parent_aces, *aces;\n\tstruct smb_acl *parent_pdacl;\n\tstruct smb_ntsd *parent_pntsd = NULL;\n\tstruct smb_sid owner_sid, group_sid;\n\tstruct dentry *parent = path->dentry->d_parent;\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0, pdacl_size;\n\tint rc = 0, num_aces, dacloffset, pntsd_type, pntsd_size, acl_len, aces_size;\n\tchar *aces_base;\n\tbool is_dir = S_ISDIR(d_inode(path->dentry)->i_mode);\n\n\tpntsd_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,\n\t\t\t\t\t    parent, &parent_pntsd);\n\tif (pntsd_size <= 0)\n\t\treturn -ENOENT;\n\tdacloffset = le32_to_cpu(parent_pntsd->dacloffset);\n\tif (!dacloffset || (dacloffset + sizeof(struct smb_acl) > pntsd_size)) {\n\t\trc = -EINVAL;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\tparent_pdacl = (struct smb_acl *)((char *)parent_pntsd + dacloffset);\n\tacl_len = pntsd_size - dacloffset;\n\tnum_aces = le32_to_cpu(parent_pdacl->num_aces);\n\tpntsd_type = le16_to_cpu(parent_pntsd->type);\n\tpdacl_size = le16_to_cpu(parent_pdacl->size);\n\n\tif (pdacl_size > acl_len || pdacl_size < sizeof(struct smb_acl)) {\n\t\trc = -EINVAL;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\taces_base = kmalloc(sizeof(struct smb_ace) * num_aces * 2, GFP_KERNEL);\n\tif (!aces_base) {\n\t\trc = -ENOMEM;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\taces = (struct smb_ace *)aces_base;\n\tparent_aces = (struct smb_ace *)((char *)parent_pdacl +\n\t\t\tsizeof(struct smb_acl));\n\taces_size = acl_len - sizeof(struct smb_acl);\n\n\tif (pntsd_type & DACL_AUTO_INHERITED)\n\t\tinherited_flags = INHERITED_ACE;\n\n\tfor (i = 0; i < num_aces; i++) {\n\t\tint pace_size;\n\n\t\tif (offsetof(struct smb_ace, access_req) > aces_size)\n\t\t\tbreak;\n\n\t\tpace_size = le16_to_cpu(parent_aces->size);\n\t\tif (pace_size > aces_size)\n\t\t\tbreak;\n\n\t\taces_size -= pace_size;\n\n\t\tflags = parent_aces->flags;\n\t\tif (!smb_inherit_flags(flags, is_dir))\n\t\t\tgoto pass;\n\t\tif (is_dir) {\n\t\t\tflags &= ~(INHERIT_ONLY_ACE | INHERITED_ACE);\n\t\t\tif (!(flags & CONTAINER_INHERIT_ACE))\n\t\t\t\tflags |= INHERIT_ONLY_ACE;\n\t\t\tif (flags & NO_PROPAGATE_INHERIT_ACE)\n\t\t\t\tflags = 0;\n\t\t} else {\n\t\t} else if (is_dir && !(parent_aces->flags & NO_PROPAGATE_INHERIT_ACE)) {\n\t\t\tpsid = &parent_aces->sid;\n\t\t}\n\n\t\tsmb_set_ace(aces, psid, parent_aces->type, flags | inherited_flags,\n\t\t\t    parent_aces->access_req);\n\t\tnt_size += le16_to_cpu(aces->size);\n\t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n\t\tace_cnt++;\npass:\n\t\tparent_aces = (struct smb_ace *)((char *)parent_aces + pace_size);\n\t}\n\n\tif (nt_size > 0) {\n\t\tstruct smb_ntsd *pntsd;\n\t\tstruct smb_acl *pdacl;\n\t\tstruct smb_sid *powner_sid = NULL, *pgroup_sid = NULL;\n\t\tint powner_sid_size = 0, pgroup_sid_size = 0, pntsd_size;\n\n\t\tif (parent_pntsd->osidoffset) {\n\t\t\tpowner_sid = (struct smb_sid *)((char *)parent_pntsd +",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "mrb_proc_copy(struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    /* already initialized proc */\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(NULL, (mrb_irep*)a->body.irep);\n  }\n  a->upper = b->upper;\n  a->e.env = b->e.env;\n  /* a->e.target_class = a->e.target_class; */\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    /* already initialized proc */\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  a->upper = b->upper;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);\n  }\n  a->e.env = b->e.env;\n  /* a->e.target_class = a->e.target_class; */\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    if (free >= need) {\n        memmove(bot, tok, copy);\n        shift_ptrs_and_fpos(-static_cast<ptrdiff_t>(free));\n    }\n    else {\n        BSIZE += std::max(BSIZE, need);\n        char * buf = new char[BSIZE + YYMAXFILL];\n        if (!buf) fatal(\"out of memory\");\n\n        memmove(buf, tok, copy);\n        shift_ptrs_and_fpos(buf - bot);\n        delete [] bot;\n        bot = buf;\n\n        free = BSIZE - copy;\n    }\n\n    if (!read(free)) {\n        eof = lim;\n        memset(lim, 0, YYMAXFILL);\n        lim += YYMAXFILL;\n    }\n\n    return true;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    if (free >= need) {\n        memmove(bot, tok, copy);\n        shift_ptrs_and_fpos(-static_cast<ptrdiff_t>(free));\n    }\n    else {\n        BSIZE += std::max(BSIZE, need);\n        char * buf = new char[BSIZE + YYMAXFILL];\n        if (!buf) fatal(\"out of memory\");\n\n        memmove(buf, tok, copy);\n        shift_ptrs_and_fpos(buf - tok);\n        delete [] bot;\n        bot = buf;\n\n        free = BSIZE - copy;\n    }\n\n    DASSERT(lim + free <= bot + BSIZE);\n    if (!read(free)) {\n        eof = lim;\n        memset(lim, 0, YYMAXFILL);\n        lim += YYMAXFILL;\n    }\n\n    return true;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\tGFP_KERNEL);\n\t\tif (!slots)\n\t\t\tgoto out_free;\n\t\tslot = id_to_memslot(slots, mem->slot);\n\t\tslot->flags |= KVM_MEMSLOT_INVALID;\n\n\t\tupdate_memslots(slots, NULL);\n\n\t\told_memslots = kvm->memslots;\n\t\trcu_assign_pointer(kvm->memslots, slots);\n\t\tsynchronize_srcu_expedited(&kvm->srcu);\n\t\t/* From this point no new shadow pages pointing to a deleted,\n\t\t * or moved, memslot will be created.\n\t\t *\n\t\t * validation of sp->gfn happens in:\n\t\t * \t- gfn_to_hva (kvm_read_guest, gfn_to_pfn)\n\t\t * \t- kvm_is_visible_gfn (mmu_check_roots)\n\t\t */\n\t\tkvm_arch_flush_shadow_memslot(kvm, slot);\n\t\tkfree(old_memslots);\n\t}\n\n\tr = kvm_arch_prepare_memory_region(kvm, &new, old, mem, user_alloc);\n\tif (r)\n\t\tgoto out_free;\n\n\t/* map/unmap the pages in iommu page table */\n\tif (npages) {\n\t\tr = kvm_iommu_map_pages(kvm, &new);\n\t\tif (r)\n\t\t\tgoto out_free;\n\t} else\n\t\tkvm_iommu_unmap_pages(kvm, &old);\n\n\tr = -ENOMEM;\n\tslots = kmemdup(kvm->memslots, sizeof(struct kvm_memslots),\n\t\t\tGFP_KERNEL);\n\tif (!slots)\n\t\tgoto out_free;\n\n\t/* actual memory is freed via old in kvm_free_physmem_slot below */\n\tif (!npages) {\n\t\tnew.dirty_bitmap = NULL;\n\t\tmemset(&new.arch, 0, sizeof(new.arch));\n\t}\n\n\tupdate_memslots(slots, &new);\n\told_memslots = kvm->memslots;\n\trcu_assign_pointer(kvm->memslots, slots);\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\n\tkvm_arch_commit_memory_region(kvm, mem, old, user_alloc);\n\n\tkvm_free_physmem_slot(&old, &new);\n\tkfree(old_memslots);\n\n\treturn 0;\n\nout_free:\n\tkvm_free_physmem_slot(&new, &old);\nout:\n\treturn r;\n\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tif (!slots)\n\t\t\tgoto out_free;\n\t\tslot = id_to_memslot(slots, mem->slot);\n\t\tslot->flags |= KVM_MEMSLOT_INVALID;\n\n\t\tupdate_memslots(slots, NULL);\n\n\t\told_memslots = kvm->memslots;\n\t\trcu_assign_pointer(kvm->memslots, slots);\n\t\tsynchronize_srcu_expedited(&kvm->srcu);\n\t\t/* slot was deleted or moved, clear iommu mapping */\n\t\tkvm_iommu_unmap_pages(kvm, &old);\n\t\t/* From this point no new shadow pages pointing to a deleted,\n\t\t * or moved, memslot will be created.\n\t\t *\n\t\t * validation of sp->gfn happens in:\n\t\t * \t- gfn_to_hva (kvm_read_guest, gfn_to_pfn)\n\t\t * \t- kvm_is_visible_gfn (mmu_check_roots)\n\t\t */\n\t\tkvm_arch_flush_shadow_memslot(kvm, slot);\n\t\tkfree(old_memslots);\n\t}\n\n\tr = kvm_arch_prepare_memory_region(kvm, &new, old, mem, user_alloc);\n\tif (r)\n\t\tgoto out_free;\n\n\tr = -ENOMEM;\n\tslots = kmemdup(kvm->memslots, sizeof(struct kvm_memslots),\n\t\t\tGFP_KERNEL);\n\tif (!slots)\n\t\tgoto out_free;\n\n\t/* map new memory slot into the iommu */\n\tif (npages) {\n\t\tr = kvm_iommu_map_pages(kvm, &new);\n\t\tif (r)\n\t\t\tgoto out_slots;\n\t}\n\n\t/* actual memory is freed via old in kvm_free_physmem_slot below */\n\tif (!npages) {\n\t\tnew.dirty_bitmap = NULL;\n\t\tmemset(&new.arch, 0, sizeof(new.arch));\n\t}\n\n\tupdate_memslots(slots, &new);\n\told_memslots = kvm->memslots;\n\trcu_assign_pointer(kvm->memslots, slots);\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\n\tkvm_arch_commit_memory_region(kvm, mem, old, user_alloc);\n\n\tkvm_free_physmem_slot(&old, &new);\n\tkfree(old_memslots);\n\n\treturn 0;\n\nout_slots:\n\tkfree(slots);\nout_free:\n\tkvm_free_physmem_slot(&new, &old);\nout:\n\treturn r;\n\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "check_owner_password_V4(std::string& user_password,\n                        std::string const& owner_password,\n                        QPDF::EncryptionData const& data)\n{\n    // Algorithm 3.7 from the PDF 1.7 Reference Manual\n\n    unsigned char key[OU_key_bytes_V4];\n    compute_O_rc4_key(user_password, owner_password, data, key);\n    unsigned char O_data[key_bytes];\n    memcpy(O_data, QUtil::unsigned_char_pointer(data.getO()), key_bytes);\n    iterate_rc4(O_data, key_bytes, key, data.getLengthBytes(),\n                (data.getR() >= 3) ? 20 : 1, true);\n    std::string new_user_password =\n        std::string(reinterpret_cast<char*>(O_data), key_bytes);\n    bool result = false;\n    if (check_user_password(new_user_password, data))\n    {\n        result = true;\n        user_password = new_user_password;\n    }\n    return result;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "check_owner_password_V4(std::string& user_password,\n                        std::string const& owner_password,\n                        QPDF::EncryptionData const& data)\n{\n    // Algorithm 3.7 from the PDF 1.7 Reference Manual\n\n    unsigned char key[OU_key_bytes_V4];\n    compute_O_rc4_key(user_password, owner_password, data, key);\n    unsigned char O_data[key_bytes];\n    memcpy(O_data, QUtil::unsigned_char_pointer(data.getO()), key_bytes);\n    std::string k1(reinterpret_cast<char*>(key), OU_key_bytes_V4);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(O_data, key_bytes, QUtil::unsigned_char_pointer(k1),\n                data.getLengthBytes(),\n                (data.getR() >= 3) ? 20 : 1, true);\n    std::string new_user_password =\n        std::string(reinterpret_cast<char*>(O_data), key_bytes);\n    bool result = false;\n    if (check_user_password(new_user_password, data))\n    {\n        result = true;\n        user_password = new_user_password;\n    }\n    return result;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\treq.lower_file = lower_file;\n\treq.path.dentry = lower_dentry;\n\treq.path.mnt = lower_mnt;\n\n\t/* Corresponding dput() and mntput() are done when the\n\t * lower file is fput() when all eCryptfs files for the inode are\n\t * released. */\n\tflags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;\n\t(*lower_file) = dentry_open(&req.path, flags, cred);\n\tif (!IS_ERR(*lower_file))\n\t\tgoto out;\n\tif ((flags & O_ACCMODE) == O_RDONLY) {\n\t\trc = PTR_ERR((*lower_file));\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\trc = -EIO;\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\tprintk(KERN_ERR \"%s: We are in the middle of shutting down; \"\n\t\t       \"aborting privileged request to open lower file\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&req.kthread_ctl_list, &ecryptfs_kthread_ctl.req_list);\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n\twait_for_completion(&req.done);\n\tif (IS_ERR(*lower_file))\n\t\trc = PTR_ERR(*lower_file);\nout:\n\treturn rc;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\treq.lower_file = lower_file;\n\treq.path.dentry = lower_dentry;\n\treq.path.mnt = lower_mnt;\n\n\t/* Corresponding dput() and mntput() are done when the\n\t * lower file is fput() when all eCryptfs files for the inode are\n\t * released. */\n\tflags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;\n\t(*lower_file) = dentry_open(&req.path, flags, cred);\n\tif (!IS_ERR(*lower_file))\n\t\tgoto have_file;\n\tif ((flags & O_ACCMODE) == O_RDONLY) {\n\t\trc = PTR_ERR((*lower_file));\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\trc = -EIO;\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\tprintk(KERN_ERR \"%s: We are in the middle of shutting down; \"\n\t\t       \"aborting privileged request to open lower file\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&req.kthread_ctl_list, &ecryptfs_kthread_ctl.req_list);\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n\twait_for_completion(&req.done);\n\tif (IS_ERR(*lower_file)) {\n\t\trc = PTR_ERR(*lower_file);\n\t\tgoto out;\n\t}\nhave_file:\n\tif ((*lower_file)->f_op->mmap == NULL) {\n\t\tfput(*lower_file);\n\t\t*lower_file = NULL;\n\t\trc = -EMEDIUMTYPE;\n\t}\nout:\n\treturn rc;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ast2obj_arguments(void* _o)\n{\n    arguments_ty o = (arguments_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    result = PyType_GenericNew(arguments_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_list(o->args, ast2obj_arg);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_args, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_arg(o->vararg);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ast2obj_arguments(void* _o)\n{\n    arguments_ty o = (arguments_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_RETURN_NONE;\n    }\n\n    result = PyType_GenericNew(arguments_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_list(o->args, ast2obj_arg);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_args, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_arg(o->vararg);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void infra_ip_create_ratedata(struct infra_cache* infra,\n\tstruct sockaddr_storage* addr, socklen_t addrlen, time_t timenow)\n{\n\thashvalue_type h = hash_addr(addr, addrlen, 0);\n\tstruct ip_rate_key* k = (struct ip_rate_key*)calloc(1, sizeof(*k));\n\tstruct ip_rate_data* d = (struct ip_rate_data*)calloc(1, sizeof(*d));\n\tif(!k || !d) {\n\t\tfree(k);\n\t\tfree(d);\n\t\treturn; /* alloc failure */\n\t}\n\tk->addr = *addr;\n\tk->addrlen = addrlen;\n\tlock_rw_init(&k->entry.lock);\n\tk->entry.hash = h;\n\tk->entry.key = k;\n\tk->entry.data = d;\n\td->qps[0] = 1;\n\td->timestamp[0] = timenow;\n\tslabhash_insert(infra->client_ip_rates, h, &k->entry, d, NULL);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void infra_ip_create_ratedata(struct infra_cache* infra,\n\tstruct sockaddr_storage* addr, socklen_t addrlen, time_t timenow,\n\tint mesh_wait)\n{\n\thashvalue_type h = hash_addr(addr, addrlen, 0);\n\tstruct ip_rate_key* k = (struct ip_rate_key*)calloc(1, sizeof(*k));\n\tstruct ip_rate_data* d = (struct ip_rate_data*)calloc(1, sizeof(*d));\n\tif(!k || !d) {\n\t\tfree(k);\n\t\tfree(d);\n\t\treturn; /* alloc failure */\n\t}\n\tk->addr = *addr;\n\tk->addrlen = addrlen;\n\tlock_rw_init(&k->entry.lock);\n\tk->entry.hash = h;\n\tk->entry.key = k;\n\tk->entry.data = d;\n\td->qps[0] = 1;\n\td->timestamp[0] = timenow;\n\td->mesh_wait = mesh_wait;\n\tslabhash_insert(infra->client_ip_rates, h, &k->entry, d, NULL);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, DesiredAccess);     /* DesiredAccess (4 bytes) */\n\tStream_Seek_UINT64(irp->input);                    /* AllocationSize (8 bytes) */\n\tStream_Seek_UINT32(irp->input);                    /* FileAttributes (4 bytes) */\n\tStream_Read_UINT32(irp->input, SharedAccess);      /* SharedAccess (4 bytes) */\n\tStream_Read_UINT32(irp->input, CreateDisposition); /* CreateDisposition (4 bytes) */\n\tStream_Seek_UINT32(irp->input);                    /* CreateOptions (4 bytes) */\n\tStream_Read_UINT32(irp->input, PathLength);        /* PathLength (4 bytes) */\n\n\tif (Stream_GetRemainingLength(irp->input) < PathLength)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Seek(irp->input, PathLength); /* Path (variable) */\n\tassert(PathLength == 0);             /* MS-RDPESP 2.2.2.2 */\n#ifndef _WIN32\n\t/* Windows 2012 server sends on a first call :\n\t *     DesiredAccess     = 0x00100080: SYNCHRONIZE | FILE_READ_ATTRIBUTES\n\t *     SharedAccess      = 0x00000007: FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ\n\t *     CreateDisposition = 0x00000001: CREATE_NEW\n\t *\n\t * then Windows 2012 sends :\n\t *     DesiredAccess     = 0x00120089: SYNCHRONIZE | READ_CONTROL | FILE_READ_ATTRIBUTES |\n\t * FILE_READ_EA | FILE_READ_DATA SharedAccess      = 0x00000007: FILE_SHARE_DELETE |",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, DesiredAccess);     /* DesiredAccess (4 bytes) */\n\tStream_Seek_UINT64(irp->input);                    /* AllocationSize (8 bytes) */\n\tStream_Seek_UINT32(irp->input);                    /* FileAttributes (4 bytes) */\n\tStream_Read_UINT32(irp->input, SharedAccess);      /* SharedAccess (4 bytes) */\n\tStream_Read_UINT32(irp->input, CreateDisposition); /* CreateDisposition (4 bytes) */\n\tStream_Seek_UINT32(irp->input);                    /* CreateOptions (4 bytes) */\n\tStream_Read_UINT32(irp->input, PathLength);        /* PathLength (4 bytes) */\n\n\tif (!Stream_SafeSeek(irp->input, PathLength)) /* Path (variable) */\n\t\treturn ERROR_INVALID_DATA;\n\n\tassert(PathLength == 0);             /* MS-RDPESP 2.2.2.2 */\n#ifndef _WIN32\n\t/* Windows 2012 server sends on a first call :\n\t *     DesiredAccess     = 0x00100080: SYNCHRONIZE | FILE_READ_ATTRIBUTES\n\t *     SharedAccess      = 0x00000007: FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ\n\t *     CreateDisposition = 0x00000001: CREATE_NEW\n\t *\n\t * then Windows 2012 sends :\n\t *     DesiredAccess     = 0x00120089: SYNCHRONIZE | READ_CONTROL | FILE_READ_ATTRIBUTES |\n\t * FILE_READ_EA | FILE_READ_DATA SharedAccess      = 0x00000007: FILE_SHARE_DELETE |",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \"\", name[200] = \"\", path[256];\n  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    size_t oft = strtoul(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    LOG(LL_DEBUG,\n        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");\n      return (int) hm->body.len;\n    }\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \"\", name[200] = \"\", path[256];\n  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    long oft = strtol(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    remove_double_dots(path);\n    LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");\n      return (int) hm->body.len;\n    }\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tif (*p == NL)\n\t    next = newline_skip_comments(p);\n\telse if (evalarg->eval_cookie != NULL)\n\t    next = getline_peek_skip_comments(evalarg);\n\telse\n\t    next = peek_next_line_from_context(evalarg->eval_cctx);\n\n\tif (next != NULL)\n\t{\n\t    *getnext = TRUE;\n\t    return skipwhite(next);\n\t}\n    }\n    return p;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tif (*p == NL)\n\t    next = newline_skip_comments(p);\n\telse if (evalarg->eval_cookie != NULL)\n\t    next = getline_peek_skip_comments(evalarg);\n\telse\n\t    next = peek_next_line_from_context(evalarg->eval_cctx);\n\n\tif (next != NULL)\n\t{\n\t    *getnext = *p != NL;\n\t    return skipwhite(next);\n\t}\n    }\n    return p;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n    /* Initialize port */\n    fport->options = options;\n    fport->readpos = fport->buf;\n\n\n    /* ok run this for all files to be sure all are good for playback. */\n    for (index=file_count-1; index>=0; index--) {\n\n\tpjmedia_wave_hdr wavehdr;\n\tpj_ssize_t size_to_read, size_read;\n\n\t/* we end with the last one so we are good to go if still in function*/\n\tpj_memcpy(filename, file_list[index].ptr, file_list[index].slen);\n\tfilename[file_list[index].slen] = '\\0';\n\n\t/* Get the file size. */\n\tfport->current_file = index;\n\tfport->fsize_list[index] = pj_file_size(filename);\n\t\n\t/* Size must be more than WAVE header size */\n\t    goto on_error;\n\t}\n\t\n\t/* Open file. */\n\tstatus = pj_file_open( pool, filename, PJ_O_RDONLY, \n\t\t\t       &fport->fd_list[index]);\n\tif (status != PJ_SUCCESS)\n\t    goto on_error;\n\t\n\t/* Read the file header plus fmt header only. */\n\tsize_read = size_to_read = sizeof(wavehdr) - 8;\n\tstatus = pj_file_read( fport->fd_list[index], &wavehdr, &size_read);\n\tif (status != PJ_SUCCESS) {\n\t    goto on_error;\n\t}\n\n\tif (size_read != size_to_read) {\n\t    status = PJMEDIA_ENOTVALIDWAVE;\n\t    goto on_error;\n\t}\n\t\n\t\twavehdr.fmt_hdr.nchan * BYTES_PER_SAMPLE)\n\t{\n\t    status = PJMEDIA_EWAVEUNSUPP;\n\t    goto on_error;\n\t}\n\t\n\t/* If length of fmt_header is greater than 16, skip the remaining\n\t * fmt header data.\n\t */\n\tif (wavehdr.fmt_hdr.len > 16) {\n\t    size_to_read = wavehdr.fmt_hdr.len - 16;\n\t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n\t\t\t\t    PJ_SEEK_CUR);\n\t    if (status != PJ_SUCCESS) {\n\t\tgoto on_error;\n\t    }\n\t}\n\t\n\t/* Repeat reading the WAVE file until we have 'data' chunk */\n\tfor (;;) {\n\t    pjmedia_wave_subchunk subchunk;\n\t    /* Normalize endianness */\n\t    PJMEDIA_WAVE_NORMALIZE_SUBCHUNK(&subchunk);\n\t    \n\t    /* Break if this is \"data\" chunk */\n\t    if (subchunk.id == PJMEDIA_DATA_TAG) {\n\t\twavehdr.data_hdr.data = PJMEDIA_DATA_TAG;\n\t\twavehdr.data_hdr.len = subchunk.len;\n\t\tbreak;\n\t    }\n\t    \n\t    /* Otherwise skip the chunk contents */\n\t    size_to_read = subchunk.len;\n\t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n\t\t\t\t    PJ_SEEK_CUR);\n\t    if (status != PJ_SUCCESS) {\n\t\tgoto on_error;\n\t    }\n\t}\n\t\n\t/* Current file position now points to start of data */\n\tstatus = pj_file_getpos(fport->fd_list[index], &pos);\n\tfport->start_data_list[index] = (unsigned)pos;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n    /* Initialize port */\n    fport->options = options;\n    fport->readpos = fport->buf;\n\n\n    /* ok run this for all files to be sure all are good for playback. */\n    for (index=file_count-1; index>=0; index--) {\n\n\tpjmedia_wave_hdr wavehdr;\n\tpj_ssize_t size_read;\n\tpj_off_t size_to_read;\n\n\t/* we end with the last one so we are good to go if still in function*/\n\tpj_memcpy(filename, file_list[index].ptr, file_list[index].slen);\n\tfilename[file_list[index].slen] = '\\0';\n\n\t/* Get the file size. */\n\tfport->current_file = index;\n\tfport->fsize_list[index] = pj_file_size(filename);\n\t\n\t/* Size must be more than WAVE header size */\n\t    goto on_error;\n\t}\n\t\n\t/* Open file. */\n\tstatus = pj_file_open( pool, filename, PJ_O_RDONLY, \n\t\t\t       &fport->fd_list[index]);\n\tif (status != PJ_SUCCESS)\n\t    goto on_error;\n\t\n\t/* Read the file header plus fmt header only. */\n\tsize_to_read = size_read = sizeof(wavehdr) - 8;\t\n\tstatus = pj_file_read( fport->fd_list[index], &wavehdr, &size_read);\n\tif (status != PJ_SUCCESS) {\n\t    goto on_error;\n\t}\n\n\tif (size_read != size_to_read) {\n\t    status = PJMEDIA_ENOTVALIDWAVE;\n\t    goto on_error;\n\t}\n\t\n\t\twavehdr.fmt_hdr.nchan * BYTES_PER_SAMPLE)\n\t{\n\t    status = PJMEDIA_EWAVEUNSUPP;\n\t    goto on_error;\n\t}\n\t\n\t/* If length of fmt_header is greater than 16, skip the remaining\n\t * fmt header data.\n\t */\n\tif (wavehdr.fmt_hdr.len > 16) {\n\t    PJ_CHECK_OVERFLOW_UINT32_TO_LONG(wavehdr.fmt_hdr.len-16,\n\t\t\t       status = PJMEDIA_ENOTVALIDWAVE; goto on_error;);\n\t    size_to_read = (pj_off_t)wavehdr.fmt_hdr.len - 16;\n\t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n\t\t\t\t    PJ_SEEK_CUR);\n\t    if (status != PJ_SUCCESS) {\n\t\tgoto on_error;\n\t    }\n\t}\n\t\n\t/* Repeat reading the WAVE file until we have 'data' chunk */\n\tfor (;;) {\n\t    pjmedia_wave_subchunk subchunk;\n\t    PJMEDIA_WAVE_NORMALIZE_SUBCHUNK(&subchunk);\n\t    \n\t    /* Break if this is \"data\" chunk */\n\t    if (subchunk.id == PJMEDIA_DATA_TAG) {\n\t\twavehdr.data_hdr.data = PJMEDIA_DATA_TAG;\n\t\twavehdr.data_hdr.len = subchunk.len;\n\t\tbreak;\n\t    }\n\t    \n\t    /* Otherwise skip the chunk contents */\n\t    PJ_CHECK_OVERFLOW_UINT32_TO_LONG(subchunk.len, \n\t\t\t       status = PJMEDIA_ENOTVALIDWAVE; goto on_error;);\n\t    size_to_read = subchunk.len;\n\n\t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n\t\t\t\t    PJ_SEEK_CUR);\n\t    if (status != PJ_SUCCESS) {\n\t\tgoto on_error;\n\t    }\n\t}\n\t\n\t/* Current file position now points to start of data */\n\tstatus = pj_file_getpos(fport->fd_list[index], &pos);\n\tfport->start_data_list[index] = (unsigned)pos;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "inline void AveragePool(const PoolParams& params,\n                        const RuntimeShape& input_shape,\n                        const int8_t* input_data,\n                        const RuntimeShape& output_shape, int8_t* output_data) {\n  TFLITE_DCHECK_LE(params.quantized_activation_min,\n                   params.quantized_activation_max);\n  TFLITE_DCHECK_EQ(input_shape.DimensionsCount(), 4);\n  TFLITE_DCHECK_EQ(output_shape.DimensionsCount(), 4);\n  const int batches = MatchingDim(input_shape, 0, output_shape, 0);\n  const int depth = MatchingDim(input_shape, 3, output_shape, 3);\n  const int input_height = input_shape.Dims(1);\n  const int input_width = input_shape.Dims(2);\n  const int output_height = output_shape.Dims(1);\n  const int output_width = output_shape.Dims(2);\n  const int stride_height = params.stride_height;\n  const int stride_width = params.stride_width;\n  for (int batch = 0; batch < batches; ++batch) {\n    for (int out_y = 0; out_y < output_height; ++out_y) {\n      for (int out_x = 0; out_x < output_width; ++out_x) {\n        for (int channel = 0; channel < depth; ++channel) {\n          const int in_x_origin =\n              (out_x * stride_width) - params.padding_values.width;\n          const int in_y_origin =\n              (out_y * stride_height) - params.padding_values.height;\n          // Compute the boundaries of the filter region clamped so as to\n          // ensure that the filter window fits in the input array.\n          const int filter_x_start = std::max(0, -in_x_origin);\n          const int filter_x_end =\n              std::min(params.filter_width, input_width - in_x_origin);\n          const int filter_y_start = std::max(0, -in_y_origin);\n          const int filter_y_end =\n              std::min(params.filter_height, input_height - in_y_origin);\n          int32_t acc = 0;\n          int filter_count = 0;\n          for (int filter_y = filter_y_start; filter_y < filter_y_end;\n               ++filter_y) {\n            for (int filter_x = filter_x_start; filter_x < filter_x_end;\n                 ++filter_x) {\n              const int in_x = in_x_origin + filter_x;\n              const int in_y = in_y_origin + filter_y;\n              acc +=\n                  input_data[Offset(input_shape, batch, in_y, in_x, channel)];\n              filter_count++;\n            }\n          }\n          // Round to the closest integer value.\n          acc = acc > 0 ? (acc + filter_count / 2) / filter_count\n                        : (acc - filter_count / 2) / filter_count;\n          acc = std::max(acc, params.quantized_activation_min);\n          acc = std::min(acc, params.quantized_activation_max);\n          output_data[Offset(output_shape, batch, out_y, out_x, channel)] =\n              static_cast<int8_t>(acc);\n        }\n      }\n    }\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "inline bool AveragePool(const PoolParams& params,\n                        const RuntimeShape& input_shape,\n                        const int8_t* input_data,\n                        const RuntimeShape& output_shape, int8_t* output_data) {\n  TFLITE_DCHECK_LE(params.quantized_activation_min,\n                   params.quantized_activation_max);\n  TFLITE_DCHECK_EQ(input_shape.DimensionsCount(), 4);\n  TFLITE_DCHECK_EQ(output_shape.DimensionsCount(), 4);\n  const int batches = MatchingDim(input_shape, 0, output_shape, 0);\n  const int depth = MatchingDim(input_shape, 3, output_shape, 3);\n  const int input_height = input_shape.Dims(1);\n  const int input_width = input_shape.Dims(2);\n  const int output_height = output_shape.Dims(1);\n  const int output_width = output_shape.Dims(2);\n  const int stride_height = params.stride_height;\n  const int stride_width = params.stride_width;\n  for (int batch = 0; batch < batches; ++batch) {\n    for (int out_y = 0; out_y < output_height; ++out_y) {\n      for (int out_x = 0; out_x < output_width; ++out_x) {\n        for (int channel = 0; channel < depth; ++channel) {\n          const int in_x_origin =\n              (out_x * stride_width) - params.padding_values.width;\n          const int in_y_origin =\n              (out_y * stride_height) - params.padding_values.height;\n          // Compute the boundaries of the filter region clamped so as to\n          // ensure that the filter window fits in the input array.\n          const int filter_x_start = std::max(0, -in_x_origin);\n          const int filter_x_end =\n              std::min(params.filter_width, input_width - in_x_origin);\n          const int filter_y_start = std::max(0, -in_y_origin);\n          const int filter_y_end =\n              std::min(params.filter_height, input_height - in_y_origin);\n          int32_t acc = 0;\n          int filter_count = 0;\n          for (int filter_y = filter_y_start; filter_y < filter_y_end;\n               ++filter_y) {\n            for (int filter_x = filter_x_start; filter_x < filter_x_end;\n                 ++filter_x) {\n              const int in_x = in_x_origin + filter_x;\n              const int in_y = in_y_origin + filter_y;\n              acc +=\n                  input_data[Offset(input_shape, batch, in_y, in_x, channel)];\n              filter_count++;\n            }\n          }\n          if (filter_count == 0) return false;\n          // Round to the closest integer value.\n          acc = acc > 0 ? (acc + filter_count / 2) / filter_count\n                        : (acc - filter_count / 2) / filter_count;\n          acc = std::max(acc, params.quantized_activation_min);\n          acc = std::min(acc, params.quantized_activation_max);\n          output_data[Offset(output_shape, batch, out_y, out_x, channel)] =\n              static_cast<int8_t>(acc);\n        }\n      }\n    }\n  }\n  return true;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n  if (!FindMember(o, \"values\", values_iterator)) {\n    (*err) = \"the sparse object ob ths accessor doesn't have values\";\n    return false;\n  }\n\n  const json &indices_obj = GetValue(indices_iterator);\n  const json &values_obj = GetValue(values_iterator);\n\n  int indices_buffer_view = 0, indices_byte_offset = 0, component_type = 0;\n  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj, \"bufferView\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&indices_byte_offset, err, indices_obj, \"byteOffset\",\n                       false);\n  if (!ParseIntegerProperty(&component_type, err, indices_obj, \"componentType\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n\n  int values_buffer_view = 0, values_byte_offset = 0;\n  if (!ParseIntegerProperty(&values_buffer_view, err, values_obj, \"bufferView\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&values_byte_offset, err, values_obj, \"byteOffset\",\n                       false);\n\n  accessor->sparse.count = count;\n  accessor->sparse.indices.bufferView = indices_buffer_view;\n  accessor->sparse.indices.byteOffset = indices_byte_offset;\n  accessor->sparse.indices.componentType = component_type;\n  accessor->sparse.values.bufferView = values_buffer_view;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n  if (!FindMember(o, \"values\", values_iterator)) {\n    (*err) = \"the sparse object ob ths accessor doesn't have values\";\n    return false;\n  }\n\n  const json &indices_obj = GetValue(indices_iterator);\n  const json &values_obj = GetValue(values_iterator);\n\n  int indices_buffer_view = 0, indices_byte_offset = 0, component_type = 0;\n  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj,\n                            \"bufferView\", true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&indices_byte_offset, err, indices_obj, \"byteOffset\",\n                       false);\n  if (!ParseIntegerProperty(&component_type, err, indices_obj, \"componentType\",\n                            true, \"SparseAccessor\")) {\n    return false;\n  }\n\n  int values_buffer_view = 0, values_byte_offset = 0;\n  if (!ParseIntegerProperty(&values_buffer_view, err, values_obj, \"bufferView\",\n                            true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&values_byte_offset, err, values_obj, \"byteOffset\",\n                       false);\n\n  accessor->sparse.count = count;\n  accessor->sparse.indices.bufferView = indices_buffer_view;\n  accessor->sparse.indices.byteOffset = indices_byte_offset;\n  accessor->sparse.indices.componentType = component_type;\n  accessor->sparse.values.bufferView = values_buffer_view;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void usage(int status)\n{\n\tFILE *dest = (status == 0) ? stdout : stderr;\n\n\tif(status == 0){\n\t\tfprintf(dest,\n\t\t\t\"%s(1)\\t\\t\\tcopyright <Pierre-Fran\u00e7ois Monville>\\t\\t\\t%s(1)\\n\\nNAME\\n\\t%s -- crypt or decrypt any data\\n\\nSYNOPSIS\\n\\t%s [-h | --help] FILE [-s | --standard | KEYFILE]\\n\\nDESCRIPTION\\n\\t(FR) permet de chiffrer et de d\u00e9chiffrer toutes les donn\u00e9es entr\u00e9es en param\u00e8tre le mot de passe demand\u00e9 au d\u00e9but est hash\u00e9 puis sert de graine pour le PRNG le PRNG permet de fournir une cl\u00e9 unique \u00e9gale \u00e0 la longueur du fichier \u00e0 coder. La cl\u00e9 unique subit un xor avec le mot de passe (le mot de passe est r\u00e9p\u00e9t\u00e9 autant de fois que n\u00e9c\u00e9ssaire). Le fichier subit un xor avec cette cl\u00e9 Puis un brouilleur est utilis\u00e9, il m\u00e9lange la table des caract\u00e8res (ascii) en utilisant le PRNG ou en utilisant le keyFile fourni.\\n\\t(EN) Can crypt and decrypt any data given in argument. The password asked is hashed to be used as a seed for the PRNG. The PRNG gives a unique key which has the same length as the source file. The key is xored with the password (the password is repeated as long as necessary). The file is then xored with this new key, then a scrambler is used. It scrambles the ascii table using the PRNG or the keyFile given\\n\\nOPTIONS\\n\\tthe options are as follows:\\n\\n\\t-h | --help\\tfurther help.\\n\\n\\t-s | --standard\\tput the scrambler on off.\\n\\n\\t-i | --inverted\\tinverts the coding/decoding process, first it xors then it scrambles.\\n\\nEXIT STATUS\\n\\tthe %s program exits 0 on success, and anything else if an error occurs.\\n\\nEXAMPLES\\n\\tthe command:\\t%s file1\\n\\n\\tlets you choose between crypting or decrypting then it will prompt for a password that crypt/decrypt file1 as xfile1 in the same folder, file1 is not modified.\\n\\n\\tthe command:\\t%s file2 keyfile1\\n\\n\\tlets you choose between crypting or decrypting, will prompt for the password that crypt/decrypt file2, uses keyfile1 to generate the scrambler then crypt/decrypt file2 as file2x in the same folder, file2 is not modified.\\n\\n\\tthe command:\\t%s file3 -s\\n\\n\\tlets you choose between crypting or decrypting, will prompt for a password that crypt/decrypt the file without using the scrambler, resulting in using the unique key only.\\n\", progName, progName, progName, progName, progName, progName, progName, progName);\n\t} else{\n\t\tfprintf(dest,\n\t\t\t\"Usage : %s [-h | --help] FILE [-s | --standard | -i | --inverted] [KEYFILE]\\nOptions :\\n  -h --help :\\t\\tfurther help\\n  -s --standard :\\tput the scrambler off\\n  -i --inverted :\\tinverts the coding/decoding process\\n  KEYFILE :\\t\\tpath to a keyfile that generates the scrambler instead of the password\\n\", progName);\n\t}\n\texit(status);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void usage(int status)\n{\n\tFILE *dest = (status == 0) ? stdout : stderr;\n\n\tif(status == 0){\n\t\tfprintf(dest,\n\t\t\t\"%s(1)\\t\\t\\tcopyright <Pierre-Fran\u00e7ois Monville>\\t\\t\\t%s(1)\\n\\nNAME\\n\\t%s -- crypt or decrypt any data\\n\\nSYNOPSIS\\n\\t%s [-h | --help] FILE [-s | --standard | KEYFILE]\\n\\nDESCRIPTION\\n\\t(FR) permet de chiffrer et de d\u00e9chiffrer toutes les donn\u00e9es entr\u00e9es en param\u00e8tre le mot de passe demand\u00e9 au d\u00e9but est hash\u00e9 puis sert de graine pour le PRNG le PRNG permet de fournir une cl\u00e9 unique \u00e9gale \u00e0 la longueur du fichier \u00e0 coder. La cl\u00e9 unique subit un xor avec le mot de passe (le mot de passe est r\u00e9p\u00e9t\u00e9 autant de fois que n\u00e9c\u00e9ssaire). Le fichier subit un xor avec cette cl\u00e9 Puis un brouilleur est utilis\u00e9, il m\u00e9lange la table des caract\u00e8res (ascii) en utilisant le PRNG ou en utilisant le keyFile fourni.\\n\\t(EN) Can crypt and decrypt any data given in argument. The password asked is hashed to be used as a seed for the PRNG. The PRNG gives a unique key which has the same length as the source file. The key is xored with the password (the password is repeated as long as necessary). The file is then xored with this new key, then a scrambler is used. It scrambles the ascii table using the PRNG or the keyFile given\\n\\nOPTIONS\\n\\tthe options are as follows:\\n\\n\\t-h | --help\\tfurther help.\\n\\n\\t-s | --standard\\tput the scrambler on off.\\n\\n\\t-i | --inverted\\tinverts the coding/decoding process, first it xors then it scrambles.\\n\\n\\tKEYFILE    \\tthe path to a file which will be used to scramble the substitution's tables and choose in which order they will be used instead of the PRNG only (starting at 2.5 ko for the keyfile is great, however not interesting to be too heavy) \\n\\nEXIT STATUS\\n\\tthe %s program exits 0 on success, and anything else if an error occurs.\\n\\nEXAMPLES\\n\\tthe command:\\t%s file1\\n\\n\\tlets you choose between crypting or decrypting then it will prompt for a password that crypt/decrypt file1 as xfile1 in the same folder, file1 is not modified.\\n\\n\\tthe command:\\t%s file2 keyfile1\\n\\n\\tlets you choose between crypting or decrypting, will prompt for the password that crypt/decrypt file2, uses keyfile1 to generate the scrambler then crypt/decrypt file2 as file2x in the same folder, file2 is not modified.\\n\\n\\tthe command:\\t%s file3 -s\\n\\n\\tlets you choose between crypting or decrypting, will prompt for a password that crypt/decrypt the file without using the scrambler, resulting in using the unique key only.\\n\", progName, progName, progName, progName, progName, progName, progName, progName);\n\t} else{\n\t\tfprintf(dest,\n\t\t\t\"Version : 2.3\\nUsage : %s [-h | --help] FILE [-s | --standard | -i | --inverted] [KEYFILE]\\nOptions :\\n  -h --help :\\t\\tfurther help\\n  -s --standard :\\tput the scrambler off\\n  -i --inverted :\\tinverts the coding/decoding process\\n  KEYFILE :\\t\\tpath to a keyfile that scrambles the substitution's tables and choose they order instead of the PRNG only\\n\", progName);\n\t}\n\texit(status);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "         //Compute CRC over the current MAC address\n         crc = enc28j60CalcCrc(&entry->addr, sizeof(MacAddr));\n         //Calculate the corresponding index in the table\n         k = (crc >> 23) & 0x3F;\n         //Update hash table contents\n         hashTable[k / 8] |= (1 << (k % 8));\n      }\n   }\n\n   //Write the hash table to the ENC28J60 controller\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT0, hashTable[0]);\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT1, hashTable[1]);\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT2, hashTable[2]);\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT3, hashTable[3]);\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT4, hashTable[4]);\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT5, hashTable[5]);\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT6, hashTable[6]);\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT7, hashTable[7]);\n\n   //Debug message\n   TRACE_DEBUG(\"  EHT0 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT0));\n   TRACE_DEBUG(\"  EHT1 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT1));\n   TRACE_DEBUG(\"  EHT2 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT2));\n   TRACE_DEBUG(\"  EHT3 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT3));\n   TRACE_DEBUG(\"  EHT0 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT4));\n   TRACE_DEBUG(\"  EHT1 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT5));\n   TRACE_DEBUG(\"  EHT2 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT6));\n   TRACE_DEBUG(\"  EHT3 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT7));\n\n   //Successful processing\n   return NO_ERROR;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "         //Compute CRC over the current MAC address\n         crc = enc28j60CalcCrc(&entry->addr, sizeof(MacAddr));\n         //Calculate the corresponding index in the table\n         k = (crc >> 23) & 0x3F;\n         //Update hash table contents\n         hashTable[k / 8] |= (1 << (k % 8));\n      }\n   }\n\n   //Write the hash table to the ENC28J60 controller\n   enc28j60WriteReg(interface, ENC28J60_EHT0, hashTable[0]);\n   enc28j60WriteReg(interface, ENC28J60_EHT1, hashTable[1]);\n   enc28j60WriteReg(interface, ENC28J60_EHT2, hashTable[2]);\n   enc28j60WriteReg(interface, ENC28J60_EHT3, hashTable[3]);\n   enc28j60WriteReg(interface, ENC28J60_EHT4, hashTable[4]);\n   enc28j60WriteReg(interface, ENC28J60_EHT5, hashTable[5]);\n   enc28j60WriteReg(interface, ENC28J60_EHT6, hashTable[6]);\n   enc28j60WriteReg(interface, ENC28J60_EHT7, hashTable[7]);\n\n   //Debug message\n   TRACE_DEBUG(\"  EHT0 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT0));\n   TRACE_DEBUG(\"  EHT1 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT1));\n   TRACE_DEBUG(\"  EHT2 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT2));\n   TRACE_DEBUG(\"  EHT3 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT3));\n   TRACE_DEBUG(\"  EHT0 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT4));\n   TRACE_DEBUG(\"  EHT1 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT5));\n   TRACE_DEBUG(\"  EHT2 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT6));\n   TRACE_DEBUG(\"  EHT3 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT7));\n\n   //Successful processing\n   return NO_ERROR;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  FILE* fh;\n  if (fd==1) fh=stdout;\n  else if (fd==2) fh=stderr;\n  else { return; }\n\n#define LOG0(t) log2fh(fh, t)\n#define LOG1(t,d) log2fh(fh, t,d)\n#define LOG2(t,d1,d2) log2fh(fh, t,d1,d2)\n#define LOG3(t,d1,d2,d3) log2fh(fh, t,d1,d2,d3)\n#define LOG4(t,d1,d2,d3,d4) log2fh(fh, t,d1,d2,d3,d4)\n\n  const pic_parameter_set* pps = ctx->get_pps(slice_pic_parameter_set_id);\n  assert(pps->pps_read); // TODO: error handling\n\n  const seq_parameter_set* sps = ctx->get_sps((int)pps->seq_parameter_set_id);\n  assert(sps->sps_read); // TODO: error handling\n\n\n  LOG0(\"----------------- SLICE -----------------\\n\");\n  LOG1(\"first_slice_segment_in_pic_flag      : %d\\n\", first_slice_segment_in_pic_flag);\n  if (ctx->get_nal_unit_type() >= NAL_UNIT_BLA_W_LP &&\n      ctx->get_nal_unit_type() <= NAL_UNIT_RESERVED_IRAP_VCL23) {\n    LOG1(\"no_output_of_prior_pics_flag         : %d\\n\", no_output_of_prior_pics_flag);\n  }\n\n  LOG1(\"slice_pic_parameter_set_id           : %d\\n\", slice_pic_parameter_set_id);\n\n  if (!first_slice_segment_in_pic_flag) {\n    //if (pps->dependent_slice_segments_enabled_flag) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  if (fd==1) fh=stdout;\n  else if (fd==2) fh=stderr;\n  else { return; }\n\n#define LOG0(t) log2fh(fh, t)\n#define LOG1(t,d) log2fh(fh, t,d)\n#define LOG2(t,d1,d2) log2fh(fh, t,d1,d2)\n#define LOG3(t,d1,d2,d3) log2fh(fh, t,d1,d2,d3)\n#define LOG4(t,d1,d2,d3,d4) log2fh(fh, t,d1,d2,d3,d4)\n\n  LOG0(\"----------------- SLICE -----------------\\n\");\n\n  const pic_parameter_set* pps = ctx->get_pps(slice_pic_parameter_set_id);\n  if (!pps) {\n    LOG0(\"invalid PPS referenced\\n\");\n    return;\n  }\n  assert(pps->pps_read); // TODO: error handling\n\n  const seq_parameter_set* sps = ctx->get_sps((int)pps->seq_parameter_set_id);\n  if (!sps) {\n    LOG0(\"invalid SPS referenced\\n\");\n    return;\n  }\n  assert(sps->sps_read); // TODO: error handling\n\n\n  LOG1(\"first_slice_segment_in_pic_flag      : %d\\n\", first_slice_segment_in_pic_flag);\n  if (ctx->get_nal_unit_type() >= NAL_UNIT_BLA_W_LP &&\n      ctx->get_nal_unit_type() <= NAL_UNIT_RESERVED_IRAP_VCL23) {\n    LOG1(\"no_output_of_prior_pics_flag         : %d\\n\", no_output_of_prior_pics_flag);\n  }\n\n  LOG1(\"slice_pic_parameter_set_id           : %d\\n\", slice_pic_parameter_set_id);\n\n  if (!first_slice_segment_in_pic_flag) {\n    //if (pps->dependent_slice_segments_enabled_flag) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int rds_loop_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\t\t unsigned int hdr_off, unsigned int sg,\n\t\t\t unsigned int off)\n{\n\t/* Do not send cong updates to loopback */\n\tif (rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\treturn sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;\n\t}\n\n\tBUG_ON(hdr_off || sg || off);\n\n\trds_inc_init(&rm->m_inc, conn, conn->c_laddr);\n\t/* For the embedded inc. Matching put is in loop_inc_free() */\n\trds_message_addref(rm);\n\n\trds_recv_incoming(conn, conn->c_laddr, conn->c_faddr, &rm->m_inc,\n\t\t\t  GFP_KERNEL, KM_USER0);\n\n\trds_send_drop_acked(conn, be64_to_cpu(rm->m_inc.i_hdr.h_sequence),\n\t\t\t    NULL);\n\n\trds_inc_put(&rm->m_inc);\n\n\treturn sizeof(struct rds_header) + be32_to_cpu(rm->m_inc.i_hdr.h_len);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int rds_loop_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\t\t unsigned int hdr_off, unsigned int sg,\n\t\t\t unsigned int off)\n{\n\tstruct scatterlist *sgp = &rm->data.op_sg[sg];\n\tint ret = sizeof(struct rds_header) +\n\t\t\tbe32_to_cpu(rm->m_inc.i_hdr.h_len);\n\n\t/* Do not send cong updates to loopback */\n\tif (rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\tret = min_t(int, ret, sgp->length - conn->c_xmit_data_off);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(hdr_off || sg || off);\n\n\trds_inc_init(&rm->m_inc, conn, conn->c_laddr);\n\t/* For the embedded inc. Matching put is in loop_inc_free() */\n\trds_message_addref(rm);\n\n\trds_recv_incoming(conn, conn->c_laddr, conn->c_faddr, &rm->m_inc,\n\t\t\t  GFP_KERNEL, KM_USER0);\n\n\trds_send_drop_acked(conn, be64_to_cpu(rm->m_inc.i_hdr.h_sequence),\n\t\t\t    NULL);\n\n\trds_inc_put(&rm->m_inc);\nout:\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({nrows + 1}),\n                                            &rt_nested_splits_out));\n    auto rt_nested_splits = rt_nested_splits_out->flat<SPLITS_TYPE>();\n    rt_nested_splits(0) = 0;\n    for (int row = 0; row < nrows; ++row) {\n      T start = broadcast_starts ? starts(0) : starts(row);\n      T limit = broadcast_limits ? limits(0) : limits(row);\n      T delta = broadcast_deltas ? deltas(0) : deltas(row);\n      OP_REQUIRES(context, delta != 0, InvalidArgument(\"Requires delta != 0\"));\n      rt_nested_splits(row + 1) =\n          rt_nested_splits(row) + RangeSize(start, limit, delta);\n    }\n    SPLITS_TYPE nvals = rt_nested_splits(nrows);\n\n    // Construct the rt_dense_values tensor.\n    Tensor* rt_dense_values_out = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, TensorShape({nvals}),\n                                                     &rt_dense_values_out));\n    auto rt_dense_values = rt_dense_values_out->flat<T>();\n    int value_index = 0;\n    for (int row = 0; row < nrows; ++row) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({nrows + 1}),\n                                            &rt_nested_splits_out));\n    auto rt_nested_splits = rt_nested_splits_out->flat<SPLITS_TYPE>();\n    rt_nested_splits(0) = 0;\n    for (int row = 0; row < nrows; ++row) {\n      T start = broadcast_starts ? starts(0) : starts(row);\n      T limit = broadcast_limits ? limits(0) : limits(row);\n      T delta = broadcast_deltas ? deltas(0) : deltas(row);\n      OP_REQUIRES(context, delta != 0, InvalidArgument(\"Requires delta != 0\"));\n      int64_t size;  // The number of elements in the specified range.\n      if (((delta > 0) && (limit < start)) ||\n          ((delta < 0) && (limit > start))) {\n        size = 0;\n      } else if (std::is_integral<T>::value) {\n        // The following is copied from tensorflow::RangeOp::Compute().\n        size = Eigen::divup(Eigen::numext::abs(limit - start),\n                            Eigen::numext::abs(delta));\n      } else {\n        // The following is copied from tensorflow::RangeOp::Compute().\n        auto size_auto =\n            Eigen::numext::ceil(Eigen::numext::abs((limit - start) / delta));\n        OP_REQUIRES(\n            context, size_auto <= std::numeric_limits<int64_t>::max(),\n            errors::InvalidArgument(\"Requires ((limit - start) / delta) <= \",\n                                    std::numeric_limits<int64_t>::max()));\n        size = static_cast<int64_t>(size_auto);\n      }\n      rt_nested_splits(row + 1) = rt_nested_splits(row) + size;\n    }\n    SPLITS_TYPE nvals = rt_nested_splits(nrows);\n\n    // Construct the rt_dense_values tensor.\n    Tensor* rt_dense_values_out = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, TensorShape({nvals}),\n                                                     &rt_dense_values_out));\n    auto rt_dense_values = rt_dense_values_out->flat<T>();\n    int value_index = 0;\n    for (int row = 0; row < nrows; ++row) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\ticonInfo->cbColorTable = 0;\n\t\t\tbreak;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, iconInfo->cbBitsMask);  /* cbBitsMask (2 bytes) */\n\tStream_Read_UINT16(s, iconInfo->cbBitsColor); /* cbBitsColor (2 bytes) */\n\n\tif (Stream_GetRemainingLength(s) < iconInfo->cbBitsMask + iconInfo->cbBitsColor)\n\t\treturn FALSE;\n\n\t/* bitsMask */\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\tif (!newBitMask)\n\t{\n\t\tfree(iconInfo->bitsMask);\n\t\ticonInfo->bitsMask = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsMask = newBitMask;\n\tStream_Read(s, iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\t/* colorTable */\n\tif (iconInfo->colorTable == NULL)\n\t{\n\t\tif (iconInfo->cbColorTable)\n\t\t{\n\t\t\ticonInfo->colorTable = (BYTE*)malloc(iconInfo->cbColorTable);\n\n\t\t\tif (!iconInfo->colorTable)\n\t\t}\n\n\t\ticonInfo->colorTable = new_tab;\n\t}\n\telse\n\t{\n\t\tfree(iconInfo->colorTable);\n\t\ticonInfo->colorTable = NULL;\n\t}\n\n\tif (iconInfo->colorTable)\n\t\tStream_Read(s, iconInfo->colorTable, iconInfo->cbColorTable);\n\n\t/* bitsColor */\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsColor, iconInfo->cbBitsColor);\n\n\tif (!newBitMask)\n\t{\n\t\tfree(iconInfo->bitsColor);\n\t\ticonInfo->bitsColor = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsColor = newBitMask;\n\tStream_Read(s, iconInfo->bitsColor, iconInfo->cbBitsColor);\n\treturn TRUE;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tdefault:\n\t\t\ticonInfo->cbColorTable = 0;\n\t\t\tbreak;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, iconInfo->cbBitsMask);  /* cbBitsMask (2 bytes) */\n\tStream_Read_UINT16(s, iconInfo->cbBitsColor); /* cbBitsColor (2 bytes) */\n\n\t/* bitsMask */\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\tif (!newBitMask)\n\t{\n\t\tfree(iconInfo->bitsMask);\n\t\ticonInfo->bitsMask = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsMask = newBitMask;\n\tif (Stream_GetRemainingLength(s) < iconInfo->cbBitsMask)\n\t\treturn FALSE;\n\tStream_Read(s, iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\t/* colorTable */\n\tif (iconInfo->colorTable == NULL)\n\t{\n\t\tif (iconInfo->cbColorTable)\n\t\t{\n\t\t\ticonInfo->colorTable = (BYTE*)malloc(iconInfo->cbColorTable);\n\n\t\t\tif (!iconInfo->colorTable)\n\n\t\ticonInfo->colorTable = new_tab;\n\t}\n\telse\n\t{\n\t\tfree(iconInfo->colorTable);\n\t\ticonInfo->colorTable = NULL;\n\t}\n\n\tif (iconInfo->colorTable)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < iconInfo->cbColorTable)\n\t\t\treturn FALSE;\n\t\tStream_Read(s, iconInfo->colorTable, iconInfo->cbColorTable);\n\t}\n\n\t/* bitsColor */\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsColor, iconInfo->cbBitsColor);\n\n\tif (!newBitMask)\n\t{\n\t\tfree(iconInfo->bitsColor);\n\t\ticonInfo->bitsColor = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsColor = newBitMask;\n\tif (Stream_GetRemainingLength(s) < iconInfo->cbBitsColor)\n\t\treturn FALSE;\n\tStream_Read(s, iconInfo->bitsColor, iconInfo->cbBitsColor);\n\treturn TRUE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n\tdec->tilexoff = siz->tilexoff;\n\tdec->tileyoff = siz->tileyoff;\n\tdec->numcomps = siz->numcomps;\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tdec->numtiles = dec->numhtiles * dec->numvtiles;\n\tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n\t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n\tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno / dec->numhtiles;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\tsize_t size;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n\tdec->tilexoff = siz->tilexoff;\n\tdec->tileyoff = siz->tileyoff;\n\tdec->numcomps = siz->numcomps;\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tif (!jas_safe_size_mul(dec->numhtiles, dec->numvtiles, &size)) {\n\t\treturn -1;\n\t}\n\tdec->numtiles = size;\n\tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n\t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n\tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno / dec->numhtiles;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_8read_strings(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self, Py_ssize_t __pyx_v_n_items, PyObject *__pyx_v_encoding) {\n  PyObject *__pyx_v_items = NULL;\n  Py_ssize_t __pyx_v_i;\n  char *__pyx_v_buffer_ptr;\n  Py_ssize_t __pyx_v_right;\n  Py_ssize_t __pyx_v_size;\n  Py_ssize_t __pyx_v_shift;\n  Py_ssize_t __pyx_v_bytes_read;\n  unsigned char __pyx_v_b;\n  char *__pyx_v_c_string;\n  Py_ssize_t __pyx_v_c_string_size;\n  char *__pyx_v_c_encoding;\n  PyObject *__pyx_v_rv = 0;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  int __pyx_t_2;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  char *__pyx_t_5;\n  Py_ssize_t __pyx_t_6;\n  Py_ssize_t __pyx_t_7;\n  Py_ssize_t __pyx_t_8;\n  Py_ssize_t __pyx_t_9;\n  Py_ssize_t __pyx_t_10;\n  Py_ssize_t __pyx_t_11;\n  PyObject *__pyx_t_12 = NULL;\n  PyObject *__pyx_t_13 = NULL;\n  PyObject *__pyx_t_14 = NULL;\n  int __pyx_t_15;\n  PyObject *__pyx_t_16 = NULL;\n  __Pyx_RefNannySetupContext(\"read_strings\", 0);\n  __Pyx_INCREF(__pyx_v_encoding);\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":67\n *         We inline strings reading logic here to avoid this overhead.\n *         \"\"\"\n *         items = PyTuple_New(n_items)             # <<<<<<<<<<<<<<\n * \n *         cdef Py_ssize_t i\n */\n  __pyx_t_1 = PyTuple_New(__pyx_v_n_items); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 67, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_items = ((PyObject*)__pyx_t_1);\n  __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":71\n *         cdef Py_ssize_t i\n *         # Buffer vars\n *         cdef char* buffer_ptr = PyByteArray_AsString(self.buffer)             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t right\n *         # String length vars\n */\n  __pyx_t_1 = __pyx_v_self->buffer;\n  __Pyx_INCREF(__pyx_t_1);\n  __pyx_v_buffer_ptr = PyByteArray_AsString(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":78\n * \n *         # String for decode vars.\n *         cdef char *c_string = NULL             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t c_string_size = 1024\n *         cdef char *c_encoding = NULL\n */\n  __pyx_v_c_string = NULL;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":79\n *         # String for decode vars.\n *         cdef char *c_string = NULL\n *         cdef Py_ssize_t c_string_size = 1024             # <<<<<<<<<<<<<<\n *         cdef char *c_encoding = NULL\n *         if encoding:\n */\n  __pyx_v_c_string_size = 0x400;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":80\n *         cdef char *c_string = NULL\n *         cdef Py_ssize_t c_string_size = 1024\n *         cdef char *c_encoding = NULL             # <<<<<<<<<<<<<<\n *         if encoding:\n *             encoding = encoding.encode('utf-8')\n */\n  __pyx_v_c_encoding = NULL;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":81\n *         cdef Py_ssize_t c_string_size = 1024\n *         cdef char *c_encoding = NULL\n *         if encoding:             # <<<<<<<<<<<<<<\n *             encoding = encoding.encode('utf-8')\n *             c_encoding = encoding\n */\n  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_encoding); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 81, __pyx_L1_error)\n  if (__pyx_t_2) {\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":82\n *         cdef char *c_encoding = NULL\n    __pyx_t_4 = NULL;\n    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {\n      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);\n      if (likely(__pyx_t_4)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);\n        __Pyx_INCREF(__pyx_t_4);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_3, function);\n      }\n    }\n    __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_kp_u_utf_8) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_u_utf_8);\n    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 82, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __Pyx_DECREF_SET(__pyx_v_encoding, __pyx_t_1);\n    __pyx_t_1 = 0;\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":83\n *         if encoding:\n *             encoding = encoding.encode('utf-8')\n *             c_encoding = encoding             # <<<<<<<<<<<<<<\n * \n *         cdef object rv = object()\n */\n    __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_encoding); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 83, __pyx_L1_error)\n    __pyx_v_c_encoding = __pyx_t_5;\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":81\n *         cdef Py_ssize_t c_string_size = 1024\n *         cdef char *c_encoding = NULL\n *         if encoding:             # <<<<<<<<<<<<<<\n *             encoding = encoding.encode('utf-8')\n *             c_encoding = encoding\n */\n  }\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":85\n *             c_encoding = encoding\n * \n * \n */\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(__pyx_v_items);\n  __pyx_r = __pyx_v_items;\n  goto __pyx_L0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":62\n *         return rv\n * \n *     def read_strings(self, Py_ssize_t n_items, encoding=None):             # <<<<<<<<<<<<<<\n *         \"\"\"\n *         Python has great overhead between function calls.\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_16);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_8read_strings(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self, unsigned PY_LONG_LONG __pyx_v_n_items, PyObject *__pyx_v_encoding) {\n  PyObject *__pyx_v_items = NULL;\n  unsigned PY_LONG_LONG __pyx_v_i;\n  char *__pyx_v_buffer_ptr;\n  unsigned PY_LONG_LONG __pyx_v_right;\n  unsigned PY_LONG_LONG __pyx_v_size;\n  unsigned PY_LONG_LONG __pyx_v_shift;\n  unsigned PY_LONG_LONG __pyx_v_bytes_read;\n  unsigned PY_LONG_LONG __pyx_v_b;\n  char *__pyx_v_c_string;\n  unsigned PY_LONG_LONG __pyx_v_c_string_size;\n  char *__pyx_v_c_encoding;\n  PyObject *__pyx_v_rv = 0;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  int __pyx_t_2;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  char *__pyx_t_5;\n  unsigned PY_LONG_LONG __pyx_t_6;\n  unsigned PY_LONG_LONG __pyx_t_7;\n  unsigned PY_LONG_LONG __pyx_t_8;\n  unsigned PY_LONG_LONG __pyx_t_9;\n  unsigned PY_LONG_LONG __pyx_t_10;\n  unsigned PY_LONG_LONG __pyx_t_11;\n  PyObject *__pyx_t_12 = NULL;\n  PyObject *__pyx_t_13 = NULL;\n  PyObject *__pyx_t_14 = NULL;\n  int __pyx_t_15;\n  PyObject *__pyx_t_16 = NULL;\n  int __pyx_lineno = 0;\n  const char *__pyx_filename = NULL;\n  int __pyx_clineno = 0;\n  __Pyx_RefNannySetupContext(\"read_strings\", 0);\n  __Pyx_INCREF(__pyx_v_encoding);\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":67\n *         We inline strings reading logic here to avoid this overhead.\n *         \"\"\"\n *         items = PyTuple_New(n_items)             # <<<<<<<<<<<<<<\n * \n *         cdef unsigned long long i\n */\n  __pyx_t_1 = PyTuple_New(__pyx_v_n_items); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 67, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_items = ((PyObject*)__pyx_t_1);\n  __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":71\n *         cdef unsigned long long i\n *         # Buffer vars\n *         cdef char* buffer_ptr = PyByteArray_AsString(self.buffer)             # <<<<<<<<<<<<<<\n *         cdef unsigned long long right\n *         # String length vars\n */\n  __pyx_t_1 = __pyx_v_self->buffer;\n  __Pyx_INCREF(__pyx_t_1);\n  __pyx_v_buffer_ptr = PyByteArray_AsString(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":78\n * \n *         # String for decode vars.\n *         cdef char *c_string = NULL             # <<<<<<<<<<<<<<\n *         cdef unsigned long long c_string_size = 1024\n *         cdef char *c_encoding = NULL\n */\n  __pyx_v_c_string = NULL;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":79\n *         # String for decode vars.\n *         cdef char *c_string = NULL\n *         cdef unsigned long long c_string_size = 1024             # <<<<<<<<<<<<<<\n *         cdef char *c_encoding = NULL\n *         if encoding:\n */\n  __pyx_v_c_string_size = 0x400;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":80\n *         cdef char *c_string = NULL\n *         cdef unsigned long long c_string_size = 1024\n *         cdef char *c_encoding = NULL             # <<<<<<<<<<<<<<\n *         if encoding:\n *             encoding = encoding.encode('utf-8')\n */\n  __pyx_v_c_encoding = NULL;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":81\n *         cdef unsigned long long c_string_size = 1024\n *         cdef char *c_encoding = NULL\n *         if encoding:             # <<<<<<<<<<<<<<\n *             encoding = encoding.encode('utf-8')\n *             c_encoding = encoding\n */\n  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_encoding); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 81, __pyx_L1_error)\n  if (__pyx_t_2) {\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":82\n *         cdef char *c_encoding = NULL\n    __pyx_t_4 = NULL;\n    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {\n      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);\n      if (likely(__pyx_t_4)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);\n        __Pyx_INCREF(__pyx_t_4);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_3, function);\n      }\n    }\n    __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_kp_s_utf_8) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_s_utf_8);\n    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 82, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __Pyx_DECREF_SET(__pyx_v_encoding, __pyx_t_1);\n    __pyx_t_1 = 0;\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":83\n *         if encoding:\n *             encoding = encoding.encode('utf-8')\n *             c_encoding = encoding             # <<<<<<<<<<<<<<\n * \n *         cdef object rv = object()\n */\n    __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_encoding); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 83, __pyx_L1_error)\n    __pyx_v_c_encoding = __pyx_t_5;\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":81\n *         cdef unsigned long long c_string_size = 1024\n *         cdef char *c_encoding = NULL\n *         if encoding:             # <<<<<<<<<<<<<<\n *             encoding = encoding.encode('utf-8')\n *             c_encoding = encoding\n */\n  }\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":85\n *             c_encoding = encoding\n * \n * \n */\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(__pyx_v_items);\n  __pyx_r = __pyx_v_items;\n  goto __pyx_L0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":62\n *         return rv\n * \n *     def read_strings(self, unsigned long long n_items, encoding=None):             # <<<<<<<<<<<<<<\n *         \"\"\"\n *         Python has great overhead between function calls.\n */\n\n  /* function exit code */\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_16);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "l2tp_accm_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tuint16_t val_h, val_l;\n\n\tptr++;\t\t/* skip \"Reserved\" */\n\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"send=%08x \", (val_h<<16) + val_l));\n\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"recv=%08x \", (val_h<<16) + val_l));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "l2tp_accm_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tuint16_t val_h, val_l;\n\n\tif (length < 2) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tptr++;\t\t/* skip \"Reserved\" */\n\tlength -= 2;\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tND_PRINT((ndo, \"send=%08x \", (val_h<<16) + val_l));\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"recv=%08x \", (val_h<<16) + val_l));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "show_tree(tree_t *t,                    /* I - Parent node */\n          int    indent)                /* I - Indentation */\n{\n  while (t)\n  {\n    if (t->markup == MARKUP_NONE)\n      printf(\"%*s\\\"%s\\\"\\n\", indent, \"\", t->data);\n    else\n      printf(\"%*s%s\\n\", indent, \"\", _htmlMarkups[t->markup]);\n\n    if (t->child)\n      show_tree(t->child, indent + 2);\n\n    t = t->next;\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "show_tree(tree_t *t,                    /* I - Parent node */\n          int    indent)                /* I - Indentation */\n{\n  static const char * const markups[] =\n  {\n    \"FILE\",\n    \"UNKNOWN\",\n    \"ERROR\"\n  };\n\n  while (t)\n  {\n    if (t->markup == MARKUP_NONE)\n      printf(\"%*s\\\"%s\\\"\\n\", indent, \"\", t->data);\n    else if (t->markup > MARKUP_NONE)\n      printf(\"%*s%s\\n\", indent, \"\", _htmlMarkups[t->markup]);\n    else\n      printf(\"%*s%s\\n\", indent, \"\", markups[t->markup - MARKUP_FILE]);\n\n    if (t->child)\n      show_tree(t->child, indent + 2);\n\n    t = t->next;\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  /* Deploy versions older than 4 might have some of the below fields, but it's\n   * not guaranteed if the deploy was first created with an old Flatpak version\n   */\n  if (old_version < 4)\n    {\n      const char *commit;\n      g_autoptr(GVariant) commit_data = NULL;\n      g_autoptr(GVariant) commit_metadata = NULL;\n      g_autoptr(GKeyFile) keyfile = NULL;\n      g_autoptr(GFile) metadata_file = NULL;\n      g_autofree char *metadata_contents = NULL;\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n\n      /* Add fields from commit metadata to deploy */\n      commit = flatpak_deploy_data_get_commit (deploy_data);\n      if (!ostree_repo_load_commit (repo, commit, &commit_data, NULL, error))\n        return NULL;\n      commit_metadata = g_variant_get_child_value (commit_data, 0);\n      add_commit_metadata_to_deploy_data (&metadata_dict, commit_metadata);\n\n      /* Add fields from metadata file to deploy */\n      keyfile = g_key_file_new ();\n      metadata_file = g_file_resolve_relative_path (deploy_dir, \"metadata\");\n      if (!g_file_load_contents (metadata_file, cancellable,\n                                 &metadata_contents, NULL, NULL, error))\n        return NULL;\n      if (!g_key_file_load_from_data (keyfile, metadata_contents, -1, 0, error))\n        return NULL;\n      add_metadata_to_deploy_data (&metadata_dict, keyfile);\n\n      /* Add fields from appdata to deploy, since appdata-content-rating wasn't\n       * added when upgrading from version 2 as it should have been\n       */\n      if (old_version >= 1)\n        add_appdata_to_deploy_data (&metadata_dict, deploy_dir, id);\n    }\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "   * not guaranteed if the deploy was first created with an old Flatpak version\n   */\n  if (old_version < 4)\n    {\n      const char *commit;\n      g_autoptr(GVariant) commit_data = NULL;\n      g_autoptr(GVariant) commit_metadata = NULL;\n      g_autoptr(GKeyFile) keyfile = NULL;\n      g_autoptr(GFile) metadata_file = NULL;\n      g_autofree char *metadata_contents = NULL;\n      gsize metadata_size = 0;\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n\n      /* Add fields from commit metadata to deploy */\n      commit = flatpak_deploy_data_get_commit (deploy_data);\n      if (!ostree_repo_load_commit (repo, commit, &commit_data, NULL, error))\n        return NULL;\n      commit_metadata = g_variant_get_child_value (commit_data, 0);\n      add_commit_metadata_to_deploy_data (&metadata_dict, commit_metadata);\n\n      /* Add fields from metadata file to deploy */\n      keyfile = g_key_file_new ();\n      metadata_file = g_file_resolve_relative_path (deploy_dir, \"metadata\");\n      if (!g_file_load_contents (metadata_file, cancellable,\n                                 &metadata_contents, &metadata_size, NULL, error))\n        return NULL;\n      if (!g_key_file_load_from_data (keyfile, metadata_contents, metadata_size, 0, error))\n        return NULL;\n      add_metadata_to_deploy_data (&metadata_dict, keyfile);\n\n      /* Add fields from appdata to deploy, since appdata-content-rating wasn't\n       * added when upgrading from version 2 as it should have been\n       */\n      if (old_version >= 1)\n        add_appdata_to_deploy_data (&metadata_dict, deploy_dir, id);\n    }\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "snmp_ber_encode_integer(unsigned char *out, uint32_t *out_len, uint32_t number)\n{\n  uint32_t original_out_len;\n\n  original_out_len = *out_len;\n  do {\n    (*out_len)++;\n    *out-- = (uint8_t)(number & 0xFF);\n    number >>= 8;\n  } while(number);\n\n  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n  out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_INTEGER);\n\n  return out;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "snmp_ber_encode_integer(snmp_packet_t *snmp_packet, uint32_t number)\n{\n  return snmp_ber_encode_unsigned_integer(snmp_packet, BER_DATA_TYPE_INTEGER, number);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "set_option_value(\n    char_u\t*name,\n    long\tnumber,\n    char_u\t*string,\n    int\t\topt_flags)\t// OPT_LOCAL or 0 (both)\n{\n    int\t\topt_idx;\n    char_u\t*varp;\n    long_u\tflags;\n    static char\terrbuf[80];\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\n    {\n\tint key;\n\n\tif (STRLEN(name) == 4 && name[0] == 't' && name[1] == '_'\n\t\t&& (key = find_key_option(name, FALSE)) != 0)\n\t{\n\t    char_u key_name[2];\n\tflags = options[opt_idx].flags;\n#ifdef HAVE_SANDBOX\n\t// Disallow changing some options in the sandbox\n\tif (sandbox > 0 && (flags & P_SECURE))\n\t{\n\t    emsg(_(e_not_allowed_in_sandbox));\n\t    return NULL;\n\t}\n#endif\n\tif (flags & P_STRING)\n\t    return set_string_option(opt_idx, string, opt_flags, errbuf);\n\n\tvarp = get_varp_scope(&(options[opt_idx]), opt_flags);\n\tif (varp != NULL)\t// hidden option is not changed\n\t{\n\t    if (number == 0 && string != NULL)\n\t    {\n\t\tint idx;\n\n\t\t// Either we are given a string or we are setting option\n\t\t// to zero.",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "set_option_value(\n    char_u\t*name,\n    long\tnumber,\n    char_u\t*string,\n    int\t\topt_flags)\t// OPT_LOCAL or 0 (both)\n{\n    int\t\topt_idx;\n    char_u\t*varp;\n    long_u\tflags;\n    static char\terrbuf[ERR_BUFLEN];\n    int\t\terrbuflen = ERR_BUFLEN;\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\n    {\n\tint key;\n\n\tif (STRLEN(name) == 4 && name[0] == 't' && name[1] == '_'\n\t\t&& (key = find_key_option(name, FALSE)) != 0)\n\t{\n\t    char_u key_name[2];\n\tflags = options[opt_idx].flags;\n#ifdef HAVE_SANDBOX\n\t// Disallow changing some options in the sandbox\n\tif (sandbox > 0 && (flags & P_SECURE))\n\t{\n\t    emsg(_(e_not_allowed_in_sandbox));\n\t    return NULL;\n\t}\n#endif\n\tif (flags & P_STRING)\n\t    return set_string_option(opt_idx, string, opt_flags, errbuf, errbuflen);\n\n\tvarp = get_varp_scope(&(options[opt_idx]), opt_flags);\n\tif (varp != NULL)\t// hidden option is not changed\n\t{\n\t    if (number == 0 && string != NULL)\n\t    {\n\t\tint idx;\n\n\t\t// Either we are given a string or we are setting option\n\t\t// to zero.",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static inline Quantum GetPixelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[image->channel_map[channel].offset].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[channel].offset]);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static inline Quantum GetPixelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[channel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[channel].offset]);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int utf8s_to_utf16s(const u8 *s, int len, wchar_t *pwcs)\n{\n\tu16 *op;\n\tint size;\n\tunicode_t u;\n\n\top = pwcs;\n\twhile (*s && len > 0) {\n\t\tif (*s & 0x80) {\n\t\t\tsize = utf8_to_utf32(s, len, &u);\n\t\t\tif (size < 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (u >= PLANE_SIZE) {\n\t\t\t\tu -= PLANE_SIZE;\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n\t\t\t\t\t\t((u >> 10) & SURROGATE_BITS));\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n\t\t\t\t\t\tSURROGATE_LOW |\n\t\t\t\t\t\t(u & SURROGATE_BITS));\n\t\t\t} else {\n\t\t\t\t*op++ = (wchar_t) u;\n\t\t\t}\n\t\t\ts += size;\n\t\t\tlen -= size;\n\t\t} else {\n\t\t\t*op++ = *s++;\n\t\t\tlen--;\n\t\t}\n\t}\n\treturn op - pwcs;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int utf8s_to_utf16s(const u8 *s, int len, enum utf16_endian endian,\n\t\twchar_t *pwcs, int maxlen)\n{\n\tu16 *op;\n\tint size;\n\tunicode_t u;\n\n\top = pwcs;\n\twhile (len > 0 && maxlen > 0 && *s) {\n\t\tif (*s & 0x80) {\n\t\t\tsize = utf8_to_utf32(s, len, &u);\n\t\t\tif (size < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\ts += size;\n\t\t\tlen -= size;\n\n\t\t\tif (u >= PLANE_SIZE) {\n\t\t\t\tif (maxlen < 2)\n\t\t\t\t\tbreak;\n\t\t\t\tu -= PLANE_SIZE;\n\t\t\t\tput_utf16(op++, SURROGATE_PAIR |\n\t\t\t\t\t\t((u >> 10) & SURROGATE_BITS),\n\t\t\t\t\t\tendian);\n\t\t\t\tput_utf16(op++, SURROGATE_PAIR |\n\t\t\t\t\t\tSURROGATE_LOW |\n\t\t\t\t\t\t(u & SURROGATE_BITS),\n\t\t\t\t\t\tendian);\n\t\t\t\tmaxlen -= 2;\n\t\t\t} else {\n\t\t\t\tput_utf16(op++, u, endian);\n\t\t\t\tmaxlen--;\n\t\t\t}\n\t\t} else {\n\t\t\tput_utf16(op++, *s++, endian);\n\t\t\tlen--;\n\t\t\tmaxlen--;\n\t\t}\n\t}\n\treturn op - pwcs;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t/*this is to cope with single MFString which shall appear as SF in XMT*/\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; mffield && (i<mffield->count); i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t/*this is to cope with single MFString which shall appear as SF in XMT*/\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t/* initializations*/\n\ttcp = &p_cp->tcps [tileno];\n\tl_tccp = tcp->tccps;\n\tl_img_comp = p_image->comps;\n\n\t/* position in x and y of tile*/\n\tp = tileno % p_cp->tw;\n\tq = tileno / p_cp->tw;\n\n\t/* here calculation of tx0, tx1, ty0, ty1, maxprec, l_dx and l_dy */\n\t*p_tx0 = opj_int_max((OPJ_INT32)(p_cp->tx0 + p * p_cp->tdx), (OPJ_INT32)p_image->x0);\n\t*p_tx1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + (p + 1) * p_cp->tdx), (OPJ_INT32)p_image->x1);\n\t*p_ty0 = opj_int_max((OPJ_INT32)(p_cp->ty0 + q * p_cp->tdy), (OPJ_INT32)p_image->y0);\n\t*p_ty1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + (q + 1) * p_cp->tdy), (OPJ_INT32)p_image->y1);\n\n\t/* max precision and resolution is 0 (can only grow)*/\n\t*p_max_prec = 0;\n\t*p_max_res = 0;\n\n\t/* take the largest value for dx_min and dy_min*/\n\t*p_dx_min = 0x7fffffff;\n\t*p_dy_min = 0x7fffffff;\n\n\tfor (compno = 0; compno < p_image->numcomps; ++compno) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t/* initializations*/\n\ttcp = &p_cp->tcps [tileno];\n\tl_tccp = tcp->tccps;\n\tl_img_comp = p_image->comps;\n\n\t/* position in x and y of tile*/\n\tp = tileno % p_cp->tw;\n\tq = tileno / p_cp->tw;\n\n\t/* here calculation of tx0, tx1, ty0, ty1, maxprec, l_dx and l_dy */\n\t*p_tx0 = (OPJ_INT32)opj_uint_max(p_cp->tx0 + p * p_cp->tdx, p_image->x0);\n\t*p_tx1 = (OPJ_INT32)opj_uint_min(p_cp->tx0 + (p + 1) * p_cp->tdx, p_image->x1);\n\t*p_ty0 = (OPJ_INT32)opj_uint_max(p_cp->ty0 + q * p_cp->tdy, p_image->y0);\n\t*p_ty1 = (OPJ_INT32)opj_uint_min(p_cp->ty0 + (q + 1) * p_cp->tdy, p_image->y1);\n\n\t/* max precision and resolution is 0 (can only grow)*/\n\t*p_max_prec = 0;\n\t*p_max_res = 0;\n\n\t/* take the largest value for dx_min and dy_min*/\n\t*p_dx_min = 0x7fffffff;\n\t*p_dy_min = 0x7fffffff;\n\n\tfor (compno = 0; compno < p_image->numcomps; ++compno) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TEST_P(Http2CodecImplTest, TestLargeRequestHeadersAtLimitAccepted) {\n  uint32_t codec_limit_kb = 64;\n  max_request_headers_kb_ = codec_limit_kb;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  std::string key = \"big\";\n  uint32_t head_room = 77;\n  uint32_t long_string_length =\n      codec_limit_kb * 1024 - request_headers.byteSize() - key.length() - head_room;\n  std::string long_string = std::string(long_string_length, 'q');\n  request_headers.addCopy(key, long_string);\n\n  // The amount of data sent to the codec is not equivalent to the size of the\n  // request headers that Envoy computes, as the codec limits based on the\n  // entire http2 frame. The exact head room needed (76) was found through iteration.\n  ASSERT_EQ(request_headers.byteSize() + head_room, codec_limit_kb * 1024);\n\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _));\n  request_encoder_->encodeHeaders(request_headers, true);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TEST_P(Http2CodecImplTest, TestLargeRequestHeadersAtLimitAccepted) {\n  uint32_t codec_limit_kb = 64;\n  max_request_headers_kb_ = codec_limit_kb;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  // Refresh byte size after adding default inline headers by reference.\n  request_headers.refreshByteSize();\n  std::string key = \"big\";\n  uint32_t head_room = 77;\n  uint32_t long_string_length =\n      codec_limit_kb * 1024 - request_headers.byteSize().value() - key.length() - head_room;\n  std::string long_string = std::string(long_string_length, 'q');\n  request_headers.addCopy(key, long_string);\n\n  // The amount of data sent to the codec is not equivalent to the size of the\n  // request headers that Envoy computes, as the codec limits based on the\n  // entire http2 frame. The exact head room needed (76) was found through iteration.\n  ASSERT_EQ(request_headers.byteSize().value() + head_room, codec_limit_kb * 1024);\n\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _));\n  request_encoder_->encodeHeaders(request_headers, true);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t/* Don't use (incr*2 < delta), incr*2 might overflow. */\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1 << i;\n\t\tdelta -= incr;\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\t/* Don't use (incr*2 < delta), incr*2 might overflow. */\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1LL << i;\n\t\tdelta -= incr;\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t} else {\n\t\tint err, size = decode_access_size(insn);\n\t\tunsigned long addr;\n\n\t\tif(floating_point_load_or_store_p(insn)) {\n\t\t\tprintk(\"User FPU load/store unaligned unsupported.\\n\");\n\t\t\tgoto kill_user;\n\t\t}\n\n\t\taddr = compute_effective_address(regs, insn);\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, addr);\n\t\tswitch(dir) {\n\t\tcase load:\n\t\t\terr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),\n\t\t\t\t\t\t\t regs),\n\t\t\t\t\t  size, (unsigned long *) addr,\n\t\t\t\t\t  decode_signedness(insn));\n\t\t\tbreak;\n\n\t\tcase store:\n\t\t\terr = do_int_store(((insn>>25)&0x1f), size,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t} else {\n\t\tint err, size = decode_access_size(insn);\n\t\tunsigned long addr;\n\n\t\tif(floating_point_load_or_store_p(insn)) {\n\t\t\tprintk(\"User FPU load/store unaligned unsupported.\\n\");\n\t\t\tgoto kill_user;\n\t\t}\n\n\t\taddr = compute_effective_address(regs, insn);\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, addr);\n\t\tswitch(dir) {\n\t\tcase load:\n\t\t\terr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),\n\t\t\t\t\t\t\t regs),\n\t\t\t\t\t  size, (unsigned long *) addr,\n\t\t\t\t\t  decode_signedness(insn));\n\t\t\tbreak;\n\n\t\tcase store:\n\t\t\terr = do_int_store(((insn>>25)&0x1f), size,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->64 */\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t\tcoerce_reg_to_size(&src_reg, 4);\n\t}\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\t\tdst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\tu64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;\n\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t\t/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t */\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t */\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t/* If we might shift our top bit out, then we know nothing */\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->32 */\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t\tcoerce_reg_to_size(&src_reg, 4);\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tdev->priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE;\n\tdev->netdev_ops = &virtnet_netdev;\n\tdev->features = NETIF_F_HIGHDMA;\n\n\tdev->ethtool_ops = &virtnet_ethtool_ops;\n\tSET_NETDEV_DEV(dev, &vdev->dev);\n\n\t/* Do we support \"hardware\" checksums? */\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CSUM)) {\n\t\t/* This opens up the world of extra features. */\n\t\tdev->hw_features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;\n\t\tif (csum)\n\t\t\tdev->features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;\n\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_GSO)) {\n\t\t\tdev->hw_features |= NETIF_F_TSO | NETIF_F_UFO\n\t\t\t\t| NETIF_F_TSO_ECN | NETIF_F_TSO6;\n\t\t}\n\t\t/* Individual feature bits: what can host handle? */\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_TSO4))\n\t\t\tdev->hw_features |= NETIF_F_TSO;\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_TSO6))\n\t\t\tdev->hw_features |= NETIF_F_TSO6;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tdev->priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE;\n\tdev->netdev_ops = &virtnet_netdev;\n\tdev->features = NETIF_F_HIGHDMA;\n\n\tdev->ethtool_ops = &virtnet_ethtool_ops;\n\tSET_NETDEV_DEV(dev, &vdev->dev);\n\n\t/* Do we support \"hardware\" checksums? */\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CSUM)) {\n\t\t/* This opens up the world of extra features. */\n\t\tdev->hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG;\n\t\tif (csum)\n\t\t\tdev->features |= NETIF_F_HW_CSUM | NETIF_F_SG;\n\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_GSO)) {\n\t\t\tdev->hw_features |= NETIF_F_TSO | NETIF_F_UFO\n\t\t\t\t| NETIF_F_TSO_ECN | NETIF_F_TSO6;\n\t\t}\n\t\t/* Individual feature bits: what can host handle? */\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_TSO4))\n\t\t\tdev->hw_features |= NETIF_F_TSO;\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_TSO6))\n\t\t\tdev->hw_features |= NETIF_F_TSO6;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "            ptr += picture->linesize[i];\n        }\n    }\n\n    s->picture = picture;\n\n    avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);\n\n    ymax = FFMAX(0, s->ymax + 1);\n    // Zero out the end if ymax+1 is not h\n    for (i = 0; i < planes; i++) {\n        ptr = picture->data[i] + (ymax * picture->linesize[i]);\n        for (y = ymax; y < avctx->height; y++) {\n            memset(ptr, 0, out_line_size);\n            ptr += picture->linesize[i];\n        }\n    }\n\n    picture->pict_type = AV_PICTURE_TYPE_I;\n    *got_frame = 1;\n\n    return avpkt->size;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "            ptr += picture->linesize[i];\n        }\n    }\n\n    s->picture = picture;\n\n    avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);\n\n    ymax = FFMAX(0, s->ymax + 1);\n    // Zero out the end if ymax+1 is not h\n    if (ymax < avctx->height)\n        for (i = 0; i < planes; i++) {\n            ptr = picture->data[i] + (ymax * picture->linesize[i]);\n            for (y = ymax; y < avctx->height; y++) {\n                memset(ptr, 0, out_line_size);\n                ptr += picture->linesize[i];\n            }\n        }\n\n    picture->pict_type = AV_PICTURE_TYPE_I;\n    *got_frame = 1;\n\n    return avpkt->size;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void lo_release(struct gendisk *disk, fmode_t mode)\n{\n\tstruct loop_device *lo = disk->private_data;\n\tint err;\n\n\tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\t/*\n\t\t * In autoclear mode, stop the loop thread\n\t\t * and remove configuration after last close.\n\t\t */\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\t/*\n\t\t * Otherwise keep thread (if running) and config,\n\t\t * but flush possible ongoing bios in thread.\n\t\t */\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\n\tmutex_unlock(&lo->lo_ctl_mutex);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void lo_release(struct gendisk *disk, fmode_t mode)\n{\n\tmutex_lock(&loop_index_mutex);\n\t__lo_release(disk->private_data);\n\tmutex_unlock(&loop_index_mutex);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      info, trace_span.get(),\n      [context, continuation, trace_span](\n          Status status, const service_control::CheckResponseInfo &info) {\n        TRACE(trace_span) << \"Check service control request returned with \"\n                          << \"status \" << status.ToString();\n        // info is valid regardless status.\n        context->set_check_response_info(info);\n\n        // update consumer_project_id to service context\n        if (!info.consumer_project_id.empty()) {\n          context->request()->AddHeaderToBackend(kConsumerProjecId,\n                                                 info.consumer_project_id);\n        }\n\n        continuation(status);\n      });\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      info, trace_span.get(),\n      [context, continuation, trace_span](\n          Status status, const service_control::CheckResponseInfo &info) {\n        TRACE(trace_span) << \"Check service control request returned with \"\n                          << \"status \" << status.ToString();\n        // info is valid regardless status.\n        context->set_check_response_info(info);\n\n        // update consumer_project_id to service context\n        if (!info.consumer_project_id.empty()) {\n          context->request()->AddHeaderToBackend(\n              kConsumerProjecId, info.consumer_project_id, false);\n        }\n\n        continuation(status);\n      });\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t/* Start all dormant timers */\n\t_UEV_FOREACH(w, ctx->watchers) {\n\t\tif (UEV_CRON_TYPE == w->type)\n\t\t\tuev_cron_set(w, w->u.c.when, w->u.c.interval);\n\t\tif (UEV_TIMER_TYPE == w->type)\n\t\t\tuev_timer_set(w, w->u.t.timeout, w->u.t.period);\n\t}\n\n\twhile (ctx->running && ctx->watchers) {\n\t\tstruct epoll_event ee[UEV_MAX_EVENTS];\n\t\tint i, nfds, rerun = 0;\n\n\t\t/* Handle special case: `application < file.txt` */\n\t\tif (ctx->workaround) {\n\t\t\t_UEV_FOREACH(w, ctx->watchers) {\n\t\t\t\tif (w->active != -1 || !w->cb)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!has_data(w->fd)) {\n\t\t\t\t\tw->active = 0;\n\t\t\t\t\t_UEV_REMOVE(w, ctx->watchers);\n\n\t\t\t\trerun++;\n\t\t\t\tw->cb(w, w->arg, UEV_READ);\n\t\t\t}\n\t\t}\n\n\t\tif (rerun)\n\t\t\tcontinue;\n\t\tctx->workaround = 0;\n\n\t\twhile ((nfds = epoll_wait(ctx->fd, ee, ctx->maxevents, timeout)) < 0) {\n\t\t\tif (!ctx->running)\n\t\t\t\tbreak;\n\n\t\t\tif (EINTR == errno)\n\t\t\t\tcontinue; /* Signalled, try again */\n\n\t\t\t/* Unrecoverable error, cleanup and exit with error. */\n\t\t\tuev_exit(ctx);\n\n\t\t\treturn -2;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t/* Start all dormant timers */\n\t_UEV_FOREACH(w, ctx->watchers) {\n\t\tif (UEV_CRON_TYPE == w->type)\n\t\t\tuev_cron_set(w, w->u.c.when, w->u.c.interval);\n\t\tif (UEV_TIMER_TYPE == w->type)\n\t\t\tuev_timer_set(w, w->u.t.timeout, w->u.t.period);\n\t}\n\n\twhile (ctx->running && ctx->watchers) {\n\t\tstruct epoll_event ee[UEV_MAX_EVENTS];\n\t\tint maxevents = ctx->maxevents;\n\t\tint i, nfds, rerun = 0;\n\n\t\tif (maxevents > UEV_MAX_EVENTS)\n\t\t\tmaxevents = UEV_MAX_EVENTS;\n\n\t\t/* Handle special case: `application < file.txt` */\n\t\tif (ctx->workaround) {\n\t\t\t_UEV_FOREACH(w, ctx->watchers) {\n\t\t\t\tif (w->active != -1 || !w->cb)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!has_data(w->fd)) {\n\t\t\t\t\tw->active = 0;\n\t\t\t\t\t_UEV_REMOVE(w, ctx->watchers);\n\n\t\t\t\trerun++;\n\t\t\t\tw->cb(w, w->arg, UEV_READ);\n\t\t\t}\n\t\t}\n\n\t\tif (rerun)\n\t\t\tcontinue;\n\t\tctx->workaround = 0;\n\n\t\twhile ((nfds = epoll_wait(ctx->fd, ee, maxevents, timeout)) < 0) {\n\t\t\tif (!ctx->running)\n\t\t\t\tbreak;\n\n\t\t\tif (EINTR == errno)\n\t\t\t\tcontinue; /* Signalled, try again */\n\n\t\t\t/* Unrecoverable error, cleanup and exit with error. */\n\t\t\tuev_exit(ctx);\n\n\t\t\treturn -2;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t value;\n    int position, zeroes, i, j;\n    char bits[65];\n\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    zeroes = i = 0;\n    while (1) {\n        if (get_bits_left(gbc) < zeroes + 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (get_bits1(gbc)) {\n            bits[i++] = '1';\n            break;\n        } else {\n            bits[i++] = '0';\n            ++zeroes;\n        }\n    }\n\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        value = get_bits_long(gbc, zeroes);\n\n        for (j = 0; j < zeroes; j++)\n            bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';\n\n        value += (1 << zeroes) - 1;\n    }\n\n    if (ctx->trace_enable) {\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL,\n                                    bits, value);\n    }\n\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n\n    *write_to = value;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t zeroes, bits_value, value;\n    int position;\n\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    zeroes = 0;\n    while (1) {\n        if (get_bits_left(gbc) < 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (get_bits1(gbc))\n            break;\n        ++zeroes;\n    }\n\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        if (get_bits_left(gbc) < zeroes) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n\n        bits_value = get_bits_long(gbc, zeroes);\n        value = bits_value + (UINT32_C(1) << zeroes) - 1;\n    }\n\n    if (ctx->trace_enable) {\n        char bits[65];\n        int i, j, k;\n\n        if (zeroes >= 32) {\n            while (zeroes > 32) {\n                k = FFMIN(zeroes - 32, 32);\n                for (i = 0; i < k; i++)\n                    bits[i] = '0';\n                bits[i] = 0;\n                ff_cbs_trace_syntax_element(ctx, position, name,\n                                            NULL, bits, 0);\n                zeroes -= k;\n                position += k;\n            }\n        }\n\n        for (i = 0; i < zeroes; i++)\n            bits[i] = '0';\n        bits[i++] = '1';\n\n        if (zeroes < 32) {\n            for (j = 0; j < zeroes; j++)\n                bits[i++] = (bits_value >> (zeroes - j - 1) & 1) ? '1' : '0';\n        }\n\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name,\n                                    NULL, bits, value);\n    }\n\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n\n    *write_to = value;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int my_redel(const char *org_name, const char *tmp_name, myf MyFlags)\n{\n  int error=1;\n  DBUG_ENTER(\"my_redel\");\n  DBUG_PRINT(\"my\",(\"org_name: '%s' tmp_name: '%s'  MyFlags: %d\",\n\t\t   org_name,tmp_name,MyFlags));\n\n  if (my_copystat(org_name,tmp_name,MyFlags) < 0)\n    goto end;\n  if (MyFlags & MY_REDEL_MAKE_BACKUP)\n  {\n    char name_buff[FN_REFLEN+20];    \n    char ext[20];\n    ext[0]='-';\n    get_date(ext+1,2+4,(time_t) 0);\n    strmov(strend(ext),REDEL_EXT);\n    if (my_rename(org_name, fn_format(name_buff, org_name, \"\", ext, 2),\n\t\t  MyFlags))\n      goto end;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int my_redel(const char *org_name, const char *tmp_name, myf MyFlags)\n{\n  int error=1;\n  DBUG_ENTER(\"my_redel\");\n  DBUG_PRINT(\"my\",(\"org_name: '%s' tmp_name: '%s'  MyFlags: %d\",\n\t\t   org_name,tmp_name,MyFlags));\n\n  if (!(MyFlags & MY_REDEL_NO_COPY_STAT))\n  {\n    if (my_copystat(org_name,tmp_name,MyFlags) < 0)\n      goto end;\n  }\n  if (MyFlags & MY_REDEL_MAKE_BACKUP)\n  {\n    char name_buff[FN_REFLEN+20];    \n    char ext[20];\n    ext[0]='-';\n    get_date(ext+1,2+4,(time_t) 0);\n    strmov(strend(ext),REDEL_EXT);\n    if (my_rename(org_name, fn_format(name_buff, org_name, \"\", ext, 2),\n\t\t  MyFlags))\n      goto end;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "write_stacktrace(const char *file_name, const char *str)\n{\n\tint fd;\n\tvoid *buffer[100];\n\tint nptrs;\n\tint i;\n\tchar **strs;\n\n\tnptrs = backtrace(buffer, 100);\n\tif (file_name) {\n\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n\t\tif (str)\n\t\t\tdprintf(fd, \"%s\\n\", str);\n\t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n\t\tif (write(fd, \"\\n\", 1) != 1) {\n\t\t\t/* We don't care, but this stops a warning on Ubuntu */\n\t\t}\n\t\tclose(fd);\n\t} else {\n\t\tif (str)\n\t\t\tlog_message(LOG_INFO, \"%s\", str);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "write_stacktrace(const char *file_name, const char *str)\n{\n\tint fd;\n\tvoid *buffer[100];\n\tint nptrs;\n\tint i;\n\tchar **strs;\n\n\tnptrs = backtrace(buffer, 100);\n\tif (file_name) {\n\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n\t\tif (str)\n\t\t\tdprintf(fd, \"%s\\n\", str);\n\t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n\t\tif (write(fd, \"\\n\", 1) != 1) {\n\t\t\t/* We don't care, but this stops a warning on Ubuntu */\n\t\t}\n\t\tclose(fd);\n\t} else {\n\t\tif (str)\n\t\t\tlog_message(LOG_INFO, \"%s\", str);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  if (op->getType().isNumberType()) {\n    UOI->setType(numberResultType);\n    return true;\n  }\n\n  if (op->getType().isBigIntType()) {\n    UOI->setType(Type::createBigInt());\n    return true;\n  }\n\n  Type mayBeBigInt =\n      op->getType().canBeBigInt() ? Type::createBigInt() : Type::createNoType();\n\n  // - ?? => Number|?BigInt. BigInt is only possible if op.Type canBeBigInt.\n  UOI->setType(Type::unionTy(numberResultType, mayBeBigInt));\n  return true;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  if (op->getType().isNumberType()) {\n    UOI->setType(numberResultType);\n    return true;\n  }\n\n  if (op->getType().isBigIntType()) {\n    UOI->setType(Type::createBigInt());\n    return true;\n  }\n\n  Type mayBeBigInt = isBigIntOrObject(op->getType()) ? Type::createBigInt()\n                                                     : Type::createNoType();\n\n  // - ?? => Number|?BigInt. BigInt is only possible if op.Type is\n  // BigInt|Object.\n  UOI->setType(Type::unionTy(numberResultType, mayBeBigInt));\n  return true;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t\t/*\n\t\t * event overflow\n\t\t */\n\t\thandled++;\n\t\tdata.period\t= event->hw.last_period;\n\n\t\tif (!x86_perf_event_set_period(event))\n\t\t\tcontinue;\n\n\t\tif (perf_event_overflow(event, 1, &data, regs))\n\t\t\tx86_pmu_stop(event, 0);\n\t}\n\n\tif (handled)\n\t\tinc_irq_stat(apic_perf_irqs);\n\n\treturn handled;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\t\t/*\n\t\t * event overflow\n\t\t */\n\t\thandled++;\n\t\tdata.period\t= event->hw.last_period;\n\n\t\tif (!x86_perf_event_set_period(event))\n\t\t\tcontinue;\n\n\t\tif (perf_event_overflow(event, &data, regs))\n\t\t\tx86_pmu_stop(event, 0);\n\t}\n\n\tif (handled)\n\t\tinc_irq_stat(apic_perf_irqs);\n\n\treturn handled;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tswitch (kiocb->ki_opcode) {\n\tcase IOCB_CMD_PREAD:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_READ)))\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (unlikely(!access_ok(VERIFY_WRITE, kiocb->ki_buf,\n\t\t\tkiocb->ki_left)))\n\t\t\tbreak;\n\t\tret = security_file_permission(file, MAY_READ);\n\t\tif (unlikely(ret))\n\t\t\tbreak;\n\t\tret = aio_setup_single_vector(kiocb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_read)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PWRITE:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_WRITE)))\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (unlikely(!access_ok(VERIFY_READ, kiocb->ki_buf,\n\t\t\tkiocb->ki_left)))\n\t\t\tbreak;\n\t\tret = security_file_permission(file, MAY_WRITE);\n\t\tif (unlikely(ret))\n\t\t\tbreak;\n\t\tret = aio_setup_single_vector(kiocb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_write)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PREADV:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_READ)))\n\t\t\tbreak;\n\t\tret = security_file_permission(file, MAY_READ);\n\t\tif (unlikely(ret))\n\t\t\tbreak;\n\t\tret = aio_setup_vectored_rw(READ, kiocb, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_read)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PWRITEV:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_WRITE)))\n\t\t\tbreak;\n\t\tret = security_file_permission(file, MAY_WRITE);\n\t\tif (unlikely(ret))\n\t\t\tbreak;\n\t\tret = aio_setup_vectored_rw(WRITE, kiocb, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_write)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_FDSYNC:\n\t\tret = -EINVAL;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tswitch (kiocb->ki_opcode) {\n\tcase IOCB_CMD_PREAD:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_READ)))\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (unlikely(!access_ok(VERIFY_WRITE, kiocb->ki_buf,\n\t\t\tkiocb->ki_left)))\n\t\t\tbreak;\n\t\tret = aio_setup_single_vector(READ, file, kiocb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_read)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PWRITE:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_WRITE)))\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (unlikely(!access_ok(VERIFY_READ, kiocb->ki_buf,\n\t\t\tkiocb->ki_left)))\n\t\t\tbreak;\n\t\tret = aio_setup_single_vector(WRITE, file, kiocb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_write)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PREADV:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_READ)))\n\t\t\tbreak;\n\t\tret = aio_setup_vectored_rw(READ, kiocb, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_read)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PWRITEV:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_WRITE)))\n\t\t\tbreak;\n\t\tret = aio_setup_vectored_rw(WRITE, kiocb, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_write)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_FDSYNC:\n\t\tret = -EINVAL;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (ret = -EINVAL, vma->addr != addr || vma->size != size) {\n\t\tif (addr + size > vma->addr + vma->size || vma->memory ||\n\t\t    (vma->refd == NVKM_VMA_PAGE_NONE && !vma->mapref)) {\n\t\t\tVMM_DEBUG(vmm, \"split %d %d %d \"\n\t\t\t\t       \"%016llx %016llx %016llx %016llx\",\n\t\t\t\t  !!vma->memory, vma->refd, vma->mapref,\n\t\t\t\t  addr, size, vma->addr, (u64)vma->size);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (vma->addr != addr) {\n\t\t\tconst u64 tail = vma->size + vma->addr - addr;\n\t\t\tif (ret = -ENOMEM, !(vma = nvkm_vma_tail(vma, tail)))\n\t\t\t\tgoto fail;\n\t\t\tvma->part = true;\n\t\t\tnvkm_vmm_node_insert(vmm, vma);\n\t\t}\n\n\t\tif (vma->size != size) {\n\t\t\tconst u64 tail = vma->size - size;\n\t\t\tstruct nvkm_vma *tmp;\n\t\t\tif (ret = -ENOMEM, !(tmp = nvkm_vma_tail(vma, tail))) {\n\t\t\t\tnvkm_vmm_unmap_region(vmm, vma);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\ttmp->part = true;\n\t\t\tnvkm_vmm_node_insert(vmm, tmp);\n\t\t}\n\t}\n\tvma->busy = true;\n\tmutex_unlock(&vmm->mutex);\n\n\tret = nvkm_memory_map(memory, offset, vmm, vma, argv, argc);\n\tif (ret == 0) {\n\t\t/* Successful map will clear vma->busy. */\n\t\tnvkm_memory_unref(&memory);\n\t\treturn 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (ret = -EINVAL, vma->addr != addr || vma->size != size) {\n\t\tif (addr + size > vma->addr + vma->size || vma->memory ||\n\t\t    (vma->refd == NVKM_VMA_PAGE_NONE && !vma->mapref)) {\n\t\t\tVMM_DEBUG(vmm, \"split %d %d %d \"\n\t\t\t\t       \"%016llx %016llx %016llx %016llx\",\n\t\t\t\t  !!vma->memory, vma->refd, vma->mapref,\n\t\t\t\t  addr, size, vma->addr, (u64)vma->size);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tvma = nvkm_vmm_node_split(vmm, vma, addr, size);\n\t\tif (!vma) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tvma->busy = true;\n\tmutex_unlock(&vmm->mutex);\n\n\tret = nvkm_memory_map(memory, offset, vmm, vma, argv, argc);\n\tif (ret == 0) {\n\t\t/* Successful map will clear vma->busy. */\n\t\tnvkm_memory_unref(&memory);\n\t\treturn 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void _luac_build_info(LuaProto *proto, LuacBinInfo *info) {\n\t/* process proto header info */\n\tchar *section_name;\n\tchar *symbol_name;\n\tchar *proto_name;\n\tRzListIter *iter;\n\n\tut64 current_offset;\n\tut64 current_size;\n\n\tint i = 0; // iter\n\n\t// 0. check if stripped (proto name is lost)\n\tif (proto->name_size == 0 || proto->proto_name == NULL) {\n\t\t// replace name with current offset\n\t\tproto_name = rz_str_newf(\"fcn.%08llx\", proto->offset);\n\t} else {\n\t\tproto_name = rz_str_new((char *)proto->proto_name);\n\t}\n\n\t// 1.1 set section name as function_name.header\n\tLuaLocalVarEntry *local_var_entry;\n\trz_list_foreach (proto->local_var_info_entries, iter, local_var_entry) {\n\t\tluac_add_string(\n\t\t\tinfo->string_list,\n\t\t\t(char *)local_var_entry->varname,\n\t\t\tlocal_var_entry->offset,\n\t\t\tlocal_var_entry->varname_len);\n\t}\n\n\t// 2.2 parse debug_upvalues\n\tchar **upvalue_names;\n\tint real_upvalue_cnt;\n\tLuaDbgUpvalueEntry *debug_upv_entry;\n\treal_upvalue_cnt = rz_list_length(proto->upvalue_entries);\n\tupvalue_names = RZ_NEWS0(char *, real_upvalue_cnt);\n\tif (!upvalue_names) {\n\t\treturn;\n\t}\n\trz_list_foreach (proto->dbg_upvalue_entries, iter, debug_upv_entry) {\n\t\tupvalue_names[i] = (char *)debug_upv_entry->upvalue_name;\n\t\tluac_add_string(\n\t\t\tinfo->string_list,\n\t\t\tupvalue_names[i],\n\t\t\tdebug_upv_entry->offset,\n\t\t\tdebug_upv_entry->name_len);\n\t}\n\n\t// 3.1 construct constant symbols\n\tLuaConstEntry *const_entry;\n\trz_list_foreach (proto->const_entries, iter, const_entry) {\n\t\tsymbol_name = get_constant_symbol_name(proto_name, const_entry);\n\t\tluac_add_symbol(\n\t\t\tinfo->symbol_list,\n\t\t\tsymbol_name,\n\t\t\tconst_entry->offset,\n\t\t\t\"UPVALUE\");\n\t\tRZ_FREE(symbol_name);\n\t}\n\n\t// 4. parse sub proto\n\tLuaProto *sub_proto;\n\trz_list_foreach (proto->proto_entries, iter, sub_proto) {\n\t\t_luac_build_info(sub_proto, info);\n\t}\n\n\tRZ_FREE(proto_name);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void _luac_build_info(LuaProto *proto, LuacBinInfo *info) {\n\t/* process proto header info */\n\tchar *section_name;\n\tchar *symbol_name;\n\tchar *proto_name;\n\tchar **upvalue_names = NULL;\n\tRzListIter *iter;\n\tint i = 0; // iter\n\n\tut64 current_offset;\n\tut64 current_size;\n\n\t// 0. check if stripped (proto name is lost)\n\tif (proto->name_size == 0 || proto->proto_name == NULL) {\n\t\t// replace name with current offset\n\t\tproto_name = rz_str_newf(\"fcn.%08llx\", proto->offset);\n\t} else {\n\t\tproto_name = rz_str_new((char *)proto->proto_name);\n\t}\n\n\t// 1.1 set section name as function_name.header\n\tLuaLocalVarEntry *local_var_entry;\n\trz_list_foreach (proto->local_var_info_entries, iter, local_var_entry) {\n\t\tluac_add_string(\n\t\t\tinfo->string_list,\n\t\t\t(char *)local_var_entry->varname,\n\t\t\tlocal_var_entry->offset,\n\t\t\tlocal_var_entry->varname_len);\n\t}\n\n\t// 2.2 parse debug_upvalues\n\tsize_t real_upvalue_cnt = rz_list_length(proto->upvalue_entries);\n\tif (real_upvalue_cnt > 0) {\n\t\tLuaDbgUpvalueEntry *debug_upv_entry;\n\t\tupvalue_names = RZ_NEWS0(char *, real_upvalue_cnt);\n\t\tif (!upvalue_names) {\n\t\t\tfree(proto_name);\n\t\t\treturn;\n\t\t}\n\n\t\ti = 0;\n\t\trz_list_foreach (proto->dbg_upvalue_entries, iter, debug_upv_entry) {\n\t\t\tupvalue_names[i] = (char *)debug_upv_entry->upvalue_name;\n\t\t\tluac_add_string(\n\t\t\t\tinfo->string_list,\n\t\t\t\tupvalue_names[i],\n\t\t\t\tdebug_upv_entry->offset,\n\t\t\t\tdebug_upv_entry->name_len);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t// 3.1 construct constant symbols\n\tLuaConstEntry *const_entry;\n\trz_list_foreach (proto->const_entries, iter, const_entry) {\n\t\tsymbol_name = get_constant_symbol_name(proto_name, const_entry);\n\t\tluac_add_symbol(\n\t\t\tinfo->symbol_list,\n\t\t\tsymbol_name,\n\t\t\tconst_entry->offset,\n\t\t\t\"UPVALUE\");\n\t\tRZ_FREE(symbol_name);\n\t}\n\n\t// 4. parse sub proto\n\tLuaProto *sub_proto;\n\trz_list_foreach (proto->proto_entries, iter, sub_proto) {\n\t\t_luac_build_info(sub_proto, info);\n\t}\n\n\tfree(upvalue_names);\n\tfree(proto_name);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int verify_cb(int preverify_ok, X509_STORE_CTX *x509_ctx)\n{\n    pj_ssl_sock_t *ssock;\n    SSL *ossl_ssl;\n    int err;\n\n    /* Get SSL instance */\n    ossl_ssl = X509_STORE_CTX_get_ex_data(x509_ctx, \n\t\t\t\t    SSL_get_ex_data_X509_STORE_CTX_idx());\n    pj_assert(ossl_ssl);\n\n    /* Get SSL socket instance */\n    ssock = SSL_get_ex_data(ossl_ssl, sslsock_idx);\n    pj_assert(ssock);\n\n    /* Store verification status */\n    err = X509_STORE_CTX_get_error(x509_ctx);\n    switch (err) {\n    case X509_V_OK:\n\tbreak;\n\n    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\n\tssock->verify_status |= PJ_SSL_CERT_EISSUER_NOT_FOUND;\n\tbreak;\n    default:\n\tssock->verify_status |= PJ_SSL_CERT_EUNKNOWN;\n\tbreak;\n    }\n\n    /* When verification is not requested just return ok here, however\n     * application can still get the verification status.\n     */\n    if (PJ_FALSE == ssock->param.verify_peer)\n\tpreverify_ok = 1;\n\n    return preverify_ok;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int verify_cb(int preverify_ok, X509_STORE_CTX *x509_ctx)\n{\n    pj_ssl_sock_t *ssock = NULL;\n    SSL *ossl_ssl = NULL;\n    int err;\n\n    /* Get SSL instance */\n    ossl_ssl = X509_STORE_CTX_get_ex_data(x509_ctx, \n\t\t\t\t    SSL_get_ex_data_X509_STORE_CTX_idx());\n    if (!ossl_ssl) {\n\tPJ_LOG(1,(THIS_FILE,\n\t\t  \"SSL verification callback failed to get SSL instance\"));\n\tgoto on_return;\n    }\n\n    /* Get SSL socket instance */\n    ssock = SSL_get_ex_data(ossl_ssl, sslsock_idx);\n    if (!ssock) {\n\t/* SSL socket may have been destroyed */\n\tPJ_LOG(1,(THIS_FILE,\n\t\t  \"SSL verification callback failed to get SSL socket \"\n\t\t  \"instance (sslsock_idx=%d).\", sslsock_idx));\n\tgoto on_return;\n    }\n\n    /* Store verification status */\n    err = X509_STORE_CTX_get_error(x509_ctx);\n    switch (err) {\n    case X509_V_OK:\n\tbreak;\n\n    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\n\tssock->verify_status |= PJ_SSL_CERT_EISSUER_NOT_FOUND;\n\tbreak;\n\tssock->verify_status |= PJ_SSL_CERT_EUNKNOWN;\n\tbreak;\n    }\n\n    /* When verification is not requested just return ok here, however\n     * application can still get the verification status.\n     */\n    if (PJ_FALSE == ssock->param.verify_peer)\n\tpreverify_ok = 1;\n\non_return:\n    return preverify_ok;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  do\n    rc = imap_cmd_step (idata);\n  while (rc == IMAP_CMD_CONTINUE);\n  \n  if (rc != IMAP_CMD_RESPOND)\n  {\n    dprint (1, (debugfile, \"Invalid response from server: %s\\n\", ibuf));\n    goto bail;\n  }\n\n  if ((len = mutt_from_base64 (obuf, idata->buf + 2)) == -1)\n  {\n    dprint (1, (debugfile, \"Error decoding base64 response.\\n\"));\n    goto bail;\n  }\n\n  obuf[len] = '\\0';\n  dprint (2, (debugfile, \"CRAM challenge: %s\\n\", obuf));\n\n  /* The client makes note of the data and then responds with a string\n   * consisting of the user name, a space, and a 'digest'. The latter is",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  do\n    rc = imap_cmd_step (idata);\n  while (rc == IMAP_CMD_CONTINUE);\n  \n  if (rc != IMAP_CMD_RESPOND)\n  {\n    dprint (1, (debugfile, \"Invalid response from server: %s\\n\", ibuf));\n    goto bail;\n  }\n\n  if ((len = mutt_from_base64 (obuf, idata->buf + 2, sizeof(obuf) - 1)) == -1)\n  {\n    dprint (1, (debugfile, \"Error decoding base64 response.\\n\"));\n    goto bail;\n  }\n\n  obuf[len] = '\\0';\n  dprint (2, (debugfile, \"CRAM challenge: %s\\n\", obuf));\n\n  /* The client makes note of the data and then responds with a string\n   * consisting of the user name, a space, and a 'digest'. The latter is",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        const NetplanState* np_state,\n        const NetplanNetDefinition* def,\n        const char *rootdir,\n        const char* path,\n        gboolean* has_been_written,\n        GError** error)\n{\n    g_autoptr(GString) network = NULL;\n    g_autoptr(GString) link = NULL;\n    GString* s = NULL;\n    mode_t orig_umask;\n\n    SET_OPT_OUT_PTR(has_been_written, FALSE);\n\n    if (def->type == NETPLAN_DEF_TYPE_VLAN && def->sriov_vlan_filter) {\n        g_debug(\"%s is defined as a hardware SR-IOV filtered VLAN, postponing creation\", def->id);\n        return TRUE;\n    }\n\n    /* Prepare the [Link] section of the .network file. */\n    link = g_string_sized_new(200);\n\n    if (network->len > 0 || link->len > 0) {\n        s = g_string_sized_new(200);\n        append_match_section(def, s, TRUE);\n\n        if (link->len > 0)\n            g_string_append_printf(s, \"\\n[Link]\\n%s\", link->str);\n        if (network->len > 0)\n            g_string_append_printf(s, \"\\n[Network]\\n%s\", network->str);\n\n        /* these do not contain secrets and need to be readable by\n         * systemd-networkd - LP: #1736965 */\n        orig_umask = umask(022);\n        _netplan_g_string_free_to_file(s, rootdir, path, \".network\");\n        umask(orig_umask);\n    }\n\n    SET_OPT_OUT_PTR(has_been_written, TRUE);\n    return TRUE;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "_netplan_netdef_write_network_file(\n        const NetplanState* np_state,\n        const NetplanNetDefinition* def,\n        const char *rootdir,\n        const char* path,\n        gboolean* has_been_written,\n        GError** error)\n{\n    g_autoptr(GString) network = NULL;\n    g_autoptr(GString) link = NULL;\n    GString* s = NULL;\n\n    SET_OPT_OUT_PTR(has_been_written, FALSE);\n\n    if (def->type == NETPLAN_DEF_TYPE_VLAN && def->sriov_vlan_filter) {\n        g_debug(\"%s is defined as a hardware SR-IOV filtered VLAN, postponing creation\", def->id);\n        return TRUE;\n    }\n\n    /* Prepare the [Link] section of the .network file. */\n    link = g_string_sized_new(200);\n\n    if (network->len > 0 || link->len > 0) {\n        s = g_string_sized_new(200);\n        append_match_section(def, s, TRUE);\n\n        if (link->len > 0)\n            g_string_append_printf(s, \"\\n[Link]\\n%s\", link->str);\n        if (network->len > 0)\n            g_string_append_printf(s, \"\\n[Network]\\n%s\", network->str);\n\n        _netplan_g_string_free_to_file_with_permissions(s, rootdir, path, \".network\", \"root\", NETWORKD_GROUP, 0640);\n    }\n\n    SET_OPT_OUT_PTR(has_been_written, TRUE);\n    return TRUE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void ep2_mul_slide(ep2_t r, const ep2_t p, const bn_t k) {\n\tep2_t t[1 << (EP_WIDTH - 1)], q;\n\tint i, j, l;\n\tuint8_t win[RLC_FP_BITS + 1];\n\n\tep2_null(q);\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n\t\t\tep2_null(t[i]);\n\t\t\tep2_new(t[i]);\n\t\t}\n\n\t\tep2_new(q);\n\n\t\tep2_copy(t[0], p);\n\t\tep2_dbl(q, p);\n\n#if defined(EP_MIXED)\n\t\tep2_norm(q, q);\n#endif\n\n\t\t/* Create table. */\n\t\tfor (i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep2_add(t[i], t[i - 1], q);\n\t\t}\n\n#if defined(EP_MIXED)\n\t\tep2_norm_sim(t + 1, t + 1, (1 << (EP_WIDTH - 1)) - 1);\n#endif\n\n\t\tep2_set_infty(q);\n\t\tl = RLC_FP_BITS + 1;\n\t\tbn_rec_slw(win, &l, k, EP_WIDTH);\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\tep2_dbl(q, q);\n\t\t\t} else {\n\t\t\t\tfor (j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\tep2_dbl(q, q);\n\t\t\t\t}\n\t\t\t\tep2_add(q, q, t[win[i] >> 1]);\n\t\t\t}\n\t\t}\n\n\t\tep2_norm(r, q);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep2_free(t[i]);\n\t\t}\n\t\tep2_free(q);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void ep2_mul_slide(ep2_t r, const ep2_t p, const bn_t k) {\n\tep2_t t[1 << (EP_WIDTH - 1)], q;\n\tuint8_t win[RLC_FP_BITS + 1];\n\tsize_t l;\n\n\tep2_null(q);\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfor (int i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n\t\t\tep2_null(t[i]);\n\t\t\tep2_new(t[i]);\n\t\t}\n\n\t\tep2_new(q);\n\n\t\tep2_copy(t[0], p);\n\t\tep2_dbl(q, p);\n\n#if defined(EP_MIXED)\n\t\tep2_norm(q, q);\n#endif\n\n\t\t/* Create table. */\n\t\tfor (size_t i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep2_add(t[i], t[i - 1], q);\n\t\t}\n\n#if defined(EP_MIXED)\n\t\tep2_norm_sim(t + 1, t + 1, (1 << (EP_WIDTH - 1)) - 1);\n#endif\n\n\t\tep2_set_infty(q);\n\t\tl = RLC_FP_BITS + 1;\n\t\tbn_rec_slw(win, &l, k, EP_WIDTH);\n\t\tfor (size_t i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\tep2_dbl(q, q);\n\t\t\t} else {\n\t\t\t\tfor (size_t j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\tep2_dbl(q, q);\n\t\t\t\t}\n\t\t\t\tep2_add(q, q, t[win[i] >> 1]);\n\t\t\t}\n\t\t}\n\n\t\tep2_norm(r, q);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep2_free(t[i]);\n\t\t}\n\t\tep2_free(q);\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tstruct btd_adapter *adapter = client->adapter;\n\tstruct mgmt_cp_stop_discovery cp;\n\n\t/* Check if there are more client discovering */\n\tif (g_slist_next(adapter->discovery_list)) {\n\t\tdiscovery_remove(client);\n\t\tupdate_discovery_filter(adapter);\n\t\treturn 0;\n\t}\n\n\tif (adapter->discovery_discoverable)\n\t\tset_discovery_discoverable(adapter, false);\n\n\t/*\n\t * In the idle phase of a discovery, there is no need to stop it\n\t * and so it is enough to send out the signal and just return.\n\t */\n\tif (adapter->discovery_enable == 0x00) {\n\t\tdiscovery_remove(client);\n\t\tadapter->discovering = false;\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tstruct btd_adapter *adapter = client->adapter;\n\tstruct mgmt_cp_stop_discovery cp;\n\n\t/* Check if there are more client discovering */\n\tif (g_slist_next(adapter->discovery_list)) {\n\t\tdiscovery_remove(client);\n\t\tupdate_discovery_filter(adapter);\n\t\treturn 0;\n\t}\n\n\tset_discovery_discoverable(adapter, false);\n\n\t/*\n\t * In the idle phase of a discovery, there is no need to stop it\n\t * and so it is enough to send out the signal and just return.\n\t */\n\tif (adapter->discovery_enable == 0x00) {\n\t\tdiscovery_remove(client);\n\t\tadapter->discovering = false;\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "epilogProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  parser->m_processor = epilogProcessor;\n  parser->m_eventPtr = s;\n  for (;;) {\n    const char *next = NULL;\n    int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    parser->m_eventEndPtr = next;\n    switch (tok) {\n    /* report partial linebreak - it might be the last token */\n    case -XML_TOK_PROLOG_S:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "epilogProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  parser->m_processor = epilogProcessor;\n  parser->m_eventPtr = s;\n  for (;;) {\n    const char *next = NULL;\n    int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n#if defined(XML_DTD) || XML_GE == 1\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    parser->m_eventEndPtr = next;\n    switch (tok) {\n    /* report partial linebreak - it might be the last token */\n    case -XML_TOK_PROLOG_S:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void rose_start_heartbeat(struct sock *sk)\n{\n\tdel_timer(&sk->sk_timer);\n\n\tsk->sk_timer.function = rose_heartbeat_expiry;\n\tsk->sk_timer.expires  = jiffies + 5 * HZ;\n\n\tadd_timer(&sk->sk_timer);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void rose_start_heartbeat(struct sock *sk)\n{\n\tsk_stop_timer(sk, &sk->sk_timer);\n\n\tsk->sk_timer.function = rose_heartbeat_expiry;\n\tsk->sk_timer.expires  = jiffies + 5 * HZ;\n\n\tsk_reset_timer(sk, &sk->sk_timer, sk->sk_timer.expires);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "bool ExtractSymlink(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName)\n{\n#if defined(SAVE_LINKS) && defined(_UNIX)\n  // For RAR 3.x archives we process links even in test mode to skip link data.\n  if (Arc.Format==RARFMT15)\n    return ExtractUnixLink30(Cmd,DataIO,Arc,LinkName);\n  if (Arc.Format==RARFMT50)\n    return ExtractUnixLink50(Cmd,LinkName,&Arc.FileHead);\n#elif defined _WIN_ALL\n  // RAR 5.0 archives store link information in file header, so there is\n  // no need to additionally test it if we do not create a file.\n  if (Arc.Format==RARFMT50)\n    return CreateReparsePoint(Cmd,LinkName,&Arc.FileHead);\n#endif\n  return false;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "bool ExtractSymlink(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName,bool &UpLink)\n{\n  // Returning true in Uplink indicates that link target might include \"..\"\n  // and enables additional checks. It is ok to falsely return true here,\n  // as it implies only the minor performance penalty. But we shall always\n  // return true for links with \"..\" in target for security reason.\n\n  UpLink=true; // Assume the target might include potentially unsafe \"..\".\n#if defined(SAVE_LINKS) && defined(_UNIX) || defined(_WIN_ALL)\n  if (Arc.Format==RARFMT50) // For RAR5 archives we can check RedirName for both Unix and Windows.\n    UpLink=wcsstr(Arc.FileHead.RedirName,L\"..\")!=NULL;\n#endif\n\n#if defined(SAVE_LINKS) && defined(_UNIX)\n  // For RAR 3.x archives we process links even in test mode to skip link data.\n  if (Arc.Format==RARFMT15)\n    return ExtractUnixLink30(Cmd,DataIO,Arc,LinkName,UpLink);\n  if (Arc.Format==RARFMT50)\n    return ExtractUnixLink50(Cmd,LinkName,&Arc.FileHead);\n#elif defined(_WIN_ALL)\n  // RAR 5.0 archives store link information in file header, so there is\n  // no need to additionally test it if we do not create a file.\n  if (Arc.Format==RARFMT50)\n    return CreateReparsePoint(Cmd,LinkName,&Arc.FileHead);\n#endif\n  return false;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int bson_check_field_name( bson *b, const char *string,\n                           const int length ) {\n\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 1, 1 );\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int bson_check_field_name( bson *b, const char *string,\n                           const size_t length ) {\n\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 1, 1 );\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (newsk == NULL)\n\t\tgoto exit_nonewsk;\n\n\tsk_setup_caps(newsk, dst);\n\n\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n\tnewinet->inet_daddr\t= ireq->rmt_addr;\n\tnewinet->inet_rcv_saddr = ireq->loc_addr;\n\tnewinet->inet_saddr\t= ireq->loc_addr;\n\tnewinet->opt\t   = ireq->opt;\n\tireq->opt\t   = NULL;\n\tnewinet->mc_index  = inet_iif(skb);\n\tnewinet->mc_ttl\t   = ip_hdr(skb)->ttl;\n\tnewinet->inet_id   = jiffies;\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (newsk == NULL)\n\t\tgoto exit_nonewsk;\n\n\tsk_setup_caps(newsk, dst);\n\n\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n\tnewinet->inet_daddr\t= ireq->rmt_addr;\n\tnewinet->inet_rcv_saddr = ireq->loc_addr;\n\tnewinet->inet_saddr\t= ireq->loc_addr;\n\tnewinet->inet_opt\t= ireq->opt;\n\tireq->opt\t   = NULL;\n\tnewinet->mc_index  = inet_iif(skb);\n\tnewinet->mc_ttl\t   = ip_hdr(skb)->ttl;\n\tnewinet->inet_id   = jiffies;\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t}\n#endif\n\n\tif (dump_cart) dump_isom_cover_art(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n\tif (dump_chap) dump_isom_chapters(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_chap);\n\tif (dump_udta_type) dump_isom_udta(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_udta_type, dump_udta_track);\n\n\tif (dump_iod) {\n\t\tGF_InitialObjectDescriptor *iod = (GF_InitialObjectDescriptor *)gf_isom_get_root_od(file);\n\t\tif (!iod) {\n\t\t\tfprintf(stderr, \"File %s has no IOD\", inName);\n\t\t} else {\n\t\t\tchar szName[GF_MAX_PATH+10];\n\t\t\tFILE *iodf;\n\t\t\tsprintf(szName, \"%s.iod\", outfile);\n\t\t\tiodf = gf_fopen(szName, \"wb\");\n\t\t\tif (!iodf) {\n\t\t\t\tfprintf(stderr, \"Cannot open destination %s\\n\", szName);\n\t\t\t} else {\n\t\t\t\tu8 *desc;\n\t\t\t\tu32 size;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t}\n#endif\n\n\tif (dump_cart) dump_isom_cover_art(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n\tif (dump_chap) dump_isom_chapters(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_chap);\n\tif (dump_udta_type) dump_isom_udta(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_udta_type, dump_udta_track);\n\n\tif (dump_iod) {\n\t\tGF_InitialObjectDescriptor *iod = (GF_InitialObjectDescriptor *)gf_isom_get_root_od(file);\n\t\tif (!iod) {\n\t\t\tfprintf(stderr, \"File %s has no IOD\\n\", inName);\n\t\t} else {\n\t\t\tchar szName[GF_MAX_PATH+10];\n\t\t\tFILE *iodf;\n\t\t\tsprintf(szName, \"%s.iod\", outfile);\n\t\t\tiodf = gf_fopen(szName, \"wb\");\n\t\t\tif (!iodf) {\n\t\t\t\tfprintf(stderr, \"Cannot open destination %s\\n\", szName);\n\t\t\t} else {\n\t\t\t\tu8 *desc;\n\t\t\t\tu32 size;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void bn_srt(bn_t c, bn_t a) {\n\tbn_t h, l, m, t;\n\tint bits, cmp;\n\n\tif (bn_sign(a) == RLC_NEG) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t}\n\n\tbits = bn_bits(a);\n\tbits += (bits % 2);\n\n\tbn_null(h);\n\tbn_null(l);\n\tbn_null(m);\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(h);\n\t\tbn_new(l);\n\t\tbn_new(m);\n\t\tbn_new(t);\n\n\t\tbn_set_2b(h, bits >> 1);\n\t\tbn_set_2b(l, (bits >> 1) - 1);\n\n\t\t/* Trivial binary search approach. */\n\t\tdo {\n\t\t\tbn_add(m, h, l);\n\t\t\tbn_hlv(m, m);\n\t\t\tbn_sqr(t, m);\n\t\t\tcmp = bn_cmp(t, a);\n\t\t\tbn_sub(t, h, l);\n\n\t\t\tif (cmp == RLC_GT) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void bn_srt(bn_t c, bn_t a) {\n\tbn_t h, l, m, t;\n\tsize_t bits;\n\tint cmp;\n\n\tif (bn_sign(a) == RLC_NEG) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t}\n\n\tbits = bn_bits(a);\n\tbits += (bits % 2);\n\n\tbn_null(h);\n\tbn_null(l);\n\tbn_null(m);\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(h);\n\t\tbn_new(l);\n\t\tbn_new(m);\n\t\tbn_new(t);\n\n\t\tbn_zero(l);\n\t\tbn_set_2b(h, bits >> 1);\n\t\tif (bits >= 2) {\n\t\t\tbn_set_2b(l, (bits >> 1) - 1);\n\t\t}\n\n\t\t/* Trivial binary search approach. */\n\t\tdo {\n\t\t\tbn_add(m, h, l);\n\t\t\tbn_hlv(m, m);\n\t\t\tbn_sqr(t, m);\n\t\t\tcmp = bn_cmp(t, a);\n\t\t\tbn_sub(t, h, l);\n\n\t\t\tif (cmp == RLC_GT) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tset_intr_gate(X86_TRAP_UD, invalid_op);\n\tset_intr_gate(X86_TRAP_NM, device_not_available);\n#ifdef CONFIG_X86_32\n\tset_task_gate(X86_TRAP_DF, GDT_ENTRY_DOUBLEFAULT_TSS);\n#else\n\tset_intr_gate_ist(X86_TRAP_DF, &double_fault, DOUBLEFAULT_STACK);\n#endif\n\tset_intr_gate(X86_TRAP_OLD_MF, coprocessor_segment_overrun);\n\tset_intr_gate(X86_TRAP_TS, invalid_TSS);\n\tset_intr_gate(X86_TRAP_NP, segment_not_present);\n\tset_intr_gate_ist(X86_TRAP_SS, &stack_segment, STACKFAULT_STACK);\n\tset_intr_gate(X86_TRAP_GP, general_protection);\n\tset_intr_gate(X86_TRAP_SPURIOUS, spurious_interrupt_bug);\n\tset_intr_gate(X86_TRAP_MF, coprocessor_error);\n\tset_intr_gate(X86_TRAP_AC, alignment_check);\n#ifdef CONFIG_X86_MCE\n\tset_intr_gate_ist(X86_TRAP_MC, &machine_check, MCE_STACK);\n#endif\n\tset_intr_gate(X86_TRAP_XF, simd_coprocessor_error);\n\n\t/* Reserve all the builtin and the syscall vector: */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tset_intr_gate(X86_TRAP_UD, invalid_op);\n\tset_intr_gate(X86_TRAP_NM, device_not_available);\n#ifdef CONFIG_X86_32\n\tset_task_gate(X86_TRAP_DF, GDT_ENTRY_DOUBLEFAULT_TSS);\n#else\n\tset_intr_gate_ist(X86_TRAP_DF, &double_fault, DOUBLEFAULT_STACK);\n#endif\n\tset_intr_gate(X86_TRAP_OLD_MF, coprocessor_segment_overrun);\n\tset_intr_gate(X86_TRAP_TS, invalid_TSS);\n\tset_intr_gate(X86_TRAP_NP, segment_not_present);\n\tset_intr_gate(X86_TRAP_SS, stack_segment);\n\tset_intr_gate(X86_TRAP_GP, general_protection);\n\tset_intr_gate(X86_TRAP_SPURIOUS, spurious_interrupt_bug);\n\tset_intr_gate(X86_TRAP_MF, coprocessor_error);\n\tset_intr_gate(X86_TRAP_AC, alignment_check);\n#ifdef CONFIG_X86_MCE\n\tset_intr_gate_ist(X86_TRAP_MC, &machine_check, MCE_STACK);\n#endif\n\tset_intr_gate(X86_TRAP_XF, simd_coprocessor_error);\n\n\t/* Reserve all the builtin and the syscall vector: */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tgoto fail;\n\t}\n\n\tStream_Seek_UINT8(s);                      /* reserved1 (1 byte) */\n\tStream_Seek_UINT8(s);                      /* reserved2 (1 byte) */\n\tStream_Read_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Read_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Read_UINT32(s, new_len);            /* length (4 bytes) */\n\n\tif (Stream_GetRemainingLength(s) < new_len)\n\t\tgoto fail;\n\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\n\tif (!new_data)\n\t\tgoto fail;\n\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tgoto fail;\n\t}\n\n\tStream_Seek_UINT8(s);                      /* reserved1 (1 byte) */\n\tStream_Seek_UINT8(s);                      /* reserved2 (1 byte) */\n\tStream_Read_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Read_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Read_UINT32(s, new_len);            /* length (4 bytes) */\n\n\tif ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len))\n\t\tgoto fail;\n\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\n\tif (!new_data)\n\t\tgoto fail;\n\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  // x: op_info.inputs(0)\n  // y: op_info.inputs(1)\n  // y_grad: op_info.inputs(2)\n  if (op_info.inputs_size() < 3) {\n    return errors::InvalidArgument(\"MaxPoolGrad op has invalid inputs: \",\n                                   op_info.ShortDebugString());\n  }\n\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n\n  int64_t ops = 0;\n  if (dims.kx == 1 && dims.ky == 1) {\n    // 1x1 window. No need to know which input was max.\n    ops = dims.batch * dims.ix * dims.iy * dims.iz;\n  } else if (dims.kx <= dims.sx && dims.ky <= dims.sy) {\n    // Non-overlapping window: re-run maxpool, then assign zero or y_grad.\n    ops = dims.batch * dims.iz *\n          (dims.ox * dims.oy * (dims.kx * dims.ky - 1) + dims.ix * dims.iy);\n  } else {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  // x: op_info.inputs(0)\n  // y: op_info.inputs(1)\n  // y_grad: op_info.inputs(2)\n  if (op_info.inputs_size() < 3) {\n    return errors::InvalidArgument(\"MaxPoolGrad op has invalid inputs: \",\n                                   op_info.ShortDebugString());\n  }\n\n  TF_ASSIGN_OR_RETURN(ConvolutionDimensions dims,\n                      OpDimensionsFromInputs(op_info.inputs(0).shape(), op_info,\n                                             &found_unknown_shapes));\n\n  int64_t ops = 0;\n  if (dims.kx == 1 && dims.ky == 1) {\n    // 1x1 window. No need to know which input was max.\n    ops = dims.batch * dims.ix * dims.iy * dims.iz;\n  } else if (dims.kx <= dims.sx && dims.ky <= dims.sy) {\n    // Non-overlapping window: re-run maxpool, then assign zero or y_grad.\n    ops = dims.batch * dims.iz *\n          (dims.ox * dims.oy * (dims.kx * dims.ky - 1) + dims.ix * dims.iy);\n  } else {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int udf_load_logicalvol(struct super_block *sb, sector_t block,\n\t\t\t       struct kernel_lb_addr *fileset)\n{\n\tstruct logicalVolDesc *lvd;\n\tint i, j, offset;\n\tuint8_t type;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct genericPartitionMap *gpm;\n\tuint16_t ident;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn 1;\n\tBUG_ON(ident != TAG_IDENT_LVD);\n\tlvd = (struct logicalVolDesc *)bh->b_data;\n\n\tret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));\n\tif (ret)\n\t\tgoto out_bh;\n\n\tfor (i = 0, offset = 0;\n\t     i < sbi->s_partitions && offset < le32_to_cpu(lvd->mapTableLength);\n\t     i++, offset += gpm->partitionMapLength) {\n\t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n\t\tgpm = (struct genericPartitionMap *)\n\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\ttype = gpm->partitionMapType;\n\t\tif (type == 1) {\n\t\t\tstruct genericPartitionMap1 *gpm1 =\n\t\t\t\t(struct genericPartitionMap1 *)gpm;\n\t\t\tmap->s_partition_type = UDF_TYPE1_MAP15;\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(gpm1->volSeqNum);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int udf_load_logicalvol(struct super_block *sb, sector_t block,\n\t\t\t       struct kernel_lb_addr *fileset)\n{\n\tstruct logicalVolDesc *lvd;\n\tint i, j, offset;\n\tuint8_t type;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct genericPartitionMap *gpm;\n\tuint16_t ident;\n\tstruct buffer_head *bh;\n\tunsigned int table_len;\n\tint ret = 0;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn 1;\n\tBUG_ON(ident != TAG_IDENT_LVD);\n\tlvd = (struct logicalVolDesc *)bh->b_data;\n\ttable_len = le32_to_cpu(lvd->mapTableLength);\n\tif (sizeof(*lvd) + table_len > sb->s_blocksize) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Partition table too long (%u > %lu)\\n\", table_len,\n\t\t\tsb->s_blocksize - sizeof(*lvd));\n\t\tgoto out_bh;\n\t}\n\n\tret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));\n\tif (ret)\n\t\tgoto out_bh;\n\n\tfor (i = 0, offset = 0;\n\t     i < sbi->s_partitions && offset < table_len;\n\t     i++, offset += gpm->partitionMapLength) {\n\t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n\t\tgpm = (struct genericPartitionMap *)\n\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\ttype = gpm->partitionMapType;\n\t\tif (type == 1) {\n\t\t\tstruct genericPartitionMap1 *gpm1 =\n\t\t\t\t(struct genericPartitionMap1 *)gpm;\n\t\t\tmap->s_partition_type = UDF_TYPE1_MAP15;\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(gpm1->volSeqNum);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "START_TEST (test_send_sonmp)\n{\n\tint n;\n\t/* Packet we should build:\nIEEE 802.3 Ethernet \n    Destination: Bay-Networks-(Synoptics)-autodiscovery (01:00:81:00:01:00)\n    Source: 5e:10:8e:e7:84:ad (5e:10:8e:e7:84:ad)\n    Length: 22\nLogical-Link Control\n    DSAP: SNAP (0xaa)\n    IG Bit: Individual\n    SSAP: SNAP (0xaa)\n    CR Bit: Command\n    Control field: U, func=UI (0x03)\n        000. 00.. = Command: Unnumbered Information (0x00)\n        .... ..11 = Frame type: Unnumbered frame (0x03)\n    Organization Code: Nortel Networks SONMP (0x000081)\n    PID: SONMP segment hello (0x01a2)\n    NMM IP address: 172.17.142.37 (172.17.142.37)\n    Segment Identifier: 0x000004\n    Chassis type: Unknown (1)\n    Backplane type: ethernet, fast ethernet and gigabit ethernet (12)\n    NMM state: New (3)\n    Number of links: 1\n\nIEEE 802.3 Ethernet \n    Destination: Bay-Networks-(Synoptics)-autodiscovery (01:00:81:00:01:01)\n    Source: 5e:10:8e:e7:84:ad (5e:10:8e:e7:84:ad)\n    Length: 22\nLogical-Link Control\n    DSAP: SNAP (0xaa)\n    IG Bit: Individual\n    SSAP: SNAP (0xaa)\n    CR Bit: Command\n    Control field: U, func=UI (0x03)\n        000. 00.. = Command: Unnumbered Information (0x00)\n        .... ..11 = Frame type: Unnumbered frame (0x03)\n    Organization Code: Nortel Networks SONMP (0x000081)\n    PID: SONMP flatnet hello (0x01a1)\nNortel Networks / SynOptics Network Management Protocol\n    NMM IP address: 172.17.142.37 (172.17.142.37)\n    Segment Identifier: 0x000004\n    Chassis type: Unknown (1)\n    Backplane type: ethernet, fast ethernet and gigabit ethernet (12)\n    NMM state: New (3)\n    Number of links: 1\n\t*/\n\tchar pkt1[] = {\n\t\t0x01, 0x00, 0x81, 0x00, 0x01, 0x00, 0x5e, 0x10,\n\t\t0x8e, 0xe7, 0x84, 0xad, 0x00, 0x16, 0xaa, 0xaa,\n\t\t0x03, 0x00, 0x00, 0x81, 0x01, 0xa2, 0xac, 0x11,\n\t\t0x8e, 0x25, 0x00, 0x00, 0x04, 0x01, 0x0c, 0x03,\n\t\t0x01 };\n\tchar pkt2[] = {\n\t\t0x01, 0x00, 0x81, 0x00, 0x01, 0x01, 0x5e, 0x10,\n\t\t0x8e, 0xe7, 0x84, 0xad, 0x00, 0x16, 0xaa, 0xaa,\n\t\t0x03, 0x00, 0x00, 0x81, 0x01, 0xa1, 0xac, 0x11,\n\t\t0x8e, 0x25, 0x00, 0x00, 0x04, 0x01, 0x0c, 0x03,\n\t\t0x01 };\n\tstruct packet *pkt;\n\tin_addr_t addr;\t\n\tstruct lldpd_mgmt *mgmt;\n\n\t/* Populate port and chassis */\n\thardware.h_lport.p_id_subtype = LLDP_PORTID_SUBTYPE_IFNAME;\n\thardware.h_lport.p_id = \"Not used\";\n\thardware.h_lport.p_id_len = strlen(hardware.h_lport.p_id);\n\tchassis.c_id_subtype = LLDP_CHASSISID_SUBTYPE_LLADDR;\n\tchassis.c_id = macaddress;\n\tchassis.c_id_len = ETHER_ADDR_LEN;\n\tTAILQ_INIT(&chassis.c_mgmt);\n\taddr = inet_addr(\"172.17.142.37\");\n\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, \n\t\t\t\t&addr, sizeof(in_addr_t), 0);\n\tif (mgmt == NULL)\n\t\tck_abort();\n\tTAILQ_INSERT_TAIL(&chassis.c_mgmt, mgmt, m_entries);\n\n\t/* Build packet */\n\tn = sonmp_send(NULL, &hardware);\n\tif (n != 0) {\n\t\tfail(\"unable to build packet\");\n\t\treturn;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "START_TEST (test_send_sonmp)\n{\n\tint n;\n\t/* Packet we should build:\nIEEE 802.3 Ethernet \n    Destination: Bay-Networks-(Synoptics)-autodiscovery (01:00:81:00:01:00)\n    Source: 5e:10:8e:e7:84:ad (5e:10:8e:e7:84:ad)\n    Length: 19\nLogical-Link Control\n    DSAP: SNAP (0xaa)\n    IG Bit: Individual\n    SSAP: SNAP (0xaa)\n    CR Bit: Command\n    Control field: U, func=UI (0x03)\n        000. 00.. = Command: Unnumbered Information (0x00)\n        .... ..11 = Frame type: Unnumbered frame (0x03)\n    Organization Code: Nortel Networks SONMP (0x000081)\n    PID: SONMP segment hello (0x01a2)\n    NMM IP address: 172.17.142.37 (172.17.142.37)\n    Segment Identifier: 0x000004\n    Chassis type: Unknown (1)\n    Backplane type: ethernet, fast ethernet and gigabit ethernet (12)\n    NMM state: New (3)\n    Number of links: 1\n\nIEEE 802.3 Ethernet \n    Destination: Bay-Networks-(Synoptics)-autodiscovery (01:00:81:00:01:01)\n    Source: 5e:10:8e:e7:84:ad (5e:10:8e:e7:84:ad)\n    Length: 19\nLogical-Link Control\n    DSAP: SNAP (0xaa)\n    IG Bit: Individual\n    SSAP: SNAP (0xaa)\n    CR Bit: Command\n    Control field: U, func=UI (0x03)\n        000. 00.. = Command: Unnumbered Information (0x00)\n        .... ..11 = Frame type: Unnumbered frame (0x03)\n    Organization Code: Nortel Networks SONMP (0x000081)\n    PID: SONMP flatnet hello (0x01a1)\nNortel Networks / SynOptics Network Management Protocol\n    NMM IP address: 172.17.142.37 (172.17.142.37)\n    Segment Identifier: 0x000004\n    Chassis type: Unknown (1)\n    Backplane type: ethernet, fast ethernet and gigabit ethernet (12)\n    NMM state: New (3)\n    Number of links: 1\n\t*/\n\tchar pkt1[] = {\n\t\t0x01, 0x00, 0x81, 0x00, 0x01, 0x00, 0x5e, 0x10,\n\t\t0x8e, 0xe7, 0x84, 0xad, 0x00, 0x13, 0xaa, 0xaa,\n\t\t0x03, 0x00, 0x00, 0x81, 0x01, 0xa2, 0xac, 0x11,\n\t\t0x8e, 0x25, 0x00, 0x00, 0x04, 0x01, 0x0c, 0x03,\n\t\t0x01 };\n\tchar pkt2[] = {\n\t\t0x01, 0x00, 0x81, 0x00, 0x01, 0x01, 0x5e, 0x10,\n\t\t0x8e, 0xe7, 0x84, 0xad, 0x00, 0x13, 0xaa, 0xaa,\n\t\t0x03, 0x00, 0x00, 0x81, 0x01, 0xa1, 0xac, 0x11,\n\t\t0x8e, 0x25, 0x00, 0x00, 0x04, 0x01, 0x0c, 0x03,\n\t\t0x01 };\n\tstruct packet *pkt;\n\tin_addr_t addr;\t\n\tstruct lldpd_mgmt *mgmt;\n\n\t/* Populate port and chassis */\n\thardware.h_lport.p_id_subtype = LLDP_PORTID_SUBTYPE_IFNAME;\n\thardware.h_lport.p_id = \"Not used\";\n\thardware.h_lport.p_id_len = strlen(hardware.h_lport.p_id);\n\tchassis.c_id_subtype = LLDP_CHASSISID_SUBTYPE_LLADDR;\n\tchassis.c_id = macaddress;\n\tchassis.c_id_len = ETHER_ADDR_LEN;\n\tTAILQ_INIT(&chassis.c_mgmt);\n\taddr = inet_addr(\"172.17.142.37\");\n\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4,\n\t\t\t\t&addr, sizeof(in_addr_t), 0);\n\tif (mgmt == NULL)\n\t\tck_abort();\n\tTAILQ_INSERT_TAIL(&chassis.c_mgmt, mgmt, m_entries);\n\n\t/* Build packet */\n\tn = sonmp_send(NULL, &hardware);\n\tif (n != 0) {\n\t\tfail(\"unable to build packet\");\n\t\treturn;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct skcipher_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(private));\n\n\tINIT_LIST_HEAD(&ctx->tsgl);\n\tctx->len = len;\n\tctx->used = 0;\n\tctx->more = 0;\n\tctx->merge = 0;\n\tctx->enc = 0;\n\tatomic_set(&ctx->inflight, 0);\n\taf_alg_init_completion(&ctx->completion);\n\n\task->private = ctx;\n\n\tskcipher_request_set_tfm(&ctx->req, private);\n\tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      af_alg_complete, &ctx->completion);\n\n\tsk->sk_destruct = skcipher_sock_destruct;\n\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct skcipher_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_tfm *tfm = private;\n\tstruct crypto_skcipher *skcipher = tfm->skcipher;\n\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);\n\n\tif (!tfm->has_key)\n\t\treturn -ENOKEY;\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));\n\n\tINIT_LIST_HEAD(&ctx->tsgl);\n\tctx->len = len;\n\tctx->used = 0;\n\tctx->more = 0;\n\tctx->merge = 0;\n\tctx->enc = 0;\n\tatomic_set(&ctx->inflight, 0);\n\taf_alg_init_completion(&ctx->completion);\n\n\task->private = ctx;\n\n\tskcipher_request_set_tfm(&ctx->req, skcipher);\n\tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      af_alg_complete, &ctx->completion);\n\n\tsk->sk_destruct = skcipher_sock_destruct;\n\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "PyInit__ast3(void)\n{\n    PyObject *m, *d;\n    if (!init_types()) return NULL;\n    m = PyModule_Create(&_astmodule3);\n    if (!m) return NULL;\n    d = PyModule_GetDict(m);\n    if (PyDict_SetItemString(d, \"AST\", (PyObject*)&AST_type) < 0) return NULL;\n    if (PyModule_AddIntMacro(m, PyCF_ONLY_AST) < 0)\n        return NULL;\n    if (PyDict_SetItemString(d, \"mod\", (PyObject*)mod_type) < 0) return NULL;\n    if (PyDict_SetItemString(d, \"Module\", (PyObject*)Module_type) < 0) return\n        NULL;\n    if (PyDict_SetItemString(d, \"Interactive\", (PyObject*)Interactive_type) <\n        0) return NULL;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "PyInit__ast3(void)\n{\n    PyObject *m, *d;\n    if (!init_types()) return NULL;\n    m = PyModule_Create(&_astmodule);\n    if (!m) return NULL;\n    d = PyModule_GetDict(m);\n    if (PyDict_SetItemString(d, \"AST\", (PyObject*)&AST_type) < 0) return NULL;\n    if (PyModule_AddIntMacro(m, PyCF_ONLY_AST) < 0)\n        return NULL;\n    if (PyDict_SetItemString(d, \"mod\", (PyObject*)mod_type) < 0) return NULL;\n    if (PyDict_SetItemString(d, \"Module\", (PyObject*)Module_type) < 0) return\n        NULL;\n    if (PyDict_SetItemString(d, \"Interactive\", (PyObject*)Interactive_type) <\n        0) return NULL;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": " */\nprivate int\nmconvert(struct magic_set *ms, struct magic *m, int flip)\n{\n\tunion VALUETYPE *p = &ms->ms_value;\n\n\tswitch (cvt_flip(m->type, flip)) {\n\tcase FILE_BYTE:\n\t\tcvt_8(p, m);\n\t\treturn 1;\n\tcase FILE_SHORT:\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LONG:\n\tcase FILE_DATE:\n\tcase FILE_LDATE:\n\t\tcvt_32(p, m);\n\t}\n\tcase FILE_BESHORT:\n\t\tp->h = (short)((p->hs[0]<<8)|(p->hs[1]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_BELONG:\n\tcase FILE_BEDATE:\n\tcase FILE_BELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_BEQUAD:\n\tcase FILE_BEQDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_BEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));\n\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_LESHORT:\n\t\tp->h = (short)((p->hs[1]<<8)|(p->hs[0]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LELONG:\n\tcase FILE_LEDATE:\n\tcase FILE_LELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_LEQUAD:\n\tcase FILE_LEQDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_LEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));\n\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_MELONG:\n\tcase FILE_MEDATE:\n\tcase FILE_MELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_FLOAT:\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_BEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)|\n\t\t\t((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_LEFLOAT:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": " */\nprivate int\nmconvert(struct magic_set *ms, struct magic *m, int flip)\n{\n\tunion VALUETYPE *p = &ms->ms_value;\n\tuint8_t type;\n\n\tswitch (type = cvt_flip(m->type, flip)) {\n\tcase FILE_BYTE:\n\t\tcvt_8(p, m);\n\t\treturn 1;\n\tcase FILE_SHORT:\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LONG:\n\tcase FILE_DATE:\n\tcase FILE_LDATE:\n\t\tcvt_32(p, m);\n\t}\n\tcase FILE_BESHORT:\n\t\tp->h = (short)((p->hs[0]<<8)|(p->hs[1]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_BELONG:\n\tcase FILE_BEDATE:\n\tcase FILE_BELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));\n\t\tif (type == FILE_BELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_BEQUAD:\n\tcase FILE_BEQDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_BEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));\n\t\tif (type == FILE_BEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_LESHORT:\n\t\tp->h = (short)((p->hs[1]<<8)|(p->hs[0]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LELONG:\n\tcase FILE_LEDATE:\n\tcase FILE_LELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));\n\t\tif (type == FILE_LELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_LEQUAD:\n\tcase FILE_LEQDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_LEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));\n\t\tif (type == FILE_LEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_MELONG:\n\tcase FILE_MEDATE:\n\tcase FILE_MELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));\n\t\tif (type == FILE_MELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_FLOAT:\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_BEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)|\n\t\t\t((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_LEFLOAT:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void perf_event_mmap_output(struct perf_event *event,\n\t\t\t\t     struct perf_mmap_event *mmap_event)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint size = mmap_event->event_id.header.size;\n\tint ret;\n\n\tperf_event_header__init_id(&mmap_event->event_id.header, &sample, event);\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tmmap_event->event_id.header.size, 0, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tmmap_event->event_id.pid = perf_event_pid(event, current);\n\tmmap_event->event_id.tid = perf_event_tid(event, current);\n\n\tperf_output_put(&handle, mmap_event->event_id);\n\t__output_copy(&handle, mmap_event->file_name,\n\t\t\t\t   mmap_event->file_size);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void perf_event_mmap_output(struct perf_event *event,\n\t\t\t\t     struct perf_mmap_event *mmap_event)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint size = mmap_event->event_id.header.size;\n\tint ret;\n\n\tperf_event_header__init_id(&mmap_event->event_id.header, &sample, event);\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tmmap_event->event_id.header.size, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tmmap_event->event_id.pid = perf_event_pid(event, current);\n\tmmap_event->event_id.tid = perf_event_tid(event, current);\n\n\tperf_output_put(&handle, mmap_event->event_id);\n\t__output_copy(&handle, mmap_event->file_name,\n\t\t\t\t   mmap_event->file_size);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t}\n      if (pid != (pid_t)-1)\n        {\n          if (WIFSIGNALED (status))\n            {\n              fprintf (stderr, \"%s%s\\n\", strsignal (WTERMSIG (status)),\n                       WCOREDUMP (status) ? _(\" (core dumped)\") : \"\");\n              status = WTERMSIG (status) + 128;\n            }\n          else\n            status = WEXITSTATUS (status);\n        }\n      else if (caught_signal)\n        status = caught_signal + 128;\n      else\n        status = 1;\n    }\n  else\n    status = 1;\n\n  if (caught_signal)\n    {\n      fprintf (stderr, _(\"\\nSession terminated, killing shell...\"));\n      kill (child, SIGTERM);\n    }\n\n  cleanup_pam (PAM_SUCCESS);\n\n  if (caught_signal)\n    {\n      sleep (2);\n      kill (child, SIGKILL);\n      fprintf (stderr, _(\" ...killed.\\n\"));\n\n      /* Let's terminate itself with the received signal.\n       *\n       * It seems that shells use WIFSIGNALED() rather than our exit status\n       * value to detect situations when is necessary to cleanup (reset)\n       * terminal settings (kzak -- Jun 2013).\n       */\n      switch (caught_signal) {\n        case SIGTERM:\n          sigaction(SIGTERM, &oldact[0], NULL);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      if (pid != (pid_t)-1)\n        {\n          if (WIFSIGNALED (status))\n            {\n              fprintf (stderr, \"%s%s\\n\", strsignal (WTERMSIG (status)),\n                       WCOREDUMP (status) ? _(\" (core dumped)\") : \"\");\n              status = WTERMSIG (status) + 128;\n            }\n          else\n            status = WEXITSTATUS (status);\n\n\t  /* child is gone, don't use the PID anymore */\n\t  child = (pid_t) -1;\n        }\n      else if (caught_signal)\n        status = caught_signal + 128;\n      else\n        status = 1;\n    }\n  else\n    status = 1;\n\n  if (caught_signal && child != (pid_t)-1)\n    {\n      fprintf (stderr, _(\"\\nSession terminated, killing shell...\"));\n      kill (child, SIGTERM);\n    }\n\n  cleanup_pam (PAM_SUCCESS);\n\n  if (caught_signal)\n    {\n      if (child != (pid_t)-1)\n\t{\n\t  sleep (2);\n\t  kill (child, SIGKILL);\n\t  fprintf (stderr, _(\" ...killed.\\n\"));\n\t}\n\n      /* Let's terminate itself with the received signal.\n       *\n       * It seems that shells use WIFSIGNALED() rather than our exit status\n       * value to detect situations when is necessary to cleanup (reset)\n       * terminal settings (kzak -- Jun 2013).\n       */\n      switch (caught_signal) {\n        case SIGTERM:\n          sigaction(SIGTERM, &oldact[0], NULL);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "         acceptable = TRUE;\n      }\n   }\n\n   //Non acceptable sequence number?\n   if(!acceptable)\n   {\n      //Debug message\n      TRACE_WARNING(\"Sequence number is not acceptable!\\r\\n\");\n\n      //If an incoming segment is not acceptable, an acknowledgment\n      //should be sent in reply (unless the RST bit is set)\n      if(!(segment->flags & TCP_FLAG_RST))\n         tcpSendSegment(socket, TCP_FLAG_ACK, socket->sndNxt, socket->rcvNxt, 0, FALSE);\n\n      //Return status code\n      return ERROR_FAILURE;\n   }\n\n   //Sequence number is acceptable\n   return NO_ERROR;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "         acceptable = TRUE;\n      }\n   }\n\n   //Non acceptable sequence number?\n   if(!acceptable)\n   {\n      //Debug message\n      TRACE_WARNING(\"Sequence number is not acceptable!\\r\\n\");\n\n      //If an incoming segment is not acceptable, an acknowledgment should\n      //be sent in reply (unless the RST bit is set)\n      if(!(segment->flags & TCP_FLAG_RST))\n      {\n         tcpSendSegment(socket, TCP_FLAG_ACK, socket->sndNxt, socket->rcvNxt,\n            0, FALSE);\n      }\n\n      //Return status code\n      return ERROR_FAILURE;\n   }\n\n   //Sequence number is acceptable\n   return NO_ERROR;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,\n                                   OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n    OPJ_UINT32 x, y;\n    OPJ_UINT8 *pix;\n    const OPJ_UINT8 *beyond;\n\n    beyond = pData + stride * height;\n    pix = pData;\n\n    x = y = 0U;\n    while (y < height) {\n        int c = getc(IN);\n        if (c == EOF) {\n            return OPJ_FALSE;\n        }\n\n        if (c) {\n            int j, c1_int;\n            OPJ_UINT8 c1;\n\n            c1_int = getc(IN);\n            if (c1_int == EOF) {\n                return OPJ_FALSE;\n            }\n            c1 = (OPJ_UINT8)c1_int;\n\n            for (j = 0; (j < c) && (x < width) &&\n                    ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                *pix = c1;\n            }\n        } else {\n            c = getc(IN);\n            if (c == EOF) {\n                return OPJ_FALSE;\n            }\n\n            if (c == 0x00) { /* EOL */\n                x = 0;\n                ++y;\n                int j;\n                for (j = 0; (j < c) && (x < width) &&\n                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                    int c1_int;\n                    OPJ_UINT8 c1;\n                    c1_int = getc(IN);\n                    if (c1_int == EOF) {\n                        return OPJ_FALSE;\n                    }\n                    c1 = (OPJ_UINT8)c1_int;\n                    *pix = c1;\n                }\n                if ((OPJ_UINT32)c & 1U) { /* skip padding byte */\n                    c = getc(IN);\n                    if (c == EOF) {\n                        return OPJ_FALSE;\n                    }\n                }\n            }\n        }\n    }/* while() */\n    return OPJ_TRUE;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,\n                                   OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n    OPJ_UINT32 x, y, written;\n    OPJ_UINT8 *pix;\n    const OPJ_UINT8 *beyond;\n\n    beyond = pData + stride * height;\n    pix = pData;\n\n    x = y = written = 0U;\n    while (y < height) {\n        int c = getc(IN);\n        if (c == EOF) {\n            return OPJ_FALSE;\n        }\n\n        if (c) {\n            int j, c1_int;\n            OPJ_UINT8 c1;\n\n            c1_int = getc(IN);\n            if (c1_int == EOF) {\n                return OPJ_FALSE;\n            }\n            c1 = (OPJ_UINT8)c1_int;\n\n            for (j = 0; (j < c) && (x < width) &&\n                    ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                *pix = c1;\n                written++;\n            }\n        } else {\n            c = getc(IN);\n            if (c == EOF) {\n                return OPJ_FALSE;\n            }\n\n            if (c == 0x00) { /* EOL */\n                x = 0;\n                ++y;\n                for (j = 0; (j < c) && (x < width) &&\n                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                    int c1_int;\n                    OPJ_UINT8 c1;\n                    c1_int = getc(IN);\n                    if (c1_int == EOF) {\n                        return OPJ_FALSE;\n                    }\n                    c1 = (OPJ_UINT8)c1_int;\n                    *pix = c1;\n                    written++;\n                }\n                if ((OPJ_UINT32)c & 1U) { /* skip padding byte */\n                    c = getc(IN);\n                    if (c == EOF) {\n                        return OPJ_FALSE;\n                    }\n                }\n            }\n        }\n    }/* while() */\n\n    if (written != width * height) {\n        fprintf(stderr, \"warning, image's actual size does not match advertized one\\n\");\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tbi->vdpi = pict_read_fixed(f, pos+12);\n\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);\n\n\tbi->pixeltype = dbuf_getu16be(f, pos+16);\n\tbi->pixelsize = dbuf_getu16be(f, pos+18);\n\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\n\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\n\tplane_bytes = dbuf_getu32be(f, pos+24);\n\tde_dbg(c, \"plane bytes: %d\", (int)plane_bytes);\n\n\tbi->pmTable = (u32)dbuf_getu32be(f, pos+28);\n\tde_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tbi->vdpi = pict_read_fixed(f, pos+12);\n\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);\n\n\tbi->pixeltype = dbuf_getu16be(f, pos+16);\n\tbi->pixelsize = dbuf_getu16be(f, pos+18);\n\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\n\tif(bi->pixelsize>0) {\n\t\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n\t}\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\n\tplane_bytes = dbuf_getu32be(f, pos+24);\n\tde_dbg(c, \"plane bytes: %d\", (int)plane_bytes);\n\n\tbi->pmTable = (u32)dbuf_getu32be(f, pos+28);\n\tde_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        tok->u.code = (OnigCodePoint )num;\n      }\n      break;\n\n    case '0':\n    case '1': case '2': case '3': case '4': case '5': case '6': case '7':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n        PUNFETCH;\n        prev = p;\n        num = scan_unsigned_octal_number(&p, end, 3, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 8;\n        tok->u.c  = num;\n      }\n      break;\n\n    default:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        tok->u.code = (OnigCodePoint )num;\n      }\n      break;\n\n    case '0':\n    case '1': case '2': case '3': case '4': case '5': case '6': case '7':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n        PUNFETCH;\n        prev = p;\n        num = scan_unsigned_octal_number(&p, end, 3, enc);\n        if (num < 0 || num >= 256) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 8;\n        tok->u.c  = num;\n      }\n      break;\n\n    default:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ast_for_async_funcdef(struct compiling *c, const node *n, asdl_seq *decorator_seq)\n{\n    /* async_funcdef: ASYNC funcdef */\n    REQ(n, async_funcdef);\n    REQ(CHILD(n, 0), ASYNC);\n    REQ(CHILD(n, 1), funcdef);\n\n    return ast_for_funcdef_impl(c, CHILD(n, 1), decorator_seq,\n                                1 /* is_async */);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ast_for_async_funcdef(struct compiling *c, const node *n, asdl_seq *decorator_seq)\n{\n    /* async_funcdef: 'async' funcdef */\n    REQ(n, async_funcdef);\n    REQ(CHILD(n, 0), NAME);\n    assert(strcmp(STR(CHILD(n, 0)), \"async\") == 0);\n    REQ(CHILD(n, 1), funcdef);\n\n    return ast_for_funcdef_impl(c, n, decorator_seq,\n                                true /* is_async */);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    if (position == output_name_to_position.end()) {\n      return InvalidArgument(\n          \"Can't import function, returned value references unknown output \"\n          \"argument \",\n          ret_val.first);\n    }\n    if (ret_val.second.empty()) {\n      return InvalidArgument(\"Function '\", func.signature().name(),\n                             \"' has empty result name\");\n    }\n    ret_vals[position->second] =\n        value_manager.GetValueOrCreatePlaceholder(ret_val.second);\n  }\n  for (const auto& ret_val : func.control_ret()) {\n    auto position = control_output_to_position.find(ret_val.first);\n    if (position == control_output_to_position.end()) {\n      return InvalidArgument(\n          \"Can't import function, returned value references unknown output \"\n          \"argument \",\n          ret_val.first);\n    }\n    if (ret_val.second.empty()) {\n      return InvalidArgument(\"Function '\", func.signature().name(),\n                             \"' has empty control result name\");\n    }\n    Value result = value_manager.GetValueOrCreatePlaceholder(\n        (Twine(\"^\") + ret_val.second).str());\n    if (!result.getType().isa<ControlType>())\n      return InvalidArgument(\"failed to map returned value \", ret_val.second,\n                             \", isn't a control output\");\n    ret_vals[func.ret_size() + position->second] = result;\n  }\n  // Check that all the of the return operands have been populated.\n  for (auto& indexed_val : llvm::enumerate(ret_vals)) {\n    if (indexed_val.value()) continue;\n    return InvalidArgument(\n        \"Failed to import function, missing output for position \",",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    if (position == output_name_to_position.end()) {\n      return InvalidArgument(\n          \"Can't import function, returned value references unknown output \"\n          \"argument \",\n          ret_val.first);\n    }\n    if (ret_val.second.empty()) {\n      return InvalidArgument(\"Function '\", func.signature().name(),\n                             \"' has empty result name\");\n    }\n    TF_ASSIGN_OR_RETURN(\n        ret_vals[position->second],\n        value_manager.GetValueOrCreatePlaceholder(ret_val.second));\n  }\n  for (const auto& ret_val : func.control_ret()) {\n    auto position = control_output_to_position.find(ret_val.first);\n    if (position == control_output_to_position.end()) {\n      return InvalidArgument(\n          \"Can't import function, returned value references unknown output \"\n          \"argument \",\n          ret_val.first);\n    }\n    if (ret_val.second.empty()) {\n      return InvalidArgument(\"Function '\", func.signature().name(),\n                             \"' has empty control result name\");\n    }\n    TF_ASSIGN_OR_RETURN(Value result, value_manager.GetValueOrCreatePlaceholder(\n                                          (Twine(\"^\") + ret_val.second).str()));\n    if (!result.getType().isa<ControlType>())\n      return InvalidArgument(\"failed to map returned value \", ret_val.second,\n                             \", isn't a control output\");\n    ret_vals[func.ret_size() + position->second] = result;\n  }\n  // Check that all the of the return operands have been populated.\n  for (auto& indexed_val : llvm::enumerate(ret_vals)) {\n    if (indexed_val.value()) continue;\n    return InvalidArgument(\n        \"Failed to import function, missing output for position \",",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteStatus GenericPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (!is_supported_type(input->type)) {\n    TF_LITE_UNSUPPORTED_TYPE(context, input->type, op_name);\n  }\n  return context->ResizeTensor(context, output,\n                               TfLiteIntArrayCopy(input->dims));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteStatus GenericPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (!is_supported_type(input->type)) {\n    TF_LITE_UNSUPPORTED_TYPE(context, input->type, op_name);\n  }\n  return context->ResizeTensor(context, output,\n                               TfLiteIntArrayCopy(input->dims));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\ttrace_xfs_attr_sf_addname(args);\n\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tASSERT(retval == 0);\n\t}\n\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\ttrace_xfs_attr_sf_addname(args);\n\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\t/*\n\t\t * Since we have removed the old attr, clear ATTR_REPLACE so\n\t\t * that the leaf format add routine won't trip over the attr\n\t\t * not being around.\n\t\t */\n\t\targs->flags &= ~ATTR_REPLACE;\n\t}\n\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                        print_unknown_data(ndo, tptr, \"\\n\\t      \", tlen);\n                    }\n                }\n                break;\n        }\n\tcase BGPTYPE_AIGP:\n\t{\n\t\tuint8_t type;\n\t\tuint16_t length;\n\n\t\tND_TCHECK2(tptr[0], 3);\n\n\t\ttlen = len;\n\n\t\twhile (tlen >= 3) {\n\n\t\t    type = *tptr;\n\t\t    length = EXTRACT_16BITS(tptr+1);\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s TLV (%u), length %u\",\n\t\t\t      tok2str(bgp_aigp_values, \"Unknown\", type),\n\t\t\t      type, length));\n\n\t\t    /*\n\t\t     * Check if we can read the TLV data.\n\t\t     */\n\t\t    ND_TCHECK2(tptr[3], length - 3);\n\n\t\t    switch (type) {\n\n\t\t    case BGP_AIGP_TLV:\n\t\t        ND_TCHECK2(tptr[3], 8);\n\t\t\tND_PRINT((ndo, \", metric %\" PRIu64,\n\t\t\t\t  EXTRACT_64BITS(tptr+3)));\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\t    print_unknown_data(ndo, tptr+3,\"\\n\\t      \", length-3);\n\t\t\t}\n\t\t    }\n\n\t\t    tptr += length;\n\t\t    tlen -= length;\n\t\t}\n\t\tbreak;\n\t}\n        case BGPTYPE_ATTR_SET:\n                ND_TCHECK2(tptr[0], 4);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                    if (ndo->ndo_vflag <= 1) {\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", tlen);\n                    }\n                }\n                break;\n        }\n\tcase BGPTYPE_AIGP:\n\t{\n\t\tuint8_t type;\n\t\tuint16_t length;\n\n\t\ttlen = len;\n\n\t\twhile (tlen >= 3) {\n\n\t\t    ND_TCHECK2(tptr[0], 3);\n\n\t\t    type = *tptr;\n\t\t    length = EXTRACT_16BITS(tptr+1);\n\t\t    tptr += 3;\n\t\t    tlen -= 3;\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s TLV (%u), length %u\",\n\t\t\t      tok2str(bgp_aigp_values, \"Unknown\", type),\n\t\t\t      type, length));\n\n\t\t    if (length < 3)\n\t\t\tgoto trunc;\n\t\t    length -= 3;\n\n\t\t    /*\n\t\t     * Check if we can read the TLV data.\n\t\t     */\n\t\t    ND_TCHECK2(tptr[3], length);\n\n\t\t    switch (type) {\n\n\t\t    case BGP_AIGP_TLV:\n\t\t        if (length < 8)\n\t\t            goto trunc;\n\t\t\tND_PRINT((ndo, \", metric %\" PRIu64,\n\t\t\t\t  EXTRACT_64BITS(tptr)));\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\t    print_unknown_data(ndo, tptr,\"\\n\\t      \", length);\n\t\t\t}\n\t\t    }\n\n\t\t    tptr += length;\n\t\t    tlen -= length;\n\t\t}\n\t\tbreak;\n\t}\n        case BGPTYPE_ATTR_SET:\n                ND_TCHECK2(tptr[0], 4);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "create_principal3_2_svc(cprinc3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n                                            arg->passwd);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_create_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "create_principal3_2_svc(cprinc3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_create_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t     xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret, *dst;\n    const xmlChar *src;\n    xmlAttributePtr attrDecl = NULL;\n    int extsubset = 0;\n\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n    }\n\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    src = value;\n    dst = ret;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n    if ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) {\n\txmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,\n\"standalone: %s on %s value had to be normalized based on external subset declaration\\n\",\n\t       name, elem->name, NULL);\n\tctxt->valid = 0;\n    }\n    return(ret);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t     xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret;\n    xmlAttributePtr attrDecl = NULL;\n    int extsubset = 0;\n\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n    }\n\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    xmlValidNormalizeString(ret);\n    if ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) {\n\txmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,\n\"standalone: %s on %s value had to be normalized based on external subset declaration\\n\",\n\t       name, elem->name, NULL);\n\tctxt->valid = 0;\n    }\n    return(ret);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[1024];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = gf_fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\tif (unicode_type<=1) {\n\t\tj=0;\n\t\tlen = (u32) strlen(szLine);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tif (!szLine[i] && !szLine[i+1]) break;\n\t\t\tc = szLine[i+1];\n\t\t\tszLine[i+1] = szLine[i];\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \\0 after a \\n*/\n\tif (unicode_type==3) gf_fgetc(txt_in);\n\treturn sOK;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[2048];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = gf_fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\tif (unicode_type<=1) {\n\t\tj=0;\n\t\tlen = (u32) strlen(szLine);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tif (!szLine[i] && !szLine[i+1]) break;\n\t\t\tc = szLine[i+1];\n\t\t\tszLine[i+1] = szLine[i];\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = (u32) gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \\0 after a \\n*/\n\tif (unicode_type==3) gf_fgetc(txt_in);\n\treturn sOK;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "comics_document_render (EvDocument      *document,\n\t\t\tEvRenderContext *rc)\n{\n\tGdkPixbuf       *pixbuf;\n\tcairo_surface_t *surface;\n\n\tpixbuf = comics_document_render_pixbuf (document, rc);\n\tsurface = ev_document_misc_surface_from_pixbuf (pixbuf);\n\tg_object_unref (pixbuf);\n\t\n\treturn surface;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "comics_document_render (EvDocument      *document,\n\t\t\tEvRenderContext *rc)\n{\n\tGdkPixbuf       *pixbuf;\n\tcairo_surface_t *surface;\n\n\tpixbuf = comics_document_render_pixbuf (document, rc);\n\tif (!pixbuf)\n\t\treturn NULL;\n\tsurface = ev_document_misc_surface_from_pixbuf (pixbuf);\n\tg_clear_object (&pixbuf);\n\n\treturn surface;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "FunctionDef(identifier name, arguments_ty args, asdl_seq * body, asdl_seq *\n            decorator_list, expr_ty returns, int lineno, int col_offset, int\n            end_lineno, int end_col_offset, PyArena *arena)\n{\n    stmt_ty p;\n    if (!name) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field name is required for FunctionDef\");\n        return NULL;\n    }\n    if (!args) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field args is required for FunctionDef\");\n        return NULL;\n    }\n    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = FunctionDef_kind;\n    p->v.FunctionDef.name = name;\n    p->v.FunctionDef.args = args;\n    p->v.FunctionDef.body = body;\n    p->v.FunctionDef.decorator_list = decorator_list;\n    p->v.FunctionDef.returns = returns;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "FunctionDef(identifier name, arguments_ty args, asdl_seq * body, asdl_seq *\n            decorator_list, expr_ty returns, string type_comment, int lineno,\n            int col_offset, int end_lineno, int end_col_offset, PyArena *arena)\n{\n    stmt_ty p;\n    if (!name) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field name is required for FunctionDef\");\n        return NULL;\n    }\n    if (!args) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field args is required for FunctionDef\");\n    }\n    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = FunctionDef_kind;\n    p->v.FunctionDef.name = name;\n    p->v.FunctionDef.args = args;\n    p->v.FunctionDef.body = body;\n    p->v.FunctionDef.decorator_list = decorator_list;\n    p->v.FunctionDef.returns = returns;\n    p->v.FunctionDef.type_comment = type_comment;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int mi_repair(MI_CHECK *param, register MI_INFO *info,\n\t      char * name, int rep_quick)\n{\n  int error,got_error;\n  ha_rows start_records,new_header_length;\n  my_off_t del;\n  File new_file;\n  MYISAM_SHARE *share=info->s;\n  char llbuff[22],llbuff2[22];\n  SORT_INFO sort_info;\n  MI_SORT_PARAM sort_param;\n  DBUG_ENTER(\"mi_repair\");\n  got_error=0;\n  /* If invoked by external program that uses thr_lock */\n  if (&share->state.state != info->state)\n    memcpy( &share->state.state, info->state, sizeof(*info->state));\n\nerr:\n  if (!got_error)\n  {\n    /* Replace the actual file with the temporary file */\n    if (new_file >= 0)\n    {\n      mysql_file_close(new_file, MYF(0));\n      info->dfile=new_file= -1;\n      /*\n        On Windows, the old data file cannot be deleted if it is either\n        open, or memory mapped. Closing the file won't remove the memory\n        map implicilty on Windows. We closed the data file, but we keep\n        the MyISAM table open. A memory map will be closed on the final\n        mi_close() only. So we need to unmap explicitly here. After\n        renaming the new file under the hook, we couldn't use the map of\n        the old file any more anyway.\n      */\n      if (info->s->file_map)\n      {\n        (void) my_munmap((char*) info->s->file_map,\n                         (size_t) info->s->mmaped_length);\n        info->s->file_map= NULL;\n      }\n      if (change_to_newfile(share->data_file_name, MI_NAME_DEXT, DATA_TMP_EXT,\n\t\t\t    (param->testflag & T_BACKUP_DATA ?\n\t\t\t     MYF(MY_REDEL_MAKE_BACKUP): MYF(0))) ||\n\t  mi_open_datafile(info,share,name,-1))\n\tgot_error=1;\n\n      param->retry_repair= 0;\n    }\n  }\n  if (got_error)\n  {\n    if (! param->error_printed)\n      mi_check_print_error(param,\"%d for record at pos %s\",my_errno,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int mi_repair(MI_CHECK *param, register MI_INFO *info,\n\t      char * name, int rep_quick, my_bool no_copy_stat)\n{\n  int error,got_error;\n  ha_rows start_records,new_header_length;\n  my_off_t del;\n  File new_file;\n  MYISAM_SHARE *share=info->s;\n  char llbuff[22],llbuff2[22];\n  SORT_INFO sort_info;\n  MI_SORT_PARAM sort_param;\n  DBUG_ENTER(\"mi_repair\");\n  /* If invoked by external program that uses thr_lock */\n  if (&share->state.state != info->state)\n    memcpy( &share->state.state, info->state, sizeof(*info->state));\n\nerr:\n  if (!got_error)\n  {\n    /* Replace the actual file with the temporary file */\n    if (new_file >= 0)\n    {\n      myf flags= 0;\n      if (param->testflag & T_BACKUP_DATA)\n        flags |= MY_REDEL_MAKE_BACKUP;\n      if (no_copy_stat)\n        flags |= MY_REDEL_NO_COPY_STAT;\n      mysql_file_close(new_file, MYF(0));\n      info->dfile=new_file= -1;\n      /*\n        On Windows, the old data file cannot be deleted if it is either\n        open, or memory mapped. Closing the file won't remove the memory\n        map implicilty on Windows. We closed the data file, but we keep\n        the MyISAM table open. A memory map will be closed on the final\n        mi_close() only. So we need to unmap explicitly here. After\n        renaming the new file under the hook, we couldn't use the map of\n        the old file any more anyway.\n      */\n      if (info->s->file_map)\n      {\n        (void) my_munmap((char*) info->s->file_map,\n                         (size_t) info->s->mmaped_length);\n        info->s->file_map= NULL;\n      }\n      if (change_to_newfile(share->data_file_name, MI_NAME_DEXT, DATA_TMP_EXT,\n                            flags) ||\n\t  mi_open_datafile(info,share,name,-1))\n\tgot_error=1;\n\n      param->retry_repair= 0;\n    }\n  }\n  if (got_error)\n  {\n    if (! param->error_printed)\n      mi_check_print_error(param,\"%d for record at pos %s\",my_errno,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static CONSTBUFFER_HANDLE CONSTBUFFER_Create_Internal(const unsigned char* source, size_t size)\n{\n    CONSTBUFFER_HANDLE result;\n    /*Codes_SRS_CONSTBUFFER_02_005: [The non-NULL handle returned by CONSTBUFFER_Create shall have its ref count set to \"1\".]*/\n    /*Codes_SRS_CONSTBUFFER_02_010: [The non-NULL handle returned by CONSTBUFFER_CreateFromBuffer shall have its ref count set to \"1\".]*/\n    result = (CONSTBUFFER_HANDLE)calloc(1, (sizeof(CONSTBUFFER_HANDLE_DATA) + size));\n    if (result == NULL)\n    {\n        /*Codes_SRS_CONSTBUFFER_02_003: [If creating the copy fails then CONSTBUFFER_Create shall return NULL.]*/\n        /*Codes_SRS_CONSTBUFFER_02_008: [If copying the content fails, then CONSTBUFFER_CreateFromBuffer shall fail and return NULL.] */\n        LogError(\"unable to malloc\");\n        /*return as is*/\n    }\n    else\n    {\n        INIT_REF_VAR(result->count);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static CONSTBUFFER_HANDLE CONSTBUFFER_Create_Internal(const unsigned char* source, size_t size)\n{\n    CONSTBUFFER_HANDLE result;\n    /*Codes_SRS_CONSTBUFFER_02_005: [The non-NULL handle returned by CONSTBUFFER_Create shall have its ref count set to \"1\".]*/\n    /*Codes_SRS_CONSTBUFFER_02_010: [The non-NULL handle returned by CONSTBUFFER_CreateFromBuffer shall have its ref count set to \"1\".]*/\n    size_t malloc_size = sizeof(CONSTBUFFER_HANDLE_DATA) + size;\n    if (malloc_size < size)\n    {\n        result = NULL;\n        LogError(\"invalid size parameter\");\n        /*return as is*/\n    }\n    else\n    {\n        result = (CONSTBUFFER_HANDLE)calloc(1, malloc_size);\n    }\n\n    if (result == NULL)\n    {\n        /*Codes_SRS_CONSTBUFFER_02_003: [If creating the copy fails then CONSTBUFFER_Create shall return NULL.]*/\n        /*Codes_SRS_CONSTBUFFER_02_008: [If copying the content fails, then CONSTBUFFER_CreateFromBuffer shall fail and return NULL.] */\n        LogError(\"unable to malloc\");\n        /*return as is*/\n    }\n    else\n    {\n        INIT_REF_VAR(result->count);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "find_entry_internal(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int\t\t\tlock,\n\tback_txn *txn,\n\tint flags\n)\n{\n\t/* check if we should search based on uniqueid or dn */\n\tif (addr->uniqueid!=NULL)\n\t{\n\t\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> find_entry_internal (uniqueid=%s) lock %d\\n\",\n\t\t    addr->uniqueid, lock, 0 );\n\t\treturn (find_entry_internal_uniqueid (pb, be, addr->uniqueid, lock, txn));\n\t}\n\telse\n\t{\n\t\tstruct backentry *entry = NULL;\n\n\t\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> find_entry_internal (dn=%s) lock %d\\n\",\n\t\t           slapi_sdn_get_dn(addr->sdn), lock, 0 );\n\t\tif (addr->sdn) {\n\t\t\tentry = find_entry_internal_dn (pb, be, addr->sdn, \n\t\t\t                                lock, txn, flags);\n\t\t} else {\n\t\t\tLDAPDebug0Args( LDAP_DEBUG_ANY,\n\t\t\t                \"find_entry_internal: Null target dn\\n\" );\n\t\t}\n\n\t\tLDAPDebug0Args( LDAP_DEBUG_TRACE, \"<= find_entry_internal\\n\" );\n\t\treturn entry;\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "find_entry_internal(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int\t\t\tlock,\n    back_txn *txn,\n    int flags,\n    int *rc\n)\n{\n\t/* check if we should search based on uniqueid or dn */\n\tif (addr->uniqueid!=NULL)\n\t{\n\t\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> find_entry_internal (uniqueid=%s) lock %d\\n\",\n\t\t    addr->uniqueid, lock, 0 );\n\t\treturn (find_entry_internal_uniqueid (pb, be, addr->uniqueid, lock, txn));\n\t}\n\telse\n\t{\n\t\tstruct backentry *entry = NULL;\n\n\t\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> find_entry_internal (dn=%s) lock %d\\n\",\n\t\t           slapi_sdn_get_dn(addr->sdn), lock, 0 );\n\t\tif (addr->sdn) {\n\t\t\tentry = find_entry_internal_dn (pb, be, addr->sdn, lock, txn, flags, rc);\n\t\t} else {\n\t\t\tLDAPDebug0Args( LDAP_DEBUG_ANY, \"find_entry_internal: Null target dn\\n\" );\n\t\t}\n\n\t\tLDAPDebug0Args( LDAP_DEBUG_TRACE, \"<= find_entry_internal\\n\" );\n\t\treturn entry;\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\n\tref->ref++;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static bool buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\n\tif (ref->ref > INT_MAX/2)\n\t\treturn false;\n\n\tref->ref++;\n\treturn true;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static char *get_header(FILE *fp)\n{\n    long start;\n\n    /* First 1024 bytes of doc must be header (1.7 spec pg 1102) */\n    char *header;\n\n    header = calloc(1, 1024);\n    \n    start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    \n    return header;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static char *get_header(FILE *fp)\n{\n    /* First 1024 bytes of doc must be header (1.7 spec pg 1102) */\n    char *header = safe_calloc(1024);\n    long start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    return header;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  YYUSE (yyscanner);\n  YYUSE (lex_env);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n          case 16: /* tokens  */\n#line 94 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1023 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 17: /* token_sequence  */\n#line 95 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1029 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 18: /* token_or_range  */\n#line 96 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1035 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 19: /* token  */\n#line 97 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1041 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 21: /* range  */\n#line 100 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1047 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 22: /* alternatives  */\n#line 99 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1053 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 23: /* byte  */\n#line 98 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1059 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n\n      default:\n        break;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  YYUSE (yyscanner);\n  YYUSE (lex_env);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n          case 16: /* tokens  */\n#line 101 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1030 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 17: /* token_sequence  */\n#line 102 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1036 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 18: /* token_or_range  */\n#line 103 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1042 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 19: /* token  */\n#line 104 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1048 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 21: /* range  */\n#line 107 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1054 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 22: /* alternatives  */\n#line 106 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1060 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 23: /* byte  */\n#line 105 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1066 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n\n      default:\n        break;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void imap_quote_string (char *dest, size_t dlen, const char *src)\n{\n  static const char quote[] = \"\\\"\\\\\";\n  char *pt;\n  const char *s;\n\n  pt = dest;\n  s  = src;\n\n  *pt++ = '\"';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr (quote, *s))\n    {\n      dlen -= 2;\n      if (!dlen)\n\tbreak;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void imap_quote_string (char *dest, size_t dlen, const char *src)\n{\n  _imap_quote_string (dest, dlen, src, \"\\\"\\\\\");\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        printf(\"Please check that unicorn.dll/unicorn.so is available as well as\\n\");\n        printf(\"any other dependent dll/so files.\\n\");\n        printf(\"The easiest way is to place them in the same directory as this app.\\n\");\n        return 1;\n    }\n#endif\n    \n    test_arm();\n    printf(\"==========================\\n\");\n    test_thumb();\n\n    // dynamically free shared library\n#ifdef DYNLOAD\n    uc_dyn_free();\n#endif\n    \n    return 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        printf(\"Please check that unicorn.dll/unicorn.so is available as well as\\n\");\n        printf(\"any other dependent dll/so files.\\n\");\n        printf(\"The easiest way is to place them in the same directory as this app.\\n\");\n        return 1;\n    }\n#endif\n    \n    test_arm();\n    printf(\"==========================\\n\");\n    test_thumb();\n    printf(\"==========================\\n\");\n    test_thumb_ite();\n    // dynamically free shared library\n#ifdef DYNLOAD\n    uc_dyn_free();\n#endif\n    \n    return 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "#endif\n\n#ifdef HAVE_SETPGID\n    static_assert(_Py_IS_TYPE_SIGNED(pid_t), \"pid_t is unsigned\");\n    if (pgid_to_set >= 0) {\n        POSIX_CALL(setpgid(0, pgid_to_set));\n    }\n#endif\n\n#ifdef HAVE_SETGROUPS\n    if (extra_group_size > 0)\n        POSIX_CALL(setgroups(extra_group_size, extra_groups));\n#endif /* HAVE_SETGROUPS */\n\n#ifdef HAVE_SETREGID\n    if (gid != (gid_t)-1)\n        POSIX_CALL(setregid(gid, gid));\n#endif /* HAVE_SETREGID */\n\n#ifdef HAVE_SETREUID\n    if (uid != (uid_t)-1)\n        POSIX_CALL(setreuid(uid, uid));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "#endif\n\n#ifdef HAVE_SETPGID\n    static_assert(_Py_IS_TYPE_SIGNED(pid_t), \"pid_t is unsigned\");\n    if (pgid_to_set >= 0) {\n        POSIX_CALL(setpgid(0, pgid_to_set));\n    }\n#endif\n\n#ifdef HAVE_SETGROUPS\n    if (extra_group_size >= 0) {\n        assert((extra_group_size == 0) == (extra_groups == NULL));\n        POSIX_CALL(setgroups(extra_group_size, extra_groups));\n    }\n#endif /* HAVE_SETGROUPS */\n\n#ifdef HAVE_SETREGID\n    if (gid != (gid_t)-1)\n        POSIX_CALL(setregid(gid, gid));\n#endif /* HAVE_SETREGID */\n\n#ifdef HAVE_SETREUID\n    if (uid != (uid_t)-1)\n        POSIX_CALL(setreuid(uid, uid));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                goto fail;\n\n        r = sd_event_source_set_enabled(q->defer_event_source, SD_EVENT_ONESHOT);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_message_rewind(q->request, true);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_enqeue_for_read(sd_bus_message_get_bus(q->request), q->request);\n        if (r < 0)\n                goto fail;\n\n        return 1;\n\nfail:\n        log_debug_errno(r, \"Processing asynchronous PolicyKit reply failed, ignoring: %m\");\n        (void) sd_bus_reply_method_errno(q->request, r, NULL);\n        async_polkit_query_free(q);\n        return r;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                goto fail;\n\n        r = sd_event_source_set_enabled(q->defer_event_source, SD_EVENT_ONESHOT);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_message_rewind(q->request, true);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_enqueue_for_read(sd_bus_message_get_bus(q->request), q->request);\n        if (r < 0)\n                goto fail;\n\n        return 1;\n\nfail:\n        log_debug_errno(r, \"Processing asynchronous PolicyKit reply failed, ignoring: %m\");\n        (void) sd_bus_reply_method_errno(q->request, r, NULL);\n        async_polkit_query_free(q);\n        return r;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t * For example, writing debug data to a port which you\n\t * have just faulted on is not going to work.\n\t */\n\n\ttsk = current;\n\tmm = tsk->mm;\n\n\t/* Not an IO address, so reenable interrupts */\n\tlocal_irq_enable();\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n\n\t/*\n\t * If we're in an interrupt or have no user\n\t * context, we must not take the fault..\n\t */\n\tif (in_atomic() || !mm)\n\t\tgoto no_context;\n\n\t/* TLB misses upon some cache flushes get done under cli() */\n\tdown_read(&mm->mmap_sem);\n\tif (unlikely(fault & VM_FAULT_ERROR)) {\n\t\tif (fault & VM_FAULT_OOM)\n\t\t\tgoto out_of_memory;\n\t\telse if (fault & VM_FAULT_SIGBUS)\n\t\t\tgoto do_sigbus;\n\t\tBUG();\n\t}\n\n\tif (fault & VM_FAULT_MAJOR) {\n\t\ttsk->maj_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n\t\t\t\t     regs, address);\n\t} else {\n\t\ttsk->min_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n\t\t\t\t     regs, address);\n\t}\n\n\t/* If we get here, the page fault has been handled.  Do the TLB refill\n\t   now from the newly-setup PTE, to avoid having to fault again right\n\t   away on the same instruction. */\n\tpte = lookup_pte (mm, address);\n\tif (!pte) {\n\t\t/* From empirical evidence, we can get here, due to\n\t\t   !pte_present(pte).  (e.g. if a swap-in occurs, and the page",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t * For example, writing debug data to a port which you\n\t * have just faulted on is not going to work.\n\t */\n\n\ttsk = current;\n\tmm = tsk->mm;\n\n\t/* Not an IO address, so reenable interrupts */\n\tlocal_irq_enable();\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n\n\t/*\n\t * If we're in an interrupt or have no user\n\t * context, we must not take the fault..\n\t */\n\tif (in_atomic() || !mm)\n\t\tgoto no_context;\n\n\t/* TLB misses upon some cache flushes get done under cli() */\n\tdown_read(&mm->mmap_sem);\n\tif (unlikely(fault & VM_FAULT_ERROR)) {\n\t\tif (fault & VM_FAULT_OOM)\n\t\t\tgoto out_of_memory;\n\t\telse if (fault & VM_FAULT_SIGBUS)\n\t\t\tgoto do_sigbus;\n\t\tBUG();\n\t}\n\n\tif (fault & VM_FAULT_MAJOR) {\n\t\ttsk->maj_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,\n\t\t\t\t     regs, address);\n\t} else {\n\t\ttsk->min_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,\n\t\t\t\t     regs, address);\n\t}\n\n\t/* If we get here, the page fault has been handled.  Do the TLB refill\n\t   now from the newly-setup PTE, to avoid having to fault again right\n\t   away on the same instruction. */\n\tpte = lookup_pte (mm, address);\n\tif (!pte) {\n\t\t/* From empirical evidence, we can get here, due to\n\t\t   !pte_present(pte).  (e.g. if a swap-in occurs, and the page",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPOFFSETS))\n\t\t\t{\n\t\t\t\tif (!isTiled(tif))\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_COLORMAP))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagColormap(tif,&ndir,dir))",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPOFFSETS))\n\t\t\t{\n\t\t\t\tif (!isTiled(tif))\n\t\t\t\t{\n                    /* td_stripoffset might be NULL in an odd OJPEG case. See\n                     *  tif_dirread.c around line 3634.\n                     * XXX: OJPEG hack.\n                     * If a) compression is OJPEG, b) it's not a tiled TIFF,\n                     * and c) the number of strips is 1,\n                     * then we tolerate the absence of stripoffsets tag,\n                     * because, presumably, all required data is in the\n                     * JpegInterchangeFormat stream.\n                     * We can get here when using tiffset on such a file.\n                     * See http://bugzilla.maptools.org/show_bug.cgi?id=2500\n                    */\n                    if (tif->tif_dir.td_stripoffset != NULL &&\n                        !TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\n                        goto bad;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_COLORMAP))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagColormap(tif,&ndir,dir))",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\n\t// Mark the box data as never having been constructed\n\t// so that we will not errantly attempt to destroy it later.\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jp2_box_create0())) {\n\t\tgoto error;\n\t}\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: \"\n\t  \"type=%c%s%c (0x%08x); length=%\"PRIuFAST32\"\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tJAS_DBGLOG(10, (\"big length\\n\"));\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (!target_class || target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st[2] = {NULL, NULL};\n    NSVStream *nst;\n    AVPacket *pkt;\n    int i, err = 0;\n    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */\n    uint32_t vsize;\n    uint16_t asize;\n    uint16_t auxsize;\n\n    if (nsv->ahead[0].data || nsv->ahead[1].data)\n        return 0; //-1; /* hey! eat what you've in your plate first! */\n\nnull_chunk_retry:\n    if (pb->eof_reached)\n        return -1;\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)\n        err = nsv_resync(s);\n\n    /* map back streams to v,a */\n    if (s->nb_streams > 0)\n        st[s->streams[0]->id] = s->streams[0];\n    if (s->nb_streams > 1)\n        st[s->streams[1]->id] = s->streams[1];\n\n    if (vsize && st[NSV_ST_VIDEO]) {\n        nst = st[NSV_ST_VIDEO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_VIDEO];\n        av_get_packet(pb, pkt, vsize);\n        pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;\n        pkt->dts = nst->frame_offset;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        for (i = 0; i < FFMIN(8, vsize); i++)\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02\"PRIx8\"\\n\",\n                   i, pkt->data[i]);\n    }\n    if(st[NSV_ST_VIDEO])\n        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;\n\n                if (bps == 8)\n                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n                samplerate /= 4;/* UGH ??? XXX */\n                channels = 1;\n                st[NSV_ST_AUDIO]->codecpar->channels = channels;\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                       bps, channels, samplerate);\n            }\n        }\n        av_get_packet(pb, pkt, asize);\n        pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n            /* on a nsvs frame we have new information on a/v sync */\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);\n            pkt->dts *= (int64_t)1000        * nsv->framerate.den;\n            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;\n            av_log(s, AV_LOG_TRACE, \"NSV AUDIO: sync:%\"PRId16\", dts:%\"PRId64,\n                   nsv->avsync, pkt->dts);\n        }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st[2] = {NULL, NULL};\n    NSVStream *nst;\n    AVPacket *pkt;\n    int i, err = 0;\n    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */\n    uint32_t vsize;\n    uint16_t asize;\n    uint16_t auxsize;\n    int ret;\n\n    if (nsv->ahead[0].data || nsv->ahead[1].data)\n        return 0; //-1; /* hey! eat what you've in your plate first! */\n\nnull_chunk_retry:\n    if (pb->eof_reached)\n        return -1;\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)\n        err = nsv_resync(s);\n\n    /* map back streams to v,a */\n    if (s->nb_streams > 0)\n        st[s->streams[0]->id] = s->streams[0];\n    if (s->nb_streams > 1)\n        st[s->streams[1]->id] = s->streams[1];\n\n    if (vsize && st[NSV_ST_VIDEO]) {\n        nst = st[NSV_ST_VIDEO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_VIDEO];\n        if ((ret = av_get_packet(pb, pkt, vsize)) < 0)\n            return ret;\n        pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;\n        pkt->dts = nst->frame_offset;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        for (i = 0; i < FFMIN(8, vsize); i++)\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02\"PRIx8\"\\n\",\n                   i, pkt->data[i]);\n    }\n    if(st[NSV_ST_VIDEO])\n        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;\n\n                if (bps == 8)\n                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n                samplerate /= 4;/* UGH ??? XXX */\n                channels = 1;\n                st[NSV_ST_AUDIO]->codecpar->channels = channels;\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                       bps, channels, samplerate);\n            }\n        }\n        if ((ret = av_get_packet(pb, pkt, asize)) < 0)\n            return ret;\n        pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n            /* on a nsvs frame we have new information on a/v sync */\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);\n            pkt->dts *= (int64_t)1000        * nsv->framerate.den;\n            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;\n            av_log(s, AV_LOG_TRACE, \"NSV AUDIO: sync:%\"PRId16\", dts:%\"PRId64,\n                   nsv->avsync, pkt->dts);\n        }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    State(IfOp* kernel, OpKernelContext* ctx, bool cond, FHandle then_handle,\n          FHandle else_handle, DoneCallback done)\n        : kernel_(kernel),\n          ctx_(ctx),\n          cond_(cond),\n          then_handle_(then_handle),\n          else_handle_(else_handle),\n          done_(std::move(done)),\n          lib_(CHECK_NOTNULL(ctx_->function_library())) {\n      SetRunOptions(ctx_, &opts_, true /* always_collect_stats */);\n      for (int i = 1; i < ctx_->num_inputs(); ++i) {\n        args_.push_back(ctx_->input(i));\n      }\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    State(IfOp* kernel, OpKernelContext* ctx, bool cond, FHandle then_handle,\n          FHandle else_handle, DoneCallback done)\n        : kernel_(kernel),\n          ctx_(ctx),\n          cond_(cond),\n          then_handle_(then_handle),\n          else_handle_(else_handle),\n          done_(std::move(done)),\n          lib_(CHECK_NOTNULL(ctx_->function_library())),\n          opts_(ctx->step_id()) {\n      SetRunOptions(ctx_, &opts_, true /* always_collect_stats */);\n      for (int i = 1; i < ctx_->num_inputs(); ++i) {\n        args_.push_back(ctx_->input(i));\n      }\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\telse\n\t{\n\t  _pdfioFileError(tb->pdf, \"Syntax error: '>%c'.\", ch);\n\t  return (false);\n\t}\n\tbreak;\n  }\n\n  *bufptr = '\\0';\n\n  PDFIO_DEBUG(\"_pdfioTokenRead: Read '%s'.\\n\", buffer);\n\n  return (bufptr > buffer);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\telse\n\t{\n\t  _pdfioFileError(tb->pdf, \"Syntax error: '>%c'.\", ch);\n\t  return (false);\n\t}\n\tbreak;\n  }\n\n  *bufptr = '\\0';\n\n//  PDFIO_DEBUG(\"_pdfioTokenRead: Read '%s'.\\n\", buffer);\n\n  return (bufptr > buffer);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int simulate_llsc(struct pt_regs *regs, unsigned int opcode)\n{\n\tif ((opcode & OPCODE) == LL) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, 0, regs, 0);\n\t\treturn simulate_ll(regs, opcode);\n\t}\n\tif ((opcode & OPCODE) == SC) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, 0, regs, 0);\n\t\treturn simulate_sc(regs, opcode);\n\t}\n\n\treturn -1;\t\t\t/* Must be something else ... */\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int simulate_llsc(struct pt_regs *regs, unsigned int opcode)\n{\n\tif ((opcode & OPCODE) == LL) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, regs, 0);\n\t\treturn simulate_ll(regs, opcode);\n\t}\n\tif ((opcode & OPCODE) == SC) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, regs, 0);\n\t\treturn simulate_sc(regs, opcode);\n\t}\n\n\treturn -1;\t\t\t/* Must be something else ... */\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      JpegInput( String filename ) : filename_( std::move( filename )) {\n         infile_ = std::fopen( filename_.c_str(), \"rb\" );\n         if( infile_ == nullptr ) {\n            if( !FileHasExtension( filename_ )) {\n               filename_ = FileAddExtension( filename_, \"jpg\" ); // Try with \"jpg\" extension\n               infile_ = std::fopen( filename_.c_str(), \"rb\" );\n               if( infile_ == nullptr ) {\n                  filename_ = FileAddExtension( filename_, \"jpeg\" ); // Try with \"jpeg\" extension\n                  infile_ = std::fopen( filename_.c_str(), \"rb\" );\n               }\n            }\n         }\n         if( infile_ == nullptr ) {\n            DIP_THROW_RUNTIME( \"Could not open the specified JPEG file\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         if( setjmp( jerr_.setjmp_buffer )) {\n            // If we get here, the JPEG code has signaled an error.\n            DIP_THROW_RUNTIME( \"Error reading JPEG file.\" );\n         }\n         jpeg_create_decompress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_src( &cinfo_, infile_ );\n         jpeg_read_header( &cinfo_, TRUE );\n      }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      JpegInput( String filename, std::jmp_buf const& setjmp_buffer ) : filename_( std::move( filename )) {\n         infile_ = std::fopen( filename_.c_str(), \"rb\" );\n         if( infile_ == nullptr ) {\n            if( !FileHasExtension( filename_ )) {\n               filename_ = FileAddExtension( filename_, \"jpg\" ); // Try with \"jpg\" extension\n               infile_ = std::fopen( filename_.c_str(), \"rb\" );\n               if( infile_ == nullptr ) {\n                  filename_ = FileAddExtension( filename_, \"jpeg\" ); // Try with \"jpeg\" extension\n                  infile_ = std::fopen( filename_.c_str(), \"rb\" );\n               }\n            }\n         }\n         if( infile_ == nullptr ) {\n            DIP_THROW_RUNTIME( \"Could not open the specified JPEG file\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         std::memcpy( jerr_.setjmp_buffer, setjmp_buffer, sizeof( setjmp_buffer ));\n         jpeg_create_decompress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_src( &cinfo_, infile_ );\n         jpeg_read_header( &cinfo_, TRUE );\n      }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps; ++pi->compno,\n\t  ++pi->picomp) {\n\t\tpirlvl = pi->picomp->pirlvls;\n\t\tpi->xstep = pi->picomp->hsamp * (1 << (pirlvl->prcwidthexpn +\n\t\t  pi->picomp->numrlvls - 1));\n\t\tpi->ystep = pi->picomp->vsamp * (1 << (pirlvl->prcheightexpn +\n\t\t  pi->picomp->numrlvls - 1));\n\t\tfor (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];\n\t\t  rlvlno < pi->picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp * (1 <<\n\t\t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls -\n\t\t\t  rlvlno - 1)));\n\t\t\tpi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp * (1 <<\n\t\t\t  (pirlvl->prcheightexpn + pi->picomp->numrlvls -\n\t\t\t  rlvlno - 1)));\n\t\t}\n\t\tfor (pi->y = pi->ystart; pi->y < pi->yend;\n\t\t  pi->y += pi->ystep - (pi->y % pi->ystep)) {\n\t\t\tfor (pi->x = pi->xstart; pi->x < pi->xend;\n\t\t\t  pi->x += pi->xstep - (pi->x % pi->xstep)) {\n\t\t\t\tfor (pi->rlvlno = pchg->rlvlnostart,\n\t\t\t\t  pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\t  pi->rlvlno < pi->picomp->numrlvls && pi->rlvlno <\n\t\t\t\t  pchg->rlvlnoend; ++pi->rlvlno, ++pi->pirlvl) {\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps; ++pi->compno,\n\t  ++pi->picomp) {\n\t\tpirlvl = pi->picomp->pirlvls;\n\t\tpi->xstep = pi->picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls - 1));\n\t\tpi->ystep = pi->picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcheightexpn + pi->picomp->numrlvls - 1));\n\t\tfor (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];\n\t\t  rlvlno < pi->picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp *\n\t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcwidthexpn +\n\t\t\t  pi->picomp->numrlvls - rlvlno - 1)));\n\t\t\tpi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp *\n\t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcheightexpn +\n\t\t\t  pi->picomp->numrlvls - rlvlno - 1)));\n\t\t}\n\t\tfor (pi->y = pi->ystart; pi->y < pi->yend;\n\t\t  pi->y += pi->ystep - (pi->y % pi->ystep)) {\n\t\t\tfor (pi->x = pi->xstart; pi->x < pi->xend;\n\t\t\t  pi->x += pi->xstep - (pi->x % pi->xstep)) {\n\t\t\t\tfor (pi->rlvlno = pchg->rlvlnostart,\n\t\t\t\t  pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\t  pi->rlvlno < pi->picomp->numrlvls && pi->rlvlno <\n\t\t\t\t  pchg->rlvlnoend; ++pi->rlvlno, ++pi->pirlvl) {\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\n\tunsigned char* cp = (unsigned char*) cp0;\n\tassert((cc%stride)==0);\n\tif (cc > stride) {\n\t\t/*\n\t\t * Pipeline the most common cases.\n\t\t */\n\t\tif (stride == 3)  {\n\t\t\tunsigned int cr = cp[0];\n\t\t\tunsigned int cg = cp[1];\n\t\t\tunsigned int cb = cp[2];\n\t\t\tcc -= 3;\n\t\t\tcp += 3;\n\t\t\t\tcp += 4;\n\t\t\t}\n\t\t} else  {\n\t\t\tcc -= stride;\n\t\t\tdo {\n\t\t\t\tREPEAT4(stride, cp[stride] =\n\t\t\t\t\t(unsigned char) ((cp[stride] + *cp) & 0xff); cp++)\n\t\t\t\tcc -= stride;\n\t\t\t} while (cc>0);\n\t\t}\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\n\tunsigned char* cp = (unsigned char*) cp0;\n    if((cc%stride)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"horAcc8\",\n                     \"%s\", \"(cc%stride)!=0\");\n        return 0;\n    }\n\n\tif (cc > stride) {\n\t\t/*\n\t\t * Pipeline the most common cases.\n\t\t */\n\t\tif (stride == 3)  {\n\t\t\tunsigned int cr = cp[0];\n\t\t\tunsigned int cg = cp[1];\n\t\t\tunsigned int cb = cp[2];\n\t\t\tcc -= 3;\n\t\t\tcp += 3;\n\t\t\t}\n\t\t} else  {\n\t\t\tcc -= stride;\n\t\t\tdo {\n\t\t\t\tREPEAT4(stride, cp[stride] =\n\t\t\t\t\t(unsigned char) ((cp[stride] + *cp) & 0xff); cp++)\n\t\t\t\tcc -= stride;\n\t\t\t} while (cc>0);\n\t\t}\n\t}\n\treturn 1;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\t\t      needed | smc->opt_payloads |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_VID) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_N) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_D) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_CR) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_CERT))) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"%smessage ignored because it contains a payload type (%s) unexpected by state %s\",\n\t\t\t\t\t\texcuse,\n\t\t\t\t\t\tenum_show(&ikev1_payload_names, np),\n\t\t\t\t\t\tst->st_state->name);\n\t\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\t\tSEND_NOTIFICATION(INVALID_PAYLOAD_TYPE);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tDBG(DBG_PARSING,\n\t\t\t\t    DBG_log(\"got payload 0x%\" PRIxLSET\"  (%s) needed: 0x%\" PRIxLSET \" opt: 0x%\" PRIxLSET,\n\t\t\t\t\t    s, enum_show(&ikev1_payload_names, np),\n\t\t\t\t\t    needed, smc->opt_payloads));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\t\t      needed | smc->opt_payloads |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_VID) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_N) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_D) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_CR) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_CERT))) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"%smessage ignored because it contains a payload type (%s) unexpected by state %s\",\n\t\t\t\t\t\texcuse,\n\t\t\t\t\t\tenum_show(&ikev1_payload_names, np),\n\t\t\t\t\t\tfinite_states[smc->state]->name);\n\t\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\t\tSEND_NOTIFICATION(INVALID_PAYLOAD_TYPE);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tDBG(DBG_PARSING,\n\t\t\t\t    DBG_log(\"got payload 0x%\" PRIxLSET\"  (%s) needed: 0x%\" PRIxLSET \" opt: 0x%\" PRIxLSET,\n\t\t\t\t\t    s, enum_show(&ikev1_payload_names, np),\n\t\t\t\t\t    needed, smc->opt_payloads));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, NULL, LINENO(ch), ch->n_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; /* the name */\n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n                break;\n            case TYPE_COMMENT:\n                /* arg will be equal to the last argument processed */\n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                i += 1;\n                break;\n            case DOUBLESTAR:\n                return i;\n            default:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, NULL, LINENO(ch), ch->n_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; /* the name */\n                if (TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n                break;\n            case TYPE_COMMENT:\n                /* arg will be equal to the last argument processed */\n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                i += 1;\n                break;\n            case DOUBLESTAR:\n                return i;\n            default:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  g_auto(GStrv) sandbox_expose = NULL;\n  g_auto(GStrv) sandbox_expose_ro = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd_ro = NULL;\n  g_autoptr(GOutputStream) instance_id_out_stream = NULL;\n  guint sandbox_flags = 0;\n  gboolean sandboxed;\n  gboolean expose_pids;\n  gboolean share_pids;\n  gboolean notify_start;\n  gboolean devel;\n\n  child_setup_data.instance_id_fd = -1;\n\n  if (fd_list != NULL)\n    fds = g_unix_fd_list_peek_fds (fd_list, &fds_len);\n\n  app_info = g_object_get_data (G_OBJECT (invocation), \"app-info\");\n  g_assert (app_info != NULL);\n\n  app_id = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_APPLICATION,\n                                  FLATPAK_METADATA_KEY_NAME, NULL);\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--device=dri\"));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--session-bus\"));\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--a11y-bus\"));\n    }\n  else\n    {\n      for (i = 0; extra_args != NULL && extra_args[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));\n    }\n\n  expose_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0;\n  share_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS) != 0;\n\n  if (expose_pids || share_pids)\n    {\n      g_autofree char *instance_id = NULL;\n      int sender_pid1 = 0;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  g_auto(GStrv) sandbox_expose_ro = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd_ro = NULL;\n  g_autoptr(GOutputStream) instance_id_out_stream = NULL;\n  guint sandbox_flags = 0;\n  gboolean sandboxed;\n  gboolean expose_pids;\n  gboolean share_pids;\n  gboolean notify_start;\n  gboolean devel;\n  g_autoptr(GString) env_string = g_string_new (\"\");\n\n  child_setup_data.instance_id_fd = -1;\n  child_setup_data.env_fd = -1;\n\n  if (fd_list != NULL)\n    fds = g_unix_fd_list_peek_fds (fd_list, &fds_len);\n\n  app_info = g_object_get_data (G_OBJECT (invocation), \"app-info\");\n  g_assert (app_info != NULL);\n\n  app_id = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_APPLICATION,\n                                  FLATPAK_METADATA_KEY_NAME, NULL);\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--device=dri\"));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--session-bus\"));\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--a11y-bus\"));\n    }\n  else\n    {\n      for (i = 0; extra_args != NULL && extra_args[i] != NULL; i++)\n        {\n          if (g_str_has_prefix (extra_args[i], \"--env=\"))\n            {\n              const char *var_val = extra_args[i] + strlen (\"--env=\");\n\n              if (var_val[0] == '\\0' || var_val[0] == '=')\n                {\n                  g_warning (\"Environment variable in extra-args has empty name\");\n                  continue;\n                }\n\n              if (strchr (var_val, '=') == NULL)\n                {\n                  g_warning (\"Environment variable in extra-args has no value\");\n                  continue;\n                }\n\n              g_string_append (env_string, var_val);\n              g_string_append_c (env_string, '\\0');\n            }\n          else\n            {\n              g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));\n            }\n        }\n    }\n\n  if (env_string->len > 0)\n    {\n      g_auto(GLnxTmpfile) env_tmpf  = { 0, };\n\n      if (!flatpak_buffer_to_sealed_memfd_or_tmpfile (&env_tmpf, \"environ\",\n                                                      env_string->str,\n                                                      env_string->len, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      child_setup_data.env_fd = glnx_steal_fd (&env_tmpf.fd);\n      g_ptr_array_add (flatpak_argv,\n                       g_strdup_printf (\"--env-fd=%d\",\n                                        child_setup_data.env_fd));\n    }\n\n  expose_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0;\n  share_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS) != 0;\n\n  if (expose_pids || share_pids)\n    {\n      g_autofree char *instance_id = NULL;\n      int sender_pid1 = 0;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* dims = GetInput(context, node, kDimsTensor);\n  const TfLiteTensor* value = GetInput(context, node, kValueTensor);\n\n  // Make sure the 1st input tensor is 1-D.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(dims), 1);\n\n  // Make sure the 1st input tensor is int32 or int64.\n  const auto dtype = dims->type;\n  TF_LITE_ENSURE(context, dtype == kTfLiteInt32 || dtype == kTfLiteInt64);\n\n  // Make sure the 2nd input tensor is a scalar.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(value), 0);\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  output->type = value->type;\n\n  if (IsConstantTensor(dims)) {\n    TF_LITE_ENSURE_OK(context, ResizeOutput(context, dims, output));\n  } else {\n    SetTensorToDynamic(output);\n  }\n  return kTfLiteOk;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* dims;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kDimsTensor, &dims));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kValueTensor, &value));\n\n  // Make sure the 1st input tensor is 1-D.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(dims), 1);\n\n  // Make sure the 1st input tensor is int32 or int64.\n  const auto dtype = dims->type;\n  TF_LITE_ENSURE(context, dtype == kTfLiteInt32 || dtype == kTfLiteInt64);\n\n  // Make sure the 2nd input tensor is a scalar.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(value), 0);\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  output->type = value->type;\n\n  if (IsConstantTensor(dims)) {\n    TF_LITE_ENSURE_OK(context, ResizeOutput(context, dims, output));\n  } else {\n    SetTensorToDynamic(output);\n  }\n  return kTfLiteOk;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n    int flush;\n    int status;\n    int footer_start;\n    uint8_t *pb;\n    size_t out_size;\n    void *out_buf;\n    z_stream strm;\n    mz_ulong crc;\n\n    out_size = in_len + 32;\n    out_buf = flb_malloc(out_size);\n    if (!out_buf) {\n        flb_errno();\n        flb_error(\"[gzip] could not allocate outgoing buffer\");\n        return -1;\n    }\n\n    /* Initialize streaming buffer context */\n    memset(&strm, '\\0', sizeof(strm));\n    strm.zalloc    = Z_NULL;\n    strm.zfree     = Z_NULL;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n    int flush;\n    int status;\n    int footer_start;\n    uint8_t *pb;\n    size_t out_size;\n    void *out_buf;\n    z_stream strm;\n    mz_ulong crc;\n\n\n    /*\n     * GZIP relies on an algorithm with worst-case expansion\n     * of 5 bytes per 32KB data. This means we need to create a variable\n     * length output, that depends on the input length.\n     * See RFC 1951 for details.\n     */\n    int max_input_expansion = ((int)(in_len / 32000) + 1) * 5;\n\n    /*\n     * Max compressed size is equal to sum of:\n     *   10 byte header\n     *   8 byte foot\n     *   max input expansion\n     *   size of input\n     */\n    out_size = 10 + 8 + max_input_expansion + in_len;\n    out_buf = flb_malloc(out_size);\n\n    if (!out_buf) {\n        flb_errno();\n        flb_error(\"[gzip] could not allocate outgoing buffer\");\n        return -1;\n    }\n\n    /* Initialize streaming buffer context */\n    memset(&strm, '\\0', sizeof(strm));\n    strm.zalloc    = Z_NULL;\n    strm.zfree     = Z_NULL;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "header_seek (SF_PRIVATE *psf, sf_count_t position, int whence)\n{\n\tswitch (whence)\n\t{\tcase SEEK_SET :\n\t\t\tif (position > SIGNED_SIZEOF (psf->header))\n\t\t\t{\t/* Too much header to cache so just seek instead. */\n\t\t\t\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\t\t\tif (position > psf->headend)\n\t\t\t\tpsf->headend += psf_fread (psf->header + psf->headend, 1, position - psf->headend, psf) ;\n\t\t\tpsf->headindex = position ;\n\t\t\tbreak ;\n\n\t\tcase SEEK_CUR :\n\t\t\tif (psf->headindex + position < 0)\n\t\t\t\tbreak ;\n\n\t\t\tif (psf->headindex >= SIGNED_SIZEOF (psf->header))\n\t\t\t{\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->headindex + position <= psf->headend)\n\t\t\t{\tpsf->headindex += position ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->headindex + position > SIGNED_SIZEOF (psf->header))\n\t\t\t{\t/* Need to jump this without caching it. */\n\t\t\t\tpsf->headindex = psf->headend ;\n\t\t\t\tpsf_fseek (psf, position, SEEK_CUR) ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\n\t\t\tpsf->headend += psf_fread (psf->header + psf->headend, 1, position - (psf->headend - psf->headindex), psf) ;\n\t\t\tpsf->headindex = psf->headend ;\n\t\t\tbreak ;\n\n\t\tcase SEEK_END :\n\t\tdefault :\n\t\t\tpsf_log_printf (psf, \"Bad whence param in header_seek().\\n\") ;\n\t\t\tbreak ;\n\t\t} ;\n\n\treturn ;\n} /* header_seek */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "header_seek (SF_PRIVATE *psf, sf_count_t position, int whence)\n{\n\tswitch (whence)\n\t{\tcase SEEK_SET :\n\t\t\tif (psf->header.indx + position >= psf->header.len)\n\t\t\t\tpsf_bump_header_allocation (psf, position) ;\n\t\t\tif (position > psf->header.len)\n\t\t\t{\t/* Too much header to cache so just seek instead. */\n\t\t\t\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\t\t\tif (position > psf->header.end)\n\t\t\t\tpsf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, position - psf->header.end, psf) ;\n\t\t\tpsf->header.indx = position ;\n\t\t\tbreak ;\n\n\t\tcase SEEK_CUR :\n\t\t\tif (psf->header.indx + position >= psf->header.len)\n\t\t\t\tpsf_bump_header_allocation (psf, position) ;\n\n\t\t\tif (psf->header.indx + position < 0)\n\t\t\t\tbreak ;\n\n\t\t\tif (psf->header.indx >= psf->header.len)\n\t\t\t{\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->header.indx + position <= psf->header.end)\n\t\t\t{\tpsf->header.indx += position ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->header.indx + position > psf->header.len)\n\t\t\t{\t/* Need to jump this without caching it. */\n\t\t\t\tpsf->header.indx = psf->header.end ;\n\t\t\t\tpsf_fseek (psf, position, SEEK_CUR) ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\n\t\t\tpsf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, position - (psf->header.end - psf->header.indx), psf) ;\n\t\t\tpsf->header.indx = psf->header.end ;\n\t\t\tbreak ;\n\n\t\tcase SEEK_END :\n\t\tdefault :\n\t\t\tpsf_log_printf (psf, \"Bad whence param in header_seek().\\n\") ;\n\t\t\tbreak ;\n\t\t} ;\n\n\treturn ;\n} /* header_seek */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->tread_sem);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->ioctl_lock);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"Code clear (free=%hu) npix=%ld\\n\", free, npix);\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\t\t/* clear */\n\t\t\tfree = clr + 2;\n\t\t\tcontext.nbbit = i->imgbits + 1;\n\t\t\tcontext.max = clr + clr - 1; /* (1 << context.nbbit) - 1 */\n\t\t\tact_code = GetGifWord(i, &context);\n\t\t\tcasspecial = (u8)act_code;\n\t\t\told_code = act_code;\n\t\t\tWritePixel(i, &context, casspecial); npix--;\n\t\t} else {\n\t\t\tread_byt = act_code;\n\t\t\tif(act_code >= free) {\t/* code pas encore dans alphabet */\n/*\t\t\t\tprintf(\"Code pas dans alphabet : %d>=%d push %d\\n\", act_code, free, casspecial); */\n\t\t\t\t*(--stackp) = casspecial; /* dernier debut de chaine ! */\n\t\t\t\tact_code = old_code;\n\t\t\t}\n/*\t\t\tprintf(\"actcode=%d\\n\", act_code); */\n\t\t\twhile(act_code > clr) { /* code non concret */\n\t\t\t\t/* fillstackloop empile les suffixes ! */\n\t\t\t\t*(--stackp) = ab_suffx[act_code];\n\t\t\t\tact_code = ab_prfx[act_code];\t/* prefixe */\n\t\t\t}\n\t\t\t/* act_code est concret */\n\t\t\tcasspecial = (u8)act_code;\t/* dernier debut de chaine ! */\n\t\t\t*(--stackp) = casspecial;\t/* push on stack */\n\t\t\tWritePixels(i, &context, stackp, stack_top - stackp);\t/* unstack all pixels at once */\n\t\t\tnpix -= (stack_top - stackp);\n\t\t\tstackp = stack_top;\n/*\t\t\tputchar('\\n'); */\n\t\t\tif(free < 4096) { /* la taille du dico est 4096 max ! */\n\t\t\t\tab_prfx[free] = old_code;\n\t\t\t\tab_suffx[free] = (u8)act_code;\n\t\t\t\tfree++;\n\t\t\t\tif((free > context.max) && (context.nbbit < 12)) {\n\t\t\t\t\tcontext.nbbit++;\t/* 1 bit de plus pour les codes LZW */\n\t\t\t\t\tcontext.max += context.max + 1;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"Code clear (free=%hu) npix=%ld\\n\", free, npix);\n#endif /* !defined(NGIFLIB_NO_FILE) */\n\t\t\t/* clear */\n\t\t\tfree = clr + 2;\n\t\t\tcontext.nbbit = i->imgbits + 1;\n\t\t\tcontext.max = clr + clr - 1; /* (1 << context.nbbit) - 1 */\n\t\t\tact_code = GetGifWord(i, &context);\n\t\t\tcasspecial = (u8)act_code;\n\t\t\told_code = act_code;\n\t\t\tif(npix > 0) WritePixel(i, &context, casspecial);\n\t\t\tnpix--;\n\t\t} else {\n\t\t\tread_byt = act_code;\n\t\t\tif(act_code >= free) {\t/* code pas encore dans alphabet */\n/*\t\t\t\tprintf(\"Code pas dans alphabet : %d>=%d push %d\\n\", act_code, free, casspecial); */\n\t\t\t\t*(--stackp) = casspecial; /* dernier debut de chaine ! */\n\t\t\t\tact_code = old_code;\n\t\t\t}\n/*\t\t\tprintf(\"actcode=%d\\n\", act_code); */\n\t\t\twhile(act_code > clr) { /* code non concret */\n\t\t\t\t/* fillstackloop empile les suffixes ! */\n\t\t\t\t*(--stackp) = ab_suffx[act_code];\n\t\t\t\tact_code = ab_prfx[act_code];\t/* prefixe */\n\t\t\t}\n\t\t\t/* act_code est concret */\n\t\t\tcasspecial = (u8)act_code;\t/* dernier debut de chaine ! */\n\t\t\t*(--stackp) = casspecial;\t/* push on stack */\n\t\t\tif(npix >= (stack_top - stackp)) {\n\t\t\t\tWritePixels(i, &context, stackp, stack_top - stackp);\t/* unstack all pixels at once */\n\t\t\t} else if(npix > 0) {\t/* \"pixel overflow\" */\n\t\t\t\tWritePixels(i, &context, stackp, npix);\n\t\t\t}\n\t\t\tnpix -= (stack_top - stackp);\n\t\t\tstackp = stack_top;\n/*\t\t\tputchar('\\n'); */\n\t\t\tif(free < 4096) { /* la taille du dico est 4096 max ! */\n\t\t\t\tab_prfx[free] = old_code;\n\t\t\t\tab_suffx[free] = (u8)act_code;\n\t\t\t\tfree++;\n\t\t\t\tif((free > context.max) && (context.nbbit < 12)) {\n\t\t\t\t\tcontext.nbbit++;\t/* 1 bit de plus pour les codes LZW */\n\t\t\t\t\tcontext.max += context.max + 1;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "bool CxImage::Transfer(CxImage &from, bool bTransferFrames /*=true*/)\n{\n\tif (!Destroy())\n\t\treturn false;\n\n\tmemcpy(&head,&from.head,sizeof(BITMAPINFOHEADER));\n\tmemcpy(&info,&from.info,sizeof(CXIMAGEINFO));\n\n\tpDib = from.pDib;\n\tpSelection = from.pSelection;\n\tpAlpha = from.pAlpha;\n\tppLayers = from.ppLayers;\n\n\tmemset(&from.head,0,sizeof(BITMAPINFOHEADER));\n\tmemset(&from.info,0,sizeof(CXIMAGEINFO));\n\tfrom.pDib = from.pSelection = from.pAlpha = NULL;\n\tfrom.ppLayers = NULL;\n\n\tif (bTransferFrames){\n\t\tDestroyFrames();\n\t\tppFrames = from.ppFrames;\n\t\tfrom.ppFrames = NULL;\n\t}\n\n\treturn true;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "bool CxImage::Transfer(CxImage &from, bool bTransferFrames /*=true*/)\n{\n\tif (!Destroy())\n\t\treturn false;\n\n\tmemcpy(&head,&from.head,sizeof(BITMAPINFOHEADER));\n\tmemcpy(&info,&from.info,sizeof(CXIMAGEINFO));\n\n\tpDib = from.pDib;\n    pDib = from.pDibLimit;\n\tpSelection = from.pSelection;\n\tpAlpha = from.pAlpha;\n\tppLayers = from.ppLayers;\n\n\tmemset(&from.head,0,sizeof(BITMAPINFOHEADER));\n\tmemset(&from.info,0,sizeof(CXIMAGEINFO));\n    from.pDib = from.pDibLimit = from.pSelection = from.pAlpha = NULL;\n\tfrom.ppLayers = NULL;\n\n\tif (bTransferFrames){\n\t\tDestroyFrames();\n\t\tppFrames = from.ppFrames;\n\t\tfrom.ppFrames = NULL;\n\t}\n\n\treturn true;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void cil_reset_classperms_set(struct cil_classperms_set *cp_set)\n{\n\tcil_reset_classpermission(cp_set->set);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void cil_reset_classperms_set(struct cil_classperms_set *cp_set)\n{\n\tif (cp_set == NULL) {\n\t\treturn;\n\t}\n\n\tcp_set->set = NULL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t}\n\t\tif( strcmp(key_name , LOC_EXTLANG_TAG) ==0 ){\n\t\t\tmax_value  = MAX_NO_EXTLANG;\n\t\t}\n\t\tif( strcmp(key_name , LOC_PRIVATE_TAG) ==0 ){\n\t\t\tmax_value  = MAX_NO_PRIVATE;\n\t\t}\n\n\t\t/* Multiple variant values as variant0, variant1 ,variant2 */\n\t\tisFirstSubtag = 0;\n\t\tfor( i=0 ; i< max_value; i++ ){  \n\t\t\tsnprintf( cur_key_name , 30, \"%s%d\", key_name , i);\t\n\t\t\tif( zend_hash_find( hash_arr , cur_key_name , strlen(cur_key_name) + 1,(void **)&ele_value ) == SUCCESS ){\n\t\t\t\tif( Z_TYPE_PP(ele_value)!= IS_STRING ){\n\t\t\t\t\t/* variant is not a string */\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\t/* Add the contents */\n\t\t\t\tif (isFirstSubtag++ == 0){\n\t\t\t\t\tadd_prefix(loc_name , cur_key_name);\n\t\t\t\t}\n\t\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t}\n\t\tif( strcmp(key_name , LOC_EXTLANG_TAG) ==0 ){\n\t\t\tmax_value  = MAX_NO_EXTLANG;\n\t\t}\n\t\tif( strcmp(key_name , LOC_PRIVATE_TAG) ==0 ){\n\t\t\tmax_value  = MAX_NO_PRIVATE;\n\t\t}\n\n\t\t/* Multiple variant values as variant0, variant1 ,variant2 */\n\t\tisFirstSubtag = 0;\n\t\tfor( i=0 ; i< max_value; i++ ){\n\t\t\tsnprintf( cur_key_name , 30, \"%s%d\", key_name , i);\n\t\t\tif( zend_hash_find( hash_arr , cur_key_name , strlen(cur_key_name) + 1,(void **)&ele_value ) == SUCCESS ){\n\t\t\t\tif( Z_TYPE_PP(ele_value)!= IS_STRING ){\n\t\t\t\t\t/* variant is not a string */\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\t/* Add the contents */\n\t\t\t\tif (isFirstSubtag++ == 0){\n\t\t\t\t\tadd_prefix(loc_name , cur_key_name);\n\t\t\t\t}\n\t\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                rrd_infoval_t prline;\n\n                if (im->gdes[i].strftm) {\n                    prline.u_str = (char*)malloc((FMT_LEG_LEN + 2) * sizeof(char));\n                    if (im->gdes[vidx].vf.never == 1) {\n                       time_clean(prline.u_str, im->gdes[i].format);\n                    } else {\n                        strftime(prline.u_str,\n                                 FMT_LEG_LEN, im->gdes[i].format, &tmvdef);\n                    }\n                } else if (bad_format(im->gdes[i].format)) {\n                    rrd_set_error\n                        (\"bad format for PRINT in '%s'\", im->gdes[i].format);\n                    return -1;\n                } else {\n                    prline.u_str =\n                        sprintf_alloc(im->gdes[i].format, printval, si_symb);\n                }\n                grinfo_push(im,\n                            sprintf_alloc\n                            (\"print[%ld]\", prline_cnt++), RD_I_STR, prline);\n                free(prline.u_str);\n            } else {\n                /* GF_GPRINT */\n\n                if (im->gdes[i].strftm) {\n                    if (im->gdes[vidx].vf.never == 1) {\n                       time_clean(im->gdes[i].legend, im->gdes[i].format);\n                    } else {\n                        strftime(im->gdes[i].legend,\n                                 FMT_LEG_LEN, im->gdes[i].format, &tmvdef);\n                    }\n                } else {\n                    if (bad_format(im->gdes[i].format)) {\n                        rrd_set_error\n                            (\"bad format for GPRINT in '%s'\",\n                             im->gdes[i].format);\n                        return -1;\n                    }\n                    snprintf(im->gdes[i].legend,\n                             FMT_LEG_LEN - 2,\n                             im->gdes[i].format, printval, si_symb);\n                }\n                graphelement = 1;\n            }\n            break;\n        case GF_LINE:\n        case GF_AREA:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                rrd_infoval_t prline;\n\n                if (im->gdes[i].strftm) {\n                    prline.u_str = (char*)malloc((FMT_LEG_LEN + 2) * sizeof(char));\n                    if (im->gdes[vidx].vf.never == 1) {\n                       time_clean(prline.u_str, im->gdes[i].format);\n                    } else {\n                        strftime(prline.u_str,\n                                 FMT_LEG_LEN, im->gdes[i].format, &tmvdef);\n                    }\n                } else if (bad_format_print(im->gdes[i].format)) {\n                    return -1;\n                } else {\n                    prline.u_str =\n                        sprintf_alloc(im->gdes[i].format, printval, si_symb);\n                }\n                grinfo_push(im,\n                            sprintf_alloc\n                            (\"print[%ld]\", prline_cnt++), RD_I_STR, prline);\n                free(prline.u_str);\n            } else {\n                /* GF_GPRINT */\n\n                if (im->gdes[i].strftm) {\n                    if (im->gdes[vidx].vf.never == 1) {\n                       time_clean(im->gdes[i].legend, im->gdes[i].format);\n                    } else {\n                        strftime(im->gdes[i].legend,\n                                 FMT_LEG_LEN, im->gdes[i].format, &tmvdef);\n                    }\n                } else {\n                    if (bad_format_print(im->gdes[i].format)) {\n                       return -1;\n                    }\n                    snprintf(im->gdes[i].legend,\n                             FMT_LEG_LEN - 2,\n                             im->gdes[i].format, printval, si_symb);\n                }\n                graphelement = 1;\n            }\n            break;\n        case GF_LINE:\n        case GF_AREA:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  }
]