{"func_before":"\t\t\t\tmemcpy(&facilities->fail_call, p + 2, AX25_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_ADD) {\n\t\t\t\tmemcpy(&facilities->fail_addr, p + 3, ROSE_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_DIGIS) {\n\t\t\t\tfac_national_digis_received = 1;\n\t\t\t\tfacilities->source_ndigis = 0;\n\t\t\t\tfacilities->dest_ndigis   = 0;\n\t\t\t\tfor (pt = p + 2, lg = 0 ; lg < l ; pt += AX25_ADDR_LEN, lg += AX25_ADDR_LEN) {\n\t\t\t\t\tif (pt[6] & AX25_HBIT)\n\t\t\t\t\t\tmemcpy(&facilities->dest_digis[facilities->dest_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\telse\n\t\t\t\t\t\tmemcpy(&facilities->source_digis[facilities->source_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;","target":1,"flaw_line_index":0,"hash":"f2948b33-51dc-4f8c-a69c-2eab20beff67","idx":"1eff6fa2-6ab7-47e9-b41a-6a8a0479d379"}
{"func_before":"\t\t\t\tmemcpy(&facilities->fail_call, p + 2, AX25_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_FAIL_ADD) {\n\t\t\t\tmemcpy(&facilities->fail_addr, p + 3, ROSE_ADDR_LEN);\n\t\t\t}\n\t\t\telse if (*p == FAC_NATIONAL_DIGIS) {\n\t\t\t\tfac_national_digis_received = 1;\n\t\t\t\tfacilities->source_ndigis = 0;\n\t\t\t\tfacilities->dest_ndigis   = 0;\n\t\t\t\tfor (pt = p + 2, lg = 0 ; lg < l ; pt += AX25_ADDR_LEN, lg += AX25_ADDR_LEN) {\n\t\t\t\t\tif (pt[6] & AX25_HBIT) {\n\t\t\t\t\t\tif (facilities->dest_ndigis >= ROSE_MAX_DIGIS)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tmemcpy(&facilities->dest_digis[facilities->dest_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (facilities->source_ndigis >= ROSE_MAX_DIGIS)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tmemcpy(&facilities->source_digis[facilities->source_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;\n\t\t\tbreak;\n\t\t}\n\t} while (*p != 0x00 && len > 0);\n\n\treturn n;","target":0,"flaw_line_index":0,"hash":"4be8f134-c350-46c3-a92e-e066ffc417f7","idx":"df2c22a4-2ffd-44f4-93e3-87a1164d158a"}
{"func_before":"  bytes_per_line=image->columns;\n  if (storage_class == DirectClass)\n    bytes_per_line*=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n  buffer=(unsigned char *) AcquireQuantumMemory(PictInfoSize,sizeof(*buffer));\n  packed_scanline=(unsigned char *) AcquireQuantumMemory((size_t)\n   (row_bytes+MaxCount),sizeof(*packed_scanline));\n  scanline=(unsigned char *) AcquireQuantumMemory(row_bytes,sizeof(*scanline));\n  if ((buffer == (unsigned char *) NULL) ||\n      (packed_scanline == (unsigned char *) NULL) ||\n      (scanline == (unsigned char *) NULL))\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(scanline,0,row_bytes);\n  (void) ResetMagickMemory(packed_scanline,0,(size_t) (row_bytes+MaxCount));\n  \/*\n    Write header, header size, size bounding box, version, and reserved.\n  *\/\n  (void) ResetMagickMemory(buffer,0,PictInfoSize);\n  (void) WriteBlob(image,PictInfoSize,buffer);\n  (void) WriteBlobMSBShort(image,0);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.left);","target":1,"flaw_line_index":0,"hash":"d7c8dc1c-4a41-4656-ab47-6101de051e10","idx":"515a4b41-7475-4f01-972f-73bb09f4b253"}
{"func_before":"  bytes_per_line=image->columns;\n  if (storage_class == DirectClass)\n    bytes_per_line*=image->alpha_trait != UndefinedPixelTrait ? 4 : 3;\n  buffer=(unsigned char *) AcquireQuantumMemory(PictInfoSize,sizeof(*buffer));\n  packed_scanline=(unsigned char *) AcquireQuantumMemory((size_t)\n   (row_bytes+MaxCount),sizeof(*packed_scanline));\n  scanline=(unsigned char *) AcquireQuantumMemory(row_bytes,sizeof(*scanline));\n  if ((buffer == (unsigned char *) NULL) ||\n      (packed_scanline == (unsigned char *) NULL) ||\n      (scanline == (unsigned char *) NULL))\n    {\n      if (scanline != (unsigned char *) NULL)\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n      if (packed_scanline != (unsigned char *) NULL)\n        packed_scanline=(unsigned char *) RelinquishMagickMemory(\n          packed_scanline);\n      if (buffer != (unsigned char *) NULL)\n        buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  (void) ResetMagickMemory(scanline,0,row_bytes);\n  (void) ResetMagickMemory(packed_scanline,0,(size_t) (row_bytes+MaxCount));\n  \/*\n    Write header, header size, size bounding box, version, and reserved.\n  *\/\n  (void) ResetMagickMemory(buffer,0,PictInfoSize);\n  (void) WriteBlob(image,PictInfoSize,buffer);\n  (void) WriteBlobMSBShort(image,0);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.top);\n  (void) WriteBlobMSBShort(image,(unsigned short) size_rectangle.left);","target":0,"flaw_line_index":0,"hash":"9b72befc-982b-47f2-b0ee-c008ec0b11a8","idx":"a242e188-441b-48a4-8459-77bde86cdaec"}
{"func_before":"\t\/* Protocol layer *\/\n\tcase TIOCOUTQ: {\n\t\tlong amount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase TIOCINQ: {\n\t\t\/*\n\t\t * These two are safe on a single CPU system as only\n\t\t * user tasks fiddle here\n\t\t *\/\n\t\tstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\n\t\tlong amount = 0;\n\n\t\tif (skb)\n\t\t\tamount = skb->len - sizeof(struct ddpehdr);\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\t\/* Routing *\/\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\trc = -EPERM;\n\t\tif (capable(CAP_NET_ADMIN))\n\t\t\trc = atrtr_ioctl(cmd, argp);\n\t\tbreak;","target":1,"flaw_line_index":0,"hash":"4ebdbc97-bf95-45b7-8ee4-ca546aa5677c","idx":"08c954b9-ce2f-4aa1-84e1-0433078354f7"}
{"func_before":"\t\/* Protocol layer *\/\n\tcase TIOCOUTQ: {\n\t\tlong amount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n\n\t\tif (amount < 0)\n\t\t\tamount = 0;\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tlong amount = 0;\n\n\t\tspin_lock_irq(&sk->sk_receive_queue.lock);\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb)\n\t\t\tamount = skb->len - sizeof(struct ddpehdr);\n\t\tspin_unlock_irq(&sk->sk_receive_queue.lock);\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\t\/* Routing *\/\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\trc = -EPERM;\n\t\tif (capable(CAP_NET_ADMIN))\n\t\t\trc = atrtr_ioctl(cmd, argp);\n\t\tbreak;","target":0,"flaw_line_index":0,"hash":"f061a50d-87fc-4c98-b9b5-31d01513ea58","idx":"515e2d90-1d68-46c0-9c23-cf1e3784e39e"}
{"func_before":"bool RequestParser::OnHeadersEnd() {\n  bool matched = view_matcher_(request_->method(), request_->url().path(),\n                               &stream_);\n\n  if (!matched) {\n    LOG_WARN(\"No view matches the request: %s %s\", request_->method().c_str(),\n             request_->url().path().c_str());\n  }\n\n  return matched;\n}","target":1,"flaw_line_index":0,"hash":"75473f6f-f1db-4a07-a8d9-e8e2d1355532","idx":"fbef8b05-599d-4220-8a92-4435a21ec098"}
{"func_before":"bool RequestParser::OnHeadersEnd() {\n  \/\/ Decode the URL path before match.\n  std::string url_path = Url::DecodeUnsafe(request_->url().path());\n  bool matched = view_matcher_(request_->method(), url_path, &stream_);\n  if (!matched) {\n    LOG_WARN(\"No view matches the request: %s %s\", request_->method().c_str(),\n             url_path.c_str());\n  }\n  return matched;\n}","target":0,"flaw_line_index":0,"hash":"1e4b995a-dc12-45b9-bb90-be471b6f1f79","idx":"a8b06750-dc80-4633-a906-c0221ab8610d"}
{"func_before":"snmp_engine_get_bulk(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t *varbinds_length)\n{\n  snmp_mib_resource_t *resource;\n  uint32_t i, j, original_varbinds_length;\n  uint32_t oid[SNMP_MAX_NR_VALUES][SNMP_MSG_OID_MAX_LEN];\n  uint8_t repeater;\n\n  \/*\n   * A local copy of the requested oids must be kept since\n   *  the varbinds are modified on the fly\n   *\/\n  original_varbinds_length = *varbinds_length;\n  for(i = 0; i < original_varbinds_length; i++) {\n    snmp_oid_copy(oid[i], varbinds[i].oid);\n  }\n\n  *varbinds_length = 0;\n  for(i = 0; i < original_varbinds_length; i++) {\n    if(i >= header->error_status_non_repeaters.non_repeaters) {\n      break;\n    }\n\n    resource = snmp_mib_find_next(oid[i]);\n    if(!resource) {\n      switch(header->version) {\n      case SNMP_VERSION_1:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        \/*\n         * Varbinds are 1 indexed\n         *\/\n        header->error_index_max_repetitions.error_index = i + 1;\n        break;\n      case SNMP_VERSION_2C:\n        (&varbinds[i])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;\n        break;\n      default:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = 0;\n      }\n    } else {\n      if(*varbinds_length < SNMP_MAX_NR_VALUES) {\n        resource->handler(&varbinds[*varbinds_length], resource->oid);\n        (*varbinds_length)++;\n      }\n    }\n  }\n\n  for(i = 0; i < header->error_index_max_repetitions.max_repetitions; i++) {\n    repeater = 0;\n    for(j = header->error_status_non_repeaters.non_repeaters; j < original_varbinds_length; j++) {\n      resource = snmp_mib_find_next(oid[j]);\n      if(!resource) {\n        switch(header->version) {\n        case SNMP_VERSION_1:\n          header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n          \/*\n           * Varbinds are 1 indexed\n           *\/\n          header->error_index_max_repetitions.error_index = *varbinds_length + 1;\n          break;\n        case SNMP_VERSION_2C:\n          if(*varbinds_length < SNMP_MAX_NR_VALUES) {\n            (&varbinds[*varbinds_length])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;\n            snmp_oid_copy((&varbinds[*varbinds_length])->oid, oid[j]);\n            (*varbinds_length)++;\n          }\n          break;\n        default:\n          header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n          header->error_index_max_repetitions.error_index = 0;\n        }\n      } else {\n        if(*varbinds_length < SNMP_MAX_NR_VALUES) {\n          resource->handler(&varbinds[*varbinds_length], resource->oid);\n          (*varbinds_length)++;\n          snmp_oid_copy(oid[j], resource->oid);\n          repeater++;\n        }\n      }\n    }\n    if(repeater == 0) {\n      break;\n    }\n  }\n\n  return 0;\n}","target":1,"flaw_line_index":0,"hash":"961c0a11-ff78-40ba-9af4-c5a8b1031eb1","idx":"443935c9-ed28-4e3e-a390-1612cd291eb0"}
{"func_before":"snmp_engine_get_bulk(snmp_header_t *header, snmp_varbind_t *varbinds)\n{\n  snmp_mib_resource_t *resource;\n  snmp_oid_t oids[SNMP_MAX_NR_VALUES];\n  uint32_t j, original_varbinds_length;\n  uint8_t repeater;\n  uint8_t i, varbinds_length;\n\n  \/*\n   * A local copy of the requested oids must be kept since\n   *  the varbinds are modified on the fly\n   *\/\n  original_varbinds_length = 0;\n  while(varbinds[original_varbinds_length].value_type != BER_DATA_TYPE_EOC && original_varbinds_length < SNMP_MAX_NR_VALUES) {\n    memcpy(&oids[original_varbinds_length], &varbinds[original_varbinds_length].oid, sizeof(snmp_oid_t));\n    original_varbinds_length++;\n  }\n\n  varbinds_length = 0;\n  for(i = 0; i < original_varbinds_length; i++) {\n    if(i >= header->non_repeaters) {\n      break;\n    }\n\n    resource = snmp_mib_find_next(&oids[i]);\n    if(!resource) {\n      switch(header->version) {\n      case SNMP_VERSION_1:\n        header->error_status = SNMP_STATUS_NO_SUCH_NAME;\n        \/*\n         * Varbinds are 1 indexed\n         *\/\n        header->error_index = i + 1;\n        break;\n      case SNMP_VERSION_2C:\n        (&varbinds[i])->value_type = BER_DATA_TYPE_END_OF_MIB_VIEW;\n        break;\n      default:\n        header->error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index = 0;\n      }\n    } else {\n      if(varbinds_length < SNMP_MAX_NR_VALUES) {\n        resource->handler(&varbinds[varbinds_length], &resource->oid);\n        (varbinds_length)++;\n      } else {\n        return -1;\n      }\n    }\n  }\n\n  for(i = 0; i < header->max_repetitions; i++) {\n    repeater = 0;\n    for(j = header->non_repeaters; j < original_varbinds_length; j++) {\n      resource = snmp_mib_find_next(&oids[j]);\n      if(!resource) {\n        switch(header->version) {\n        case SNMP_VERSION_1:\n          header->error_status = SNMP_STATUS_NO_SUCH_NAME;\n          \/*\n           * Varbinds are 1 indexed\n           *\/\n          header->error_index = varbinds_length + 1;\n          break;\n        case SNMP_VERSION_2C:\n          if(varbinds_length < SNMP_MAX_NR_VALUES) {\n            (&varbinds[varbinds_length])->value_type = BER_DATA_TYPE_END_OF_MIB_VIEW;\n            memcpy(&varbinds[varbinds_length].oid, &oids[j], sizeof(snmp_oid_t));\n            (varbinds_length)++;\n          } else {\n            return -1;\n          }\n          break;\n        default:\n          header->error_status = SNMP_STATUS_NO_SUCH_NAME;\n          header->error_index = 0;\n        }\n      } else {\n        if(varbinds_length < SNMP_MAX_NR_VALUES) {\n          resource->handler(&varbinds[varbinds_length], &resource->oid);\n          (varbinds_length)++;\n          memcpy(&oids[j], &resource->oid, sizeof(snmp_oid_t));\n          repeater++;\n        } else {\n          return -1;\n        }\n      }\n    }\n    if(repeater == 0) {\n      break;\n    }\n  }\n\n  return 0;\n}","target":0,"flaw_line_index":0,"hash":"7c873de5-8c87-4235-8f4f-7c89b76e7e8e","idx":"dbb91081-861b-4e8a-a077-b207949b9303"}
{"func_before":"BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\n\treturn rv;\n}","target":1,"flaw_line_index":0,"hash":"95904ca9-305e-45b0-ada3-afcec783485b","idx":"717b31b6-f3b8-4b1e-98d5-25af0764712e"}
{"func_before":"BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tif (_gdImageWebpCtx(im, out, -1)) {\n\t\trv = NULL;\n\t} else {\n\t\trv = gdDPExtractData(out, size);\n\t}\n\tout->gd_free(out);\n\n\treturn rv;\n}","target":0,"flaw_line_index":0,"hash":"eec04040-5615-41e8-83b3-05bf015871c1","idx":"63551048-c30c-43d0-ab2e-81a9d324631a"}
{"func_before":"                while (data >= data_start && !isspace(*data) && *data != tag_open) {\n                    data--;\n                }\n                result->start = ++data;\n                \/* now go forward *\/\n                int i = 0;\n                while (data <= data_end && !isspace(*data) && *data != tag_close && i < MOBI_ATTRVALUE_MAXSIZE) {\n                    result->value[i++] = (char) *data++;\n                }\n                \/* self closing tag '\/>' *\/\n                if (*(data - 1) == '\/' && *data == '>') {\n                    --data; --i;\n                }\n                result->end = data;\n                result->value[i] = '\\0';\n                return MOBI_SUCCESS;\n            }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}","target":1,"flaw_line_index":0,"hash":"de015fe4-9658-4d41-8bd9-29b15fcb6170","idx":"f6e6f8e1-aa52-488e-b2b1-b22af9eddb35"}
{"func_before":"                while (data >= data_start && !isspace(*data) && *data != tag_open) {\n                    data--;\n                }\n                result->start = ++data;\n                \/* now go forward *\/\n                int i = 0;\n                while (data <= data_end && !isspace(*data) && *data != tag_close && i < MOBI_ATTRVALUE_MAXSIZE) {\n                    result->value[i++] = (char) *data++;\n                }\n                \/* self closing tag '\/>' *\/\n                if (data <= data_end && *(data - 1) == '\/' && *data == '>') {\n                    --data; --i;\n                }\n                result->end = data;\n                result->value[i] = '\\0';\n                return MOBI_SUCCESS;\n            }\n        data++;\n    }\n    return MOBI_SUCCESS;\n}","target":0,"flaw_line_index":0,"hash":"70c54312-81f6-4802-910d-529f84d0b692","idx":"4bee9808-1b71-4f9d-8f5a-985ffc2abfd6"}
{"func_before":"\tinode = d_backing_inode(path.dentry);\n\tret = inode_permission(inode, MAY_WRITE);\n\tif (ret)\n\t\tgoto out;\n\n\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\n\traw = bpf_any_get(inode->i_private, *type);\n\ttouch_atime(&path);\n\n\tpath_put(&path);\n\treturn raw;\nout:\n\tpath_put(&path);\n\treturn ERR_PTR(ret);\n}","target":1,"flaw_line_index":0,"hash":"b3a3feaf-2f05-47aa-a14f-46570838e3d7","idx":"3137bb4d-b54a-466e-8119-df1636891852"}
{"func_before":"\tinode = d_backing_inode(path.dentry);\n\tret = inode_permission(inode, MAY_WRITE);\n\tif (ret)\n\t\tgoto out;\n\n\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\n\traw = bpf_any_get(inode->i_private, *type);\n\tif (!IS_ERR(raw))\n\t\ttouch_atime(&path);\n\n\tpath_put(&path);\n\treturn raw;\nout:\n\tpath_put(&path);\n\treturn ERR_PTR(ret);\n}","target":0,"flaw_line_index":0,"hash":"da2aa517-3e45-4db9-b243-572d945fe4d7","idx":"5f19d65d-8822-49c2-a69f-fd4393e40346"}
{"func_before":"static int sgi_clock_set(clockid_t clockid, struct timespec *tp)\n{\n\n\tu64 nsec;\n\tu64 rem;\n\n\tnsec = rtc_time() * sgi_clock_period;\n\n\tsgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n\n\tif (rem <= tp->tv_nsec)\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec - rem;\n\telse {\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;\n\t\tsgi_clock_offset.tv_sec--;\n\t}\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"7374f589-6a01-4e72-9776-a7b1ade0a31b","idx":"130fa83c-c012-46f2-bdb5-c675d6f7e26d"}
{"func_before":"static int sgi_clock_set(clockid_t clockid, struct timespec *tp)\n{\n\n\tu64 nsec;\n\tu32 rem;\n\n\tnsec = rtc_time() * sgi_clock_period;\n\n\tsgi_clock_offset.tv_sec = tp->tv_sec - div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\n\tif (rem <= tp->tv_nsec)\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec - rem;\n\telse {\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;\n\t\tsgi_clock_offset.tv_sec--;\n\t}\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"f83a8e52-5233-4ed5-a323-da42a0861ac8","idx":"700b1c91-cd85-47ea-aad4-753152e4d698"}
{"func_before":"int bn_ham(const bn_t a) {\n\tint c = 0;\n\n\tfor (int i = 0; i < bn_bits(a); i++) {\n\t\tc += bn_get_bit(a, i);\n\t}\n\n\treturn c;\n}","target":1,"flaw_line_index":0,"hash":"81df3ae1-b28e-4765-a9b8-e8b7b7c72c73","idx":"2e3935b3-fd50-4a2b-9a15-eccdcbdd7d95"}
{"func_before":"size_t bn_ham(const bn_t a) {\n\tint c = 0;\n\n\tfor (int i = 0; i < bn_bits(a); i++) {\n\t\tc += bn_get_bit(a, i);\n\t}\n\n\treturn c;\n}","target":0,"flaw_line_index":0,"hash":"582bdb4c-e6a2-4212-8f27-ffac0745f27a","idx":"e21ce706-205a-49c3-9e08-6260a2a64ed8"}
{"func_before":"    else if(status<0){\n      VANESSA_LOGGER_DEBUG_UNSAFE(\"protocol->out_setup %d\", status);\n      VANESSA_LOGGER_ERR(\"Fatal error negotiating setup. Exiting child.\");\n      perdition_exit_cleanly(-1);\n    }\n\n#ifdef WITH_SSL_SUPPORT\n    else if((opt.ssl_mode & SSL_MODE_TLS_OUTGOING) &&\n          (status & PROTOCOL_S_STARTTLS)) {\n      server_io=perdition_ssl_client_connection(server_io, opt.ssl_ca_file, \n\t\t      opt.ssl_ca_path, opt.ssl_listen_ciphers, servername);\n      if(!server_io) {\n        VANESSA_LOGGER_DEBUG(\"perdition_ssl_connection outgoing\");\n        VANESSA_LOGGER_ERR(\"Fatal error establishing SSL connection\");\n        perdition_exit_cleanly(-1);\n      }\n      tls_state |= SSL_MODE_TLS_OUTGOING;\n    }\n    else if((opt.ssl_mode & SSL_MODE_TLS_OUTGOING) &&\n\t\t    (opt.ssl_mode & SSL_MODE_TLS_OUTGOING_FORCE) &&\n\t\t    !(status & PROTOCOL_S_STARTTLS)) {","target":1,"flaw_line_index":0,"hash":"b5a81932-df14-4ea7-b610-a1950a2b18fe","idx":"86bb035d-0022-41c7-9a5b-b5d591f0d7ca"}
{"func_before":"    else if(status<0){\n      VANESSA_LOGGER_DEBUG_UNSAFE(\"protocol->out_setup %d\", status);\n      VANESSA_LOGGER_ERR(\"Fatal error negotiating setup. Exiting child.\");\n      perdition_exit_cleanly(-1);\n    }\n\n#ifdef WITH_SSL_SUPPORT\n    else if((opt.ssl_mode & SSL_MODE_TLS_OUTGOING) &&\n          (status & PROTOCOL_S_STARTTLS)) {\n      server_io=perdition_ssl_client_connection(server_io, opt.ssl_ca_file, \n\t\t      opt.ssl_ca_path, opt.ssl_outgoing_ciphers, servername);\n      if(!server_io) {\n        VANESSA_LOGGER_DEBUG(\"perdition_ssl_connection outgoing\");\n        VANESSA_LOGGER_ERR(\"Fatal error establishing SSL connection\");\n        perdition_exit_cleanly(-1);\n      }\n      tls_state |= SSL_MODE_TLS_OUTGOING;\n    }\n    else if((opt.ssl_mode & SSL_MODE_TLS_OUTGOING) &&\n\t\t    (opt.ssl_mode & SSL_MODE_TLS_OUTGOING_FORCE) &&\n\t\t    !(status & PROTOCOL_S_STARTTLS)) {","target":0,"flaw_line_index":0,"hash":"1acd7652-8d09-4145-8e9c-37b9833d321a","idx":"7947e5dd-a1ea-40e5-8c67-95e4beb980fb"}
{"func_before":"htp_status_t htp_connp_REQ_PROTOCOL(htp_connp_t *connp) {\n    \/\/ Is this a short-style HTTP\/0.9 request? If it is,\n    \/\/ we will not want to parse request headers.\n    if (connp->in_tx->is_protocol_0_9 == 0) {\n        \/\/ Switch to request header parsing.\n        connp->in_state = htp_connp_REQ_HEADERS;\n        connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n    } else {\n        \/\/ Let's check if the protocol was simply missing\n        int64_t pos = connp->in_current_read_offset;\n        int afterspaces = 0;\n        \/\/ Probe if data looks like a header line\n        while (pos < connp->in_current_len) {\n            if (connp->in_current_data[pos] == ':') {\n                htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Request line: missing protocol\");\n                connp->in_tx->is_protocol_0_9 = 0;\n                \/\/ Switch to request header parsing.\n                connp->in_state = htp_connp_REQ_HEADERS;\n                connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n                return HTP_OK;\n            } else if (htp_is_lws(connp->in_current_data[pos])) {\n                \/\/ Allows spaces after header name\n                afterspaces = 1;\n            } else if (htp_is_space(connp->in_current_data[pos]) || afterspaces == 1) {\n                break;\n            }\n            pos++;\n        }\n        \/\/ We're done with this request.\n        connp->in_state = htp_connp_REQ_FINALIZE;\n    }\n\n    return HTP_OK;\n}","target":1,"flaw_line_index":0,"hash":"1e778c14-8216-48c0-842c-fa9e4a57a506","idx":"d56e57ab-dff7-4088-b1d4-04e7477ae27c"}
{"func_before":"htp_status_t htp_connp_REQ_PROTOCOL(htp_connp_t *connp) {\n    \/\/ Is this a short-style HTTP\/0.9 request? If it is,\n    \/\/ we will not want to parse request headers.\n    if (connp->in_tx->is_protocol_0_9 == 0) {\n        \/\/ Switch to request header parsing.\n        connp->in_state = htp_connp_REQ_HEADERS;\n        connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n    } else {\n        \/\/ Let's check if the protocol was simply missing\n        int64_t pos = connp->in_current_read_offset;\n        \/\/ Probe if data looks like a header line\n        while (pos < connp->in_current_len) {\n            if (!htp_is_space(connp->in_current_data[pos])) {\n                htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Request line: missing protocol\");\n                connp->in_tx->is_protocol_0_9 = 0;\n                \/\/ Switch to request header parsing.\n                connp->in_state = htp_connp_REQ_HEADERS;\n                connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n                return HTP_OK;\n            }\n            pos++;\n        }\n        \/\/ We're done with this request.\n        connp->in_state = htp_connp_REQ_FINALIZE;\n    }\n\n    return HTP_OK;\n}","target":0,"flaw_line_index":0,"hash":"6d3922e5-23d6-4dfa-a2d0-ba70124d1256","idx":"f873c76f-a0bb-4aa2-8779-ca4c8498a5f5"}
{"func_before":"\t\t}\n\t\tfree += EXT2_XATTR_LEN(name_len);\n\t}\n\terror = -ENOSPC;\n\tif (free < EXT2_XATTR_LEN(name_len) + EXT2_XATTR_SIZE(value_len))\n\t\tgoto cleanup;\n\n\t\/* Here we know that we can set the new attribute. *\/\n\n\tif (header) {\n\t\tstruct mb_cache_entry *ce;\n\n\t\t\/* assert(header == HDR(bh)); *\/\n\t\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev,\n\t\t\t\t\tbh->b_blocknr);\n\t\tlock_buffer(bh);\n\t\tif (header->h_refcount == cpu_to_le32(1)) {\n\t\t\tea_bdebug(bh, \"modifying in-place\");\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\t\/* keep the buffer locked while modifying it. *\/\n\t\t} else {\n\t\t\tint offset;\n\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\tunlock_buffer(bh);\n\t\t\tea_bdebug(bh, \"cloning\");\n\t\t\theader = kmalloc(bh->b_size, GFP_KERNEL);\n\t\t\terror = -ENOMEM;\n\t\t\tif (header == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(header, HDR(bh), bh->b_size);\n\t\t\theader->h_refcount = cpu_to_le32(1);\n\n\t\t\toffset = (char *)here - bh->b_data;","target":1,"flaw_line_index":0,"hash":"5d32c850-db12-410a-bf8e-ee29be64cadd","idx":"c53e635c-bf4c-4e0f-9b32-dcc9f1f84d1e"}
{"func_before":"\t\t\tfree += EXT2_XATTR_SIZE(size);\n\t\t}\n\t\tfree += EXT2_XATTR_LEN(name_len);\n\t}\n\terror = -ENOSPC;\n\tif (free < EXT2_XATTR_LEN(name_len) + EXT2_XATTR_SIZE(value_len))\n\t\tgoto cleanup;\n\n\t\/* Here we know that we can set the new attribute. *\/\n\n\tif (header) {\n\t\t\/* assert(header == HDR(bh)); *\/\n\t\tlock_buffer(bh);\n\t\tif (header->h_refcount == cpu_to_le32(1)) {\n\t\t\t__u32 hash = le32_to_cpu(header->h_hash);\n\n\t\t\tea_bdebug(bh, \"modifying in-place\");\n\t\t\t\/*\n\t\t\t * This must happen under buffer lock for\n\t\t\t * ext2_xattr_set2() to reliably detect modified block\n\t\t\t *\/\n\t\t\tmb2_cache_entry_delete_block(EXT2_SB(sb)->s_mb_cache,\n\t\t\t\t\t\t     hash, bh->b_blocknr);\n\n\t\t\t\/* keep the buffer locked while modifying it. *\/\n\t\t} else {\n\t\t\tint offset;\n\n\t\t\tunlock_buffer(bh);\n\t\t\tea_bdebug(bh, \"cloning\");\n\t\t\theader = kmalloc(bh->b_size, GFP_KERNEL);\n\t\t\terror = -ENOMEM;\n\t\t\tif (header == NULL)\n\t\t\t\tgoto cleanup;\n\t\t\tmemcpy(header, HDR(bh), bh->b_size);\n\t\t\theader->h_refcount = cpu_to_le32(1);\n\n\t\t\toffset = (char *)here - bh->b_data;","target":0,"flaw_line_index":0,"hash":"7d37e6b4-752b-40f7-bab1-73a4c7330dad","idx":"981df3b1-9bfc-40c2-b0f3-16f161e06a46"}
{"func_before":"char *oidc_util_get_chunked_cookie(request_rec *r, const char *cookieName, int chunkSize) {\n\tchar *cookieValue = NULL;\n\tchar *chunkValue = NULL;\n\tint i = 0;\n\tif (chunkSize == 0) {\n\t\tcookieValue = oidc_util_get_cookie(r, cookieName);\n\t} else {\n\t\tint chunkCount = oidc_util_get_chunked_count(r, cookieName);\n\t\tif (chunkCount > 0) {\n\t\t\tcookieValue = \"\";\n\t\t\tfor (i = 0; i < chunkCount; i++) {\n\t\t\t\tchunkValue = oidc_util_get_cookie(r, oidc_util_get_chunk_cookie_name(r, cookieName, i));\n\t\t\t\tif (chunkValue != NULL)\n\t\t\t\t\tcookieValue = apr_psprintf(r->pool, \"%s%s\", cookieValue, chunkValue);\n\t\t\t}\n\t\t} else {\n\t\t\tcookieValue = oidc_util_get_cookie(r, cookieName);\n\t\t}\n\t}\n\treturn cookieValue;\n}","target":1,"flaw_line_index":0,"hash":"13a220b4-c132-441a-908a-5fb870b91e27","idx":"44aaf3db-c2db-4eea-823d-1960586ea157"}
{"func_before":"char *oidc_util_get_chunked_cookie(request_rec *r, const char *cookieName, int chunkSize) {\n\tchar *cookieValue = NULL, *chunkValue = NULL;\n\tint chunkCount = 0, i = 0;\n\tif (chunkSize == 0)\n\t\treturn oidc_util_get_cookie(r, cookieName);\n\tchunkCount = oidc_util_get_chunked_count(r, cookieName);\n\tif (chunkCount == 0)\n\t\treturn oidc_util_get_cookie(r, cookieName);\n\tif ((chunkCount < 0) || (chunkCount > 99)) {\n\t\toidc_warn(r, \"chunk count out of bounds: %d\", chunkCount);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < chunkCount; i++) {\n\t\tchunkValue = oidc_util_get_cookie(r, oidc_util_get_chunk_cookie_name(r, cookieName, i));\n\t\tif (chunkValue == NULL) {\n\t\t\toidc_warn(r, \"could not find chunk %d; aborting\", i);\n\t\t\tbreak;\n\t\t}\n\t\tcookieValue = apr_psprintf(r->pool, \"%s%s\", cookieValue ? cookieValue : \"\", chunkValue);\n\t}\n\treturn cookieValue;\n}","target":0,"flaw_line_index":0,"hash":"5e43ec0f-6dcd-4de5-95c9-15564b6071bd","idx":"b6063bab-d6fd-43e6-9ec9-1a6868382072"}
{"func_before":"        mutt_buffer_addstr(buf, \"HEADER \");\n\n        \/* extract header name *\/\n        delim = strchr(pat->p.str, ':');\n        if (!delim)\n        {\n          mutt_error(_(\"Header search without header name: %s\"), pat->p.str);\n          return -1;\n        }\n        *delim = '\\0';\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        mutt_buffer_addch(buf, ' ');\n\n        \/* and field *\/\n        *delim = ':';\n        delim++;\n        SKIPWS(delim);\n        imap_quote_string(term, sizeof(term), delim);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_BODY:\n        mutt_buffer_addstr(buf, \"BODY \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_WHOLE_MSG:\n        mutt_buffer_addstr(buf, \"TEXT \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_SERVERSEARCH:\n      {\n        struct ImapData *idata = ctx->data;\n        if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))\n        {\n          mutt_error(_(\"Server-side custom search not supported: %s\"), pat->p.str);\n          return -1;\n        }\n      }\n        mutt_buffer_addstr(buf, \"X-GM-RAW \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n    }\n  }\n\n  return 0;\n}","target":1,"flaw_line_index":0,"hash":"62dca677-8ea0-40e9-b302-8f34c1814832","idx":"49906a99-8dad-46da-9a5a-e2e0ed35e286"}
{"func_before":"        mutt_buffer_addstr(buf, \"HEADER \");\n\n        \/* extract header name *\/\n        delim = strchr(pat->p.str, ':');\n        if (!delim)\n        {\n          mutt_error(_(\"Header search without header name: %s\"), pat->p.str);\n          return -1;\n        }\n        *delim = '\\0';\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        mutt_buffer_addch(buf, ' ');\n\n        \/* and field *\/\n        *delim = ':';\n        delim++;\n        SKIPWS(delim);\n        imap_quote_string(term, sizeof(term), delim, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_BODY:\n        mutt_buffer_addstr(buf, \"BODY \");\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_WHOLE_MSG:\n        mutt_buffer_addstr(buf, \"TEXT \");\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_SERVERSEARCH:\n      {\n        struct ImapData *idata = ctx->data;\n        if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))\n        {\n          mutt_error(_(\"Server-side custom search not supported: %s\"), pat->p.str);\n          return -1;\n        }\n      }\n        mutt_buffer_addstr(buf, \"X-GM-RAW \");\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n    }\n  }\n\n  return 0;\n}","target":0,"flaw_line_index":0,"hash":"6a1df9de-4707-461b-b8c8-e95b67a61fd1","idx":"1fbb9611-eeb4-4349-9402-472029edb9b5"}
{"func_before":"static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct perf_event *event = file->private_data;\n\tvoid (*func)(struct perf_event *);\n\tu32 flags = arg;\n\n\tswitch (cmd) {\n\tcase PERF_EVENT_IOC_ENABLE:\n\t\tfunc = perf_event_enable;\n\t\tbreak;\n\tcase PERF_EVENT_IOC_DISABLE:\n\t\tfunc = perf_event_disable;\n\t\tbreak;\n\tcase PERF_EVENT_IOC_RESET:\n\t\tfunc = perf_event_reset;\n\t\tbreak;\n\n\tcase PERF_EVENT_IOC_REFRESH:\n\t\treturn perf_event_refresh(event, arg);\n\n\tcase PERF_EVENT_IOC_PERIOD:\n\t\treturn perf_event_period(event, (u64 __user *)arg);\n\n\tcase PERF_EVENT_IOC_ID:\n\t{\n\t\tu64 id = primary_event_id(event);\n\n\t\tif (copy_to_user((void __user *)arg, &id, sizeof(id)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase PERF_EVENT_IOC_SET_OUTPUT:\n\t{\n\t\tint ret;\n\t\tif (arg != -1) {\n\t\t\tstruct perf_event *output_event;\n\t\t\tstruct fd output;\n\t\t\tret = perf_fget_light(arg, &output);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\toutput_event = output.file->private_data;\n\t\t\tret = perf_event_set_output(event, output_event);\n\t\t\tfdput(output);\n\t\t} else {\n\t\t\tret = perf_event_set_output(event, NULL);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tcase PERF_EVENT_IOC_SET_FILTER:\n\t\treturn perf_event_set_filter(event, (void __user *)arg);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\tif (flags & PERF_IOC_FLAG_GROUP)\n\t\tperf_event_for_each(event, func);\n\telse\n\t\tperf_event_for_each_child(event, func);\n\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"6ed3f3f7-b241-4850-916e-1e4e67ca68c2","idx":"53f3598e-7b16-4c70-b1c9-6b8e6b9e4b35"}
{"func_before":"static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct perf_event *event = file->private_data;\n\tstruct perf_event_context *ctx;\n\tlong ret;\n\n\tctx = perf_event_ctx_lock(event);\n\tret = _perf_ioctl(event, cmd, arg);\n\tperf_event_ctx_unlock(event, ctx);\n\n\treturn ret;\n}","target":0,"flaw_line_index":0,"hash":"7e09e3ff-2055-4235-875f-5ddc0e1f1b7e","idx":"9b073d20-f972-4662-8a32-b064f540e3e1"}
{"func_before":"int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,\n\tint offset, int len, int odd, struct sk_buff *skb),\n\tvoid *from, int length, int transhdrlen,\n\tint hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,\n\tstruct rt6_info *rt, unsigned int flags, int dontfrag)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_cork *cork;\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\tunsigned int maxfraglen, fragheaderlen;\n\tint exthdrlen;\n\tint dst_exthdrlen;\n\tint hh_len;\n\tint mtu;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\t__u8 tx_flags = 0;\n\n\tif (flags&MSG_PROBE)\n\t\treturn 0;\n\tcork = &inet->cork.base;\n\tif (skb_queue_empty(&sk->sk_write_queue)) {\n\t\t\/*\n\t\t\tunsigned int alloclen;\nalloc_new_skb:\n\t\t\t\/* There's no room in the current skb *\/\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t\/* update mtu and maxfraglen if necessary *\/\n\t\t\tif (skb == NULL || skb_prev == NULL)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt);\n\n\t\t\tskb_prev = skb;\n\n\t\t\t\/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t *\/\n\t\t\tdatalen = length + fraggap;\n\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)","target":1,"flaw_line_index":0,"hash":"e9427bdd-aee4-49b7-9611-0ca986c33530","idx":"d240cca9-4db4-42b4-bcc1-b5a29d1c8d1e"}
{"func_before":"int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,\n\tint offset, int len, int odd, struct sk_buff *skb),\n\tvoid *from, int length, int transhdrlen,\n\tint hlimit, int tclass, struct ipv6_txoptions *opt, struct flowi6 *fl6,\n\tstruct rt6_info *rt, unsigned int flags, int dontfrag)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_cork *cork;\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\tunsigned int maxfraglen, fragheaderlen, mtu;\n\tint exthdrlen;\n\tint dst_exthdrlen;\n\tint hh_len;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\t__u8 tx_flags = 0;\n\n\tif (flags&MSG_PROBE)\n\t\treturn 0;\n\tcork = &inet->cork.base;\n\tif (skb_queue_empty(&sk->sk_write_queue)) {\n\t\t\/*\n\t\t\tunsigned int alloclen;\nalloc_new_skb:\n\t\t\t\/* There's no room in the current skb *\/\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t\/* update mtu and maxfraglen if necessary *\/\n\t\t\tif (skb == NULL || skb_prev == NULL)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt,\n\t\t\t\t\t\t    np->pmtudisc ==\n\t\t\t\t\t\t    IPV6_PMTUDISC_PROBE);\n\n\t\t\tskb_prev = skb;\n\n\t\t\t\/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t *\/\n\t\t\tdatalen = length + fraggap;\n\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)","target":0,"flaw_line_index":0,"hash":"02b337a5-e3b4-4bcf-ad88-5753c0db3725","idx":"6b1a58d1-5c5e-44d4-b643-5a78b2795971"}
{"func_before":"int jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)\n{\n\tint i;\n\tint j;\n\n\tif (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=\n\t  mat1->numcols_) {\n\t\treturn 1;\n\t}\n\tfor (i = 0; i < mat0->numrows_; i++) {\n\t\tfor (j = 0; j < mat0->numcols_; j++) {\n\t\t\tif (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {\n\t\t\t\treturn 1;\n\t\t\t}","target":1,"flaw_line_index":0,"hash":"a4d8ea1f-3e65-4eba-aa7a-eb34f91cb83d","idx":"aca8947b-16f7-42f2-9e54-784756348ac0"}
{"func_before":"int jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)\n{\n\tjas_matind_t i;\n\tjas_matind_t j;\n\n\tif (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=\n\t  mat1->numcols_) {\n\t\treturn 1;\n\t}\n\tfor (i = 0; i < mat0->numrows_; i++) {\n\t\tfor (j = 0; j < mat0->numcols_; j++) {\n\t\t\tif (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {\n\t\t\t\treturn 1;\n\t\t\t}","target":0,"flaw_line_index":0,"hash":"2567e0e6-a7d5-443e-9e0d-d0ff2ec55f4c","idx":"a90d81b0-736e-493f-a254-dd7f623db1b5"}
{"func_before":"TfLiteStatus L2Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  switch (input->type) {  \/\/ Already know in\/out types are same.\n    case kTfLiteFloat32:\n      L2EvalFloat<kernel_type>(context, node, params, data, input, output);\n      break;\n    case kTfLiteUInt8:\n    \/\/ We don't have a quantized implementation, so just fall through to the\n    \/\/ 'default' case.\n    default:\n      context->ReportError(context, \"Type %d not currently supported.\",\n                           input->type);","target":1,"flaw_line_index":0,"hash":"acdd2e40-08dd-4b53-81e9-0216e9e3c831","idx":"88718ccd-8e43-45e7-8b0a-42b71af1b789"}
{"func_before":"TfLiteStatus L2Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  switch (input->type) {  \/\/ Already know in\/out types are same.\n    case kTfLiteFloat32:\n      L2EvalFloat<kernel_type>(context, node, params, data, input, output);\n      break;\n    case kTfLiteUInt8:\n    \/\/ We don't have a quantized implementation, so just fall through to the\n    \/\/ 'default' case.\n    default:\n      context->ReportError(context, \"Type %d not currently supported.\",\n                           input->type);","target":0,"flaw_line_index":0,"hash":"d2df79ba-d40e-4733-a6af-1de51b0b1670","idx":"5649e365-2c0f-4b19-a64e-e9458bac3cdd"}
{"func_before":"\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}","target":1,"flaw_line_index":0,"hash":"cbb1d4af-3949-4426-a2bf-1c7a848255a3","idx":"2b80f6f2-f68d-4aae-ad91-ffff7eacf954"}
{"func_before":"\n  if (!ReadOK(source->pub.input_file, source->iobuffer, source->buffer_width))\n    ERREXIT(cinfo, JERR_INPUT_EOF);\n  ptr = source->pub.buffer[0];\n  bufferptr = source->iobuffer;\n  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}","target":0,"flaw_line_index":0,"hash":"67451eb9-a418-4997-bbf2-e945cb13f3d1","idx":"2c880907-e7af-410a-800e-34bdd63a7ad2"}
{"func_before":"\tuint32_t *payload = NULL; \/\/buffer to store GPMF samples from the MP4.\n\n\n\t\/\/ get file return data\n\tif (argc != 2)\n\t{\n\t\tprintf(\"usage: %s <file_with_GPMF>\\n\", argv[0]);\n\t\treturn -1;\n\t}\n\n\tsize_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);\n\/\/\tsize_t mp4 = OpenMP4SourceUDTA(argv[1]);  \/\/Search for GPMF payload with MP4's udta \n\n\tmetadatalength = GetDuration(mp4);\n\n\tif (metadatalength > 0.0)\n\t{\n\t\tuint32_t index, payloads = GetNumberPayloads(mp4);\n\/\/\t\tprintf(\"found %.2fs of metadata, from %d payloads, within %s\\n\", metadatalength, payloads, argv[1]);\n\n#if 1\n\t\t\tGPMF_ResetState(ms);\n\t\t\tprintf(\"\\n\");\n\n\t\t}\n#endif\n\n\n\t\tfor (index = 0; index < payloads; index++)\n\t\t{\n\t\t\tuint32_t payloadsize = GetPayloadSize(mp4, index);\n\t\t\tfloat in = 0.0, out = 0.0; \/\/times\n\t\t\tpayload = GetPayload(mp4, payload, index);\n\t\t\tif (payload == NULL)\n\t\t\t\tgoto cleanup;\n\n\t\t\tret = GetPayloadTime(mp4, index, &in, &out);\n\t\t\tif (ret != GPMF_OK)\n\t\t\t\tgoto cleanup;\n\n\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n\t\t\tif (ret != GPMF_OK)\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n#endif \n\t\t}\n\n#if 1\n\t\t\/\/ Find all the available Streams and compute they sample rates\n\t\twhile (GPMF_OK == GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS))\n\t\t{\n\t\t\tif (GPMF_OK == GPMF_SeekToSamples(ms)) \/\/find the last FOURCC within the stream\n\t\t\t{\n\t\t\t\tuint32_t fourcc = GPMF_Key(ms);\n\t\t\t\tdouble rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE);\/\/ GPMF_SAMPLE_RATE_FAST);\n\t\t\t\tprintf(\"%c%c%c%c sampling rate = %f Hz\\n\", PRINTF_4CC(fourcc), rate);\n\t\t\t}\n\t\t}\n#endif\n\n\n\tcleanup:\n\t\tif (payload) FreePayload(payload); payload = NULL;\n\t\tCloseSource(mp4);\n\t}\n","target":1,"flaw_line_index":0,"hash":"63d95db1-ebbf-4b99-a39a-e84863677e8d","idx":"1fcde9bc-4411-4c86-9189-601d3841d743"}
{"func_before":"\n\n\t\/\/ get file return data\n\tif (argc != 2)\n\t{\n\t\tprintf(\"usage: %s <file_with_GPMF>\\n\", argv[0]);\n\t\treturn -1;\n\t}\n\n\tsize_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);\n\tif (mp4 == 0)\n\t{\n\t\tprintf(\"error: %s is an invalid MP4\/MOV\\n\", argv[1]);\n\t\treturn -1;\n\t}\n\n\/\/\tsize_t mp4 = OpenMP4SourceUDTA(argv[1]);  \/\/Search for GPMF payload with MP4's udta \n\n\tmetadatalength = GetDuration(mp4);\n\n\tif (metadatalength > 0.0)\n\t{\n\t\tuint32_t index, payloads = GetNumberPayloads(mp4);\n\/\/\t\tprintf(\"found %.2fs of metadata, from %d payloads, within %s\\n\", metadatalength, payloads, argv[1]);\n\n#if 1\n\t\t\tGPMF_ResetState(ms);\n\t\t\tprintf(\"\\n\");\n\n\t\t}\n#endif\n\n\n\t\tfor (index = 0; index < payloads; index++)\n\t\t{\n\t\t\tuint32_t payloadsize = GetPayloadSize(mp4, index);\n\t\t\tdouble in = 0.0, out = 0.0; \/\/times\n\t\t\tpayload = GetPayload(mp4, payload, index);\n\t\t\tif (payload == NULL)\n\t\t\t\tgoto cleanup;\n\n\t\t\tret = GetPayloadTime(mp4, index, &in, &out);\n\t\t\tif (ret != GPMF_OK)\n\t\t\t\tgoto cleanup;\n\n\t\t\tret = GPMF_Init(ms, payload, payloadsize);\n\t\t\tif (ret != GPMF_OK)\n\t\t\t}\n#endif \n\t\t}\n\n#if 1\n\t\t\/\/ Find all the available Streams and compute they sample rates\n\t\twhile (GPMF_OK == GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS))\n\t\t{\n\t\t\tif (GPMF_OK == GPMF_SeekToSamples(ms)) \/\/find the last FOURCC within the stream\n\t\t\t{\n\t\t\t\tdouble in = 0.0, out = 0.0;\n\t\t\t\tuint32_t fourcc = GPMF_Key(ms);\n\t\t\t\tdouble rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE, &in, &out);\/\/ GPMF_SAMPLE_RATE_FAST);\n\t\t\t\tprintf(\"%c%c%c%c sampling rate = %f Hz (from %f to %f)\\n\", PRINTF_4CC(fourcc), rate, in, out);\n\t\t\t}\n\t\t}\n#endif\n\n\n\tcleanup:\n\t\tif (payload) FreePayload(payload); payload = NULL;\n\t\tCloseSource(mp4);\n\t}\n","target":0,"flaw_line_index":0,"hash":"d5877c1e-f437-4df0-a0dd-fc99c47f3c4a","idx":"06099876-77e0-4e9c-866c-63a7ba90ff04"}
{"func_before":"int64_t OutputFile::readImpl(char* \/*buffer*\/, int64_t \/*length*\/) {\n  raise_warning(\"cannot read from a php:\/\/output stream\");\n  return -1;\n}","target":1,"flaw_line_index":0,"hash":"fec176c0-49f8-45fc-896f-6388f726d12a","idx":"1804a2d7-e0e5-4f77-a69a-2c98fc96673d"}
{"func_before":"int64_t OutputFile::readImpl(char* \/*buffer*\/, int64_t \/*length*\/) {\n  raise_warning(\"cannot read from a php:\/\/output stream\");\n  return 0;\n}","target":0,"flaw_line_index":0,"hash":"f74b91ab-a936-4787-b1a7-2db6e5760a9e","idx":"29fe69c8-2d9c-476c-a46a-27bcf347958f"}
{"func_before":"\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_2_LE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_4_BE:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_BE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_4_LE:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_LE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_LENGTH_INCLUDES_ITSELF:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags |= PSTRING_LENGTH_INCLUDES_ITSELF;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\tbad:\n\t\t\t\t\tif (ms->flags & MAGIC_CHECK)","target":1,"flaw_line_index":0,"hash":"4bf76da2-c8cf-4216-9e8b-d7903a248fde","idx":"44743086-917f-46f8-9fa3-acf07b8cbd63"}
{"func_before":"\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_2_LE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_4_BE:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_BE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_4_LE:\n\t\t\t\t\tswitch (m->type) {\n\t\t\t\t\tcase FILE_PSTRING:\n\t\t\t\t\tcase FILE_REGEX:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t}\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_LE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_LENGTH_INCLUDES_ITSELF:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags |= PSTRING_LENGTH_INCLUDES_ITSELF;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\tbad:\n\t\t\t\t\tif (ms->flags & MAGIC_CHECK)","target":0,"flaw_line_index":0,"hash":"76ea671e-a91c-457a-b03c-1ef137cf3170","idx":"71661677-d02b-4dd6-8f5f-ed5aff10f07c"}
{"func_before":"\nprivate int\nmget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n    int flip, int recursion_level, int *printed_something,\n    int *need_separator, int *returnval)\n{\n\tuint32_t soffset, offset = ms->offset;\n\tuint32_t lhs;\n\tint rv, oneed_separator, in_type;\n\tchar *sbuf, *rbuf;\n\tunion VALUETYPE *p = &ms->ms_value;\n\tstruct mlist ml;\n\n\tif (recursion_level >= 20) {\n\t\tfile_error(ms, 0, \"recursion nesting exceeded\");\n\t\treturn -1;\n\t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t    (uint32_t)nbytes, m) == -1)\n\t\treturn -1;\n\n\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\tfprintf(stderr, \"mget(type=%d, flag=%x, offset=%u, o=%\"\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_REGEX:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\t\tif (offset == 0)\n\t\t\treturn 0;\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = ms->o.buf;\n\t\tsoffset = ms->offset;\n\t\tms->o.buf = NULL;\n\t\tms->offset = 0;\n\t\trv = file_softmagic(ms, s + offset, nbytes - offset,\n\t\t    recursion_level, BINTEST, text);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\tfprintf(stderr, \"indirect @offs=%u[%d]\\n\", offset, rv);\n\t\trbuf = ms->o.buf;\n\t\tms->o.buf = sbuf;\n\t\tms->offset = soffset;\n\t\tif (rv == 1) {\n\t\t\tif ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&\n\t\t\t    file_printf(ms, F(ms, m, \"%u\"), offset) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(rbuf);\n\t\treturn rv;\n\n\tcase FILE_USE:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = m->value.s;\n\t\tif (*sbuf == '^') {\n\t\t\tsbuf++;\n\t\t\tflip = !flip;\n\t\t}\n\t\tif (file_magicfind(ms, sbuf, &ml) == -1) {\n\t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", sbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\toneed_separator = *need_separator;\n\t\tif (m->flag & NOSPACE)\n\t\t\t*need_separator = 0;\n\t\trv = match(ms, ml.magic, ml.nmagic, s, nbytes, offset + o,\n\t\t    mode, text, flip, recursion_level, printed_something,\n\t\t    need_separator, returnval);\n\t\tif (rv != 1)","target":1,"flaw_line_index":0,"hash":"e960c492-983d-430c-92ac-9dc6a4fc2eef","idx":"ab532fa1-ae7c-4ecc-9cab-15ccf529f9f5"}
{"func_before":"\nprivate int\nmget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n    int flip, int recursion_level, int *printed_something,\n    int *need_separator, int *returnval)\n{\n\tuint32_t offset = ms->offset;\n\tuint32_t lhs;\n\tfile_pushbuf_t *pb;\n\tint rv, oneed_separator, in_type;\n\tchar *rbuf;\n\tunion VALUETYPE *p = &ms->ms_value;\n\tstruct mlist ml;\n\n\tif (recursion_level >= MAX_RECURSION_LEVEL) {\n\t\tfile_error(ms, 0, \"recursion nesting exceeded\");\n\t\treturn -1;\n\t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t    (uint32_t)nbytes, m) == -1)\n\t\treturn -1;\n\n\tif ((ms->flags & MAGIC_DEBUG) != 0) {\n\t\tfprintf(stderr, \"mget(type=%d, flag=%x, offset=%u, o=%\"\n\t\tbreak;\n\n\tcase FILE_REGEX:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\t\tif (offset == 0)\n\t\t\treturn 0;\n\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\n\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\treturn -1;\n\n\t\trv = file_softmagic(ms, s + offset, nbytes - offset,\n\t\t    recursion_level, BINTEST, text);\n\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\tfprintf(stderr, \"indirect @offs=%u[%d]\\n\", offset, rv);\n\n\t\trbuf = file_pop_buffer(ms, pb);\n\t\tif (rbuf == NULL)\n\t\t\treturn -1;\n\n\t\tif (rv == 1) {\n\t\t\tif ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&\n\t\t\t    file_printf(ms, F(ms, m, \"%u\"), offset) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (file_printf(ms, \"%s\", rbuf) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(rbuf);\n\t\treturn rv;\n\n\tcase FILE_USE:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\trbuf = m->value.s;\n\t\tif (*rbuf == '^') {\n\t\t\trbuf++;\n\t\t\tflip = !flip;\n\t\t}\n\t\tif (file_magicfind(ms, rbuf, &ml) == -1) {\n\t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", rbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\toneed_separator = *need_separator;\n\t\tif (m->flag & NOSPACE)\n\t\t\t*need_separator = 0;\n\t\trv = match(ms, ml.magic, ml.nmagic, s, nbytes, offset + o,\n\t\t    mode, text, flip, recursion_level, printed_something,\n\t\t    need_separator, returnval);\n\t\tif (rv != 1)","target":0,"flaw_line_index":0,"hash":"e53685da-6f28-47ad-852d-9a9e618bcb1b","idx":"6c6a78d0-0afd-47ce-a854-8ae21b39181f"}
{"func_before":"  void lazyCompile(Runtime &runtime) {\n    if (LLVM_UNLIKELY(isLazy())) {\n      lazyCompileImpl(runtime);\n    }\n  }","target":1,"flaw_line_index":0,"hash":"69acad6c-6be8-4045-92ca-ec0bf27d4b14","idx":"ae0e86e5-47ec-45de-ba8b-64a50b9669ea"}
{"func_before":"  ExecutionStatus lazyCompile(Runtime &runtime) {\n    if (LLVM_UNLIKELY(isLazy())) {\n      return lazyCompileImpl(runtime);\n    }\n    return ExecutionStatus::RETURNED;\n  }","target":0,"flaw_line_index":0,"hash":"f31cfade-bc50-4a47-ba8f-9fa9723ecf18","idx":"a978b6ca-4129-4b4a-ba90-898c78de1199"}
{"func_before":"\n      \/\/ Points to the original or updated (if batch_dims is set) indices.\n      const Tensor* op_indices = &indices;\n      if (batch_dims_ > 0) {\n        OP_REQUIRES_OK(c, c->allocate_temp(indices.dtype(), indices.shape(),\n                                           &tmp_indices));\n        functor::DenseUpdate<Device, Index, ASSIGN> copy_functor;\n        copy_functor(c->eigen_device<Device>(), tmp_indices.flat<Index>(),\n                     indices.flat<Index>());\n\n        AddBatchOffsets(&tmp_indices, params);\n        op_indices = &tmp_indices;\n      }\n\n      int64_t gather_dim_size = 1;\n      for (int idx = 0; idx <= batch_dims_; ++idx) {\n        gather_dim_size *= params.dim_size(idx);\n      }\n      int64_t inner_size = 1;\n      for (int i = batch_dims_ + 1; i < params.dims(); ++i) {\n        inner_size *= params.dim_size(i);","target":1,"flaw_line_index":0,"hash":"4122204c-bc7a-449a-8e51-ead44d936d2e","idx":"526fa467-9def-49df-ba42-cf360df0634d"}
{"func_before":"\n      \/\/ Points to the original or updated (if batch_dims is set) indices.\n      const Tensor* op_indices = &indices;\n      if (batch_dims_ > 0) {\n        OP_REQUIRES_OK(c, c->allocate_temp(indices.dtype(), indices.shape(),\n                                           &tmp_indices));\n        functor::DenseUpdate<Device, Index, ASSIGN> copy_functor;\n        copy_functor(c->eigen_device<Device>(), tmp_indices.flat<Index>(),\n                     indices.flat<Index>());\n\n        AddBatchOffsets(c, &tmp_indices, params);\n        if (!c->status().ok()) return;\n        op_indices = &tmp_indices;\n      }\n\n      int64_t gather_dim_size = 1;\n      for (int idx = 0; idx <= batch_dims_; ++idx) {\n        gather_dim_size *= params.dim_size(idx);\n      }\n      int64_t inner_size = 1;\n      for (int i = batch_dims_ + 1; i < params.dims(); ++i) {\n        inner_size *= params.dim_size(i);","target":0,"flaw_line_index":0,"hash":"de0c1ee0-53d1-413f-ab29-247fd1942226","idx":"92bc902e-b9c3-4c31-92ec-2ded68ae1714"}
{"func_before":"split_der(asn1buf *buf, uint8_t *const *der, size_t len, taginfo *tag_out)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n\n    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (rlen != 0)\n        return ASN1_BAD_LENGTH;\n    insert_bytes(buf, contents, clen);\n    return 0;\n}","target":1,"flaw_line_index":0,"hash":"3fe71bd1-3f57-4197-af36-d2b8ca9aa1bf","idx":"950e1286-2365-4c68-9fb6-02baedd90f4c"}
{"func_before":"split_der(asn1buf *buf, uint8_t *const *der, size_t len, taginfo *tag_out)\n{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n\n    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen, 0);\n    if (ret)\n        return ret;\n    if (rlen != 0)\n        return ASN1_BAD_LENGTH;\n    insert_bytes(buf, contents, clen);\n    return 0;\n}","target":0,"flaw_line_index":0,"hash":"e6edfdda-d736-44c3-8b93-ba23127e9a1f","idx":"81615ea2-e0bc-4add-bf04-0146e41c7fa3"}
{"func_before":"     ci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: URL requested: %s\\n\", httpinf.url);\n\n     \/* Check the URL against SquidClamav Whitelist *\/\n     if (simple_pattern_compare(httpinf.url, WHITELIST) == 1) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (WHITELIST match) for url: %s\\n\", httpinf.url);\n\t   return CI_MOD_ALLOW204;\n     }\n\n     \n     \/* Check URL header against squidGuard *\/\n     if (usepipe == 1) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Sending request to chained program: %s\\n\", squidguard);\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Request: %s %s %s %s\\n\", httpinf.url,clientip,username,httpinf.method);\n\tfprintf(sgfpw,\"%s %s %s %s\\n\",httpinf.url,clientip,username,httpinf.method);\n\tfflush(sgfpw);\n\t\/* the chained redirector must return empty line if ok or the redirection url *\/\n\tchain_ret = (char *)malloc(sizeof(char)*MAX_URL_SIZE);\n\tif (chain_ret != NULL) {\n\t   ret = fgets(chain_ret,MAX_URL_SIZE,sgfpr);\n\t   if ((ret != NULL) && (strlen(chain_ret) > 1)) {\n\t\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: Chained program redirection received: %s\\n\", chain_ret);\n\t\tif (logredir)\n\t\t   ci_debug_printf(0, \"INFO Chained program redirection received: %s\\n\", chain_ret);\n\t\t\/* Create the redirection url to squid *\/\n\t\tdata->blocked = 1;","target":1,"flaw_line_index":0,"hash":"d48beb70-cc24-4821-a2a7-6cf69d63e6fb","idx":"3f8adccc-8328-4804-aa80-ee4a33f45661"}
{"func_before":"\n     \/* Check the URL against SquidClamav Whitelist *\/\n     if (simple_pattern_compare(httpinf.url, WHITELIST) == 1) {\n           ci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: No squidguard and antivir check (WHITELIST match) for url: %s\\n\", httpinf.url);\n\t   return CI_MOD_ALLOW204;\n     }\n\n     \n     \/* Check URL header against squidGuard *\/\n     if (usepipe == 1) {\n\tchar *rbuff = NULL;\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Sending request to chained program: %s\\n\", squidguard);\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Request: %s %s %s %s\\n\", httpinf.url,clientip,username,httpinf.method);\n\t\/* escaping escaped character to prevent unescaping by squidguard *\/\n\trbuff = replace(httpinf.url, \"%\", \"%25\");\n\tfprintf(sgfpw,\"%s %s %s %s\\n\",rbuff,clientip,username,httpinf.method);\n\tfflush(sgfpw);\n\txfree(rbuff);\n\t\/* the chained redirector must return empty line if ok or the redirection url *\/\n\tchain_ret = (char *)malloc(sizeof(char)*MAX_URL_SIZE);\n\tif (chain_ret != NULL) {\n\t   ret = fgets(chain_ret,MAX_URL_SIZE,sgfpr);\n\t   if ((ret != NULL) && (strlen(chain_ret) > 1)) {\n\t\tci_debug_printf(1, \"DEBUG squidclamav_check_preview_handler: Chained program redirection received: %s\\n\", chain_ret);\n\t\tif (logredir)\n\t\t   ci_debug_printf(0, \"INFO Chained program redirection received: %s\\n\", chain_ret);\n\t\t\/* Create the redirection url to squid *\/\n\t\tdata->blocked = 1;","target":0,"flaw_line_index":0,"hash":"03134e28-b031-477d-b76c-f0f683012c54","idx":"5cebe1d8-9633-4e93-bf00-afd597a96384"}
{"func_before":"int is_manager_apk(char *path)\n{\n\treturn check_v2_signature(path, ksu_expected_size, ksu_expected_hash);\n}","target":1,"flaw_line_index":0,"hash":"c0a9438d-b206-451a-b17a-b3bfd6cbddb7","idx":"54f9100b-35af-45fb-9ee2-e4f7db7639e9"}
{"func_before":"bool is_manager_apk(char *path)\n{\n\treturn check_v2_signature(path, ksu_expected_size, ksu_expected_hash);\n}","target":0,"flaw_line_index":0,"hash":"57fb316d-c36c-4d78-9007-000eb6d7e6d7","idx":"952a4622-55cf-49e5-a3b2-252e78be6808"}
{"func_before":"do_prefetch_tables (const void *gcmM, size_t gcmM_size)\n{\n  prefetch_table(gcmM, gcmM_size);\n  prefetch_table(gcmR, sizeof(gcmR));\n}","target":1,"flaw_line_index":0,"hash":"d711d2d0-644f-4a72-8d01-1cf7d8cd3ff8","idx":"dce5ee8b-df4f-44bc-b20b-092e9df7dee2"}
{"func_before":"do_prefetch_tables (const void *gcmM, size_t gcmM_size)\n{\n  \/* Modify counters to trigger copy-on-write and unsharing if physical pages\n   * of look-up table are shared between processes.  Modifying counters also\n   * causes checksums for pages to change and hint same-page merging algorithm\n   * that these pages are frequently changing.  *\/\n  gcm_table.counter_head++;\n  gcm_table.counter_tail++;\n\n  \/* Prefetch look-up tables to cache.  *\/\n  prefetch_table(gcmM, gcmM_size);\n  prefetch_table(&gcm_table, sizeof(gcm_table));\n}","target":0,"flaw_line_index":0,"hash":"eb9c4cee-a5cd-4de4-aaef-8fd3ea46d687","idx":"497b1618-67f5-4763-99ae-b1418ce54cf7"}
{"func_before":"create_spnego_ctx(void)\n{\n\tspnego_gss_ctx_id_t spnego_ctx = NULL;\n\tspnego_ctx = (spnego_gss_ctx_id_t)\n\t\tmalloc(sizeof (spnego_gss_ctx_id_rec));\n\n\tif (spnego_ctx == NULL) {\n\t\treturn (NULL);\n\t}\n\n\tspnego_ctx->magic_num = SPNEGO_MAGIC_ID;\n\tspnego_ctx->mech_set = NULL;\n\tspnego_ctx->internal_mech = NULL;\n\tspnego_ctx->optionStr = NULL;\n\tspnego_ctx->DER_mechTypes.length = 0;\n\tspnego_ctx->DER_mechTypes.value = NULL;\n\tspnego_ctx->default_cred = GSS_C_NO_CREDENTIAL;\n\tspnego_ctx->mic_reqd = 0;\n\tspnego_ctx->mic_sent = 0;\n\tspnego_ctx->mic_rcvd = 0;\n\tspnego_ctx->mech_complete = 0;\n\tspnego_ctx->nego_done = 0;\n\tspnego_ctx->internal_name = GSS_C_NO_NAME;\n\tspnego_ctx->actual_mech = GSS_C_NO_OID;\n\n\tcheck_spnego_options(spnego_ctx);\n\n\treturn (spnego_ctx);\n}","target":1,"flaw_line_index":0,"hash":"75f21924-281b-498e-9002-f695e044f5d4","idx":"4d4c59de-5a64-492e-be98-eca2da4b2a93"}
{"func_before":"create_spnego_ctx(int initiate)\n{\n\tspnego_gss_ctx_id_t spnego_ctx = NULL;\n\tspnego_ctx = (spnego_gss_ctx_id_t)\n\t\tmalloc(sizeof (spnego_gss_ctx_id_rec));\n\n\tif (spnego_ctx == NULL) {\n\t\treturn (NULL);\n\t}\n\n\tspnego_ctx->magic_num = SPNEGO_MAGIC_ID;\n\tspnego_ctx->internal_mech = NULL;\n\tspnego_ctx->optionStr = NULL;\n\tspnego_ctx->DER_mechTypes.length = 0;\n\tspnego_ctx->DER_mechTypes.value = NULL;\n\tspnego_ctx->default_cred = GSS_C_NO_CREDENTIAL;\n\tspnego_ctx->mic_reqd = 0;\n\tspnego_ctx->mic_sent = 0;\n\tspnego_ctx->mic_rcvd = 0;\n\tspnego_ctx->mech_complete = 0;\n\tspnego_ctx->nego_done = 0;\n\tspnego_ctx->opened = 0;\n\tspnego_ctx->initiate = initiate;\n\tspnego_ctx->internal_name = GSS_C_NO_NAME;\n\tspnego_ctx->actual_mech = GSS_C_NO_OID;\n\n\tcheck_spnego_options(spnego_ctx);\n\n\treturn (spnego_ctx);\n}","target":0,"flaw_line_index":0,"hash":"7527d881-fc53-4d93-9016-0063600927fe","idx":"5745495a-2ae9-4d2f-a98c-faa9d6ae0b93"}
{"func_before":"accept_xsmp_connection (SmsConn        sms_conn,\n                        GsmXsmpServer *server,\n                        unsigned long *mask_ret,\n                        SmsCallbacks  *callbacks_ret,\n                        char         **failure_reason_ret)\n{\n        IceConn        ice_conn;\n        GsmXSMPClient *client;\n\n        \/* FIXME: what about during shutdown but before gsm_xsmp_shutdown? *\/\n        if (server->priv->xsmp_sockets == NULL) {\n                g_debug (\"GsmXsmpServer: In shutdown, rejecting new client\");\n\n                *failure_reason_ret = strdup (_(\"Refusing new client connection because the session is currently being shut down\\n\"));\n                return FALSE;\n        }\n\n        ice_conn = SmsGetIceConnection (sms_conn);\n        client = ice_conn->context;\n\n        g_return_val_if_fail (client != NULL, TRUE);\n\n        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n\n        return TRUE;\n}","target":1,"flaw_line_index":0,"hash":"08a77ca9-a766-4676-84ff-34d042cae757","idx":"0ce06bd6-8fe2-4034-8edb-01e0bb8f9298"}
{"func_before":"accept_xsmp_connection (SmsConn        sms_conn,\n                        GsmXsmpServer *server,\n                        unsigned long *mask_ret,\n                        SmsCallbacks  *callbacks_ret,\n                        char         **failure_reason_ret)\n{\n        IceConn                ice_conn;\n        GsmClient             *client;\n        GsmIceConnectionWatch *data;\n\n        \/* FIXME: what about during shutdown but before gsm_xsmp_shutdown? *\/\n        if (server->priv->xsmp_sockets == NULL) {\n                g_debug (\"GsmXsmpServer: In shutdown, rejecting new client\");\n\n                *failure_reason_ret = strdup (_(\"Refusing new client connection because the session is currently being shut down\\n\"));\n                return FALSE;\n        }\n\n        ice_conn = SmsGetIceConnection (sms_conn);\n        data = ice_conn->context;\n\n        \/* Each GsmXSMPClient has its own IceConn watcher *\/\n        free_ice_connection_watch (data);\n\n        client = gsm_xsmp_client_new (ice_conn);\n\n        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n        \/* the store will own the ref *\/\n        g_object_unref (client);\n\n        gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);\n\n        return TRUE;\n}","target":0,"flaw_line_index":0,"hash":"5a485a7e-e21b-49f8-8c40-e88d747fe477","idx":"620ed5f1-9a7f-4951-9326-914daf420b40"}
{"func_before":"file_extension(const char *s)\t\/* I - Filename or URL *\/\n{\n  const char\t*extension;\t\/* Pointer to directory separator *\/\n  static char\tbuf[1024];\t\/* Buffer for files with targets *\/\n\n\n  if (s == NULL)\n    return (NULL);\n  else if (!strncmp(s, \"data:image\/bmp;\", 15))\n    return (\"bmp\");\n  else if (!strncmp(s, \"data:image\/gif;\", 15))\n    return (\"gif\");\n  else if (!strncmp(s, \"data:image\/jpeg;\", 16))\n  if ((extension = strrchr(extension, '.')) == NULL)\n    return (\"\");\n  else\n    extension ++;\n\n  if (strchr(extension, '#') == NULL)\n    return (extension);\n\n  strlcpy(buf, extension, sizeof(buf));\n\n  *(char *)strchr(buf, '#') = '\\0';\n\n  return (buf);\n}","target":1,"flaw_line_index":0,"hash":"9a5b6a26-3481-403f-8434-dde2ff982e91","idx":"3898d988-bd63-483c-b42a-826d5c88da7f"}
{"func_before":"file_extension(const char *s)\t\/* I - Filename or URL *\/\n{\n  const char\t*extension;\t\/* Pointer to directory separator *\/\n  char\t\t*bufptr;\t\/* Pointer into buffer *\/\n  static char\tbuf[1024];\t\/* Buffer for files with targets *\/\n\n\n  if (s == NULL)\n    return (NULL);\n  else if (!strncmp(s, \"data:image\/bmp;\", 15))\n    return (\"bmp\");\n  else if (!strncmp(s, \"data:image\/gif;\", 15))\n    return (\"gif\");\n  else if (!strncmp(s, \"data:image\/jpeg;\", 16))\n  if ((extension = strrchr(extension, '.')) == NULL)\n    return (\"\");\n  else\n    extension ++;\n\n  if (strchr(extension, '#') == NULL)\n    return (extension);\n\n  strlcpy(buf, extension, sizeof(buf));\n\n  if ((bufptr = strchr(buf, '#')) != NULL)\n    *bufptr = '\\0';\n\n  return (buf);\n}","target":0,"flaw_line_index":0,"hash":"ba1c51ee-e08d-4136-9c06-55650f9f5339","idx":"43b15a20-c451-4dea-a32e-3959c88a37d3"}
{"func_before":"static void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tevtchn_to_irq[row][col] = -1;\n}","target":1,"flaw_line_index":0,"hash":"dc7af082-a030-4639-b199-3e5ba169ec7d","idx":"8a712451-dcb1-4b2a-8e96-27a67902bebc"}
{"func_before":"static void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tWRITE_ONCE(evtchn_to_irq[row][col], -1);\n}","target":0,"flaw_line_index":0,"hash":"acf9046b-3b5e-4938-8e5e-294c24a9b719","idx":"f2e904e4-3ccf-4a37-806a-96353832a35d"}
{"func_before":"\t\t}\n\t}\n\tif (!found) {\n\t\tbtrfs_err(fs_info,\n\t\"dev extent physical offset %llu devid %llu has no corresponding chunk\",\n\t\t\tphysical_offset, devid);\n\t\tret = -EUCLEAN;\n\t}\n\n\t\/* Make sure no dev extent is beyond device bondary *\/\n\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);\n\tif (!dev) {\n\t\tbtrfs_err(fs_info, \"failed to find devid %llu\", devid);\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\n\t\/* It's possible this device is a dummy for seed device *\/\n\tif (dev->disk_total_bytes == 0) {\n\t\tdev = find_device(fs_info->fs_devices->seed, devid, NULL);\n\t\tif (!dev) {\n\t\t\tbtrfs_err(fs_info, \"failed to find seed devid %llu\",\n\t\t\t\t  devid);\n\t\t\tret = -EUCLEAN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (physical_offset + physical_len > dev->disk_total_bytes) {\n\t\tbtrfs_err(fs_info,","target":1,"flaw_line_index":0,"hash":"fcf563e1-89c8-4018-ad60-f72d1e9ada4f","idx":"3adc31fe-ac70-4061-999c-371505aada78"}
{"func_before":"\t\t}\n\t}\n\tif (!found) {\n\t\tbtrfs_err(fs_info,\n\t\"dev extent physical offset %llu devid %llu has no corresponding chunk\",\n\t\t\tphysical_offset, devid);\n\t\tret = -EUCLEAN;\n\t}\n\n\t\/* Make sure no dev extent is beyond device bondary *\/\n\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true);\n\tif (!dev) {\n\t\tbtrfs_err(fs_info, \"failed to find devid %llu\", devid);\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\n\t\/* It's possible this device is a dummy for seed device *\/\n\tif (dev->disk_total_bytes == 0) {\n\t\tdev = btrfs_find_device(fs_info->fs_devices->seed, devid, NULL,\n\t\t\t\t\tNULL, false);\n\t\tif (!dev) {\n\t\t\tbtrfs_err(fs_info, \"failed to find seed devid %llu\",\n\t\t\t\t  devid);\n\t\t\tret = -EUCLEAN;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (physical_offset + physical_len > dev->disk_total_bytes) {\n\t\tbtrfs_err(fs_info,","target":0,"flaw_line_index":0,"hash":"cab6fe62-341f-4f8c-92e2-3abd0ddbf067","idx":"dfc6e923-4033-40eb-97c6-72a91df21ab7"}
{"func_before":"DH *get_dh2048(void)\n{\n    static unsigned char dhp_2048[] = {\n        0xD5, 0x75, 0xF1, 0x23, 0xC1, 0x81, 0x4B, 0x44, 0x23, 0xBE,\n        0x97, 0x81, 0x7A, 0xDA, 0x97, 0x1F, 0x1F, 0x0D, 0xD5, 0xEC,\n        0xC5, 0x5F, 0x86, 0x42, 0x7F, 0x38, 0xA3, 0x95, 0xEE, 0xA0,\n        0x52, 0x2C, 0xB7, 0x20, 0x29, 0xC1, 0xC7, 0xE6, 0x8E, 0x6F,\n        0xE5, 0xC1, 0x0D, 0xDD, 0x8A, 0xEF, 0x8D, 0xE7, 0xA8, 0x63,\n        0xB4, 0xF7, 0x58, 0x32, 0x0E, 0x24, 0xAC, 0x30, 0x94, 0xF5,\n        0xC7, 0x02, 0x81, 0x1B, 0xC7, 0x68, 0xE5, 0x71, 0xD7, 0x1E,\n        0x3D, 0xE4, 0x2E, 0x2F, 0xC0, 0x0A, 0xED, 0x34, 0xAC, 0xC0,\n        0x1F, 0x0A, 0x56, 0xA4, 0x12, 0x02, 0xFD, 0x68, 0xD2, 0x4D,\n        0x5E, 0x0A, 0x5D, 0x78, 0xE3, 0xA0, 0x85, 0x75, 0xD2, 0xA9,\n        0xC1, 0xF2, 0xAD, 0x65, 0x11, 0xDE, 0xE8, 0x05, 0x68, 0x36,\n        0x4C, 0x92, 0x99, 0x21, 0xB9, 0x69, 0xD0, 0x6F, 0xD8, 0xA3,\n        0xEA, 0x35, 0x13, 0x93, 0xDC, 0x1B, 0x13, 0x16, 0xB2, 0x15,\n        0x8E, 0x10, 0x22, 0xCE, 0x01, 0x1F, 0x1C, 0x09, 0x86, 0xD5,\n        0xE7, 0xCB, 0xCF, 0xFA, 0xED, 0x2F, 0xE2, 0x3A, 0x65, 0x14,\n        0xC9, 0xFA, 0x70, 0x99, 0xF7, 0xE0, 0x30, 0xBF, 0x7F, 0xEA,\n        0x84, 0x14, 0x8A, 0x51, 0xC9, 0xE9, 0x85, 0x73, 0x7F, 0xA1,\n        0xB0, 0xC3, 0x33, 0x9A, 0xAB, 0x69, 0x4E, 0x75, 0xFB, 0x12,\n        0xB0, 0x9E, 0xB1, 0xD9, 0xD1, 0xB9, 0x32, 0x1D, 0xC6, 0xD9,\n        0x2C, 0xAA, 0xB0, 0xC5, 0x3E, 0x69, 0x56, 0xA2, 0xB3, 0xA2,\n        0x81, 0xCA, 0x9D, 0x77, 0xBB, 0x52, 0x44, 0xA2, 0xED, 0xE0,\n        0xF0, 0x2A, 0x81, 0x85, 0x90, 0xB6, 0x04, 0x60, 0xEB, 0x09,\n        0x72, 0x08, 0x44, 0xAF, 0x28, 0xF5, 0x15, 0x34, 0x87, 0x5C,\n        0x8A, 0xB4, 0x5B, 0x15, 0x6A, 0xAD, 0x27, 0x4E, 0xA0, 0xDE,\n        0x99, 0x22, 0xCF, 0xAB, 0x4C, 0xFD, 0x75, 0x10, 0x5D, 0xFF,\n        0xE8, 0x81, 0x50, 0xC4, 0xC0, 0x4B\n    };\n    static unsigned char dhg_2048[] = {\n        0x02\n    };\n    DH *dh = DH_new();\n    BIGNUM *p, *g;\n\n    if (dh == NULL)\n        return NULL;\n    p = BN_bin2bn(dhp_2048, sizeof(dhp_2048), NULL);","target":1,"flaw_line_index":0,"hash":"2b89e742-3202-4690-bff1-fb59fa05d104","idx":"87e58e9f-cd71-4397-8a0a-2bee0fe6e60c"}
{"func_before":"DH *get_dh2048(void)\n{\n    static unsigned char dhp_2048[] = {\n        0xCF, 0x9F, 0x3A, 0x9C, 0xC5, 0xA5, 0x89, 0x27, 0x6D, 0x2C,\n        0x2C, 0xF3, 0xA6, 0x00, 0xD2, 0x7C, 0xEA, 0xFA, 0xF2, 0x43,\n        0x4F, 0x49, 0x0A, 0xFC, 0xA6, 0xE7, 0x75, 0xCA, 0x07, 0xDC,\n        0xA5, 0xF2, 0x83, 0x4E, 0x5A, 0xA0, 0xA0, 0xF5, 0x9C, 0xFD,\n        0x02, 0xE6, 0x9E, 0xFC, 0x01, 0x59, 0xD7, 0xB6, 0xC1, 0x4E,\n        0xC0, 0xB6, 0x71, 0x49, 0xF0, 0xC7, 0xD5, 0x2F, 0x8D, 0xDF,\n        0xD3, 0xF1, 0x82, 0x82, 0x23, 0x33, 0x13, 0x93, 0xEB, 0x50,\n        0x29, 0xFD, 0x1B, 0x5A, 0x2F, 0xD5, 0x08, 0x99, 0x64, 0xE9,\n        0x7B, 0x1A, 0xDD, 0x68, 0x16, 0x08, 0xD0, 0x13, 0x82, 0xB6,\n        0x86, 0x62, 0x76, 0xAA, 0x16, 0x14, 0xCC, 0x86, 0x72, 0x26,\n        0x45, 0x8E, 0x2A, 0x82, 0x5B, 0x6F, 0xC1, 0xDF, 0xAA, 0x18,\n        0x43, 0xB8, 0xAD, 0x84, 0x52, 0xF2, 0xD9, 0x9C, 0xC0, 0x47,\n        0x52, 0x1B, 0x8E, 0x42, 0xC4, 0xD3, 0x61, 0x7B, 0x65, 0xA7,\n        0x69, 0x03, 0xB5, 0xD4, 0x6C, 0x83, 0x6A, 0x46, 0x73, 0xAF,\n        0x76, 0x77, 0x70, 0xC2, 0xD0, 0x74, 0xFE, 0x78, 0xF5, 0x75,\n        0x3B, 0xCE, 0xE2, 0xB6, 0xA0, 0x25, 0xE9, 0xE8, 0x4B, 0xA2,\n        0xF1, 0x20, 0x88, 0x13, 0x07, 0xED, 0x66, 0xBC, 0x46, 0xA1,\n        0xB3, 0x44, 0xAF, 0x2C, 0xED, 0x73, 0x75, 0x3D, 0x14, 0x6E,\n        0x43, 0x92, 0x40, 0x99, 0xB0, 0xD1, 0xBF, 0x2C, 0x4D, 0x0F,\n        0x2A, 0x63, 0xF4, 0x85, 0x7B, 0x1B, 0x0E, 0x48, 0x5A, 0x06,\n        0x02, 0xA6, 0x3D, 0x9E, 0x78, 0x05, 0xA8, 0x7C, 0xAD, 0x54,\n        0x49, 0xDE, 0x7A, 0xE6, 0x36, 0x5C, 0x50, 0xFC, 0x09, 0x81,\n        0x9E, 0x83, 0x53, 0x8C, 0x42, 0xEF, 0x12, 0x36, 0x4F, 0x22,\n        0x16, 0x2A, 0x15, 0x88, 0x83, 0xA9, 0x00, 0x66, 0x9E, 0xD1,\n        0xDC, 0x0F, 0x54, 0xC0, 0x32, 0x5C, 0x4C, 0x5E, 0xE2, 0x3D,\n        0xBC, 0x56, 0x89, 0x75, 0x28, 0xA3\n    };\n    static unsigned char dhg_2048[] = {\n        0x02\n    };\n    DH *dh = DH_new();\n    BIGNUM *p, *g;\n\n    if (dh == NULL)\n        return NULL;\n    p = BN_bin2bn(dhp_2048, sizeof(dhp_2048), NULL);","target":0,"flaw_line_index":0,"hash":"876ee7d3-0a16-4ec9-a034-c84478e9f5b5","idx":"23a9b4ab-735c-4ec0-9530-9405d92dbbf1"}
{"func_before":"      int member_count = 0;\n      bool all_same = true;\n      if (me.second.m_has_this) {\n        bool any_multiple = false;\n        auto& fr = me.second.m_member_memos.begin()->second.m_return_value;\n        member_count = me.second.m_member_memos.size();\n        for (auto& mme : me.second.m_member_memos) {\n          if (mme.second.m_return_value != fr) all_same = false;\n          count += mme.second.m_count;\n          auto ser_len = mme.second.m_return_value.length();\n          min_ser_len = std::min(min_ser_len, ser_len);\n          max_ser_len = std::max(max_ser_len, ser_len);\n          if (mme.second.m_count > 1) any_multiple = true;\n        }\n        if (!any_multiple && !all_same) continue;\n      } else {\n        min_ser_len = max_ser_len = me.second.m_return_value.length();\n        count = me.second.m_count;\n        all_same = me.second.m_ret_tv_same;\n      }\n      fprintf(stderr, \"%d %s %d %d %s %s %s %d\\n\",\n              count, me.first.data(),","target":1,"flaw_line_index":0,"hash":"f34054d3-6666-4c09-bf47-f728a7dfe8d5","idx":"64e503ae-6e42-4de1-bc4e-28e40371c109"}
{"func_before":"      int member_count = 0;\n      bool all_same = true;\n      if (me.second.m_has_this) {\n        bool any_multiple = false;\n        auto& fr = me.second.m_member_memos.begin()->second.m_return_value;\n        member_count = me.second.m_member_memos.size();\n        for (auto& mme : me.second.m_member_memos) {\n          if (mme.second.m_return_value != fr) all_same = false;\n          count += mme.second.m_count;\n          auto ser_len = mme.second.m_return_value.length();\n          min_ser_len = std::min<int64_t>(min_ser_len, ser_len);\n          max_ser_len = std::max<int64_t>(max_ser_len, ser_len);\n          if (mme.second.m_count > 1) any_multiple = true;\n        }\n        if (!any_multiple && !all_same) continue;\n      } else {\n        min_ser_len = max_ser_len = me.second.m_return_value.length();\n        count = me.second.m_count;\n        all_same = me.second.m_ret_tv_same;\n      }\n      fprintf(stderr, \"%d %s %d %d %s %s %s %d\\n\",\n              count, me.first.data(),","target":0,"flaw_line_index":0,"hash":"7d431d2d-1e49-49f8-a0ef-7f1bdcbe4f7c","idx":"36298f25-d1c9-41c5-a821-aacf331b8470"}
{"func_before":"\t\treturn false;\n\t}\n\tif (header.fixups_version > 0) {\n\t\teprintf (\"Unsupported fixups version: %u\\n\", header.fixups_version);\n\t\treturn false;\n\t}\n\tut64 starts_at = offset + header.starts_offset;\n\tif (header.starts_offset > size) {\n\t\treturn false;\n\t}\n\tut32 segs_count;\n\tif ((segs_count = r_buf_read_le32_at (bin->b, starts_at)) == UT32_MAX) {\n\t\treturn false;\n\t}\n\tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, segs_count);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tbin->fixups_header = header;\n\tbin->fixups_offset = offset;\n\tbin->fixups_size = size;\n\tsize_t i;\n\tut64 cursor = starts_at + sizeof (ut32);\n\tut64 bsize = r_buf_size (bin->b);","target":1,"flaw_line_index":0,"hash":"73fd726a-ed35-42a3-9fbd-5ee506b55b3f","idx":"02839593-44c7-4328-857e-8732cc7b9f43"}
{"func_before":"\t\treturn false;\n\t}\n\tif (header.fixups_version > 0) {\n\t\teprintf (\"Unsupported fixups version: %u\\n\", header.fixups_version);\n\t\treturn false;\n\t}\n\tut64 starts_at = offset + header.starts_offset;\n\tif (header.starts_offset > size) {\n\t\treturn false;\n\t}\n\tut32 segs_count = r_buf_read_le32_at (bin->b, starts_at);\n\tif (segs_count == UT32_MAX || segs_count == 0) {\n\t\treturn false;\n\t}\n\tbin->segs_count = segs_count;\n\tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, segs_count);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tbin->fixups_header = header;\n\tbin->fixups_offset = offset;\n\tbin->fixups_size = size;\n\tsize_t i;\n\tut64 cursor = starts_at + sizeof (ut32);\n\tut64 bsize = r_buf_size (bin->b);","target":0,"flaw_line_index":0,"hash":"bd85849a-8ee3-4604-b107-d32b21a78155","idx":"6de5a6b9-3409-49b8-8e48-09dc28d5059d"}
{"func_before":"void big_key_describe(const struct key *key, struct seq_file *m)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\n\tseq_puts(m, key->description);\n\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %zu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}","target":1,"flaw_line_index":0,"hash":"29cbed95-c34e-4c7d-8203-388e30bcdba1","idx":"1b509503-9ecc-4ab6-b6c7-4c309f26bbfc"}
{"func_before":"void big_key_describe(const struct key *key, struct seq_file *m)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\n\tseq_puts(m, key->description);\n\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \": %zu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}","target":0,"flaw_line_index":0,"hash":"25183617-10bd-434e-a3ed-2917bfe7eb45","idx":"93665e1a-aeb1-42c1-b722-b75574dcfc47"}
{"func_before":"init_ctx_new(OM_uint32 *minor_status,\n\t     spnego_gss_cred_id_t spcred,\n\t     gss_ctx_id_t *ctx,\n\t     send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\tsc = create_spnego_ctx();\n\tif (sc == NULL)\n\t\treturn GSS_S_FAILURE;\n\n\t\/* determine negotiation mech set *\/\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,\n\t\t\t\t   &sc->mech_set);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\t\/* Set an initial internal mech to make the first context token. *\/\n\tsc->internal_mech = &sc->mech_set->elements[0];\n\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\t\/*\n\t * The actual context is not yet determined, set the output\n\t * context handle to refer to the spnego context itself.\n\t *\/\n\tsc->ctx_handle = GSS_C_NO_CONTEXT;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\t*tokflag = INIT_TOKEN_SEND;\n\tret = GSS_S_CONTINUE_NEEDED;\n\ncleanup:\n\trelease_spnego_ctx(&sc);\n\treturn ret;\n}","target":1,"flaw_line_index":0,"hash":"c1b8412c-1ec1-4b2f-923d-aa948de52cff","idx":"50f5a056-befd-4ec4-be8b-07d11f304bdb"}
{"func_before":"init_ctx_new(OM_uint32 *minor_status,\n\t     spnego_gss_cred_id_t spcred,\n\t     gss_ctx_id_t *ctx,\n\t     send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\tsc = create_spnego_ctx(1);\n\tif (sc == NULL)\n\t\treturn GSS_S_FAILURE;\n\n\t\/* determine negotiation mech set *\/\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,\n\t\t\t\t   &sc->mech_set);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\t\/* Set an initial internal mech to make the first context token. *\/\n\tsc->internal_mech = &sc->mech_set->elements[0];\n\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\n\tsc->ctx_handle = GSS_C_NO_CONTEXT;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\t*tokflag = INIT_TOKEN_SEND;\n\tret = GSS_S_CONTINUE_NEEDED;\n\ncleanup:\n\trelease_spnego_ctx(&sc);\n\treturn ret;\n}","target":0,"flaw_line_index":0,"hash":"94063a4b-c5bc-4866-9f9f-89f440dd0e11","idx":"b5a61832-0da4-46c5-8429-5dbce22ee2dd"}
{"func_before":"static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n}","target":1,"flaw_line_index":0,"hash":"73950df2-8b67-4332-8bb7-143cc98f1cef","idx":"830c4e24-f293-4b3b-b533-9c40c88fcfc5"}
{"func_before":"static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n}","target":0,"flaw_line_index":0,"hash":"568a1288-6239-4c40-be88-93761e43f1e3","idx":"6f8a7b3a-c4cf-4343-a671-f9c3b1a6e5d1"}
{"func_before":"\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\n\t\t\/*\n\t\t * Get a reference to this pipe buffer,\n\t\t * so we can copy the contents over.\n\t\t *\/\n\t\tpipe_buf_get(ipipe, ibuf);\n\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\n\t\t\/*\n\t\t * Don't inherit the gift flag, we need to\n\t\t * prevent multiple steals of this page.\n\t\t *\/\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n","target":1,"flaw_line_index":0,"hash":"93a57320-5fd2-4aeb-ad4c-5e30d44d781d","idx":"5a725fdc-d353-47db-b04f-7cf4e82873b4"}
{"func_before":"\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\n\t\t\/*\n\t\t * Get a reference to this pipe buffer,\n\t\t * so we can copy the contents over.\n\t\t *\/\n\t\tif (!pipe_buf_get(ipipe, ibuf)) {\n\t\t\tif (ret == 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\n\t\t\/*\n\t\t * Don't inherit the gift flag, we need to\n\t\t * prevent multiple steals of this page.\n\t\t *\/\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n","target":0,"flaw_line_index":0,"hash":"7e9015cd-1d41-4090-b554-36205c1cf42e","idx":"8647efa3-b305-424b-880e-e1d321eb9acc"}
{"func_before":"static int jpg_dec_parseopts(char *optstr, jpg_dec_importopts_t *opts)\n{\n\tjas_tvparser_t *tvp;\n\n\topts->max_size = 0;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\treturn -1;\n\t}\n\n\twhile (!jas_tvparser_next(tvp)) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_MAXSIZE:\n\t\t\topts->max_size = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t  jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n","target":1,"flaw_line_index":0,"hash":"80840a55-4aa3-4402-b0ab-3f1836156f2c","idx":"117a56ac-ca18-4493-96e3-f8921d017975"}
{"func_before":"static int jpg_dec_parseopts(char *optstr, jpg_dec_importopts_t *opts)\n{\n\tjas_tvparser_t *tvp;\n\n\topts->max_samples = 64 * JAS_MEBI;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\treturn -1;\n\t}\n\n\twhile (!jas_tvparser_next(tvp)) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_MAXSIZE:\n\t\t\topts->max_samples = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t  jas_tvparser_gettag(tvp));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tjas_tvparser_destroy(tvp);\n","target":0,"flaw_line_index":0,"hash":"6467bb8a-d6d1-4427-94f5-30ebb934d517","idx":"19057fd5-bbce-4a62-adfd-c863ba20627e"}
{"func_before":"static void dbOutputHexBlob(Jsi_DString *dStr, const void *pBlob, int nBlob){\n  int i;\n  char out[100], *zBlob = (char *)pBlob;\n  Jsi_DSAppend(dStr, \"X'\", NULL);\n  for(i=0; i<nBlob; i++){ snprintf(out, sizeof(out),\"%02x\",zBlob[i]&0xff);Jsi_DSAppend(dStr, out, NULL); }\n  Jsi_DSAppend(dStr, \"'\", NULL);\n}","target":1,"flaw_line_index":0,"hash":"6ee3fc94-6465-4d03-86e0-cf939dce3a62","idx":"65a97d80-2dc4-4634-92c1-e321882f695a"}
{"func_before":"static void dbOutputHexBlob(Jsi_DString *dStr, const void *pBlob, int nBlob){\n  int i;\n  char out[JSI_MAX_NUMBER_STRING], *zBlob = (char *)pBlob;\n  Jsi_DSAppend(dStr, \"X'\", NULL);\n  for(i=0; i<nBlob; i++){ snprintf(out, sizeof(out),\"%02x\",zBlob[i]&0xff);Jsi_DSAppend(dStr, out, NULL); }\n  Jsi_DSAppend(dStr, \"'\", NULL);\n}","target":0,"flaw_line_index":0,"hash":"9b3cbaaa-7571-4ea7-91d6-f310671e9597","idx":"b7cdc715-f97c-4d23-a609-184409ec22de"}
{"func_before":"int ZEXPORT deflateCopy (dest, source)\n    z_streamp dest;\n    z_streamp source;\n{\n#ifdef MAXSEG_64K\n    return Z_STREAM_ERROR;\n#else\n    deflate_state *ds;\n    deflate_state *ss;\n    ushf *overlay;\n\n\n    if (deflateStateCheck(source) || dest == Z_NULL) {\n        return Z_STREAM_ERROR;\n    }\n\n    ss = source->state;\n\n    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));\n\n    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));\n    if (ds == Z_NULL) return Z_MEM_ERROR;\n    dest->state = (struct internal_state FAR *) ds;\n    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));\n    ds->strm = dest;\n\n    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));\n    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));\n    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);\n    ds->pending_buf = (uchf *) overlay;\n\n    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||\n        ds->pending_buf == Z_NULL) {\n        deflateEnd (dest);\n        return Z_MEM_ERROR;\n    }\n    \/* following zmemcpy do not work for 16-bit MSDOS *\/\n    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));\n    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));\n    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));\n    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n\n    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);\n    ds->d_buf = overlay + ds->lit_bufsize\/sizeof(ush);\n    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;\n\n    ds->l_desc.dyn_tree = ds->dyn_ltree;\n    ds->d_desc.dyn_tree = ds->dyn_dtree;\n    ds->bl_desc.dyn_tree = ds->bl_tree;\n\n    return Z_OK;\n#endif \/* MAXSEG_64K *\/\n}","target":1,"flaw_line_index":0,"hash":"56a46261-90c8-43d1-adf0-93bdf97a8150","idx":"928e3cd2-c966-47ea-a162-ec8943e6cb55"}
{"func_before":"int ZEXPORT deflateCopy (dest, source)\n    z_streamp dest;\n    z_streamp source;\n{\n#ifdef MAXSEG_64K\n    return Z_STREAM_ERROR;\n#else\n    deflate_state *ds;\n    deflate_state *ss;\n\n\n    if (deflateStateCheck(source) || dest == Z_NULL) {\n        return Z_STREAM_ERROR;\n    }\n\n    ss = source->state;\n\n    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));\n\n    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));\n    if (ds == Z_NULL) return Z_MEM_ERROR;\n    dest->state = (struct internal_state FAR *) ds;\n    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));\n    ds->strm = dest;\n\n    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));\n    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));\n    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, 4);\n\n    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||\n        ds->pending_buf == Z_NULL) {\n        deflateEnd (dest);\n        return Z_MEM_ERROR;\n    }\n    \/* following zmemcpy do not work for 16-bit MSDOS *\/\n    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));\n    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));\n    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));\n    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n\n    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);\n    ds->sym_buf = ds->pending_buf + ds->lit_bufsize;\n\n    ds->l_desc.dyn_tree = ds->dyn_ltree;\n    ds->d_desc.dyn_tree = ds->dyn_dtree;\n    ds->bl_desc.dyn_tree = ds->bl_tree;\n\n    return Z_OK;\n#endif \/* MAXSEG_64K *\/\n}","target":0,"flaw_line_index":0,"hash":"cedb1701-7c83-4271-a434-7e353de143c4","idx":"277a47ef-91b6-48e2-8c00-c03c8b90401f"}
{"func_before":"      }\n    }\n  }\n\n  const float float_activation_min = params.float_activation_min;\n  const float float_activation_max = params.float_activation_max;\n  float* data_ptr = output_data;\n  if (bias_data) {\n    const int outer_size =\n        batches * output_depth * output_height * output_width;\n    const int num_channels = input_shape.Dims(4);\n    for (int n = 0; n < outer_size; ++n) {\n      for (int c = 0; c < output_num_channels; ++c) {\n        data_ptr[c] = ActivationFunctionWithMinMax(data_ptr[c] + bias_data[c],\n                                                   float_activation_min,\n                                                   float_activation_max);\n      }\n      data_ptr += num_channels;\n    }\n  } else {\n    const int flat_size = output_shape.FlatSize();\n    for (int i = 0; i < flat_size; ++i) {\n      data_ptr[i] = ActivationFunctionWithMinMax(\n          data_ptr[i], float_activation_min, float_activation_max);\n    }\n  }\n}","target":1,"flaw_line_index":0,"hash":"0a107abb-0e68-4a55-afa6-3591ca46d59a","idx":"2cfac81e-7584-4df6-8548-a3e695db6d62"}
{"func_before":"        }\n      }\n    }\n  }\n\n  const float float_activation_min = params.float_activation_min;\n  const float float_activation_max = params.float_activation_max;\n  float* data_ptr = output_data;\n  if (bias_data) {\n    const int outer_size =\n        batches * output_depth * output_height * output_width;\n    for (int n = 0; n < outer_size; ++n) {\n      for (int c = 0; c < output_num_channels; ++c) {\n        data_ptr[c] = ActivationFunctionWithMinMax(data_ptr[c] + bias_data[c],\n                                                   float_activation_min,\n                                                   float_activation_max);\n      }\n      data_ptr += output_num_channels;\n    }\n  } else {\n    const int flat_size = output_shape.FlatSize();\n    for (int i = 0; i < flat_size; ++i) {\n      data_ptr[i] = ActivationFunctionWithMinMax(\n          data_ptr[i], float_activation_min, float_activation_max);\n    }\n  }\n}","target":0,"flaw_line_index":0,"hash":"7afc07c6-173a-49b2-97a2-48a4798944e6","idx":"bca9a54e-73e9-4046-a477-a32df4118989"}
{"func_before":"static mif_hdr_t *mif_hdr_get(jas_stream_t *in)\n{\n\tuchar magicbuf[MIF_MAGICLEN];\n\tchar buf[4096];\n\tmif_hdr_t *hdr;\n\tbool done;\n\tjas_tvparser_t *tvp;\n\tint id;\n\n\thdr = 0;\n\ttvp = 0;\n\n\tif (jas_stream_read(in, magicbuf, MIF_MAGICLEN) != MIF_MAGICLEN) {","target":1,"flaw_line_index":0,"hash":"bb13164b-492d-4dcc-bdbd-d7207fceeec9","idx":"10a82298-6154-454e-9bd2-f46140371f58"}
{"func_before":"static mif_hdr_t *mif_hdr_get(jas_stream_t *in)\n{\n\tjas_uchar magicbuf[MIF_MAGICLEN];\n\tchar buf[4096];\n\tmif_hdr_t *hdr;\n\tbool done;\n\tjas_tvparser_t *tvp;\n\tint id;\n\n\thdr = 0;\n\ttvp = 0;\n\n\tif (jas_stream_read(in, magicbuf, MIF_MAGICLEN) != MIF_MAGICLEN) {","target":0,"flaw_line_index":0,"hash":"77a49fb4-5353-4674-bb69-f33760713551","idx":"b9fe8079-1d36-4b6a-8104-ec21c0c71c19"}
{"func_before":"    int length() { return ptr - start; }","target":1,"flaw_line_index":0,"hash":"8ead4e7e-070c-499d-80c2-a0ba438f6ada","idx":"8bec5a43-da67-4d72-be29-79e68fec96f4"}
{"func_before":"    size_t length() { return ptr - start; }","target":0,"flaw_line_index":0,"hash":"d9892090-bb98-48ae-a3e5-bc59327fab5b","idx":"3042aed6-7a1a-42e0-87dd-35de34bf4d43"}
{"func_before":"static int get_query(struct MHD_Connection *connection, char **query, const char *separator)\n{\n\tint element_counter;\n\tchar **elements;\n\tchar *query_str;\n\tstruct collect_query collect_query;\n\tint i;\n\tint j;\n\tint length = 0;\n\n\tdebug(LOG_DEBUG, \" Getting query, separator is [%s].\", separator);\n\n\telement_counter = MHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, counter_iterator, NULL);\n\tif (element_counter < 0) {\n\t\t*query = safe_strdup(\"\");\n\t\treturn MHD_NO;\n\t}\n\telements = calloc(element_counter, sizeof(char *));\n\n\t\/\/ Collect the arguments of the query string from MHD\n\tMHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, collect_query_string, &collect_query);\n\n\tfor (i = 0; i < element_counter; i++) {\n\t\tif (!elements[i])\n\t\t\tcontinue;\n\t\tlength += strlen(elements[i]);\n\n\t\tif (i > 0) \/\/ q=foo&o=bar the '&' need also some space\n\t\t\tlength++;\n\t}\n\n\t\/\/ don't miss the zero terminator\n\tif (*query == NULL) {\n\t\tfor (i = 0; i < element_counter; i++) {\n\t\t\tfree(elements[i]);\n\t\t}\n\t\tfree(elements);\n\t\treturn 0;\n\t}\n\n\tquery_str = safe_calloc(QUERYMAXLEN);\n\n\tfor (i = 0, j = 0; i < element_counter; i++) {\n\t\tif (!elements[i]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdebug(LOG_DEBUG, \" element [%d] is [%s]\", i, elements[i]);\n\n\t\tstrncpy(*query + j, elements[i], length - j);\n\t\tif (i == 0) {\n\t\t\t\/\/ query_str is empty when i = 0 so safe to copy a single char into it\n\t\t\tstrcpy(query_str, \"?\");\n\t\t} else {\n\t\t\tif (QUERYMAXLEN - strlen(query_str) > length - j + 1) {\n\t\t\t\tstrncat(query_str, separator, QUERYMAXLEN - strlen(query_str));\n\t\t\t}\n\t\t}\n\n\t\t\/\/ note: query string will be truncated if too long\n\t\tif (QUERYMAXLEN - strlen(query_str) > length - j) {\n\t\t\tstrncat(query_str, *query, QUERYMAXLEN - strlen(query_str));\n\t\t} else {\n\t\t\tdebug(LOG_WARNING, \" Query string exceeds the maximum of %d bytes so has been truncated.\", QUERYMAXLEN\/2);\n\t\t}\n\n\t\tfree(elements[i]);\n\t}\n\n\tdebug(LOG_DEBUG, \" query is [%s]\", query_str);\n\tstrncpy(*query, query_str, QUERYMAXLEN);\n\tfree(query_str);\n\tfree(elements);\n\treturn 0;","target":1,"flaw_line_index":0,"hash":"d06dd890-810e-45d8-9f46-15dd15260cc9","idx":"f69f876b-b17a-4046-87d1-bcb4cb404701"}
{"func_before":"static int get_query(struct MHD_Connection *connection, char **query, const char *separator)\n{\n\tint element_counter;\n\tchar **elements;\n\tchar *query_str;\n\tstruct collect_query collect_query;\n\tint i;\n\tint j = 4;\n\tint length = 0;\n\n\tdebug(LOG_DEBUG, \" Getting query, separator is [%s].\", separator);\n\n\telement_counter = MHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, counter_iterator, NULL);\n\tif (element_counter < 0) {\n\t\t*query = safe_strdup(\"\");\n\t\treturn MHD_NO;\n\t}\n\telements = calloc(element_counter, sizeof(char *));\n\t\/\/ Collect the arguments of the query string from MHD\n\tMHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, collect_query_string, &collect_query);\n\n\tfor (i = 0; i < element_counter; i++) {\n\t\tif (!elements[i])\n\t\t\tcontinue;\n\t\tlength += strlen(elements[i]);\n\n\t\tif (i > 0) \/\/ q=foo&o=bar the '&' need also some space\n\t\t\tlength++;\n\n\t\tdebug(LOG_DEBUG, \" cumulative element length is [%d]\", length);\n\t}\n\n\t\/\/ don't miss the zero terminator\n\tif (*query == NULL) {\n\t\tfor (i = 0; i < element_counter; i++) {\n\t\t\tfree(elements[i]);\n\t\t}\n\t\tfree(elements);\n\t\treturn 0;\n\t}\n\n\tquery_str = safe_calloc(QUERYMAXLEN);\n\n\tfor (i = 0, j = 0; i < element_counter; i++) {\n\t\tif (!elements[i]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdebug(LOG_DEBUG, \" element [%d] is [%s]\", i, elements[i]);\n\n\t\tif (length + j < QUERYMAXLEN) {\n\n\t\t\tstrncpy(*query + j, elements[i], length - j);\n\n\t\t\tif (i == 0) {\n\t\t\t\t\/\/ query_str is empty when i = 0 so safe to copy a single char into it\n\t\t\t\tstrcpy(query_str, \"?\");\n\t\t\t} else {\n\t\t\t\tif (QUERYMAXLEN - strlen(query_str) > length - j + 1) {\n\t\t\t\t\tstrncat(query_str, separator, QUERYMAXLEN - strlen(query_str));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstrncat(query_str, *query, QUERYMAXLEN - strlen(query_str));\n\t\t} else {\n\t\t\tdebug(LOG_WARNING, \" Query string is too long, invalid or corrupt so is ignored.\");\n\t\t}\n\n\t\tfree(elements[i]);\n\t}\n\n\tdebug(LOG_DEBUG, \" query is [%s]\", query_str);\n\tstrncpy(*query, query_str, QUERYMAXLEN);\n\tfree(query_str);\n\tfree(elements);\n\treturn 0;","target":0,"flaw_line_index":0,"hash":"535c299a-03f5-4bcc-ace9-4cfcd7eda116","idx":"4171bbbc-dc69-4985-8869-7c91820e5e3f"}
{"func_before":"      throw FizzException(\n          \"supported version mismatch\", AlertDescription::protocol_version);\n    }\n  }\n\n  state.writeRecordLayer()->setProtocolVersion(*version);\n\n  validateClientHello(chlo);\n\n  auto cipher = negotiateCipher(chlo, state.context()->getSupportedCiphers());\n\n  verifyCookieState(cookieState, *version, cipher);\n\n  auto resStateResult = getResumptionState(\n      chlo,\n      state.context()->getTicketCipher(),\n      state.context()->getSupportedPskModes());\n\n  auto replayCacheResultFuture = getReplayCacheResult(\n      chlo,\n      state.context()->getAcceptEarlyData(*version),\n        std::unique_ptr<HandshakeContext> handshakeContext;\n        std::tie(scheduler, handshakeContext) = setupSchedulerAndContext(\n            *state.context()->getFactory(),\n            cipher,\n            chlo,\n            resState,\n            cookieState,\n            pskType,\n            std::move(state.handshakeContext()),\n            version);\n\n        if (state.cipher().has_value() && cipher != *state.cipher()) {\n          throw FizzException(\n              \"cipher mismatch with previous negotiation\",\n              AlertDescription::illegal_parameter);\n        }\n\n        auto alpn = negotiateAlpn(chlo, folly::none, *state.context());\n\n        auto clockSkew = getClockSkew(\n            resState,\n            obfuscatedAge,\n            state.context()->getClock().getCurrentTime());\n\n        auto appToken = getAppToken(resState);\n","target":1,"flaw_line_index":0,"hash":"b8cfb298-784a-43e4-b33e-a39bdbfe7061","idx":"b6a53547-d629-4bff-9103-4776c6f944d1"}
{"func_before":"          \"supported version mismatch\", AlertDescription::protocol_version);\n    }\n  }\n\n  state.writeRecordLayer()->setProtocolVersion(*version);\n\n  validateClientHello(chlo);\n\n  auto cipher = negotiateCipher(chlo, state.context()->getSupportedCiphers());\n\n  if (state.cipher().has_value() && cipher != *state.cipher()) {\n    throw FizzException(\n        \"cipher mismatch with previous negotiation\",\n        AlertDescription::illegal_parameter);\n  }\n\n  verifyCookieState(cookieState, *version, cipher);\n\n  auto resStateResult = getResumptionState(\n      chlo,\n      state.context()->getTicketCipher(),\n      state.context()->getSupportedPskModes());\n\n  auto replayCacheResultFuture = getReplayCacheResult(\n      chlo,\n      state.context()->getAcceptEarlyData(*version),\n        std::unique_ptr<KeyScheduler> scheduler;\n        std::unique_ptr<HandshakeContext> handshakeContext;\n        std::tie(scheduler, handshakeContext) = setupSchedulerAndContext(\n            *state.context()->getFactory(),\n            cipher,\n            chlo,\n            resState,\n            cookieState,\n            pskType,\n            std::move(state.handshakeContext()),\n            version);\n\n        auto alpn = negotiateAlpn(chlo, folly::none, *state.context());\n\n        auto clockSkew = getClockSkew(\n            resState,\n            obfuscatedAge,\n            state.context()->getClock().getCurrentTime());\n\n        auto appToken = getAppToken(resState);\n","target":0,"flaw_line_index":0,"hash":"3af3a7eb-7c53-430b-bf6d-e54df3231d0b","idx":"49dfbe43-68fd-46e7-9f2f-75d022b9f06f"}
{"func_before":"\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\n\tif (!valid_localpart(maddr->user) ||\n\t    !valid_domainpart(maddr->domain)) {\n\t\t\/* accept empty return-path in MAIL FROM, required for bounces *\/\n\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\t\treturn (1);\n\n\t\t\/* no user-part, reject *\/\n\t\tif (maddr->user[0] == '\\0')\n\t\t\treturn (0);\n\n\t\t\/* no domain, local user *\/\n\t\tif (maddr->domain[0] == '\\0') {\n\t\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\t    sizeof(maddr->domain));\n\t\t\treturn (1);\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (1);\n}","target":1,"flaw_line_index":0,"hash":"06c7d315-6623-4681-8fdf-df8c0df47d31","idx":"2d8caeac-1510-41b4-9208-8b56c9cb7ec9"}
{"func_before":"\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\n\t\/* accept empty return-path in MAIL FROM, required for bounces *\/\n\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\treturn (1);\n\n\t\/* no or invalid user-part, reject *\/\n\tif (maddr->user[0] == '\\0' || !valid_localpart(maddr->user))\n\t\treturn (0);\n\n\t\/* no domain part, local user *\/\n\tif (maddr->domain[0] == '\\0') {\n\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\tsizeof(maddr->domain));\n\t}\n\n\tif (!valid_domainpart(maddr->domain))\n\t\treturn (0);\n\n\treturn (1);\n}","target":0,"flaw_line_index":0,"hash":"ce55fbf3-5325-4a8d-8e5b-0ea8f6c750c8","idx":"c9546328-d2f2-4694-b83d-ebe99384831f"}
{"func_before":"cib_remote_msg(gpointer data)\n{\n    const char *value = NULL;\n    xmlNode *command = NULL;\n    cib_client_t *client = data;\n\n    crm_trace(\"%s callback\", client->encrypted ? \"secure\" : \"clear-text\");\n\n    command = crm_recv_remote_msg(client->session, client->encrypted);\n    if (command == NULL) {\n        return -1;\n    }\n\n    value = crm_element_name(command);\n    if (safe_str_neq(value, \"cib_command\")) {\n        crm_log_xml_trace(command, \"Bad command: \");\n        goto bail;\n    }\n\n    if (client->name == NULL) {\n        value = crm_element_value(command, F_CLIENTNAME);\n        if (value == NULL) {\n            client->name = strdup(client->id);\n        } else {\n            client->name = strdup(value);\n        }\n    }\n\n    if (client->callback_id == NULL) {\n        value = crm_element_value(command, F_CIB_CALLBACK_TOKEN);\n        if (value != NULL) {\n            client->callback_id = strdup(value);\n            crm_trace(\"Callback channel for %s is %s\", client->id, client->callback_id);\n\n        } else {\n            client->callback_id = strdup(client->id);\n        }\n    }\n\n    \/* unset dangerous options *\/\n    xml_remove_prop(command, F_ORIG);\n    xml_remove_prop(command, F_CIB_HOST);\n    xml_remove_prop(command, F_CIB_GLOBAL_UPDATE);\n\n    crm_xml_add(command, F_TYPE, T_CIB);\n    crm_xml_add(command, F_CIB_CLIENTID, client->id);\n    crm_xml_add(command, F_CIB_CLIENTNAME, client->name);\n#if ENABLE_ACL\n    crm_xml_add(command, F_CIB_USER, client->user);\n#endif\n\n    if (crm_element_value(command, F_CIB_CALLID) == NULL) {\n        char *call_uuid = crm_generate_uuid();\n\n        \/* fix the command *\/\n        crm_xml_add(command, F_CIB_CALLID, call_uuid);\n        free(call_uuid);\n    }\n\n    if (crm_element_value(command, F_CIB_CALLOPTS) == NULL) {\n        crm_xml_add_int(command, F_CIB_CALLOPTS, 0);\n    }\n\n    crm_log_xml_trace(command, \"Remote command: \");\n    cib_common_callback_worker(0, 0, command, client, TRUE);\n  bail:\n    free_xml(command);\n    command = NULL;\n    return 0;\n}","target":1,"flaw_line_index":0,"hash":"1c491fdb-44f7-4076-bf36-360105ec6f15","idx":"f8377619-2d85-4e21-86bc-6618ceeda79c"}
{"func_before":"cib_remote_msg(gpointer data)\n{\n    xmlNode *command = NULL;\n    cib_client_t *client = data;\n    int disconnected = 0;\n    int timeout = client->remote_auth ? -1 : 1000;\n\n    crm_trace(\"%s callback\", client->encrypted ? \"secure\" : \"clear-text\");\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n    if (client->encrypted && (client->handshake_complete == FALSE)) {\n        int rc = 0;\n\n        \/* Muliple calls to handshake will be required, this callback\n         * will be invoked once the client sends more handshake data. *\/\n        do {\n            rc = gnutls_handshake(*client->session);\n\n            if (rc < 0 && rc != GNUTLS_E_AGAIN) {\n                crm_err(\"Remote cib tls handshake failed\");\n                return -1;\n            }\n        } while (rc == GNUTLS_E_INTERRUPTED);\n\n        if (rc == 0) {\n            crm_debug(\"Remote cib tls handshake completed\");\n            client->handshake_complete = TRUE;\n            if (client->remote_auth_timeout) {\n                g_source_remove(client->remote_auth_timeout);\n            }\n            \/* after handshake, clients must send auth in a few seconds *\/\n            client->remote_auth_timeout = g_timeout_add(REMOTE_AUTH_TIMEOUT, remote_auth_timeout_cb, client);\n        }\n        return 0;\n    }\n#endif\n\n    crm_recv_remote_msg(client->session, &client->recv_buf, client->encrypted, timeout, &disconnected);\n\n    \/* must pass auth before we will process anything else *\/\n    if (client->remote_auth == FALSE) {\n        xmlNode *reg;\n#if ENABLE_ACL\n        const char *user = NULL;\n#endif\n        command = crm_parse_remote_buffer(&client->recv_buf);\n        if (cib_remote_auth(command) == FALSE) {\n            free_xml(command);\n            return -1;\n        }\n\n        crm_debug(\"remote connection authenticated successfully\");\n        client->remote_auth = TRUE;\n        g_source_remove(client->remote_auth_timeout);\n        client->remote_auth_timeout = 0;\n        client->name = crm_element_value_copy(command, \"name\");\n\n#if ENABLE_ACL\n        user = crm_element_value(command, \"user\");\n        if (user) {\n           new_client->user = strdup(user);\n        }\n#endif\n\n        \/* send ACK *\/\n        reg = create_xml_node(NULL, \"cib_result\");\n        crm_xml_add(reg, F_CIB_OPERATION, CRM_OP_REGISTER);\n        crm_xml_add(reg, F_CIB_CLIENTID, client->id);\n        crm_send_remote_msg(client->session, reg, client->encrypted);\n        free_xml(reg);\n        free_xml(command);\n    }\n\n    command = crm_parse_remote_buffer(&client->recv_buf);\n    while (command) {\n        crm_trace(\"command received\");\n        cib_handle_remote_msg(client, command);\n        free_xml(command);\n        command = crm_parse_remote_buffer(&client->recv_buf);\n    }\n\n    if (disconnected) {\n        crm_trace(\"disconnected while receiving remote cib msg.\");\n        return -1;\n    }\n\n    return 0;\n}","target":0,"flaw_line_index":0,"hash":"fc34ea6c-cdfb-422e-acf4-1e3bfcb14d93","idx":"c5fe76b9-688a-4de8-bf20-fc8c5a091fac"}
{"func_before":"  if (overflow2(sizeof(unsigned char *), sy)) {\n    return NULL;\n  }\n\n  if (overflow2(sizeof(int) + sizeof(unsigned char), sx * sy)) {\n    return NULL;\n  }\n\n  \/\/ Check for OOM before doing a potentially large allocation.\n  auto allocsz = sizeof(gdImage)\n    + sy * (sizeof(int *) + sizeof(unsigned char *))\n    + sx * sy * (sizeof(int) + sizeof(unsigned char));\n  if (UNLIKELY(precheckOOM(allocsz))) {\n    \/\/ Don't throw here because GD might need to do its own cleanup.\n    return NULL;\n  }\n\n  im = (gdImage *) gdMalloc(sizeof(gdImage));\n  memset(im, 0, sizeof(gdImage));\n  im->tpixels = (int **) gdMalloc(sizeof(int *) * sy);\n  im->AA_opacity = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n  im->polyInts = 0;","target":1,"flaw_line_index":0,"hash":"08346ad5-6056-4f32-9541-387f36497dea","idx":"c7d5c5b1-8f9a-4eda-bfd8-b9cf8deb0db3"}
{"func_before":"  if (overflow2(sizeof(unsigned char *), sy)) {\n    return NULL;\n  }\n\n  if (overflow2(sizeof(int) + sizeof(unsigned char), sx * sy)) {\n    return NULL;\n  }\n\n  \/\/ Check for OOM before doing a potentially large allocation.\n  auto allocsz = sizeof(gdImage)\n    + (sizeof(int *) + sizeof(unsigned char *)) * sy\n    + (sizeof(int) + sizeof(unsigned char)) * sx * sy;\n  if (UNLIKELY(precheckOOM(allocsz))) {\n    \/\/ Don't throw here because GD might need to do its own cleanup.\n    return NULL;\n  }\n\n  im = (gdImage *) gdMalloc(sizeof(gdImage));\n  memset(im, 0, sizeof(gdImage));\n  im->tpixels = (int **) gdMalloc(sizeof(int *) * sy);\n  im->AA_opacity = (unsigned char **) gdMalloc(sizeof(unsigned char *) * sy);\n  im->polyInts = 0;","target":0,"flaw_line_index":0,"hash":"47f2fe9d-6d24-4da8-a8b3-6f77afe719b3","idx":"e0a219f4-73ff-4223-8134-4b7eb258b6b1"}
{"func_before":"TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                        int index) {\n  if (index >= 0 && index < node->outputs->size) {\n    const int tensor_index = node->outputs->data[index];\n    if (tensor_index != kTfLiteOptionalTensor) {\n      if (context->tensors != nullptr) {\n        return &context->tensors[tensor_index];\n      } else {\n        return context->GetTensor(context, tensor_index);\n      }\n    }\n  }\n  return nullptr;\n}","target":1,"flaw_line_index":0,"hash":"0f39fd42-17ec-4f32-9e33-1a6e78ab5edd","idx":"f8c92ce6-ce0d-41f9-a10f-35431a1ad3ca"}
{"func_before":"TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                        int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->outputs->size, node->outputs->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}","target":0,"flaw_line_index":0,"hash":"00cd7fb5-a7e8-4b23-a83e-f3bad73fb7f0","idx":"8c52ce32-a8f2-401d-83b8-dcfb9a275758"}
{"func_before":"          \"Data of TensorProto ( tensor name: \",\n          tensor.name(),\n          \") is stored externally and should not have data field.\",\n          value_field);\n    }\n\n    bool has_location = false;\n    for (const StringStringEntryProto& entry : tensor.external_data()) {\n      if (entry.has_key() && entry.has_value() && entry.key() == \"location\") {\n        has_location = true;\n        std::string data_path = path_join(ctx.get_model_dir(), entry.value());\n        \/\/ use stat to check whether the file exists\n        struct stat buffer;\n        if (stat((data_path).c_str(), &buffer) != 0) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be stored in \",\n              data_path,\n              \", but it doesn't exist or is not accessible.\");\n        }\n      }\n    }\n    if (!has_location) {\n      fail_check(\"TensorProto ( tensor name: \", tensor.name(), \") is stored externally but doesn't have a location.\");\n    }\n    return;\n  }\n  int64_t nelem = 1;\n  for (auto x : tensor.dims()) {\n    nelem *= x;","target":1,"flaw_line_index":0,"hash":"348a3fa9-58b3-441c-a711-5f797ec5fc80","idx":"886aedfd-5a81-4743-b768-fbd2d06f4b1b"}
{"func_before":"          \"Data of TensorProto ( tensor name: \",\n          tensor.name(),\n          \") is stored externally and should not have data field.\",\n          value_field);\n    }\n\n    bool has_location = false;\n    for (const StringStringEntryProto& entry : tensor.external_data()) {\n      if (entry.has_key() && entry.has_value() && entry.key() == \"location\") {\n        has_location = true;\n        std::string relative_path = clean_relative_path(entry.value());\n        \/\/ Check that normalized relative path starts with \"..\/\" or \"..\\\" on windows.\n        if (relative_path.rfind(\"..\" + k_preferred_path_separator, 0) == 0) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be file inside the \",\n              ctx.get_model_dir(),\n              \", but the '\",\n              entry.value(),\n              \"' points outside the directory\");\n        }\n\n        std::string data_path = path_join(ctx.get_model_dir(), relative_path);\n        \/\/ use stat to check whether the file exists\n        struct stat buffer;\n        if (stat((data_path).c_str(), &buffer) != 0) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be stored in \",\n              data_path,\n              \", but it doesn't exist or is not accessible.\");\n        }\n#ifdef _WIN32\n#else \/\/ POSIX\n      \/\/  Do not allow symlinks or directories.\n        if (!S_ISREG(buffer.st_mode)) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be stored in \",\n              data_path,\n              \", but it is not regular file.\");\n        }\n#endif\n      }\n    }\n    if (!has_location) {\n      fail_check(\"TensorProto ( tensor name: \", tensor.name(), \") is stored externally but doesn't have a location.\");\n    }\n    return;\n  }\n  int64_t nelem = 1;\n  for (auto x : tensor.dims()) {\n    nelem *= x;","target":0,"flaw_line_index":0,"hash":"3eccb878-ce0f-4cd4-8f2e-66a5c60a7328","idx":"a94c1c14-3d71-4798-963d-1d4401be39b8"}
{"func_before":"  PyObject *__pyx_v_state = 0;\n  PyObject *__pyx_v__dict = 0;\n  int __pyx_v_use_setstate;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  int __pyx_t_5;\n  int __pyx_t_6;\n  __Pyx_RefNannySetupContext(\"__reduce_cython__\", 0);\n\n  \/* \"(tree fragment)\":5\n *     cdef object _dict\n *     cdef bint use_setstate\n *     state = (self.buffer, self.buffer_size, self.position)             # <<<<<<<<<<<<<<\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:\n *\/\n  __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->buffer); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->buffer_size); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_self->position); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __Pyx_GIVEREF(__pyx_t_1);\n  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1);\n  __Pyx_GIVEREF(__pyx_t_2);\n  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2);\n  __Pyx_GIVEREF(__pyx_t_3);\n  PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_3);\n  __pyx_t_1 = 0;","target":1,"flaw_line_index":0,"hash":"4c5244df-1f64-43a3-9305-27871516b31b","idx":"230c1c1f-eca8-4da8-97cb-7e864abe5a33"}
{"func_before":"  PyObject *__pyx_v__dict = 0;\n  int __pyx_v_use_setstate;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  int __pyx_t_5;\n  int __pyx_t_6;\n  int __pyx_lineno = 0;\n  const char *__pyx_filename = NULL;\n  int __pyx_clineno = 0;\n  __Pyx_RefNannySetupContext(\"__reduce_cython__\", 0);\n\n  \/* \"(tree fragment)\":5\n *     cdef object _dict\n *     cdef bint use_setstate\n *     state = (self.buffer, self.buffer_size, self.position)             # <<<<<<<<<<<<<<\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:\n *\/\n  __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->buffer); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = __Pyx_PyInt_From_unsigned_PY_LONG_LONG(__pyx_v_self->buffer_size); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_3 = __Pyx_PyInt_From_unsigned_PY_LONG_LONG(__pyx_v_self->position); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __Pyx_GIVEREF(__pyx_t_1);\n  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1);\n  __Pyx_GIVEREF(__pyx_t_2);\n  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2);\n  __Pyx_GIVEREF(__pyx_t_3);\n  PyTuple_SET_ITEM(__pyx_t_4, 2, __pyx_t_3);\n  __pyx_t_1 = 0;","target":0,"flaw_line_index":0,"hash":"4e8d141e-06c5-4577-b448-ac2e82c49de9","idx":"5c4782ab-1a00-4252-a0e0-e770df45be91"}
{"func_before":"void* ipc_alloc(int size)\n{\n\tvoid* out;\n\tif(size > PAGE_SIZE)\n\t\tout = vmalloc(size);\n\telse\n\t\tout = kmalloc(size, GFP_KERNEL);\n\treturn out;\n}","target":1,"flaw_line_index":0,"hash":"66742f2b-11a2-4633-afd2-3d54874e5f40","idx":"8f94837e-7948-42fa-a35d-4ca9628bbe3e"}
{"func_before":"void *ipc_alloc(int size)\n{\n\tvoid *out;\n\tif(size > PAGE_SIZE)\n\t\tout = vmalloc(size);\n\telse\n\t\tout = kmalloc(size, GFP_KERNEL);\n\treturn out;\n}","target":0,"flaw_line_index":0,"hash":"45d6fcec-c4c2-446b-9aef-628fd6ead358","idx":"49f7f5f2-9951-438a-9f26-d6aa6963a0e8"}
{"func_before":"        {\n          ec = CreateRestrictedDirectory(state_temp_dir);\n        }\n        else\n        {\n          ec = CreateNormalDirectory(state_temp_dir);\n        }\n\n        if (ec)\n        {\n          \/\/ Delete previous uninstaller\n          if (DeleteFile(unexe))\n          {\n            myDelete(state_temp_dir, DEL_DIR|DEL_RECURSE);\n            if (!retry++) goto retry_un_dir;\n          }\n        }\n        else\n        {\n          HANDLE hProc;\n          SetCurrentDirectory(state_temp_dir);\n#ifdef NSIS_SUPPORT_MOVEONREBOOT\n          MoveFileOnReboot(state_temp_dir, NULL);\n#endif","target":1,"flaw_line_index":0,"hash":"cfb75ddb-8ce0-48f9-88dd-7e553d1e9692","idx":"6b9091c3-26a1-4025-80ab-e38d0c16fb8e"}
{"func_before":"        {\n          ec = CreateRestrictedDirectory(state_temp_dir);\n        }\n        else\n        {\n          ec = CreateNormalDirectory(state_temp_dir);\n        }\n\n        if (ec)\n        {\n          \/\/ Delete previous uninstaller (if it is safe to do so)\n          if (!(GetFileAttributes(unexe) & FILE_ATTRIBUTE_REPARSE_POINT) && DeleteFile(unexe))\n          {\n            myDelete(state_temp_dir, DEL_DIR);\n            if (!retry++) goto retry_un_dir;\n          }\n        }\n        else\n        {\n          HANDLE hProc;\n          SetCurrentDirectory(state_temp_dir);\n#ifdef NSIS_SUPPORT_MOVEONREBOOT\n          MoveFileOnReboot(state_temp_dir, NULL);\n#endif","target":0,"flaw_line_index":0,"hash":"bc15dbd3-c1e0-49d0-9613-1904c3e9a63a","idx":"f7f73520-583b-4fc2-80e6-bd329369066b"}
{"func_before":"\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\n\t    \/\/ insert the new text\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\n\t\t\/\/ insert block's trailing spaces only if there's text behind\n\t\tif ((j < count - 1 || !shortline) && spaces)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t\telse\n\t\t    totlen -= spaces;  \/\/ didn't use these spaces\n\t    }\n\n\t    \/\/ may insert some spaces after the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t\t    ++curwin->w_cursor.lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t\/\/ put cursor on first inserted character\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\n\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);","target":1,"flaw_line_index":0,"hash":"ae09c9de-ffe3-4e34-bde4-42d78b2e2688","idx":"f060ca9e-9916-4c1d-993c-134ea9dcf8dc"}
{"func_before":"\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\n\t    \/\/ insert the new text\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\n\t\t\/\/ insert block's trailing spaces only if there's text behind\n\t\tif ((j < count - 1 || !shortline) && spaces > 0)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t\telse\n\t\t    totlen -= spaces;  \/\/ didn't use these spaces\n\t    }\n\n\t    \/\/ may insert some spaces after the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t\/\/ put cursor on first inserted character\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\n\n    \/\/ Make sure the cursor is not after the NUL.\n    int len = (int)STRLEN(ml_get_curline());\n    if (curwin->w_cursor.col > len)\n    {\n\tif (cur_ve_flags == VE_ALL)\n\t    curwin->w_cursor.coladd = curwin->w_cursor.col - len;\n\tcurwin->w_cursor.col = len;\n    }\n\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);","target":0,"flaw_line_index":0,"hash":"6ffb7fc4-6180-4bda-84af-fa37bd70959f","idx":"3799c6c0-c50d-42bc-bf59-e4b0216902b8"}
{"func_before":"bool RepeatedAttrDefEqual(\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a1,\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {\n  std::unordered_map<string, const OpDef::AttrDef*> a1_set;\n  for (const OpDef::AttrDef& def : a1) {\n    DCHECK(a1_set.find(def.name()) == a1_set.end())\n        << \"AttrDef names must be unique, but '\" << def.name()\n        << \"' appears more than once\";\n    a1_set[def.name()] = &def;\n  }\n  for (const OpDef::AttrDef& def : a2) {\n    auto iter = a1_set.find(def.name());\n    if (iter == a1_set.end()) return false;\n    if (!AttrDefEqual(*iter->second, def)) return false;\n    a1_set.erase(iter);\n  }\n  if (!a1_set.empty()) return false;\n  return true;","target":1,"flaw_line_index":0,"hash":"6a2ef149-5171-40fe-8910-d11f155f5057","idx":"5e192974-37e0-47ae-a836-b45f4991e407"}
{"func_before":"bool RepeatedAttrDefEqual(\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a1,\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {\n  std::unordered_map<string, const OpDef::AttrDef*> a1_set;\n  for (const OpDef::AttrDef& def : a1) {\n    if (a1_set.find(def.name()) != a1_set.end()) {\n      LOG(ERROR) << \"AttrDef names must be unique, but '\" << def.name()\n                 << \"' appears more than once\";\n    }\n    a1_set[def.name()] = &def;\n  }\n  for (const OpDef::AttrDef& def : a2) {\n    auto iter = a1_set.find(def.name());\n    if (iter == a1_set.end()) return false;\n    if (!AttrDefEqual(*iter->second, def)) return false;\n    a1_set.erase(iter);\n  }\n  if (!a1_set.empty()) return false;\n  return true;","target":0,"flaw_line_index":0,"hash":"24d136ac-5e2a-4698-bd15-b1e09d0c512c","idx":"2b242375-d8a9-4a67-9d14-775f763b100e"}
{"func_before":"static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct device *dev = &intf->dev;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct net_device *netdev;\n\tstruct catc *catc;\n\tu8 broadcast[ETH_ALEN];\n\tint i, pktsz, ret;\n\n\tif (usb_set_interface(usbdev,\n\t\t\tintf->altsetting->desc.bInterfaceNumber, 1)) {\n\t\tdev_err(dev, \"Can't set altsetting 1.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tnetdev = alloc_etherdev(sizeof(struct catc));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\n\tusb_fill_bulk_urb(catc->tx_urb, usbdev, usb_sndbulkpipe(usbdev, 1),\n\t\tNULL, 0, catc_tx_done, catc);\n\n\tusb_fill_bulk_urb(catc->rx_urb, usbdev, usb_rcvbulkpipe(usbdev, 1),\n\t\tcatc->rx_buf, pktsz, catc_rx_done, catc);\n\n\tusb_fill_int_urb(catc->irq_urb, usbdev, usb_rcvintpipe(usbdev, 2),\n                catc->irq_buf, 2, catc_irq_done, catc, 1);\n\n\tif (!catc->is_f5u011) {\n\t\tdev_dbg(dev, \"Checking memory size\\n\");\n\n\t\ti = 0x12345678;\n\t\tcatc_write_mem(catc, 0x7a80, &i, 4);\n\t\ti = 0x87654321;\t\n\t\tcatc_write_mem(catc, 0xfa80, &i, 4);\n\t\tcatc_read_mem(catc, 0x7a80, &i, 4);\n\t  \n\t\tswitch (i) {\n\t\tcase 0x12345678:\n\t\t\tcatc_set_reg(catc, TxBufCount, 8);\n\t\t\tcatc_set_reg(catc, RxBufCount, 32);\n\t\t\tdev_dbg(dev, \"64k Memory\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&intf->dev,\n\t\t\t\t \"Couldn't detect memory size, assuming 32k\\n\");\n\t\tcase 0x87654321:\n\t\t\tcatc_set_reg(catc, TxBufCount, 4);\n\t\t\tcatc_set_reg(catc, RxBufCount, 16);\n\t\t\tdev_dbg(dev, \"32k Memory\\n\");\n\t\t\tbreak;\n\t\t}\n\t  \n\t\tdev_dbg(dev, \"Getting MAC from SEEROM.\\n\");\n\t  \n\t\tcatc_get_mac(catc, netdev->dev_addr);\n\t\t\n\t\tdev_dbg(dev, \"Setting MAC into registers.\\n\");\n\t  \n\t\tfor (i = 0; i < 6; i++)\n\t\t\tcatc_set_reg(catc, StationAddr0 - i, netdev->dev_addr[i]);\n\t\t","target":1,"flaw_line_index":0,"hash":"ce545fe3-b85f-434f-899a-1728682f6949","idx":"b00388af-1273-431d-b10c-b5cc97a1c373"}
{"func_before":"static int catc_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct device *dev = &intf->dev;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct net_device *netdev;\n\tstruct catc *catc;\n\tu8 broadcast[ETH_ALEN];\n\tint pktsz, ret;\n\n\tif (usb_set_interface(usbdev,\n\t\t\tintf->altsetting->desc.bInterfaceNumber, 1)) {\n\t\tdev_err(dev, \"Can't set altsetting 1.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tnetdev = alloc_etherdev(sizeof(struct catc));\n\tif (!netdev)\n\t\treturn -ENOMEM;\n\tusb_fill_bulk_urb(catc->tx_urb, usbdev, usb_sndbulkpipe(usbdev, 1),\n\t\tNULL, 0, catc_tx_done, catc);\n\n\tusb_fill_bulk_urb(catc->rx_urb, usbdev, usb_rcvbulkpipe(usbdev, 1),\n\t\tcatc->rx_buf, pktsz, catc_rx_done, catc);\n\n\tusb_fill_int_urb(catc->irq_urb, usbdev, usb_rcvintpipe(usbdev, 2),\n                catc->irq_buf, 2, catc_irq_done, catc, 1);\n\n\tif (!catc->is_f5u011) {\n\t\tu32 *buf;\n\t\tint i;\n\n\t\tdev_dbg(dev, \"Checking memory size\\n\");\n\n\t\tbuf = kmalloc(4, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_free;\n\t\t}\n\n\t\t*buf = 0x12345678;\n\t\tcatc_write_mem(catc, 0x7a80, buf, 4);\n\t\t*buf = 0x87654321;\n\t\tcatc_write_mem(catc, 0xfa80, buf, 4);\n\t\tcatc_read_mem(catc, 0x7a80, buf, 4);\n\t  \n\t\tswitch (*buf) {\n\t\tcase 0x12345678:\n\t\t\tcatc_set_reg(catc, TxBufCount, 8);\n\t\t\tcatc_set_reg(catc, RxBufCount, 32);\n\t\t\tdev_dbg(dev, \"64k Memory\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(&intf->dev,\n\t\t\t\t \"Couldn't detect memory size, assuming 32k\\n\");\n\t\tcase 0x87654321:\n\t\t\tcatc_set_reg(catc, TxBufCount, 4);\n\t\t\tcatc_set_reg(catc, RxBufCount, 16);\n\t\t\tdev_dbg(dev, \"32k Memory\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree(buf);\n\t  \n\t\tdev_dbg(dev, \"Getting MAC from SEEROM.\\n\");\n\t  \n\t\tcatc_get_mac(catc, netdev->dev_addr);\n\t\t\n\t\tdev_dbg(dev, \"Setting MAC into registers.\\n\");\n\t  \n\t\tfor (i = 0; i < 6; i++)\n\t\t\tcatc_set_reg(catc, StationAddr0 - i, netdev->dev_addr[i]);\n\t\t","target":0,"flaw_line_index":0,"hash":"64901bfd-f6a3-454e-90db-d98903af5f38","idx":"40d925b5-973f-4385-84e2-eaf9fd2665d8"}
{"func_before":"    Check_Type(indent, T_STRING);\n    len = RSTRING_LEN(indent);\n    if (len == 0) {\n        if (state->indent) {\n            ruby_xfree(state->indent);\n            state->indent = NULL;\n            state->indent_len = 0;\n        }\n    } else {\n        if (state->indent) ruby_xfree(state->indent);\n        state->indent = strdup(RSTRING_PTR(indent));\n        state->indent_len = len;\n    }\n    return Qnil;\n}","target":1,"flaw_line_index":0,"hash":"1be1cb59-4686-4ca4-8821-eac4b6db11a2","idx":"1945552d-6271-4e63-8794-03ed59be8cd7"}
{"func_before":"    Check_Type(indent, T_STRING);\n    len = RSTRING_LEN(indent);\n    if (len == 0) {\n        if (state->indent) {\n            ruby_xfree(state->indent);\n            state->indent = NULL;\n            state->indent_len = 0;\n        }\n    } else {\n        if (state->indent) ruby_xfree(state->indent);\n        state->indent = fstrndup(RSTRING_PTR(indent), len);\n        state->indent_len = len;\n    }\n    return Qnil;\n}","target":0,"flaw_line_index":0,"hash":"0fd3b707-eb98-480f-9e9f-e6d298130bb9","idx":"d7f71166-5324-4f88-9391-2f91aaaeafb4"}
{"func_before":"  void event_cb(drachtio::RequestHandler::GlobalInfo *g, curl_socket_t s,\n                       int action, const boost::system::error_code & error,\n                       int *fdp) {\n    std::shared_ptr<RequestHandler> p = RequestHandler::getInstance() ;\n    std::map<curl_socket_t, boost::asio::ip::tcp::socket *>& socket_map = p->getSocketMap() ;\n    boost::asio::deadline_timer& timer = p->getTimer() ;\n\n    if(socket_map.find(s) == socket_map.end()) {\n      DR_LOG(log_error) << \"event_cb: socket already closed\";\n      return;\n    }\n\n    \/* make sure the event matches what are wanted *\/\n    if(*fdp == action || *fdp == CURL_POLL_INOUT) {\n      CURLMcode rc;\n      if(error)\n        action = CURL_CSELECT_ERR;\n      rc = curl_multi_socket_action(g->multi, s, action, &g->still_running);\n\n      mcode_test(\"event_cb: curl_multi_socket_action\", rc);\n      check_multi_info(g);\n\n      if(g->still_running <= 0) {\n        timer.cancel();\n      }\n\n      \/* keep on watching.\n       * the socket may have been closed and\/or fdp may have been changed\n       * in curl_multi_socket_action(), so check them both *\/\n      if(!error && socket_map.find(s) != socket_map.end() &&\n         (*fdp == action || *fdp == CURL_POLL_INOUT)) {\n        boost::asio::ip::tcp::socket *tcp_socket = socket_map.find(s)->second;\n\n        if(action == CURL_POLL_IN) {\n          tcp_socket->async_read_some(boost::asio::null_buffers(),\n                                      boost::bind(&event_cb, g, s,\n                                                  action, boost::placeholders::_1, fdp));\n        }\n        if(action == CURL_POLL_OUT) {\n          tcp_socket->async_write_some(boost::asio::null_buffers(),\n                                       boost::bind(&event_cb, g, s,","target":1,"flaw_line_index":0,"hash":"11ab5f73-ff3d-4959-8b4a-47dfb4a5654f","idx":"30e3fbe3-794d-45a4-8928-98a565267dc9"}
{"func_before":"  void event_cb(drachtio::RequestHandler::GlobalInfo *g, curl_socket_t s,\n                       int action, const boost::system::error_code & error,\n                       int *fdp) {\n    int f = *fdp;\n    std::shared_ptr<RequestHandler> p = RequestHandler::getInstance() ;\n    std::map<curl_socket_t, boost::asio::ip::tcp::socket *>& socket_map = p->getSocketMap() ;\n    boost::asio::deadline_timer& timer = p->getTimer() ;\n\n    if(socket_map.find(s) == socket_map.end()) {\n      DR_LOG(log_error) << \"event_cb: socket already closed\";\n      return;\n    }\n\n    \/* make sure the event matches what are wanted *\/\n    if(f == action || f == CURL_POLL_INOUT) {\n      CURLMcode rc;\n      if(error)\n        action = CURL_CSELECT_ERR;\n      rc = curl_multi_socket_action(g->multi, s, action, &g->still_running);\n\n      mcode_test(\"event_cb: curl_multi_socket_action\", rc);\n      check_multi_info(g);\n\n      if(g->still_running <= 0) {\n        timer.cancel();\n      }\n\n      \/* keep on watching.\n       * the socket may have been closed and\/or fdp may have been changed\n       * in curl_multi_socket_action(), so check them both *\/\n      if(!error && socket_map.find(s) != socket_map.end() &&\n         (f == action || f == CURL_POLL_INOUT)) {\n        boost::asio::ip::tcp::socket *tcp_socket = socket_map.find(s)->second;\n\n        if(action == CURL_POLL_IN) {\n          tcp_socket->async_read_some(boost::asio::null_buffers(),\n                                      boost::bind(&event_cb, g, s,\n                                                  action, boost::placeholders::_1, fdp));\n        }\n        if(action == CURL_POLL_OUT) {\n          tcp_socket->async_write_some(boost::asio::null_buffers(),\n                                       boost::bind(&event_cb, g, s,","target":0,"flaw_line_index":0,"hash":"a4dc048b-5cb2-48eb-95bd-38280a892772","idx":"9a0c5778-d4fd-44d7-8eb8-44a32db293d8"}
{"func_before":"        else\n        {\n            if (b2->size ==0)\n            {\n                \/\/ b2->size = 0, whatever b1->size is, do nothing\n                result = 0;\n            }\n            else\n            {\n                \/\/ b2->size != 0, whatever b1->size is\n                unsigned char* temp = (unsigned char*)realloc(b1->buffer, b1->size + b2->size);\n                if (temp == NULL)\n                {\n                    \/* Codes_SRS_BUFFER_07_023: [BUFFER_append shall return a nonzero upon any error that is encountered.] *\/\n                    LogError(\"Failure: allocating temp buffer.\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    \/* Codes_SRS_BUFFER_07_024: [BUFFER_append concatenates b2 onto b1 without modifying b2 and shall return zero on success.]*\/\n                    b1->buffer = temp;\n                    \/\/ Append the BUFFER","target":1,"flaw_line_index":0,"hash":"703d8f20-5ff3-42db-a768-b797301cd8a0","idx":"16bee21a-d2e9-47a2-bf20-fd03f95de7c0"}
{"func_before":"        else\n        {\n            if (b2->size ==0)\n            {\n                \/\/ b2->size = 0, whatever b1->size is, do nothing\n                result = 0;\n            }\n            else\n            {\n                \/\/ b2->size != 0, whatever b1->size is\n                unsigned char* temp;\n                size_t malloc_size = safe_add_size_t(b1->size, b2->size);\n                if (malloc_size == SIZE_MAX || \n                    (temp = (unsigned char*)realloc(b1->buffer, malloc_size)) == NULL)\n                {\n                    \/* Codes_SRS_BUFFER_07_023: [BUFFER_append shall return a nonzero upon any error that is encountered.] *\/\n                    LogError(\"Failure: allocating temp buffer.\");\n                    result = MU_FAILURE;\n                }\n                else\n                {\n                    \/* Codes_SRS_BUFFER_07_024: [BUFFER_append concatenates b2 onto b1 without modifying b2 and shall return zero on success.]*\/\n                    b1->buffer = temp;\n                    \/\/ Append the BUFFER","target":0,"flaw_line_index":0,"hash":"ce938fad-ee67-4627-95ca-5770e167f89d","idx":"410c9509-738f-4205-b0da-0840786509fd"}
{"func_before":"njs_vm_start(njs_vm_t *vm)\n{\n    njs_int_t  ret;\n\n    ret = njs_module_load(vm);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_vmcode_interpreter(vm, vm->start);\n\n    return (ret == NJS_ERROR) ? NJS_ERROR : NJS_OK;\n}","target":1,"flaw_line_index":0,"hash":"90c177f6-4525-462d-af36-78316c265e2f","idx":"418eaba2-b980-4039-b00d-9bf006104eb7"}
{"func_before":"njs_vm_start(njs_vm_t *vm)\n{\n    njs_int_t  ret;\n\n    ret = njs_module_load(vm);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_vmcode_interpreter(vm, vm->start, NULL, NULL);\n\n    return (ret == NJS_ERROR) ? NJS_ERROR : NJS_OK;\n}","target":0,"flaw_line_index":0,"hash":"228047a2-dd4d-4cbf-8130-87fdff278b31","idx":"634f0ba1-ffea-4e82-8e15-303c747655e8"}
{"func_before":"\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}","target":1,"flaw_line_index":0,"hash":"c94fdc93-89e4-427a-812c-e691490ec155","idx":"624bf0e2-a39a-4ace-aede-1725206d373e"}
{"func_before":"\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset\n\t    < sizeof(struct ipt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}","target":0,"flaw_line_index":0,"hash":"ca079fdf-950f-4cf4-be0c-614218e70b0e","idx":"36eff65f-351d-4790-908a-428e3b0e0dcc"}
{"func_before":"static pj_status_t ssl_on_recv_packet(dtls_srtp *ds, unsigned idx,\n                                      const void *data, pj_size_t len)\n{\n    char tmp[128];\n    pj_size_t nwritten;\n\n    pj_lock_acquire(ds->ossl_lock);\n\n    if (!ds->ossl_rbio[idx]) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_EGONE;\n    }\n\n    nwritten = BIO_write(ds->ossl_rbio[idx], data, (int)len);\n    if (nwritten < len) {\n        \/* Error? *\/\n        pj_status_t status;\n        status = GET_SSL_STATUS(ds);\n#if DTLS_DEBUG\n        pj_perror(2, ds->base.name, status, \"BIO_write() error\");\n#endif\n        pj_lock_release(ds->ossl_lock);\n        return status;\n    }\n\n    if (!ds->ossl_ssl[idx]) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_EGONE;\n    }\n\n    \/* Consume (and ignore) the packet *\/\n    while (1) {\n        int rc = SSL_read(ds->ossl_ssl[idx], tmp, sizeof(tmp));\n        if (rc <= 0) {\n#if DTLS_DEBUG\n            pj_status_t status = GET_SSL_STATUS(ds);\n            if (status != PJ_SUCCESS)\n                pj_perror(2, ds->base.name, status, \"SSL_read() error\");\n#endif\n            break;\n        }\n    }\n\n    pj_lock_release(ds->ossl_lock);\n\n    \/* Flush anything pending in the write BIO *\/\n    return ssl_flush_wbio(ds, idx);\n}","target":1,"flaw_line_index":0,"hash":"9ec74809-d55e-4060-ac14-174a8747dc82","idx":"8f694c01-7da3-4f09-a28c-aa6552a35eb2"}
{"func_before":"static pj_status_t ssl_on_recv_packet(dtls_srtp *ds, unsigned idx,\n                                      const void *data, pj_size_t len)\n{\n    char tmp[128];\n    pj_size_t nwritten;\n\n    DTLS_LOCK(ds);\n\n    if (!ds->ossl_rbio[idx]) {\n        DTLS_UNLOCK(ds);\n        return PJ_EGONE;\n    }\n\n    nwritten = BIO_write(ds->ossl_rbio[idx], data, (int)len);\n    if (nwritten < len) {\n        \/* Error? *\/\n        pj_status_t status;\n        status = GET_SSL_STATUS(ds);\n#if DTLS_DEBUG\n        pj_perror(2, ds->base.name, status, \"BIO_write() error\");\n#endif\n        DTLS_UNLOCK(ds);\n        return status;\n    }\n\n    if (!ds->ossl_ssl[idx]) {\n        DTLS_UNLOCK(ds);\n        return PJ_EGONE;\n    }\n\n    \/* Consume (and ignore) the packet *\/\n    while (1) {\n        int rc = SSL_read(ds->ossl_ssl[idx], tmp, sizeof(tmp));\n        if (rc <= 0) {\n#if DTLS_DEBUG\n            pj_status_t status = GET_SSL_STATUS(ds);\n            if (status != PJ_SUCCESS)\n                pj_perror(2, ds->base.name, status, \"SSL_read() error\");\n#endif\n            break;\n        }\n    }\n\n    DTLS_UNLOCK(ds);\n\n    \/* Flush anything pending in the write BIO *\/\n    return ssl_flush_wbio(ds, idx);\n}","target":0,"flaw_line_index":0,"hash":"56659f4b-0e04-4fce-9073-51c2bfd89e95","idx":"6f6904be-5e48-4467-aaf2-477db32d21c7"}
{"func_before":"FdOutStream::FdOutStream(int fd_, bool blocking_, int timeoutms_, int bufSize_)\n  : fd(fd_), blocking(blocking_), timeoutms(timeoutms_),\n    bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)\n{\n  ptr = start = sentUpTo = new U8[bufSize];\n  end = start + bufSize;\n\n  gettimeofday(&lastWrite, NULL);\n}","target":1,"flaw_line_index":0,"hash":"c84853b7-a3e8-4351-85c9-d1265df37fb3","idx":"223ad123-7793-43fb-a7d3-9ddf80934f98"}
{"func_before":"FdOutStream::FdOutStream(int fd_, bool blocking_, int timeoutms_, size_t bufSize_)\n  : fd(fd_), blocking(blocking_), timeoutms(timeoutms_),\n    bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)\n{\n  ptr = start = sentUpTo = new U8[bufSize];\n  end = start + bufSize;\n\n  gettimeofday(&lastWrite, NULL);\n}","target":0,"flaw_line_index":0,"hash":"85e96731-738e-4129-b54e-ed8c41ca3804","idx":"3462d1f9-bc06-4444-b01e-4407cd4c81b9"}
{"func_before":"static ssize_t _hostfs_pwrite(\n    oe_fd_t* desc,\n    const void* buf,\n    size_t count,\n    oe_off_t offset)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_pwrite_ocall(&ret, file->host_fd, buf, count, offset) !=\n        OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}","target":1,"flaw_line_index":0,"hash":"3a7c7933-f1ca-4ef4-8e74-7a8e5ed41c3d","idx":"570becc6-f718-4844-b785-af9e99df0b37"}
{"func_before":"static ssize_t _hostfs_pwrite(\n    oe_fd_t* desc,\n    const void* buf,\n    size_t count,\n    oe_off_t offset)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    \/*\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https:\/\/pubs.opengroup.org\/onlinepubs\/9699919799\/functions\/pwrite.html\n     * for more detail.\n     *\/\n    if (!file || count > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_pwrite_ocall(&ret, file->host_fd, buf, count, offset) !=\n        OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    \/*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed count.\n     *\/\n    if (ret > (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}","target":0,"flaw_line_index":0,"hash":"1f03292f-b64e-45dc-a6f4-f628acdebd23","idx":"081c5520-e0a2-4adc-88d4-3dc697399e26"}
{"func_before":"void HeaderTable::setCapacity(uint32_t capacity) {\n  auto oldCapacity = capacity_;\n  capacity_ = capacity;\n  if (capacity_ <= oldCapacity) {\n    evict(0);\n  } else {\n    auto oldTail = tail();\n    auto oldLength = table_.size();\n    uint32_t newLength = (capacity_ >> 5) + 1;\n    table_.resize(newLength);\n    if (size_ > 0 && oldTail > head_) {\n      \/\/ the list wrapped around, need to move oldTail..oldLength to the end of\n      \/\/ the now-larger table_\n      std::copy(table_.begin() + oldTail, table_.begin() + oldLength,\n                table_.begin() + newLength - (oldLength - oldTail));\n      \/\/ Update the names indecies that pointed to the old range\n      for (auto& names_it: names_) {\n        for (auto& idx: names_it.second) {\n          if (idx >= oldTail) {\n            DCHECK_LT(idx + (table_.size() - oldLength), table_.size());\n            idx += (table_.size() - oldLength);\n          } else {\n            \/\/ remaining indecies in the list were smaller than oldTail, so\n            \/\/ should be indexed from 0\n            break;\n          }\n        }\n      }\n    }\n  }\n}","target":1,"flaw_line_index":0,"hash":"26b358de-509d-4a58-9d6f-cc8648d8e074","idx":"3e54b6c9-b10a-45dc-8ee3-c783e7619531"}
{"func_before":"void HeaderTable::setCapacity(uint32_t capacity) {\n  \/\/ TODO: ddmello - the below is a little dangerous as we update the\n  \/\/ capacity right away.  Some properties of the class utilize that variable\n  \/\/ and so might be better to refactor and update capacity at the end of the\n  \/\/ method (and update other methods)\n  auto oldCapacity = capacity_;\n  capacity_ = capacity;\n  if (capacity_ == oldCapacity) {\n    return;\n  } else if (capacity_ < oldCapacity) {\n    \/\/ NOTE: currently no actual resizing is performed...\n    evict(0);\n  } else {\n    \/\/ NOTE: due to the above lack of resizing, we must determine whether a\n    \/\/ resize is actually appropriate (to handle cases where the underlying\n    \/\/ vector is still >= to the size related to the new capacity requested)\n    uint32_t newLength = (capacity_ >> 5) + 1;\n    if (newLength > table_.size()) {\n      auto oldTail = tail();\n      auto oldLength = table_.size();\n      table_.resize(newLength);\n      if (size_ > 0 && oldTail > head_) {\n        \/\/ the list wrapped around, need to move oldTail..oldLength to the end\n        \/\/ of the now-larger table_\n        std::copy(table_.begin() + oldTail, table_.begin() + oldLength,\n                  table_.begin() + newLength - (oldLength - oldTail));\n        \/\/ Update the names indecies that pointed to the old range\n        for (auto& names_it: names_) {\n          for (auto& idx: names_it.second) {\n            if (idx >= oldTail) {\n              DCHECK_LT(idx + (table_.size() - oldLength), table_.size());\n              idx += (table_.size() - oldLength);\n            } else {\n              \/\/ remaining indecies in the list were smaller than oldTail, so\n              \/\/ should be indexed from 0\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n}","target":0,"flaw_line_index":0,"hash":"ac0af86e-aac9-41b6-8f61-ba94c1f4e69d","idx":"b06e4c3c-29f0-4b9f-9371-5a2950f40358"}
{"func_before":"\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\n\t\/* Switch off the timer when it_value is zero *\/\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"3cfac818-9c81-4fa7-bf51-408f321c5f0e","idx":"ea2eaf7f-167e-443c-a85c-e0663b7937b6"}
{"func_before":"\ttimr->it_requeue_pending = (timr->it_requeue_pending + 2) &\n\t\t~REQUEUE_PENDING;\n\ttimr->it_overrun_last = 0;\n\n\t\/* Switch off the timer when it_value is zero *\/\n\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = timr->it_sigev_notify == SIGEV_NONE;\n\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"289fa462-6e06-4ded-bc77-759a9bf57c74","idx":"0c1f1cbc-1252-49bd-b62e-1914640904a2"}
{"func_before":"Status TensorSliceWriter::SaveData(const T* data, int64_t num_elements,\n                                   SavedSlice* ss) {\n  size_t size_bound =\n      ss->ByteSize() + kTensorProtoHeaderBytes +\n      (MaxBytesPerElement(DataTypeToEnum<T>::value) * num_elements);\n  if (size_bound > kMaxMessageBytes) {\n    return errors::InvalidArgument(\n        \"Tensor slice is too large to serialize (conservative estimate: \",\n        size_bound, \" bytes)\");\n  }\n  Fill(data, num_elements, ss->mutable_data());\n  DCHECK_GE(ss->ByteSize(), 0);\n  DCHECK_LE(ss->ByteSize(), size_bound);\n  return OkStatus();\n}","target":1,"flaw_line_index":0,"hash":"f6190658-c921-4ef3-a17c-8d416c005821","idx":"9c5e53c4-69fa-4811-a61a-29f8e9fa091f"}
{"func_before":"Status TensorSliceWriter::SaveData(const T* data, int64_t num_elements,\n                                   SavedSlice* ss) {\n  size_t max_bytes_per_element =\n      MaxBytesPerElementOrZero(DataTypeToEnum<T>::value);\n  if (max_bytes_per_element == 0) {\n    return errors::InvalidArgument(\n        \"Tensor slice serialization not implemented for dtype \",\n        DataTypeToEnum<T>::value);\n  }\n  size_t size_bound = ss->ByteSize() + kTensorProtoHeaderBytes +\n                      (max_bytes_per_element * num_elements);\n  if (size_bound > kMaxMessageBytes) {\n    return errors::InvalidArgument(\n        \"Tensor slice is too large to serialize (conservative estimate: \",\n        size_bound, \" bytes)\");\n  }\n  Fill(data, num_elements, ss->mutable_data());\n  DCHECK_GE(ss->ByteSize(), 0);\n  DCHECK_LE(ss->ByteSize(), size_bound);\n  return OkStatus();\n}","target":0,"flaw_line_index":0,"hash":"3c1b25eb-c5c1-4116-bdf2-ae8f8761b979","idx":"7d64b59c-240b-4f5c-ab7a-bce9ec4b81d0"}
{"func_before":"static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t\/* Look for an exact match *\/\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t\/* Look for an exact match *\/\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\t\/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address\/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP\/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. *\/\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\tnow = ast_tvnow();\n\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n\t\t\t\/* Find first unused call number that hasn't been used in a while *\/\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\t\/* We've still got lock held if we found a spot *\/\n\t\tif (x >= TRUNK_CALL_START) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;","target":1,"flaw_line_index":0,"hash":"f0c81018-1cc7-4431-98fb-be1500587bc7","idx":"1071d09a-bf1c-4c43-9cb6-c765e75acd13"}
{"func_before":"static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t\/* Look for an exact match *\/\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t\/* Look for an exact match *\/\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\tint start, found = 0;\n\n\t\t\/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address\/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP\/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. *\/\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\n\t\tnow = ast_tvnow();\n\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n\t\tfor (x = start; 1; x++) {\n\t\t\tif (x == TRUNK_CALL_START) {\n\t\t\t\tx = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t\/* Find first unused call number that hasn't been used in a while *\/\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\t\n\t\t\tif (x == start - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\/* We've still got lock held if we found a spot *\/\n\t\tif (x == start - 1 && !found) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;","target":0,"flaw_line_index":0,"hash":"7d65d62e-d6f0-476d-8f79-220420dcca05","idx":"4ac8d383-d1bb-4cd0-b830-24f9091f3bf7"}
{"func_before":"static RList *symbols(RBinFile *bf) {\n\tRList *res = r_list_newf ((RListFree)r_bin_symbol_free);\n\tr_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tHtUU *hash = ht_uu_new0 ();\n\tif (!hash) {\n\t\treturn res;\n\t}\n\tbool found = false;\n\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\tRCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tht_uu_find (hash, sym->paddr, &found);\n\t\tif (found) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\tif (s) {\n\t\t\tr_list_append (res, s);\n\t\t\tht_uu_insert (hash, sym->paddr, 1);\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &element->symbols[i];\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);","target":1,"flaw_line_index":0,"hash":"89f2e4fa-0900-42fd-93ad-7015c87a4d85","idx":"80319b3f-47fd-4643-a7c8-e53e84e65731"}
{"func_before":"static RList *symbols(RBinFile *bf) {\n\tr_return_val_if_fail (bf && bf->o && bf->o->bin_obj, NULL);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tHtUU *hash = ht_uu_new0 ();\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\tRList *res = r_list_newf ((RListFree)r_bin_symbol_free);\n\tbool found = false;\n\tif (element->lined_symbols) {\n\t\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n\t\t\tif (!sym) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t\tht_uu_insert (hash, sym->paddr, 1);\n\t\t\t}\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &element->symbols[i];\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);","target":0,"flaw_line_index":0,"hash":"1a78f564-59d4-4c78-9235-be148d6eb5ce","idx":"285552fc-6837-414b-9112-0e0a77edbd15"}
{"func_before":"void FileBody::Dump(std::ostream& os, const std::string& prefix) const {\n  os << prefix << \"<file: \" << path_.string() << \">\" << std::endl;\n}","target":1,"flaw_line_index":0,"hash":"4a5253f6-cdfa-4b6a-bfea-d80903827c26","idx":"8bce4017-9b14-420e-a9f0-f0fd2bf00428"}
{"func_before":"void FileBody::Dump(std::ostream& os, const std::string& prefix) const {\n  os << prefix << \"<file: \" << path_.u8string() << \">\" << std::endl;\n}","target":0,"flaw_line_index":0,"hash":"01f928fa-ef3d-4d20-a213-10a6820b1095","idx":"ae4b8330-d086-4660-b1b5-1132ff54b641"}
{"func_before":"  void SetUp() override {\n    env_ = std::make_unique<FakeClockEnv>(Env::Default());\n    tfdataz_metrics_ = std::make_unique<TfDatazMetricsCollector>(*env_);\n  }","target":1,"flaw_line_index":0,"hash":"a3d45b63-9c84-4f66-be9d-c37ec1fa2675","idx":"f6bb30b7-cd43-4133-ac5e-c65501f710e7"}
{"func_before":"  void SetUp() override {\n    env_ = std::make_unique<FakeClockEnv>(Env::Default());\n    tfdataz_metrics_ =\n        std::make_unique<TfDatazMetricsCollector>(*env_, iterator_.get());\n  }","target":0,"flaw_line_index":0,"hash":"61d02485-7076-4de9-b8f6-a1f85ed66fc0","idx":"849106f0-25bf-432f-942c-1d893e2d813b"}
{"func_before":"Http::FilterTrailersStatus Context::onResponseTrailers() {\n  if (!wasm_->onResponseTrailers_) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  if (wasm_->onResponseTrailers_(this, id_).u64_ == 0) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  return Http::FilterTrailersStatus::StopIteration;\n}","target":1,"flaw_line_index":0,"hash":"a92f7f8a-b347-4105-9238-40aa89906f73","idx":"7b001396-b4d3-4053-92ca-18dd901b8034"}
{"func_before":"Http::FilterTrailersStatus Context::onResponseTrailers() {\n  if (!in_vm_context_created_ || !wasm_->onResponseTrailers_) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  if (wasm_->onResponseTrailers_(this, id_).u64_ == 0) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  return Http::FilterTrailersStatus::StopIteration;\n}","target":0,"flaw_line_index":0,"hash":"9d2cdd18-d917-4b34-a818-639037ea627a","idx":"cf8190ef-a115-4db1-8470-92d60a967488"}
{"func_before":"generic_ret *init_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static generic_ret         ret;\n    gss_buffer_desc            client_name,\n        service_name;\n    kadm5_server_handle_t      handle;\n    OM_uint32                  minor_stat;\n    const char                 *errmsg = NULL;\n    size_t clen, slen;\n    char *cdots, *sdots;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n                                   \"client=%.*s%s, service=%.*s%s, addr=%s, \"\n                                   \"vers=%d, flavor=%d\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     errmsg ? errmsg : _(\"success\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     (int)slen, (char *)service_name.value, sdots,\n                     client_addr(rqstp->rq_xprt),\n                     ret.api_version & ~(KADM5_API_VERSION_MASK),\n                     rqstp->rq_cred.oa_flavor);\n    if (errmsg != NULL)\n        krb5_free_error_message(NULL, errmsg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n\nexit_func:\n    return(&ret);\n}","target":1,"flaw_line_index":0,"hash":"73fcdee6-d335-4029-82b9-76a6bffe5d95","idx":"d8148789-69ca-49b7-afd5-40ff05485c02"}
{"func_before":"generic_ret *init_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static generic_ret         ret;\n    gss_buffer_desc            client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc            service_name = GSS_C_EMPTY_BUFFER;\n    kadm5_server_handle_t      handle;\n    OM_uint32                  minor_stat;\n    const char                 *errmsg = NULL;\n    size_t clen, slen;\n    char *cdots, *sdots;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))\n        goto exit_func;\n                                   \"vers=%d, flavor=%d\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     errmsg ? errmsg : _(\"success\"),\n                     (int)clen, (char *)client_name.value, cdots,\n                     (int)slen, (char *)service_name.value, sdots,\n                     client_addr(rqstp->rq_xprt),\n                     ret.api_version & ~(KADM5_API_VERSION_MASK),\n                     rqstp->rq_cred.oa_flavor);\n    if (errmsg != NULL)\n        krb5_free_error_message(NULL, errmsg);\n\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    return(&ret);\n}","target":0,"flaw_line_index":0,"hash":"0ce4d06d-dcc4-43fa-a7af-762d5fc6302d","idx":"0c5c7cff-8e0e-4d0c-af61-9d7130ee693e"}
{"func_before":"void enc624j600UpdateMacConfig(NetInterface *interface)\n{\n   uint16_t duplexMode;\n\n   \/\/Determine the new duplex mode by reading the PHYDPX bit\n   duplexMode = enc624j600ReadReg(interface, ENC624J600_REG_ESTAT) & ESTAT_PHYDPX;\n\n   \/\/Full-duplex mode?\n   if(duplexMode)\n   {\n      \/\/Configure the FULDPX bit to match the current duplex mode\n      enc624j600WriteReg(interface, ENC624J600_REG_MACON2, MACON2_DEFER |\n         MACON2_PADCFG2 | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1 | MACON2_FULDPX);\n      \/\/Configure the Back-to-Back Inter-Packet Gap register\n      enc624j600WriteReg(interface, ENC624J600_REG_MABBIPG, 0x15);\n   }\n   \/\/Half-duplex mode?\n   else\n   {\n      \/\/Configure the FULDPX bit to match the current duplex mode\n      enc624j600WriteReg(interface, ENC624J600_REG_MACON2, MACON2_DEFER |\n         MACON2_PADCFG2 | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1);\n      \/\/Configure the Back-to-Back Inter-Packet Gap register\n      enc624j600WriteReg(interface, ENC624J600_REG_MABBIPG, 0x12);\n   }\n}","target":1,"flaw_line_index":0,"hash":"ab5620a0-06e1-4402-b90d-2ebc8234f344","idx":"160adc49-b58e-467f-ae16-c86ae9ad8e02"}
{"func_before":"void enc624j600UpdateMacConfig(NetInterface *interface)\n{\n   uint16_t duplexMode;\n\n   \/\/Determine the new duplex mode by reading the PHYDPX bit\n   duplexMode = enc624j600ReadReg(interface, ENC624J600_ESTAT) & ENC624J600_ESTAT_PHYDPX;\n\n   \/\/Full-duplex mode?\n   if(duplexMode)\n   {\n      \/\/Configure the FULDPX bit to match the current duplex mode\n      enc624j600WriteReg(interface, ENC624J600_MACON2, ENC624J600_MACON2_DEFER |\n         ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN |\n         ENC624J600_MACON2_R1_DEFAULT | ENC624J600_MACON2_FULDPX);\n\n      \/\/Configure the Back-to-Back Inter-Packet Gap register\n      enc624j600WriteReg(interface, ENC624J600_MABBIPG,\n         ENC624J600_MABBIPG_BBIPG_DEFAULT_FD);\n   }\n   \/\/Half-duplex mode?\n   else\n   {\n      \/\/Configure the FULDPX bit to match the current duplex mode\n      enc624j600WriteReg(interface, ENC624J600_MACON2, ENC624J600_MACON2_DEFER |\n         ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN |\n         ENC624J600_MACON2_R1_DEFAULT);\n\n      \/\/Configure the Back-to-Back Inter-Packet Gap register\n      enc624j600WriteReg(interface, ENC624J600_MABBIPG,\n         ENC624J600_MABBIPG_BBIPG_DEFAULT_HD);\n   }\n}","target":0,"flaw_line_index":0,"hash":"8704a7cb-0bab-4ebc-9aae-0bb6d7a02c7e","idx":"f606a4dc-7c81-463a-ba4d-f8a464fd38f5"}
{"func_before":"\nint read_escaped_char(\n    yyscan_t yyscanner,\n    uint8_t* escaped_char)\n{\n  char text[4] = {0, 0, 0, 0};\n\n  text[0] = '\\\\';\n  text[1] = RE_YY_INPUT(yyscanner);\n\n  if (text[1] == EOF)\n    return 0;\n\n  if (text[1] == 'x')\n  {\n    text[2] = RE_YY_INPUT(yyscanner);\n\n    if (text[2] == EOF)\n      return 0;\n\n    text[3] = RE_YY_INPUT(yyscanner);\n\n    if (text[3] == EOF)\n      return 0;\n  }\n\n  *escaped_char = escaped_char_value(text);\n\n  return 1;","target":1,"flaw_line_index":0,"hash":"93bad8ee-19d6-45f4-a0f7-d7276cd98d19","idx":"2b2f7dd4-c4c5-4833-9dcf-e616bbaa187b"}
{"func_before":"\nint read_escaped_char(\n    yyscan_t yyscanner,\n    uint8_t* escaped_char)\n{\n  char text[4] = {0, 0, 0, 0};\n\n  text[0] = '\\\\';\n  text[1] = RE_YY_INPUT(yyscanner);\n\n  if (text[1] == EOF || text[1] == 0)\n    return 0;\n\n  if (text[1] == 'x')\n  {\n    text[2] = RE_YY_INPUT(yyscanner);\n\n    if (!isxdigit(text[2]))\n      return 0;\n\n    text[3] = RE_YY_INPUT(yyscanner);\n\n    if (!isxdigit(text[3]))\n      return 0;\n  }\n\n  *escaped_char = escaped_char_value(text);\n\n  return 1;","target":0,"flaw_line_index":0,"hash":"5efc07f2-dc83-475e-abfa-f2b7685d1c45","idx":"f83a9bd7-cb0d-47b0-ad38-c3787e484f65"}
{"func_before":"{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun;\n\tvoid __user* argp = (void __user*)arg;\n\tstruct sock_fprog fprog;\n\tstruct ifreq ifr;\n\tint sndbuf;\n\tint vnet_hdr_sz;\n\tint ret;\n\n\tif (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89)\n\t\tif (copy_from_user(&ifr, argp, ifreq_len))\n\t\t\treturn -EFAULT;\n\n\tif (cmd == TUNGETFEATURES) {\n\t\t\/* Currently this just means: \"what IFF flags are valid?\".\n\t\t * This is needed because we never checked for invalid flags on\n\t\t * TUNSETIFF. *\/\n\t\treturn put_user(IFF_TUN | IFF_TAP | IFF_NO_PI | IFF_ONE_QUEUE |\n\t\t\t\tIFF_VNET_HDR,\n\t\t\t\t(unsigned int __user*)argp);\n\t}\n","target":1,"flaw_line_index":0,"hash":"784b62bc-f408-4379-8cd6-6552eddf5e9d","idx":"d3395b2a-fbb4-44d9-b312-fb87831613dc"}
{"func_before":"{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun;\n\tvoid __user* argp = (void __user*)arg;\n\tstruct sock_fprog fprog;\n\tstruct ifreq ifr;\n\tint sndbuf;\n\tint vnet_hdr_sz;\n\tint ret;\n\n\tif (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89) {\n\t\tif (copy_from_user(&ifr, argp, ifreq_len))\n\t\t\treturn -EFAULT;\n\t} else\n\t\tmemset(&ifr, 0, sizeof(ifr));\n\n\tif (cmd == TUNGETFEATURES) {\n\t\t\/* Currently this just means: \"what IFF flags are valid?\".\n\t\t * This is needed because we never checked for invalid flags on\n\t\t * TUNSETIFF. *\/\n\t\treturn put_user(IFF_TUN | IFF_TAP | IFF_NO_PI | IFF_ONE_QUEUE |\n\t\t\t\tIFF_VNET_HDR,\n\t\t\t\t(unsigned int __user*)argp);\n\t}\n","target":0,"flaw_line_index":0,"hash":"08d4094f-d62c-4021-876e-1db989ea058f","idx":"91ad7806-0f24-4fb8-9af5-5818db512d53"}
{"func_before":"      \/\/ are simplified to NDIMS==1 case.\n      \/\/\n      \/\/ Because this optimization increases the binary size for each\n      \/\/ Functor (+, -, *, \/, <, <=, etc.), type and ndim combination.\n      \/\/ we only apply such optimization for selected ops\/types\/ndims.\n      \/\/\n      \/\/ Because NDIMS, Functor::use_broadcast_optimization and\n      \/\/ use_broadcast_optimization<T> are compile-time constant, gcc\n      \/\/ does a decent job avoiding generating code when conditions\n      \/\/ are not met.\n      const int a = in0.dimension(0);  \/\/ in0 is shape [a, b]\n      const int b = in0.dimension(1);\n      const int c = in1.dimension(0);  \/\/ in1 is shape [c, d]\n      const int d = in1.dimension(1);\n      if ((a == 1) && (d == 1)) {\n        auto lhs = in0.reshape(OneByM(b)).broadcast(NByOne(c));\n        auto rhs = in1.reshape(NByOne(c)).broadcast(OneByM(b));\n        Assign(dev, out, lhs.binaryExpr(rhs, func));\n        return;\n      }\n      if ((b == 1) && (c == 1)) {\n        auto lhs = in0.reshape(NByOne(a)).broadcast(OneByM(d));\n        auto rhs = in1.reshape(OneByM(d)).broadcast(NByOne(a));\n        Assign(dev, out, lhs.binaryExpr(rhs, func));","target":1,"flaw_line_index":0,"hash":"6a065718-8831-4261-85f6-4aa8448a53b8","idx":"6209ea8e-1dc2-49a7-8753-a49845b1a05b"}
{"func_before":"      \/\/ are simplified to NDIMS==1 case.\n      \/\/\n      \/\/ Because this optimization increases the binary size for each\n      \/\/ Functor (+, -, *, \/, <, <=, etc.), type and ndim combination.\n      \/\/ we only apply such optimization for selected ops\/types\/ndims.\n      \/\/\n      \/\/ Because NDIMS, Functor::use_broadcast_optimization and\n      \/\/ use_broadcast_optimization<T> are compile-time constant, gcc\n      \/\/ does a decent job avoiding generating code when conditions\n      \/\/ are not met.\n      const Eigen::DenseIndex a = in0.dimension(0);  \/\/ in0 is shape [a, b]\n      const Eigen::DenseIndex b = in0.dimension(1);\n      const Eigen::DenseIndex c = in1.dimension(0);  \/\/ in1 is shape [c, d]\n      const Eigen::DenseIndex d = in1.dimension(1);\n      if ((a == 1) && (d == 1)) {\n        auto lhs = in0.reshape(OneByM(b)).broadcast(NByOne(c));\n        auto rhs = in1.reshape(NByOne(c)).broadcast(OneByM(b));\n        Assign(dev, out, lhs.binaryExpr(rhs, func));\n        return;\n      }\n      if ((b == 1) && (c == 1)) {\n        auto lhs = in0.reshape(NByOne(a)).broadcast(OneByM(d));\n        auto rhs = in1.reshape(OneByM(d)).broadcast(NByOne(a));\n        Assign(dev, out, lhs.binaryExpr(rhs, func));","target":0,"flaw_line_index":0,"hash":"5df112af-b2d7-487d-97a0-a963f3955148","idx":"5f38c80d-6dbf-4267-91bd-f9b9ed8d7f07"}
{"func_before":"#endif\n    int\t\tts = wp->w_buffer->b_p_ts;\n    int\t\tc;\n\n    vcol = 0;\n    line = ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);\n    if (pos->col == MAXCOL)\n\tposptr = NULL;  \/\/ continue until the NUL\n    else\n    {\n\t\/\/ Special check for an empty line, which can happen on exit, when\n\t\/\/ ml_get_buf() always returns an empty string.\n\tif (*ptr == NUL)\n\t    pos->col = 0;\n\tposptr = ptr + pos->col;\n\tif (has_mbyte)\n\t    \/\/ always start on the first byte\n\t    posptr -= (*mb_head_off)(line, posptr);\n    }\n\n    \/*\n     * This function is used very often, do some speed optimizations.\n     * When 'list', 'linebreak', 'showbreak' and 'breakindent' are not set\n     * use a simple loop.","target":1,"flaw_line_index":0,"hash":"41754af7-d287-40cc-9062-70148eda3c2e","idx":"375d971d-3184-42dd-a205-8bd944b8c46f"}
{"func_before":"#endif\n    int\t\tts = wp->w_buffer->b_p_ts;\n    int\t\tc;\n\n    vcol = 0;\n    line = ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);\n    if (pos->col == MAXCOL)\n\tposptr = NULL;  \/\/ continue until the NUL\n    else\n    {\n\tcolnr_T i;\n\n\t\/\/ In a few cases the position can be beyond the end of the line.\n\tfor (i = 0; i < pos->col; ++i)\n\t    if (ptr[i] == NUL)\n\t    {\n\t\tpos->col = i;\n\t\tbreak;\n\t    }\n\tposptr = ptr + pos->col;\n\tif (has_mbyte)\n\t    \/\/ always start on the first byte\n\t    posptr -= (*mb_head_off)(line, posptr);\n    }\n\n    \/*\n     * This function is used very often, do some speed optimizations.\n     * When 'list', 'linebreak', 'showbreak' and 'breakindent' are not set\n     * use a simple loop.","target":0,"flaw_line_index":0,"hash":"b4921e95-4b1e-471b-a371-ac6e85a1780b","idx":"a485ba90-ea1a-4a4d-8101-c1a6a72d9cb4"}
{"func_before":"int btrfs_get_dev_stats(struct btrfs_fs_info *fs_info,\n\t\t\tstruct btrfs_ioctl_get_dev_stats *stats)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tint i;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, stats->devid, NULL, NULL);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tif (!dev) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, device not found\");\n\t\treturn -ENODEV;\n\t} else if (!dev->dev_stats_valid) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, not yet valid\");\n\t\treturn -ENODEV;\n\t} else if (stats->flags & BTRFS_DEV_STATS_RESET) {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {","target":1,"flaw_line_index":0,"hash":"68f7af24-e72f-4350-8c2a-eba67c8c30c2","idx":"0b3a8c71-b4aa-42f5-b341-a2472a3e8b25"}
{"func_before":"int btrfs_get_dev_stats(struct btrfs_fs_info *fs_info,\n\t\t\tstruct btrfs_ioctl_get_dev_stats *stats)\n{\n\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tint i;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, stats->devid, NULL, NULL,\n\t\t\t\ttrue);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tif (!dev) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, device not found\");\n\t\treturn -ENODEV;\n\t} else if (!dev->dev_stats_valid) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, not yet valid\");\n\t\treturn -ENODEV;\n\t} else if (stats->flags & BTRFS_DEV_STATS_RESET) {\n\t\tfor (i = 0; i < BTRFS_DEV_STAT_VALUES_MAX; i++) {","target":0,"flaw_line_index":0,"hash":"08f31ac0-0831-4f40-9d74-caf50ddbcb31","idx":"7875eabf-660c-4868-8bd5-2c2ae46b4a88"}
{"func_before":"TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n\t\t\t\t       size_t len)\n{\n\tuaddr_t a;\n\tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n\t\t\t       CORE_MMU_USER_PARAM_SIZE);\n\n\tif (ADD_OVERFLOW(uaddr, len, &a))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\/*\n\t * Rely on TA private memory test to check if address range is private\n\t * to TA or not.\n\t *\/\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n\t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\tfor (a = uaddr; a < (uaddr + len); a += addr_incr) {\n\t\tuint32_t attr;\n\t\tTEE_Result res;\n\n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;","target":1,"flaw_line_index":0,"hash":"3cf23b9b-db53-43d5-8a10-44cb4aeec074","idx":"2f5e7cd5-dcc6-4ac9-8dce-ccf05c2bef4d"}
{"func_before":"TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n\t\t\t\t       size_t len)\n{\n\tuaddr_t a;\n\tuaddr_t end_addr = 0;\n\tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n\t\t\t       CORE_MMU_USER_PARAM_SIZE);\n\n\tif (ADD_OVERFLOW(uaddr, len, &end_addr))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\t\/*\n\t * Rely on TA private memory test to check if address range is private\n\t * to TA or not.\n\t *\/\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n\t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\tfor (a = ROUNDDOWN(uaddr, addr_incr); a < end_addr; a += addr_incr) {\n\t\tuint32_t attr;\n\t\tTEE_Result res;\n\n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)\n\t\t\treturn res;\n\n\t\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t\t    (attr & TEE_MATTR_SECURE))\n\t\t\treturn TEE_ERROR_ACCESS_DENIED;","target":0,"flaw_line_index":0,"hash":"e6e91233-4899-45a2-8257-95054a52c178","idx":"79434214-5ed4-45d6-bd62-b7ec87e3551b"}
{"func_before":"   * ri-record.\n   *\/\n  size_t subkey_lf = le32toh (nk->subkey_lf);\n  subkey_lf += 0x1000;\n  if (!IS_VALID_BLOCK (h, subkey_lf)) {\n    SET_ERRNO (EFAULT,\n               \"subkey_lf is not a valid block (0x%zx)\", subkey_lf);\n    goto error;\n  }\n\n  if (_get_children (h, subkey_lf, &children, &blocks, flags) == -1)\n    goto error;\n\n  \/* Check the number of children we ended up reading matches\n   * nr_subkeys_in_nk.\n   *\/\n  size_t nr_children = _hivex_get_offset_list_length (&children);\n  if (nr_subkeys_in_nk != nr_children) {\n    if (!h->unsafe) {\n      SET_ERRNO (ENOTSUP,\n                 \"nr_subkeys_in_nk = %zu \"","target":1,"flaw_line_index":0,"hash":"86d25d95-4c6e-4e2c-9b3c-8ba12c67cb9e","idx":"5e58dbde-1efd-481f-9167-565757c33625"}
{"func_before":"   * ri-record.\n   *\/\n  size_t subkey_lf = le32toh (nk->subkey_lf);\n  subkey_lf += 0x1000;\n  if (!IS_VALID_BLOCK (h, subkey_lf)) {\n    SET_ERRNO (EFAULT,\n               \"subkey_lf is not a valid block (0x%zx)\", subkey_lf);\n    goto error;\n  }\n\n  if (_get_children (h, subkey_lf, &children, &blocks, flags, 0) == -1)\n    goto error;\n\n  \/* Check the number of children we ended up reading matches\n   * nr_subkeys_in_nk.\n   *\/\n  size_t nr_children = _hivex_get_offset_list_length (&children);\n  if (nr_subkeys_in_nk != nr_children) {\n    if (!h->unsafe) {\n      SET_ERRNO (ENOTSUP,\n                 \"nr_subkeys_in_nk = %zu \"","target":0,"flaw_line_index":0,"hash":"b761c6bd-2e4a-4610-9dfd-b5b3b9a6f966","idx":"c3edc9b4-0d64-4448-b05e-57646faacb2b"}
{"func_before":"                                  \" : \", x.shape().DebugString(), \" vs. \",\n                                  v.shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, i.dim_size(0) == v.dim_size(0),\n                errors::InvalidArgument(\n                    \"i and x shape doesn't match at index 0: \",\n                    i.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n\n    Tensor y = x;  \/\/ This creates an alias intentionally.\n    \/\/ Skip processing if tensors are empty.\n    if (x.NumElements() > 0 || v.NumElements() > 0) {\n      OP_REQUIRES_OK(ctx, DoCompute(ctx, i, v, &y));\n    }\n    ctx->set_output(0, y);\n  }","target":1,"flaw_line_index":0,"hash":"9542bf8d-9af2-40c2-b0dd-9d13bb438f81","idx":"a3ef63af-6a30-4b46-8923-1253b9271e83"}
{"func_before":"                                  \" : \", x.shape().DebugString(), \" vs. \",\n                                  v.shape().DebugString()));\n    }\n    OP_REQUIRES(ctx, i.dim_size(0) == v.dim_size(0),\n                errors::InvalidArgument(\n                    \"i and x shape doesn't match at index 0: \",\n                    i.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n\n    Tensor y = x;  \/\/ This creates an alias intentionally.\n    \/\/ Skip processing if tensors are empty.\n    if (x.NumElements() > 0 && v.NumElements() > 0) {\n      OP_REQUIRES_OK(ctx, DoCompute(ctx, i, v, &y));\n    }\n    ctx->set_output(0, y);\n  }","target":0,"flaw_line_index":0,"hash":"9fcd1eb5-6261-4844-9f01-a148eb392d1d","idx":"1e392c45-e7f5-4a72-85f5-14068035d41d"}
{"func_before":"untrusted_launcher_response_callback (GtkDialog                 *dialog,\n                                      int                        response_id,\n                                      ActivateParametersDesktop *parameters)\n{\n    GdkScreen *screen;\n    char *uri;\n    GFile *file;\n\n    switch (response_id)\n    {\n        case RESPONSE_RUN:\n        {\n            screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n            uri = nautilus_file_get_uri (parameters->file);\n            DEBUG (\"Launching untrusted launcher %s\", uri);\n            nautilus_launch_desktop_file (screen, uri, NULL,\n                                          parameters->parent_window);\n            g_free (uri);\n        }\n        break;\n\n        case RESPONSE_MARK_TRUSTED:\n        {\n            file = nautilus_file_get_location (parameters->file);\n            nautilus_file_mark_desktop_file_trusted (file,\n                                                     parameters->parent_window,\n                                                     TRUE,\n                                                     NULL, NULL);\n            g_object_unref (file);\n        }\n        break;\n\n        default:\n        {\n            \/* Just destroy dialog *\/\n        }\n        break;\n    }","target":1,"flaw_line_index":0,"hash":"6e6d2872-7ccd-48ce-acfc-995e3cb9808c","idx":"59e60a8c-2d83-4135-b60f-ad9859b0cff4"}
{"func_before":"untrusted_launcher_response_callback (GtkDialog                 *dialog,\n                                      int                        response_id,\n                                      ActivateParametersDesktop *parameters)\n{\n    GdkScreen *screen;\n    char *uri;\n    GFile *file;\n\n    switch (response_id)\n    {\n        case GTK_RESPONSE_OK:\n        {\n            file = nautilus_file_get_location (parameters->file);\n\n            \/* We need to do this in order to prevent malicious desktop files\n             * with the executable bit already set.\n             * See https:\/\/bugzilla.gnome.org\/show_bug.cgi?id=777991\n             *\/\n            nautilus_file_set_metadata (parameters->file, NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,\n                                        NULL,\n                                        \"yes\");\n\n            nautilus_file_mark_desktop_file_executable (file,\n                                                        parameters->parent_window,\n                                                        TRUE,\n                                                        NULL, NULL);\n\n            \/* Need to force a reload of the attributes so is_trusted is marked\n             * correctly. Not sure why the general monitor doesn't fire in this\n             * case when setting the metadata\n             *\/\n            nautilus_file_invalidate_all_attributes (parameters->file);\n\n            screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n            uri = nautilus_file_get_uri (parameters->file);\n            DEBUG (\"Launching untrusted launcher %s\", uri);\n            nautilus_launch_desktop_file (screen, uri, NULL,\n                                          parameters->parent_window);\n            g_free (uri);\n            g_object_unref (file);\n        }\n        break;\n\n        default:\n        {\n            \/* Just destroy dialog *\/\n        }\n        break;\n    }","target":0,"flaw_line_index":0,"hash":"03706c7d-fef6-4a7a-88d1-9c45890bbbf5","idx":"77794b19-f810-419e-a69a-db28b370c52c"}
{"func_before":"\t\t\t    authblob->Signature);\n\t\treturn -EINVAL;\n\t}\n\n\tnt_off = le32_to_cpu(authblob->NtChallengeResponse.BufferOffset);\n\tnt_len = le16_to_cpu(authblob->NtChallengeResponse.Length);\n\n\tdn_off = le32_to_cpu(authblob->DomainName.BufferOffset);\n\tdn_len = le16_to_cpu(authblob->DomainName.Length);\n\n\tif (blob_len < (u64)dn_off + dn_len || blob_len < (u64)nt_off + nt_len)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_SMB_INSECURE_SERVER\n\tlm_off = le32_to_cpu(authblob->LmChallengeResponse.BufferOffset);\n\tlm_len = le16_to_cpu(authblob->LmChallengeResponse.Length);\n\tif (blob_len < (u64)lm_off + lm_len)\n\t\treturn -EINVAL;\n\n\t\/* process NTLM authentication *\/\n\tif (nt_len == CIFS_AUTH_RESP_SIZE) {","target":1,"flaw_line_index":0,"hash":"2828eb66-8c00-465c-ac9b-08cdf6f8cbca","idx":"f9a0b5f1-ba42-4c18-95c6-8579df4db3c3"}
{"func_before":"\t\t\t    authblob->Signature);\n\t\treturn -EINVAL;\n\t}\n\n\tnt_off = le32_to_cpu(authblob->NtChallengeResponse.BufferOffset);\n\tnt_len = le16_to_cpu(authblob->NtChallengeResponse.Length);\n\n\tdn_off = le32_to_cpu(authblob->DomainName.BufferOffset);\n\tdn_len = le16_to_cpu(authblob->DomainName.Length);\n\n\tif (blob_len < (u64)dn_off + dn_len || blob_len < (u64)nt_off + nt_len ||\n\t    nt_len < CIFS_ENCPWD_SIZE)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_SMB_INSECURE_SERVER\n\tlm_off = le32_to_cpu(authblob->LmChallengeResponse.BufferOffset);\n\tlm_len = le16_to_cpu(authblob->LmChallengeResponse.Length);\n\tif (blob_len < (u64)lm_off + lm_len)\n\t\treturn -EINVAL;\n\n\t\/* process NTLM authentication *\/\n\tif (nt_len == CIFS_AUTH_RESP_SIZE) {","target":0,"flaw_line_index":0,"hash":"fb6ad252-8280-4020-b83c-0dcc02c96fe3","idx":"95b29e2b-2bd7-480f-8e71-90019b9c1947"}
{"func_before":"static int enable_trace_input(struct flb_hs *hs, const char *name, const char *prefix, const char *output_name, struct mk_list *props)\n{\n    struct flb_input_instance *in;\n\n\n    in = find_input(hs, name);\n    if (in == NULL) {\n        return 404;\n    }\n\n    flb_chunk_trace_context_new(in, output_name, prefix, NULL, props);\n    return (in->chunk_trace_ctxt == NULL ? 503 : 0);\n}","target":1,"flaw_line_index":0,"hash":"71ff393f-7dad-414d-af6b-ab0cf13ef7e9","idx":"e845b7bc-792b-4886-a15f-a272860e706f"}
{"func_before":"static int enable_trace_input(struct flb_hs *hs, const char *name, ssize_t nlen, const char *prefix,\n                              const char *output_name, struct mk_list *props)\n{\n    struct flb_input_instance *in;\n\n    in = find_input(hs, name, nlen);\n    if (in == NULL) {\n        flb_error(\"unable to find input: [%d]%.*s\", (int)nlen, (int)nlen, name);\n        return 404;\n    }\n\n    flb_chunk_trace_context_new(in, output_name, prefix, NULL, props);\n\n    if (in->chunk_trace_ctxt == NULL) {\n        flb_error(\"unable to start tracing\");\n        return 503;\n    }\n\n    return 0;\n}","target":0,"flaw_line_index":0,"hash":"072c59a4-91c7-42fb-a587-0123517190b4","idx":"6f4faaa9-1165-4d5d-af67-7016ed9a12f6"}
{"func_before":"void Archive::Seek(int64 Offset,int Method)\n{\n  if (!QOpen.Seek(Offset,Method))\n    File::Seek(Offset,Method);\n}","target":1,"flaw_line_index":0,"hash":"9ff1444e-65e1-4414-9b98-76aea69c4703","idx":"2faf6a76-bad2-41d7-a675-b1bdc07be4f7"}
{"func_before":"void Archive::Seek(int64 Offset,int Method)\n{\n#ifdef USE_QOPEN\n  if (QOpen.Seek(Offset,Method))\n    return;\n#endif\n#ifdef USE_ARCMEM\n  if (ArcMem.Seek(Offset,Method))\n    return;\n#endif\n  File::Seek(Offset,Method);\n}","target":0,"flaw_line_index":0,"hash":"1b8c9668-285d-457b-a44f-a362ac982bd0","idx":"3afd9abc-a5fa-4a05-9be9-e79a02876eff"}
{"func_before":"test_make_inputs (xd3_stream *stream, xoff_t *ss_out, xoff_t *ts_out)\n{\n  usize_t ts = (mt_random (&static_mtrand) % TEST_FILE_MEAN) + TEST_FILE_MEAN \/ 2;\n  usize_t ss = (mt_random (&static_mtrand) % TEST_FILE_MEAN) + TEST_FILE_MEAN \/ 2;\n  uint8_t *buf = (uint8_t*) malloc (ts + ss), *sbuf = buf, *tbuf = buf + ss;\n  usize_t sadd = 0, sadd_max = (usize_t)(ss * TEST_ADD_RATIO);\n  FILE  *tf = NULL, *sf = NULL;\n  usize_t i, j;\n  int ret;\n\n  if (buf == NULL) { return ENOMEM; }\n\n  if ((tf = fopen (TEST_TARGET_FILE, \"w\")) == NULL ||\n      (ss_out != NULL && (sf = fopen (TEST_SOURCE_FILE, \"w\")) == NULL))","target":1,"flaw_line_index":0,"hash":"ac816f45-547e-4749-a272-02a767f59abd","idx":"7ccca51d-8090-45aa-801f-57dbaa9205d9"}
{"func_before":"test_make_inputs (xd3_stream *stream, xoff_t *ss_out, xoff_t *ts_out)\n{\n  usize_t ts = (mt_random (&static_mtrand) % TEST_FILE_MEAN) +\n    TEST_FILE_MEAN \/ 2;\n  usize_t ss = (mt_random (&static_mtrand) % TEST_FILE_MEAN) +\n    TEST_FILE_MEAN \/ 2;\n  uint8_t *buf = (uint8_t*) malloc (ts + ss), *sbuf = buf, *tbuf = buf + ss;\n  usize_t sadd = 0, sadd_max = (usize_t)(ss * TEST_ADD_RATIO);\n  FILE  *tf = NULL, *sf = NULL;\n  usize_t i, j;\n  int ret;\n\n  if (buf == NULL) { return ENOMEM; }\n\n  if ((tf = fopen (TEST_TARGET_FILE, \"w\")) == NULL ||\n      (ss_out != NULL && (sf = fopen (TEST_SOURCE_FILE, \"w\")) == NULL))","target":0,"flaw_line_index":0,"hash":"3713b381-9656-4a2f-95f7-584b73d9ab4c","idx":"c5865cd5-3aa9-44d9-b534-650ca591b0d0"}
{"func_before":"static int fsmVerify(const char *path, rpmfi fi)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n\n    rc = fsmStat(path, 1, &dsb);\n    if (rc)\n\treturn rc;\n\n\trc = fsmRename(path, rmpath);\n\t\/* XXX shouldn't we take unlink return code here? *\/\n\tif (!rc)\n\t    (void) fsmUnlink(rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t\/* XXX HACK *\/\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n            rc = fsmStat(path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n            if (S_ISDIR(dsb.st_mode)) return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }","target":1,"flaw_line_index":0,"hash":"28819034-2139-4ef3-921e-6054e13ed24e","idx":"66b68271-25e4-414e-bac0-bddcdd811953"}
{"func_before":"static int fsmVerify(const char *path, rpmfi fi, const struct stat *fsb)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n\n    rc = fsmStat(path, 1, &dsb);\n    if (rc)\n\treturn rc;\n\n\t\/* XXX shouldn't we take unlink return code here? *\/\n\tif (!rc)\n\t    (void) fsmUnlink(rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t\/* XXX HACK *\/\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n\t    uid_t luid = dsb.st_uid;\n            rc = fsmStat(path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n\t    \/* Only permit directory symlinks by target owner and root *\/\n            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == fsb->st_uid))\n\t\t    return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }","target":0,"flaw_line_index":0,"hash":"4ecfcb7f-86a6-47a5-8529-5f0cfa3f3c9e","idx":"b2f3c2ce-138b-4dba-ba84-7a0535e022dd"}
{"func_before":"\t\t\t\tbreak;\n\t\t\tcase SC_FILE_TYPE_INTERNAL_EF:   \/* EF for RSA keys *\/\n\t\t\t\tp_idx = efi_idx;\n\t\t\t\tbreak;\n\t\t\tdefault:                         \/* EF *\/\n\t\t\t\tp_idx = ef_idx;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t\/* Encryption key present ? *\/\n\t\t\tiPinCount = iACLen - 1;\t\t\n\n\t\t\tif (buf[iOffset] & 0x20) {\n\t\t\t\tint iSC;\n\t\t\t\tif (len < 1 + (size_t)iACLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiSC = buf[iOffset + iACLen];\n\n\t\t\t\tswitch( (iSC>>5) & 0x03 ) {\n\t\t\t\tcase 0:\n\t\t\t\t\tiMethod = SC_AC_TERM;\t\t\/* key authentication *\/","target":1,"flaw_line_index":0,"hash":"438bc261-3482-4177-bde0-bb5de6ed4714","idx":"44984d35-7e4a-4cfe-8f34-80f49e14988e"}
{"func_before":"\t\t\t\tbreak;\n\t\t\tcase SC_FILE_TYPE_INTERNAL_EF:   \/* EF for RSA keys *\/\n\t\t\t\tp_idx = efi_idx;\n\t\t\t\tbreak;\n\t\t\tdefault:                         \/* EF *\/\n\t\t\t\tp_idx = ef_idx;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t\/* Encryption key present ? *\/\n\t\t\tiPinCount = iACLen > 0 ? iACLen - 1 : 0;\n\n\t\t\tif (buf[iOffset] & 0x20) {\n\t\t\t\tint iSC;\n\t\t\t\tif (len < 1 + (size_t)iACLen)\n\t\t\t\t\tbreak;\n\t\t\t\tiSC = buf[iOffset + iACLen];\n\n\t\t\t\tswitch( (iSC>>5) & 0x03 ) {\n\t\t\t\tcase 0:\n\t\t\t\t\tiMethod = SC_AC_TERM;\t\t\/* key authentication *\/","target":0,"flaw_line_index":0,"hash":"2d0b1de1-4b06-4487-a785-8074306a6519","idx":"2f7c5404-563e-4ed5-90eb-8db68fcd444f"}
{"func_before":"void unix_notinflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tspin_lock(&unix_gc_lock);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tBUG_ON(list_empty(&u->link));\n\n\t\tif (atomic_long_dec_and_test(&u->inflight))\n\t\t\tlist_del_init(&u->link);\n\t\tunix_tot_inflight--;\n\t}\n\tfp->f_cred->user->unix_inflight--;\n\tspin_unlock(&unix_gc_lock);\n}","target":1,"flaw_line_index":0,"hash":"0bba7c84-1a3d-4df5-9581-90e7492c29cb","idx":"a249ae19-a08d-435d-b2c0-38ae67f0404a"}
{"func_before":"void unix_notinflight(struct user_struct *user, struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tspin_lock(&unix_gc_lock);\n\n\tif (s) {\n\t\tstruct unix_sock *u = unix_sk(s);\n\n\t\tBUG_ON(list_empty(&u->link));\n\n\t\tif (atomic_long_dec_and_test(&u->inflight))\n\t\t\tlist_del_init(&u->link);\n\t\tunix_tot_inflight--;\n\t}\n\tuser->unix_inflight--;\n\tspin_unlock(&unix_gc_lock);\n}","target":0,"flaw_line_index":0,"hash":"aa69a312-4389-4075-aa11-e656f53a6b8c","idx":"16c24eb7-85e1-4ec2-a79f-e28a8cfea70c"}
{"func_before":"\t\t\t\tlogit(NSLOG_CONFIG_ERROR, TRUE, \"Error: Failed to process config file '%s'. Aborting\\n\", config_file);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\ttiming_point(\"Main config file read\\n\");\n\n\t\t\t\/* NOTE 11\/06\/07 EG moved to after we read config files, as user may have overridden timezone offset *\/\n\t\t\t\/* get program (re)start time and save as macro *\/\n\t\t\tprogram_start = time(NULL);\n\t\t\tmy_free(mac->x[MACRO_PROCESSSTARTTIME]);\n\t\t\tasprintf(&mac->x[MACRO_PROCESSSTARTTIME], \"%llu\", (unsigned long long)program_start);\n\n\t\t\t\/* drop privileges *\/\n\t\t\tif(drop_privileges(nagios_user, nagios_group) == ERROR) {\n\n\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, \"Failed to drop privileges.  Aborting.\");\n\n\t\t\t\tcleanup();\n\t\t\t\texit(ERROR);\n\t\t\t\t}\n\n\t\t\tif (test_path_access(nagios_binary_path, X_OK)) {\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: failed to access() %s: %s\\n\", nagios_binary_path, strerror(errno));\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Spawning workers will be impossible. Aborting.\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\n\t\t\tif (test_configured_paths() == ERROR) {\n\t\t\t\t\/* error has already been logged *\/\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\/* enter daemon mode (unless we're restarting...) *\/\n\t\t\tif(daemon_mode == TRUE && sigrestart == FALSE) {\n\n\t\t\t\tresult = daemon_init();\n\n\t\t\t\t\/* we had an error daemonizing, so bail... *\/\n\t\t\t\tif(result == ERROR) {\n\t\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, \"Bailing out due to failure to daemonize. (PID=%d)\", (int)getpid());\n\t\t\t\t\tcleanup();\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t\t}\n\n\t\t\t\t\/* get new PID *\/\n\t\t\t\tnagios_pid = (int)getpid();\n\t\t\t\t}\n\n\t\t\t\/* this must be logged after we read config data, as user may have changed location of main log file *\/\n\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Nagios %s starting... (PID=%d)\\n\", PROGRAM_VERSION, (int)getpid());\n\n\t\t\t\/* log the local time - may be different than clock time due to timezone offset *\/\n\t\t\tnow = time(NULL);\n\t\t\ttm = localtime_r(&now, &tm_s);\n\t\t\tstrftime(datestring, sizeof(datestring), \"%a %b %d %H:%M:%S %Z %Y\", tm);\n\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Local time is %s\", datestring);","target":1,"flaw_line_index":0,"hash":"13be4dba-bbad-4f3f-8465-5487008258ec","idx":"d130ae84-5c8b-4186-b55a-4b2a9aefa688"}
{"func_before":"\t\t\t\tlogit(NSLOG_CONFIG_ERROR, TRUE, \"Error: Failed to process config file '%s'. Aborting\\n\", config_file);\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\ttiming_point(\"Main config file read\\n\");\n\n\t\t\t\/* NOTE 11\/06\/07 EG moved to after we read config files, as user may have overridden timezone offset *\/\n\t\t\t\/* get program (re)start time and save as macro *\/\n\t\t\tprogram_start = time(NULL);\n\t\t\tmy_free(mac->x[MACRO_PROCESSSTARTTIME]);\n\t\t\tasprintf(&mac->x[MACRO_PROCESSSTARTTIME], \"%llu\", (unsigned long long)program_start);\n\t\t\t\n\t\t\t\/* enter daemon mode (unless we're restarting...) *\/\n\t\t\tif(daemon_mode == TRUE && sigrestart == FALSE) {\n\n\t\t\t\tresult = daemon_init();\n\n\t\t\t\t\/* we had an error daemonizing, so bail... *\/\n\t\t\t\tif(result == ERROR) {\n\t\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR, TRUE, \"Bailing out due to failure to daemonize. (PID=%d)\", (int)getpid());\n\t\t\t\t\tcleanup();\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t\t}\n\n\t\t\t\t\/* get new PID *\/\n\t\t\t\tnagios_pid = (int)getpid();\n\t\t\t\t}\n\n\t\t\t\/* drop privileges *\/\n\t\t\tif(drop_privileges(nagios_user, nagios_group) == ERROR) {\n\n\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, \"Failed to drop privileges.  Aborting.\");\n\n\t\t\t\tcleanup();\n\t\t\t\texit(ERROR);\n\t\t\t\t}\n\n\t\t\tif (test_path_access(nagios_binary_path, X_OK)) {\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: failed to access() %s: %s\\n\", nagios_binary_path, strerror(errno));\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Spawning workers will be impossible. Aborting.\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\n\t\t\tif (test_configured_paths() == ERROR) {\n\t\t\t\t\/* error has already been logged *\/\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\n\t\t\t\/* this must be logged after we read config data, as user may have changed location of main log file *\/\n\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Nagios %s starting... (PID=%d)\\n\", PROGRAM_VERSION, (int)getpid());\n\n\t\t\t\/* log the local time - may be different than clock time due to timezone offset *\/\n\t\t\tnow = time(NULL);\n\t\t\ttm = localtime_r(&now, &tm_s);\n\t\t\tstrftime(datestring, sizeof(datestring), \"%a %b %d %H:%M:%S %Z %Y\", tm);\n\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Local time is %s\", datestring);","target":0,"flaw_line_index":0,"hash":"98f755be-388e-4964-860d-275e3dc67298","idx":"4373fafa-c42a-40e2-a7c7-c46ed2a4406a"}
{"func_before":"\t\tpipe_unlock(pipe);\n\t\treturn -ENOMEM;\n\t}\n\n\tnbuf = 0;\n\trem = 0;\n\tfor (idx = 0; idx < pipe->nrbufs && rem < len; idx++)\n\t\trem += pipe->bufs[(pipe->curbuf + idx) & (pipe->buffers - 1)].len;\n\n\tret = -EINVAL;\n\tif (rem < len) {\n\t\tpipe_unlock(pipe);\n\t\tgoto out;\n\t}\n\n\trem = len;\n\twhile (rem) {\n\t\tstruct pipe_buffer *ibuf;\n\t\tstruct pipe_buffer *obuf;\n\n\t\tBUG_ON(nbuf >= pipe->buffers);\n\t\tBUG_ON(!pipe->nrbufs);\n\t\tibuf = &pipe->bufs[pipe->curbuf];\n\t\tobuf = &bufs[nbuf];\n\n\t\tif (rem >= ibuf->len) {\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t} else {\n\t\t\tpipe_buf_get(pipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\t\tobuf->len = rem;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tnbuf++;\n\t\trem -= obuf->len;\n\t}\n\tpipe_unlock(pipe);\n\tfuse_copy_init(&cs, 0, NULL);\n\tcs.pipebufs = bufs;\n\tcs.nr_segs = nbuf;\n\tcs.pipe = pipe;\n\n\tif (flags & SPLICE_F_MOVE)\n\t\tcs.move_pages = 1;\n\n\tret = fuse_dev_do_write(fud, &cs, len);\n\n\tpipe_lock(pipe);\n\tfor (idx = 0; idx < nbuf; idx++)\n\t\tpipe_buf_release(pipe, &bufs[idx]);\n\tpipe_unlock(pipe);\n\nout:\n\tkvfree(bufs);\n\treturn ret;\n}","target":1,"flaw_line_index":0,"hash":"086bfeb8-6b02-46f5-94c2-20678dc81672","idx":"05696843-ef05-429a-9168-90e82c8cae6f"}
{"func_before":"\t\tpipe_unlock(pipe);\n\t\treturn -ENOMEM;\n\t}\n\n\tnbuf = 0;\n\trem = 0;\n\tfor (idx = 0; idx < pipe->nrbufs && rem < len; idx++)\n\t\trem += pipe->bufs[(pipe->curbuf + idx) & (pipe->buffers - 1)].len;\n\n\tret = -EINVAL;\n\tif (rem < len)\n\t\tgoto out_free;\n\n\trem = len;\n\twhile (rem) {\n\t\tstruct pipe_buffer *ibuf;\n\t\tstruct pipe_buffer *obuf;\n\n\t\tBUG_ON(nbuf >= pipe->buffers);\n\t\tBUG_ON(!pipe->nrbufs);\n\t\tibuf = &pipe->bufs[pipe->curbuf];\n\t\tobuf = &bufs[nbuf];\n\n\t\tif (rem >= ibuf->len) {\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t} else {\n\t\t\tif (!pipe_buf_get(pipe, ibuf))\n\t\t\t\tgoto out_free;\n\n\t\t\t*obuf = *ibuf;\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\t\tobuf->len = rem;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tnbuf++;\n\t\trem -= obuf->len;\n\t}\n\tpipe_unlock(pipe);\n\tcs.pipebufs = bufs;\n\tcs.nr_segs = nbuf;\n\tcs.pipe = pipe;\n\n\tif (flags & SPLICE_F_MOVE)\n\t\tcs.move_pages = 1;\n\n\tret = fuse_dev_do_write(fud, &cs, len);\n\n\tpipe_lock(pipe);\nout_free:\n\tfor (idx = 0; idx < nbuf; idx++)\n\t\tpipe_buf_release(pipe, &bufs[idx]);\n\tpipe_unlock(pipe);\n\n\tkvfree(bufs);\n\treturn ret;\n}","target":0,"flaw_line_index":0,"hash":"53512788-649f-4964-a93b-11275e841b67","idx":"189620da-256d-47c9-81af-2736b6b2bc3a"}
{"func_before":"void deletesuccessor(file_t **existing, file_t *duplicate, int matchconfirmed,\n      int (*comparef)(file_t *f1, file_t *f2), struct log_info *loginfo)\n{\n  file_t *to_keep;\n  file_t *to_delete;\n\n  if (comparef(duplicate, *existing) >= 0)\n  {\n    to_keep = *existing;\n    to_delete = duplicate;\n  }\n  else\n  {\n    to_keep = duplicate;\n    to_delete = *existing;\n  if (loginfo)\n    log_begin_set(loginfo);\n\n  printf(\"   [+] %s\\n\", to_keep->d_name);\n\n  if (loginfo)\n    log_file_remaining(loginfo, to_keep->d_name);\n\n  if (matchconfirmed)\n  {\n    if (remove(to_delete->d_name) == 0) {\n      printf(\"   [-] %s\\n\", to_delete->d_name);\n\n      if (loginfo)\n        log_file_deleted(loginfo, to_delete->d_name);\n    } else {\n      printf(\"   [!] %s \", to_delete->d_name);\n      printf(\"-- unable to delete file!\\n\");\n\n      if (loginfo)\n        log_file_remaining(loginfo, to_delete->d_name);\n    }\n  }\n  else\n  {\n    printf(\"   [!] %s\\n\", to_delete->d_name);\n    printf(\" -- unable to confirm match; file not deleted!\\n\");\n","target":1,"flaw_line_index":0,"hash":"1cc9bc91-d9da-4671-9244-2f767b5bf896","idx":"df242389-d3d6-4253-84a2-72b338b98f0f"}
{"func_before":"void deletesuccessor(file_t **existing, file_t *duplicate, int matchconfirmed,\n      int (*comparef)(file_t *f1, file_t *f2), struct log_info *loginfo)\n{\n  file_t *to_keep;\n  file_t *to_delete;\n  char *errorstring;\n\n  if (comparef(duplicate, *existing) >= 0)\n  {\n    to_keep = *existing;\n    to_delete = duplicate;\n  }\n  else\n  {\n    to_keep = duplicate;\n    to_delete = *existing;\n  if (loginfo)\n    log_begin_set(loginfo);\n\n  printf(\"   [+] %s\\n\", to_keep->d_name);\n\n  if (loginfo)\n    log_file_remaining(loginfo, to_keep->d_name);\n\n  if (matchconfirmed)\n  {\n    if (removeifnotchanged(to_delete, &errorstring) == 0) {\n      printf(\"   [-] %s\\n\", to_delete->d_name);\n\n      if (loginfo)\n        log_file_deleted(loginfo, to_delete->d_name);\n    } else {\n      printf(\"   [!] %s \", to_delete->d_name);\n      printf(\"-- unable to delete file: %s!\\n\", errorstring);\n\n      if (loginfo)\n        log_file_remaining(loginfo, to_delete->d_name);\n    }\n  }\n  else\n  {\n    printf(\"   [!] %s\\n\", to_delete->d_name);\n    printf(\" -- unable to confirm match; file not deleted!\\n\");\n","target":0,"flaw_line_index":0,"hash":"2ab257be-1c08-45ca-a868-364d5a52532b","idx":"78245c1f-42bf-40c3-8bdb-a5a6d0ec8791"}
{"func_before":"void CoreUserInputHandler::handleSay(const BufferInfo &bufferInfo, const QString &msg)\n{\n    if (bufferInfo.bufferName().isEmpty() || !bufferInfo.acceptsRegularMessages())\n        return;  \/\/ server buffer\n\n    QByteArray encMsg = channelEncode(bufferInfo.bufferName(), msg);\n#ifdef HAVE_QCA2\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg, network()->cipher(bufferInfo.bufferName()));\n#else\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg);\n#endif\n    emit displayMsg(Message::Plain, bufferInfo.type(), bufferInfo.bufferName(), msg, network()->myNick(), Message::Self);\n}","target":1,"flaw_line_index":0,"hash":"31199622-b394-48b8-9c16-852316840c50","idx":"0a56436a-036e-465b-97a2-7f05781270bc"}
{"func_before":"void CoreUserInputHandler::handleSay(const BufferInfo &bufferInfo, const QString &msg)\n{\n    if (bufferInfo.bufferName().isEmpty() || !bufferInfo.acceptsRegularMessages())\n        return;  \/\/ server buffer\n\n    std::function<QByteArray(const QString &, const QString &)> encodeFunc = [this] (const QString &target, const QString &message) -> QByteArray {\n        return channelEncode(target, message);\n    };\n\n#ifdef HAVE_QCA2\n    putPrivmsg(bufferInfo.bufferName(), msg, encodeFunc, network()->cipher(bufferInfo.bufferName()));\n#else\n    putPrivmsg(bufferInfo.bufferName(), msg, encodeFunc);\n#endif\n    emit displayMsg(Message::Plain, bufferInfo.type(), bufferInfo.bufferName(), msg, network()->myNick(), Message::Self);\n}","target":0,"flaw_line_index":0,"hash":"87ff92fe-592f-44e0-b5cf-aa5e5d26a992","idx":"27d8963c-df04-4cc1-8348-7c8f4c98c264"}
{"func_before":"static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t\/* This is the main host *\/\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\t\/* That's us.  Be sure we keep track of the peer call number *\/\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t\/* We're transferring *\/\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}","target":1,"flaw_line_index":0,"hash":"e0174baf-c6b8-4410-99c7-b69cc42cff14","idx":"baee3f44-961b-4959-9d4d-e851d887a927"}
{"func_before":"static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t\/* This is the main host *\/\n\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n\t\t\t\/* That's us.  Be sure we keep track of the peer call number *\/\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t\/* We're transferring *\/\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}","target":0,"flaw_line_index":0,"hash":"c8bbad65-5ef2-4d90-8aac-05b476228dc7","idx":"86e031f5-0aae-484c-8f5f-2e4aa530cb7f"}
{"func_before":"static RzList *classes_from_symbols(RzBinFile *bf) {\n\tRzBinSymbol *sym;\n\tRzListIter *iter;\n\trz_list_foreach (bf->o->symbols, iter, sym) {\n\t\tif (sym->name[0] != '_') {\n\t\t\tcontinue;\n\t\t}\n\t\tconst char *cn = sym->classname;\n\t\tif (cn) {\n\t\t\tRzBinClass *c = rz_bin_file_add_class(bf, sym->classname, NULL, 0);\n\t\t\tif (!c) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\/\/ swift specific\n\t\t\tchar *dn = sym->dname;","target":1,"flaw_line_index":0,"hash":"83a4426d-bc27-4813-a04b-c638582d772c","idx":"5b078f13-9f2b-4117-bbbf-86ae3bb71d1a"}
{"func_before":"static RzList *classes_from_symbols(RzBinFile *bf) {\n\tRzBinSymbol *sym;\n\tRzListIter *iter;\n\trz_list_foreach (bf->o->symbols, iter, sym) {\n\t\tif (!sym->name || sym->name[0] != '_') {\n\t\t\tcontinue;\n\t\t}\n\t\tconst char *cn = sym->classname;\n\t\tif (cn) {\n\t\t\tRzBinClass *c = rz_bin_file_add_class(bf, sym->classname, NULL, 0);\n\t\t\tif (!c) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\/\/ swift specific\n\t\t\tchar *dn = sym->dname;","target":0,"flaw_line_index":0,"hash":"b45b3fb5-62cd-4a48-8639-d7f4ba8a80d6","idx":"d3e2f308-8f94-44e1-a81e-cf68baf669b1"}
{"func_before":"ext2_xattr_delete_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct mb_cache_entry *ce;\n\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\tif (!bh) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: block %d read error\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tea_bdebug(bh, \"b_count=%d\", atomic_read(&(bh->b_count)));\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev, bh->b_blocknr);\n\tlock_buffer(bh);\n\tif (HDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\text2_free_blocks(inode, EXT2_I(inode)->i_file_acl, 1);\n\t\tget_bh(bh);\n\t\tbforget(bh);\n\t\tunlock_buffer(bh);\n\t} else {\n\t\tle32_add_cpu(&HDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\tea_bdebug(bh, \"refcount now=%d\",\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tif (IS_SYNC(inode))\n\t\t\tsync_dirty_buffer(bh);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t}\n\tEXT2_I(inode)->i_file_acl = 0;\n","target":1,"flaw_line_index":0,"hash":"d06a0b74-b376-4a1f-9442-73b505791b77","idx":"e58a9452-0905-4420-99ea-eadc428f373e"}
{"func_before":"ext2_xattr_delete_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\tif (!bh) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: block %d read error\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tea_bdebug(bh, \"b_count=%d\", atomic_read(&(bh->b_count)));\n\tif (HDR(bh)->h_magic != cpu_to_le32(EXT2_XATTR_MAGIC) ||\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tlock_buffer(bh);\n\tif (HDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\n\t\t\/*\n\t\t * This must happen under buffer lock for ext2_xattr_set2() to\n\t\t * reliably detect freed block\n\t\t *\/\n\t\tmb2_cache_entry_delete_block(EXT2_SB(inode->i_sb)->s_mb_cache,\n\t\t\t\t\t     hash, bh->b_blocknr);\n\t\text2_free_blocks(inode, EXT2_I(inode)->i_file_acl, 1);\n\t\tget_bh(bh);\n\t\tbforget(bh);\n\t\tunlock_buffer(bh);\n\t} else {\n\t\tle32_add_cpu(&HDR(bh)->h_refcount, -1);\n\t\tea_bdebug(bh, \"refcount now=%d\",\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tif (IS_SYNC(inode))\n\t\t\tsync_dirty_buffer(bh);\n\t\tdquot_free_block_nodirty(inode, 1);\n\t}\n\tEXT2_I(inode)->i_file_acl = 0;\n","target":0,"flaw_line_index":0,"hash":"06785f33-0246-4f9b-a807-9ebb821cf57c","idx":"ae6140a2-6464-42c9-a497-06553eff6ba9"}
{"func_before":"\n    OP_REQUIRES_OK(context, context->input(\"sparse_indices\", &input_indices));\n    OP_REQUIRES_OK(context, context->input(\"sparse_values\", &input_values));\n    OP_REQUIRES_OK(context, context->input(\"sparse_shape\", &input_shape));\n    OP_REQUIRES_OK(context, GetMap(context, true \/* is_writing *\/, &map));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    input_indices->shape().DebugString()));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    input_values->shape().DebugString()));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    input_shape->shape().DebugString()));\n\n    int rank = input_shape->NumElements();\n\n    OP_REQUIRES(\n        context, rank > 1,\n        errors::InvalidArgument(\n            \"Rank of input SparseTensor should be > 1, but saw rank: \", rank));\n\n    auto input_shape_vec = input_shape->vec<int64_t>();\n    int new_num_elements = 1;","target":1,"flaw_line_index":0,"hash":"7e9819c8-e5ed-463f-8d5f-eaa518414077","idx":"b56d6a09-be4f-4449-a4f5-1bc5597c77ae"}
{"func_before":"    SparseTensorsMap* map;\n\n    OP_REQUIRES_OK(context, context->input(\"sparse_indices\", &input_indices));\n    OP_REQUIRES_OK(context, context->input(\"sparse_values\", &input_values));\n    OP_REQUIRES_OK(context, context->input(\"sparse_shape\", &input_shape));\n    OP_REQUIRES_OK(context, GetMap(context, true \/* is_writing *\/, &map));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    input_indices->shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    input_values->shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    input_shape->shape().DebugString()));\n    OP_REQUIRES(\n        context,\n        input_values->shape().dim_size(0) == input_indices->shape().dim_size(0),\n        errors::InvalidArgument(\n            \"Number of values must match first dimension of indices. \", \"Got \",\n            input_values->shape().dim_size(0),\n            \" values, indices shape: \", input_indices->shape().DebugString()));\n    OP_REQUIRES(\n        context,\n        input_shape->shape().dim_size(0) == input_indices->shape().dim_size(1),\n        errors::InvalidArgument(\n            \"Number of dimensions must match second dimension of indices. \",\n            \"Got \", input_shape->shape().dim_size(0),\n            \" dimensions, indices shape: \",\n            input_indices->shape().DebugString()));\n\n    int rank = input_shape->NumElements();\n\n    OP_REQUIRES(\n        context, rank > 1,\n        errors::InvalidArgument(\n            \"Rank of input SparseTensor should be > 1, but saw rank: \", rank));\n\n    auto input_shape_vec = input_shape->vec<int64_t>();\n    int new_num_elements = 1;","target":0,"flaw_line_index":0,"hash":"951c7bda-00a7-419b-b191-18dc8c71ef12","idx":"bbd03018-727b-40e0-9dd6-224f7d7fcdac"}
{"func_before":"\t\tif (parm != NULL)\n\t\t\tr = decode_bit_field(obj, objlen, (u8 *) parm, *len);\n\t\tbreak;\n\tcase SC_ASN1_OCTET_STRING:\n\t\tif (parm != NULL) {\n\t\t\tsize_t c;\n\t\t\tassert(len != NULL);\n\n\t\t\t\/* Strip off padding zero *\/\n\t\t\tif ((entry->flags & SC_ASN1_UNSIGNED)\n\t\t\t && obj[0] == 0x00 && objlen > 1) {\n\t\t\t\tobjlen--;\n\t\t\t\tobj++;\n\t\t\t}\n\n\t\t\t\/* Allocate buffer if needed *\/\n\t\t\tif (entry->flags & SC_ASN1_ALLOC) {\n\t\t\t\tu8 **buf = (u8 **) parm;\n\t\t\t\t*buf = malloc(objlen);\n\t\t\t\tif (*buf == NULL) {\n\t\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;","target":1,"flaw_line_index":0,"hash":"99d13cae-abea-4891-8bd6-0f110afff2b3","idx":"f8008515-b3a5-422d-bb91-b5e190df3d6e"}
{"func_before":"\t\tif (parm != NULL)\n\t\t\tr = decode_bit_field(obj, objlen, (u8 *) parm, *len);\n\t\tbreak;\n\tcase SC_ASN1_OCTET_STRING:\n\t\tif (parm != NULL) {\n\t\t\tsize_t c;\n\t\t\tassert(len != NULL);\n\n\t\t\t\/* Strip off padding zero *\/\n\t\t\tif ((entry->flags & SC_ASN1_UNSIGNED)\n\t\t\t\t\t&& objlen > 1 && obj[0] == 0x00) {\n\t\t\t\tobjlen--;\n\t\t\t\tobj++;\n\t\t\t}\n\n\t\t\t\/* Allocate buffer if needed *\/\n\t\t\tif (entry->flags & SC_ASN1_ALLOC) {\n\t\t\t\tu8 **buf = (u8 **) parm;\n\t\t\t\t*buf = malloc(objlen);\n\t\t\t\tif (*buf == NULL) {\n\t\t\t\t\tr = SC_ERROR_OUT_OF_MEMORY;","target":0,"flaw_line_index":0,"hash":"246cd163-4604-4f5b-8586-db7d2489aa1e","idx":"31077877-5746-4271-82d3-eec30d0ca410"}
{"func_before":"static json_t * check_attestation_fido_u2f(json_t * j_params, unsigned char * credential_id, size_t credential_id_len, unsigned char * cert_x, size_t cert_x_len, unsigned char * cert_y, size_t cert_y_len, cbor_item_t * att_stmt, unsigned char * rpid_hash, size_t rpid_hash_len, const unsigned char * client_data) {\n  json_t * j_error = json_array(), * j_return;\n  cbor_item_t * key = NULL, * x5c = NULL, * sig = NULL, * att_cert = NULL;\n  int i, ret;\n  char * message = NULL;\n  gnutls_pubkey_t pubkey = NULL;\n  gnutls_x509_crt_t cert = NULL;\n  gnutls_datum_t cert_dat, data, signature, cert_issued_by;\n  unsigned char data_signed[200], client_data_hash[32], cert_export[32], cert_export_b64[64];\n  size_t data_signed_offset = 0, client_data_hash_len = 32, cert_export_len = 32, cert_export_b64_len = 0;\n  \n  if (j_error != NULL) {\n    do {\n      if (gnutls_x509_crt_init(&cert)) {\n        json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_x509_crt_init\"));\n        break;\n      }\n      if (gnutls_pubkey_init(&pubkey)) {\n        json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_pubkey_init\"));\n      if (!generate_digest_raw(digest_SHA256, client_data, o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) {\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error generate_digest_raw client_data\");\n        break;\n      }\n\n      if (sig == NULL || !cbor_isa_bytestring(sig)) {\n        json_array_append_new(j_error, json_string(\"Error sig is not a bytestring\"));\n        break;\n      }\n      \n      \/\/ Build bytestring to verify signature\n      data_signed[0] = 0x0;\n      data_signed_offset = 1;\n      \n      memcpy(data_signed+data_signed_offset, rpid_hash, rpid_hash_len);\n      data_signed_offset += rpid_hash_len;\n      \n      memcpy(data_signed+data_signed_offset, client_data_hash, client_data_hash_len);\n      data_signed_offset+=client_data_hash_len;\n      \n      data.data = data_signed;\n      data.size = data_signed_offset;\n      \n      signature.data = cbor_bytestring_handle(sig);\n      signature.size = cbor_bytestring_length(sig);\n      \n      if (gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) {\n        json_array_append_new(j_error, json_string(\"Invalid signature\"));\n      }\n      \n    } while (0);\n    \n    if (json_array_size(j_error)) {\n      j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"error\", j_error);\n    } else {\n      j_return = json_pack(\"{sis{ss%}}\", \"result\", G_OK, \"data\", \"certificate\", cert_export_b64, cert_export_b64_len);\n    }\n    json_decref(j_error);\n    gnutls_pubkey_deinit(pubkey);\n    gnutls_x509_crt_deinit(cert);\n    if (att_cert != NULL) {","target":1,"flaw_line_index":0,"hash":"c1307850-4636-452b-8a75-7187d5564d38","idx":"bfddf85c-4b82-4cfb-8f72-e51515227839"}
{"func_before":"static json_t * check_attestation_fido_u2f(json_t * j_params, unsigned char * credential_id, size_t credential_id_len, unsigned char * cert_x, size_t cert_x_len, unsigned char * cert_y, size_t cert_y_len, cbor_item_t * att_stmt, unsigned char * rpid_hash, size_t rpid_hash_len, const unsigned char * client_data) {\n  json_t * j_error = json_array(), * j_return;\n  cbor_item_t * key = NULL, * x5c = NULL, * sig = NULL, * att_cert = NULL;\n  int i, ret;\n  char * message = NULL;\n  gnutls_pubkey_t pubkey = NULL;\n  gnutls_x509_crt_t cert = NULL;\n  gnutls_datum_t cert_dat, data, signature, cert_issued_by;\n  unsigned char * data_signed = NULL, client_data_hash[32], cert_export[32], cert_export_b64[64];\n  size_t data_signed_offset = 0, client_data_hash_len = 32, cert_export_len = 32, cert_export_b64_len = 0;\n  \n  if (j_error != NULL) {\n    do {\n      if (gnutls_x509_crt_init(&cert)) {\n        json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_x509_crt_init\"));\n        break;\n      }\n      if (gnutls_pubkey_init(&pubkey)) {\n        json_array_append_new(j_error, json_string(\"check_attestation_fido_u2f - Error gnutls_pubkey_init\"));\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        y_log_message(Y_LOG_LEVEL_ERROR, \"check_attestation_fido_u2f - Error generate_digest_raw client_data\");\n        break;\n      }\n\n      if (sig == NULL || !cbor_isa_bytestring(sig)) {\n        json_array_append_new(j_error, json_string(\"Error sig is not a bytestring\"));\n        break;\n      }\n      \n      if ((data_signed = o_malloc(rpid_hash_len+client_data_hash_len+credential_id_len+cert_x_len+cert_y_len+2)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error allocating data_signed\");\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        break;\n      }\n      \n      \/\/ Build bytestring to verify signature\n      data_signed[0] = 0x0;\n      data_signed_offset = 1;\n      \n      memcpy(data_signed+data_signed_offset, rpid_hash, rpid_hash_len);\n      data_signed_offset += rpid_hash_len;\n      \n      memcpy(data_signed+data_signed_offset, client_data_hash, client_data_hash_len);\n      data_signed_offset+=client_data_hash_len;\n      \n      data.size = data_signed_offset;\n      \n      signature.data = cbor_bytestring_handle(sig);\n      signature.size = cbor_bytestring_length(sig);\n      \n      if (gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) {\n        json_array_append_new(j_error, json_string(\"Invalid signature\"));\n      }\n      \n    } while (0);\n    o_free(data_signed);\n    \n    if (json_array_size(j_error)) {\n      j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"error\", j_error);\n    } else {\n      j_return = json_pack(\"{sis{ss%}}\", \"result\", G_OK, \"data\", \"certificate\", cert_export_b64, cert_export_b64_len);\n    }\n    json_decref(j_error);\n    gnutls_pubkey_deinit(pubkey);\n    gnutls_x509_crt_deinit(cert);\n    if (att_cert != NULL) {","target":0,"flaw_line_index":0,"hash":"1330e1ff-bc3b-46d3-bde8-8e40c4612d3c","idx":"b46cb03c-3b38-49a2-b350-3ac1a92c392e"}
{"func_before":"    if (!message) {\n        log_warning(\"Carbon received with no message element\");\n        return TRUE;\n    }\n\n    char *message_txt = xmpp_message_get_body(message);\n    if (!message_txt) {\n        log_warning(\"Carbon received with no message.\");\n        return TRUE;\n    }\n\n    const gchar *to = xmpp_stanza_get_to(message);\n    const gchar *from = xmpp_stanza_get_from(message);\n\n    \/\/ happens when receive a carbon of a self sent message\n    if (!to) to = from;\n\n    Jid *jid_from = jid_create(from);\n    Jid *jid_to = jid_create(to);\n    Jid *my_jid = jid_create(connection_get_fulljid());\n\n    \/\/ check for pgp encrypted message\n    char *enc_message = NULL;\n    xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);\n    if (x) {\n        enc_message = xmpp_stanza_get_text(x);\n    }\n\n    \/\/ if we are the recipient, treat as standard incoming message\n    if (g_strcmp0(my_jid->barejid, jid_to->barejid) == 0) {","target":1,"flaw_line_index":0,"hash":"0519d39b-214d-4d3f-98e5-474aa65703b5","idx":"e3526abf-ce8a-4a1e-a585-8bf4395af43b"}
{"func_before":"        log_warning(\"Carbon received with no message element\");\n        return TRUE;\n    }\n\n    char *message_txt = xmpp_message_get_body(message);\n    if (!message_txt) {\n        log_warning(\"Carbon received with no message.\");\n        return TRUE;\n    }\n\n    Jid *my_jid = jid_create(connection_get_fulljid());\n    const char *const stanza_from = xmpp_stanza_get_from(stanza);\n    Jid *msg_jid = jid_create(stanza_from);\n    if (g_strcmp0(my_jid->barejid, msg_jid->barejid) != 0) {\n        log_warning(\"Invalid carbon received, from: %s\", stanza_from);\n        return TRUE;\n    }\n\n    const gchar *to = xmpp_stanza_get_to(message);\n    const gchar *from = xmpp_stanza_get_from(message);\n\n    \/\/ happens when receive a carbon of a self sent message\n    if (!to) to = from;\n\n    Jid *jid_from = jid_create(from);\n    Jid *jid_to = jid_create(to);\n\n    \/\/ check for pgp encrypted message\n    char *enc_message = NULL;\n    xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);\n    if (x) {\n        enc_message = xmpp_stanza_get_text(x);\n    }\n\n    \/\/ if we are the recipient, treat as standard incoming message\n    if (g_strcmp0(my_jid->barejid, jid_to->barejid) == 0) {","target":0,"flaw_line_index":0,"hash":"ca2ea51e-b409-43ee-83fe-768c3fe2667d","idx":"eacf34bd-f840-44da-a29d-763eed38ed2b"}
{"func_before":"\tif (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_WRONLY)) {\n\t\tsize = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (strcmp(f->file, \"tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"\/tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"\/cgroup.procs\") == 0 ||\n\t\t\tstrcmp(f->file, \"cgroup.procs\") == 0)\n\t\t\/\/ special case - we have to translate the pids\n\t\tr = do_write_pids(fc->pid, f->controller, f->cgroup, f->file, localbuf);\n\telse\n\t\tr = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf);\n\n\tif (!r)\n\t\tsize = -EINVAL;\n\nout:\n\tfree_key(k);\n\treturn size;\n}","target":1,"flaw_line_index":0,"hash":"3c6bff9e-8309-44e2-9d4f-215d39131494","idx":"ef06f3c2-726b-47aa-a922-75202e302ee2"}
{"func_before":"\tif (!fc_may_access(fc, f->controller, f->cgroup, f->file, O_WRONLY)) {\n\t\tsize = -EACCES;\n\t\tgoto out;\n\t}\n\n\tif (strcmp(f->file, \"tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"\/tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"\/cgroup.procs\") == 0 ||\n\t\t\tstrcmp(f->file, \"cgroup.procs\") == 0)\n\t\t\/\/ special case - we have to translate the pids\n\t\tr = do_write_pids(fc->pid, fc->uid, f->controller, f->cgroup, f->file, localbuf);\n\telse\n\t\tr = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf);\n\n\tif (!r)\n\t\tsize = -EINVAL;\n\nout:\n\tfree_key(k);\n\treturn size;\n}","target":0,"flaw_line_index":0,"hash":"6b292445-a1f8-41a3-a44c-f4f697279358","idx":"52301c9f-cc10-4270-a500-3c3f33114195"}
{"func_before":"void AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    AreaData::Evidence evi = {argv[1], argv[2], argv[3]};\n    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n        area->replaceEvidence(idx, evi);\n    }\n    sendEvidenceList(area);\n}","target":1,"flaw_line_index":0,"hash":"9387616c-1416-402b-b324-deb9c40eba40","idx":"1874f33c-9a74-411d-aafc-7d241bcf84d4"}
{"func_before":"void AOClient::pktEditEvidence(AreaData* area, int argc, QStringList argv, AOPacket packet)\n{\n    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    AreaData::Evidence evi = {argv[1], argv[2], argv[3]};\n    if (is_int && idx < area->evidence().size() && idx >= 0) {\n        area->replaceEvidence(idx, evi);\n    }\n    sendEvidenceList(area);\n}","target":0,"flaw_line_index":0,"hash":"926c9f13-095d-409a-8b83-457468ef3d7e","idx":"940a7293-c15e-421b-abb2-fda7e3cbd6e6"}
{"func_before":"  void operator()(const CPUDevice& d, typename TTypes<T>::ConstFlat gradient,\n                  typename TTypes<T>::ConstFlat input,\n                  typename TTypes<T>::ConstScalar input_min_tensor,\n                  typename TTypes<T>::ConstScalar input_max_tensor,\n                  typename TTypes<T>::Flat input_backprop,\n                  typename TTypes<T>::Scalar input_min_backprop,\n                  typename TTypes<T>::Scalar input_max_backprop) {\n    QuantizeAndDequantizeOneScaleGradientImpl<CPUDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }","target":1,"flaw_line_index":0,"hash":"bec208c3-7d05-47f1-a287-7e19c70ea510","idx":"16a2266b-f852-41bf-ac92-106f04541e38"}
{"func_before":"  void operator()(const CpuDevice& d, typename TTypes<T>::ConstFlat gradient,\n                  typename TTypes<T>::ConstFlat input,\n                  typename TTypes<T>::ConstScalar input_min_tensor,\n                  typename TTypes<T>::ConstScalar input_max_tensor,\n                  typename TTypes<T>::Flat input_backprop,\n                  typename TTypes<T>::Scalar input_min_backprop,\n                  typename TTypes<T>::Scalar input_max_backprop) {\n    QuantizeAndDequantizeOneScaleGradientImpl<CpuDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }","target":0,"flaw_line_index":0,"hash":"3d7b3f4c-9ee7-4d05-b8c3-79ef546b3cfc","idx":"798d7f82-9976-496d-bb5c-94b75a0c1223"}
{"func_before":"int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"2fa1e7cc-b46b-40c9-9688-9060244d7bb3","idx":"07acc404-f35c-4905-8220-0a3b3e98c2fa"}
{"func_before":"int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"418b64f7-a974-4653-97fb-da13027674d7","idx":"472fb0a9-aafb-466d-931d-ceb41f7cedfd"}
{"func_before":"                            shape.DebugString(), \" which is not fully defined\");\n  }\n\n  PartialTensorShape new_dims;\n  if (outputs[0]->dtype() == DT_INT32) {\n    std::vector<int32> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int32_t dim = outputs[0]->flat<int32>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  } else {\n    std::vector<int64_t> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int64_t dim = outputs[0]->flat<int64_t>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  }\n\n  if (!shape.IsCompatibleWith(new_dims)) {\n    return errors::Internal(\"Expected shape \", shape.DebugString(),\n                            \"to be compatible with \", new_dims.DebugString());\n  }\n\n  return Status::OK();\n}","target":1,"flaw_line_index":0,"hash":"3c447821-de94-41ed-ae8c-9dfc87714de2","idx":"3803e316-232a-449c-ae86-25273d3862b6"}
{"func_before":"                            shape.DebugString(), \" which is not fully defined\");\n  }\n\n  PartialTensorShape new_dims;\n  if (outputs[0]->dtype() == DT_INT32) {\n    std::vector<int32> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int32_t dim = outputs[0]->flat<int32>()(i);\n      shp.push_back(dim);\n    }\n    s = TensorShapeUtils::MakeShape(shp, &new_dims);\n    if (!s.ok()) return s;\n  } else {\n    std::vector<int64_t> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int64_t dim = outputs[0]->flat<int64_t>()(i);\n      shp.push_back(dim);\n    }\n    s = TensorShapeUtils::MakeShape(shp, &new_dims);\n    if (!s.ok()) return s;\n  }\n\n  if (!shape.IsCompatibleWith(new_dims)) {\n    return errors::Internal(\"Expected shape \", shape.DebugString(),\n                            \"to be compatible with \", new_dims.DebugString());\n  }\n\n  return Status::OK();\n}","target":0,"flaw_line_index":0,"hash":"1dd3bcca-019c-4f78-b8a7-d49c7978038b","idx":"f14a77f6-6433-4152-8fb3-98202aea2e76"}
{"func_before":"struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\n\t\tstruct dentry *new_dir, const char *new_name)\n{\n\tint error;\n\tstruct dentry *dentry = NULL, *trap;\n\tconst char *old_name;\n\n\ttrap = lock_rename(new_dir, old_dir);\n\t\/* Source or destination directories don't exist? *\/\n\tif (d_really_is_negative(old_dir) || d_really_is_negative(new_dir))\n\t\tgoto exit;\n\t\/* Source does not exist, cyclic rename, or mountpoint? *\/\n\tif (d_really_is_negative(old_dentry) || old_dentry == trap ||\n\t    d_mountpoint(old_dentry))\n\t\tgoto exit;\n\tdentry = lookup_one_len(new_name, new_dir, strlen(new_name));\n\t\/* Lookup failed, cyclic rename or target exists? *\/\n\tif (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))\n\t\tgoto exit;\n\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\n\terror = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),\n\t\t\t      dentry, 0);\n\tif (error) {\n\t\tfsnotify_oldname_free(old_name);\n\t\tgoto exit;\n\t}\n\td_move(old_dentry, dentry);\n\tfsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name,\n\t\td_is_dir(old_dentry),\n\t\tNULL, old_dentry);\n\tfsnotify_oldname_free(old_name);\n\tunlock_rename(new_dir, old_dir);\n\tdput(dentry);\n\treturn old_dentry;\nexit:\n\tif (dentry && !IS_ERR(dentry))\n\t\tdput(dentry);\n\tunlock_rename(new_dir, old_dir);\n\treturn NULL;\n}","target":1,"flaw_line_index":0,"hash":"78c99718-1749-411b-be5f-0ef05a7b196a","idx":"54ec82ae-f630-42f2-b2a1-c84eae9e3c1c"}
{"func_before":"struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\n\t\tstruct dentry *new_dir, const char *new_name)\n{\n\tint error;\n\tstruct dentry *dentry = NULL, *trap;\n\tstruct name_snapshot old_name;\n\n\ttrap = lock_rename(new_dir, old_dir);\n\t\/* Source or destination directories don't exist? *\/\n\tif (d_really_is_negative(old_dir) || d_really_is_negative(new_dir))\n\t\tgoto exit;\n\t\/* Source does not exist, cyclic rename, or mountpoint? *\/\n\tif (d_really_is_negative(old_dentry) || old_dentry == trap ||\n\t    d_mountpoint(old_dentry))\n\t\tgoto exit;\n\tdentry = lookup_one_len(new_name, new_dir, strlen(new_name));\n\t\/* Lookup failed, cyclic rename or target exists? *\/\n\tif (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))\n\t\tgoto exit;\n\n\ttake_dentry_name_snapshot(&old_name, old_dentry);\n\n\terror = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),\n\t\t\t      dentry, 0);\n\tif (error) {\n\t\trelease_dentry_name_snapshot(&old_name);\n\t\tgoto exit;\n\t}\n\td_move(old_dentry, dentry);\n\tfsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name.name,\n\t\td_is_dir(old_dentry),\n\t\tNULL, old_dentry);\n\trelease_dentry_name_snapshot(&old_name);\n\tunlock_rename(new_dir, old_dir);\n\tdput(dentry);\n\treturn old_dentry;\nexit:\n\tif (dentry && !IS_ERR(dentry))\n\t\tdput(dentry);\n\tunlock_rename(new_dir, old_dir);\n\treturn NULL;\n}","target":0,"flaw_line_index":0,"hash":"e16e4d23-d6da-40b5-bd01-e1fee78d51e8","idx":"14a7af38-1dc6-4d49-bf5c-5b670357ce3c"}
{"func_before":"TfLiteStatus PrepareAny(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteBool);\n  return PrepareSimple(context, node);\n}","target":1,"flaw_line_index":0,"hash":"b941f4de-3fce-4614-a94f-0717e3f292cd","idx":"6ffe5296-c0bc-4ca7-964e-06ef86c5a122"}
{"func_before":"TfLiteStatus PrepareAny(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteBool);\n  return PrepareSimple(context, node);\n}","target":0,"flaw_line_index":0,"hash":"9aa2ff2e-ef17-4170-a7da-2642a7a90bc1","idx":"e02da373-61b0-4257-b23d-74a478704c39"}
{"func_before":"\tbond_dev->netdev_ops = &bond_netdev_ops;\n\tbond_dev->ethtool_ops = &bond_ethtool_ops;\n\tbond_set_mode_ops(bond, bond->params.mode);\n\n\tbond_dev->destructor = bond_destructor;\n\n\t\/* Initialize the device options *\/\n\tbond_dev->tx_queue_len = 0;\n\tbond_dev->flags |= IFF_MASTER|IFF_MULTICAST;\n\tbond_dev->priv_flags |= IFF_BONDING;\n\tbond_dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\n\t\/* At first, we block adding VLANs. That's the only way to\n\t * prevent problems that occur when adding VLANs over an\n\t * empty bond. The block will be removed once non-challenged\n\t * slaves are enslaved.\n\t *\/\n\tbond_dev->features |= NETIF_F_VLAN_CHALLENGED;\n\n\t\/* don't acquire bond device's netif_tx_lock when\n\t * transmitting *\/","target":1,"flaw_line_index":0,"hash":"e83c1983-ae50-4bb0-bd6b-81fbe55560b3","idx":"57830ec2-f177-4835-8f57-3accf595f5b7"}
{"func_before":"\tbond_dev->netdev_ops = &bond_netdev_ops;\n\tbond_dev->ethtool_ops = &bond_ethtool_ops;\n\tbond_set_mode_ops(bond, bond->params.mode);\n\n\tbond_dev->destructor = bond_destructor;\n\n\t\/* Initialize the device options *\/\n\tbond_dev->tx_queue_len = 0;\n\tbond_dev->flags |= IFF_MASTER|IFF_MULTICAST;\n\tbond_dev->priv_flags |= IFF_BONDING;\n\tbond_dev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n\n\t\/* At first, we block adding VLANs. That's the only way to\n\t * prevent problems that occur when adding VLANs over an\n\t * empty bond. The block will be removed once non-challenged\n\t * slaves are enslaved.\n\t *\/\n\tbond_dev->features |= NETIF_F_VLAN_CHALLENGED;\n\n\t\/* don't acquire bond device's netif_tx_lock when\n\t * transmitting *\/","target":0,"flaw_line_index":0,"hash":"b45c8862-8abb-4a2e-852a-b61fe9702068","idx":"3aacc8b5-6bc9-4c74-8069-6a1813782134"}
{"func_before":"inline bool ShapeIsVector(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* shape = GetInput(context, node, kShapeTensor);\n  return (shape->dims->size == 1 && shape->type == kTfLiteInt32);\n}","target":1,"flaw_line_index":0,"hash":"888ae8ec-7131-409c-9a51-e83bc4ed16cd","idx":"786bdf40-0d12-4409-a33e-297e40d0f12a"}
{"func_before":"inline bool ShapeIsVector(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* shape = GetInput(context, node, kShapeTensor);\n  return (shape != nullptr && shape->dims->size == 1 &&\n          shape->type == kTfLiteInt32);\n}","target":0,"flaw_line_index":0,"hash":"53d14ff3-bfbc-4db5-a6ec-f3d4cb1ed1d0","idx":"c9c1d065-23da-411b-85ea-132c9699ccbb"}
{"func_before":"\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_COM))) {\n\t\treturn -1;\n\t}\n\tsprintf(buf, \"Creator: JasPer Version %s\", jas_getversion());\n\tcom = &enc->mrk->parms.com;\n\tcom->len = JAS_CAST(uint_fast16_t, strlen(buf));\n\tcom->regid = JPC_COM_LATIN;\n\tif (!(com->data = JAS_CAST(uchar *, jas_strdup(buf)))) {\n\t\tabort();\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write COM marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n#if 0","target":1,"flaw_line_index":0,"hash":"33d3c795-7aff-4c12-ac0f-ff0c0f21f15d","idx":"34b2a2e5-567f-41dc-bd3c-7920bb0cd154"}
{"func_before":"\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n\tif (!(enc->mrk = jpc_ms_create(JPC_MS_COM))) {\n\t\treturn -1;\n\t}\n\tsprintf(buf, \"Creator: JasPer Version %s\", jas_getversion());\n\tcom = &enc->mrk->parms.com;\n\tcom->len = JAS_CAST(uint_fast16_t, strlen(buf));\n\tcom->regid = JPC_COM_LATIN;\n\tif (!(com->data = JAS_CAST(jas_uchar *, jas_strdup(buf)))) {\n\t\tabort();\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write COM marker\\n\");\n\t\treturn -1;\n\t}\n\tjpc_ms_destroy(enc->mrk);\n\tenc->mrk = 0;\n\n#if 0","target":0,"flaw_line_index":0,"hash":"4f5673a6-e82b-4286-afdd-a97f9458b6b6","idx":"defb0461-0f33-4ad7-89f9-0a6fc5bf1015"}
{"func_before":"TEST_F(ZNCTest, AwayNotify) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    auto client = ConnectClient();\n    client.Write(\"CAP LS\");\n    client.Write(\"PASS :hunter2\");\n    client.Write(\"NICK nick\");\n    client.Write(\"USER user\/test x x :x\");\n    QByteArray cap_ls;\n    client.ReadUntilAndGet(\" LS :\", cap_ls);\n    ASSERT_THAT(cap_ls.toStdString(), AllOf(HasSubstr(\"cap-notify\"), Not(HasSubstr(\"away-notify\"))));\n    client.Write(\"CAP REQ :cap-notify\");\n    client.ReadUntil(\"ACK :cap-notify\");\n    client.Write(\"CAP END\");\n    client.ReadUntil(\" 001 \");\n    ircd.ReadUntil(\"USER\");\n    ircd.Write(\"CAP user LS :away-notify\");\n    ircd.ReadUntil(\"CAP REQ :away-notify\");\n    ircd.Write(\"CAP user ACK :away-notify\");\n    ircd.ReadUntil(\"CAP END\");\n    ircd.Write(\":server 001 user :welcome\");\n    client.ReadUntil(\"CAP user NEW :away-notify\");\n    client.Write(\"CAP REQ :away-notify\");\n    client.ReadUntil(\"ACK :away-notify\");\n    ircd.Write(\":x!y@z AWAY :reason\");\n    client.ReadUntil(\":x!y@z AWAY :reason\");\n    ircd.Close();\n    client.ReadUntil(\"DEL :away-notify\");\n}","target":1,"flaw_line_index":0,"hash":"e6c9f713-0973-4eab-90e7-4e9cf406385d","idx":"3b7b4f18-2eb3-4389-b480-fbd64846d6b6"}
{"func_before":"TEST_F(ZNCTest, StatusEchoMessage) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"CAP REQ :echo-message\");\n    client.Write(\"PRIVMSG *status :blah\");\n    client.ReadUntil(\":nick!user@irc.znc.in PRIVMSG *status :blah\");\n    client.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n}","target":0,"flaw_line_index":0,"hash":"b5ddd034-9e02-4ab9-a6b1-7216c3343daf","idx":"86de2659-2aed-4388-bcfc-a85b0d7263c2"}
{"func_before":"TfLiteStatus Resize(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteLSHProjectionParams*>(node->builtin_data);\n  TF_LITE_ENSURE(context, NumInputs(node) == 2 || NumInputs(node) == 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* hash = GetInput(context, node, 0);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(hash), 2);\n  \/\/ Support up to 32 bits.\n  TF_LITE_ENSURE(context, SizeOfDimension(hash, 1) <= 32);\n\n  const TfLiteTensor* input = GetInput(context, node, 1);\n  TF_LITE_ENSURE(context, NumDimensions(input) >= 1);\n\n  if (NumInputs(node) == 3) {\n    const TfLiteTensor* weight = GetInput(context, node, 2);\n    TF_LITE_ENSURE_EQ(context, NumDimensions(weight), 1);\n    TF_LITE_ENSURE_EQ(context, SizeOfDimension(weight, 0),\n                      SizeOfDimension(input, 0));\n  }\n\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  switch (params->type) {\n    case kTfLiteLshProjectionSparse:\n      outputSize->data[0] = SizeOfDimension(hash, 0);\n      break;\n    case kTfLiteLshProjectionDense:\n      outputSize->data[0] = SizeOfDimension(hash, 0) * SizeOfDimension(hash, 1);\n      break;\n    default:\n      return kTfLiteError;","target":1,"flaw_line_index":0,"hash":"9e8d6ee7-f0a2-45db-a7ce-f972a6d26685","idx":"7fbcfef1-2bff-4e6d-941a-ec02dbc6271e"}
{"func_before":"TfLiteStatus Resize(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteLSHProjectionParams*>(node->builtin_data);\n  TF_LITE_ENSURE(context, NumInputs(node) == 2 || NumInputs(node) == 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* hash;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &hash));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(hash), 2);\n  \/\/ Support up to 32 bits.\n  TF_LITE_ENSURE(context, SizeOfDimension(hash, 1) <= 32);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &input));\n  TF_LITE_ENSURE(context, NumDimensions(input) >= 1);\n\n  if (NumInputs(node) == 3) {\n    const TfLiteTensor* weight;\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &weight));\n    TF_LITE_ENSURE_EQ(context, NumDimensions(weight), 1);\n    TF_LITE_ENSURE_EQ(context, SizeOfDimension(weight, 0),\n                      SizeOfDimension(input, 0));\n  }\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  switch (params->type) {\n    case kTfLiteLshProjectionSparse:\n      outputSize->data[0] = SizeOfDimension(hash, 0);\n      break;\n    case kTfLiteLshProjectionDense:\n      outputSize->data[0] = SizeOfDimension(hash, 0) * SizeOfDimension(hash, 1);\n      break;\n    default:\n      return kTfLiteError;","target":0,"flaw_line_index":0,"hash":"73ead55f-6627-4102-b170-50045d8156f4","idx":"1bca8e21-872e-4480-848a-96e72a7d5b60"}
{"func_before":"expand_dynamic_string_token (struct link_map *l, const char *s)\n{\n  \/* We make two runs over the string.  First we determine how large the\n     resulting string is and then we copy it over.  Since this is now\n     frequently executed operation we are looking here not for performance\n     but rather for code size.  *\/\n  size_t cnt;\n  size_t total;\n  char *result;\n\n  \/* Determine the nubmer of DST elements.  *\/\n  cnt = DL_DST_COUNT (s, 1);\n\n  \/* If we do not have to replace anything simply copy the string.  *\/\n  if (cnt == 0)\n    return local_strdup (s);\n\n  \/* Determine the length of the substituted string.  *\/\n  total = DL_DST_REQUIRED (l, s, strlen (s), cnt);\n\n  \/* Allocate the necessary memory.  *\/","target":1,"flaw_line_index":0,"hash":"9956cf94-327e-4353-bbb5-5ac09ddc4fe4","idx":"371e5d3a-539a-405b-82a3-8845806fae1d"}
{"func_before":"expand_dynamic_string_token (struct link_map *l, const char *s)\n{\n  \/* We make two runs over the string.  First we determine how large the\n     resulting string is and then we copy it over.  Since this is now\n     frequently executed operation we are looking here not for performance\n     but rather for code size.  *\/\n  size_t cnt;\n  size_t total;\n  char *result;\n\n  \/* Determine the number of DST elements.  *\/\n  cnt = DL_DST_COUNT (s, 1);\n\n  \/* If we do not have to replace anything simply copy the string.  *\/\n  if (cnt == 0)\n    return local_strdup (s);\n\n  \/* Determine the length of the substituted string.  *\/\n  total = DL_DST_REQUIRED (l, s, strlen (s), cnt);\n\n  \/* Allocate the necessary memory.  *\/","target":0,"flaw_line_index":0,"hash":"a01b8849-961e-4c51-8600-e59f37d192df","idx":"e378d56e-38ad-4254-a0ff-2d38df4bc657"}
{"func_before":"void CommandData::ParseArg(wchar *Arg)\n{\n  if (IsSwitch(*Arg) && !NoMoreSwitches)\n    if (Arg[1]=='-' && Arg[2]==0)\n      NoMoreSwitches=true;\n    else\n      ProcessSwitch(Arg+1);\n  else\n    if (*Command==0)\n    {\n      wcsncpy(Command,Arg,ASIZE(Command));\n\n\n      *Command=toupperw(*Command);\n      \/\/ 'I' and 'S' commands can contain case sensitive strings after\n      \/\/ the first character, so we must not modify their case.\n      \/\/ 'S' can contain SFX name, which case is important in Unix.\n      if (*Command!='I' && *Command!='S')\n        wcsupper(Command);\n    }\n    else","target":1,"flaw_line_index":0,"hash":"fa86e106-66c4-4ddd-a4da-49057584d341","idx":"59c5f6a3-29ab-4b6b-967b-febaf47080e4"}
{"func_before":"void CommandData::ParseArg(wchar *Arg)\n{\n  if (IsSwitch(*Arg) && !NoMoreSwitches)\n    if (Arg[1]=='-' && Arg[2]==0)\n      NoMoreSwitches=true;\n    else\n      ProcessSwitch(Arg+1);\n  else\n    if (*Command==0)\n    {\n      wcsncpyz(Command,Arg,ASIZE(Command));\n\n\n      *Command=toupperw(*Command);\n      \/\/ 'I' and 'S' commands can contain case sensitive strings after\n      \/\/ the first character, so we must not modify their case.\n      \/\/ 'S' can contain SFX name, which case is important in Unix.\n      if (*Command!='I' && *Command!='S')\n        wcsupper(Command);\n    }\n    else","target":0,"flaw_line_index":0,"hash":"2a04ead2-1dab-42fa-84fb-799f46e9361b","idx":"36fe5e12-334c-459d-b60f-9e73be42c9a4"}
{"func_before":"void __perf_sw_event(u32 event_id, u64 nr, int nmi,\n\t\t\t    struct pt_regs *regs, u64 addr)\n{\n\tstruct perf_sample_data data;\n\tint rctx;\n\n\tpreempt_disable_notrace();\n\trctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn;\n\n\tperf_sample_data_init(&data, addr);\n\n\tdo_perf_sw_event(PERF_TYPE_SOFTWARE, event_id, nr, nmi, &data, regs);\n\n\tperf_swevent_put_recursion_context(rctx);\n\tpreempt_enable_notrace();\n}","target":1,"flaw_line_index":0,"hash":"3389cec4-1908-48f3-a6e2-40a9cd0104b5","idx":"1071b8ee-10b1-4368-a31f-e322a98ec49f"}
{"func_before":"void __perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)\n{\n\tstruct perf_sample_data data;\n\tint rctx;\n\n\tpreempt_disable_notrace();\n\trctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn;\n\n\tperf_sample_data_init(&data, addr);\n\n\tdo_perf_sw_event(PERF_TYPE_SOFTWARE, event_id, nr, &data, regs);\n\n\tperf_swevent_put_recursion_context(rctx);\n\tpreempt_enable_notrace();\n}","target":0,"flaw_line_index":0,"hash":"3e93682e-4cae-4948-9d25-43db78237e10","idx":"931ef9cb-e50b-4a83-adac-165b7ed0aed7"}
{"func_before":"    }\n\n  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);\n  free (input_u8);\n\n  if (rc == IDN2_OK)\n    {\n      \/* wow, this is ugly, but libidn manpage states:\n       * char * out  output zero terminated string that must have room for at\n       * least 63 characters plus the terminating zero.\n       *\/\n      if (output)\n\tstrcpy (output, (const char *) output_u8);\n\n      free(output_u8);\n    }\n\n  return rc;\n}","target":1,"flaw_line_index":0,"hash":"cf2db5a0-be31-4b8e-9a43-b845b09468e9","idx":"0b28cdcf-c539-4432-8c4f-418f4bcf20d0"}
{"func_before":"\n  rc = idn2_lookup_u8 (input_u8, &output_u8, flags);\n  free (input_u8);\n\n  if (rc == IDN2_OK)\n    {\n      \/* wow, this is ugly, but libidn manpage states:\n       * char * out  output zero terminated string that must have room for at\n       * least 63 characters plus the terminating zero.\n       *\/\n      size_t len = strlen ((char *) output_u8);\n\n      if (len > 63)\n        {\n\t  free (output_u8);\n\t  return IDN2_TOO_BIG_DOMAIN;\n        }\n\n      if (output)\n\tstrcpy (output, (char *) output_u8);\n\n      free (output_u8);\n    }\n\n  return rc;\n}","target":0,"flaw_line_index":0,"hash":"701a9c3b-b8de-4a82-ad58-027c173b4672","idx":"a77984d6-d37f-46f0-a676-40a49d4e3730"}
{"func_before":"R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) {\n\tr_return_val_if_fail (cmd && cmd->aliases && k, NULL);\n\treturn ht_pp_find(cmd->aliases, k, NULL);\n}","target":1,"flaw_line_index":0,"hash":"4606f43f-b685-48f5-be72-09d6fbbb365e","idx":"9b116e12-16a4-4d48-b8bc-f3121639e40a"}
{"func_before":"R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) {\n\tr_return_val_if_fail (cmd && cmd->aliases && k, NULL);\n\treturn ht_pp_find (cmd->aliases, k, NULL);\n}","target":0,"flaw_line_index":0,"hash":"6f71bd8d-718f-41e3-a32e-80cf22692454","idx":"80eb0ff2-5f09-45fb-8d08-b48b12031ce7"}
{"func_before":"  if ((unique_file == -1) || (file == (FILE *) NULL))\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(huffman_image->filename,MagickPathExtent,\"tiff:%s\",\n    filename);\n  (void) SetImageType(huffman_image,BilevelType,exception);\n  write_info=CloneImageInfo((ImageInfo *) NULL);\n  SetImageInfoFile(write_info,file);\n  (void) SetImageType(image,BilevelType,exception);\n  (void) SetImageDepth(image,1,exception);\n  write_info->compression=Group4Compression;\n  write_info->type=BilevelType;\n  (void) SetImageOption(write_info,\"quantum:polarity\",\"min-is-white\");\n  status=WriteTIFFImage(write_info,huffman_image,exception);\n  (void) fflush(file);\n  write_info=DestroyImageInfo(write_info);\n  if (status == MagickFalse)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);","target":1,"flaw_line_index":0,"hash":"a4de12f5-3338-462e-a5c8-c23cf3b147da","idx":"ab770e04-0137-4b7d-b688-1ea1ed617b9f"}
{"func_before":"    {\n      ThrowFileException(exception,FileOpenError,\"UnableToCreateTemporaryFile\",\n        filename);\n      return(MagickFalse);\n    }\n  (void) FormatLocaleString(huffman_image->filename,MagickPathExtent,\"tiff:%s\",\n    filename);\n  (void) SetImageType(huffman_image,BilevelType,exception);\n  write_info=CloneImageInfo((ImageInfo *) NULL);\n  SetImageInfoFile(write_info,file);\n  (void) SetImageDepth(image,1,exception);\n  (void) SetImageType(image,BilevelType,exception);\n  write_info->compression=Group4Compression;\n  write_info->type=BilevelType;\n  (void) SetImageOption(write_info,\"quantum:polarity\",\"min-is-white\");\n  status=WriteTIFFImage(write_info,huffman_image,exception);\n  (void) fflush(file);\n  write_info=DestroyImageInfo(write_info);\n  if (status == MagickFalse)\n    {\n      huffman_image=DestroyImage(huffman_image);\n      (void) fclose(file);","target":0,"flaw_line_index":0,"hash":"ffa5d542-39db-4a04-a2a0-60c795ea6cc8","idx":"4dd20841-6020-45bd-8296-239d9147980b"}
{"func_before":"    for (attempt = 0; attempt <= (fuzzy ? 0 : 1); ++attempt)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tscore = 0;\n\n\tif (!fuzzy)\n\t{\n\t    if (attempt > 0 && patc == pat)\n\t\tbreak;\t\/\/ there was no anchor, no need to try again\n\t    regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);\n\t    if (regmatch.regprog == NULL)\n\t    {\n\t\tif (patc != pat)\n\t\t    vim_free(patc);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t\/\/ round == 1: Count the matches.\n\t\/\/ round == 2: Build the array to keep the matches.\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    count = 0;\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tif (!buf->b_p_bl)\t\/\/ skip unlisted buffers\n\t\t    continue;\n#ifdef FEAT_DIFF\n\t\tif (options & BUF_DIFF_FILTER)\n\t\t    \/\/ Skip buffers not suitable for\n\t\t    \/\/ :diffget or :diffput completion.\n\t\t    if (buf == curbuf || !diff_mode_buf(buf))\n\t\t\tcontinue;\n#endif\n\n\t\tif (!fuzzy)\n\t\t    p = buflist_match(&regmatch, buf, p_wic);\n\t\telse\n\t\t{\n\t\t    p = NULL;\n\t\t    \/\/ first try matching with the short file name\n\t\t    if ((score = fuzzy_match_str(buf->b_sfname, pat)) != 0)\n\t\t\tp = buf->b_sfname;\n\t\t    if (p == NULL)\n\t\t    {\n\t\t\t\/\/ next try matching with the full path file name\n\t\t\tif ((score = fuzzy_match_str(buf->b_ffname, pat)) != 0)","target":1,"flaw_line_index":0,"hash":"276b8777-13da-4ec8-8c01-01040c8c6c9e","idx":"9b55b5f6-7842-453c-b233-5f4085e69d2b"}
{"func_before":"    \/\/ attempt == 1: try match without '\\<', match anywhere\n    for (attempt = 0; attempt <= (fuzzy ? 0 : 1); ++attempt)\n    {\n\tregmatch_T\tregmatch;\n\tint\t\tscore = 0;\n\n\tif (!fuzzy)\n\t{\n\t    if (attempt > 0 && patc == pat)\n\t\tbreak;\t\/\/ there was no anchor, no need to try again\n\t    regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);\n\t}\n\n\t\/\/ round == 1: Count the matches.\n\t\/\/ round == 2: Build the array to keep the matches.\n\tfor (round = 1; round <= 2; ++round)\n\t{\n\t    count = 0;\n\t    FOR_ALL_BUFFERS(buf)\n\t    {\n\t\tif (!buf->b_p_bl)\t\/\/ skip unlisted buffers\n\t\t    continue;\n#ifdef FEAT_DIFF\n\t\tif (options & BUF_DIFF_FILTER)\n\t\t    \/\/ Skip buffers not suitable for\n\t\t    \/\/ :diffget or :diffput completion.\n\t\t    if (buf == curbuf || !diff_mode_buf(buf))\n\t\t\tcontinue;\n#endif\n\n\t\tif (!fuzzy)\n\t\t{\n\t\t    if (regmatch.regprog == NULL)\n\t\t    {\n\t\t\t\/\/ invalid pattern, possibly after recompiling\n\t\t\tif (patc != pat)\n\t\t\t    vim_free(patc);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    p = buflist_match(&regmatch, buf, p_wic);\n\t\t}\n\t\telse\n\t\t{\n\t\t    p = NULL;\n\t\t    \/\/ first try matching with the short file name\n\t\t    if ((score = fuzzy_match_str(buf->b_sfname, pat)) != 0)\n\t\t\tp = buf->b_sfname;\n\t\t    if (p == NULL)\n\t\t    {\n\t\t\t\/\/ next try matching with the full path file name\n\t\t\tif ((score = fuzzy_match_str(buf->b_ffname, pat)) != 0)","target":0,"flaw_line_index":0,"hash":"713b791c-f2e2-4dfd-adfa-05c2aafb5573","idx":"9dd5e4d7-ec88-4c13-8c77-8c24611acb89"}
{"func_before":"{\n\tstruct bio *bio = *bio_ret;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tsector_t block_in_file;\n\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t block_nr;\n\tint ret = 0;\n\n\tblock_in_file = (sector_t)page->index;\n\tlast_block = block_in_file + nr_pages;\n\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >>\n\t\t\t\t\t\t\tblkbits;\n\tif (last_block > last_block_in_file)\n\t\tlast_block = last_block_in_file;\n\n\t\/* just zeroing out page which is beyond EOF *\/\n\tif (block_in_file >= last_block)\n\t\tgoto zero_out;\n\t\/*\n\tmap->m_len = last_block - block_in_file;\n\n\tret = f2fs_map_blocks(inode, map, 0, F2FS_GET_BLOCK_DEFAULT);\n\tif (ret)\n\t\tgoto out;\ngot_it:\n\tif ((map->m_flags & F2FS_MAP_MAPPED)) {\n\t\tblock_nr = map->m_pblk + block_in_file - map->m_lblk;\n\t\tSetPageMappedToDisk(page);\n\n\t\tif (!PageUptodate(page) && !cleancache_get_page(page)) {\n\t\t\tSetPageUptodate(page);\n\t\t\tgoto confused;\n\t\t}\n\n\t\tif (!f2fs_is_valid_blkaddr(F2FS_I_SB(inode), block_nr,\n\t\t\t\t\t\tDATA_GENERIC_ENHANCE_READ)) {\n\t\t\tret = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t} else {","target":1,"flaw_line_index":0,"hash":"391d7f55-fe3e-4254-9ba1-5bea8ebbdc17","idx":"08a2e3ca-3025-4871-9614-461a197ea0dc"}
{"func_before":"{\n\tstruct bio *bio = *bio_ret;\n\tconst unsigned blkbits = inode->i_blkbits;\n\tconst unsigned blocksize = 1 << blkbits;\n\tsector_t block_in_file;\n\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t block_nr;\n\tint ret = 0;\n\n\tblock_in_file = (sector_t)page_index(page);\n\tlast_block = block_in_file + nr_pages;\n\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >>\n\t\t\t\t\t\t\tblkbits;\n\tif (last_block > last_block_in_file)\n\t\tlast_block = last_block_in_file;\n\n\t\/* just zeroing out page which is beyond EOF *\/\n\tif (block_in_file >= last_block)\n\t\tgoto zero_out;\n\t\/*\n\tmap->m_len = last_block - block_in_file;\n\n\tret = f2fs_map_blocks(inode, map, 0, F2FS_GET_BLOCK_DEFAULT);\n\tif (ret)\n\t\tgoto out;\ngot_it:\n\tif ((map->m_flags & F2FS_MAP_MAPPED)) {\n\t\tblock_nr = map->m_pblk + block_in_file - map->m_lblk;\n\t\tSetPageMappedToDisk(page);\n\n\t\tif (!PageUptodate(page) && (!PageSwapCache(page) &&\n\t\t\t\t\t!cleancache_get_page(page))) {\n\t\t\tSetPageUptodate(page);\n\t\t\tgoto confused;\n\t\t}\n\n\t\tif (!f2fs_is_valid_blkaddr(F2FS_I_SB(inode), block_nr,\n\t\t\t\t\t\tDATA_GENERIC_ENHANCE_READ)) {\n\t\t\tret = -EFSCORRUPTED;\n\t\t\tgoto out;\n\t\t}\n\t} else {","target":0,"flaw_line_index":0,"hash":"c0a15e4f-7085-44b6-b568-b96d76170b3c","idx":"83897633-350f-443a-b6e3-10ecd1897bd4"}
{"func_before":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  const int num_elements = NumElements(input);\n  TF_LITE_ENSURE_EQ(context, num_elements, NumElements(output));\n  switch (input->type) {\n    case kTfLiteInt64:\n      return copyToTensor(context, input->data.i64, output, num_elements);\n    case kTfLiteInt32:\n      return copyToTensor(context, input->data.i32, output, num_elements);\n    case kTfLiteUInt8:\n      return copyToTensor(context, input->data.uint8, output, num_elements);\n    case kTfLiteFloat32:","target":1,"flaw_line_index":0,"hash":"1c61a12f-72ca-43e0-85b2-5a867d4f75fe","idx":"62e59c0b-8d5e-45eb-85f6-e8b913fa98c5"}
{"func_before":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  const int num_elements = NumElements(input);\n  TF_LITE_ENSURE_EQ(context, num_elements, NumElements(output));\n  switch (input->type) {\n    case kTfLiteInt64:\n      return copyToTensor(context, input->data.i64, output, num_elements);\n    case kTfLiteInt32:\n      return copyToTensor(context, input->data.i32, output, num_elements);\n    case kTfLiteUInt8:\n      return copyToTensor(context, input->data.uint8, output, num_elements);\n    case kTfLiteFloat32:","target":0,"flaw_line_index":0,"hash":"8dfab1db-6d85-4051-8149-bd2ec6e0b758","idx":"170a9fb4-17a2-4e9e-b3bd-94135f488482"}
{"func_before":"GF_EXPORT\nGF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\t\/\/box has been disabled, do not write\n\tif (!a->size) return GF_OK;\n\t\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s size %d write\\n\", gf_4cc_to_str(a->type), a->size));\n\te = gf_isom_box_write_listing(a, bs);\n\tif (e) return e;\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_write(a, a->child_boxes, bs);","target":1,"flaw_line_index":0,"hash":"a8a0098d-fb85-4bf8-a72b-5e6f62835e50","idx":"76072fee-1988-433b-be2e-8e76388c233c"}
{"func_before":"GF_EXPORT\nGF_Err gf_isom_box_write(GF_Box *a, GF_BitStream *bs)\n{\n\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\t\/\/box has been disabled, do not write\n\tif (!a->size) return GF_OK;\n\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s size %d write\\n\", gf_4cc_to_str(a->type), a->size));\n\te = gf_isom_box_write_listing(a, bs);\n\tif (e) return e;\n\tif (a->child_boxes) {\n\t\te = gf_isom_box_array_write(a, a->child_boxes, bs);","target":0,"flaw_line_index":0,"hash":"1b0cd102-2dac-4536-9f12-cf689495c961","idx":"0f233a58-67a3-4fc4-bdc2-ae63a399b21f"}
{"func_before":"\n\t\t\t\/\/ fixes MOOH.XM loading problems\n\t\t\t\/\/ seems to store more instruments in the header than in the actual file\n\t\t\tif (f.posWithBaseOffset() >= fileSize)\n\t\t\t\tbreak;\n\t\t\n\t\t\t\/\/TXMInstrument* ins = &instr[y];\n\t\t\n\t\t\tf.readDwords(&instr[y].size,1);\n\t\t\t\n\t\t\tif (instr[y].size < 29)\n\t\t\t{\n\t\t\t\tmp_ubyte buffer[29];\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tf.read(buffer, 1, instr[y].size - 4);\n\t\t\t\tmemcpy(instr[y].name, buffer, 22);\n\t\t\t\tinstr[y].type = buffer[22];\n\t\t\t\tinstr[y].samp = LittleEndian::GET_WORD(buffer + 23);\n\t\t\t}\n\t\t\telse\n\t\t\t{","target":1,"flaw_line_index":0,"hash":"c89bce38-5c96-4724-80fc-a16fdb543be0","idx":"149ea575-9382-47e5-93ef-670faa801b1c"}
{"func_before":"\n\t\t\t\/\/ fixes MOOH.XM loading problems\n\t\t\t\/\/ seems to store more instruments in the header than in the actual file\n\t\t\tif (f.posWithBaseOffset() >= fileSize)\n\t\t\t\tbreak;\n\t\t\n\t\t\t\/\/TXMInstrument* ins = &instr[y];\n\t\t\n\t\t\tf.readDwords(&instr[y].size,1);\n\t\t\t\n\t\t\tif (instr[y].size >= 4 && instr[y].size < 29)\n\t\t\t{\n\t\t\t\tmp_ubyte buffer[29];\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tf.read(buffer, 1, instr[y].size - 4);\n\t\t\t\tmemcpy(instr[y].name, buffer, 22);\n\t\t\t\tinstr[y].type = buffer[22];\n\t\t\t\tinstr[y].samp = LittleEndian::GET_WORD(buffer + 23);\n\t\t\t}\n\t\t\telse\n\t\t\t{","target":0,"flaw_line_index":0,"hash":"88341ba7-b162-4b4d-a3c9-bf470f300f9b","idx":"9dd32d88-282e-41ac-82cd-11957ebaa795"}
{"func_before":"\t\treturn 0;\n\t}\n\n\t\/\/ Read the header length field (including extended headers), and\n\t\/\/ extend to this full length. Because this is a 32-bit value,\n\t\/\/ we must place a sensible limit on the amount of data that will\n\t\/\/ be read, to avoid possibly allocating gigabytes of memory.\n\n\theader_len = lha_decode_uint32(&RAW_DATA(header, 24));\n\n\tif (header_len > LEVEL_3_MAX_HEADER_LEN) {\n\t\treturn 0;\n\t}\n\n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\n\t\/\/ Compression method:\n","target":1,"flaw_line_index":0,"hash":"d97c2e1a-d940-477b-a514-d4fe1c7f143a","idx":"fab9a999-d40c-4664-a32b-1456e0bc3a03"}
{"func_before":"\t\treturn 0;\n\t}\n\n\t\/\/ Read the header length field (including extended headers), and\n\t\/\/ extend to this full length. Because this is a 32-bit value,\n\t\/\/ we must place a sensible limit on the amount of data that will\n\t\/\/ be read, to avoid possibly allocating gigabytes of memory.\n\n\theader_len = lha_decode_uint32(&RAW_DATA(header, 24));\n\n\tif (header_len > LEVEL_3_MAX_HEADER_LEN\n\t || header_len < RAW_DATA_LEN(header)) {\n\t\treturn 0;\n\t}\n\n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {\n\t\treturn 0;\n\t}\n\n\t\/\/ Compression method:\n","target":0,"flaw_line_index":0,"hash":"4546b2e1-cb81-49ef-a060-1825c3c48f8f","idx":"75febfbf-4a54-4da5-b447-05498c8a9e1a"}
{"func_before":"QualifyIpPacket(IPHeader *pIpHeader, ULONG len)\n{\n    tTcpIpPacketParsingResult res;\n    UCHAR  ver_len = pIpHeader->v4.ip_verlen;\n    UCHAR  ip_version = (ver_len & 0xF0) >> 4;\n    USHORT ipHeaderSize = 0;\n    USHORT fullLength = 0;\n    res.value = 0;\n    \n    if (ip_version == 4)\n    {\n        ipHeaderSize = (ver_len & 0xF) << 2;\n        fullLength = swap_short(pIpHeader->v4.ip_length);\n        DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d\\n\",\n            ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength));\n        res.ipStatus = (ipHeaderSize >= sizeof(IPv4Header)) ? ppresIPV4 : ppresNotIP;\n        if (len < ipHeaderSize) res.ipCheckSum = ppresIPTooShort;\n        if (fullLength) {}\n        else\n        {\n            DPrintf(2, (\"ip v.%d, iplen %d\\n\", ip_version, fullLength));\n        }\n    }\n    else if (ip_version == 6)\n    {\n        UCHAR nextHeader = pIpHeader->v6.ip6_next_header;\n        BOOLEAN bParsingDone = FALSE;\n        ipHeaderSize = sizeof(pIpHeader->v6);\n        res.ipStatus = ppresIPV6;\n        res.ipCheckSum = ppresCSOK;\n        fullLength = swap_short(pIpHeader->v6.ip6_payload_len);\n        else\n        {\n            DPrintf(0, (\"[%s] ERROR: IP chain is too large (%d)\\n\", __FUNCTION__, ipHeaderSize));\n            res.ipStatus = ppresNotIP;\n        }\n    }\n    \n    if (res.ipStatus == ppresIPV4)\n    {\n        res.ipHeaderSize = ipHeaderSize;\n        res.xxpFull = len >= fullLength ? 1 : 0;\n        \/\/ bit \"more fragments\" or fragment offset mean the packet is fragmented\n        res.IsFragment = (pIpHeader->v4.ip_offset & ~0xC0) != 0;\n        switch (pIpHeader->v4.ip_protocol)\n        {\n            case PROTOCOL_TCP:\n            {\n                res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);\n            }\n            break;\n        case PROTOCOL_UDP:","target":1,"flaw_line_index":0,"hash":"bb95c1c6-8556-4bda-8528-772e1009cd3a","idx":"8e5c838d-9d32-4061-a9aa-eb12ab20bb13"}
{"func_before":"QualifyIpPacket(IPHeader *pIpHeader, ULONG len)\n{\n    tTcpIpPacketParsingResult res;\n    res.value = 0;\n\n    if (len < 4)\n    {\n        res.ipStatus = ppresNotIP;\n        return res;\n    }\n\n    UCHAR  ver_len = pIpHeader->v4.ip_verlen;\n    UCHAR  ip_version = (ver_len & 0xF0) >> 4;\n    USHORT ipHeaderSize = 0;\n    USHORT fullLength = 0;\n    res.value = 0;\n\n    if (ip_version == 4)\n    {\n        if (len < sizeof(IPv4Header))\n        {\n            res.ipStatus = ppresNotIP;\n            return res;\n        }\n        ipHeaderSize = (ver_len & 0xF) << 2;\n        fullLength = swap_short(pIpHeader->v4.ip_length);\n        DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\",\n            ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));\n\n        res.ipStatus = (ipHeaderSize >= sizeof(IPv4Header)) ? ppresIPV4 : ppresNotIP;\n        if (res.ipStatus == ppresNotIP)\n        {\n            return res;\n        }\n\n        if (ipHeaderSize >= fullLength || len < fullLength)\n        {\n            DPrintf(2, (\"[%s] - truncated packet - ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\",\n                ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));\n            res.ipCheckSum = ppresIPTooShort;\n            return res;\n        }\n    }\n    else if (ip_version == 6)\n    {\n        UCHAR nextHeader = pIpHeader->v6.ip6_next_header;\n        BOOLEAN bParsingDone = FALSE;\n        ipHeaderSize = sizeof(pIpHeader->v6);\n        res.ipStatus = ppresIPV6;\n        res.ipCheckSum = ppresCSOK;\n        fullLength = swap_short(pIpHeader->v6.ip6_payload_len);\n        else\n        {\n            DPrintf(0, (\"[%s] ERROR: IP chain is too large (%d)\\n\", __FUNCTION__, ipHeaderSize));\n            res.ipStatus = ppresNotIP;\n        }\n    }\n    \n    if (res.ipStatus == ppresIPV4)\n    {\n        res.ipHeaderSize = ipHeaderSize;\n\n        \/\/ bit \"more fragments\" or fragment offset mean the packet is fragmented\n        res.IsFragment = (pIpHeader->v4.ip_offset & ~0xC0) != 0;\n        switch (pIpHeader->v4.ip_protocol)\n        {\n            case PROTOCOL_TCP:\n            {\n                res = ProcessTCPHeader(res, pIpHeader, len, ipHeaderSize);\n            }\n            break;\n        case PROTOCOL_UDP:","target":0,"flaw_line_index":0,"hash":"0b777f47-02d0-4fde-b6e7-479c8714d405","idx":"238465f6-3dd6-4a4d-a25e-8365ed1fc656"}
{"func_before":"\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, \/* value *\/\n\t\t\t     0, \/* index *\/\n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc < 0)\n\t\tdev_err(&port->dev, \"Reading line status failed (error = %d)\\n\",\n\t\t\trc);\n\telse {\n\t\tstatus = get_unaligned_le16(status_buf);\n\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\n\tkfree(status_buf);\n\treturn rc;","target":1,"flaw_line_index":0,"hash":"fd0d2ded-d6ae-46b8-97d8-02c29d402230","idx":"99e5d4ae-e8ce-4416-b787-e424b5fcb70c"}
{"func_before":"\tstatus_buf[1] = 0xff;\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_POLL,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t     0, \/* value *\/\n\t\t\t     0, \/* index *\/\n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc != KLSI_STATUSBUF_LEN) {\n\t\tdev_err(&port->dev, \"reading line status failed: %d\\n\", rc);\n\t\tif (rc >= 0)\n\t\t\trc = -EIO;\n\t} else {\n\t\tstatus = get_unaligned_le16(status_buf);\n\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n\n\t\t*line_state_p = klsi_105_status2linestate(status);\n\t}\n\n\tkfree(status_buf);\n\treturn rc;","target":0,"flaw_line_index":0,"hash":"2cc04ca1-c38a-4964-837b-80664df42e8e","idx":"8b86cc79-3d9d-44ea-8cc4-fb43e9672499"}
{"func_before":"const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index) {\n  const bool use_tensor = index < node->inputs->size &&\n                          node->inputs->data[index] != kTfLiteOptionalTensor;\n  if (use_tensor) {\n    return GetMutableInput(context, node, index);\n  }\n  return nullptr;\n}","target":1,"flaw_line_index":0,"hash":"bd32e1c7-aeeb-4888-a2cb-548b5fead101","idx":"514c67de-ae62-4549-b640-8101e249a6ea"}
{"func_before":"const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index) {\n  return GetInput(context, node, index);\n}","target":0,"flaw_line_index":0,"hash":"ee96b3f7-349f-4e58-a021-e70ed38b805e","idx":"52711811-c8ce-4ff9-bb95-e7ff82e4512a"}
{"func_before":"  int64_t num_batches = input_descriptor.count();\n  int64_t elements_per_batch_input = input_descriptor.NodesAcrossFeatureMaps();\n  int64_t elements_per_batch_output =\n      output_descriptor.NodesAcrossFeatureMaps();\n\n  int64_t max_batches_per_split =\n      std::numeric_limits<int>::max() \/ elements_per_batch_input;\n\n  if (max_batches_per_split == 0) {\n    return tsl::Status(\n        port::error::INTERNAL,\n        absl::StrCat(\n            \"Tensor has too many elements for int32 indexing: batches=\",\n            num_batches, \" elements_per_batch=\", elements_per_batch_input,\n            \".\"));\n  }\n\n  int64_t processed_batches = 0;\n  while (processed_batches < num_batches) {\n    int64_t num_batches_per_split =\n        std::min(max_batches_per_split, num_batches - processed_batches);","target":1,"flaw_line_index":0,"hash":"b6a10506-86a2-4bca-ad76-8ac99b0440e8","idx":"ddbc947b-2ba9-4b47-b06d-e93e1066147f"}
{"func_before":"  int64_t num_batches = input_descriptor.count();\n  int64_t elements_per_batch_input = input_descriptor.NodesAcrossFeatureMaps();\n  int64_t elements_per_batch_output =\n      output_descriptor.NodesAcrossFeatureMaps();\n\n  int64_t max_batches_per_split =\n      std::numeric_limits<int>::max() \/ elements_per_batch_input;\n\n  if (max_batches_per_split == 0) {\n    return tsl::Status(\n        tsl::error::INTERNAL,\n        absl::StrCat(\n            \"Tensor has too many elements for int32 indexing: batches=\",\n            num_batches, \" elements_per_batch=\", elements_per_batch_input,\n            \".\"));\n  }\n\n  int64_t processed_batches = 0;\n  while (processed_batches < num_batches) {\n    int64_t num_batches_per_split =\n        std::min(max_batches_per_split, num_batches - processed_batches);","target":0,"flaw_line_index":0,"hash":"99702995-3651-4883-b472-889585a23056","idx":"4c129e27-498d-4e51-a45d-f8fa1cf4acf0"}
{"func_before":"int setpwnam(struct passwd *pwd)\n{\n\tFILE *fp = NULL, *pwf = NULL;\n\tint save_errno;\n\tint found;\n\tint namelen;\n\tint buflen = 256;\n\tint contlen, rc;\n\tchar *linebuf = NULL;\n\tchar *tmpname = NULL;\n\tchar *atomic_dir = \"\/etc\";\n\n\tpw_init();\n\n\tif ((fp = xfmkstemp(&tmpname, atomic_dir)) == NULL)\n\t\treturn -1;\n\n\t\/* ptmp should be owned by root.root or root.wheel *\/\n\tif (fchown(fileno(fp), (uid_t) 0, (gid_t) 0) < 0)\n\t\tgoto fail;\n\n\t\/* acquire exclusive lock *\/\n\tif (lckpwdf() < 0)\n\t\tgoto fail;\n\tpwf = fopen(PASSWD_FILE, \"r\");","target":1,"flaw_line_index":0,"hash":"e9c920e3-1776-48ec-ac63-e0a8d9be9a53","idx":"22b3d4ac-c14a-48ff-bb11-6215967f4205"}
{"func_before":"int setpwnam(struct passwd *pwd, const char *prefix)\n{\n\tFILE *fp = NULL, *pwf = NULL;\n\tint save_errno;\n\tint found;\n\tint namelen;\n\tint buflen = 256;\n\tint contlen, rc;\n\tchar *linebuf = NULL;\n\tchar *tmpname = NULL;\n\n\tpw_init();\n\n\tif ((fp = xfmkstemp(&tmpname, \"\/etc\", prefix)) == NULL)\n\t\treturn -1;\n\n\t\/* ptmp should be owned by root.root or root.wheel *\/\n\tif (fchown(fileno(fp), (uid_t) 0, (gid_t) 0) < 0)\n\t\tgoto fail;\n\n\t\/* acquire exclusive lock *\/\n\tif (lckpwdf() < 0)\n\t\tgoto fail;\n\tpwf = fopen(PASSWD_FILE, \"r\");","target":0,"flaw_line_index":0,"hash":"fcbdfd07-a6b8-411b-8ef6-1d1255f7ed5b","idx":"bb611271-732d-4107-9545-05e2fd5ac020"}
{"func_before":"\tZ_TYPE_P(return_value) = IS_OBJECT;\n\n\tif (ce->constructor->common.scope != spl_ce_SplFileInfo) {\n\t\tMAKE_STD_ZVAL(arg1);\n\t\tZVAL_STRINGL(arg1, file_path, file_path_len, use_copy);\n\t\tzend_call_method_with_1_params(&return_value, ce, &ce->constructor, \"__construct\", NULL, arg1);\n\t\tzval_ptr_dtor(&arg1);\n\t} else {\n\t\tspl_filesystem_info_set_filename(intern, file_path, file_path_len, use_copy TSRMLS_CC);\n\t}\n\t\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\treturn intern;\n} \/* }}} *\/","target":1,"flaw_line_index":0,"hash":"9af05cd0-afc6-49b8-8a46-de524c5cfc4d","idx":"6c865d22-24a7-4799-ba76-eea99e78a26a"}
{"func_before":"\tZ_TYPE_P(return_value) = IS_OBJECT;\n\n\tif (ce->constructor->common.scope != spl_ce_SplFileInfo) {\n\t\tMAKE_STD_ZVAL(arg1);\n\t\tZVAL_STRINGL(arg1, file_path, file_path_len, use_copy);\n\t\tzend_call_method_with_1_params(&return_value, ce, &ce->constructor, \"__construct\", NULL, arg1);\n\t\tzval_ptr_dtor(&arg1);\n\t} else {\n\t\tspl_filesystem_info_set_filename(intern, file_path, file_path_len, use_copy TSRMLS_CC);\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\treturn intern;\n} \/* }}} *\/","target":0,"flaw_line_index":0,"hash":"11e84064-6afb-4045-bf49-70a133e2e270","idx":"0d1f5ad6-353c-41d3-84e7-5a11cf52ccaf"}
{"func_before":"        length = (Py_ssize_t) slen;\n        if (start < 0) {\n            start += length;\n            if (start < 0)\n                start = 0;\n        }\n        if (stop < 0)\n            stop += length;\n    }\n    if (unlikely(stop <= start))\n        return PyUnicode_FromUnicode(NULL, 0);\n    length = stop - start;\n    cstring += start;\n    if (decode_func) {\n        return decode_func(cstring, length, errors);\n    } else {\n        return PyUnicode_Decode(cstring, length, encoding, errors);\n    }\n}","target":1,"flaw_line_index":0,"hash":"4be12c42-a14a-42cc-a353-dc0a2f235025","idx":"d5ba1811-7a04-4705-bc96-9865af4180cc"}
{"func_before":"        length = (Py_ssize_t) slen;\n        if (start < 0) {\n            start += length;\n            if (start < 0)\n                start = 0;\n        }\n        if (stop < 0)\n            stop += length;\n    }\n    if (unlikely(stop <= start))\n        return __Pyx_NewRef(__pyx_empty_unicode);\n    length = stop - start;\n    cstring += start;\n    if (decode_func) {\n        return decode_func(cstring, length, errors);\n    } else {\n        return PyUnicode_Decode(cstring, length, encoding, errors);\n    }\n}","target":0,"flaw_line_index":0,"hash":"daef062b-4a39-4a7f-b523-11ae0bbb9e45","idx":"ccb4a207-2c3e-455f-b2d1-df8e1576608e"}
{"func_before":"        fe = fe2;\n        tlm2 = fe->fi_time_last_mod;\n        filenum = fiu+1;\n\n        \/*  The space character at the end of line is silly,\n            but lets leave it there for the moment to avoid\n            changing output.  *\/\n        if (line_context->lc_file_entry_count > 9) {\n            dwarfstring_append_printf_u(&m3,\n                \"  file[%2u] \",fiu);\n            dwarfstring_append_printf_s(&m3,\n                \"%-20s \",\n                (char *) fe->fi_file_name);\n            dwarfstring_append_printf_u(&m3,\n                \"(file-number: %u)\\n\",\n                filenum);\n        } else {\n            dwarfstring_append_printf_u(&m3,\n                \"  file[%u]  \", fiu);\n            dwarfstring_append_printf_s(&m3,\n                \"%-20s \",(char *)fe->fi_file_name);\n            dwarfstring_append_printf_u(&m3,\n                \"(file-number: %u)\\n\",filenum);\n        }\n        _dwarf_printf(dbg,dwarfstring_string(&m3));\n        dwarfstring_reset(&m3);\n        if (fe->fi_dir_index_present) {\n            Dwarf_Unsigned di = 0;\n            di = fe->fi_dir_index;\n            dwarfstring_append_printf_i(&m3,\n                \"    dir index %d\\n\", di);\n        }\n        if (fe->fi_time_last_mod_present) {\n            time_t tt = (time_t) tlm2;","target":1,"flaw_line_index":0,"hash":"f8d02c13-23c7-4df2-b9e1-5dded91038d8","idx":"28190691-c05a-4625-b81d-8ad2dbc599fb"}
{"func_before":"\n        fe = fe2;\n        tlm2 = fe->fi_time_last_mod;\n        filenum = fiu+1;\n\n        \/*  The space character at the end of line is silly,\n            but lets leave it there for the moment to avoid\n            changing output.  *\/\n        if (line_context->lc_file_entry_count > 9) {\n            dwarfstring_append_printf_u(&m3,\n                \"  file[%2u] \",fiu);\n        } else {\n            dwarfstring_append_printf_u(&m3,\n                \"  file[%u]  \", fiu);\n        }\n        \/*  DWARF5 can have a null fi_file_name\n            if  the format code in the\n            line table header is unknown, such\n            as in a corrupt object file. *\/\n        dwarfstring_append_printf_s(&m3,\n            \"%-20s \",\n            fe->fi_file_name?\n            (char *) fe->fi_file_name:\n            \"<no file name>\");\n        dwarfstring_append_printf_u(&m3,\n            \"(file-number: %u)\\n\",\n            filenum);\n        _dwarf_printf(dbg,dwarfstring_string(&m3));\n        dwarfstring_reset(&m3);\n        if (fe->fi_dir_index_present) {\n            Dwarf_Unsigned di = 0;\n            di = fe->fi_dir_index;\n            dwarfstring_append_printf_i(&m3,\n                \"    dir index %d\\n\", di);\n        }\n        if (fe->fi_time_last_mod_present) {\n            time_t tt = (time_t) tlm2;","target":0,"flaw_line_index":0,"hash":"5ede5bfb-3f08-4ead-aec6-36facf54be34","idx":"d0616aea-76ca-48f7-a759-db5f1bc01ae3"}
{"func_before":"static Jsi_RC jsi_ArrayUnshiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    Jsi_Obj *obj = _this->d.obj;\n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = Jsi_ObjGetLength(interp, obj);\n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    if (argc <= 0) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    if (Jsi_ObjArraySizer(interp, obj, curlen+argc)<=0) \n        return Jsi_LogError(\"too long\");\n    memmove(obj->arr+argc, obj->arr, (curlen)*sizeof(Jsi_Value*));\n    obj->arrCnt += argc;\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        obj->arr[i] = NULL;\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); continue; }\n        obj->arr[i] = ov;\n        Jsi_IncrRefCount(interp, ov);\n    }\n    Jsi_ObjSetLength(interp, obj, curlen+argc);\n    \n    Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj));\n    return JSI_OK;\n}","target":1,"flaw_line_index":0,"hash":"43cef722-2977-4b01-8643-e622a12c441c","idx":"dc0273ad-36d7-4a6b-bca3-d9266ec3c44c"}
{"func_before":"static Jsi_RC jsi_ArrayUnshiftCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr) {\n    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    Jsi_Obj *obj = _this->d.obj;\n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = jsi_SizeOfArray(interp, obj);\n    if (argc <= 0) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n    if (Jsi_ObjArraySizer(interp, obj, curlen+argc)<=0) \n        return Jsi_LogError(\"too long\");\n    memmove(obj->arr+argc, obj->arr, (curlen)*sizeof(Jsi_Value*));\n    obj->arrCnt += argc;\n    int i;\n    for (i = 0; i < argc; ++i) {\n        Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i);\n        obj->arr[i] = NULL;\n        if (!ov) { Jsi_LogBug(\"Arguments Error\"); continue; }\n        obj->arr[i] = ov;\n        Jsi_IncrRefCount(interp, ov);\n    }\n    Jsi_ObjSetLength(interp, obj, curlen+argc);\n    \n    Jsi_ValueMakeNumber(interp, ret, jsi_SizeOfArray(interp, obj));\n    return JSI_OK;\n}","target":0,"flaw_line_index":0,"hash":"23b8e462-472a-48bc-afdc-d28b5a5eb163","idx":"5138a110-c4d6-481c-8007-cdfae9e9e8ea"}
{"func_before":"asmlinkage __visible void __init xen_start_kernel(void)\n{\n\tstruct physdev_set_iopl set_iopl;\n\tunsigned long initrd_start = 0;\n\tint rc;\n\n\tif (!xen_start_info)\n\t\treturn;\n\n\t__text_gen_insn(&early_xen_iret_patch,\n\t\t\tJMP32_INSN_OPCODE, &early_xen_iret_patch, &xen_iret,\n\t\t\tJMP32_INSN_SIZE);\n\n\txen_domain_type = XEN_PV_DOMAIN;\n\txen_start_flags = xen_start_info->flags;\n\n\txen_setup_features();\n","target":1,"flaw_line_index":0,"hash":"046f2e00-819b-4ba0-82f5-1fdd5b0a6c3d","idx":"c1690358-a0c8-4048-afa7-bd5e29fab369"}
{"func_before":"asmlinkage __visible void __init xen_start_kernel(struct start_info *si)\n{\n\tstruct physdev_set_iopl set_iopl;\n\tunsigned long initrd_start = 0;\n\tint rc;\n\n\tif (!si)\n\t\treturn;\n\n\tclear_bss();\n\n\txen_start_info = si;\n\n\t__text_gen_insn(&early_xen_iret_patch,\n\t\t\tJMP32_INSN_OPCODE, &early_xen_iret_patch, &xen_iret,\n\t\t\tJMP32_INSN_SIZE);\n\n\txen_domain_type = XEN_PV_DOMAIN;\n\txen_start_flags = xen_start_info->flags;\n\n\txen_setup_features();\n","target":0,"flaw_line_index":0,"hash":"0eee9d77-b2f0-43bc-87d8-ed2cf510fc4a","idx":"3655ebe2-bb71-4257-9b6a-6f4548d03a21"}
{"func_before":"\t\tbreak;\n\tcase PCIBAR_MEM64:\n\t\tdev->bar[idx].addr &= ~0xffffffffUL;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tcase PCIBAR_MEMHI64:\n\t\tdev->bar[idx].addr &= 0xffffffff;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tdefault:\n\t\tassert(0);\n\t}\n\n\tif (decode)\n\t\tregister_bar(dev, idx);\n\n\t\/* update bar mapping *\/\n\tif (dev->dev_ops->vdev_update_bar_map && decode)\n\t\tdev->dev_ops->vdev_update_bar_map(ctx, dev, idx, orig_addr);\n}","target":1,"flaw_line_index":0,"hash":"487f5920-eb54-4738-88ff-34422c289489","idx":"eb78da43-9dfd-420d-bfa0-cbd917f33cb3"}
{"func_before":"\t\tbreak;\n\tcase PCIBAR_MEM64:\n\t\tdev->bar[idx].addr &= ~0xffffffffUL;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tcase PCIBAR_MEMHI64:\n\t\tdev->bar[idx].addr &= 0xffffffff;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: invalid bar type %d\\n\", __func__, type);\n\t\treturn;\n\t}\n\n\tif (decode)\n\t\tregister_bar(dev, idx);\n\n\t\/* update bar mapping *\/\n\tif (dev->dev_ops->vdev_update_bar_map && decode)\n\t\tdev->dev_ops->vdev_update_bar_map(ctx, dev, idx, orig_addr);\n}","target":0,"flaw_line_index":0,"hash":"2d8131fc-5962-484d-ab0e-5076c76ee2ae","idx":"0fae1e09-78d7-4a8d-b833-578cb9276318"}
{"func_before":"\n  if (query_string) {\n    \/\/ ntop->getTrace()->traceEvent(TRACE_WARNING, \"[HTTP] %s\", query_string);\n\n    tok = strtok_r(query_string, \"&\", &where);\n\n    while(tok != NULL) {\n      char *_equal;\n\n      if(strncmp(tok, \"csrf\", strlen(\"csrf\")) \/* Do not put csrf into the params table *\/\n\t && (_equal = strchr(tok, '='))) {\n\tchar *decoded_buf;\n        int len;\n\n        _equal[0] = '\\0';\n        _equal = &_equal[1];\n        len = strlen(_equal);\n\n        purifyHTTPParameter(tok), purifyHTTPParameter(_equal);\n\n        \/\/ ntop->getTrace()->traceEvent(TRACE_WARNING, \"%s = %s\", tok, _equal);","target":1,"flaw_line_index":0,"hash":"82cf281f-3184-4f11-80e7-21538332b938","idx":"e810c5c8-3b61-4033-928b-d25c82947da4"}
{"func_before":"\n  if (query_string) {\n    \/\/ ntop->getTrace()->traceEvent(TRACE_WARNING, \"[HTTP] %s\", query_string);\n\n    tok = strtok_r(query_string, \"&\", &where);\n\n    while(tok != NULL) {\n      char *_equal;\n\n      if(strncmp(tok, \"csrf\", strlen(\"csrf\")) \/* Do not put csrf into the params table *\/\n\t && (_equal = strchr(tok, '='))\n\t && (strlen(_equal) > 1)) {\n\tchar *decoded_buf;\n        int len;\n\n        _equal[0] = '\\0';\n        _equal = &_equal[1];\n        len = strlen(_equal);\n\n        purifyHTTPParameter(tok), purifyHTTPParameter(_equal);\n\n        \/\/ ntop->getTrace()->traceEvent(TRACE_WARNING, \"%s = %s\", tok, _equal);","target":0,"flaw_line_index":0,"hash":"b39fc7ae-d689-445d-9d22-b7ec412c7612","idx":"dcd59fc8-4d34-4095-b707-219118ce1eae"}
{"func_before":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  \/\/ Reinterprete the opaque data provided by user.\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n\n  const TfLiteType type = input1->type;\n  switch (type) {\n    case kTfLiteFloat32:\n    case kTfLiteInt32:\n      break;\n    default:\n      context->ReportError(context, \"Type '%s' is not supported by floor_div.\",","target":1,"flaw_line_index":0,"hash":"95edf98e-41cf-4d44-a177-7ae4ba5d0039","idx":"9f2b9161-97fd-4419-a55d-182fb8905982"}
{"func_before":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  \/\/ Reinterprete the opaque data provided by user.\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n\n  const TfLiteType type = input1->type;\n  switch (type) {\n    case kTfLiteFloat32:\n    case kTfLiteInt32:\n      break;\n    default:\n      context->ReportError(context, \"Type '%s' is not supported by floor_div.\",","target":0,"flaw_line_index":0,"hash":"411d11aa-1383-4055-a071-ed618cd2777c","idx":"5d894e8b-f4bf-4d1a-adae-cd35aaa7e604"}
{"func_before":"\n      \/\/ If we do not have any more data in file to read, we must process\n      \/\/ what we have until last byte. Otherwise we can return and append\n      \/\/ more data to unprocessed few bytes.\n      if ((D.Inp.InAddr>=DataBorder) && !D.NoDataLeft || D.Inp.InAddr>=D.DataSize)\n      {\n        D.Incomplete=true;\n        break;\n      }\n    }\n    if (((WriteBorder-UnpPtr) & MaxWinMask)<MAX_LZ_MATCH+3 && WriteBorder!=UnpPtr)\n    {\n      UnpWriteBuf();\n      if (WrittenFileSize>DestUnpSize)\n        return false;\n    }\n\n    uint MainSlot=DecodeNumber(D.Inp,&D.BlockTables.LD);\n    if (MainSlot<256)\n    {\n      Window[UnpPtr++]=(byte)MainSlot;","target":1,"flaw_line_index":0,"hash":"8b9a416f-159d-42da-88e2-36effe1a5424","idx":"5dae65e5-edbd-4fc7-87b4-cb24eeefecd5"}
{"func_before":"\n      \/\/ If we do not have any more data in file to read, we must process\n      \/\/ what we have until last byte. Otherwise we can return and append\n      \/\/ more data to unprocessed few bytes.\n      if ((D.Inp.InAddr>=DataBorder) && !D.NoDataLeft || D.Inp.InAddr>=D.DataSize)\n      {\n        D.Incomplete=true;\n        break;\n      }\n    }\n    if (((WriteBorder-UnpPtr) & MaxWinMask)<MAX_INC_LZ_MATCH && WriteBorder!=UnpPtr)\n    {\n      UnpWriteBuf();\n      if (WrittenFileSize>DestUnpSize)\n        return false;\n    }\n\n    uint MainSlot=DecodeNumber(D.Inp,&D.BlockTables.LD);\n    if (MainSlot<256)\n    {\n      Window[UnpPtr++]=(byte)MainSlot;","target":0,"flaw_line_index":0,"hash":"68e8748c-cab3-4d42-ba02-7d3f9a2c0b82","idx":"34d76541-aea5-4401-a4e3-aba4f48092aa"}
{"func_before":"  switch (sock->getType()) {\n  case AF_UNIX:\n    {\n#ifdef _MSC_VER\n      return false;\n#else\n      struct sockaddr_un *sa = (struct sockaddr_un *)sock_type;\n      sa->sun_family = AF_UNIX;\n      if (addr.length() > sizeof(sa->sun_path)) {\n        raise_warning(\n          \"Unix socket path length (%d) is larger than system limit (%lu)\",\n          addr.length(),\n          sizeof(sa->sun_path)\n        );\n        return false;\n      }\n      memcpy(sa->sun_path, addr.data(), addr.length());\n      sa_ptr = (struct sockaddr *)sa;\n      sa_size = offsetof(struct sockaddr_un, sun_path) + addr.length();\n#ifdef __linux__\n      if (addr.length() == 0) {","target":1,"flaw_line_index":0,"hash":"69097b11-2243-4ed5-a2eb-6ea1d2214626","idx":"a5a0d64e-a2f0-403b-9630-75d2130f0fea"}
{"func_before":"  switch (sock->getType()) {\n  case AF_UNIX:\n    {\n#ifdef _MSC_VER\n      return false;\n#else\n      struct sockaddr_un *sa = (struct sockaddr_un *)sock_type;\n      sa->sun_family = AF_UNIX;\n      if (addr.length() > sizeof(sa->sun_path)) {\n        raise_warning(\n          \"Unix socket path length (%ld) is larger than system limit (%lu)\",\n          addr.length(),\n          sizeof(sa->sun_path)\n        );\n        return false;\n      }\n      memcpy(sa->sun_path, addr.data(), addr.length());\n      sa_ptr = (struct sockaddr *)sa;\n      sa_size = offsetof(struct sockaddr_un, sun_path) + addr.length();\n#ifdef __linux__\n      if (addr.length() == 0) {","target":0,"flaw_line_index":0,"hash":"7e028be1-675d-443b-959e-daeab1438592","idx":"8392dac9-4761-48fb-86c5-06b9f54db76b"}
{"func_before":"    ogs_getopt_t options;\n    struct {\n        char *config_file;\n        char *log_file;\n        char *log_level;\n        char *domain_mask;\n\n        bool enable_debug;\n        bool enable_trace;\n    } optarg;\n    const char *argv_out[argc];\n\n    memset(&optarg, 0, sizeof(optarg));\n\n    ogs_getopt_init(&options, (char**)argv);\n    while ((opt = ogs_getopt(&options, \"vhDc:l:e:m:dt\")) != -1) {\n        switch (opt) {\n        case 'v':\n            show_version();\n            return OGS_OK;\n        case 'h':","target":1,"flaw_line_index":0,"hash":"3638f7db-47c7-41a1-b833-76253414ea80","idx":"f11af784-6238-4bd4-a2be-592afc615336"}
{"func_before":"    ogs_getopt_t options;\n    struct {\n        char *config_file;\n        char *log_file;\n        char *log_level;\n        char *domain_mask;\n\n        bool enable_debug;\n        bool enable_trace;\n    } optarg;\n    const char *argv_out[argc+1];\n\n    memset(&optarg, 0, sizeof(optarg));\n\n    ogs_getopt_init(&options, (char**)argv);\n    while ((opt = ogs_getopt(&options, \"vhDc:l:e:m:dt\")) != -1) {\n        switch (opt) {\n        case 'v':\n            show_version();\n            return OGS_OK;\n        case 'h':","target":0,"flaw_line_index":0,"hash":"194949b5-9d8d-4d04-ae0e-1cf8eaa0e58a","idx":"b74553ba-40cc-4b0c-af17-50111ace9139"}
{"func_before":"{\n  if (blocktyp == POST_BINARY) {\n    output_current_post();\n    blocktyp = POST_ASCII;\n  }\n  \/* Mac line endings *\/\n  if (len > 0 && s[len-1] == '\\n')\n    s[len-1] = '\\r';\n  t1mac_output_data((byte *)s, len);\n  if (strncmp(s, \"\/FontName\", 9) == 0) {\n    for (s += 9; isspace(*s); s++) ;\n    if (*s == '\/') {\n      const char *t = ++s;\n      while (*t && !isspace(*t)) t++;\n      free(font_name);\n      font_name = (char *)malloc(t - s + 1);\n      memcpy(font_name, s, t - s);\n      font_name[t - s] = 0;\n    }\n  }\n}","target":1,"flaw_line_index":0,"hash":"9d6924d9-804a-4858-9143-aed7dc5e464d","idx":"1bd38c55-5a47-49a0-bb76-ea3969d63da0"}
{"func_before":"{\n  if (blocktyp == POST_BINARY) {\n    output_current_post();\n    blocktyp = POST_ASCII;\n  }\n  \/* Mac line endings *\/\n  if (len > 0 && s[len-1] == '\\n')\n    s[len-1] = '\\r';\n  t1mac_output_data((byte *)s, len);\n  if (strncmp(s, \"\/FontName\", 9) == 0) {\n    for (s += 9; isspace((unsigned char) *s); s++)\n        \/* skip *\/;\n    if (*s == '\/') {\n      const char *t = ++s;\n      while (*t && !isspace((unsigned char) *t)) t++;\n      free(font_name);\n      font_name = (char *)malloc(t - s + 1);\n      memcpy(font_name, s, t - s);\n      font_name[t - s] = 0;\n    }\n  }\n}","target":0,"flaw_line_index":0,"hash":"2e4ca285-8e39-4698-936d-7ec8abcd5d3c","idx":"84331ea7-f586-4106-acb3-97206f46756a"}
{"func_before":"      DSA_Verification_Operation(const DSA_PublicKey& dsa,\n                                 const std::string& emsa) :\n         PK_Ops::Verification_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_y(dsa.get_y()),\n         m_mod_q(dsa.group_q())\n         {}","target":1,"flaw_line_index":0,"hash":"b529adc5-a6a7-40a8-8abd-e9d1710b4567","idx":"307c6d5b-de08-44de-94de-ff52e342bd04"}
{"func_before":"      DSA_Verification_Operation(const DSA_PublicKey& dsa,\n                                 const std::string& emsa) :\n         PK_Ops::Verification_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_y(dsa.get_y()),\n         m_mod_q(dsa.group_q())\n         {\n         }","target":0,"flaw_line_index":0,"hash":"af4d53ad-0aca-41b9-8b80-0fcc9e9ccc86","idx":"060059d3-1a62-4eda-8982-9af50e03177b"}
{"func_before":"\t\t    --depth;\n\t\t    line_breakcheck();\n\t\t    ins_compl_check_keys(50, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t    \/\/ Do one more byte at this node.\n\t\t    n = arridx[depth] + curi[depth];\n\t\t    ++curi[depth];\n\t\t    c = byts[n];\n\t\t    if (c == 0)\n\t\t    {\n\t\t\t\/\/ End of word, deal with the word.\n\t\t\t\/\/ Don't use keep-case words in the fold-case tree,\n\t\t\t\/\/ they will appear in the keep-case tree.\n\t\t\t\/\/ Only use the word when the region matches.\n\t\t\tflags = (int)idxs[n];\n\t\t\tif ((round == 2 || (flags & WF_KEEPCAP) == 0)\n\t\t\t\t&& (flags & WF_NEEDCOMP) == 0\n\t\t\t\t&& (do_region\n\t\t\t\t    || (flags & WF_REGION) == 0\n\t\t\t\t    || (((unsigned)flags >> 16)\n\t\t\t\t\t\t       & lp->lp_region) != 0))","target":1,"flaw_line_index":0,"hash":"a2f9b8fc-d1f9-4cf6-aa33-3c13f1212e71","idx":"e246f978-ba1c-4f95-a38a-3f9185aefc41"}
{"func_before":"\t\t    --depth;\n\t\t    line_breakcheck();\n\t\t    ins_compl_check_keys(50, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t    \/\/ Do one more byte at this node.\n\t\t    n = arridx[depth] + curi[depth];\n\t\t    ++curi[depth];\n\t\t    c = byts[n];\n\t\t    if (c == 0 || depth >= MAXWLEN - 1)\n\t\t    {\n\t\t\t\/\/ End of word or reached maximum length, deal with the\n\t\t\t\/\/ word.\n\t\t\t\/\/ Don't use keep-case words in the fold-case tree,\n\t\t\t\/\/ they will appear in the keep-case tree.\n\t\t\t\/\/ Only use the word when the region matches.\n\t\t\tflags = (int)idxs[n];\n\t\t\tif ((round == 2 || (flags & WF_KEEPCAP) == 0)\n\t\t\t\t&& (flags & WF_NEEDCOMP) == 0\n\t\t\t\t&& (do_region\n\t\t\t\t    || (flags & WF_REGION) == 0\n\t\t\t\t    || (((unsigned)flags >> 16)\n\t\t\t\t\t\t       & lp->lp_region) != 0))","target":0,"flaw_line_index":0,"hash":"bfd182e7-caed-4a8f-896e-75ccb88e9d86","idx":"6cb29d09-06bf-430d-8e06-877a9488453d"}
{"func_before":"\n    \/*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     *\/\n\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    if (GSSINT_CHK_LOOP(ctx))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    status = gssint_delete_internal_sec_context(minor_status,\n\t\t\t\t\t\tctx->mech_type,\n\t\t\t\t\t\t&ctx->internal_ctx_id,\n\t\t\t\t\t\toutput_token);\n    if (status)\n\treturn status;\n\n    \/* now free up the space for the union context structure *\/\n    free(ctx->mech_type->elements);\n    free(ctx->mech_type);\n    free(*context_handle);\n    *context_handle = GSS_C_NO_CONTEXT;\n\n    return (GSS_S_COMPLETE);\n}","target":1,"flaw_line_index":0,"hash":"5fe041ca-afcd-4de4-bd93-8f67ed8c6df1","idx":"9fb81029-ebf9-4e3d-883f-37590c396463"}
{"func_before":"\n    \/*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     *\/\n\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    if (GSSINT_CHK_LOOP(ctx))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n\tstatus = gssint_delete_internal_sec_context(minor_status,\n\t\t\t\t\t\t    ctx->mech_type,\n\t\t\t\t\t\t    &ctx->internal_ctx_id,\n\t\t\t\t\t\t    output_token);\n\tif (status)\n\t    return status;\n    }\n\n    \/* now free up the space for the union context structure *\/\n    free(ctx->mech_type->elements);\n    free(ctx->mech_type);\n    free(*context_handle);\n    *context_handle = GSS_C_NO_CONTEXT;\n\n    return (GSS_S_COMPLETE);\n}","target":0,"flaw_line_index":0,"hash":"d45bc88e-007a-4598-a45b-6819233d97b6","idx":"75a90d75-9ddb-4f14-a1cd-5be64b6f5ea2"}
{"func_before":"int mongo_env_read_socket( mongo *conn, void *buf, int len ) {\n    char *cbuf = buf;\n\n    while ( len ) {\n        int sent = recv( conn->sock, cbuf, len, 0 );\n        if ( sent == 0 || sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() );\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n\n    return MONGO_OK;\n}","target":1,"flaw_line_index":0,"hash":"ef1bdd11-7526-4da8-914a-6011e5b961d2","idx":"d4a1b708-7b0c-479c-9aff-e7e938252a81"}
{"func_before":"int mongo_env_read_socket( mongo *conn, void *buf, size_t len ) {\n    char *cbuf = buf;\n\n    while ( len ) {\n        size_t sent = recv( conn->sock, cbuf, len, 0 );\n        if ( sent == 0 || sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() );\n            return MONGO_ERROR;\n        }\n        cbuf += sent;\n        len -= sent;\n    }\n\n    return MONGO_OK;\n}","target":0,"flaw_line_index":0,"hash":"f43b1040-94be-4294-a07d-06ad2ad0e662","idx":"151cdf7f-b448-4b29-b226-d6fffa2141ac"}
{"func_before":"static ssize_t k90_show_macro_mode(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tconst char *macro_mode;\n\tchar data[8];\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_GET_MODE,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 2,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial mode (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\n\tswitch (data[0]) {\n\tcase K90_MACRO_MODE_HW:\n\t\tmacro_mode = \"HW\";\n\t\tbreak;\n\n\tcase K90_MACRO_MODE_SW:\n\t\tmacro_mode = \"SW\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"K90 in unknown mode: %02hhx.\\n\",\n\t\t\t data[0]);\n\t\treturn -EIO;\n\t}\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", macro_mode);\n}","target":1,"flaw_line_index":0,"hash":"84860374-2087-4243-b12f-4651833e0608","idx":"0536d9f8-746a-4f80-8933-27e4b29f591f"}
{"func_before":"static ssize_t k90_show_macro_mode(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tconst char *macro_mode;\n\tchar *data;\n\n\tdata = kmalloc(2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_GET_MODE,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 2,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial mode (error %d).\\n\",\n\t\t\t ret);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tswitch (data[0]) {\n\tcase K90_MACRO_MODE_HW:\n\t\tmacro_mode = \"HW\";\n\t\tbreak;\n\n\tcase K90_MACRO_MODE_SW:\n\t\tmacro_mode = \"SW\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"K90 in unknown mode: %02hhx.\\n\",\n\t\t\t data[0]);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = snprintf(buf, PAGE_SIZE, \"%s\\n\", macro_mode);\nout:\n\tkfree(data);\n\n\treturn ret;\n}","target":0,"flaw_line_index":0,"hash":"2f607a94-eea0-417b-aab1-b0cfee3540a2","idx":"3618b2fe-7d0e-4f12-8423-017d782c0387"}
{"func_before":"\tuint_fast32_t rpx;\n\tuint_fast32_t rpy;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps; ++pi->compno,\n\t  ++pi->picomp) {\n\t\tpirlvl = pi->picomp->pirlvls;\n\t\tpi->xstep = pi->picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls - 1));\n\t\tpi->ystep = pi->picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcheightexpn + pi->picomp->numrlvls - 1));\n\t\tfor (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];\n\t\t  rlvlno < pi->picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp *\n\t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcwidthexpn +\n\t\t\t  pi->picomp->numrlvls - rlvlno - 1)));\n\t\t\tpi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp *\n\t\t\t\t  pi->rlvlno < pi->picomp->numrlvls && pi->rlvlno <\n\t\t\t\t  pchg->rlvlnoend; ++pi->rlvlno, ++pi->pirlvl) {\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;\n\t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);\n\t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n\t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n\t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n\t\t\t\t\tif (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx))) ||\n\t\t\t\t\t  !(pi->x % (pi->picomp->hsamp << rpx))) &&\n\t\t\t\t\t  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy))) ||\n\t\t\t\t\t  !(pi->y % (pi->picomp->vsamp << rpy)))) {\n\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,\n\t\t\t\t\t\t  pi->pirlvl->prcwidthexpn);\n\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,\n\t\t\t\t\t\t  pi->pirlvl->prcheightexpn);\n\t\t\t\t\t\tpi->prcno = prcvind *\n\t\t\t\t\t\t  pi->pirlvl->numhprcs +\n\t\t\t\t\t\t  prchind;\n\t\t\t\t\t\tassert(pi->prcno <\n\t\t\t\t\t\t  pi->pirlvl->numprcs);\n\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno <\n\t\t\t\t\t\t  pi->numlyrs && pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {\n\t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\nskip:\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}","target":1,"flaw_line_index":0,"hash":"80787d2a-6e49-486d-9feb-3af892e9eef4","idx":"04946e89-dd5d-493f-88f8-c747a5aac743"}
{"func_before":"\tuint_fast32_t rpx;\n\tuint_fast32_t rpy;\n\n\tpchg = pi->pchg;\n\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->compno = pchg->compnostart, pi->picomp = &pi->picomps[pi->compno];\n\t  pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps;\n\t  ++pi->compno, ++pi->picomp) {\n\t\tpirlvl = pi->picomp->pirlvls;\n\t\t\/\/ Check for the potential for overflow problems.\n\t\tif (pirlvl->prcwidthexpn + pi->picomp->numrlvls >\n\t\t  JAS_UINTFAST32_NUMBITS - 2 ||\n\t\t  pirlvl->prcheightexpn + pi->picomp->numrlvls >\n\t\t  JAS_UINTFAST32_NUMBITS - 2) {\n\t\t\treturn -1;\n\t\t}\n\t\tpi->xstep = pi->picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls - 1));\n\t\tpi->ystep = pi->picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcheightexpn + pi->picomp->numrlvls - 1));\n\t\tfor (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];\n\t\t  rlvlno < pi->picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp *\n\t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcwidthexpn +\n\t\t\t  pi->picomp->numrlvls - rlvlno - 1)));\n\t\t\tpi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp *\n\t\t\t\t  pi->rlvlno < pi->picomp->numrlvls && pi->rlvlno <\n\t\t\t\t  pchg->rlvlnoend; ++pi->rlvlno, ++pi->pirlvl) {\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;\n\t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);\n\t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n\t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n\t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n\t\t\t\t\tif (((pi->x == pi->xstart &&\n\t\t\t\t\t  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx))) ||\n\t\t\t\t\t  !(pi->x % (pi->picomp->hsamp << rpx))) &&\n\t\t\t\t\t  ((pi->y == pi->ystart &&\n\t\t\t\t\t  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy))) ||\n\t\t\t\t\t  !(pi->y % (pi->picomp->vsamp << rpy)))) {\n\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,\n\t\t\t\t\t\t  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -\n\t\t\t\t\t\t  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);\n\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y,\n\t\t\t\t\t\t  pi->picomp->vsamp << r), pi->pirlvl->prcheightexpn) -\n\t\t\t\t\t\t  JPC_FLOORDIVPOW2(try0, pi->pirlvl->prcheightexpn);\n\t\t\t\t\t\tpi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;\n\t\t\t\t\t\tassert(pi->prcno < pi->pirlvl->numprcs);\n\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno < pi->numlyrs &&\n\t\t\t\t\t\t  pi->lyrno < JAS_CAST(int, pchg->lyrnoend);\n\t\t\t\t\t\t  ++pi->lyrno) {\n\t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\nskip:\n\t\t\t\t\t\t\t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}","target":0,"flaw_line_index":0,"hash":"6e20a47c-6f9e-4ede-bc04-28b85ebe0d4a","idx":"04d3d4ea-01b9-43dd-ab69-1f1d53946a21"}
{"func_before":"\t} else if (ZEND_NUM_ARGS()) {\n\t\tintern->file_name_len = slprintf(tmp_fname, sizeof(tmp_fname), \"php:\/\/temp\/maxmemory:%ld\", max_memory);\n\t\tintern->file_name = tmp_fname;\n\t} else {\n\t\tintern->file_name = \"php:\/\/temp\";\n\t\tintern->file_name_len = 10;\n\t}\n\tintern->u.file.open_mode = \"wb\";\n\tintern->u.file.open_mode_len = 1;\n\tintern->u.file.zcontext = NULL;\n\t\n\tif (spl_filesystem_file_open(intern, 0, 0 TSRMLS_CC) == SUCCESS) {\n\t\tintern->_path_len = 0;\n\t\tintern->_path = estrndup(\"\", 0);\n\t}\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n} \/* }}} *\/","target":1,"flaw_line_index":0,"hash":"865361ec-7143-4ae7-ae47-27efbcaeb6b5","idx":"0e7e09e0-282e-43e0-a1f6-98898aa43a25"}
{"func_before":"\t} else if (ZEND_NUM_ARGS()) {\n\t\tintern->file_name_len = slprintf(tmp_fname, sizeof(tmp_fname), \"php:\/\/temp\/maxmemory:%ld\", max_memory);\n\t\tintern->file_name = tmp_fname;\n\t} else {\n\t\tintern->file_name = \"php:\/\/temp\";\n\t\tintern->file_name_len = 10;\n\t}\n\tintern->u.file.open_mode = \"wb\";\n\tintern->u.file.open_mode_len = 1;\n\tintern->u.file.zcontext = NULL;\n\n\tif (spl_filesystem_file_open(intern, 0, 0 TSRMLS_CC) == SUCCESS) {\n\t\tintern->_path_len = 0;\n\t\tintern->_path = estrndup(\"\", 0);\n\t}\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n} \/* }}} *\/","target":0,"flaw_line_index":0,"hash":"93c8b1e2-76c3-4648-a979-e728497065ab","idx":"41584a57-7ac0-4251-9f4c-e99288b71d2c"}
{"func_before":"obj2ast_withitem(PyObject* obj, withitem_ty* out, PyArena* arena)\n{\n    PyObject* tmp = NULL;\n    expr_ty context_expr;\n    expr_ty optional_vars;\n\n    if (_PyObject_HasAttrId(obj, &PyId_context_expr)) {\n        int res;\n        tmp = _PyObject_GetAttrId(obj, &PyId_context_expr);\n        if (tmp == NULL) goto failed;\n        res = obj2ast_expr(tmp, &context_expr, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    } else {\n        PyErr_SetString(PyExc_TypeError, \"required field \\\"context_expr\\\" missing from withitem\");\n        return 1;\n    }\n    if (exists_not_none(obj, &PyId_optional_vars)) {\n        int res;\n        tmp = _PyObject_GetAttrId(obj, &PyId_optional_vars);\n        if (tmp == NULL) goto failed;\n        res = obj2ast_expr(tmp, &optional_vars, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    } else {\n        optional_vars = NULL;\n    }\n    *out = withitem(context_expr, optional_vars, arena);\n    return 0;\nfailed:\n    Py_XDECREF(tmp);\n    return 1;\n}","target":1,"flaw_line_index":0,"hash":"98f28308-811a-465d-9145-b74ba4744442","idx":"a6947742-4cbb-4f01-a01e-ff06468a2f53"}
{"func_before":"obj2ast_withitem(PyObject* obj, withitem_ty* out, PyArena* arena)\n{\n    PyObject* tmp = NULL;\n    expr_ty context_expr;\n    expr_ty optional_vars;\n\n    if (lookup_attr_id(obj, &PyId_context_expr, &tmp) < 0) {\n        return 1;\n    }\n    if (tmp == NULL) {\n        PyErr_SetString(PyExc_TypeError, \"required field \\\"context_expr\\\" missing from withitem\");\n        return 1;\n    }\n    else {\n        int res;\n        res = obj2ast_expr(tmp, &context_expr, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    }\n    if (lookup_attr_id(obj, &PyId_optional_vars, &tmp) < 0) {\n        return 1;\n    }\n    if (tmp == NULL || tmp == Py_None) {\n        Py_CLEAR(tmp);\n        optional_vars = NULL;\n    }\n    else {\n        int res;\n        res = obj2ast_expr(tmp, &optional_vars, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    }\n    *out = withitem(context_expr, optional_vars, arena);\n    return 0;\nfailed:\n    Py_XDECREF(tmp);\n    return 1;\n}","target":0,"flaw_line_index":0,"hash":"53570595-04e9-4ac8-80cb-9a16fb558caf","idx":"bd5c328c-45a7-436a-ae35-96a028be0b08"}
{"func_before":"ppp_hdlc(netdissect_options *ndo,\n         const u_char *p, u_int length)\n{\n\tu_int caplen = ND_BYTES_AVAILABLE_AFTER(p);\n\tu_char *b, *t, c;\n\tconst u_char *s;\n\tu_int i, proto;\n\tconst void *sb, *se;\n\n\tif (caplen == 0)\n\t\treturn;\n\n        if (length == 0)\n                return;\n\n\tb = (u_char *)nd_malloc(ndo, caplen);\n\tif (b == NULL)\n\t\treturn;\n\n\t\/*\n\t * Unescape all the data into a temporary, private, buffer.\n\t * Do this so that we don't overwrite the original packet\n\t * contents.\n\t *\/\n\tfor (s = p, t = b, i = caplen; i != 0; i--) {\n\t\tc = GET_U_1(s);\n\t\ts++;\n\t\tif (c == 0x7d) {\n\t\t\tif (i <= 1)\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t\tc = GET_U_1(s) ^ 0x20;\n\t\t\ts++;\n\t\t}\n\t\t*t++ = c;\n\t}\n\n\t\/*\n\t * Change the end pointer, so bounds checks work.\n\t * Change the pointer to packet data to help debugging.\n\t *\/\n\tsb = ndo->ndo_packetp;\n\tse = ndo->ndo_snapend;\n\tndo->ndo_packetp = b;\n\tndo->ndo_snapend = t;\n\tlength = ND_BYTES_AVAILABLE_AFTER(b);\n\n        \/* now lets guess about the payload codepoint format *\/\n        if (length < 1)\n                goto trunc;\n        proto = GET_U_1(b); \/* start with a one-octet codepoint guess *\/\n\n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n            break;\n        default: \/* last guess - proto must be a PPP proto-id *\/\n            if ((proto & 0xff00) == 0x7e00)\n                ND_PRINT(\"(protocol 0x%04x invalid)\", proto);\n            else\n                handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\n\ncleanup:\n\tndo->ndo_packetp = sb;\n\tndo->ndo_snapend = se;\n        return;\n\ntrunc:\n\tndo->ndo_packetp = sb;\n\tndo->ndo_snapend = se;\n\tnd_print_trunc(ndo);\n}","target":1,"flaw_line_index":0,"hash":"7f4e87f1-ca93-4422-ba6a-261807f7727a","idx":"ff4b6d38-fa77-4b5b-a03d-1cd511ebe2b5"}
{"func_before":"ppp_hdlc(netdissect_options *ndo,\n         const u_char *p, u_int length)\n{\n\tu_int caplen = ND_BYTES_AVAILABLE_AFTER(p);\n\tu_char *b, *t, c;\n\tconst u_char *s;\n\tu_int i, proto;\n\n\tif (caplen == 0)\n\t\treturn;\n\n        if (length == 0)\n                return;\n\n\tb = (u_char *)malloc(caplen);\n\tif (b == NULL) {\n\t\t(*ndo->ndo_error)(ndo, S_ERR_ND_MEM_ALLOC,\n\t\t\t\"%s: malloc\", __func__);\n\t}\n\n\t\/*\n\t * Unescape all the data into a temporary, private, buffer.\n\t * Do this so that we don't overwrite the original packet\n\t * contents.\n\t *\/\n\tfor (s = p, t = b, i = caplen; i != 0; i--) {\n\t\tc = GET_U_1(s);\n\t\ts++;\n\t\tif (c == 0x7d) {\n\t\t\tif (i <= 1)\n\t\t\t\tbreak;\n\t\t\ti--;\n\t\t\tc = GET_U_1(s) ^ 0x20;\n\t\t\ts++;\n\t\t}\n\t\t*t++ = c;\n\t}\n\n\t\/*\n\t * Switch to the output buffer for dissection, and save it\n\t * on the buffer stack so it can be freed; our caller must\n\t * pop it when done.\n\t *\/\n\tif (!nd_push_buffer(ndo, b, b, (u_int)(t - b))) {\n\t\tfree(b);\n\t\t(*ndo->ndo_error)(ndo, S_ERR_ND_MEM_ALLOC,\n\t\t\t\"%s: can't push buffer on buffer stack\", __func__);\n\t}\n\tlength = ND_BYTES_AVAILABLE_AFTER(b);\n\n        \/* now lets guess about the payload codepoint format *\/\n        if (length < 1)\n                goto trunc;\n        proto = GET_U_1(b); \/* start with a one-octet codepoint guess *\/\n\n        switch (proto) {\n        case PPP_IP:\n\t\tip_print(ndo, b + 1, length - 1);\n            break;\n        default: \/* last guess - proto must be a PPP proto-id *\/\n            if ((proto & 0xff00) == 0x7e00)\n                ND_PRINT(\"(protocol 0x%04x invalid)\", proto);\n            else\n                handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\n\ncleanup:\n\tnd_pop_packet_info(ndo);\n        return;\n\ntrunc:\n\tnd_pop_packet_info(ndo);\n\tnd_print_trunc(ndo);\n}","target":0,"flaw_line_index":0,"hash":"80407c0c-e1c4-4bab-9c7a-adeff8ae8132","idx":"c7d1a653-ac05-4d10-89c9-adda1f686b5b"}
{"func_before":"void CNativeControlEmbed::CreateObjectBuilderInContext(const std::string& name, JSSmart<CJSContext> context)\n{\n    v8::Isolate* current = CV8Worker::GetCurrent();\n    context->m_internal->m_global->Set(current, name.c_str(), v8::FunctionTemplate::New(current, NSNativeControl::CreateNativeObjectBuilder));\n}","target":1,"flaw_line_index":0,"hash":"62603b98-fac4-4503-b291-a474a9befde2","idx":"3737c2ec-b966-4bb1-9cce-5c62abaf269d"}
{"func_before":"void CNativeControlEmbed::CreateObjectBuilderInContext(const std::string& name, JSSmart<CJSContext> context)\n{\n\tv8::Isolate* current = CV8Worker::GetCurrent();\n\tcontext->m_internal->m_global->Set(current, name.c_str(), v8::FunctionTemplate::New(current, NSNativeControl::CreateNativeObjectBuilder));\n}","target":0,"flaw_line_index":0,"hash":"99bfbeb1-7c0f-4583-9490-ce01396d084e","idx":"87c3f513-6a66-4331-be01-54da3d97b92d"}
{"func_before":"    void operator = (const IniSection &s)\n\t{\n\t    if (&s == this)\n\t    {\n\t\treturn;\n\t    } \n\t    IniBase::operator = (s);\n\t    ip = s.ip;\n\t    end_comment = s.end_comment; rewrite_by = s.rewrite_by;\n\t    container = s.container;\n\n\t    reindex ();\n\t}","target":1,"flaw_line_index":0,"hash":"29b3ea5f-dacd-41e4-adda-614fb00e9dab","idx":"f7736fb7-b5f8-4d35-a27d-017b7f2ec0fc"}
{"func_before":"    void operator = (const IniSection &s)\n\t{\n\t    if (&s == this)\n\t    {\n\t\treturn;\n\t    } \n\t    IniBase::operator = (s);\n\t    ip = s.ip;\n\t    end_comment = s.end_comment;\n            is_private = s.is_private;\n            rewrite_by = s.rewrite_by;\n\t    container = s.container;\n\n\t    reindex ();\n\t}","target":0,"flaw_line_index":0,"hash":"01aa79ae-fedd-4a29-8277-d99d0775c26d","idx":"2746c01a-76bc-4353-a6c7-aa5bae57b6fb"}
{"func_before":"\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = valuelen;\n\t\tmemcpy(args->value, &name_loc->nameval[args->namelen], valuelen);\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tASSERT(name_rmt->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n\t\tvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n\t\t\t\t\t\t       valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = valuelen;\n\t}\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"997a711d-aba1-4800-87bc-5a6f0d01e919","idx":"28c5b649-a168-4b32-b51d-cd25cce54f02"}
{"func_before":"\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = valuelen;\n\t\tmemcpy(args->value, &name_loc->nameval[args->namelen], valuelen);\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tASSERT(name_rmt->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n\t\t\t\t\t\t       args->rmtvaluelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < args->rmtvaluelen) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = args->rmtvaluelen;\n\t}\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"62a12dc0-001f-4874-9723-6be2e7b96943","idx":"e0264b87-7379-4b1c-9b32-b3956f00169a"}
{"func_before":"    else\n\tca.cmdchar = c;\n    idx = find_command(ca.cmdchar);\n    if (idx < 0)\n    {\n\t\/\/ Not a known command: beep.\n\tclearopbeep(oap);\n\tgoto normal_end;\n    }\n\n    if ((nv_cmds[idx].cmd_flags & NV_NCW)\n\t\t\t\t&& (check_text_locked(oap) || curbuf_locked()))\n\t\/\/ this command is not allowed now\n\tgoto normal_end;\n\n    \/\/ In Visual\/Select mode, a few keys are handled in a special way.\n    if (VIsual_active)\n    {\n\t\/\/ when 'keymodel' contains \"stopsel\" may stop Select\/Visual mode\n\tif (km_stopsel\n\t\t&& (nv_cmds[idx].cmd_flags & NV_STS)\n\t\t&& !(mod_mask & MOD_MASK_SHIFT))","target":1,"flaw_line_index":0,"hash":"28208156-3e7c-4e53-81c3-086a797d8987","idx":"11b651d9-3486-4c58-a35f-2a063abdbafb"}
{"func_before":"    else\n\tca.cmdchar = c;\n    idx = find_command(ca.cmdchar);\n    if (idx < 0)\n    {\n\t\/\/ Not a known command: beep.\n\tclearopbeep(oap);\n\tgoto normal_end;\n    }\n\n    if ((nv_cmds[idx].cmd_flags & NV_NCW) && check_text_or_curbuf_locked(oap))\n\t\/\/ this command is not allowed now\n\tgoto normal_end;\n\n    \/\/ In Visual\/Select mode, a few keys are handled in a special way.\n    if (VIsual_active)\n    {\n\t\/\/ when 'keymodel' contains \"stopsel\" may stop Select\/Visual mode\n\tif (km_stopsel\n\t\t&& (nv_cmds[idx].cmd_flags & NV_STS)\n\t\t&& !(mod_mask & MOD_MASK_SHIFT))","target":0,"flaw_line_index":0,"hash":"10a4fb34-e6e9-4870-93a0-0080db8870e4","idx":"f333b80a-64bc-4d39-b71d-5bc3f61e1027"}
{"func_before":"\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong PPS ID %d in PPS\\n\", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &vvc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif (pps->sps_id >= 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\tvvc->sps_active_idx = pps->sps_id; \/*set active sps*\/\n\tpps->mixed_nal_types = gf_bs_read_int_log(bs, 1, \"mixed_nal_types\");\n\tpps->width = gf_bs_read_ue_log(bs, \"width\");\n\tpps->height = gf_bs_read_ue_log(bs, \"height\");\n\tpps->conf_window = gf_bs_read_int_log(bs, 1, \"conformance_window_flag\");\n\tif (pps->conf_window) {","target":1,"flaw_line_index":0,"hash":"056f252b-615a-447e-b05c-e38fa95c173d","idx":"d723e5f6-c533-43bc-8ef5-ec64dc5015e2"}
{"func_before":"\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong PPS ID %d in PPS\\n\", pps_id));\n\t\treturn -1;\n\t}\n\tpps = &vvc->pps[pps_id];\n\n\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif ((pps->sps_id<0) || (pps->sps_id >= 16)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\tvvc->sps_active_idx = pps->sps_id; \/*set active sps*\/\n\tpps->mixed_nal_types = gf_bs_read_int_log(bs, 1, \"mixed_nal_types\");\n\tpps->width = gf_bs_read_ue_log(bs, \"width\");\n\tpps->height = gf_bs_read_ue_log(bs, \"height\");\n\tpps->conf_window = gf_bs_read_int_log(bs, 1, \"conformance_window_flag\");\n\tif (pps->conf_window) {","target":0,"flaw_line_index":0,"hash":"8da50bf1-b0e7-4c59-acad-04380165f591","idx":"cb0892e2-4a06-4c46-abcd-fdf6a996cf57"}
{"func_before":"\tfree (symbols);\n\n\tif (!addr && bin->main_cmd.cmd == LC_MAIN) {\n\t\taddr = bin->entry + bin->baddr;\n\t}\n\n\tif (!addr) {\n\t\tut8 b[128];\n\t\tut64 entry = addr_to_offset(bin, bin->entry);\n\t\t\/\/ XXX: X86 only and hacky!\n\t\tif (entry > bin->size || entry + sizeof (b) > bin->size)\n\t\t\treturn 0;\n\t\ti = r_buf_read_at (bin->b, entry, b, sizeof (b));\n\t\tif (i < 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tif (b[i] == 0xe8 && !b[i+3] && !b[i+4]) {\n\t\t\t\tint delta = b[i+1] | (b[i+2] << 8) | (b[i+3] << 16) | (b[i+4] << 24);\n\t\t\t\treturn bin->entry + i + 5 + delta;\n\n\t\t\t}","target":1,"flaw_line_index":0,"hash":"456ffe10-63c5-4e98-b43d-88916a93bcc1","idx":"9d9c2498-0d42-44e8-ae38-acb5583b427f"}
{"func_before":"\tfree (symbols);\n\n\tif (!addr && bin->main_cmd.cmd == LC_MAIN) {\n\t\taddr = bin->entry + bin->baddr;\n\t}\n\n\tif (!addr) {\n\t\tut8 b[128];\n\t\tut64 entry = addr_to_offset(bin, bin->entry);\n\t\t\/\/ XXX: X86 only and hacky!\n\t\tif (entry > bin->size || entry + sizeof (b) > bin->size) {\n\t\t\treturn 0;\n\t\t}\n\t\ti = r_buf_read_at (bin->b, entry, b, sizeof (b));\n\t\tif (i < 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {\n\t\t\tif (b[i] == 0xe8 && !b[i+3] && !b[i+4]) {\n\t\t\t\tint delta = b[i+1] | (b[i+2] << 8) | (b[i+3] << 16) | (b[i+4] << 24);\n\t\t\t\treturn bin->entry + i + 5 + delta;\n\n\t\t\t}","target":0,"flaw_line_index":0,"hash":"7acfa7df-d243-4050-97cf-60642f7ff926","idx":"a04572e3-9cc9-43fd-93ac-2e954edcf477"}
{"func_before":"  }\n\n  if (upper_frequency_limit <= lower_frequency_limit) {\n    LOG(ERROR) << \"Upper frequency limit must be greater than \"\n               << \"lower frequency limit.\";\n    return false;\n  }\n\n  \/\/ An extra center frequency is computed at the top to get the upper\n  \/\/ limit on the high side of the final triangular filter.\n  center_frequencies_.resize(num_channels_ + 1);\n  const double mel_low = FreqToMel(lower_frequency_limit);\n  const double mel_hi = FreqToMel(upper_frequency_limit);\n  const double mel_span = mel_hi - mel_low;\n  const double mel_spacing = mel_span \/ static_cast<double>(num_channels_ + 1);\n  for (int i = 0; i < num_channels_ + 1; ++i) {\n    center_frequencies_[i] = mel_low + (mel_spacing * (i + 1));\n  }\n\n  \/\/ Always exclude DC; emulate HTK.\n  const double hz_per_sbin =","target":1,"flaw_line_index":0,"hash":"800b35bf-4d20-43f6-9d07-443a461887f4","idx":"45418364-b69c-415e-9cae-669994e4f13f"}
{"func_before":"  }\n\n  if (upper_frequency_limit <= lower_frequency_limit) {\n    LOG(ERROR) << \"Upper frequency limit must be greater than \"\n               << \"lower frequency limit.\";\n    return false;\n  }\n\n  \/\/ An extra center frequency is computed at the top to get the upper\n  \/\/ limit on the high side of the final triangular filter.\n  std::size_t center_frequencies_size = std::size_t(num_channels_) + 1;\n  if (center_frequencies_size >= std::numeric_limits<int>::max() ||\n      center_frequencies_size > center_frequencies_.max_size()) {\n    LOG(ERROR) << \"Number of filterbank channels must be less than \"\n               << std::numeric_limits<int>::max()\n               << \" and less than or equal to \"\n               << center_frequencies_.max_size();\n    return false;\n  }\n  center_frequencies_.resize(center_frequencies_size);\n\n  const double mel_low = FreqToMel(lower_frequency_limit);\n  const double mel_hi = FreqToMel(upper_frequency_limit);\n  const double mel_span = mel_hi - mel_low;\n  const double mel_spacing = mel_span \/ static_cast<double>(num_channels_ + 1);\n  for (int i = 0; i < num_channels_ + 1; ++i) {\n    center_frequencies_[i] = mel_low + (mel_spacing * (i + 1));\n  }\n\n  \/\/ Always exclude DC; emulate HTK.\n  const double hz_per_sbin =","target":0,"flaw_line_index":0,"hash":"88908e75-bd23-49fe-b4ed-b381f6db5466","idx":"11fb384a-dd1e-4e37-8a72-fd8997e4b2ba"}
{"func_before":"struct btrfs_device *btrfs_find_device_by_devspec(\n\t\tstruct btrfs_fs_info *fs_info, u64 devid,\n\t\tconst char *device_path)\n{\n\tstruct btrfs_device *device;\n\n\tif (devid) {\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, NULL,\n\t\t\t\t\t   NULL);\n\t\tif (!device)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn device;\n\t}\n\n\tif (!device_path || !device_path[0])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\t\/* Find first missing device *\/","target":1,"flaw_line_index":0,"hash":"3843a788-eedc-45af-b4b9-b3a9a0d9f688","idx":"687c1d20-7c07-4ad3-a2c7-d4440eda44c8"}
{"func_before":"struct btrfs_device *btrfs_find_device_by_devspec(\n\t\tstruct btrfs_fs_info *fs_info, u64 devid,\n\t\tconst char *device_path)\n{\n\tstruct btrfs_device *device;\n\n\tif (devid) {\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, NULL,\n\t\t\t\t\t   NULL, true);\n\t\tif (!device)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn device;\n\t}\n\n\tif (!device_path || !device_path[0])\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (strcmp(device_path, \"missing\") == 0) {\n\t\t\/* Find first missing device *\/","target":0,"flaw_line_index":0,"hash":"3e4fda69-5f43-4dde-8b39-6249c9a67130","idx":"05af151b-ed23-4576-ae7a-6e3482470cbb"}
{"func_before":"    const uint256 &epk,\n    const uint256 &cmu\n)\n{\n    auto pt = AttemptSaplingEncDecryption(ciphertext, ivk, epk);\n    if (!pt) {\n        return boost::none;\n    }\n\n    \/\/ Deserialize from the plaintext\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << pt.get();\n\n    SaplingNotePlaintext ret;\n    ss >> ret;\n\n    assert(ss.size() == 0);\n\n    uint256 pk_d;\n    if (!librustzcash_ivk_to_pkd(ivk.begin(), ret.d.data(), pk_d.begin())) {\n        return boost::none;\n    }\n\n    uint256 cmu_expected;\n    if (!librustzcash_sapling_compute_cm(\n        ret.d.data(),\n        pk_d.begin(),","target":1,"flaw_line_index":0,"hash":"f1f8d79e-0c5a-43a0-8ae7-f0a18a567709","idx":"7441832e-668e-4477-a284-f0a57305c5d5"}
{"func_before":"    const uint256 &ivk,\n    const uint256 &epk,\n    const uint256 &cmu\n)\n{\n    auto pt = AttemptSaplingEncDecryption(ciphertext, ivk, epk);\n    if (!pt) {\n        return boost::none;\n    }\n\n    \/\/ Deserialize from the plaintext\n    SaplingNotePlaintext ret;\n    try {\n        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n        ss << pt.get();\n        ss >> ret;\n        assert(ss.size() == 0);\n    } catch (const boost::thread_interrupted&) {\n        throw;\n    } catch (...) {\n        return boost::none;\n    }\n\n    uint256 pk_d;\n    if (!librustzcash_ivk_to_pkd(ivk.begin(), ret.d.data(), pk_d.begin())) {\n        return boost::none;\n    }\n\n    uint256 cmu_expected;\n    if (!librustzcash_sapling_compute_cm(\n        ret.d.data(),\n        pk_d.begin(),","target":0,"flaw_line_index":0,"hash":"21d263f0-038d-48db-9d56-9b561b8ba178","idx":"1cdf7baf-888d-4afb-9caf-f8d543ab3e89"}
{"func_before":"int http_connect(int sockfd, const char *host, int port, AyProxyData *proxy)\n{\n\t\/* step two : do  proxy tunneling init *\/\n\tchar cmd[512];\n\tchar *inputline = NULL;\n\tchar *proxy_auth = NULL;\n\tchar debug_buff[512];\n\tint remaining = sizeof(cmd) - 1;\n\n\tremaining -= snprintf(cmd, sizeof(cmd), \"CONNECT %s:%d HTTP\/1.1\\r\\n\", host, port);\n\tif (proxy->username && proxy->username[0]) {\n\t\tproxy_auth = encode_proxy_auth_str(proxy);\n\n\t\tstrncat(cmd, \"Proxy-Authorization: Basic \", remaining);\n\t\tremaining -= 27;\n\t\tstrncat(cmd, proxy_auth, remaining);\n\t\tremaining -= strlen(proxy_auth);\n\t\tstrncat(cmd, \"\\r\\n\", remaining);\n\t\tremaining -= 2;\n\t}\n\tstrncat(cmd, \"\\r\\n\", remaining);\n#ifndef DEBUG\n\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", cmd);\n\tdebug_print(debug_buff);\n#endif\n\tif (send(sockfd, cmd, strlen(cmd), 0) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n\tif (ay_recv_line(sockfd, &inputline) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n#ifndef DEBUG\n\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);\n\tdebug_print(debug_buff);\n#endif\n\tif (!strstr(inputline, \"200\")) {\n\t\t\/* Check if proxy authorization needed *\/\n\t\tif (strstr(inputline, \"407\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\t\t\t\tfree(inputline);\n\t\t\t}\n\t\t\treturn AY_PROXY_AUTH_REQUIRED;\n\t\t}\n\t\tif (strstr(inputline, \"403\")) {\n\t\t}\n\t\tfree(inputline);\n\t\treturn AY_CONNECTION_REFUSED;\n\t}\n\n\twhile (strlen(inputline) > 1) {\n\t\tfree(inputline);\n\t\tif (ay_recv_line(sockfd, &inputline) < 0) {\n\t\t\treturn AY_CONNECTION_REFUSED;\n\t\t}\n#ifndef DEBUG\n\t\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);\n\t\tdebug_print(debug_buff);\n#endif\n\t}\n\tfree(inputline);\n\n\tg_free(proxy_auth);\n\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"ad90375e-a52c-46f1-9bbc-7dac9d34f107","idx":"8655b729-40e0-4c24-b7da-02ac36f3b07d"}
{"func_before":"int http_connect(int sockfd, const char *host, int port, AyProxyData *proxy)\n{\n\t\/* step two : do  proxy tunneling init *\/\n\tchar cmd[512];\n\tchar *inputline = NULL;\n\tchar *proxy_auth = NULL;\n\tint remaining = sizeof(cmd) - 1;\n\n\tremaining -= snprintf(cmd, sizeof(cmd), \"CONNECT %s:%d HTTP\/1.1\\r\\n\", host, port);\n\tif (proxy->username && proxy->username[0]) {\n\t\tproxy_auth = encode_proxy_auth_str(proxy);\n\n\t\tstrncat(cmd, \"Proxy-Authorization: Basic \", remaining);\n\t\tremaining -= 27;\n\t\tstrncat(cmd, proxy_auth, remaining);\n\t\tremaining -= strlen(proxy_auth);\n\t\tstrncat(cmd, \"\\r\\n\", remaining);\n\t\tremaining -= 2;\n\t}\n\tstrncat(cmd, \"\\r\\n\", remaining);\n#ifdef DEBUG\n\tdebug_print(\"<%s>\\n\", cmd);\n#endif\n\tif (send(sockfd, cmd, strlen(cmd), 0) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n\tif (ay_recv_line(sockfd, &inputline) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n#ifdef DEBUG\n\tdebug_print(\"<%s>\\n\", inputline);\n#endif\n\tif (!strstr(inputline, \"200\")) {\n\t\t\/* Check if proxy authorization needed *\/\n\t\tif (strstr(inputline, \"407\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\t\t\t\tfree(inputline);\n\t\t\t}\n\t\t\treturn AY_PROXY_AUTH_REQUIRED;\n\t\t}\n\t\tif (strstr(inputline, \"403\")) {\n\t\t}\n\t\tfree(inputline);\n\t\treturn AY_CONNECTION_REFUSED;\n\t}\n\n\twhile (strlen(inputline) > 1) {\n\t\tfree(inputline);\n\t\tif (ay_recv_line(sockfd, &inputline) < 0) {\n\t\t\treturn AY_CONNECTION_REFUSED;\n\t\t}\n#ifdef DEBUG\n\t\tdebug_print(\"<%s>\\n\", inputline);\n#endif\n\t}\n\tfree(inputline);\n\n\tg_free(proxy_auth);\n\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"3e15f187-1ad5-42d9-bdd8-3e37ffe3ae5b","idx":"27f857b8-a484-41d4-ba3c-7267f6c16291"}
{"func_before":"            }\n        }\n\n        vector<string> public_shares(n);\n        for (int i = 0; i < n; ++i) {\n            public_shares[i] = publicShares[i].asString();\n        }\n\n        vector<string> public_keys = calculateAllBlsPublicKeys(public_shares);\n\n        if (public_keys.size() != n) {\n            throw SGXException(UNKNOWN_ERROR, \"\");\n        }\n\n        for (int i = 0; i < n; ++i) {\n            result[\"publicKeys\"][i] = public_keys[i];\n        }\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result);\n}","target":1,"flaw_line_index":0,"hash":"4602f936-e373-4502-972d-e608fbad9592","idx":"61ed5453-7cd3-4992-a4c1-c0efe28ce933"}
{"func_before":"            }\n        }\n\n        vector<string> public_shares(n);\n        for (int i = 0; i < n; ++i) {\n            public_shares[i] = publicShares[i].asString();\n        }\n\n        vector<string> public_keys = calculateAllBlsPublicKeys(public_shares);\n\n        if (public_keys.size() != (uint64_t)n) {\n            throw SGXException(UNKNOWN_ERROR, \"\");\n        }\n\n        for (int i = 0; i < n; ++i) {\n            result[\"publicKeys\"][i] = public_keys[i];\n        }\n    } HANDLE_SGX_EXCEPTION(result)\n\n    RETURN_SUCCESS(result);\n}","target":0,"flaw_line_index":0,"hash":"62c64912-fcb7-4bdc-af89-dced57f866d8","idx":"ea349136-62dc-4eb1-ba6a-4b51ef067b2b"}
{"func_before":"    if (tok->atbol) {\n        int col = 0;\n        int altcol = 0;\n        tok->atbol = 0;\n        for (;;) {\n            c = tok_nextc(tok);\n            if (c == ' ') {\n                col++, altcol++;\n            }\n            else if (c == '\\t') {\n                col = (col\/tok->tabsize + 1) * tok->tabsize;\n                altcol = (altcol\/tok->alttabsize + 1)\n                    * tok->alttabsize;\n            }\n            else if (c == '\\014')  {\/* Control-L (formfeed) *\/\n                col = altcol = 0; \/* For Emacs users *\/\n            }\n            else {\n                break;\n            }\n        }\n        tok_backup(tok, c);\n        if (c == '#' || c == '\\n') {\n            else {\n                blankline = 1; \/* Ignore completely *\/\n            }\n            \/* We can't jump back right here since we still\n               may need to skip to the end of a comment *\/\n        }\n        if (!blankline && tok->level == 0) {\n            if (col == tok->indstack[tok->indent]) {\n                \/* No change *\/\n                if (altcol != tok->altindstack[tok->indent]) {\n                    if (indenterror(tok)) {\n                        return ERRORTOKEN;\n                    }\n                }\n            }\n            else if (col > tok->indstack[tok->indent]) {\n                \/* Indent -- always one *\/\n                if (tok->indent+1 >= MAXINDENT) {\n                    tok->done = E_TOODEEP;\n                    tok->cur = tok->inp;\n                    return ERRORTOKEN;\n                }\n                if (altcol <= tok->altindstack[tok->indent]) {\n                    if (indenterror(tok)) {\n                        return ERRORTOKEN;\n                    }\n                }\n                tok->pendin++;\n                tok->indstack[++tok->indent] = col;\n                tok->altindstack[tok->indent] = altcol;\n            }\n            else \/* col < tok->indstack[tok->indent] *\/ {\n                \/* Dedent -- any number, must be consistent *\/\n                while (tok->indent > 0 &&\n                    col < tok->indstack[tok->indent]) {\n                    tok->pendin--;\n                    tok->indent--;\n                }\n                if (col != tok->indstack[tok->indent]) {\n                    tok->done = E_DEDENT;\n                    tok->cur = tok->inp;\n                    return ERRORTOKEN;\n                }\n                if (altcol != tok->altindstack[tok->indent]) {\n                    if (indenterror(tok)) {\n                        return ERRORTOKEN;\n                    }\n                }\n            }\n        }\n    }\n\n    tok->start = tok->cur;\n\n    \/* Return pending indents\/dedents *\/\n    if (tok->pendin != 0) {\n        if (tok->pendin < 0) {\n    }\n\n    \/* Check for EOF and errors now *\/\n    if (c == EOF) {\n        return tok->done == E_EOF ? ENDMARKER : ERRORTOKEN;\n    }\n\n    \/* Identifier (most frequent token!) *\/\n    nonascii = 0;\n    if (is_potential_identifier_start(c)) {\n        \/* Process b\"\", r\"\", u\"\", br\"\" and rb\"\" *\/\n        int saw_b = 0, saw_r = 0, saw_u = 0, saw_f = 0;\n        while (1) {\n            if (!(saw_b || saw_u || saw_f) && (c == 'b' || c == 'B'))\n                saw_b = 1;\n            \/* Since this is a backwards compatibility support literal we don't\n               want to support it in arbitrary order like byte literals. *\/\n            else if (!(saw_b || saw_u || saw_r || saw_f)\n                     && (c == 'u'|| c == 'U')) {\n                saw_u = 1;\n            }\n        tok_backup(tok, c);\n        if (nonascii && !verify_identifier(tok)) {\n            return ERRORTOKEN;\n        }\n        *p_start = tok->start;\n        *p_end = tok->cur;\n\n        \/* async\/await parsing block. *\/\n        if (tok->cur - tok->start == 5) {\n            \/* Current token length is 5. *\/\n            if (tok->async_def) {\n                \/* We're inside an 'async def' function. *\/\n                if (memcmp(tok->start, \"async\", 5) == 0) {\n                    return ASYNC;\n                }\n                if (memcmp(tok->start, \"await\", 5) == 0) {\n                    return AWAIT;\n                }\n            }\n            else if (memcmp(tok->start, \"async\", 5) == 0) {\n                \/* The current token is 'async'.","target":1,"flaw_line_index":0,"hash":"b1f8bca4-c26b-4a3c-a3fa-16a016cf5ba7","idx":"813b55b0-40c2-4501-9270-5083b95665cb"}
{"func_before":"    if (tok->atbol) {\n        int col = 0;\n        int altcol = 0;\n        tok->atbol = 0;\n        for (;;) {\n            c = tok_nextc(tok);\n            if (c == ' ') {\n                col++, altcol++;\n            }\n            else if (c == '\\t') {\n                col = (col \/ tok->tabsize + 1) * tok->tabsize;\n                altcol = (altcol \/ ALTTABSIZE + 1) * ALTTABSIZE;\n            }\n            else if (c == '\\014')  {\/* Control-L (formfeed) *\/\n                col = altcol = 0; \/* For Emacs users *\/\n            }\n            else {\n                break;\n            }\n        }\n        tok_backup(tok, c);\n        if (c == '#' || c == '\\n') {\n            else {\n                blankline = 1; \/* Ignore completely *\/\n            }\n            \/* We can't jump back right here since we still\n               may need to skip to the end of a comment *\/\n        }\n        if (!blankline && tok->level == 0) {\n            if (col == tok->indstack[tok->indent]) {\n                \/* No change *\/\n                if (altcol != tok->altindstack[tok->indent]) {\n                    return indenterror(tok);\n                }\n            }\n            else if (col > tok->indstack[tok->indent]) {\n                \/* Indent -- always one *\/\n                if (tok->indent+1 >= MAXINDENT) {\n                    tok->done = E_TOODEEP;\n                    tok->cur = tok->inp;\n                    return ERRORTOKEN;\n                }\n                if (altcol <= tok->altindstack[tok->indent]) {\n                    return indenterror(tok);\n                }\n                tok->pendin++;\n                tok->indstack[++tok->indent] = col;\n                tok->altindstack[tok->indent] = altcol;\n            }\n            else \/* col < tok->indstack[tok->indent] *\/ {\n                \/* Dedent -- any number, must be consistent *\/\n                while (tok->indent > 0 &&\n                    col < tok->indstack[tok->indent]) {\n                    tok->pendin--;\n                    tok->indent--;\n                }\n                if (col != tok->indstack[tok->indent]) {\n                    tok->done = E_DEDENT;\n                    tok->cur = tok->inp;\n                    return ERRORTOKEN;\n                }\n                if (altcol != tok->altindstack[tok->indent]) {\n                    return indenterror(tok);\n                }\n            }\n        }\n    }\n\n    tok->start = tok->cur;\n\n    \/* Return pending indents\/dedents *\/\n    if (tok->pendin != 0) {\n        if (tok->pendin < 0) {\n    }\n\n    \/* Check for EOF and errors now *\/\n    if (c == EOF) {\n        return tok->done == E_EOF ? ENDMARKER : ERRORTOKEN;\n    }\n\n    \/* Identifier (most frequent token!) *\/\n    nonascii = 0;\n    if (is_potential_identifier_start(c)) {\n        \/* Process the various legal combinations of b\"\", r\"\", u\"\", and f\"\". *\/\n        int saw_b = 0, saw_r = 0, saw_u = 0, saw_f = 0;\n        while (1) {\n            if (!(saw_b || saw_u || saw_f) && (c == 'b' || c == 'B'))\n                saw_b = 1;\n            \/* Since this is a backwards compatibility support literal we don't\n               want to support it in arbitrary order like byte literals. *\/\n            else if (!(saw_b || saw_u || saw_r || saw_f)\n                     && (c == 'u'|| c == 'U')) {\n                saw_u = 1;\n            }\n        tok_backup(tok, c);\n        if (nonascii && !verify_identifier(tok)) {\n            return ERRORTOKEN;\n        }\n        *p_start = tok->start;\n        *p_end = tok->cur;\n\n        \/* async\/await parsing block. *\/\n        if (tok->cur - tok->start == 5) {\n            \/* Current token length is 5. *\/\n            if (tok->async_always || tok->async_def) {\n                \/* We're inside an 'async def' function. *\/\n                if (memcmp(tok->start, \"async\", 5) == 0) {\n                    return ASYNC;\n                }\n                if (memcmp(tok->start, \"await\", 5) == 0) {\n                    return AWAIT;\n                }\n            }\n            else if (memcmp(tok->start, \"async\", 5) == 0) {\n                \/* The current token is 'async'.","target":0,"flaw_line_index":0,"hash":"79b39b56-b0e7-470c-ae09-e2cfbad56af0","idx":"84459b69-086c-4d46-9fc4-60a076741299"}
{"func_before":"  JsVar *parent = 0;\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    bool ok = false;\n    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      \/\/ if no parent, check in root?\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n\n      if (jsvHasChildren(parent)) {\n        \/\/ else remove properly.\n        if (jsvIsArray(parent)) {\n          \/\/ For arrays, we must make sure we don't change the length\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);\n        } else {\n          jsvRemoveChild(parent, a);\n        }\n        ok = true;\n      }","target":1,"flaw_line_index":0,"hash":"e3c53b12-02f7-43aa-b018-5ee1442f5aaa","idx":"a2544e16-94a4-45f5-881b-9042e8730dd7"}
{"func_before":"  JsVar *parent = 0;\n  JsVar *a = jspeFactorMember(jspeFactor(), &parent);\n  JsVar *result = 0;\n  if (JSP_SHOULD_EXECUTE) {\n    bool ok = false;\n    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      \/\/ if no parent, check in root?\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n\n#ifdef DEBUG\n      if (jsvHasChildren(parent)) assert(jsvIsChild(parent, a));\n#endif\n      if (jsvHasChildren(parent) && jsvIsChild(parent, a)) {\n        \/\/ else remove properly.\n        \/* we use jsvIsChild here just in case. delete probably isn't called\n        that often so it pays to be safe *\/\n        if (jsvIsArray(parent)) {\n          \/\/ For arrays, we must make sure we don't change the length\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);\n        } else {\n          jsvRemoveChild(parent, a);\n        }\n        ok = true;\n      }","target":0,"flaw_line_index":0,"hash":"57732dd8-3bba-48a2-9d4a-d2b92bd18d27","idx":"d36f84f8-f242-41b3-80b4-6bbd3f476a64"}
{"func_before":"int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tint r = EMULATION_OK;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\n\tinit_emulate_ctxt(vcpu);\n\n\t\/*\n\t * We will reenter on the same instruction since we do not set\n\t * complete_userspace_io. This does not handle watchpoints yet,\n\t * those would be handled in the emulate_ops.\n\t *\/\n\tif (!(emulation_type & EMULTYPE_SKIP) &&\n\t    kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\treturn r;\n\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu->stat.insn_emulation;\n\n\treturn r;\n}","target":1,"flaw_line_index":0,"hash":"106733e3-8f9c-47d6-8884-9bfa9f68dbad","idx":"efb880b8-5619-4020-bb98-960d499482e9"}
{"func_before":"int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint r;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu->stat.insn_emulation;\n\n\treturn r;\n}","target":0,"flaw_line_index":0,"hash":"9eb55ffc-c6d6-45fe-bacc-c74a0038f47a","idx":"77ebebf8-b23c-419d-a6a8-05cf0d8473a1"}
{"func_before":"static_inline bool unsafe_yyjson_num_equals(void *lhs, void *rhs) {\n    yyjson_val_uni *luni = &((yyjson_val *)lhs)->uni;\n    yyjson_val_uni *runi = &((yyjson_val *)rhs)->uni;\n    yyjson_subtype lt = unsafe_yyjson_get_subtype(lhs);\n    yyjson_subtype rt = unsafe_yyjson_get_subtype(rhs);\n    if (lt == rt)\n        return luni->u64 == runi->u64;\n    if (lt == YYJSON_SUBTYPE_SINT && rt == YYJSON_SUBTYPE_UINT)\n        return luni->i64 >= 0 && luni->u64 == runi->u64;\n    if (lt == YYJSON_SUBTYPE_UINT && rt == YYJSON_SUBTYPE_SINT)\n        return runi->i64 >= 0 && luni->u64 == runi->u64;\n    return false;\n}","target":1,"flaw_line_index":0,"hash":"de9e6991-c835-4489-9cf4-2b20f7cf1060","idx":"42ebb45c-7fb2-44e5-8f71-e0949a19ff8c"}
{"func_before":"static_inline bool unsafe_yyjson_num_equals(void *lhs, void *rhs) {\n    yyjson_val_uni *luni = &((yyjson_val *)lhs)->uni;\n    yyjson_val_uni *runi = &((yyjson_val *)rhs)->uni;\n    yyjson_subtype lt = unsafe_yyjson_get_subtype(lhs);\n    yyjson_subtype rt = unsafe_yyjson_get_subtype(rhs);\n    if (lt == rt) return luni->u64 == runi->u64;\n    if (lt == YYJSON_SUBTYPE_SINT && rt == YYJSON_SUBTYPE_UINT) {\n        return luni->i64 >= 0 && luni->u64 == runi->u64;\n    }\n    if (lt == YYJSON_SUBTYPE_UINT && rt == YYJSON_SUBTYPE_SINT) {\n        return runi->i64 >= 0 && luni->u64 == runi->u64;\n    }\n    return false;\n}","target":0,"flaw_line_index":0,"hash":"caf8c1e1-616c-431f-9a86-a5405bb73e69","idx":"e33f133c-8f1e-4086-85cf-7b8d7fb3c16a"}
{"func_before":"u32 cdk_pk_get_keyid(cdk_pubkey_t pk, u32 * keyid)\n{\n\tu32 lowbits = 0;\n\tbyte buf[24];\n\n\tif (pk && (!pk->keyid[0] || !pk->keyid[1])) {\n\t\tif (pk->version < 4 && is_RSA(pk->pubkey_algo)) {\n\t\t\tbyte p[MAX_MPI_BYTES];\n\t\t\tsize_t n;\n\n\t\t\tn = MAX_MPI_BYTES;\n\t\t\t_gnutls_mpi_print(pk->mpi[0], p, &n);\n\t\t\tpk->keyid[0] =\n\t\t\t    p[n - 8] << 24 | p[n - 7] << 16 | p[n -\n\t\t\t\t\t\t\t\t6] << 8 |\n\t\t\t    p[n - 5];\n\t\t\tpk->keyid[1] =\n\t\t\t    p[n - 4] << 24 | p[n - 3] << 16 | p[n -\n\t\t\t\t\t\t\t\t2] << 8 |\n\t\t\t    p[n - 1];\n\t\t} else if (pk->version == 4) {\n\t\t\tcdk_pk_get_fingerprint(pk, buf);","target":1,"flaw_line_index":0,"hash":"94f8aca2-1d32-4b6f-aa94-bdd018a8a3dd","idx":"d33589f6-e641-4cca-b611-c41e4ac036d6"}
{"func_before":"u32 cdk_pk_get_keyid(cdk_pubkey_t pk, u32 * keyid)\n{\n\tu32 lowbits = 0;\n\tbyte buf[24];\n\tint rc;\n\n\tif (pk && (!pk->keyid[0] || !pk->keyid[1])) {\n\t\tif (pk->version < 4 && is_RSA(pk->pubkey_algo)) {\n\t\t\tbyte p[MAX_MPI_BYTES];\n\t\t\tsize_t n;\n\n\t\t\tn = MAX_MPI_BYTES;\n\t\t\trc = _gnutls_mpi_print(pk->mpi[0], p, &n);\n\t\t\tif (rc < 0 || n < 8) {\n\t\t\t\tkeyid[0] = keyid[1] = (u32)-1;\n\t\t\t\treturn (u32)-1;\n\t\t\t}\n\n\t\t\tpk->keyid[0] =\n\t\t\t    p[n - 8] << 24 | p[n - 7] << 16 | p[n -\n\t\t\t\t\t\t\t\t6] << 8 |\n\t\t\t    p[n - 5];\n\t\t\tpk->keyid[1] =\n\t\t\t    p[n - 4] << 24 | p[n - 3] << 16 | p[n -\n\t\t\t\t\t\t\t\t2] << 8 |\n\t\t\t    p[n - 1];\n\t\t} else if (pk->version == 4) {\n\t\t\tcdk_pk_get_fingerprint(pk, buf);","target":0,"flaw_line_index":0,"hash":"8387b97a-0e48-41ce-9c0e-0528cf53e1a6","idx":"e30e03ff-18ed-4ee3-b98d-ef0856786d3a"}
{"func_before":"static inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\t\/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t *\/\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tstruct frag_hdr fhdr;\n\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\n\t\t\/* reserve space for Hardware header *\/\n\t\tskb_reserve(skb, hh_len);\n\n\t\t\/* create space for UDP\/IP header *\/\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\n\t\t\/* initialize network header pointer *\/\n\t\tskb_reset_network_header(skb);\n\n\t\t\/* initialize protocol header pointer *\/\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\n\t\t\/* Specify the length of each IPv6 datagram fragment.\n\t\t * It has to be a multiple of 8.\n\t\t *\/\n\t\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\tipv6_select_ident(&fhdr, rt);\n\t\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t}\n\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}","target":1,"flaw_line_index":0,"hash":"d1af69de-410f-4c08-acbe-53bd53f7d76b","idx":"6c22c15f-9509-45f5-8bb8-fc30f660db07"}
{"func_before":"static inline int ip6_ufo_append_data(struct sock *sk,\n\t\t\tint getfrag(void *from, char *to, int offset, int len,\n\t\t\tint odd, struct sk_buff *skb),\n\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n\n{\n\tstruct sk_buff *skb;\n\tstruct frag_hdr fhdr;\n\tint err;\n\n\t\/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t *\/\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\n\t\t\/* reserve space for Hardware header *\/\n\t\tskb_reserve(skb, hh_len);\n\n\t\t\/* create space for UDP\/IP header *\/\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\n\t\t\/* initialize network header pointer *\/\n\t\tskb_reset_network_header(skb);\n\n\t\t\/* initialize protocol header pointer *\/\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->csum = 0;\n\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t} else if (skb_is_gso(skb)) {\n\t\tgoto append;\n\t}\n\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\/* Specify the length of each IPv6 datagram fragment.\n\t * It has to be a multiple of 8.\n\t *\/\n\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\tipv6_select_ident(&fhdr, rt);\n\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n\nappend:\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}","target":0,"flaw_line_index":0,"hash":"62cf2397-b326-4cbf-b51f-a3e6162146e9","idx":"c183a4a3-18e7-4a90-9c2a-a45df823ee46"}
{"func_before":"static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n  int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,\n  int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,\n  uint_fast32_t inmem)\n{\n\tjas_image_cmpt_t *cmpt;\n\tsize_t size;\n\n\tcmpt = 0;\n\tif (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {\n\t\tgoto error;\n\t}\n\tif (!jas_safe_intfast32_add(tlx, width, 0) ||\n\t  !jas_safe_intfast32_add(tly, height, 0)) {\n\t\tgoto error;\n\t}\n\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\tgoto error;\n\t}\n\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) \/ 8;\n\n\t\/\/ Compute the number of samples in the image component, while protecting\n\t\/\/ against overflow.\n\t\/\/ size = cmpt->width_ * cmpt->height_ * cmpt->cps_;\n\tif (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||\n\t  !jas_safe_size_mul(size, cmpt->cps_, &size)) {\n\t\tgoto error;\n\t}\n\tcmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :\n\t  jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tgoto error;\n\t}\n\n\t\/* Zero the component data.  This isn't necessary, but it is\n\tconvenient for debugging purposes. *\/","target":1,"flaw_line_index":0,"hash":"62dabd52-c0e2-4d9a-b354-9b1fd4c63d84","idx":"fe4ac3e6-9adf-48db-b6df-63d862752fed"}
{"func_before":"static jas_image_cmpt_t *jas_image_cmpt_create(int_fast32_t tlx,\n  int_fast32_t tly, int_fast32_t hstep, int_fast32_t vstep,\n  int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,\n  uint_fast32_t inmem)\n{\n\tjas_image_cmpt_t *cmpt;\n\tsize_t size;\n\n\tJAS_DBGLOG(100, (\n\t  \"jas_image_cmpt_create(%ld, %ld, %ld, %ld, %ld, %ld, %d, %d, %d)\\n\",\n\t  JAS_CAST(long, tlx),\n\t  JAS_CAST(long, tly),\n\t  JAS_CAST(long, hstep),\n\t  JAS_CAST(long, vstep),\n\t  JAS_CAST(long, width),\n\t  JAS_CAST(long, height),\n\t  JAS_CAST(int, depth),\n\t  sgnd,\n\t  inmem\n\t  ));\n\n\tcmpt = 0;\n\tif (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {\n\t\tgoto error;\n\t}\n\tif (!jas_safe_intfast32_add(tlx, width, 0) ||\n\t  !jas_safe_intfast32_add(tly, height, 0)) {\n\t\tgoto error;\n\t}\n\tif (!jas_safe_intfast32_mul3(width, height, depth, 0)) {\n\t\tgoto error;\n\t}\n\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\tgoto error;\n\t}\n\n\tcmpt->type_ = JAS_IMAGE_CT_UNKNOWN;\n\tcmpt->tlx_ = tlx;\n\tcmpt->tly_ = tly;\n\tcmpt->width_ = width;\n\tcmpt->height_ = height;\n\tcmpt->prec_ = depth;\n\tcmpt->sgnd_ = sgnd;\n\tcmpt->stream_ = 0;\n\tcmpt->cps_ = (depth + 7) \/ 8;\n\n\t\/\/ Compute the number of samples in the image component, while protecting\n\t\/\/ against overflow.\n\t\/\/ size = cmpt->width_ * cmpt->height_ * cmpt->cps_;\n\tif (!jas_safe_size_mul3(cmpt->width_, cmpt->height_, cmpt->cps_, &size)) {\n\t\tgoto error;\n\t}\n\tcmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :\n\t  jas_stream_tmpfile();\n\tif (!cmpt->stream_) {\n\t\tgoto error;\n\t}\n\n\t\/* Zero the component data.  This isn't necessary, but it is\n\tconvenient for debugging purposes. *\/","target":0,"flaw_line_index":0,"hash":"00da5ca8-aedf-4203-9f30-f2277881085f","idx":"0938d664-3613-4e08-8856-1f5adaf763c5"}
{"func_before":"static int dccp_error(struct net *net, struct nf_conn *tmpl,\n\t\t      struct sk_buff *skb, unsigned int dataoff,\n\t\t      enum ip_conntrack_info *ctinfo,\n\t\t      u_int8_t pf, unsigned int hooknum)\n{\n\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb->len - dataoff;\n\tunsigned int cscov;\n\tconst char *msg;\n\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tif (dh == NULL) {\n\t\tmsg = \"nf_ct_dccp: short packet \";\n\t\tgoto out_invalid;\n\t}\n\n\tif (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||\n\t    dh->dccph_doff * 4 > dccp_len) {\n\t\tmsg = \"nf_ct_dccp: truncated\/malformed packet \";\n\t\tgoto out_invalid;\n\t}","target":1,"flaw_line_index":0,"hash":"fba54164-f36f-4feb-8151-fc2dc7f9b9a0","idx":"5da59946-ce64-40b1-8026-5ad2ff1dbfa3"}
{"func_before":"static int dccp_error(struct net *net, struct nf_conn *tmpl,\n\t\t      struct sk_buff *skb, unsigned int dataoff,\n\t\t      enum ip_conntrack_info *ctinfo,\n\t\t      u_int8_t pf, unsigned int hooknum)\n{\n\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb->len - dataoff;\n\tunsigned int cscov;\n\tconst char *msg;\n\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);\n\tif (dh == NULL) {\n\t\tmsg = \"nf_ct_dccp: short packet \";\n\t\tgoto out_invalid;\n\t}\n\n\tif (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||\n\t    dh->dccph_doff * 4 > dccp_len) {\n\t\tmsg = \"nf_ct_dccp: truncated\/malformed packet \";\n\t\tgoto out_invalid;\n\t}","target":0,"flaw_line_index":0,"hash":"06bcf2ce-6a38-4ce1-9901-c7712f146cca","idx":"b7953a6d-a64d-4502-9407-2ce3e6e5019c"}
{"func_before":"fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample \/ 8;\n\ttmsize_t wc = cc \/ bps;\n\ttmsize_t count = cc;\n\tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp = (uint8 *)_TIFFmalloc(cc);\n\n    if(cc%(bps*stride)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"fpAcc\",\n                     \"%s\", \"cc%(bps*stride))!=0\");\n        return 0;\n    }\n\n\tif (!tmp)\n\t\treturn 0;\n\n\twhile (count > stride) {\n\t\tREPEAT4(stride, cp[stride] =\n                        (unsigned char) ((cp[stride] + cp[0]) & 0xff); cp++)\n\t\tcount -= stride;\n\t}\n\n\t_TIFFmemcpy(tmp, cp0, cc);","target":1,"flaw_line_index":0,"hash":"e915f8ad-7c87-469e-ba49-f35509acf5a3","idx":"5179feeb-fc82-47ec-9249-afcd2e52f4dd"}
{"func_before":"fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample \/ 8;\n\ttmsize_t wc = cc \/ bps;\n\ttmsize_t count = cc;\n\tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp;\n\n    if(cc%(bps*stride)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"fpAcc\",\n                     \"%s\", \"cc%(bps*stride))!=0\");\n        return 0;\n    }\n\n    tmp = (uint8 *)_TIFFmalloc(cc);\n\tif (!tmp)\n\t\treturn 0;\n\n\twhile (count > stride) {\n\t\tREPEAT4(stride, cp[stride] =\n                        (unsigned char) ((cp[stride] + cp[0]) & 0xff); cp++)\n\t\tcount -= stride;\n\t}\n\n\t_TIFFmemcpy(tmp, cp0, cc);","target":0,"flaw_line_index":0,"hash":"9518618f-6fcb-42fc-9904-169be2c9cbf2","idx":"aca3b876-0538-4f99-9e70-967dc94d726b"}
{"func_before":"      info_dir_name = CPDB_BACKEND_INFO_DIR;\n    path = cpdbConcatPath(info_dir_name, backend_file_name);\n    \n    if ((file = fopen(path, \"r\")) == NULL)\n    {\n        logerror(\"Error creating backend %s : Couldn't open %s for reading\\n\",\n                    backend_name, path);\n        free(path);\n        return NULL;\n    }\n    if (fscanf(file, \"%s\", obj_path) == 0)\n    {\n        logerror(\"Error creating backend %s : Couldn't parse %s\\n\",\n                    backend_name, path);\n        free(path);\n        fclose(file);\n        return NULL;\n    }\n    free(path);\n    fclose(file);\n    ","target":1,"flaw_line_index":0,"hash":"3c0589bc-513a-4eeb-b5ab-c9ac93277cb6","idx":"304c8df5-5022-4e09-a41a-6a0c8856145f"}
{"func_before":"      info_dir_name = CPDB_BACKEND_INFO_DIR;\n    path = cpdbConcatPath(info_dir_name, backend_file_name);\n    \n    if ((file = fopen(path, \"r\")) == NULL)\n    {\n        logerror(\"Error creating backend %s : Couldn't open %s for reading\\n\",\n                    backend_name, path);\n        free(path);\n        return NULL;\n    }\n    if (fscanf(file, \"%1023s\", obj_path) == 0)\n    {\n        logerror(\"Error creating backend %s : Couldn't parse %s\\n\",\n                    backend_name, path);\n        free(path);\n        fclose(file);\n        return NULL;\n    }\n    free(path);\n    fclose(file);\n    ","target":0,"flaw_line_index":0,"hash":"56bf7ef3-0cb7-42ec-8698-9009c0333cf1","idx":"e9717de3-9522-4cfe-b310-54cea1380b92"}
{"func_before":"static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n{\n\tstruct sem_array *sma;\n\tstruct sem_undo_list *ulp;\n\tstruct sem_undo *un, *new;\n\tint nsems;\n\tint error;\n\n\terror = get_undo_list(&ulp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\trcu_read_lock();\n\tspin_lock(&ulp->lock);\n\tun = lookup_undo(ulp, semid);\n\tspin_unlock(&ulp->lock);\n\tif (likely(un!=NULL))\n\n\t\/* no undo structure around - allocate one. *\/\n\t\/* step 1: figure out the size of the semaphore array *\/\n\tsma = sem_obtain_object_check(ns, semid);\n\tif (IS_ERR(sma)) {\n\t\trcu_read_unlock();\n\t\treturn ERR_CAST(sma);\n\t}\n\n\tnsems = sma->sem_nsems;\n\tipc_rcu_getref(sma);\n\trcu_read_unlock();\n\n\t\/* step 2: allocate new undo structure *\/\n\tnew = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);\n\tif (!new) {\n\t\tsem_putref(sma);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t\/* step 3: Acquire the lock on semaphore array *\/\n\tsem_lock_and_putref(sma);\n\tif (sma->sem_perm.deleted) {\n\t\tsem_unlock(sma);\n\t\tkfree(new);\n\t\tun = ERR_PTR(-EIDRM);\n\t\tgoto out;\n\t}\n\tspin_lock(&ulp->lock);\n\n\t\/*\n\t * step 4: check for races: did someone else allocate the undo struct?\n\t *\/\n\tun = lookup_undo(ulp, semid);\n\tnew->semid = semid;\n\tassert_spin_locked(&ulp->lock);\n\tlist_add_rcu(&new->list_proc, &ulp->list_proc);\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_add(&new->list_id, &sma->list_id);\n\tun = new;\n\nsuccess:\n\tspin_unlock(&ulp->lock);\n\trcu_read_lock();\n\tsem_unlock(sma);\nout:\n\treturn un;\n}","target":1,"flaw_line_index":0,"hash":"2deb853f-3032-4c80-9901-b7a8d594a0b0","idx":"f99a107a-afbe-45ca-96d5-03061882d458"}
{"func_before":"static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n{\n\tstruct sem_array *sma;\n\tstruct sem_undo_list *ulp;\n\tstruct sem_undo *un, *new;\n\tint nsems, error;\n\n\terror = get_undo_list(&ulp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\trcu_read_lock();\n\tspin_lock(&ulp->lock);\n\tun = lookup_undo(ulp, semid);\n\tspin_unlock(&ulp->lock);\n\tif (likely(un!=NULL))\n\n\t\/* no undo structure around - allocate one. *\/\n\t\/* step 1: figure out the size of the semaphore array *\/\n\tsma = sem_obtain_object_check(ns, semid);\n\tif (IS_ERR(sma)) {\n\t\trcu_read_unlock();\n\t\treturn ERR_CAST(sma);\n\t}\n\n\tnsems = sma->sem_nsems;\n\tif (!ipc_rcu_getref(sma)) {\n\t\trcu_read_unlock();\n\t\tun = ERR_PTR(-EIDRM);\n\t\tgoto out;\n\t}\n\trcu_read_unlock();\n\n\t\/* step 2: allocate new undo structure *\/\n\tnew = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);\n\tif (!new) {\n\t\tsem_putref(sma);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t\/* step 3: Acquire the lock on semaphore array *\/\n\tsem_lock_and_putref(sma);\n\tif (sma->sem_perm.deleted) {\n\t\tsem_unlock(sma, -1);\n\t\tkfree(new);\n\t\tun = ERR_PTR(-EIDRM);\n\t\tgoto out;\n\t}\n\tspin_lock(&ulp->lock);\n\n\t\/*\n\t * step 4: check for races: did someone else allocate the undo struct?\n\t *\/\n\tun = lookup_undo(ulp, semid);\n\tnew->semid = semid;\n\tassert_spin_locked(&ulp->lock);\n\tlist_add_rcu(&new->list_proc, &ulp->list_proc);\n\tassert_spin_locked(&sma->sem_perm.lock);\n\tlist_add(&new->list_id, &sma->list_id);\n\tun = new;\n\nsuccess:\n\tspin_unlock(&ulp->lock);\n\trcu_read_lock();\n\tsem_unlock(sma, -1);\nout:\n\treturn un;\n}","target":0,"flaw_line_index":0,"hash":"d6719153-071b-4bbf-85e8-1f14ad48d692","idx":"864069e7-5fbf-4d0f-a464-267da3b65e22"}
{"func_before":"\n\t\/* Fill in device structure with ethernet-generic values. *\/\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\trandom_ether_addr(dev->dev_addr);\n}","target":1,"flaw_line_index":0,"hash":"dd6dc27e-1e82-438f-a907-1c62255d3fba","idx":"c0d25dc4-b91e-44b1-8243-d5125bb62a25"}
{"func_before":"\n\t\/* Fill in device structure with ethernet-generic values. *\/\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n\trandom_ether_addr(dev->dev_addr);\n}","target":0,"flaw_line_index":0,"hash":"4bdf2550-e348-4b69-9934-60eddaebabba","idx":"a59df541-dec8-4ebb-a4a3-3ff86849b3cd"}
{"func_before":"    {\n      if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->refno != -1)\n      {\n        j++;\n        if (!ctx->quiet)\n          mutt_progress_update(&progress, j, -1);\n        snprintf(buf, sizeof(buf), \"DELE %d\\r\\n\", ctx->hdrs[i]->refno);\n        ret = pop_query(pop_data, buf, sizeof(buf));\n        if (ret == 0)\n        {\n          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);\n#ifdef USE_HCACHE\n          mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n#endif\n        }\n      }\n\n#ifdef USE_HCACHE\n      if (ctx->hdrs[i]->changed)\n      {\n        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),","target":1,"flaw_line_index":0,"hash":"185457cb-5421-4241-a274-0170296351ad","idx":"1010cf15-fe93-47e1-a0e9-e97afdf8bf98"}
{"func_before":"    {\n      if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->refno != -1)\n      {\n        j++;\n        if (!ctx->quiet)\n          mutt_progress_update(&progress, j, -1);\n        snprintf(buf, sizeof(buf), \"DELE %d\\r\\n\", ctx->hdrs[i]->refno);\n        ret = pop_query(pop_data, buf, sizeof(buf));\n        if (ret == 0)\n        {\n          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));\n#ifdef USE_HCACHE\n          mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n#endif\n        }\n      }\n\n#ifdef USE_HCACHE\n      if (ctx->hdrs[i]->changed)\n      {\n        mutt_hcache_store(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data),","target":0,"flaw_line_index":0,"hash":"9b48564f-d6e6-414f-bf61-3276039f1249","idx":"fa61d695-fc9e-4196-a71a-4b00d7836516"}
{"func_before":"static char *dex_resolve_library(const char *library) {\n\tif (!library || library[0] != 'L') {\n\t\treturn NULL;\n\t}\n\tchar *demangled = strdup(library + 1);\n\trz_str_replace_ch(demangled, '\/', '.', 1);\n\tdemangled[strlen(demangled) - 1] = 0;\n\treturn demangled;\n}","target":1,"flaw_line_index":0,"hash":"9e0e8b38-112c-475b-8e8c-22add177b151","idx":"d0dbbb87-977b-47f0-a034-baa0f5b794c2"}
{"func_before":"static char *dex_resolve_library(const char *library) {\n\tif (!library || library[0] != 'L') {\n\t\treturn NULL;\n\t}\n\tchar *demangled = strdup(library + 1);\n\trz_str_replace_ch(demangled, '\/', '.', 1);\n\tif (RZ_STR_ISNOTEMPTY(demangled)) {\n\t\tdemangled[strlen(demangled) - 1] = 0;\n\t}\n\treturn demangled;\n}","target":0,"flaw_line_index":0,"hash":"6af534d2-507d-424c-b187-372c291abf11","idx":"9738aaf5-61e0-4bd5-b7a2-b5b5e34e34a6"}
{"func_before":"    }\n  }\n\n  int original_rank = dense_shape_.size();\n  int block_dim = 0;\n\n  blocked_shape_.resize(original_rank);\n  block_size_.resize(block_map_.size());\n  for (int i = 0; i < original_rank; i++) {\n    if (block_dim < block_map_.size() && block_map_[block_dim] == i) {\n      int orig_dim = traversal_order_[original_rank + block_dim];\n      block_size_[block_dim] = dense_size[orig_dim];\n      blocked_shape_[i] = dense_shape_[i] \/ dense_size[orig_dim];\n      block_dim++;\n    } else {\n      blocked_shape_[i] = dense_shape_[i];\n    }\n  }\n}","target":1,"flaw_line_index":0,"hash":"fcb1514d-099a-4f33-adaa-41e027fe8d98","idx":"85205407-727a-4900-8298-6edaf2d479c9"}
{"func_before":"    }\n  }\n\n  int original_rank = dense_shape_.size();\n  int block_dim = 0;\n\n  blocked_shape_.resize(original_rank);\n  block_size_.resize(block_map_.size());\n  for (int i = 0; i < original_rank; i++) {\n    if (block_dim < block_map_.size() && block_map_[block_dim] == i) {\n      if (original_rank + block_dim < traversal_order_.size()) {\n        int orig_dim = traversal_order_[original_rank + block_dim];\n        block_size_[block_dim] = dense_size[orig_dim];\n        blocked_shape_[i] = dense_shape_[i] \/ dense_size[orig_dim];\n        block_dim++;\n      }\n    } else {\n      blocked_shape_[i] = dense_shape_[i];\n    }\n  }\n}","target":0,"flaw_line_index":0,"hash":"d32c6655-57b6-46c9-8bf1-def23bc16e34","idx":"75267499-1b0e-43dc-b036-973e30a84506"}
{"func_before":"void set_task_blockstep(struct task_struct *task, bool on)\n{\n\tunsigned long debugctl;\n\n\t\/*\n\t * Ensure irq\/preemption can't change debugctl in between.\n\t * Note also that both TIF_BLOCKSTEP and debugctl should\n\t * be changed atomically wrt preemption.\n\t * FIXME: this means that set\/clear TIF_BLOCKSTEP is simply\n\t * wrong if task != current, SIGKILL can wakeup the stopped\n\t * tracee and set\/clear can play with the running task, this\n\t * can confuse the next __switch_to_xtra().\n\t *\/\n\tlocal_irq_disable();\n\tdebugctl = get_debugctlmsr();\n\tif (on) {\n\t\tdebugctl |= DEBUGCTLMSR_BTF;\n\t\tset_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t} else {\n\t\tdebugctl &= ~DEBUGCTLMSR_BTF;\n\t\tclear_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t}","target":1,"flaw_line_index":0,"hash":"383b4c2f-a119-45f9-affa-a77dc981f8b8","idx":"6978a34e-18e3-4795-86f2-288db8cd25b0"}
{"func_before":"void set_task_blockstep(struct task_struct *task, bool on)\n{\n\tunsigned long debugctl;\n\n\t\/*\n\t * Ensure irq\/preemption can't change debugctl in between.\n\t * Note also that both TIF_BLOCKSTEP and debugctl should\n\t * be changed atomically wrt preemption.\n\t *\n\t * NOTE: this means that set\/clear TIF_BLOCKSTEP is only safe if\n\t * task is current or it can't be running, otherwise we can race\n\t * with __switch_to_xtra(). We rely on ptrace_freeze_traced() but\n\t * PTRACE_KILL is not safe.\n\t *\/\n\tlocal_irq_disable();\n\tdebugctl = get_debugctlmsr();\n\tif (on) {\n\t\tdebugctl |= DEBUGCTLMSR_BTF;\n\t\tset_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t} else {\n\t\tdebugctl &= ~DEBUGCTLMSR_BTF;\n\t\tclear_tsk_thread_flag(task, TIF_BLOCKSTEP);\n\t}","target":0,"flaw_line_index":0,"hash":"6fdf59b3-6715-46b0-b94c-a3e3ac6a2ea4","idx":"ec445626-fbc3-4875-aa2f-d98db3355bbb"}
{"func_before":"int WriteRiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)\n{\n    int do_rf64 = 0, write_junk = 1;\n    ChunkHeader ds64hdr, datahdr, fmthdr;\n    RiffChunkHeader riffhdr;\n    DS64Chunk ds64_chunk;\n    JunkChunk junkchunk;\n    WaveHeader wavhdr;\n    uint32_t bcount;\n\n    int64_t total_data_bytes, total_riff_bytes;\n    int num_channels = WavpackGetNumChannels (wpc);\n    int32_t channel_mask = WavpackGetChannelMask (wpc);\n    int32_t sample_rate = WavpackGetSampleRate (wpc);\n    int bytes_per_sample = WavpackGetBytesPerSample (wpc);\n    int bits_per_sample = WavpackGetBitsPerSample (wpc);\n        wavhdr.GUID [6] = 0x80;\n        wavhdr.GUID [9] = 0xaa;\n        wavhdr.GUID [11] = 0x38;\n        wavhdr.GUID [12] = 0x9b;\n        wavhdr.GUID [13] = 0x71;\n    }\n\n    strncpy (riffhdr.ckID, do_rf64 ? \"RF64\" : \"RIFF\", sizeof (riffhdr.ckID));\n    strncpy (riffhdr.formType, \"WAVE\", sizeof (riffhdr.formType));\n    total_riff_bytes = sizeof (riffhdr) + wavhdrsize + sizeof (datahdr) + ((total_data_bytes + 1) & ~(int64_t)1);\n    if (do_rf64) total_riff_bytes += sizeof (ds64hdr) + sizeof (ds64_chunk);\n    if (write_junk) total_riff_bytes += sizeof (junkchunk);\n    strncpy (fmthdr.ckID, \"fmt \", sizeof (fmthdr.ckID));\n    strncpy (datahdr.ckID, \"data\", sizeof (datahdr.ckID));\n    fmthdr.ckSize = wavhdrsize;\n\n    if (write_junk) {\n        CLEAR (junkchunk);\n        strncpy (junkchunk.ckID, \"junk\", sizeof (junkchunk.ckID));\n        junkchunk.ckSize = sizeof (junkchunk) - 8;\n        WavpackNativeToLittleEndian (&junkchunk, ChunkHeaderFormat);\n    }\n\n    if (do_rf64) {\n        strncpy (ds64hdr.ckID, \"ds64\", sizeof (ds64hdr.ckID));\n        ds64hdr.ckSize = sizeof (ds64_chunk);\n        CLEAR (ds64_chunk);\n        ds64_chunk.riffSize64 = total_riff_bytes;\n        ds64_chunk.dataSize64 = total_data_bytes;\n        ds64_chunk.sampleCount64 = total_samples;\n        riffhdr.ckSize = (uint32_t) -1;\n        datahdr.ckSize = (uint32_t) -1;\n        WavpackNativeToLittleEndian (&ds64hdr, ChunkHeaderFormat);\n        WavpackNativeToLittleEndian (&ds64_chunk, DS64ChunkFormat);\n    }\n    else {\n        riffhdr.ckSize = (uint32_t) total_riff_bytes;\n        datahdr.ckSize = (uint32_t) total_data_bytes;\n    }\n\n    \/\/ write the RIFF chunks up to just before the data starts\n\n    WavpackNativeToLittleEndian (&riffhdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&fmthdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&wavhdr, WaveHeaderFormat);\n    WavpackNativeToLittleEndian (&datahdr, ChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &riffhdr, sizeof (riffhdr), &bcount) || bcount != sizeof (riffhdr) ||\n        (do_rf64 && (!DoWriteFile (outfile, &ds64hdr, sizeof (ds64hdr), &bcount) || bcount != sizeof (ds64hdr))) ||\n        (do_rf64 && (!DoWriteFile (outfile, &ds64_chunk, sizeof (ds64_chunk), &bcount) || bcount != sizeof (ds64_chunk))) ||\n        (write_junk && (!DoWriteFile (outfile, &junkchunk, sizeof (junkchunk), &bcount) || bcount != sizeof (junkchunk))) ||\n        !DoWriteFile (outfile, &fmthdr, sizeof (fmthdr), &bcount) || bcount != sizeof (fmthdr) ||\n        !DoWriteFile (outfile, &wavhdr, wavhdrsize, &bcount) || bcount != wavhdrsize ||\n        !DoWriteFile (outfile, &datahdr, sizeof (datahdr), &bcount) || bcount != sizeof (datahdr)) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n    }\n\n    return TRUE;\n}","target":1,"flaw_line_index":0,"hash":"bb72639c-f3f5-47d6-89b3-0a0cec27f142","idx":"ef662563-1463-4d36-8109-41906d1fff3c"}
{"func_before":"int WriteRiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)\n{\n    int do_rf64 = 0, write_junk = 1, table_length = 0;\n    ChunkHeader ds64hdr, datahdr, fmthdr;\n    RiffChunkHeader riffhdr;\n    DS64Chunk ds64_chunk;\n    CS64Chunk cs64_chunk;\n    JunkChunk junkchunk;\n    WaveHeader wavhdr;\n    uint32_t bcount;\n\n    int64_t total_data_bytes, total_riff_bytes;\n    int num_channels = WavpackGetNumChannels (wpc);\n    int32_t channel_mask = WavpackGetChannelMask (wpc);\n    int32_t sample_rate = WavpackGetSampleRate (wpc);\n    int bytes_per_sample = WavpackGetBytesPerSample (wpc);\n    int bits_per_sample = WavpackGetBitsPerSample (wpc);\n        wavhdr.GUID [9] = 0xaa;\n        wavhdr.GUID [11] = 0x38;\n        wavhdr.GUID [12] = 0x9b;\n        wavhdr.GUID [13] = 0x71;\n    }\n\n    strncpy (riffhdr.ckID, do_rf64 ? \"RF64\" : \"RIFF\", sizeof (riffhdr.ckID));\n    strncpy (riffhdr.formType, \"WAVE\", sizeof (riffhdr.formType));\n    total_riff_bytes = sizeof (riffhdr) + wavhdrsize + sizeof (datahdr) + ((total_data_bytes + 1) & ~(int64_t)1);\n    if (do_rf64) total_riff_bytes += sizeof (ds64hdr) + sizeof (ds64_chunk);\n    total_riff_bytes += table_length * sizeof (CS64Chunk);\n    if (write_junk) total_riff_bytes += sizeof (junkchunk);\n    strncpy (fmthdr.ckID, \"fmt \", sizeof (fmthdr.ckID));\n    strncpy (datahdr.ckID, \"data\", sizeof (datahdr.ckID));\n    fmthdr.ckSize = wavhdrsize;\n\n    if (write_junk) {\n        CLEAR (junkchunk);\n        strncpy (junkchunk.ckID, \"junk\", sizeof (junkchunk.ckID));\n        junkchunk.ckSize = sizeof (junkchunk) - 8;\n        WavpackNativeToLittleEndian (&junkchunk, ChunkHeaderFormat);\n    }\n\n    if (do_rf64) {\n        strncpy (ds64hdr.ckID, \"ds64\", sizeof (ds64hdr.ckID));\n        ds64hdr.ckSize = sizeof (ds64_chunk) + (table_length * sizeof (CS64Chunk));\n        CLEAR (ds64_chunk);\n        ds64_chunk.riffSize64 = total_riff_bytes;\n        ds64_chunk.dataSize64 = total_data_bytes;\n        ds64_chunk.sampleCount64 = total_samples;\n        ds64_chunk.tableLength = table_length;\n        riffhdr.ckSize = (uint32_t) -1;\n        datahdr.ckSize = (uint32_t) -1;\n        WavpackNativeToLittleEndian (&ds64hdr, ChunkHeaderFormat);\n        WavpackNativeToLittleEndian (&ds64_chunk, DS64ChunkFormat);\n    }\n    else {\n        riffhdr.ckSize = (uint32_t) total_riff_bytes;\n        datahdr.ckSize = (uint32_t) total_data_bytes;\n    }\n\n    \/\/ this \"table\" is just a dummy placeholder for testing (normally not written)\n\n    if (table_length) {\n        strncpy (cs64_chunk.ckID, \"dmmy\", sizeof (cs64_chunk.ckID));\n        cs64_chunk.chunkSize64 = 12345678;\n        WavpackNativeToLittleEndian (&cs64_chunk, CS64ChunkFormat);\n    }\n\n    \/\/ write the RIFF chunks up to just before the data starts\n\n    WavpackNativeToLittleEndian (&riffhdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&fmthdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&wavhdr, WaveHeaderFormat);\n    WavpackNativeToLittleEndian (&datahdr, ChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &riffhdr, sizeof (riffhdr), &bcount) || bcount != sizeof (riffhdr) ||\n        (do_rf64 && (!DoWriteFile (outfile, &ds64hdr, sizeof (ds64hdr), &bcount) || bcount != sizeof (ds64hdr))) ||\n        (do_rf64 && (!DoWriteFile (outfile, &ds64_chunk, sizeof (ds64_chunk), &bcount) || bcount != sizeof (ds64_chunk)))) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n    }\n\n    \/\/ again, this is normally not written except for testing\n\n    while (table_length--)\n        if (!DoWriteFile (outfile, &cs64_chunk, sizeof (cs64_chunk), &bcount) || bcount != sizeof (cs64_chunk)) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n        }\n\n\n    if ((write_junk && (!DoWriteFile (outfile, &junkchunk, sizeof (junkchunk), &bcount) || bcount != sizeof (junkchunk))) ||\n        !DoWriteFile (outfile, &fmthdr, sizeof (fmthdr), &bcount) || bcount != sizeof (fmthdr) ||\n        !DoWriteFile (outfile, &wavhdr, wavhdrsize, &bcount) || bcount != wavhdrsize ||\n        !DoWriteFile (outfile, &datahdr, sizeof (datahdr), &bcount) || bcount != sizeof (datahdr)) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n    }\n\n    return TRUE;\n}","target":0,"flaw_line_index":0,"hash":"ceb8eb9d-dd58-47af-857f-cb7e84ef5ce8","idx":"2f3d45f4-2fce-4384-ac31-6311e601c316"}
{"func_before":"\t    else if (attr->name == attMAPIPROPS) \n\t    { \n\t\tMAPI_Attr **mapi_attrs \n\t\t    = mapi_attr_read (attr->len, attr->buf); \n\t\tif (mapi_attrs)\n\t\t{ \n\t\t    int i;\n\t\t    for (i = 0; mapi_attrs[i]; i++)\n\t\t    {\n\t\t\tMAPI_Attr *a = mapi_attrs[i];\n\t\t\t    \n\t\t\tif (a->name == MAPI_BODY_HTML)\n\t\t\t{\n\t\t\t    body.html_bodies = get_html_data (a);\n                                html_size = a->num_values;\n\t\t\t}\n\t\t\telse if (a->name == MAPI_RTF_COMPRESSED)\n\t\t\t{\n\t\t\t    body.rtf_bodies = get_rtf_data (a);\n                                rtf_size = a->num_values;\n\t\t\t}\n\t\t    }\n\t\t    \/* cannot save attributes to file, since they\n\t\t     * are not attachment attributes *\/ \n\t\t    \/* file_add_mapi_attrs (file, mapi_attrs); *\/\n\t\t    mapi_attr_free_list (mapi_attrs); \n\t\t    XFREE (mapi_attrs); ","target":1,"flaw_line_index":0,"hash":"280b1f0c-5d52-428a-83dd-34169c67f97a","idx":"c80d9c51-ae0c-4a44-98ea-167c92db165c"}
{"func_before":"\t    else if (attr->name == attMAPIPROPS) \n\t    { \n\t\tMAPI_Attr **mapi_attrs \n\t\t    = mapi_attr_read (attr->len, attr->buf); \n\t\tif (mapi_attrs)\n\t\t{ \n\t\t    int i;\n\t\t    for (i = 0; mapi_attrs[i]; i++)\n\t\t    {\n\t\t\tMAPI_Attr *a = mapi_attrs[i];\n\t\t\n\t\t\tif (a->type == szMAPI_BINARY && a->name == MAPI_BODY_HTML)\n\t\t\t{\n\t\t\t    body.html_bodies = get_html_data (a);\n                                html_size = a->num_values;\n\t\t\t}\n\t\t\telse if (a->type == szMAPI_BINARY && a->name == MAPI_RTF_COMPRESSED)\n\t\t\t{\n\t\t\t    body.rtf_bodies = get_rtf_data (a);\n                                rtf_size = a->num_values;\n\t\t\t}\n\t\t    }\n\t\t    \/* cannot save attributes to file, since they\n\t\t     * are not attachment attributes *\/ \n\t\t    \/* file_add_mapi_attrs (file, mapi_attrs); *\/\n\t\t    mapi_attr_free_list (mapi_attrs); \n\t\t    XFREE (mapi_attrs); ","target":0,"flaw_line_index":0,"hash":"d5489ec0-3f21-4ff2-beb8-525871558786","idx":"a10b227a-bfb1-47e0-bdbc-c0b7a858d9ba"}
{"func_before":"    usize alc_max; \/* maximum value count for allocator *\/\n    usize ctn_len; \/* the number of elements in current container *\/\n    yyjson_val *val_hdr; \/* the head of allocated values *\/\n    yyjson_val *val_end; \/* the end of allocated values *\/\n    yyjson_val *val_tmp; \/* temporary pointer for realloc *\/\n    yyjson_val *val; \/* current JSON value *\/\n    yyjson_val *ctn; \/* current container *\/\n    yyjson_val *ctn_parent; \/* parent of current container *\/\n    yyjson_doc *doc; \/* the JSON document, equals to val_hdr *\/\n    const char *msg; \/* error message *\/\n    \n    bool raw; \/* read number as raw *\/\n    bool inv; \/* allow invalid unicode *\/\n    u8 *raw_end; \/* raw end for null-terminator *\/\n    u8 **pre; \/* previous raw end pointer *\/\n    \n    dat_len = has_read_flag(STOP_WHEN_DONE) ? 256 : (usize)(end - cur);\n    hdr_len = sizeof(yyjson_doc) \/ sizeof(yyjson_val);\n    hdr_len += (sizeof(yyjson_doc) % sizeof(yyjson_val)) > 0;\n    alc_max = USIZE_MAX \/ sizeof(yyjson_val);\n    alc_len = hdr_len + (dat_len \/ YYJSON_READER_ESTIMATED_MINIFY_RATIO) + 4;\n    if (*cur++ == '{') {\n        ctn->tag = YYJSON_TYPE_OBJ;\n        ctn->uni.ofs = 0;\n        goto obj_key_begin;\n    } else {\n        ctn->tag = YYJSON_TYPE_ARR;\n        ctn->uni.ofs = 0;\n        goto arr_val_begin;\n    }\n    \narr_begin:\n    \/* save current container *\/\n    ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n               (ctn->tag & YYJSON_TAG_MASK);\n    \n    \/* create a new array value, save parent container offset *\/\n    val_incr();\n    val->tag = YYJSON_TYPE_ARR;\n    val->uni.ofs = (usize)((u8 *)val - (u8 *)ctn);\n    \n    \/* push the new array value as current container *\/\n    if (char_is_space(*cur)) {\n        while (char_is_space(*++cur));\n        goto arr_val_end;\n    }\n    if (has_read_flag(ALLOW_COMMENTS)) {\n        if (skip_spaces_and_comments(&cur)) goto arr_val_end;\n        if (byte_match_2(cur, \"\/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \narr_end:\n    \/* get parent container *\/\n    ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n    \n    \/* save the next sibling value offset *\/\n    ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n    ctn->tag = ((ctn_len) << YYJSON_TAG_BIT) | YYJSON_TYPE_ARR;\n    if (unlikely(ctn == ctn_parent)) goto doc_end;\n    \n    \/* pop parent as current container *\/\n    ctn = ctn_parent;\n    ctn_len = (usize)(ctn->tag >> YYJSON_TAG_BIT);\n    if ((ctn->tag & YYJSON_TYPE_MASK) == YYJSON_TYPE_OBJ) {\n        goto obj_val_end;\n    } else {\n        goto arr_val_end;\n    }\n    \nobj_begin:\n    \/* push container *\/\n    ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n               (ctn->tag & YYJSON_TAG_MASK);\n    val_incr();\n    val->tag = YYJSON_TYPE_OBJ;\n    \/* offset to the parent *\/\n    val->uni.ofs = (usize)((u8 *)val - (u8 *)ctn);\n    ctn = val;\n    ctn_len = 0;\n    \n    if (char_is_space(*cur)) {\n        while (char_is_space(*++cur));\n        goto obj_val_end;\n    }\n    if (has_read_flag(ALLOW_COMMENTS)) {\n        if (skip_spaces_and_comments(&cur)) goto obj_val_end;\n        if (byte_match_2(cur, \"\/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \nobj_end:\n    \/* pop container *\/\n    ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n    \/* point to the next value *\/\n    ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n    ctn->tag = (ctn_len << (YYJSON_TAG_BIT - 1)) | YYJSON_TYPE_OBJ;\n    if (unlikely(ctn == ctn_parent)) goto doc_end;\n    ctn = ctn_parent;\n    ctn_len = (usize)(ctn->tag >> YYJSON_TAG_BIT);\n    if ((ctn->tag & YYJSON_TYPE_MASK) == YYJSON_TYPE_OBJ) {\n        goto obj_val_end;\n    return_err(cur, MEMORY_ALLOCATION, \"memory allocation failed\");\nfail_trailing_comma:\n    return_err(cur, JSON_STRUCTURE, \"trailing comma is not allowed\");\nfail_literal:\n    return_err(cur, LITERAL, \"invalid literal\");\nfail_comment:\n    return_err(cur, INVALID_COMMENT, \"unclosed multiline comment\");\nfail_character:\n    return_err(cur, UNEXPECTED_CHARACTER, \"unexpected character\");\nfail_garbage:\n    return_err(cur, UNEXPECTED_CONTENT, \"unexpected content after document\");\n    \n#undef val_incr\n#undef return_err\n}","target":1,"flaw_line_index":0,"hash":"6f0b164f-9658-4d60-92d6-f6466410c5d0","idx":"60a3fe7f-4e6c-46ac-8c98-d5f9f7e99660"}
{"func_before":"    usize alc_max; \/* maximum value count for allocator *\/\n    usize ctn_len; \/* the number of elements in current container *\/\n    yyjson_val *val_hdr; \/* the head of allocated values *\/\n    yyjson_val *val_end; \/* the end of allocated values *\/\n    yyjson_val *val_tmp; \/* temporary pointer for realloc *\/\n    yyjson_val *val; \/* current JSON value *\/\n    yyjson_val *ctn; \/* current container *\/\n    yyjson_val *ctn_parent; \/* parent of current container *\/\n    yyjson_doc *doc; \/* the JSON document, equals to val_hdr *\/\n    const char *msg; \/* error message *\/\n\n    u32 container_depth = 0; \/* limit on number of open array and map *\/\n    bool raw; \/* read number as raw *\/\n    bool inv; \/* allow invalid unicode *\/\n    u8 *raw_end; \/* raw end for null-terminator *\/\n    u8 **pre; \/* previous raw end pointer *\/\n    \n    dat_len = has_read_flag(STOP_WHEN_DONE) ? 256 : (usize)(end - cur);\n    hdr_len = sizeof(yyjson_doc) \/ sizeof(yyjson_val);\n    hdr_len += (sizeof(yyjson_doc) % sizeof(yyjson_val)) > 0;\n    alc_max = USIZE_MAX \/ sizeof(yyjson_val);\n    alc_len = hdr_len + (dat_len \/ YYJSON_READER_ESTIMATED_MINIFY_RATIO) + 4;\n        ctn->tag = YYJSON_TYPE_OBJ;\n        ctn->uni.ofs = 0;\n        goto obj_key_begin;\n    } else {\n        ctn->tag = YYJSON_TYPE_ARR;\n        ctn->uni.ofs = 0;\n        goto arr_val_begin;\n    }\n    \narr_begin:\n    container_depth++;\n    if (unlikely(container_depth >= YYJSON_READER_CONTAINER_RECURSION_LIMIT)) {\n        goto fail_recursion;\n    }\n\n    \/* save current container *\/\n    ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n               (ctn->tag & YYJSON_TAG_MASK);\n    \n    \/* create a new array value, save parent container offset *\/\n    val_incr();\n    val->tag = YYJSON_TYPE_ARR;\n    val->uni.ofs = (usize)((u8 *)val - (u8 *)ctn);\n    \n    \/* push the new array value as current container *\/\n        while (char_is_space(*++cur));\n        goto arr_val_end;\n    }\n    if (has_read_flag(ALLOW_COMMENTS)) {\n        if (skip_spaces_and_comments(&cur)) goto arr_val_end;\n        if (byte_match_2(cur, \"\/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \narr_end:\n    container_depth--;\n\n    \/* get parent container *\/\n    ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n    \n    \/* save the next sibling value offset *\/\n    ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n    ctn->tag = ((ctn_len) << YYJSON_TAG_BIT) | YYJSON_TYPE_ARR;\n    if (unlikely(ctn == ctn_parent)) goto doc_end;\n    \n    \/* pop parent as current container *\/\n    ctn = ctn_parent;\n    ctn_len = (usize)(ctn->tag >> YYJSON_TAG_BIT);\n    if ((ctn->tag & YYJSON_TYPE_MASK) == YYJSON_TYPE_OBJ) {\n        goto obj_val_end;\n    } else {\n        goto arr_val_end;\n    }\n    \nobj_begin:\n    container_depth++;\n    if (unlikely(container_depth >= YYJSON_READER_CONTAINER_RECURSION_LIMIT)) {\n        goto fail_recursion;\n    }\n\n    \/* push container *\/\n    ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n               (ctn->tag & YYJSON_TAG_MASK);\n    val_incr();\n    val->tag = YYJSON_TYPE_OBJ;\n    \/* offset to the parent *\/\n    val->uni.ofs = (usize)((u8 *)val - (u8 *)ctn);\n    ctn = val;\n    ctn_len = 0;\n    \n        while (char_is_space(*++cur));\n        goto obj_val_end;\n    }\n    if (has_read_flag(ALLOW_COMMENTS)) {\n        if (skip_spaces_and_comments(&cur)) goto obj_val_end;\n        if (byte_match_2(cur, \"\/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \nobj_end:\n    container_depth--;\n\n    \/* pop container *\/\n    ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n    \/* point to the next value *\/\n    ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n    ctn->tag = (ctn_len << (YYJSON_TAG_BIT - 1)) | YYJSON_TYPE_OBJ;\n    if (unlikely(ctn == ctn_parent)) goto doc_end;\n    ctn = ctn_parent;\n    ctn_len = (usize)(ctn->tag >> YYJSON_TAG_BIT);\n    if ((ctn->tag & YYJSON_TYPE_MASK) == YYJSON_TYPE_OBJ) {\n        goto obj_val_end;\nfail_trailing_comma:\n    return_err(cur, JSON_STRUCTURE, \"trailing comma is not allowed\");\nfail_literal:\n    return_err(cur, LITERAL, \"invalid literal\");\nfail_comment:\n    return_err(cur, INVALID_COMMENT, \"unclosed multiline comment\");\nfail_character:\n    return_err(cur, UNEXPECTED_CHARACTER, \"unexpected character\");\nfail_garbage:\n    return_err(cur, UNEXPECTED_CONTENT, \"unexpected content after document\");\nfail_recursion:\n    return_err(cur, RECURSION_DEPTH, \"array and object recursion depth exceeded\");\n    \n#undef val_incr\n#undef return_err\n}","target":0,"flaw_line_index":0,"hash":"10a4d361-08b7-4216-9ac8-6a84b4166f17","idx":"ddcbb243-6e77-4756-9260-767d78e4a23d"}
{"func_before":"static void rand_gen(uint8_t *out, int out_len) {\n\tint m = RLC_CEIL(out_len, RLC_MD_LEN);\n\tuint8_t hash[RLC_MD_LEN], data[(RLC_RAND_SIZE - 1)\/2];\n\tctx_t *ctx = core_get();\n\n\t\/* data = V *\/\n\tmemcpy(data, ctx->rand + 1, (RLC_RAND_SIZE - 1)\/2);\n\tfor (int i = 0; i < m; i++) {\n\t\t\/* w_i = Hash(data) *\/\n\t\tmd_map(hash, data, sizeof(data));\n\t\t\/* W = W || w_i *\/","target":1,"flaw_line_index":0,"hash":"f4e24ce2-c069-4421-b739-3406e6ee4715","idx":"bb5f161a-3cba-4c30-a04b-28fd927b6f67"}
{"func_before":"static void rand_gen(uint8_t *out, size_t out_len) {\n\tint m = RLC_CEIL(out_len, RLC_MD_LEN);\n\tuint8_t hash[RLC_MD_LEN], data[(RLC_RAND_SIZE - 1)\/2];\n\tctx_t *ctx = core_get();\n\n\t\/* data = V *\/\n\tmemcpy(data, ctx->rand + 1, (RLC_RAND_SIZE - 1)\/2);\n\tfor (int i = 0; i < m; i++) {\n\t\t\/* w_i = Hash(data) *\/\n\t\tmd_map(hash, data, sizeof(data));\n\t\t\/* W = W || w_i *\/","target":0,"flaw_line_index":0,"hash":"aac58759-28af-4c69-a311-d7b1538eb3d9","idx":"bfe6556d-4d28-4b56-b66e-6d9c99c66610"}
{"func_before":"int cg_mkdir(const char *path, mode_t mode)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *path1, *cgdir = NULL, *controller;\n\tconst char *cgroup;\n\tint ret;\n\n\tif (!fc)\n\t\treturn -EIO;\n\n\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath)\n\t\tpath1 = \"\/\";\n\telse\n\t\tpath1 = cgdir;\n\n\tif (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\n\tret = cgfs_create(controller, cgroup, fc->uid, fc->gid);\n\tprintf(\"cgfs_create returned %d for %s %s\\n\", ret, controller, cgroup);\n\nout:\n\tfree(cgdir);\n\treturn ret;\n}","target":1,"flaw_line_index":0,"hash":"a21ce380-4bc5-4ad2-9543-9c42d47eed42","idx":"602b4e8a-f90b-47d6-a7cc-7e5ad2c1f719"}
{"func_before":"int cg_mkdir(const char *path, mode_t mode)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *path1, *cgdir = NULL, *controller, *next = NULL;\n\tconst char *cgroup;\n\tint ret;\n\n\tif (!fc)\n\t\treturn -EIO;\n\n\n\tcontroller = pick_controller_from_path(fc, path);\n\tif (!controller)\n\t\treturn -EINVAL;\n\tcgroup = find_cgroup_in_path(path);\n\tif (!cgroup)\n\t\treturn -EINVAL;\n\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath)\n\t\tpath1 = \"\/\";\n\telse\n\t\tpath1 = cgdir;\n\n\tif (!caller_is_in_ancestor(fc->pid, controller, path1, &next)) {\n\t\tif (fpath && strcmp(next, fpath) == 0)\n\t\t\tret = -EEXIST;\n\t\telse\n\t\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\n\tret = cgfs_create(controller, cgroup, fc->uid, fc->gid);\n\tprintf(\"cgfs_create returned %d for %s %s\\n\", ret, controller, cgroup);\n\nout:\n\tfree(cgdir);\n\tfree(next);\n\treturn ret;\n}","target":0,"flaw_line_index":0,"hash":"c0cdd0ab-e54c-46d0-9f01-b64eaf7b63b6","idx":"c7904723-629f-4195-badd-b4946cfd332d"}
{"func_before":"\t\n\t\/* Populate our address from the given *\/\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t\/* If this is a trunk, update it now *\/\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;","target":1,"flaw_line_index":0,"hash":"92e500c7-fb56-44a6-8ff4-cbfa1c61609c","idx":"8a4e6e5d-116c-4ce6-81fc-7db90b750432"}
{"func_before":"\t\n\t\/* Populate our address from the given *\/\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t\/* If this is a trunk, update it now *\/\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;","target":0,"flaw_line_index":0,"hash":"3fd347fa-dd86-4690-9339-180bf71a5728","idx":"c6df2022-d7cd-481f-b98c-ac292271fbd7"}
{"func_before":"static bool init_ehdr(ELFOBJ *bin) {\n\tut8 e_ident[EI_NIDENT];\n\tut8 ehdr[sizeof (Elf_(Ehdr))] = {0};\n\tint i, len;\n\tif (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) == -1) {\n\t\tR_LOG_ERROR (\"read (magic)\");\n\t\treturn false;\n\t}\n\tsdb_set (bin->kv, \"elf_type.cparse\", \"enum elf_type { ET_NONE=0, ET_REL=1,\"\n\t\t\t\" ET_EXEC=2, ET_DYN=3, ET_CORE=4, ET_LOOS=0xfe00, ET_HIOS=0xfeff,\"\n\t\t\t\" ET_LOPROC=0xff00, ET_HIPROC=0xffff };\", 0);\n\tsdb_set (bin->kv, \"elf_machine.cparse\", \"enum elf_machine {EM_NONE=0, EM_M32=1,\"\n\t\t\t\" EM_SPARC=2, EM_386=3, EM_68K=4, EM_88K=5, EM_IAMCU=6, EM_860=7, EM_MIPS=8,\"\n\t\t\t\" EM_S370=9, EM_MIPS_RS3_LE=10, EM_RS6000=11, EM_PARISC=15, EM_nCUBE=16,\"\n\t\t\t\" EM_VPP500=17, EM_SPARC32PLUS=18, EM_960=19, EM_PPC=20, EM_PPC64=21, EM_S390=22,\"\n\t\t\t\" EM_SPU=23, EM_V800=36, EM_FR20=37, EM_RH32=38, EM_RCE=39, EM_ARM=40,\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_header.format\", \"?[2]E[2]E[4]ExxxxN2N2N2N2N2N2\"\n\t\t\t\" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#endif\n\tbin->endian = (e_ident[EI_DATA] == ELFDATA2MSB)? 1: 0;\n\tmemset (&bin->ehdr, 0, sizeof (Elf_(Ehdr)));\n\tlen = r_buf_read_at (bin->b, 0, ehdr, sizeof (ehdr));\n\tif (len < 32) { \/\/ tinyelf != sizeof (Elf_(Ehdr))) {\n\t\tR_LOG_ERROR (\"read (ehdr)\");\n\t\treturn false;\n\t}\n\t\/\/ XXX no need to check twice\n\tmemcpy (&bin->ehdr.e_ident, ehdr, 16);\n\tif (!__is_valid_ident (bin)) {\n\t\treturn false;\n\t}\n\ti = 16;\n\t\/\/ TODO: use r_read or r_buf_read_ apis instead\n\tbin->ehdr.e_type = READ16 (ehdr, i);","target":1,"flaw_line_index":0,"hash":"67c4dc9a-1fbf-4dba-86e0-5c60eff02dbc","idx":"99ed7656-561f-41aa-b485-16889088afce"}
{"func_before":"static bool init_ehdr(ELFOBJ *bin) {\n\tut8 e_ident[EI_NIDENT];\n\tut8 ehdr[sizeof (Elf_(Ehdr))] = {0};\n\tint i, len;\n\tif (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) == -1) {\n\t\tR_LOG_DEBUG (\"read (magic)\");\n\t\treturn false;\n\t}\n\tsdb_set (bin->kv, \"elf_type.cparse\", \"enum elf_type { ET_NONE=0, ET_REL=1,\"\n\t\t\t\" ET_EXEC=2, ET_DYN=3, ET_CORE=4, ET_LOOS=0xfe00, ET_HIOS=0xfeff,\"\n\t\t\t\" ET_LOPROC=0xff00, ET_HIPROC=0xffff };\", 0);\n\tsdb_set (bin->kv, \"elf_machine.cparse\", \"enum elf_machine {EM_NONE=0, EM_M32=1,\"\n\t\t\t\" EM_SPARC=2, EM_386=3, EM_68K=4, EM_88K=5, EM_IAMCU=6, EM_860=7, EM_MIPS=8,\"\n\t\t\t\" EM_S370=9, EM_MIPS_RS3_LE=10, EM_RS6000=11, EM_PARISC=15, EM_nCUBE=16,\"\n\t\t\t\" EM_VPP500=17, EM_SPARC32PLUS=18, EM_960=19, EM_PPC=20, EM_PPC64=21, EM_S390=22,\"\n\t\t\t\" EM_SPU=23, EM_V800=36, EM_FR20=37, EM_RH32=38, EM_RCE=39, EM_ARM=40,\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#else\n\tsdb_set (bin->kv, \"elf_header.format\", \"?[2]E[2]E[4]ExxxxN2N2N2N2N2N2\"\n\t\t\t\" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version\"\n\t\t\t\" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx\", 0);\n#endif\n\tbin->endian = (e_ident[EI_DATA] == ELFDATA2MSB)? 1: 0;\n\tmemset (&bin->ehdr, 0, sizeof (Elf_(Ehdr)));\n\tlen = r_buf_read_at (bin->b, 0, ehdr, sizeof (ehdr));\n\tif (len < 32) { \/\/ tinyelf != sizeof (Elf_(Ehdr))) {\n\t\tR_LOG_DEBUG (\"read (ehdr)\");\n\t\treturn false;\n\t}\n\t\/\/ XXX no need to check twice\n\tmemcpy (&bin->ehdr.e_ident, ehdr, 16);\n\tif (!__is_valid_ident (bin)) {\n\t\treturn false;\n\t}\n\ti = 16;\n\t\/\/ TODO: use r_read or r_buf_read_ apis instead\n\tbin->ehdr.e_type = READ16 (ehdr, i);","target":0,"flaw_line_index":0,"hash":"94833fe9-96c5-4af7-a58d-aaba1c0366aa","idx":"b2ee75ba-3516-4ec1-825d-f3a5c1e78172"}
{"func_before":"\nnext_tag:\n\tif (unlikely(datalen - dp < 2)) {\n\t\tif (datalen == dp)\n\t\t\tgoto missing_eoc;\n\t\tgoto data_overrun_error;\n\t}\n\n\t\/* Extract a tag from the data *\/\n\ttag = data[dp++];\n\tif (tag == 0) {\n\t\t\/* It appears to be an EOC. *\/\n\t\tif (data[dp++] != 0)\n\t\t\tgoto invalid_eoc;\n\t\tif (--indef_level <= 0) {\n\t\t\t*_len = dp - *_dp;\n\t\t\t*_dp = dp;\n\t\t\treturn 0;\n\t\t}\n\t\tgoto next_tag;\n\t}\n\tif (unlikely((tag & 0x1f) == ASN1_LONG_TAG)) {\n\t\tdo {\n\t\t\tif (unlikely(datalen - dp < 2))\n\t\t\t\tgoto data_overrun_error;\n\t\t\ttmp = data[dp++];\n\t\t} while (tmp & 0x80);\n\t}\n\n\t\/* Extract the length *\/\n\tlen = data[dp++];\n\tif (len <= 0x7f) {\n\t\tdp += len;\n\t\tgoto next_tag;\n\t}\n\n\tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\t\/* Indefinite length *\/\n\t\tif (unlikely((tag & ASN1_CONS_BIT) == ASN1_PRIM << 5))\n\t\t\tgoto indefinite_len_primitive;\n\t\tindef_level++;\n\t\tgoto next_tag;\n\t}\n\n\tn = len - 0x80;\n\tif (unlikely(n > sizeof(size_t) - 1))\n\t\tgoto length_too_long;\n\tif (unlikely(n > datalen - dp))\n\t\tgoto data_overrun_error;\n\tfor (len = 0; n > 0; n--) {\n\t\tlen <<= 8;\n\t\tlen |= data[dp++];\n\t}\n\tdp += len;\n\tgoto next_tag;\n\nlength_too_long:\n\t*_errmsg = \"Unsupported length\";\n\tgoto error;\nindefinite_len_primitive:\n\t*_errmsg = \"Indefinite len primitive not permitted\";\n\tgoto error;\ninvalid_eoc:","target":1,"flaw_line_index":0,"hash":"87cb280b-c29e-404a-8da5-feca0e1eb2e5","idx":"2f7c89a0-b733-442b-be5e-3f4be2fdf23f"}
{"func_before":"\nnext_tag:\n\tif (unlikely(datalen - dp < 2)) {\n\t\tif (datalen == dp)\n\t\t\tgoto missing_eoc;\n\t\tgoto data_overrun_error;\n\t}\n\n\t\/* Extract a tag from the data *\/\n\ttag = data[dp++];\n\tif (tag == ASN1_EOC) {\n\t\t\/* It appears to be an EOC. *\/\n\t\tif (data[dp++] != 0)\n\t\t\tgoto invalid_eoc;\n\t\tif (--indef_level <= 0) {\n\t\t\t*_len = dp - *_dp;\n\t\t\t*_dp = dp;\n\t\t\treturn 0;\n\t\t}\n\t\tgoto next_tag;\n\t}\n\tif (unlikely((tag & 0x1f) == ASN1_LONG_TAG)) {\n\t\tdo {\n\t\t\tif (unlikely(datalen - dp < 2))\n\t\t\t\tgoto data_overrun_error;\n\t\t\ttmp = data[dp++];\n\t\t} while (tmp & 0x80);\n\t}\n\n\t\/* Extract the length *\/\n\tlen = data[dp++];\n\tif (len <= 0x7f)\n\t\tgoto check_length;\n\n\tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\t\/* Indefinite length *\/\n\t\tif (unlikely((tag & ASN1_CONS_BIT) == ASN1_PRIM << 5))\n\t\t\tgoto indefinite_len_primitive;\n\t\tindef_level++;\n\t\tgoto next_tag;\n\t}\n\n\tn = len - 0x80;\n\tif (unlikely(n > sizeof(len) - 1))\n\t\tgoto length_too_long;\n\tif (unlikely(n > datalen - dp))\n\t\tgoto data_overrun_error;\n\tlen = 0;\n\tfor (; n > 0; n--) {\n\t\tlen <<= 8;\n\t\tlen |= data[dp++];\n\t}\ncheck_length:\n\tif (len > datalen - dp)\n\t\tgoto data_overrun_error;\n\tdp += len;\n\tgoto next_tag;\n\nlength_too_long:\n\t*_errmsg = \"Unsupported length\";\n\tgoto error;\nindefinite_len_primitive:\n\t*_errmsg = \"Indefinite len primitive not permitted\";\n\tgoto error;\ninvalid_eoc:","target":0,"flaw_line_index":0,"hash":"ce3d6ff2-6ad0-4adf-97ff-4605f3d549a3","idx":"3e90f80e-3eaf-4cab-a113-c940cabd052b"}
{"func_before":"void fp12_exp_dig(fp12_t c, const fp12_t a, dig_t b) {\n\tbn_t _b;\n\tfp12_t t, v;\n\tint8_t u, naf[RLC_DIG + 1];\n\tint l;\n\n\tif (b == 0) {\n\t\tfp12_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(_b);\n\tfp12_null(t);\n\tfp12_null(v);\n","target":1,"flaw_line_index":0,"hash":"a8ae0ed9-0dc7-423f-a8f0-5ab58b9377e2","idx":"115b5032-2666-48b9-9986-4ce05ee3deb5"}
{"func_before":"void fp12_exp_dig(fp12_t c, const fp12_t a, dig_t b) {\n\tbn_t _b;\n\tfp12_t t, v;\n\tint8_t u, naf[RLC_DIG + 1];\n\tsize_t l;\n\n\tif (b == 0) {\n\t\tfp12_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(_b);\n\tfp12_null(t);\n\tfp12_null(v);\n","target":0,"flaw_line_index":0,"hash":"64427e20-3f44-40db-819a-b43ad801da39","idx":"4d4b197e-5088-4b04-af64-e49fc487169d"}
{"func_before":"\t        ip_print(ndo, p, length);\n\t\tbreak;\n\n\tcase NLPID_IP6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\n\tcase NLPID_CLNP:\n\tcase NLPID_ESIS:\n\tcase NLPID_ISIS:\n\t\tisoclns_print(ndo, p - 1, length + 1, ndo->ndo_snapend - p + 1); \/* OSI printers need the NLPID field *\/\n\t\tbreak;\n\n\tcase NLPID_SNAP:\n\t\tif (snap_print(ndo, p, length, ndo->ndo_snapend - p, NULL, NULL, 0) == 0) {\n\t\t\t\/* ether_type not known, print raw packet *\/\n                        if (!ndo->ndo_eflag)\n                            fr_hdr_print(ndo, length + hdr_len, hdr_len,\n                                         dlci, flags, nlpid);\n\t\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\t\tND_DEFAULTPRINT(p - hdr_len, length + hdr_len);","target":1,"flaw_line_index":0,"hash":"7ca4b98b-9bf3-486e-a8da-ed17fbaaa202","idx":"855f5426-318a-4b4d-8041-f2d4c1eba847"}
{"func_before":"\t        ip_print(ndo, p, length);\n\t\tbreak;\n\n\tcase NLPID_IP6:\n\t\tip6_print(ndo, p, length);\n\t\tbreak;\n\n\tcase NLPID_CLNP:\n\tcase NLPID_ESIS:\n\tcase NLPID_ISIS:\n\t\tisoclns_print(ndo, p - 1, length + 1); \/* OSI printers need the NLPID field *\/\n\t\tbreak;\n\n\tcase NLPID_SNAP:\n\t\tif (snap_print(ndo, p, length, ndo->ndo_snapend - p, NULL, NULL, 0) == 0) {\n\t\t\t\/* ether_type not known, print raw packet *\/\n                        if (!ndo->ndo_eflag)\n                            fr_hdr_print(ndo, length + hdr_len, hdr_len,\n                                         dlci, flags, nlpid);\n\t\t\tif (!ndo->ndo_suppress_default_print)\n\t\t\t\tND_DEFAULTPRINT(p - hdr_len, length + hdr_len);","target":0,"flaw_line_index":0,"hash":"223d5b8f-b1ed-4c2c-9f13-07743e3079c0","idx":"595b5ab6-a5f8-4e68-8bca-d58ee5a4ea43"}
{"func_before":"context_parse_args (FlatpakContext *context,\n                    ...)\n{\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GOptionContext) oc = NULL;\n  g_autoptr(GOptionGroup) group = NULL;\n  g_autoptr(GPtrArray) args = g_ptr_array_new_with_free_func (g_free);\n  g_auto(GStrv) argv = NULL;\n  const char *arg;\n  va_list ap;\n\n  g_ptr_array_add (args, g_strdup (\"argv[0]\"));\n\n  va_start (ap, context);\n\n  while ((arg = va_arg (ap, const char *)) != NULL)\n    g_ptr_array_add (args, g_strdup (arg));\n\n  va_end (ap);\n\n  g_ptr_array_add (args, NULL);\n  argv = (GStrv) g_ptr_array_free (g_steal_pointer (&args), FALSE);\n\n  oc = g_option_context_new (\"\");\n  group = flatpak_context_get_options (context);\n  g_option_context_add_group (oc, group);\n  g_option_context_parse_strv (oc, &argv, &local_error);\n  g_assert_no_error (local_error);\n}","target":1,"flaw_line_index":0,"hash":"c1d70380-e472-4c24-9f4e-3e5fde645b43","idx":"582c3bd5-3c8a-4c24-af79-d078230a99dd"}
{"func_before":"context_parse_args (FlatpakContext *context,\n                    GError        **error,\n                    ...)\n{\n  g_autoptr(GOptionContext) oc = NULL;\n  g_autoptr(GOptionGroup) group = NULL;\n  g_autoptr(GPtrArray) args = g_ptr_array_new_with_free_func (g_free);\n  g_auto(GStrv) argv = NULL;\n  const char *arg;\n  va_list ap;\n\n  g_ptr_array_add (args, g_strdup (\"argv[0]\"));\n\n  va_start (ap, error);\n\n  while ((arg = va_arg (ap, const char *)) != NULL)\n    g_ptr_array_add (args, g_strdup (arg));\n\n  va_end (ap);\n\n  g_ptr_array_add (args, NULL);\n  argv = (GStrv) g_ptr_array_free (g_steal_pointer (&args), FALSE);\n\n  oc = g_option_context_new (\"\");\n  group = flatpak_context_get_options (context);\n  g_option_context_add_group (oc, group);\n  g_option_context_parse_strv (oc, &argv, error);\n}","target":0,"flaw_line_index":0,"hash":"3d511d2f-c3a4-430e-b6d1-8f542370efbc","idx":"24e94966-7dac-48a4-a07f-9d86439bc552"}
{"func_before":"  if (! pool->blocks) {\n    if (! poolGrow(pool))\n      return XML_ERROR_NO_MEMORY;\n  }\n\n  for (;;) {\n    const char *next\n        = entityTextPtr; \/* XmlEntityValueTok doesn't always set the last arg *\/\n    int tok = XmlEntityValueTok(enc, entityTextPtr, entityTextEnd, &next);\n\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, entityTextPtr, next, __LINE__,\n                                  account)) {\n      accountingOnAbort(parser);\n      result = XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      goto endEntityValue;\n    }\n#endif\n\n    switch (tok) {\n    case XML_TOK_PARAM_ENTITY_REF:","target":1,"flaw_line_index":0,"hash":"7e86ce2b-3c68-4224-a4f4-a933acb5304a","idx":"11634d5e-37e7-412a-bba9-00df8191f542"}
{"func_before":"  if (! pool->blocks) {\n    if (! poolGrow(pool))\n      return XML_ERROR_NO_MEMORY;\n  }\n\n  for (;;) {\n    const char *next\n        = entityTextPtr; \/* XmlEntityValueTok doesn't always set the last arg *\/\n    int tok = XmlEntityValueTok(enc, entityTextPtr, entityTextEnd, &next);\n\n#if defined(XML_DTD) || XML_GE == 1\n    if (! accountingDiffTolerated(parser, tok, entityTextPtr, next, __LINE__,\n                                  account)) {\n      accountingOnAbort(parser);\n      result = XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      goto endEntityValue;\n    }\n#endif\n\n    switch (tok) {\n    case XML_TOK_PARAM_ENTITY_REF:","target":0,"flaw_line_index":0,"hash":"d5f9d151-dd93-4731-bcdf-0f71b6cd2155","idx":"acee007d-fe10-4b57-b80f-aed857278480"}
{"func_before":"\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tworking_segment_size = working_descriptor->packet_size;\n\n\t\t\t} else {\n\t\t\t\t\/\/ We don't know what this packet is, so we'll let the parser continue\n\t\t\t\t\/\/ just so that we can dequeue it in one shot\n\t\t\t\tworking_segment_size = packet_size + PACKET_SIZE_TYPE_SIZE;\n\n\t\t\t\tif (working_segment_size > CRSF_MAX_PACKET_LEN) {\n\t\t\t\t\tparser_statistics->invalid_unknown_packet_sizes++;\n\t\t\t\t\tparser_state = PARSER_STATE_HEADER;\n\t\t\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparser_state = PARSER_STATE_PAYLOAD;","target":1,"flaw_line_index":0,"hash":"1c6ce1f6-6ea2-4d31-a673-2fb8d0107d1f","idx":"d8dc6623-0c17-4061-8af9-c88d0120c718"}
{"func_before":"\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tworking_segment_size = working_descriptor->packet_size;\n\n\t\t\t} else {\n\t\t\t\t\/\/ We don't know what this packet is, so we'll let the parser continue\n\t\t\t\t\/\/ just so that we can dequeue it in one shot\n\t\t\t\tworking_segment_size = packet_size - PACKET_SIZE_TYPE_SIZE;\n\n\t\t\t\tif (working_index + working_segment_size + CRC_SIZE > CRSF_MAX_PACKET_LEN) {\n\t\t\t\t\tparser_statistics->invalid_unknown_packet_sizes++;\n\t\t\t\t\tparser_state = PARSER_STATE_HEADER;\n\t\t\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparser_state = PARSER_STATE_PAYLOAD;","target":0,"flaw_line_index":0,"hash":"c8a133d8-a530-4bd1-80bd-e0b8992f2792","idx":"655880be-abae-484d-9730-e62c53a8c656"}
{"func_before":"\t\/*\n\t * Size? If bigger than 4 bytes, the actual data is not\n\t * in the entry but somewhere else (offset).\n\t *\/\n\tif (s > 4)\n\t\tdoff = exif_get_long (d + offset + 8, data->priv->order);\n\telse\n\t\tdoff = offset + 8;\n\n\t\/* Sanity checks *\/\n\tif ((doff + s < doff) || (doff + s < s) || (doff + s > size)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag data past end of buffer (%u > %u)\", doff+s, size);\t\n\t\treturn 0;\n\t}\n\n\tentry->data = exif_data_alloc (data, s);\n\tif (entry->data) {\n\t\tentry->size = s;\n\t\tmemcpy (entry->data, d + doff, s);\n\t} else {\n\t\tEXIF_LOG_NO_MEMORY(data->priv->log, \"ExifData\", s);\n\t\treturn 0;","target":1,"flaw_line_index":0,"hash":"4235c04a-ef87-4c06-ac6f-4c83cbc6f154","idx":"9760b8e8-50c1-41ac-98f5-dcf769e633b0"}
{"func_before":"\t\/*\n\t * Size? If bigger than 4 bytes, the actual data is not\n\t * in the entry but somewhere else (offset).\n\t *\/\n\tif (s > 4)\n\t\tdoff = exif_get_long (d + offset + 8, data->priv->order);\n\telse\n\t\tdoff = offset + 8;\n\n\t\/* Sanity checks *\/\n\tif (doff >= size) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag starts past end of buffer (%u > %u)\", doff, size);\n\t\treturn 0;\n\t}\n\n\tif (s > size - doff) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag data goes past end of buffer (%u > %u)\", doff+s, size);\n\t\treturn 0;\n\t}\n\n\tentry->data = exif_data_alloc (data, s);\n\tif (entry->data) {\n\t\tentry->size = s;\n\t\tmemcpy (entry->data, d + doff, s);\n\t} else {\n\t\tEXIF_LOG_NO_MEMORY(data->priv->log, \"ExifData\", s);\n\t\treturn 0;","target":0,"flaw_line_index":0,"hash":"17f2010f-ef8f-416e-aec1-a3a99fdb5644","idx":"7315d323-ef36-4957-bf8e-94a79744a012"}
{"func_before":"static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tstruct common_audit_data sa;\n\tstruct apparmor_audit_data aad = {0,};\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\t\/* args points to a PAGE_SIZE buffer, AppArmor requires that\n\t * the buffer must be null terminated or have size <= PAGE_SIZE -1\n\t * so that AppArmor can null terminate them\n\t *\/\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\n\t\/* task can only write its own attributes *\/\n\tif (current != task)\n\t\treturn -EACCES;\n\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t} else\n\t\t\tgoto fail;\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\tif (strcmp(command, \"exec\") == 0)\n\t\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\telse\n\t\t\tgoto fail;\n\t} else\n\t\t\/* only support the \"current\" and \"exec\" process attributes *\/\n\t\treturn -EINVAL;\n\n\tif (!error)\n\t\terror = size;\n\treturn error;\n\nfail:\n\tsa.type = LSM_AUDIT_DATA_NONE;\n\tsa.aad = &aad;\n\taad.profile = aa_current_profile();\n\taad.op = OP_SETPROCATTR;\n\taad.info = name;\n\taad.error = -EINVAL;\n\taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n\treturn -EINVAL;\n}","target":1,"flaw_line_index":0,"hash":"9340e4e0-526c-4ec0-b17f-aca6317a17db","idx":"c47fc2bd-36b0-4497-a78f-e6139ebe86b4"}
{"func_before":"static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tstruct common_audit_data sa;\n\tstruct apparmor_audit_data aad = {0,};\n\tchar *command, *largs = NULL, *args = value;\n\tsize_t arg_size;\n\tint error;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\t\/* task can only write its own attributes *\/\n\tif (current != task)\n\t\treturn -EACCES;\n\n\t\/* AppArmor requires that the buffer must be null terminated atm *\/\n\tif (args[size - 1] != '\\0') {\n\t\t\/* null terminate *\/\n\t\tlargs = args = kmalloc(size + 1, GFP_KERNEL);\n\t\tif (!args)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(args, value, size);\n\t\targs[size] = '\\0';\n\t}\n\n\terror = -EINVAL;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\tgoto out;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\tgoto out;\n\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t !AA_DO_TEST);\n\t\t} else if (strcmp(command, \"permhat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t AA_DO_TEST);\n\t\t} else if (strcmp(command, \"changeprofile\") == 0) {\n\t\t} else\n\t\t\tgoto fail;\n\t} else if (strcmp(name, \"exec\") == 0) {\n\t\tif (strcmp(command, \"exec\") == 0)\n\t\t\terror = aa_setprocattr_changeprofile(args, AA_ONEXEC,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\telse\n\t\t\tgoto fail;\n\t} else\n\t\t\/* only support the \"current\" and \"exec\" process attributes *\/\n\t\tgoto fail;\n\n\tif (!error)\n\t\terror = size;\nout:\n\tkfree(largs);\n\treturn error;\n\nfail:\n\tsa.type = LSM_AUDIT_DATA_NONE;\n\tsa.aad = &aad;\n\taad.profile = aa_current_profile();\n\taad.op = OP_SETPROCATTR;\n\taad.info = name;\n\taad.error = error = -EINVAL;\n\taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n\tgoto out;\n}","target":0,"flaw_line_index":0,"hash":"7689c2f9-91d1-4992-ad39-9964c2223e8f","idx":"edbdb824-19b3-4cb9-8a11-a05c1e9a1b07"}
{"func_before":"\t\tu32 j, type, nb_items, first=GF_TRUE;\n\t\tbin128 uuid;\n\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\tnb_items = gf_isom_get_user_data_count(file, track_number, type, uuid);\n\t\tfprintf(stderr, \"%s (%d) \", gf_4cc_to_str(type), nb_items);\n\t\tfor (j=0; j<nb_items; j++) {\n\t\t\tu8 *udta=NULL;\n\t\t\tu32 udta_size;\n\t\t\tgf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);\n\t\t\tif (!udta) continue;\n\t\t\tif (gf_utf8_is_legal(udta, udta_size)) {\n\t\t\t\tif (first) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tfirst = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\t%s\\n\", (char *) udta);\n\t\t\t}\n\t\t\tgf_free(udta);\n\t\t}\n\t}","target":1,"flaw_line_index":0,"hash":"758b447b-4997-4d0f-9760-43b1345689e2","idx":"a1e2a102-b794-44a9-801b-de9bdcf034ec"}
{"func_before":"\t\tu32 j, type, nb_items, first=GF_TRUE;\n\t\tbin128 uuid;\n\t\tgf_isom_get_udta_type(file, track_number, i+1, &type, &uuid);\n\t\tnb_items = gf_isom_get_user_data_count(file, track_number, type, uuid);\n\t\tfprintf(stderr, \"%s (%d) \", gf_4cc_to_str(type), nb_items);\n\t\tfor (j=0; j<nb_items; j++) {\n\t\t\tu8 *udta=NULL;\n\t\t\tu32 udta_size;\n\t\t\tgf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);\n\t\t\tif (!udta) continue;\n\t\t\tif (udta_size && gf_utf8_is_legal(udta, udta_size)) {\n\t\t\t\tu32 idx;\n\t\t\t\tif (first) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tfirst = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\t\");\n\t\t\t\tfor (idx=0; idx<udta_size; idx++) {\n\t\t\t\t\tif (!udta[idx]) break;\n\t\t\t\t\tfprintf(stderr, \"%c\", udta[idx]);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tgf_free(udta);\n\t\t}\n\t}","target":0,"flaw_line_index":0,"hash":"4f25a8fe-be2e-415a-9ff8-798158ceefa9","idx":"5aea8044-d1a3-40a1-ad04-be7768411970"}
{"func_before":"    int\t\tsave_msg_scroll = msg_scroll;\n    int\t\tsave_State = State;\t\/\/ remember State when called\n    int\t\tsome_key_typed = FALSE;\t\/\/ one of the keys was typed\n    \/\/ mouse drag and release events are ignored, unless they are\n    \/\/ preceded with a mouse down event\n    int\t\tignore_drag_release = TRUE;\n#ifdef FEAT_EVAL\n    int\t\tbreak_ctrl_c = FALSE;\n#endif\n    expand_T\txpc;\n    long\t*b_im_ptr = NULL;\n    cmdline_info_T save_ccline;\n    int\t\tdid_save_ccline = FALSE;\n    int\t\tcmdline_type;\n    int\t\twild_type;\n\n    \/\/ one recursion level deeper\n    ++depth;\n\n    if (ccline.cmdbuff != NULL)\n    {\n    msg_scroll = FALSE;\n\n    State = MODE_CMDLINE;\n\n    if (firstc == '\/' || firstc == '?' || firstc == '@')\n    {\n\t\/\/ Use \":lmap\" mappings for search pattern and input().\n\tif (curbuf->b_p_imsearch == B_IMODE_USE_INSERT)\n\t    b_im_ptr = &curbuf->b_p_iminsert;\n\telse\n\t    b_im_ptr = &curbuf->b_p_imsearch;\n\tif (*b_im_ptr == B_IMODE_LMAP)\n\t    State |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(*b_im_ptr == B_IMODE_IM);\n#endif\n    }\n#ifdef HAVE_INPUT_METHOD\n    else if (p_imcmdline)\n\tim_set_active(TRUE);\n#endif\n\n\tcase K_INS:\n\tcase K_KINS:\n\t\tccline.overstrike = !ccline.overstrike;\n#ifdef CURSOR_SHAPE\n\t\tui_cursor_shape();\t\/\/ may show different cursor shape\n#endif\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_HAT:\n\t\tcmdline_toggle_langmap(b_im_ptr);\n\t\tgoto cmdline_not_changed;\n\n\/\/\tcase '@':   only in very old vi\n\tcase Ctrl_U:\n\t\t\/\/ delete all characters left of the cursor\n\t\tj = ccline.cmdpos;\n\t\tccline.cmdlen -= j;\n\t\ti = ccline.cmdpos = 0;\n\t\twhile (i < ccline.cmdlen)\n\t\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINELEAVE);\n\n    State = save_State;\n\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n#ifdef HAVE_INPUT_METHOD\n    if (b_im_ptr != NULL && *b_im_ptr != B_IMODE_LMAP)\n\tim_save_status(b_im_ptr);\n    im_set_active(FALSE);\n#endif\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t\/\/ may show different cursor shape\n#endif\n    sb_text_end_cmdline();\n\ntheend:","target":1,"flaw_line_index":0,"hash":"0a250e71-f9d9-49bd-a686-f89a83c8b5ce","idx":"15c29136-b720-4953-9dfa-d05976a1f804"}
{"func_before":"    int\t\tsave_State = State;\t\/\/ remember State when called\n    int\t\tsome_key_typed = FALSE;\t\/\/ one of the keys was typed\n    \/\/ mouse drag and release events are ignored, unless they are\n    \/\/ preceded with a mouse down event\n    int\t\tignore_drag_release = TRUE;\n#ifdef FEAT_EVAL\n    int\t\tbreak_ctrl_c = FALSE;\n#endif\n    expand_T\txpc;\n    long\t*b_im_ptr = NULL;\n    buf_T\t*b_im_ptr_buf = NULL;\t\/\/ buffer where b_im_ptr is valid\n    cmdline_info_T save_ccline;\n    int\t\tdid_save_ccline = FALSE;\n    int\t\tcmdline_type;\n    int\t\twild_type;\n\n    \/\/ one recursion level deeper\n    ++depth;\n\n    if (ccline.cmdbuff != NULL)\n    {\n\n    State = MODE_CMDLINE;\n\n    if (firstc == '\/' || firstc == '?' || firstc == '@')\n    {\n\t\/\/ Use \":lmap\" mappings for search pattern and input().\n\tif (curbuf->b_p_imsearch == B_IMODE_USE_INSERT)\n\t    b_im_ptr = &curbuf->b_p_iminsert;\n\telse\n\t    b_im_ptr = &curbuf->b_p_imsearch;\n\tb_im_ptr_buf = curbuf;\n\tif (*b_im_ptr == B_IMODE_LMAP)\n\t    State |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(*b_im_ptr == B_IMODE_IM);\n#endif\n    }\n#ifdef HAVE_INPUT_METHOD\n    else if (p_imcmdline)\n\tim_set_active(TRUE);\n#endif\n\n\tcase K_INS:\n\tcase K_KINS:\n\t\tccline.overstrike = !ccline.overstrike;\n#ifdef CURSOR_SHAPE\n\t\tui_cursor_shape();\t\/\/ may show different cursor shape\n#endif\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_HAT:\n\t\tcmdline_toggle_langmap(\n\t\t\t\t    buf_valid(b_im_ptr_buf) ? b_im_ptr : NULL);\n\t\tgoto cmdline_not_changed;\n\n\/\/\tcase '@':   only in very old vi\n\tcase Ctrl_U:\n\t\t\/\/ delete all characters left of the cursor\n\t\tj = ccline.cmdpos;\n\t\tccline.cmdlen -= j;\n\t\ti = ccline.cmdpos = 0;\n\t\twhile (i < ccline.cmdlen)\n\t\t    ccline.cmdbuff[i++] = ccline.cmdbuff[j++];\n    trigger_cmd_autocmd(cmdline_type, EVENT_CMDLINELEAVE);\n\n    State = save_State;\n\n#ifdef FEAT_EVAL\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n#ifdef HAVE_INPUT_METHOD\n    if (b_im_ptr != NULL && buf_valid(b_im_ptr_buf)\n\t\t\t\t\t\t  && *b_im_ptr != B_IMODE_LMAP)\n\tim_save_status(b_im_ptr);\n    im_set_active(FALSE);\n#endif\n    setmouse();\n#ifdef CURSOR_SHAPE\n    ui_cursor_shape();\t\t\/\/ may show different cursor shape\n#endif\n    sb_text_end_cmdline();\n\ntheend:","target":0,"flaw_line_index":0,"hash":"0c3b77d7-f9ac-4b98-9484-3b5a304aac7d","idx":"8df0fd89-c153-452a-a827-2bfd25256669"}
{"func_before":"ecma_op_internal_buffer_append (ecma_collection_t *container_p, \/**< internal container pointer *\/\n                                ecma_value_t key_arg, \/**< key argument *\/\n                                ecma_value_t value_arg, \/**< value argument *\/\n                                lit_magic_string_id_t lit_id) \/**< class id *\/\n{\n  JERRY_ASSERT (container_p != NULL);\n\n  ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (value_arg));\n  }\n\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);\n} \/* ecma_op_internal_buffer_append *\/","target":1,"flaw_line_index":0,"hash":"a6b4ef59-3de9-46aa-b52d-b35c8f625375","idx":"93c1862d-4dce-4820-a348-37011ee79f2c"}
{"func_before":"ecma_op_internal_buffer_append (ecma_collection_t *container_p, \/**< internal container pointer *\/\n                                ecma_value_t key_arg, \/**< key argument *\/\n                                ecma_value_t value_arg, \/**< value argument *\/\n                                lit_magic_string_id_t lit_id) \/**< class id *\/\n{\n  JERRY_ASSERT (container_p != NULL);\n\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_value_t values[] = { ecma_copy_value_if_not_object (key_arg), ecma_copy_value_if_not_object (value_arg) };\n    ecma_collection_append (container_p, values, 2);\n  }\n  else\n  {\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n  }\n\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);\n} \/* ecma_op_internal_buffer_append *\/","target":0,"flaw_line_index":0,"hash":"ca76719d-1147-4152-82d9-3ef3c4b2850a","idx":"a78c06a6-6953-48e9-bdeb-e2f556a76b7f"}
{"func_before":"\t++p;\n\n\tif (*p!='m') {\n\t\tif (*p!='a' && *p!='O' && *p!='C' && *p!='r') {\n\t\t\tgoto outexcept;\n\t\t}\n\t\tintern->ar_flags &= ~SPL_ARRAY_CLONE_MASK;\n\t\tintern->ar_flags |= flags & SPL_ARRAY_CLONE_MASK;\n\t\tzval_ptr_dtor(&intern->array);\n\t\tALLOC_INIT_ZVAL(intern->array);\n\t\tif (!php_var_unserialize(&intern->array, &p, s + buf_len, &var_hash TSRMLS_CC)) {\n\t\t\tgoto outexcept;\n\t\t}\n\t\tvar_push_dtor(&var_hash, &intern->array);\n\t}\n\tif (*p != ';') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\t\/* members *\/","target":1,"flaw_line_index":0,"hash":"e9cb7682-f46a-4e3c-b940-b58544c4c2b2","idx":"8ef44cc6-82ac-45e2-ad35-0627cc92483f"}
{"func_before":"\t++p;\n\n\tif (*p!='m') {\n\t\tif (*p!='a' && *p!='O' && *p!='C' && *p!='r') {\n\t\t\tgoto outexcept;\n\t\t}\n\t\tintern->ar_flags &= ~SPL_ARRAY_CLONE_MASK;\n\t\tintern->ar_flags |= flags & SPL_ARRAY_CLONE_MASK;\n\t\tzval_ptr_dtor(&intern->array);\n\t\tALLOC_INIT_ZVAL(intern->array);\n\t\tif (!php_var_unserialize(&intern->array, &p, s + buf_len, &var_hash TSRMLS_CC)\n\t\t\t\t|| (Z_TYPE_P(intern->array) != IS_ARRAY && Z_TYPE_P(intern->array) != IS_OBJECT)) {\n\t\t\tzval_ptr_dtor(&intern->array);\n\t\t\tgoto outexcept;\n\t\t}\n\t\tvar_push_dtor(&var_hash, &intern->array);\n\t}\n\tif (*p != ';') {\n\t\tgoto outexcept;\n\t}\n\t++p;\n\n\t\/* members *\/","target":0,"flaw_line_index":0,"hash":"b2515b17-f3c9-4211-aeab-f00cb12819ef","idx":"27592c67-d8a8-409f-a25e-eff02863867c"}
{"func_before":"    const int image_height = grads_image.dimension(1);\n    const int image_width = grads_image.dimension(2);\n\n    const int num_boxes = grads.dimension(0);\n    const int crop_height = grads.dimension(1);\n    const int crop_width = grads.dimension(2);\n    const int depth = grads.dimension(3);\n\n    grads_image.setZero();\n\n    auto CropAndResizeBackImgPerBox = [&](int start_box, int limit_box) {\n      for (int b = start_box; b < limit_box; ++b) {\n        const float y1 = boxes(b, 0);\n        const float x1 = boxes(b, 1);\n        const float y2 = boxes(b, 2);\n        const float x2 = boxes(b, 3);\n\n        const int32 b_in = box_index(b);\n        if (!FastBoundsCheck(b_in, batch_size)) {\n          continue;\n        }","target":1,"flaw_line_index":0,"hash":"6ca39831-9594-41e3-a1f1-57ec066c1f01","idx":"1489985a-ecd6-4638-8a69-c8a4328befce"}
{"func_before":"    const int image_height = grads_image.dimension(1);\n    const int image_width = grads_image.dimension(2);\n\n    const int num_boxes = grads.dimension(0);\n    const int crop_height = grads.dimension(1);\n    const int crop_width = grads.dimension(2);\n    const int depth = grads.dimension(3);\n\n    grads_image.setZero();\n\n    auto CropAndResizeBackImgPerBox = [&](int64 start_box, int64 limit_box) {\n      for (int b = start_box; b < limit_box; ++b) {\n        const float y1 = boxes(b, 0);\n        const float x1 = boxes(b, 1);\n        const float y2 = boxes(b, 2);\n        const float x2 = boxes(b, 3);\n\n        const int32 b_in = box_index(b);\n        if (!FastBoundsCheck(b_in, batch_size)) {\n          continue;\n        }","target":0,"flaw_line_index":0,"hash":"0c76168a-4bad-484c-bafb-8ace4c36e5a0","idx":"880381de-c63f-49df-bc6e-6810ae1e3cc4"}
{"func_before":"\t\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos);\n\t}\n\n\t\/*HEVC*\/\n\tgf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);\n\n\t\/*VVC*\/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n\t\n\t\/*AV1*\/\n\tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n\n\t\/*VPx*\/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);\n\n\t\/*JP2H*\/\n\tgf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos);\n\n\t\/*DolbyVision*\/","target":1,"flaw_line_index":0,"hash":"4e79d4d7-f678-4364-ba5a-32dc8ea136cf","idx":"0f0d7de6-eb27-4d90-ab50-4b862823af96"}
{"func_before":"\t\tgf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos);\n\t\tgf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos);\n\t}\n\n\t\/*HEVC*\/\n\tgf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);\n\n\t\/*VVC*\/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n\n\t\/*AV1*\/\n\tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n\n\t\/*VPx*\/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);\n\n\t\/*JP2H*\/\n\tgf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos);\n\n\t\/*DolbyVision*\/","target":0,"flaw_line_index":0,"hash":"62858d32-37b9-4d4f-92a7-fdaaad8162c6","idx":"68af2b4f-6f59-4431-9eef-8f266c7d0ddb"}
{"func_before":"int nfc_data_exchange(struct nfc_dev *dev, u32 target_idx, struct sk_buff *skb,\n\t\t      data_exchange_cb_t cb, void *cb_context)\n{\n\tint rc;\n\n\tpr_debug(\"dev_name=%s target_idx=%u skb->len=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, skb->len);\n\n\tdevice_lock(&dev->dev);\n\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\tif (dev->rf_mode == NFC_RF_INITIATOR && dev->active_target != NULL) {\n\t\tif (dev->active_target->idx != target_idx) {\n\t\t\trc = -EADDRNOTAVAIL;\n\t\t\tkfree_skb(skb);\n\t\t\tgoto error;","target":1,"flaw_line_index":0,"hash":"e4114a08-8380-4b1a-9830-9900932e00f5","idx":"fc0de270-71c6-4191-a65b-cbcf408e3cf5"}
{"func_before":"int nfc_data_exchange(struct nfc_dev *dev, u32 target_idx, struct sk_buff *skb,\n\t\t      data_exchange_cb_t cb, void *cb_context)\n{\n\tint rc;\n\n\tpr_debug(\"dev_name=%s target_idx=%u skb->len=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, skb->len);\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->shutting_down) {\n\t\trc = -ENODEV;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n\n\tif (dev->rf_mode == NFC_RF_INITIATOR && dev->active_target != NULL) {\n\t\tif (dev->active_target->idx != target_idx) {\n\t\t\trc = -EADDRNOTAVAIL;\n\t\t\tkfree_skb(skb);\n\t\t\tgoto error;","target":0,"flaw_line_index":0,"hash":"b689637c-04d4-4c2c-9659-24bc89a8722f","idx":"b6b346fa-3b81-4d38-ab78-3f77a710cb70"}
{"func_before":"rad_get_vendor_attr(u_int32_t *vendor, const void **data, size_t *len)\n{\n\tstruct vendor_attribute *attr;\n\n\tattr = (struct vendor_attribute *)*data;\n\t*vendor = ntohl(attr->vendor_value);\n\t*data = attr->attrib_data;\n\t*len = attr->attrib_len - 2;\n\n\treturn (attr->attrib_type);\n}","target":1,"flaw_line_index":0,"hash":"6d89dda6-48ad-4171-bb20-46c4b10cd9bf","idx":"f3b9d53d-c109-416a-9b70-92da2aa0d2a5"}
{"func_before":"rad_get_vendor_attr(u_int32_t *vendor, unsigned char *type, const void **data, size_t *len, const void *raw, size_t raw_len)\n{\n\tstruct vendor_attribute *attr;\n\n\tif (raw_len < sizeof(struct vendor_attribute)) {\n\t\treturn -1;\n\t}\n\n\tattr = (struct vendor_attribute *) raw;\n\t*vendor = ntohl(attr->vendor_value);\n\t*type = attr->attrib_type;\n\t*data = attr->attrib_data;\n\t*len = attr->attrib_len - 2;\n\n\tif ((attr->attrib_len + 4) > raw_len) {\n\t\treturn -1;\n\t}\n\n\treturn (attr->attrib_type);\n}","target":0,"flaw_line_index":0,"hash":"0eea81f5-d61f-46f2-a01a-d6126c9ee7b2","idx":"8937d015-c663-4e15-8ead-7a2dfa38124c"}
{"func_before":"\n\tfilter_dbg(port->driver_bound, data, \"<- i8042 (interrupt, %d, %d%s%s)\\n\",\n\t\t   port_no, irq,\n\t\t   dfl & SERIO_PARITY ? \", bad parity\" : \"\",\n\t\t   dfl & SERIO_TIMEOUT ? \", timeout\" : \"\");\n\n\tfiltered = i8042_filter(data, str, serio);\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\tif (likely(port->exists && !filtered))\n\t\tserio_interrupt(serio, data, dfl);\n\n out:\n\treturn IRQ_RETVAL(ret);\n}","target":1,"flaw_line_index":0,"hash":"f0da5c5d-ee8c-4dad-8bbd-71bb007ecca3","idx":"3aec647c-9449-4d55-ac04-9d5e472fec16"}
{"func_before":"\n\tfilter_dbg(port->driver_bound, data, \"<- i8042 (interrupt, %d, %d%s%s)\\n\",\n\t\t   port_no, irq,\n\t\t   dfl & SERIO_PARITY ? \", bad parity\" : \"\",\n\t\t   dfl & SERIO_TIMEOUT ? \", timeout\" : \"\");\n\n\tfiltered = i8042_filter(data, str, serio);\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\tif (likely(serio && !filtered))\n\t\tserio_interrupt(serio, data, dfl);\n\n out:\n\treturn IRQ_RETVAL(ret);\n}","target":0,"flaw_line_index":0,"hash":"a17364a9-de26-4ae9-8817-3462a4dbcfde","idx":"6537022a-7332-4db0-ae78-5f0646fc50fd"}
{"func_before":"\t}\n\n\t\/*\n\t * We have to traverse the policy forwards, not in reverse,\n\t * to support the \"pwcheck == all\" case.\n\t *\/\n\tTAILQ_FOREACH(us, &nss->parse_tree->userspecs, entries) {\n\t    int user_match = userlist_matches(nss->parse_tree, ctx->user.pw,\n\t\t&us->users);\n\t    if (user_match != ALLOW) {\n\t\tif (callback != NULL && user_match != UNSPEC) {\n\t\t    callback(nss->parse_tree, us, user_match, NULL, UNSPEC,\n\t\t\tNULL, UNSPEC, UNSPEC, UNSPEC, cb_data);\n\t\t}\n\t\tcontinue;\n\t    }\n\t    TAILQ_FOREACH(priv, &us->privileges, entries) {\n\t\tint priv_nopass = UNSPEC;\n\t\tint host_match = hostlist_matches(nss->parse_tree, ctx->user.pw,\n\t\t    &priv->hostlist);\n\t\tif (host_match != ALLOW) {\n\t\t\t\t    cs->cmnd, cs->runchroot, NULL);\n\t\t\t    }\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if (callback != NULL) {\n\t\t\tcallback(nss->parse_tree, us, user_match, priv,\n\t\t\t    host_match, cs, date_match, runas_match,\n\t\t\t    cmnd_match, cb_data);\n\t\t    }\n\t\t    if (cmnd_match != UNSPEC) {\n\t\t\t\/*\n\t\t\t * We take the last match but must process\n\t\t\t * the entire policy for pwcheck == all.\n\t\t\t *\/\n\t\t\tmatch = cmnd_match;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (!sudo_nss_can_continue(nss, match))","target":1,"flaw_line_index":0,"hash":"09207cb7-a2f2-48ae-a992-79a287c8dffe","idx":"6f661985-0620-45d1-bf64-ec9ec5ac73fe"}
{"func_before":"\t}\n\n\t\/*\n\t * We have to traverse the policy forwards, not in reverse,\n\t * to support the \"pwcheck == all\" case.\n\t *\/\n\tTAILQ_FOREACH(us, &nss->parse_tree->userspecs, entries) {\n\t    int user_match = userlist_matches(nss->parse_tree, ctx->user.pw,\n\t\t&us->users);\n\t    if (user_match != ALLOW) {\n\t\tif (callback != NULL && user_match == DENY) {\n\t\t    callback(nss->parse_tree, us, user_match, NULL, UNSPEC,\n\t\t\tNULL, UNSPEC, UNSPEC, UNSPEC, cb_data);\n\t\t}\n\t\tcontinue;\n\t    }\n\t    TAILQ_FOREACH(priv, &us->privileges, entries) {\n\t\tint priv_nopass = UNSPEC;\n\t\tint host_match = hostlist_matches(nss->parse_tree, ctx->user.pw,\n\t\t    &priv->hostlist);\n\t\tif (host_match != ALLOW) {\n\t\t\t\t    cs->cmnd, cs->runchroot, NULL);\n\t\t\t    }\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    if (callback != NULL) {\n\t\t\tcallback(nss->parse_tree, us, user_match, priv,\n\t\t\t    host_match, cs, date_match, runas_match,\n\t\t\t    cmnd_match, cb_data);\n\t\t    }\n\t\t    if (SPECIFIED(cmnd_match)) {\n\t\t\t\/*\n\t\t\t * We take the last match but must process\n\t\t\t * the entire policy for pwcheck == all.\n\t\t\t *\/\n\t\t\tmatch = cmnd_match;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (!sudo_nss_can_continue(nss, match))","target":0,"flaw_line_index":0,"hash":"5f50fadd-3580-4173-895a-4ca7f6325586","idx":"9a2fe273-f9c9-4b0f-93ab-b479ae337fca"}
{"func_before":"static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,\n\t\t\t      indx, data, size, 100);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}","target":1,"flaw_line_index":0,"hash":"68312650-b2aa-406a-b7c4-aaa886000e3e","idx":"7dd35cae-5244-42e3-85e7-9be0bbc59d5b"}
{"func_before":"static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size,\n\t\t\t const void *data)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(data, size, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,\n\t\t\t      indx, buf, size, 100);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\tkfree(buf);\n\treturn ret;\n}","target":0,"flaw_line_index":0,"hash":"46167dc7-84f5-43b9-96df-5a736f185674","idx":"a732139b-cc51-488b-87a8-1f14faf8da35"}
{"func_before":"Http::FilterMetadataStatus Context::onResponseMetadata() {\n  if (!wasm_->onResponseMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onResponseMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; \/\/ This is currently the only return code.\n}","target":1,"flaw_line_index":0,"hash":"1c3a43e0-9b50-4767-9f07-c046a29cc6c9","idx":"8fc2178b-2d02-4495-bcfd-45f7a6fd9e50"}
{"func_before":"Http::FilterMetadataStatus Context::onResponseMetadata() {\n  if (!in_vm_context_created_ || !wasm_->onResponseMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onResponseMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  return Http::FilterMetadataStatus::Continue; \/\/ This is currently the only return code.\n}","target":0,"flaw_line_index":0,"hash":"53928bb4-d355-4111-9720-a59c32979b2e","idx":"62a6387e-36fa-4ee8-8afe-219c800e7a65"}
{"func_before":"TfLiteStatus LeakyReluEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  const auto* params =\n      reinterpret_cast<TfLiteLeakyReluParams*>(node->builtin_data);\n  const LeakyReluOpData* data =\n      reinterpret_cast<LeakyReluOpData*>(node->user_data);\n\n  LeakyReluParams op_params;\n  switch (input->type) {\n    case kTfLiteFloat32: {\n      op_params.alpha = params->alpha;\n      optimized_ops::LeakyRelu(","target":1,"flaw_line_index":0,"hash":"e64b11b5-d813-44eb-bc32-cecd4c2e88db","idx":"d1357f69-4e79-42cf-9eae-9b179a6ff455"}
{"func_before":"TfLiteStatus LeakyReluEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const auto* params =\n      reinterpret_cast<TfLiteLeakyReluParams*>(node->builtin_data);\n  const LeakyReluOpData* data =\n      reinterpret_cast<LeakyReluOpData*>(node->user_data);\n\n  LeakyReluParams op_params;\n  switch (input->type) {\n    case kTfLiteFloat32: {\n      op_params.alpha = params->alpha;\n      optimized_ops::LeakyRelu(","target":0,"flaw_line_index":0,"hash":"4ef85880-9fff-4b1c-90af-a3051c2f8506","idx":"df8b2ca3-8ba0-4415-9ca6-92ec92e19203"}
{"func_before":"\t\t\tif (!parse_thread (bin, &lc, off, is_first_thread)) {\n\t\t\t\tbprintf (\"Cannot parse thread\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tis_first_thread = false;\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLIB:\n\t\tcase LC_LOAD_WEAK_DYLIB:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"load_dylib\", 0);\n\t\t\tbin->nlibs++;\n\t\t\tif (!parse_dylib(bin, off)){\n\t\t\t\tbprintf (\"Cannot parse dylib\\n\");\n\t\t\t\tbin->nlibs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_INFO:\n\t\tcase LC_DYLD_INFO_ONLY:\n\t\t\t{\n\t\t\tut8 dyldi[sizeof (struct dyld_info_command)] = {0};\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dyld_info\", 0);\n\t\t\tbin->dyld_info = malloc (sizeof(struct dyld_info_command));\n\n\t\t\tif (off + sizeof (struct dyld_info_command) > bin->size){\n\t\t\t\tbprintf (\"Cannot parse dyldinfo\\n\");\n\t\t\t\tfree (bin->dyld_info);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {\n\t\t\t\tfree (bin->dyld_info);\n\t\t\t\tbin->dyld_info = NULL;\n\t\t\t\tbprintf (\"Error: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\t} else {\n\t\t\t\tbin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);\n\t\t\t\tbin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);\n\t\t\t\tbin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);\n\t\t\t\tbin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);\n\t\t\t\tbin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);\n\t\t\t\tbin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);\n\t\t\t\tbin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);\n\t\t\t\tbin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);\n\t\t\t\tbin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);\n\t\t\t\tbin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);\n\t\t\t\tbin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);\n\t\t\t\tbin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_CODE_SIGNATURE:\n\t\t\tparse_signature (bin, off);\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"signature\", 0);\n\t\t\t\/* ut32 dataoff\n\t\t\t\/\/ ut32 datasize *\/\n\t\t\tbreak;\n\t\tcase LC_SOURCE_VERSION:","target":1,"flaw_line_index":0,"hash":"9132f949-633f-45f3-a8a1-deac71ad27f6","idx":"1386836b-1c6e-4d49-a520-bec70ea9802f"}
{"func_before":"\t\t\tif (!parse_thread (bin, &lc, off, is_first_thread)) {\n\t\t\t\tbprintf (\"Cannot parse thread\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tis_first_thread = false;\n\t\t\tbreak;\n\t\tcase LC_LOAD_DYLIB:\n\t\tcase LC_LOAD_WEAK_DYLIB:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"load_dylib\", 0);\n\t\t\tbin->nlibs++;\n\t\t\tif (!parse_dylib (bin, off)){\n\t\t\t\tbprintf (\"Cannot parse dylib\\n\");\n\t\t\t\tbin->nlibs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_INFO:\n\t\tcase LC_DYLD_INFO_ONLY:\n\t\t\t{\n\t\t\tut8 dyldi[sizeof (struct dyld_info_command)] = {0};\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dyld_info\", 0);\n\t\t\tbin->dyld_info = calloc (1, sizeof (struct dyld_info_command));\n\t\t\tif (bin->dyld_info) {\n\t\t\t\tif (off + sizeof (struct dyld_info_command) > bin->size){\n\t\t\t\t\tbprintf (\"Cannot parse dyldinfo\\n\");\n\t\t\t\t\tR_FREE (bin->dyld_info);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {\n\t\t\t\t\tfree (bin->dyld_info);\n\t\t\t\t\tbin->dyld_info = NULL;\n\t\t\t\t\tbprintf (\"Error: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\t\t} else {\n\t\t\t\t\tbin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_CODE_SIGNATURE:\n\t\t\tparse_signature (bin, off);\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"signature\", 0);\n\t\t\t\/* ut32 dataoff\n\t\t\t\/\/ ut32 datasize *\/\n\t\t\tbreak;\n\t\tcase LC_SOURCE_VERSION:","target":0,"flaw_line_index":0,"hash":"c4efb730-d95f-4f2f-b02c-c486cc1e942e","idx":"92dd373a-1ef4-409d-83a8-b77dcb955ba1"}
{"func_before":"{\n\tchar *ea_name;\n\tint rc;\n\tint size = 0;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tinode->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(inode);\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {","target":1,"flaw_line_index":0,"hash":"03493470-9d42-4e02-99f8-3d748fe57243","idx":"ca2d139c-3273-4490-be38-a0e34b226406"}
{"func_before":"{\n\tchar *ea_name;\n\tint rc;\n\tint size = 0;\n\tchar *value = NULL;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\trc = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tinode->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {","target":0,"flaw_line_index":0,"hash":"550eefb9-4424-4606-b3bc-d925a7fc9c09","idx":"da6c3a50-7ced-48df-8d5e-8bd54eefe983"}
{"func_before":"void dm9000WritePhyReg(uint8_t address, uint16_t data)\n{\n   \/\/Write PHY register address\n   dm9000WriteReg(DM9000_REG_EPAR, 0x40 | address);\n   \/\/Write register value\n   dm9000WriteReg(DM9000_REG_EPDRL, LSB(data));\n   dm9000WriteReg(DM9000_REG_EPDRH, MSB(data));\n\n   \/\/Start the write operation\n   dm9000WriteReg(DM9000_REG_EPCR, EPCR_EPOS | EPCR_ERPRW);\n   \/\/PHY access is still in progress?\n   while((dm9000ReadReg(DM9000_REG_EPCR) & EPCR_ERRE) != 0)\n   {\n   }\n\n   \/\/Wait 5us minimum\n   usleep(5);\n   \/\/Clear command register\n   dm9000WriteReg(DM9000_REG_EPCR, EPCR_EPOS);\n}","target":1,"flaw_line_index":0,"hash":"f9bba847-7fd9-4ef6-9d2e-de3c964e2ba2","idx":"fa7cdbfc-c882-42a9-9658-8614039de4ab"}
{"func_before":"void dm9000WritePhyReg(uint8_t address, uint16_t data)\n{\n   \/\/Write PHY register address\n   dm9000WriteReg(DM9000_EPAR, 0x40 | address);\n   \/\/Write register value\n   dm9000WriteReg(DM9000_EPDRL, LSB(data));\n   dm9000WriteReg(DM9000_EPDRH, MSB(data));\n\n   \/\/Start the write operation\n   dm9000WriteReg(DM9000_EPCR, DM9000_EPCR_EPOS | DM9000_EPCR_ERPRW);\n\n   \/\/PHY access is still in progress?\n   while((dm9000ReadReg(DM9000_EPCR) & DM9000_EPCR_ERRE) != 0)\n   {\n   }\n\n   \/\/Wait 5us minimum\n   usleep(5);\n   \/\/Clear command register\n   dm9000WriteReg(DM9000_EPCR, DM9000_EPCR_EPOS);\n}","target":0,"flaw_line_index":0,"hash":"93ec32f3-d944-4dab-9bcd-eeecc71286c9","idx":"04e2c7b1-d2a9-4094-a991-343a787c2cf8"}
{"func_before":"    else\n\tnew_ts_str = vim_strnsave(new_ts_str, eap->arg - new_ts_str);\n#else\n    ptr = eap->arg;\n    new_ts = getdigits(&ptr);\n    if (new_ts < 0 && *eap->arg == '-')\n    {\n\temsg(_(e_argument_must_be_positive));\n\treturn;\n    }\n    if (new_ts < 0 || new_ts > 9999)\n    {\n\tsemsg(_(e_invalid_argument_str), eap->arg);\n\treturn;\n    }\n    if (new_ts == 0)\n\tnew_ts = curbuf->b_p_ts;\n#endif\n    for (lnum = eap->line1; !got_int && lnum <= eap->line2; ++lnum)\n    {\n\tptr = ml_get(lnum);","target":1,"flaw_line_index":0,"hash":"0dc50f2e-1898-4460-b5f0-95f4b840d4e1","idx":"aad1de09-4083-4158-bf1e-2a7a080f86a6"}
{"func_before":"    else\n\tnew_ts_str = vim_strnsave(new_ts_str, eap->arg - new_ts_str);\n#else\n    ptr = eap->arg;\n    new_ts = getdigits(&ptr);\n    if (new_ts < 0 && *eap->arg == '-')\n    {\n\temsg(_(e_argument_must_be_positive));\n\treturn;\n    }\n    if (new_ts < 0 || new_ts > TABSTOP_MAX)\n    {\n\tsemsg(_(e_invalid_argument_str), eap->arg);\n\treturn;\n    }\n    if (new_ts == 0)\n\tnew_ts = curbuf->b_p_ts;\n#endif\n    for (lnum = eap->line1; !got_int && lnum <= eap->line2; ++lnum)\n    {\n\tptr = ml_get(lnum);","target":0,"flaw_line_index":0,"hash":"b4223ac1-b590-4998-a1df-28c09bbee99c","idx":"6ad66d28-26e9-4e75-b326-6bce34789899"}
{"func_before":"\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tret = make_NegHints(minor_status, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tsc = create_spnego_ctx();\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->internal_mech = GSS_C_NO_OID;\n","target":1,"flaw_line_index":0,"hash":"be7383e5-8cc1-49a9-af2b-0a05a2bd21a4","idx":"495d069b-1f1a-4de1-baca-b0ba11d36280"}
{"func_before":"\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_ACCEPT,\n\t\t\t\t   &supported_mechSet);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tret = make_NegHints(minor_status, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tsc = create_spnego_ctx(0);\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tsc->internal_mech = GSS_C_NO_OID;\n","target":0,"flaw_line_index":0,"hash":"0841b88a-60d4-40f0-acaa-9a7225ab9f3e","idx":"48e028e0-6386-43f7-84b3-08d28012c088"}
{"func_before":"find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}","target":1,"flaw_line_index":0,"hash":"32a1e690-e9e8-4d16-99d7-9c25e0a153b0","idx":"587812ca-33d7-4ce9-962d-0b5103f483ab"}
{"func_before":"find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\t\/* don't alter vm_end if the coredump is running *\/\n\tif (!prev || !mmget_still_valid(mm) || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}","target":0,"flaw_line_index":0,"hash":"b872b339-5c39-4a84-b50d-692253f75574","idx":"68995b8d-ecb2-4449-8f0a-e16459ab4162"}
{"func_before":"\tvoid verifyDirectoryPermissions(const string &path) {\n\t\tTRACE_POINT();\n\t\tstruct stat buf;\n\n\t\tif (stat(path.c_str(), &buf) == -1) {\n\t\t\tint e = errno;\n\t\t\tthrow FileSystemException(\"Cannot stat() \" + path, e, path);\n\t\t} else if (buf.st_mode != (S_IFDIR | parseModeString(\"u=rwx,g=rx,o=rx\"))) {\n\t\t\tthrow RuntimeException(\"Tried to reuse existing server instance directory \" +\n\t\t\t\tpath + \", but it has wrong permissions\");\n\t\t} else if (buf.st_uid != geteuid() || buf.st_gid != getegid()) {\n\t\t\t\/* The server instance directory is always created by the Watchdog. Its UID\/GID never\n\t\t\t * changes because:\n\t\t\t * 1. Disabling user switching only lowers the privilege of the HelperAgent.\n\t\t\t * 2. For the UID\/GID to change, the web server must be completely restarted\n\t\t\t *    (not just graceful reload) so that the control process can change its UID\/GID.\n\t\t\t *    This causes the PID to change, so that an entirely new server instance\n\t\t\t *    directory is created.","target":1,"flaw_line_index":0,"hash":"aa39b638-dddd-4caa-8ac9-0a5c03619b20","idx":"96981580-0d16-4cc3-928a-83672b667ce3"}
{"func_before":"\tvoid verifyDirectoryPermissions(const string &path, struct stat &buf) {\n\t\tTRACE_POINT();\n\n\t\tif (buf.st_mode != (S_IFDIR | parseModeString(\"u=rwx,g=rx,o=rx\"))) {\n\t\t\tthrow RuntimeException(\"Tried to reuse existing server instance directory \" +\n\t\t\t\tpath + \", but it has wrong permissions\");\n\t\t} else if (buf.st_uid != geteuid() || buf.st_gid != getegid()) {\n\t\t\t\/* The server instance directory is always created by the Watchdog. Its UID\/GID never\n\t\t\t * changes because:\n\t\t\t * 1. Disabling user switching only lowers the privilege of the HelperAgent.\n\t\t\t * 2. For the UID\/GID to change, the web server must be completely restarted\n\t\t\t *    (not just graceful reload) so that the control process can change its UID\/GID.\n\t\t\t *    This causes the PID to change, so that an entirely new server instance\n\t\t\t *    directory is created.","target":0,"flaw_line_index":0,"hash":"33c4638f-028d-4ad0-8615-1d888f700962","idx":"adc8a399-c6bf-493f-93bd-dfabc19ea50b"}
{"func_before":"struct bpf_prog *bpf_prog_get(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\n\tprog = __bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\n\tatomic_inc(&prog->aux->refcnt);\n\tfdput(f);\n\n\treturn prog;\n}","target":1,"flaw_line_index":0,"hash":"89cd53ea-615c-487e-8a14-7d67b752e7d1","idx":"8c6cb715-5203-4864-8d38-4b855849dd4d"}
{"func_before":"struct bpf_prog *bpf_prog_get(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\n\tprog = __bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\n\tprog = bpf_prog_inc(prog);\n\tfdput(f);\n\n\treturn prog;\n}","target":0,"flaw_line_index":0,"hash":"4cf40f5b-9536-4a01-8453-d24ec1495ca9","idx":"fe603787-0f80-44cf-ac1f-177b93243cd6"}
{"func_before":"void kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\tif (vapic_addr)\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\telse\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n}","target":1,"flaw_line_index":0,"hash":"109f73d9-1fe9-4f98-80d7-e16452d053ab","idx":"eed7253c-8ba6-47c8-968c-9d491efce633"}
{"func_before":"int kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tif (vapic_addr) {\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t\t\t\t&vcpu->arch.apic->vapic_cache,\n\t\t\t\t\tvapic_addr, sizeof(u32)))\n\t\t\treturn -EINVAL;\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t} else {\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t}\n\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"f855dfa1-0937-4581-9fd5-dfbfea48c13d","idx":"8254dce1-dc5a-44b6-bfb5-701c1823ce32"}
{"func_before":"\tif (!s)\n\t\treturn;\n\n\tkey_id = se050_rsa_keypair_from_nvm(s);\n\tif (key_id) {\n\t\tst = sss_se05x_key_object_get_handle(&k_object, key_id);\n\t\tif (st == kStatus_SSS_Success)\n\t\t\tsss_se05x_key_store_erase_key(se050_kstore, &k_object);\n\t}\n\n\tcrypto_bignum_free(s->e);\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->qp);\n\tcrypto_bignum_free(s->dp);\n\tcrypto_bignum_free(s->dq);\n}","target":1,"flaw_line_index":0,"hash":"654b13e2-6d74-460c-afc2-b8ce49eca604","idx":"9bf0a2b9-d760-4acc-aa0b-4ed0cc758772"}
{"func_before":"\tif (!s)\n\t\treturn;\n\n\tkey_id = se050_rsa_keypair_from_nvm(s);\n\tif (key_id) {\n\t\tst = sss_se05x_key_object_get_handle(&k_object, key_id);\n\t\tif (st == kStatus_SSS_Success)\n\t\t\tsss_se05x_key_store_erase_key(se050_kstore, &k_object);\n\t}\n\n\tcrypto_bignum_free(&s->e);\n\tcrypto_bignum_free(&s->d);\n\tcrypto_bignum_free(&s->n);\n\tcrypto_bignum_free(&s->p);\n\tcrypto_bignum_free(&s->q);\n\tcrypto_bignum_free(&s->qp);\n\tcrypto_bignum_free(&s->dp);\n\tcrypto_bignum_free(&s->dq);\n}","target":0,"flaw_line_index":0,"hash":"37a5d763-b197-4247-a0b0-b6a0b3874e66","idx":"a8082d79-a029-4b22-a744-20b23bfae288"}
{"func_before":"load_kernel_module_list (void)\n{\n  GHashTable *modules = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  g_autofree char *modules_data = NULL;\n  g_autoptr(GError) error = NULL;\n  char *start, *end;\n  \n  if (!g_file_get_contents (\"\/proc\/modules\", &modules_data, NULL, &error))\n    {\n      g_info (\"Failed to read \/proc\/modules: %s\", error->message);\n      return modules;\n    }\n\n  \/* \/proc\/modules is a table of modules.\n   * Columns are split by spaces and rows by newlines.\n   * The first column is the name. *\/\n  start = modules_data;","target":1,"flaw_line_index":0,"hash":"47bbaa0c-93cc-48b2-ab7d-71badfda26f6","idx":"5f88d55c-159f-47e0-813b-13b4dc1965af"}
{"func_before":"load_kernel_module_list (void)\n{\n  GHashTable *modules = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  g_autofree char *modules_data = NULL;\n  g_autoptr(GError) error = NULL;\n  char *start, *end;\n\n  if (!g_file_get_contents (\"\/proc\/modules\", &modules_data, NULL, &error))\n    {\n      g_info (\"Failed to read \/proc\/modules: %s\", error->message);\n      return modules;\n    }\n\n  \/* \/proc\/modules is a table of modules.\n   * Columns are split by spaces and rows by newlines.\n   * The first column is the name. *\/\n  start = modules_data;","target":0,"flaw_line_index":0,"hash":"9b6b45e8-7836-493a-ba5b-1a59e7299220","idx":"fb7bdec3-a24e-4b25-860c-fad88999f698"}
{"func_before":"    long l;\n    int withvalues = 0;\n    robj *hash;\n    listpackEntry ele;\n\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4)\n            withvalues = 1;\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n\n    \/* Handle variant without <count> argument. Reply with simple bulk string *\/\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,hash,OBJ_HASH)) {\n        return;\n    }\n","target":1,"flaw_line_index":0,"hash":"cef8834b-be0f-4771-b9eb-11ea68925b04","idx":"d1ac21d7-0e9d-4728-a483-2481f5cd1dd7"}
{"func_before":"    long l;\n    int withvalues = 0;\n    robj *hash;\n    listpackEntry ele;\n\n    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4) {\n            withvalues = 1;\n            if (l < LONG_MIN\/2 || l > LONG_MAX\/2) {\n                addReplyError(c,\"value is out of range\");\n                return;\n            }\n        }\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n\n    \/* Handle variant without <count> argument. Reply with simple bulk string *\/\n    if ((hash = lookupKeyReadOrReply(c,c->argv[1],shared.null[c->resp]))== NULL ||\n        checkType(c,hash,OBJ_HASH)) {\n        return;\n    }\n","target":0,"flaw_line_index":0,"hash":"87ea6741-a01d-4dea-a66f-f4c71c628be6","idx":"4a077afe-de35-40cf-839a-7b4e64a3132b"}
{"func_before":"int hugepage_madvise(struct vm_area_struct *vma,\n\t\t     unsigned long *vm_flags, int advice)\n{\n\tswitch (advice) {\n\tcase MADV_HUGEPAGE:\n\t\t\/*\n\t\t * Be somewhat over-protective like KSM for now!\n\t\t *\/\n\t\tif (*vm_flags & (VM_HUGEPAGE |\n\t\t\t\t VM_SHARED   | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |\n\t\t\t\t VM_MIXEDMAP | VM_SAO))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_NOHUGEPAGE;\n\t\t*vm_flags |= VM_HUGEPAGE;\n\t\t\/*\n\t\t * If the vma become good for khugepaged to scan,\n\t\t * register it here without waiting a page fault that\n\t\t * may not happen any time soon.\n\t\t *\/\n\t\tif (unlikely(khugepaged_enter_vma_merge(vma)))\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase MADV_NOHUGEPAGE:\n\t\t\/*\n\t\t * Be somewhat over-protective like KSM for now!\n\t\t *\/\n\t\tif (*vm_flags & (VM_NOHUGEPAGE |\n\t\t\t\t VM_SHARED   | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |\n\t\t\t\t VM_MIXEDMAP | VM_SAO))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_HUGEPAGE;\n\t\t*vm_flags |= VM_NOHUGEPAGE;\n\t\t\/*\n\t\t * Setting VM_NOHUGEPAGE will prevent khugepaged from scanning\n\t\t * this vma even if we leave the mm registered in khugepaged if\n\t\t * it got registered before VM_NOHUGEPAGE was set.\n\t\t *\/\n\t\tbreak;\n\t}","target":1,"flaw_line_index":0,"hash":"7b0ef1d1-3240-4d72-8737-014186856c1d","idx":"703c15b8-65bb-46eb-a642-a3229e962bec"}
{"func_before":"int hugepage_madvise(struct vm_area_struct *vma,\n\t\t     unsigned long *vm_flags, int advice)\n{\n\tswitch (advice) {\n\tcase MADV_HUGEPAGE:\n\t\t\/*\n\t\t * Be somewhat over-protective like KSM for now!\n\t\t *\/\n\t\tif (*vm_flags & (VM_HUGEPAGE | VM_NO_THP))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_NOHUGEPAGE;\n\t\t*vm_flags |= VM_HUGEPAGE;\n\t\t\/*\n\t\t * If the vma become good for khugepaged to scan,\n\t\t * register it here without waiting a page fault that\n\t\t * may not happen any time soon.\n\t\t *\/\n\t\tif (unlikely(khugepaged_enter_vma_merge(vma)))\n\t\t\treturn -ENOMEM;\n\t\tbreak;\n\tcase MADV_NOHUGEPAGE:\n\t\t\/*\n\t\t * Be somewhat over-protective like KSM for now!\n\t\t *\/\n\t\tif (*vm_flags & (VM_NOHUGEPAGE | VM_NO_THP))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_HUGEPAGE;\n\t\t*vm_flags |= VM_NOHUGEPAGE;\n\t\t\/*\n\t\t * Setting VM_NOHUGEPAGE will prevent khugepaged from scanning\n\t\t * this vma even if we leave the mm registered in khugepaged if\n\t\t * it got registered before VM_NOHUGEPAGE was set.\n\t\t *\/\n\t\tbreak;\n\t}","target":0,"flaw_line_index":0,"hash":"d6939098-4fff-463b-80a4-6577955dae17","idx":"cc8dfc21-4e6a-4e89-919f-419e5ca67b01"}
{"func_before":"\t\t\t\t\t\t!utf8_trail(str[pos + 3])) {\n\t\t\t\t\tif (avail < 2 || utf8_lead(str[pos + 1]))\n\t\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t\telse if (avail < 3 || utf8_lead(str[pos + 2]))\n\t\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t\telse if (avail < 4 || utf8_lead(str[pos + 3]))\n\t\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t\telse\n\t\t\t\t\t\tMB_FAILURE(pos, 4);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis_char = ((c & 0x07) << 18) | ((str[pos + 1] & 0x3f) << 12) | ((str[pos + 2] & 0x3f) << 6) | (str[pos + 3] & 0x3f);\n\t\t\t\tif (this_char < 0x10000 || this_char > 0x10FFFF) { \/* non-shortest form or outside range *\/\n\t\t\t\t\tMB_FAILURE(pos, 4);\n\t\t\t\t}\n\t\t\t\tpos += 4;\n\t\t\t} else {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t}\n\t\t}\n\t\tbreak;","target":1,"flaw_line_index":0,"hash":"1488a506-63e2-4364-8176-5f55bf38998e","idx":"86517473-4c94-4cf6-8bd3-92df50cf8f28"}
{"func_before":"\t\t\t\t\t\t!utf8_trail(str[pos + 3])) {\n\t\t\t\t\tif (avail < 2 || utf8_lead(str[pos + 1]))\n\t\t\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t\t\telse if (avail < 3 || utf8_lead(str[pos + 2]))\n\t\t\t\t\t\tMB_FAILURE(pos, 2);\n\t\t\t\t\telse if (avail < 4 || utf8_lead(str[pos + 3]))\n\t\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t\telse\n\t\t\t\t\t\tMB_FAILURE(pos, 4);\n\t\t\t\t}\n\n\t\t\t\tthis_char = ((c & 0x07) << 18) | ((str[pos + 1] & 0x3f) << 12) | ((str[pos + 2] & 0x3f) << 6) | (str[pos + 3] & 0x3f);\n\t\t\t\tif (this_char < 0x10000 || this_char > 0x10FFFF) { \/* non-shortest form or outside range *\/\n\t\t\t\t\tMB_FAILURE(pos, 4);\n\t\t\t\t}\n\t\t\t\tpos += 4;\n\t\t\t} else {\n\t\t\t\tMB_FAILURE(pos, 1);\n\t\t\t}\n\t\t}\n\t\tbreak;","target":0,"flaw_line_index":0,"hash":"73e5ae71-7725-4898-8be6-1f568b139613","idx":"a2dd11b2-8400-464e-971a-afa33547f0b6"}
{"func_before":"static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n}","target":1,"flaw_line_index":0,"hash":"0445e31a-bb99-437b-8332-cd67702d7aba","idx":"3d1a8161-4862-4283-988e-0ff33285e1a3"}
{"func_before":"static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n}","target":0,"flaw_line_index":0,"hash":"0d6cd324-5f1a-4a47-b252-df2e79f471b2","idx":"fcc63961-62df-40c0-af80-340bbc7ddff0"}
{"func_before":"\t * Change file ownership.  Must be the owner or privileged.\n\t *\/\n\tif (mask & FSX_PROJID) {\n\t\t\/*\n\t\t * CAP_FSETID overrides the following restrictions:\n\t\t *\n\t\t * The set-user-ID and set-group-ID bits of a file will be\n\t\t * cleared upon successful return from chown()\n\t\t *\/\n\t\tif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\n\t\t    !inode_capable(VFS_I(ip), CAP_FSETID))\n\t\t\tip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\n\n\t\t\/*\n\t\t * Change the ownerships and register quota modifications\n\t\t * in the transaction.\n\t\t *\/\n\t\tif (xfs_get_projid(ip) != fa->fsx_projid) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_PQUOTA_ON(mp)) {\n\t\t\t\tolddquot = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_pdquot, pdqp);","target":1,"flaw_line_index":0,"hash":"1f1687a1-c465-4e1d-8a4f-6827382489e4","idx":"cb301809-ccb8-4795-92c1-1351861524f1"}
{"func_before":"\t * Change file ownership.  Must be the owner or privileged.\n\t *\/\n\tif (mask & FSX_PROJID) {\n\t\t\/*\n\t\t * CAP_FSETID overrides the following restrictions:\n\t\t *\n\t\t * The set-user-ID and set-group-ID bits of a file will be\n\t\t * cleared upon successful return from chown()\n\t\t *\/\n\t\tif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\n\t\t    !capable_wrt_inode_uidgid(VFS_I(ip), CAP_FSETID))\n\t\t\tip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\n\n\t\t\/*\n\t\t * Change the ownerships and register quota modifications\n\t\t * in the transaction.\n\t\t *\/\n\t\tif (xfs_get_projid(ip) != fa->fsx_projid) {\n\t\t\tif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_PQUOTA_ON(mp)) {\n\t\t\t\tolddquot = xfs_qm_vop_chown(tp, ip,\n\t\t\t\t\t\t\t&ip->i_pdquot, pdqp);","target":0,"flaw_line_index":0,"hash":"d2df4638-ef82-4934-81b7-941dc7ee471c","idx":"30edaabd-5494-448f-b8c0-e4af6e1769df"}
{"func_before":"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_nack(\n\t\t\t\t\tpjmedia_rtcp_session *session,\n\t\t\t\t\tvoid *buf,\n\t\t\t\t\tpj_size_t *length,\n\t\t\t\t\tunsigned nack_cnt,\n\t\t\t\t\tconst pjmedia_rtcp_fb_nack nack[])\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    unsigned len, i;\n\n    PJ_ASSERT_RETURN(session && buf && length && nack_cnt && nack, PJ_EINVAL);\n\n    len = (3 + nack_cnt) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    \/* Build RTCP-FB NACK header *\/\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_RTPFB;\n    hdr->count = 1; \/* FMT = 1 *\/\n    hdr->length = pj_htons((pj_uint16_t)(len\/4 - 1));\n\n    \/* Build RTCP-FB NACK FCI *\/\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < nack_cnt; ++i) {\n\tpj_uint16_t val;\n\tval = pj_htons((pj_uint16_t)nack[i].pid);\n\tpj_memcpy(p, &val, 2);\n\tval = pj_htons(nack[i].blp);\n\tpj_memcpy(p+2, &val, 2);\n\tp += 4;","target":1,"flaw_line_index":0,"hash":"18755f01-8e0a-41ab-846c-22101557bea1","idx":"e08fd90c-8e23-4197-a822-c30df463eeb0"}
{"func_before":"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_build_nack(\n\t\t\t\t\tpjmedia_rtcp_session *session,\n\t\t\t\t\tvoid *buf,\n\t\t\t\t\tpj_size_t *length,\n\t\t\t\t\tunsigned nack_cnt,\n\t\t\t\t\tconst pjmedia_rtcp_fb_nack nack[])\n{\n    pjmedia_rtcp_fb_common *hdr;\n    pj_uint8_t *p;\n    unsigned len, i;\n\n    PJ_ASSERT_RETURN(session && buf && length && nack_cnt && nack, PJ_EINVAL);\n\n    len = (3 + nack_cnt) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    \/* Build RTCP-FB NACK header *\/\n    hdr = (pjmedia_rtcp_fb_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_fb_com, sizeof(*hdr));\n    hdr->rtcp_common.pt = RTCP_RTPFB;\n    hdr->rtcp_common.count = 1; \/* FMT = 1 *\/\n    hdr->rtcp_common.length = pj_htons((pj_uint16_t)(len\/4 - 1));\n\n    \/* Build RTCP-FB NACK FCI *\/\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < nack_cnt; ++i) {\n\tpj_uint16_t val;\n\tval = pj_htons((pj_uint16_t)nack[i].pid);\n\tpj_memcpy(p, &val, 2);\n\tval = pj_htons(nack[i].blp);\n\tpj_memcpy(p+2, &val, 2);\n\tp += 4;","target":0,"flaw_line_index":0,"hash":"f4db6bd5-3c0f-4c61-a452-bc3a52f14a18","idx":"0742b8d9-5254-44aa-832b-52afb7307348"}
{"func_before":"static const char *jsi_evalprint(Jsi_Value *v)\n{\n    static char buf[100];\n    if (!v)\n        return \"nil\";\n    if (v->vt == JSI_VT_NUMBER) {\n        snprintf(buf, 100, \"NUM:%\" JSI_NUMGFMT \" \", v->d.num);\n    } else if (v->vt == JSI_VT_BOOL) {\n        snprintf(buf, 100, \"BOO:%d\", v->d.val);\n    } else if (v->vt == JSI_VT_STRING) {\n        snprintf(buf, 100, \"STR:'%s'\", v->d.s.str);\n    } else if (v->vt == JSI_VT_VARIABLE) {\n        snprintf(buf, 100, \"VAR:%p\", v->d.lval);\n    } else if (v->vt == JSI_VT_NULL) {\n        snprintf(buf, 100, \"NULL\");\n    } else if (v->vt == JSI_VT_OBJECT) {\n        snprintf(buf, 100, \"OBJ:%p\", v->d.obj);\n    } else if (v->vt == JSI_VT_UNDEF) {\n        snprintf(buf, 100, \"UNDEFINED\");\n    }\n    return buf;\n}","target":1,"flaw_line_index":0,"hash":"b61192ac-b529-43d6-a259-346f1dbc54ae","idx":"ad504a2b-1523-44e3-9c9f-5a35f6bcab2e"}
{"func_before":"static const char *jsi_evalprint(Jsi_Value *v)\n{\n    static char buf[JSI_MAX_NUMBER_STRING];\n    if (!v)\n        return \"nil\";\n    if (v->vt == JSI_VT_NUMBER) {\n        snprintf(buf, sizeof(buf), \"NUM:%\" JSI_NUMGFMT \" \", v->d.num);\n    } else if (v->vt == JSI_VT_BOOL) {\n        snprintf(buf, sizeof(buf), \"BOO:%d\", v->d.val);\n    } else if (v->vt == JSI_VT_STRING) {\n        snprintf(buf, sizeof(buf), \"STR:'%s'\", v->d.s.str);\n    } else if (v->vt == JSI_VT_VARIABLE) {\n        snprintf(buf, sizeof(buf), \"VAR:%p\", v->d.lval);\n    } else if (v->vt == JSI_VT_NULL) {\n        snprintf(buf, sizeof(buf), \"NULL\");\n    } else if (v->vt == JSI_VT_OBJECT) {\n        snprintf(buf, sizeof(buf), \"OBJ:%p\", v->d.obj);\n    } else if (v->vt == JSI_VT_UNDEF) {\n        snprintf(buf, sizeof(buf), \"UNDEFINED\");\n    }\n    return buf;\n}","target":0,"flaw_line_index":0,"hash":"71075e41-ba82-40d6-b647-d10a98e0ede6","idx":"a3ba4318-5c78-4950-a10e-d20c9ca60079"}
{"func_before":"        int          GetU8    (int nPos, bool *pbSuccess)\n        {\n            \/\/*pbSuccess = true;\n            if ( nPos < 0 || nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            return m_sFile[ nPos ];\n        }","target":1,"flaw_line_index":0,"hash":"018f4e3b-9de9-43cc-94a0-6ce4dd30cf48","idx":"1631236e-df13-48d5-9c4b-3010e73da680"}
{"func_before":"        int          GetU8    (const unsigned int& nPos, bool *pbSuccess)\n        {\n            \/\/*pbSuccess = true;\n            if ( nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            return m_sFile[ nPos ];\n        }","target":0,"flaw_line_index":0,"hash":"43afc048-d6d1-4c61-ba75-2eaf2172cf9f","idx":"7577b167-a6b0-4a56-81a1-5ae7dc66d925"}
{"func_before":"static void request_key_auth_describe(const struct key *key,\n\t\t\t\t      struct seq_file *m)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\n\tseq_puts(m, \"key:\");\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n}","target":1,"flaw_line_index":0,"hash":"a038d5e0-5c60-4cf2-b2cd-95cfa4d76070","idx":"1726c92e-da51-4e42-8874-f2783ec0d4cf"}
{"func_before":"static void request_key_auth_describe(const struct key *key,\n\t\t\t\t      struct seq_file *m)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\n\tseq_puts(m, \"key:\");\n\tseq_puts(m, key->description);\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n}","target":0,"flaw_line_index":0,"hash":"c4da5a7e-f32a-487b-b8ce-b1e989eec834","idx":"3fa9af01-6e14-4076-8b6b-e508be08de75"}
{"func_before":"  \/\/ vector space so that the vector doesn't resize itself, which could\n  \/\/ invalidate pointers to its strings' data.\n  tensor_proto_strs.reserve(num_components);\n  int64 total_size = 0;\n  for (int i = 0; i < num_components; ++i) {\n    const CompressedComponentMetadata& metadata =\n        compressed.component_metadata(i);\n    if (DataTypeCanUseMemcpy(metadata.dtype())) {\n      out->emplace_back(metadata.dtype(), metadata.tensor_shape());\n      TensorBuffer* buffer = DMAHelper::buffer(&out->back());\n      iov[i].iov_base = buffer->data();\n      iov[i].iov_len = buffer->size();\n    } else {\n      \/\/ Allocate an empty Tensor. We will fill it out later after\n      \/\/ uncompressing into the tensor_proto_str.\n      out->emplace_back();\n      tensor_proto_strs.emplace_back();\n      tstring& tensor_proto_str = tensor_proto_strs.back();\n      tensor_proto_str.resize_uninitialized(metadata.tensor_size_bytes());\n      iov[i].iov_base = tensor_proto_str.mdata();\n      iov[i].iov_len = tensor_proto_str.size();\n    }","target":1,"flaw_line_index":0,"hash":"32c4c296-9950-4bb0-adbe-ba0c0a259281","idx":"55f412d3-394f-4503-9547-8b941c494f22"}
{"func_before":"  \/\/ vector space so that the vector doesn't resize itself, which could\n  \/\/ invalidate pointers to its strings' data.\n  tensor_proto_strs.reserve(num_components);\n  int64 total_size = 0;\n  for (int i = 0; i < num_components; ++i) {\n    const CompressedComponentMetadata& metadata =\n        compressed.component_metadata(i);\n    if (DataTypeCanUseMemcpy(metadata.dtype())) {\n      out->emplace_back(metadata.dtype(), metadata.tensor_shape());\n      TensorBuffer* buffer = DMAHelper::buffer(&out->back());\n      if (buffer) {\n        iov[i].iov_base = buffer->data();\n        iov[i].iov_len = buffer->size();\n      } else {\n        iov[i].iov_base = nullptr;\n        iov[i].iov_len = 0;\n      }\n    } else {\n      \/\/ Allocate an empty Tensor. We will fill it out later after\n      \/\/ uncompressing into the tensor_proto_str.\n      out->emplace_back();\n      tensor_proto_strs.emplace_back();\n      tstring& tensor_proto_str = tensor_proto_strs.back();\n      tensor_proto_str.resize_uninitialized(metadata.tensor_size_bytes());\n      iov[i].iov_base = tensor_proto_str.mdata();\n      iov[i].iov_len = tensor_proto_str.size();\n    }","target":0,"flaw_line_index":0,"hash":"41336272-fa3e-4717-92e2-294b8a1bf43e","idx":"aefbb1d3-c1d3-4278-84bc-a5ed8dcae6a9"}
{"func_before":"iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t interprocess_token)\n{\n    OM_uint32 maj;\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    \/* We don't currently support exporting partially established contexts. *\/\n    if (!ctx->established)\n        return GSS_S_UNAVAILABLE;\n\n    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n                                      interprocess_token);\n    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;","target":1,"flaw_line_index":0,"hash":"50acb5fc-a89e-43f2-87af-adb1f9115588","idx":"8d11e373-b981-4b9b-84db-d7927ea0f1bb"}
{"func_before":"iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t interprocess_token)\n{\n    OM_uint32 maj;\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;\n\n    \/* We don't currently support exporting partially established contexts. *\/\n    if (!ctx->established)\n        return GSS_S_UNAVAILABLE;\n\n    maj = krb5_gss_export_sec_context(minor_status, &ctx->gssc,\n                                      interprocess_token);\n    if (ctx->gssc == GSS_C_NO_CONTEXT) {\n        iakerb_release_context(ctx);\n        *context_handle = GSS_C_NO_CONTEXT;","target":0,"flaw_line_index":0,"hash":"f858fec5-ab62-4683-800e-f7ba05c007f7","idx":"6e22654a-6861-4d03-b984-d7afba8fd4e4"}
{"func_before":"TfLiteStatus EvalQuantized(TfLiteContext* context, TfLiteNode* node,\n                           TfLiteFullyConnectedParams* params, OpData* data,\n                           const TfLiteTensor* input,\n                           const TfLiteTensor* filter, const TfLiteTensor* bias,\n                           TfLiteTensor* output) {\n  int32_t input_offset = -input->params.zero_point;\n  int32_t filter_offset = -filter->params.zero_point;\n  int32_t output_offset = output->params.zero_point;\n  \/\/ Only the Pie path supports quantized models and float inputs\/outputs.\n  if (input->type == kTfLiteFloat32) {\n    TfLiteTensor* input_quantized = GetTemporary(context, node, \/*index=*\/0);\n    TfLiteTensor* scaling_factors = GetTemporary(context, node, \/*index=*\/1);\n    TfLiteTensor* accum_scratch = GetTemporary(context, node, \/*index=*\/2);\n    TfLiteTensor* input_offsets = GetTemporary(context, node, \/*index=*\/3);\n    TfLiteTensor* row_sums = GetTemporary(context, node, \/*index=*\/4);\n    return EvalHybrid(context, node, params, data, input, filter, bias,\n                      input_quantized, scaling_factors, accum_scratch, row_sums,\n                      input_offsets, output);\n  } else {\n    FullyConnectedParams op_params;\n    op_params.input_offset = input_offset;\n    op_params.weights_offset = filter_offset;\n    op_params.output_offset = output_offset;\n    op_params.output_multiplier = data->output_multiplier;\n    op_params.output_shift = data->output_shift;","target":1,"flaw_line_index":0,"hash":"b0925ecc-5fd4-4c40-a8ca-f8ab28171ed3","idx":"1d6dc33c-9c21-4888-875f-2852cc82ad78"}
{"func_before":"TfLiteStatus EvalQuantized(TfLiteContext* context, TfLiteNode* node,\n                           TfLiteFullyConnectedParams* params, OpData* data,\n                           const TfLiteTensor* input,\n                           const TfLiteTensor* filter, const TfLiteTensor* bias,\n                           TfLiteTensor* output) {\n  int32_t input_offset = -input->params.zero_point;\n  int32_t filter_offset = -filter->params.zero_point;\n  int32_t output_offset = output->params.zero_point;\n  \/\/ Only the Pie path supports quantized models and float inputs\/outputs.\n  if (input->type == kTfLiteFloat32) {\n    TfLiteTensor* input_quantized;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, \/*index=*\/0,\n                                                &input_quantized));\n    TfLiteTensor* scaling_factors;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, \/*index=*\/1,\n                                                &scaling_factors));\n    TfLiteTensor* accum_scratch;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, \/*index=*\/2, &accum_scratch));\n    TfLiteTensor* input_offsets;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, \/*index=*\/3, &input_offsets));\n    TfLiteTensor* row_sums;\n    TF_LITE_ENSURE_OK(context,\n                      GetTemporarySafe(context, node, \/*index=*\/4, &row_sums));\n    return EvalHybrid(context, node, params, data, input, filter, bias,\n                      input_quantized, scaling_factors, accum_scratch, row_sums,\n                      input_offsets, output);\n  } else {\n    FullyConnectedParams op_params;\n    op_params.input_offset = input_offset;\n    op_params.weights_offset = filter_offset;\n    op_params.output_offset = output_offset;\n    op_params.output_multiplier = data->output_multiplier;\n    op_params.output_shift = data->output_shift;","target":0,"flaw_line_index":0,"hash":"173b70af-dc19-4bc8-bf8e-4eadf469c727","idx":"119eb181-c460-4583-9213-92693e742675"}
{"func_before":"ripng_print(netdissect_options *ndo, const u_char *dat, unsigned int length)\n{\n\tregister const struct rip6 *rp = (const struct rip6 *)dat;\n\tregister const struct netinfo6 *ni;\n\tregister u_int amt;\n\tregister u_int i;\n\tint j;\n\tint trunc;\n\n\tif (ndo->ndo_snapend < dat)\n\t\treturn;\n\tamt = ndo->ndo_snapend - dat;\n\ti = min(length, amt);\n\tif (i < (sizeof(struct rip6) - sizeof(struct netinfo6)))\n\t\treturn;\n\ti -= (sizeof(struct rip6) - sizeof(struct netinfo6));\n\n\tswitch (rp->rip6_cmd) {\n\n\tcase RIP6_REQUEST:\n\t\tj = length \/ sizeof(*ni);\n\t\tif (j == 1\n\t\t    &&  rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6\n\t\t    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {\n\t\t\tND_PRINT((ndo, \" ripng-req dump\"));\n\t\t\tbreak;\n\t\t}\n\t\tif (j * sizeof(*ni) != length - 4)\n\t\t\tND_PRINT((ndo, \" ripng-req %d[%u]:\", j, length));\n\t\telse\n\t\t\tND_PRINT((ndo, \" ripng-req %d:\", j));\n\t\ttrunc = ((i \/ sizeof(*ni)) * sizeof(*ni) != i);\n\t\tfor (ni = rp->rip6_nets; i >= sizeof(*ni);\n\t\t    i -= sizeof(*ni), ++ni) {\n\t\t\tif (ndo->ndo_vflag > 1)\n\t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\trip6_entry_print(ndo, ni, 0);\n\t\t}\n\t\tbreak;\n\tcase RIP6_RESPONSE:\n\t\tj = length \/ sizeof(*ni);\n\t\tif (j * sizeof(*ni) != length - 4)\n\t\t\tND_PRINT((ndo, \" ripng-resp %d[%u]:\", j, length));\n\t\telse\n\t\t\tND_PRINT((ndo, \" ripng-resp %d:\", j));\n\t\ttrunc = ((i \/ sizeof(*ni)) * sizeof(*ni) != i);\n\t\tfor (ni = rp->rip6_nets; i >= sizeof(*ni);\n\t\t    i -= sizeof(*ni), ++ni) {\n\t\t\tif (ndo->ndo_vflag > 1)\n\t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\trip6_entry_print(ndo, ni, ni->rip6_metric);\n\t\t}\n\t\tif (trunc)\n\t\t\tND_PRINT((ndo, \"[|ripng]\"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \" ripng-%d ?? %u\", rp->rip6_cmd, length));\n\t\tbreak;\n\t}\n\tif (rp->rip6_vers != RIP6_VERSION)\n\t\tND_PRINT((ndo, \" [vers %d]\", rp->rip6_vers));\n}","target":1,"flaw_line_index":0,"hash":"b2b8271f-3441-4053-b400-21720eac1e75","idx":"172b614f-ebca-411f-bcc3-940727275b4f"}
{"func_before":"ripng_print(netdissect_options *ndo, const u_char *dat, unsigned int length)\n{\n\tregister const struct rip6 *rp = (const struct rip6 *)dat;\n\tregister const struct netinfo6 *ni;\n\tunsigned int length_left;\n\tu_int j;\n\n\tND_TCHECK(rp->rip6_cmd);\n\tswitch (rp->rip6_cmd) {\n\n\tcase RIP6_REQUEST:\n\t\tlength_left = length;\n\t\tif (length_left < (sizeof(struct rip6) - sizeof(struct netinfo6)))\n\t\t\tgoto trunc;\n\t\tlength_left -= (sizeof(struct rip6) - sizeof(struct netinfo6));\n \t\tj = length_left \/ sizeof(*ni);\n\t\tif (j == 1) {\n\t\t\tND_TCHECK(rp->rip6_nets);\n\t\t\tif (rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6\n\t\t\t    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {\n\t\t\t\tND_PRINT((ndo, \" ripng-req dump\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j * sizeof(*ni) != length_left)\n\t\t\tND_PRINT((ndo, \" ripng-req %u[%u]:\", j, length));\n\t\telse\n\t\t\tND_PRINT((ndo, \" ripng-req %u:\", j));\n\t\tfor (ni = rp->rip6_nets; length_left >= sizeof(*ni);\n\t\t    length_left -= sizeof(*ni), ++ni) {\n\t\t\tND_TCHECK(*ni);\n\t\t\tif (ndo->ndo_vflag > 1)\n\t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\trip6_entry_print(ndo, ni, 0);\n\t\t}\n\t\tif (length_left != 0)\n\t\t\tgoto trunc;\n\t\tbreak;\n\tcase RIP6_RESPONSE:\n\t\tlength_left = length;\n\t\tif (length_left < (sizeof(struct rip6) - sizeof(struct netinfo6)))\n\t\t\tgoto trunc;\n\t\tlength_left -= (sizeof(struct rip6) - sizeof(struct netinfo6));\n\t\tj = length_left \/ sizeof(*ni);\n\t\tif (j * sizeof(*ni) != length_left)\n\t\t\tND_PRINT((ndo, \" ripng-resp %d[%u]:\", j, length));\n\t\telse\n\t\t\tND_PRINT((ndo, \" ripng-resp %d:\", j));\n\t\tfor (ni = rp->rip6_nets; length_left >= sizeof(*ni);\n\t\t    length_left -= sizeof(*ni), ++ni) {\n\t\t\tND_TCHECK(*ni);\n\t\t\tif (ndo->ndo_vflag > 1)\n\t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\trip6_entry_print(ndo, ni, ni->rip6_metric);\n\t\t}\n\t\tif (length_left != 0)\n\t\t\tgoto trunc;\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \" ripng-%d ?? %u\", rp->rip6_cmd, length));\n\t\tbreak;\n\t}\n\tND_TCHECK(rp->rip6_vers);\n\tif (rp->rip6_vers != RIP6_VERSION)\n\t\tND_PRINT((ndo, \" [vers %d]\", rp->rip6_vers));\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|ripng]\"));\n\treturn;\n}","target":0,"flaw_line_index":0,"hash":"f9a3fed9-c208-4f4f-a218-92301e2ef8c3","idx":"00423dc1-e49a-457e-b684-f0d70b1dc306"}
{"func_before":"\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (tmpstream) {","target":1,"flaw_line_index":0,"hash":"e22d55d1-4409-4125-b9a0-97577a9d511d","idx":"253d40ff-82aa-49d8-8d8e-c0f76d64d312"}
{"func_before":"\tif (jp2_putuint32(out, box->type)) {\n\t\tgoto error;\n\t}\n\tif (extlen) {\n\t\tif (jp2_putuint64(out, box->len)) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len -\n\t\t  JP2_BOX_HDRLEN(false))) {\n\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n\n\treturn 0;\n\nerror:\n\n\tif (tmpstream) {","target":0,"flaw_line_index":0,"hash":"5ff608a9-6b10-4315-b5e8-faff660467ca","idx":"94b4cd5e-8fd6-472b-9262-af17d2810154"}
{"func_before":"\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t    {\n\t\tcan_unload = FALSE;\n\t\tbreak;\n\t    }\n    }\n    if (!can_unload)\n\tsemsg(_(e_attempt_to_delete_buffer_that_is_in_use_str), buf->b_fname);\n    return can_unload;\n}","target":1,"flaw_line_index":0,"hash":"33074cc9-fad3-4d7c-b665-33876f74c87f","idx":"71ef29e0-969f-4e66-b18e-3d048cf63c51"}
{"func_before":"\twin_T\t*wp;\n\n\tFOR_ALL_WINDOWS(wp)\n\t    if (wp->w_buffer == buf)\n\t    {\n\t\tcan_unload = FALSE;\n\t\tbreak;\n\t    }\n    }\n    if (!can_unload)\n    {\n\tchar_u *fname = buf->b_fname != NULL ? buf->b_fname : buf->b_ffname;\n\n\tsemsg(_(e_attempt_to_delete_buffer_that_is_in_use_str),\n\t\t\t\tfname != NULL ? fname : (char_u *)\"[No Name]\");\n    }\n    return can_unload;\n}","target":0,"flaw_line_index":0,"hash":"3b130425-69dd-4385-b228-23c70e474838","idx":"43c4e94e-8ec4-4d9b-9ce7-9825cacfd307"}
{"func_before":"\tExifMnoteDataOlympus *n = (ExifMnoteDataOlympus *) en;\n\tExifShort c;\n\tsize_t i, tcount, o, o2, datao = 6, base = 0;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\to2 = 6 + n->offset; \/* Start of interesting data *\/\n\tif ((o2 + 10 < o2) || (o2 + 10 < 10) || (o2 + 10 > buf_size)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t\/*\n\t * Olympus headers start with \"OLYMP\" and need to have at least\n\t * a size of 22 bytes (6 for 'OLYMP', 2 other bytes, 2 for the\n\t * number of entries, and 12 for one entry.\n\t *\n\t\t\t} else {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase olympusV2:\n\t\t\/* Olympus S760, S770 *\/\n\t\tdatao = o2;\n\t\to2 += 8;\n\t\tif ((o2 + 4 < o2) || (o2 + 4 < 4) || (o2 + 4 > buf_size)) return;\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Olympus maker note v2 (0x%02x, %02x, %02x, %02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3]);\n\n\t\tif ((buf[o2] == 'I') && (buf[o2 + 1] == 'I'))\n\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\telse if ((buf[o2] == 'M') && (buf[o2 + 1] == 'M'))\n\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\n\t\t\/* The number of entries is at position 8+4. *\/\n\t\t\tif (n->order == EXIF_BYTE_ORDER_INTEL) {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\t\t} else {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase nikonV2:\n\t\to2 += 6;\n\t\tif ((o2 + 12 < o2) || (o2 + 12 < 12) || (o2 + 12 > buf_size)) return;\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Nikon maker note v2 (0x%02x, %02x, %02x, \"\n\t\t\t\"%02x, %02x, %02x, %02x, %02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3],\n\t\t\tbuf[o2 + 4], buf[o2 + 5], buf[o2 + 6], buf[o2 + 7]);\n\n\t\t\/* Skip version number *\/\n\t\to2 += 1;\n\n\t\t\/* Skip an unknown byte (00 or 0A). *\/\n\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\tbreak;\n\n\tdefault:\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Unknown Olympus variant %i.\", n->version);\n\t\treturn;\n\t}\n\n\t\/* Sanity check the offset *\/\n\tif ((o2 + 2 < o2) || (o2 + 2 < 2) || (o2 + 2 > buf_size)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t\/* Read the number of tags *\/\n\tc = exif_get_short (buf + o2, n->order);\n\to2 += 2;\n\n\t\/* Remove any old entries *\/\n\tn->entries = exif_mem_alloc (en->mem, sizeof (MnoteOlympusEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteOlympus\", sizeof (MnoteOlympusEntry) * c);\n\t\treturn;\n\t}\n\n\t\/* Parse all c entries, storing ones that are successfully parsed *\/\n\ttcount = 0;\n\tfor (i = c, o = o2; i; --i, o += 12) {\n\t\tsize_t s;\n\t\tif ((o + 12 < o) || (o + 12 < 12) || (o + 12 > buf_size)) {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteOlympus\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t    n->entries[tcount].tag        = exif_get_short (buf + o, n->order) + base;\n\t    n->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t    n->entries[tcount].components = exif_get_long (buf + o + 4, n->order);\n\t    n->entries[tcount].order      = n->order;\n\n\t    exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteOlympus\",\n\t\t      \"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t      mnote_olympus_tag_get_name (n->entries[tcount].tag));\n\/*\t    exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteOlympus\",\n\t\t\t    \"0x%x %d %ld*(%d)\",\n\t\t    n->entries[tcount].tag,\n\t\t    n->entries[tcount].format,\n\t\t    n->entries[tcount].components,\n\t\t    (int)exif_format_get_size(n->entries[tcount].format)); *\/\n\n\t    \/*\n\t     * Size? If bigger than 4 bytes, the actual data is not\n\t     * in the entry but somewhere else (offset).\n\t     *\/\n\t    s = exif_format_get_size (n->entries[tcount].format) *\n\t\t   \t\t\t n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (s) {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4) {\n\t\t\t\t\/* The data in this case is merely a pointer *\/\n\t\t\t\tdataofs = exif_get_long (buf + dataofs, n->order) + datao;\n#ifdef EXIF_OVERCOME_SANYO_OFFSET_BUG\n\t\t\t\t\/* Some Sanyo models (e.g. VPC-C5, C40) suffer from a bug when\n\t\t\t\t * writing the offset for the MNOTE_OLYMPUS_TAG_THUMBNAILIMAGE\n\t\t\t\t * tag in its MakerNote. The offset is actually the absolute\n\t\t\t\t * position in the file instead of the position within the IFD.\n\t\t\t\t *\/\n\t\t\t    if (dataofs + s > buf_size && n->version == sanyoV1) {\n\t\t\t\t\t\/* fix pointer *\/\n\t\t\t\t\tdataofs -= datao + 6;\n\t\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\t  \"ExifMnoteOlympus\",\n\t\t\t\t\t\t  \"Inconsistent thumbnail tag offset; attempting to recover\");\n\t\t\t    }\n#endif\n\t\t\t}\n\t\t\tif ((dataofs + s < dataofs) || (dataofs + s < s) || \n\t\t\t    (dataofs + s > buf_size)) {\n\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t  \"ExifMnoteOlympus\",\n\t\t\t\t\t  \"Tag data past end of buffer (%u > %u)\",\n\t\t\t\t\t  (unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (en->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteOlympus\", s);","target":1,"flaw_line_index":0,"hash":"b9e8cf30-e152-4942-9bd0-1b3da0e3936f","idx":"0e972e7b-3018-4e0c-907c-a8387e84f05f"}
{"func_before":"\tExifMnoteDataOlympus *n = (ExifMnoteDataOlympus *) en;\n\tExifShort c;\n\tsize_t i, tcount, o, o2, datao = 6, base = 0;\n\n\tif (!n || !buf || !buf_size) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\to2 = 6 + n->offset; \/* Start of interesting data *\/\n\tif (CHECKOVERFLOW(o2,buf_size,10)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t\/*\n\t * Olympus headers start with \"OLYMP\" and need to have at least\n\t * a size of 22 bytes (6 for 'OLYMP', 2 other bytes, 2 for the\n\t * number of entries, and 12 for one entry.\n\t *\n\t\t\t} else {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase olympusV2:\n\t\t\/* Olympus S760, S770 *\/\n\t\tdatao = o2;\n\t\to2 += 8;\n\t\tif (CHECKOVERFLOW(o2,buf_size,4)) return;\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Olympus maker note v2 (0x%02x, %02x, %02x, %02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3]);\n\n\t\tif ((buf[o2] == 'I') && (buf[o2 + 1] == 'I'))\n\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\telse if ((buf[o2] == 'M') && (buf[o2 + 1] == 'M'))\n\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\n\t\t\/* The number of entries is at position 8+4. *\/\n\t\t\tif (n->order == EXIF_BYTE_ORDER_INTEL) {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\t\t} else {\n\t\t\t\tn->order = EXIF_BYTE_ORDER_INTEL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase nikonV2:\n\t\to2 += 6;\n\t\tif (CHECKOVERFLOW(o2,buf_size,12)) return;\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Nikon maker note v2 (0x%02x, %02x, %02x, \"\n\t\t\t\"%02x, %02x, %02x, %02x, %02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3],\n\t\t\tbuf[o2 + 4], buf[o2 + 5], buf[o2 + 6], buf[o2 + 7]);\n\n\t\t\/* Skip version number *\/\n\t\to2 += 1;\n\n\t\t\/* Skip an unknown byte (00 or 0A). *\/\n\t\tn->order = EXIF_BYTE_ORDER_MOTOROLA;\n\t\tbreak;\n\n\tdefault:\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Unknown Olympus variant %i.\", n->version);\n\t\treturn;\n\t}\n\n\t\/* Sanity check the offset *\/\n\tif (CHECKOVERFLOW(o2,buf_size,2)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\t\/* Read the number of tags *\/\n\tc = exif_get_short (buf + o2, n->order);\n\to2 += 2;\n\n\t\/* Remove any old entries *\/\n\tn->entries = exif_mem_alloc (en->mem, sizeof (MnoteOlympusEntry) * c);\n\tif (!n->entries) {\n\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteOlympus\", sizeof (MnoteOlympusEntry) * c);\n\t\treturn;\n\t}\n\n\t\/* Parse all c entries, storing ones that are successfully parsed *\/\n\ttcount = 0;\n\tfor (i = c, o = o2; i; --i, o += 12) {\n\t\tsize_t s;\n\t\tif (CHECKOVERFLOW(o, buf_size, 12)) {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteOlympus\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t    n->entries[tcount].tag        = exif_get_short (buf + o, n->order) + base;\n\t    n->entries[tcount].format     = exif_get_short (buf + o + 2, n->order);\n\t    n->entries[tcount].components = exif_get_long (buf + o + 4, n->order);\n\t    n->entries[tcount].order      = n->order;\n\n\t    exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteOlympus\",\n\t\t      \"Loading entry 0x%x ('%s')...\", n->entries[tcount].tag,\n\t\t      mnote_olympus_tag_get_name (n->entries[tcount].tag));\n\/*\t    exif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteOlympus\",\n\t\t\t    \"0x%x %d %ld*(%d)\",\n\t\t    n->entries[tcount].tag,\n\t\t    n->entries[tcount].format,\n\t\t    n->entries[tcount].components,\n\t\t    (int)exif_format_get_size(n->entries[tcount].format)); *\/\n\n\t    \/* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n\t     * we will check the buffer sizes closer later. *\/\n\t    if (exif_format_get_size (n->entries[tcount].format) &&\n\t\tbuf_size \/ exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n\t    ) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifMnoteOlympus\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n\t\tcontinue;\n\t    }\n\t    \/*\n\t     * Size? If bigger than 4 bytes, the actual data is not\n\t     * in the entry but somewhere else (offset).\n\t     *\/\n\t    s = exif_format_get_size (n->entries[tcount].format) *\n\t\t   \t\t\t n->entries[tcount].components;\n\t\tn->entries[tcount].size = s;\n\t\tif (s) {\n\t\t\tsize_t dataofs = o + 8;\n\t\t\tif (s > 4) {\n\t\t\t\t\/* The data in this case is merely a pointer *\/\n\t\t\t\tdataofs = exif_get_long (buf + dataofs, n->order) + datao;\n#ifdef EXIF_OVERCOME_SANYO_OFFSET_BUG\n\t\t\t\t\/* Some Sanyo models (e.g. VPC-C5, C40) suffer from a bug when\n\t\t\t\t * writing the offset for the MNOTE_OLYMPUS_TAG_THUMBNAILIMAGE\n\t\t\t\t * tag in its MakerNote. The offset is actually the absolute\n\t\t\t\t * position in the file instead of the position within the IFD.\n\t\t\t\t *\/\n\t\t\t    if (dataofs > (buf_size - s) && n->version == sanyoV1) {\n\t\t\t\t\t\/* fix pointer *\/\n\t\t\t\t\tdataofs -= datao + 6;\n\t\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\t  \"ExifMnoteOlympus\",\n\t\t\t\t\t\t  \"Inconsistent thumbnail tag offset; attempting to recover\");\n\t\t\t    }\n#endif\n\t\t\t}\n\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t  \"ExifMnoteOlympus\",\n\t\t\t\t\t  \"Tag data past end of buffer (%u > %u)\",\n\t\t\t\t\t  (unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tn->entries[tcount].data = exif_mem_alloc (en->mem, s);\n\t\t\tif (!n->entries[tcount].data) {\n\t\t\t\tEXIF_LOG_NO_MEMORY(en->log, \"ExifMnoteOlympus\", s);","target":0,"flaw_line_index":0,"hash":"50fdb129-6299-42cb-905d-f7adcf6fcf0d","idx":"eaa52c1f-d543-46e7-ae62-24d25addd4ae"}
{"func_before":"    exarg_T *eap,\n    int\t    deep,\n    void    *coookie)\n{\n    cctx_T\t*cctx = coookie;\n    int\t\tcc = *name_end;\n    char_u\t*p = lvp->ll_name;\n    int\t\tret = OK;\n    size_t\tlen;\n    char_u\t*buf;\n    isntype_T\tisn = ISN_EXEC;\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    \/\/ Cannot use :lockvar and :unlockvar on local variables.\n    if (p[1] != ':')\n    {\n\tchar_u *end = find_name_end(p, NULL, NULL, FNE_CHECK_START);\n\n\tif (lookup_local(p, end - p, NULL, cctx) == OK)\n\t{\n\t    char_u *s = p;\n\n    }\n\n    \/\/ Checking is done at runtime.\n    *name_end = NUL;\n    len = name_end - p + 20;\n    buf = alloc(len);\n    if (buf == NULL)\n\tret = FAIL;\n    else\n    {\n\tchar *cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\";\n\n\tif (deep < 0)\n\t    vim_snprintf((char *)buf, len, \"%s! %s\", cmd, p);\n\telse\n\t    vim_snprintf((char *)buf, len, \"%s %d %s\", cmd, deep, p);\n\tret = generate_EXEC_copy(cctx, isn, buf);\n\n\tvim_free(buf);\n\t*name_end = cc;\n    }\n    return ret;","target":1,"flaw_line_index":0,"hash":"8b0b6a07-9463-4b66-9fea-0b635d4faffb","idx":"9181c746-1603-4b18-b3f4-4bb0152c2c1f"}
{"func_before":"    int\t    deep,\n    void    *coookie)\n{\n    cctx_T\t*cctx = coookie;\n    int\t\tcc = *name_end;\n    char_u\t*p = lvp->ll_name;\n    int\t\tret = OK;\n    size_t\tlen;\n    char_u\t*buf;\n    isntype_T\tisn = ISN_EXEC;\n    char\t*cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\";\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    if (*p == NUL)\n    {\n\tsemsg(_(e_argument_required_for_str), cmd);\n\treturn FAIL;\n    }\n\n    \/\/ Cannot use :lockvar and :unlockvar on local variables.\n    if (p[1] != ':')\n    {\n\tchar_u *end = find_name_end(p, NULL, NULL, FNE_CHECK_START);\n\n\tif (lookup_local(p, end - p, NULL, cctx) == OK)\n\t{\n\t    char_u *s = p;\n\n\t}\n    }\n\n    \/\/ Checking is done at runtime.\n    *name_end = NUL;\n    len = name_end - p + 20;\n    buf = alloc(len);\n    if (buf == NULL)\n\tret = FAIL;\n    else\n    {\n\tif (deep < 0)\n\t    vim_snprintf((char *)buf, len, \"%s! %s\", cmd, p);\n\telse\n\t    vim_snprintf((char *)buf, len, \"%s %d %s\", cmd, deep, p);\n\tret = generate_EXEC_copy(cctx, isn, buf);\n\n\tvim_free(buf);\n\t*name_end = cc;\n    }\n    return ret;","target":0,"flaw_line_index":0,"hash":"d05c89f5-148f-45a7-aa6e-48cb27ce9bc1","idx":"cdde6c46-c225-4616-94aa-5c460c355ade"}
{"func_before":"cssp_read_tsrequest(STREAM token, STREAM pubkey)\n{\n\tSTREAM s;\n\tint length;\n\tint tagval;\n\n\ts = tcp_recv(NULL, 4);\n\n\tif (s == NULL)\n\t\treturn False;\n\n\t\/\/ verify ASN.1 header\n\tif (s->p[0] != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t{\n\t\tlogger(Protocol, Error,\n\tif (s->p[1] < 0x80)\n\t\tlength = s->p[1] - 2;\n\telse if (s->p[1] == 0x81)\n\t\tlength = s->p[2] - 1;\n\telse if (s->p[1] == 0x82)\n\t\tlength = (s->p[2] << 8) | s->p[3];\n\telse\n\t\treturn False;\n\n\t\/\/ receive the remainings of message\n\ts = tcp_recv(s, length);\n\n\t\/\/ parse the response and into nego token\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\treturn False;\n\n\t\/\/ version [0]\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\treturn False;\n\tin_uint8s(s, length);\n\n\t\/\/ negoToken [1]\n\tif (token)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\t\treturn False;\n\n\t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)\n\t\t\treturn False;\n\n\t\ttoken->end = token->p = token->data;\n\t\tout_uint8p(token, s->p, length);\n\t\ts_mark_end(token);\n\t}\n\n\t\/\/ pubKey [3]\n\tif (pubkey)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3))\n\t\t\treturn False;","target":1,"flaw_line_index":0,"hash":"abb1f440-4e37-4e9e-81f4-137b28c2733e","idx":"1d9c4417-c1da-4481-a95d-a8bacb2f6c6e"}
{"func_before":"cssp_read_tsrequest(STREAM token, STREAM pubkey)\n{\n\tSTREAM s;\n\tint length;\n\tint tagval;\n\tstruct stream packet;\n\n\ts = tcp_recv(NULL, 4);\n\n\tif (s == NULL)\n\t\treturn False;\n\n\t\/\/ verify ASN.1 header\n\tif (s->p[0] != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t{\n\t\tlogger(Protocol, Error,\n\t\tlength = s->p[1] - 2;\n\telse if (s->p[1] == 0x81)\n\t\tlength = s->p[2] - 1;\n\telse if (s->p[1] == 0x82)\n\t\tlength = (s->p[2] << 8) | s->p[3];\n\telse\n\t\treturn False;\n\n\t\/\/ receive the remainings of message\n\ts = tcp_recv(s, length);\n\tpacket = *s;\n\n\t\/\/ parse the response and into nego token\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\treturn False;\n\n\t\/\/ version [0]\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\treturn False;\n\n\tif (!s_check_rem(s, length))\n\t{\n\t\t rdp_protocol_error(\"cssp_read_tsrequest(), consume of version from stream would overrun\",\n\t\t\t\t    &packet);\n\t}\n\tin_uint8s(s, length);\n\n\t\/\/ negoToken [1]\n\tif (token)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\t\treturn False;\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\t\treturn False;\n\n\t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)\n\t\t\treturn False;\n\n\t\tif (!s_check_rem(s, length))\n\t\t{\n\t\t\trdp_protocol_error(\"cssp_read_tsrequest(), consume of token from stream would overrun\",\n\t\t\t\t\t   &packet);\n\t\t}\n\n\t\ts_realloc(token, length);\n\t\ts_reset(token);\n\t\tout_uint8p(token, s->p, length);\n\t\ts_mark_end(token);\n\t}\n\n\t\/\/ pubKey [3]\n\tif (pubkey)\n\t{\n\t\tif (!ber_in_header(s, &tagval, &length)\n\t\t    || tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 3))\n\t\t\treturn False;","target":0,"flaw_line_index":0,"hash":"e26fc317-7a62-4d5c-b3bc-e94f5e5c6787","idx":"a7241108-c082-4a96-9ac1-e81d958555f6"}
{"func_before":"    else if (varp == &p_imak)\n    {\n\tif (gui.in_use && !im_xim_isvalid_imactivate())\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_KEYMAP\n    else if (varp == &curbuf->b_p_keymap)\n    {\n\t\/* load or unload key mapping tables *\/\n\terrmsg = keymap_init();\n\n\tif (errmsg == NULL)\n\t{\n\t    if (*curbuf->b_p_keymap != NUL)\n\t    {\n\t\t\/* Installed a new keymap, switch on using it. *\/\n\t\tcurbuf->b_p_iminsert = B_IMODE_LMAP;\n\t\tif (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)\n\t\t    curbuf->b_p_imsearch = B_IMODE_LMAP;\n\t    }\n    }\n#endif\n\n#if defined(FEAT_RENDER_OPTIONS)\n    else if (varp == &p_rop && gui.in_use)\n    {\n\tif (!gui_mch_set_rendering_options(p_rop))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    \/* Options that are a list of flags. *\/\n    else\n    {\n\tp = NULL;\n\tif (varp == &p_ww)\n\t    p = (char_u *)WW_ALL;\n\tif (varp == &p_shm)\n\t    p = (char_u *)SHM_ALL;\n\telse if (varp == &(p_cpo))\n\t    p = (char_u *)CPO_ALL;","target":1,"flaw_line_index":0,"hash":"daff2754-f318-47b4-b194-e28b284f717f","idx":"ce703f71-1496-43c8-9762-2f359631a53b"}
{"func_before":"    else if (varp == &p_imak)\n    {\n\tif (gui.in_use && !im_xim_isvalid_imactivate())\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_KEYMAP\n    else if (varp == &curbuf->b_p_keymap)\n    {\n\tif (!valid_filetype(*varp))\n\t    errmsg = e_invarg;\n\telse\n\t    \/* load or unload key mapping tables *\/\n\t    errmsg = keymap_init();\n\n\tif (errmsg == NULL)\n\t{\n\t    if (*curbuf->b_p_keymap != NUL)\n\t    {\n\t\t\/* Installed a new keymap, switch on using it. *\/\n\t\tcurbuf->b_p_iminsert = B_IMODE_LMAP;\n\t\tif (curbuf->b_p_imsearch != B_IMODE_USE_INSERT)\n\t\t    curbuf->b_p_imsearch = B_IMODE_LMAP;\n\t    }\n#endif\n\n#if defined(FEAT_RENDER_OPTIONS)\n    else if (varp == &p_rop && gui.in_use)\n    {\n\tif (!gui_mch_set_rendering_options(p_rop))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_AUTOCMD\n    else if (gvarp == &p_ft)\n    {\n\tif (!valid_filetype(*varp))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_SYN_HL\n    else if (gvarp == &p_syn)\n    {\n\tif (!valid_filetype(*varp))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    \/* Options that are a list of flags. *\/\n    else\n    {\n\tp = NULL;\n\tif (varp == &p_ww)\n\t    p = (char_u *)WW_ALL;\n\tif (varp == &p_shm)\n\t    p = (char_u *)SHM_ALL;\n\telse if (varp == &(p_cpo))\n\t    p = (char_u *)CPO_ALL;","target":0,"flaw_line_index":0,"hash":"24f9928d-6292-427c-8460-020dd3738a65","idx":"9f3d1de1-0144-4f81-a17b-9cfcd199e4e2"}
{"func_before":"            switch(rsvp_obj_ctype) {\n\t\tint subobj_type,af,subobj_len,total_subobj_len;\n\n            case RSVP_CTYPE_1:\n\n                if (obj_tlen < 4)\n                    return-1;\n\n\t\t\/* read variable length subobjects *\/\n\t\ttotal_subobj_len = obj_tlen;\n                while(total_subobj_len > 0) {\n                    subobj_len  = EXTRACT_16BITS(obj_tptr);\n                    subobj_type = (EXTRACT_16BITS(obj_tptr+2))>>8;\n                    af = (EXTRACT_16BITS(obj_tptr+2))&0x00FF;\n\n                    ND_PRINT((ndo, \"%s  Subobject Type: %s (%u), AF: %s (%u), length: %u\",\n                           ident,\n                           tok2str(rsvp_obj_generalized_uni_values, \"Unknown\", subobj_type),\n                           subobj_type,\n                           tok2str(af_values, \"Unknown\", af), af,\n                           subobj_len));\n\n                    if(subobj_len == 0)\n                        goto invalid;\n\n                    switch(subobj_type) {\n                    case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS:\n                    case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS:\n\n                        switch(af) {\n                        case AFNUM_INET:\n                            if (subobj_len < 8)\n                                return -1;","target":1,"flaw_line_index":0,"hash":"6b4d6018-e4be-4905-a997-f88371a7a558","idx":"ea0e12a6-ab23-4303-8c26-a30b48637f9c"}
{"func_before":"\t\tint subobj_type,af,subobj_len,total_subobj_len;\n\n            case RSVP_CTYPE_1:\n\n                if (obj_tlen < 4)\n                    return-1;\n\n\t\t\/* read variable length subobjects *\/\n\t\ttotal_subobj_len = obj_tlen;\n                while(total_subobj_len > 0) {\n                    \/* If RFC 3476 Section 3.1 defined that a sub-object of the\n                     * GENERALIZED_UNI RSVP object must have the Length field as\n                     * a multiple of 4, instead of the check below it would be\n                     * better to test total_subobj_len only once before the loop.\n                     * So long as it does not define it and this while loop does\n                     * not implement such a requirement, let's accept that within\n                     * each iteration subobj_len may happen to be a multiple of 1\n                     * and test it and total_subobj_len respectively.\n                     *\/\n                    if (total_subobj_len < 4)\n                        goto invalid;\n                    subobj_len  = EXTRACT_16BITS(obj_tptr);\n                    subobj_type = (EXTRACT_16BITS(obj_tptr+2))>>8;\n                    af = (EXTRACT_16BITS(obj_tptr+2))&0x00FF;\n\n                    ND_PRINT((ndo, \"%s  Subobject Type: %s (%u), AF: %s (%u), length: %u\",\n                           ident,\n                           tok2str(rsvp_obj_generalized_uni_values, \"Unknown\", subobj_type),\n                           subobj_type,\n                           tok2str(af_values, \"Unknown\", af), af,\n                           subobj_len));\n\n                    \/* In addition to what is explained above, the same spec does not\n                     * explicitly say that the same Length field includes the 4-octet\n                     * sub-object header, but as long as this while loop implements it\n                     * as it does include, let's keep the check below consistent with\n                     * the rest of the code.\n                     *\/\n                    if(subobj_len < 4 || subobj_len > total_subobj_len)\n                        goto invalid;\n\n                    switch(subobj_type) {\n                    case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS:\n                    case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS:\n\n                        switch(af) {\n                        case AFNUM_INET:\n                            if (subobj_len < 8)\n                                return -1;","target":0,"flaw_line_index":0,"hash":"4ac4715b-ffc3-4fbb-8ce2-bf5b53e59067","idx":"547aff6b-c36c-4438-8c68-088cad741974"}
{"func_before":"static pj_status_t transport_destroy  (pjmedia_transport *tp)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n\n    \/* Close the slave transport *\/\n    if (adapter->del_base) {\n        pjmedia_transport_close(adapter->slave_tp);\n    }\n\n    \/* Self destruct.. *\/\n    pj_pool_release(adapter->pool);\n\n    return PJ_SUCCESS;\n}","target":1,"flaw_line_index":0,"hash":"1f95941a-b37a-4856-bc4d-7a80ab4a8a5d","idx":"ce84a717-6c21-4ce6-ac65-622a6a9cd599"}
{"func_before":"static pj_status_t transport_destroy  (pjmedia_transport *tp)\n{\n    struct tp_adapter *adapter = (struct tp_adapter*)tp;\n\n    \/* Close the slave transport *\/\n    if (adapter->del_base) {\n        pjmedia_transport_close(adapter->slave_tp);\n    }\n\n    if (adapter->base.grp_lock) {\n        pj_grp_lock_dec_ref(adapter->base.grp_lock);\n    } else {\n        adapter_on_destroy(tp);\n    }\n\n    return PJ_SUCCESS;\n}","target":0,"flaw_line_index":0,"hash":"6b1491f5-7acc-400e-a080-bca56911a1de","idx":"627247fb-6758-4af6-8ac7-05f5016ed6e1"}
{"func_before":"static struct ip_options *ip_options_get_alloc(const int optlen)\n{\n\treturn kzalloc(sizeof(struct ip_options) + ((optlen + 3) & ~3),\n\t\t       GFP_KERNEL);\n}","target":1,"flaw_line_index":0,"hash":"c235f726-a159-4945-8b13-58f5894ccc18","idx":"bfbab408-5e94-4ad7-af62-79cb3376ecb1"}
{"func_before":"static struct ip_options_rcu *ip_options_get_alloc(const int optlen)\n{\n\treturn kzalloc(sizeof(struct ip_options_rcu) + ((optlen + 3) & ~3),\n\t\t       GFP_KERNEL);\n}","target":0,"flaw_line_index":0,"hash":"a1a64a83-0842-40ff-96c8-43fcbc5264c6","idx":"d7310fe2-34f3-4950-8045-6837c6e9f78e"}
{"func_before":"otError Commissioner::GeneratePskc(const char *              aPassPhrase,\n                                   const char *              aNetworkName,\n                                   const Mac::ExtendedPanId &aExtPanId,\n                                   Pskc &                    aPskc)\n{\n    otError     error      = OT_ERROR_NONE;\n    const char *saltPrefix = \"Thread\";\n    uint8_t     salt[OT_PBKDF2_SALT_MAX_LEN];\n    uint16_t    saltLen = 0;\n\n    VerifyOrExit((strlen(aPassPhrase) >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&\n                     (strlen(aPassPhrase) <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE) &&\n                     (strlen(aNetworkName) <= OT_NETWORK_NAME_MAX_SIZE),\n                 error = OT_ERROR_INVALID_ARGS);\n\n    memset(salt, 0, sizeof(salt));\n    memcpy(salt, saltPrefix, strlen(saltPrefix));\n    saltLen += static_cast<uint16_t>(strlen(saltPrefix));\n\n    memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId));\n    saltLen += OT_EXT_PAN_ID_SIZE;\n\n    memcpy(salt + saltLen, aNetworkName, strlen(aNetworkName));\n    saltLen += static_cast<uint16_t>(strlen(aNetworkName));\n\n    otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), static_cast<uint16_t>(strlen(aPassPhrase)),\n                 reinterpret_cast<const uint8_t *>(salt), saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);\n\nexit:\n    return error;\n}","target":1,"flaw_line_index":0,"hash":"bc8de39b-9b37-4799-9df4-183dc997ab0e","idx":"6076a4db-32f9-4dc2-b5bf-1dda9655ac05"}
{"func_before":"otError Commissioner::GeneratePskc(const char *              aPassPhrase,\n                                   const char *              aNetworkName,\n                                   const Mac::ExtendedPanId &aExtPanId,\n                                   Pskc &                    aPskc)\n{\n    otError    error        = OT_ERROR_NONE;\n    const char saltPrefix[] = \"Thread\";\n    uint8_t    salt[OT_PBKDF2_SALT_MAX_LEN];\n    uint16_t   saltLen = 0;\n    uint16_t   passphraseLen;\n    uint8_t    networkNameLen;\n\n    passphraseLen  = static_cast<uint16_t>(strnlen(aPassPhrase, OT_COMMISSIONING_PASSPHRASE_MAX_SIZE + 1));\n    networkNameLen = static_cast<uint8_t>(strnlen(aNetworkName, OT_NETWORK_NAME_MAX_SIZE + 1));\n\n    VerifyOrExit((passphraseLen >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&\n                     (passphraseLen <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE) &&\n                     (networkNameLen <= OT_NETWORK_NAME_MAX_SIZE),\n                 error = OT_ERROR_INVALID_ARGS);\n\n    memset(salt, 0, sizeof(salt));\n    memcpy(salt, saltPrefix, sizeof(saltPrefix) - 1);\n    saltLen += static_cast<uint16_t>(sizeof(saltPrefix) - 1);\n\n    memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId));\n    saltLen += OT_EXT_PAN_ID_SIZE;\n\n    memcpy(salt + saltLen, aNetworkName, networkNameLen);\n    saltLen += networkNameLen;\n\n    otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), passphraseLen, reinterpret_cast<const uint8_t *>(salt),\n                 saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);\n\nexit:\n    return error;\n}","target":0,"flaw_line_index":0,"hash":"cde527fd-bd75-4999-9a2d-9ca262193630","idx":"b540ff46-68c6-4973-b307-9e350ff03e0c"}
{"func_before":"static __inline__ void scm_set_cred(struct scm_cookie *scm,\n\t\t\t\t    struct pid *pid, const struct cred *cred)\n{\n\tscm->pid  = get_pid(pid);\n\tscm->cred = cred ? get_cred(cred) : NULL;\n\tscm->creds.pid = pid_vnr(pid);\n\tscm->creds.uid = cred ? cred->euid : INVALID_UID;\n\tscm->creds.gid = cred ? cred->egid : INVALID_GID;\n}","target":1,"flaw_line_index":0,"hash":"210424b0-40f8-4623-a473-3392530537f0","idx":"7489c704-52b1-426d-aaf0-535c018ec733"}
{"func_before":"static __inline__ void scm_set_cred(struct scm_cookie *scm,\n\t\t\t\t    struct pid *pid, const struct cred *cred)\n{\n\tscm->pid  = get_pid(pid);\n\tscm->cred = cred ? get_cred(cred) : NULL;\n\tscm->creds.pid = pid_vnr(pid);\n\tscm->creds.uid = cred ? cred->uid : INVALID_UID;\n\tscm->creds.gid = cred ? cred->gid : INVALID_GID;\n}","target":0,"flaw_line_index":0,"hash":"87b34807-2ac0-4658-9be7-48ad862c082e","idx":"6fe2a9b1-0af3-4414-a3e6-06f9967e5953"}
{"func_before":"\tu8 *out_buf;\n\tint ret;\n\n\tif (buf[0] != REPORT_TYPE_LEDS)\n\t\treturn -EINVAL;\n\n\tout_buf = kzalloc(DJREPORT_SHORT_LENGTH, GFP_ATOMIC);\n\tif (!out_buf)\n\t\treturn -ENOMEM;\n\n\tif (count < DJREPORT_SHORT_LENGTH - 2)\n\t\tcount = DJREPORT_SHORT_LENGTH - 2;\n\n\tout_buf[0] = REPORT_ID_DJ_SHORT;\n\tout_buf[1] = djdev->device_index;\n\tmemcpy(out_buf + 2, buf, count);\n\n\tret = hid_hw_raw_request(djrcv_dev->hdev, out_buf[0], out_buf,\n\t\tDJREPORT_SHORT_LENGTH, report_type, reqtype);\n\n\tkfree(out_buf);","target":1,"flaw_line_index":0,"hash":"e278af1c-1bea-4c3f-862b-64e4f1f10ae5","idx":"5ab16fcd-a4c8-4eab-bf1d-5e1b9db6f11a"}
{"func_before":"\tu8 *out_buf;\n\tint ret;\n\n\tif (buf[0] != REPORT_TYPE_LEDS)\n\t\treturn -EINVAL;\n\n\tout_buf = kzalloc(DJREPORT_SHORT_LENGTH, GFP_ATOMIC);\n\tif (!out_buf)\n\t\treturn -ENOMEM;\n\n\tif (count > DJREPORT_SHORT_LENGTH - 2)\n\t\tcount = DJREPORT_SHORT_LENGTH - 2;\n\n\tout_buf[0] = REPORT_ID_DJ_SHORT;\n\tout_buf[1] = djdev->device_index;\n\tmemcpy(out_buf + 2, buf, count);\n\n\tret = hid_hw_raw_request(djrcv_dev->hdev, out_buf[0], out_buf,\n\t\tDJREPORT_SHORT_LENGTH, report_type, reqtype);\n\n\tkfree(out_buf);","target":0,"flaw_line_index":0,"hash":"f73647f0-89d4-4df1-ad5a-d6a6224fb24e","idx":"0be21161-53aa-462d-b0fe-972e2d772f29"}
{"func_before":"    res = _gdContributionsAlloc(line_size, windows_size);\n\n    for (u = 0; u < line_size; u++) {\n        const double dCenter = (double)u \/ scale_d;\n        \/* get the significant edge points affecting the pixel *\/\n        register int iLeft = MAX(0, (int)floor (dCenter - width_d));\n        int iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n        double dTotalWeight = 0.0;\n\t\tint iSrc;\n\n        res->ContribRow[u].Left = iLeft;\n        res->ContribRow[u].Right = iRight;\n\n        \/* Cut edge points to fit in filter window in case of spill-off *\/\n        if (iRight - iLeft + 1 > windows_size)  {\n            if (iLeft < ((int)src_size - 1 \/ 2))  {\n                iLeft++;\n            } else {\n                iRight--;\n            }\n        }\n\n        for (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n            dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n        }\n\n\t\tif (dTotalWeight < 0.0) {\n\t\t\t_gdContributionsFree(res);\n\t\t\treturn NULL;\n\t\t}\n","target":1,"flaw_line_index":0,"hash":"e415989f-d9d1-4e9a-84c3-17813ca2619f","idx":"0251565c-43a3-410b-b168-8da86226ee23"}
{"func_before":"    windows_size = 2 * (int)ceil(width_d) + 1;\n    res = _gdContributionsAlloc(line_size, windows_size);\n\n    for (u = 0; u < line_size; u++) {\n        const double dCenter = (double)u \/ scale_d;\n        \/* get the significant edge points affecting the pixel *\/\n        register int iLeft = MAX(0, (int)floor (dCenter - width_d));\n        int iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n        double dTotalWeight = 0.0;\n\t\tint iSrc;\n\n        \/* Cut edge points to fit in filter window in case of spill-off *\/\n        if (iRight - iLeft + 1 > windows_size)  {\n            if (iLeft < ((int)src_size - 1 \/ 2))  {\n                iLeft++;\n            } else {\n                iRight--;\n            }\n        }\n\n        res->ContribRow[u].Left = iLeft;\n        res->ContribRow[u].Right = iRight;\n\n        for (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n            dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n        }\n\n\t\tif (dTotalWeight < 0.0) {\n\t\t\t_gdContributionsFree(res);\n\t\t\treturn NULL;\n\t\t}\n","target":0,"flaw_line_index":0,"hash":"ff6a2019-a91a-4bef-8844-6ec0ce23b8b7","idx":"1677320a-f687-43b9-b102-cc0637eebda8"}
{"func_before":"void ed_mul_sim_trick(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\t\tconst bn_t m) {\n\ted_t t0[1 << (ED_WIDTH \/ 2)], t1[1 << (ED_WIDTH \/ 2)], t[1 << ED_WIDTH];\n\tbn_t n;\n\tint l0, l1, w = ED_WIDTH \/ 2;\n\tuint8_t w0[RLC_FP_BITS + 1], w1[RLC_FP_BITS + 1];\n\n\tbn_null(n);\n\n\tif (bn_is_zero(k) || ed_is_infty(p)) {\n\t\ted_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ed_is_infty(q)) {\n\t\ted_mul(r, p, k);","target":1,"flaw_line_index":0,"hash":"ecf64bc5-d91a-4f10-84bb-da58a59fd476","idx":"17e24150-5f0c-4800-8d2b-4a8f87341038"}
{"func_before":"void ed_mul_sim_trick(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\t\tconst bn_t m) {\n\ted_t t0[1 << (ED_WIDTH \/ 2)], t1[1 << (ED_WIDTH \/ 2)], t[1 << ED_WIDTH];\n\tbn_t n;\n\tsize_t l0, l1, w = ED_WIDTH \/ 2;\n\tuint8_t w0[RLC_FP_BITS + 1], w1[RLC_FP_BITS + 1];\n\n\tbn_null(n);\n\n\tif (bn_is_zero(k) || ed_is_infty(p)) {\n\t\ted_mul(r, q, m);\n\t\treturn;\n\t}\n\tif (bn_is_zero(m) || ed_is_infty(q)) {\n\t\ted_mul(r, p, k);","target":0,"flaw_line_index":0,"hash":"1686fc3a-72a4-44e6-9d5a-8ff8740581f7","idx":"f18be165-a773-4ea2-96ca-9174e48de590"}
{"func_before":"                continue;\n            }\n            vol++;\n            if ((ret = decode_vol_header(ctx, gb)) < 0)\n                return ret;\n        } else if (startcode == USER_DATA_STARTCODE) {\n            decode_user_data(ctx, gb);\n        } else if (startcode == GOP_STARTCODE) {\n            mpeg4_decode_gop_header(s, gb);\n        } else if (startcode == VOS_STARTCODE) {\n            mpeg4_decode_profile_level(s, gb);\n            if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n                (s->avctx->level > 0 && s->avctx->level < 9)) {\n                s->studio_profile = 1;\n                next_start_code_studio(gb);\n                extension_and_user_data(s, gb, 0);\n            }\n        } else if (startcode == VISUAL_OBJ_STARTCODE) {\n            if (s->studio_profile) {\n                if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n                    return ret;\n            } else\n                mpeg4_decode_visual_object(s, gb);\n        } else if (startcode == VOP_STARTCODE) {\n            break;\n        }\n\n        align_get_bits(gb);\n        startcode = 0xff;\n    }\n\nend:\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n    s->avctx->has_b_frames = !s->low_delay;\n\n    if (s->studio_profile) {\n        if (!s->avctx->bits_per_raw_sample) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        return decode_studio_vop_header(ctx, gb);\n    } else\n        return decode_vop_header(ctx, gb);\n}","target":1,"flaw_line_index":0,"hash":"05e65534-bff5-4770-bd37-aaaf926b1160","idx":"88bd7b00-30b8-487c-9bf1-a464221dd460"}
{"func_before":"                continue;\n            }\n            vol++;\n            if ((ret = decode_vol_header(ctx, gb)) < 0)\n                return ret;\n        } else if (startcode == USER_DATA_STARTCODE) {\n            decode_user_data(ctx, gb);\n        } else if (startcode == GOP_STARTCODE) {\n            mpeg4_decode_gop_header(s, gb);\n        } else if (startcode == VOS_STARTCODE) {\n            int profile, level;\n            mpeg4_decode_profile_level(s, gb, &profile, &level);\n            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n                (level > 0 && level < 9)) {\n                s->studio_profile = 1;\n                next_start_code_studio(gb);\n                extension_and_user_data(s, gb, 0);\n            } else if (s->studio_profile) {\n                avpriv_request_sample(s->avctx, \"Mixes studio and non studio profile\\n\");\n                return AVERROR_PATCHWELCOME;\n            }\n            s->avctx->profile = profile;\n            s->avctx->level   = level;\n        } else if (startcode == VISUAL_OBJ_STARTCODE) {\n            if (s->studio_profile) {\n                if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n                    return ret;\n            } else\n                mpeg4_decode_visual_object(s, gb);\n        } else if (startcode == VOP_STARTCODE) {\n            break;\n        }\n\n        align_get_bits(gb);\n        startcode = 0xff;\n    }\n\nend:\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n    s->avctx->has_b_frames = !s->low_delay;\n\n    if (s->studio_profile) {\n        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        if (!s->avctx->bits_per_raw_sample) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        return decode_studio_vop_header(ctx, gb);\n    } else\n        return decode_vop_header(ctx, gb);\n}","target":0,"flaw_line_index":0,"hash":"ea4e9dbe-8be3-46f2-b147-d47ac9147dcb","idx":"34e0b2e1-8c7e-4c06-9053-374f6eea12aa"}
{"func_before":"static void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tmemcpy(state->stateid.data, stateid->data, sizeof(state->stateid.data));\n\tmemcpy(state->open_stateid.data, stateid->data, sizeof(state->open_stateid.data));\n\tswitch (open_flags) {\n\t\tcase FMODE_READ:\n\t\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n}","target":1,"flaw_line_index":0,"hash":"f749b0cc-3c76-4bd0-a45e-50ef0074fd8d","idx":"fb60cf77-38d6-4e81-8ea0-6d7b0fdf5de6"}
{"func_before":"static void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, fmode_t fmode)\n{\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tmemcpy(state->stateid.data, stateid->data, sizeof(state->stateid.data));\n\tmemcpy(state->open_stateid.data, stateid->data, sizeof(state->open_stateid.data));\n\tswitch (fmode) {\n\t\tcase FMODE_READ:\n\t\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_READ|FMODE_WRITE:\n\t\t\tset_bit(NFS_O_RDWR_STATE, &state->flags);\n\t}\n}","target":0,"flaw_line_index":0,"hash":"a2b1345a-2989-46a6-b1e7-73343acc425b","idx":"4c7b77fd-6eef-4bc9-b0ce-857256a34f84"}
{"func_before":"\tint error;\n\n\tdprintk(\"nfsd: SETACL(2acl)   %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n\t\tgoto out;\n\n\tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n\tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\n\tif (error)\n\t\tgoto out_drop_write;\n\n\tfh_drop_write(fh);\n\n\tnfserr = fh_getattr(fh, &resp->stat);\n\nout:\n\t\/* argp->acl_{access,default} may have been allocated in\n\t   nfssvc_decode_setaclargs. *\/\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\treturn nfserr;\nout_drop_write:\n\tfh_drop_write(fh);\nout_errno:\n\tnfserr = nfserrno(error);\n\tgoto out;\n}","target":1,"flaw_line_index":0,"hash":"78f4daae-3463-40ee-926a-e2e1d77566bc","idx":"a4392077-43c7-4a08-927a-9480c3a6d745"}
{"func_before":"\t__be32 nfserr = 0;\n\tint error;\n\n\tdprintk(\"nfsd: SETACL(2acl)   %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n\t\tgoto out;\n\n\tinode = d_inode(fh->fh_dentry);\n\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\n\tfh_lock(fh);\n\n\terror = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);\n\tif (error)\n\t\tgoto out_drop_lock;\n\terror = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);\n\tif (error)\n\t\tgoto out_drop_lock;\n\n\tfh_unlock(fh);\n\n\tfh_drop_write(fh);\n\n\tnfserr = fh_getattr(fh, &resp->stat);\n\nout:\n\t\/* argp->acl_{access,default} may have been allocated in\n\t   nfssvc_decode_setaclargs. *\/\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\treturn nfserr;\nout_drop_lock:\n\tfh_unlock(fh);\n\tfh_drop_write(fh);\nout_errno:\n\tnfserr = nfserrno(error);\n\tgoto out;\n}","target":0,"flaw_line_index":0,"hash":"67414718-5801-4b20-afe2-0b6239a0b8ac","idx":"c0206366-38b0-400c-b8eb-8763c02537bf"}
{"func_before":"\t{\n\t\tStream_Write_UINT8(s, brush->y);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tStream_Write_UINT8(s, brush->style);\n\t}\n\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->hatch = brush->index;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tStream_Write_UINT8(s, brush->hatch);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_05)","target":1,"flaw_line_index":0,"hash":"c3c84774-ef7b-47cd-b952-16985d1a8dc9","idx":"ae5e985d-6889-41e8-9a74-274600e62623"}
{"func_before":"\t\tStream_Write_UINT8(s, brush->y);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_03)\n\t{\n\t\tStream_Write_UINT8(s, brush->style);\n\t}\n\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tBOOL rc;\n\t\tbrush->hatch = brush->index;\n\t\tbrush->bpp = get_bmf_bpp(brush->style, &rc);\n\t\tif (!rc)\n\t\t\treturn FALSE;\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_04)\n\t{\n\t\tStream_Write_UINT8(s, brush->hatch);\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_05)","target":0,"flaw_line_index":0,"hash":"5f500686-acb9-4544-9197-a3fe9fa2657f","idx":"27ce4862-d5e6-4e0f-b594-b864a2126cf7"}
{"func_before":"tsl::Status GpuExecutor::WaitForEvent(Stream* stream, Event* event) {\n  if (GpuDriver::WaitStreamOnEvent(context_, AsGpuStream(stream)->gpu_stream(),\n                                   AsGpuEvent(event)->gpu_event())) {\n    return ::tsl::OkStatus();\n  } else {\n    return tsl::Status(\n        port::error::INTERNAL,\n        absl::StrFormat(\"error recording waiting for CUDA event on stream %p\",\n                        stream));\n  }\n}","target":1,"flaw_line_index":0,"hash":"5fce49ba-2a65-4ad2-900b-e30c828f0e74","idx":"eabc41a2-ae0e-447f-ab36-0a6b05f854ae"}
{"func_before":"tsl::Status GpuExecutor::WaitForEvent(Stream* stream, Event* event) {\n  if (GpuDriver::WaitStreamOnEvent(context_, AsGpuStream(stream)->gpu_stream(),\n                                   AsGpuEvent(event)->gpu_event())) {\n    return ::tsl::OkStatus();\n  } else {\n    return tsl::Status(\n        tsl::error::INTERNAL,\n        absl::StrFormat(\"error recording waiting for CUDA event on stream %p\",\n                        stream));\n  }\n}","target":0,"flaw_line_index":0,"hash":"5d867c80-29cc-414b-9bb0-cfbf4549ca58","idx":"98712645-4a8c-4803-b9ef-de83117ba7c0"}
{"func_before":"void enc624j600EventHandler(NetInterface *interface)\n{\n   error_t error;\n   uint16_t status;\n   uint16_t value;\n\n   \/\/Read interrupt status register\n   status = enc624j600ReadReg(interface, ENC624J600_REG_EIR);\n\n   \/\/Check whether the link state has changed\n   if((status & EIR_LINKIF) != 0)\n   {\n      \/\/Clear interrupt flag\n      enc624j600ClearBit(interface, ENC624J600_REG_EIR, EIR_LINKIF);\n      \/\/Read Ethernet status register\n      value = enc624j600ReadReg(interface, ENC624J600_REG_ESTAT);\n\n      \/\/Check link state\n      if((value & ESTAT_PHYLNK) != 0)\n      {\n         \/\/Read PHY status register 3\n         value = enc624j600ReadPhyReg(interface, ENC624J600_PHY_REG_PHSTAT3);\n\n         \/\/Get current speed\n         if((value & PHSTAT3_SPDDPX1) != 0)\n         {\n            interface->linkSpeed = NIC_LINK_SPEED_100MBPS;\n         }\n         else\n         {\n            interface->linkSpeed = NIC_LINK_SPEED_10MBPS;\n         }\n\n         \/\/Determine the new duplex mode\n         if((value & PHSTAT3_SPDDPX2) != 0)\n         {\n            interface->duplexMode = NIC_FULL_DUPLEX_MODE;\n         }\n         else\n         {\n            interface->duplexMode = NIC_HALF_DUPLEX_MODE;\n         }\n\n         \/\/Link is up\n         interface->linkState = TRUE;\n      {\n         \/\/Link is down\n         interface->linkState = FALSE;\n      }\n\n      \/\/Process link state change event\n      nicNotifyLinkChange(interface);\n   }\n\n   \/\/Check whether a packet has been received?\n   if((status & EIR_PKTIF) != 0)\n   {\n      \/\/Clear interrupt flag\n      enc624j600ClearBit(interface, ENC624J600_REG_EIR, EIR_PKTIF);\n\n      \/\/Process all pending packets\n      do\n      {\n         \/\/Read incoming packet\n         error = enc624j600ReceivePacket(interface);\n\n         \/\/No more data in the receive buffer?\n      } while(error != ERROR_BUFFER_EMPTY);\n   }\n\n   \/\/Re-enable LINKIE and PKTIE interrupts\n   enc624j600SetBit(interface, ENC624J600_REG_EIE, EIE_LINKIE | EIE_PKTIE);\n}","target":1,"flaw_line_index":0,"hash":"62f2ab8a-31d6-41bb-b7af-725a13d7d22c","idx":"d4542a57-64b2-4269-a982-ecab04b11c29"}
{"func_before":"void enc624j600EventHandler(NetInterface *interface)\n{\n   error_t error;\n   uint16_t status;\n   uint16_t value;\n\n   \/\/Read interrupt status register\n   status = enc624j600ReadReg(interface, ENC624J600_EIR);\n\n   \/\/Check whether the link state has changed\n   if((status & ENC624J600_EIR_LINKIF) != 0)\n   {\n      \/\/Clear interrupt flag\n      enc624j600ClearBit(interface, ENC624J600_EIR, ENC624J600_EIR_LINKIF);\n      \/\/Read Ethernet status register\n      value = enc624j600ReadReg(interface, ENC624J600_ESTAT);\n\n      \/\/Check link state\n      if((value & ENC624J600_ESTAT_PHYLNK) != 0)\n      {\n         \/\/Read PHY status register 3\n         value = enc624j600ReadPhyReg(interface, ENC624J600_PHSTAT3);\n\n         \/\/Get current speed\n         if((value & ENC624J600_PHSTAT3_SPDDPX1) != 0)\n         {\n            interface->linkSpeed = NIC_LINK_SPEED_100MBPS;\n         }\n         else\n         {\n            interface->linkSpeed = NIC_LINK_SPEED_10MBPS;\n         }\n\n         \/\/Determine the new duplex mode\n         if((value & ENC624J600_PHSTAT3_SPDDPX2) != 0)\n         {\n            interface->duplexMode = NIC_FULL_DUPLEX_MODE;\n         }\n         else\n         {\n            interface->duplexMode = NIC_HALF_DUPLEX_MODE;\n         }\n\n         \/\/Link is up\n         interface->linkState = TRUE;\n      {\n         \/\/Link is down\n         interface->linkState = FALSE;\n      }\n\n      \/\/Process link state change event\n      nicNotifyLinkChange(interface);\n   }\n\n   \/\/Check whether a packet has been received?\n   if((status & ENC624J600_EIR_PKTIF) != 0)\n   {\n      \/\/Clear interrupt flag\n      enc624j600ClearBit(interface, ENC624J600_EIR, ENC624J600_EIR_PKTIF);\n\n      \/\/Process all pending packets\n      do\n      {\n         \/\/Read incoming packet\n         error = enc624j600ReceivePacket(interface);\n\n         \/\/No more data in the receive buffer?\n      } while(error != ERROR_BUFFER_EMPTY);\n   }\n\n   \/\/Re-enable LINKIE and PKTIE interrupts\n   enc624j600SetBit(interface, ENC624J600_EIE, ENC624J600_EIE_LINKIE |\n      ENC624J600_EIE_PKTIE);\n}","target":0,"flaw_line_index":0,"hash":"510141ea-1fc0-4537-b592-ddeb252ed2e8","idx":"1870395f-bbe9-474a-a957-c18e1a08e0f8"}
{"func_before":"\t\t\t\t      WLAN_EID_COUNTRY);\n\tis_11d = country_ie ? 1 : 0;\n\n\tmemset(&ssid_le, 0, sizeof(ssid_le));\n\tif (settings->ssid == NULL || settings->ssid_len == 0) {\n\t\tie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;\n\t\tssid_ie = brcmf_parse_tlvs(\n\t\t\t\t(u8 *)&settings->beacon.head[ie_offset],\n\t\t\t\tsettings->beacon.head_len - ie_offset,\n\t\t\t\tWLAN_EID_SSID);\n\t\tif (!ssid_ie)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(ssid_le.SSID, ssid_ie->data, ssid_ie->len);\n\t\tssid_le.SSID_len = cpu_to_le32(ssid_ie->len);\n\t\tbrcmf_dbg(TRACE, \"SSID is (%s) in Head\\n\", ssid_le.SSID);\n\t} else {\n\t\tmemcpy(ssid_le.SSID, settings->ssid, settings->ssid_len);\n\t\tssid_le.SSID_len = cpu_to_le32((u32)settings->ssid_len);\n\t}\n","target":1,"flaw_line_index":0,"hash":"53ac3184-282e-442b-8e75-6f8da447944d","idx":"45f8385a-9a2b-45d5-9201-9ccd64511763"}
{"func_before":"\t\t\t\t      WLAN_EID_COUNTRY);\n\tis_11d = country_ie ? 1 : 0;\n\n\tmemset(&ssid_le, 0, sizeof(ssid_le));\n\tif (settings->ssid == NULL || settings->ssid_len == 0) {\n\t\tie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;\n\t\tssid_ie = brcmf_parse_tlvs(\n\t\t\t\t(u8 *)&settings->beacon.head[ie_offset],\n\t\t\t\tsettings->beacon.head_len - ie_offset,\n\t\t\t\tWLAN_EID_SSID);\n\t\tif (!ssid_ie || ssid_ie->len > IEEE80211_MAX_SSID_LEN)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(ssid_le.SSID, ssid_ie->data, ssid_ie->len);\n\t\tssid_le.SSID_len = cpu_to_le32(ssid_ie->len);\n\t\tbrcmf_dbg(TRACE, \"SSID is (%s) in Head\\n\", ssid_le.SSID);\n\t} else {\n\t\tmemcpy(ssid_le.SSID, settings->ssid, settings->ssid_len);\n\t\tssid_le.SSID_len = cpu_to_le32((u32)settings->ssid_len);\n\t}\n","target":0,"flaw_line_index":0,"hash":"88cc5741-5ed2-49af-a2b8-d2772b27a4ab","idx":"231dedc6-7286-41f5-85b2-d9e1db9dbc27"}
{"func_before":"        upstream_tls_context:\n          common_tls_context:\n            tls_certificates:\n            - certificate_chain:\n                filename: \"{{ test_rundir }}\/test\/extensions\/transport_sockets\/tls\/test_data\/san_uri_cert.pem\"\n              private_key:\n                filename: \"{{ test_rundir }}\/test\/extensions\/transport_sockets\/tls\/test_data\/san_uri_key.pem\"\n            validation_context:\n              trusted_ca:\n                filename: \"{{ test_rundir }}\/test\/extensions\/transport_sockets\/tls\/test_data\/ca_cert.pem\"\n              match_subject_alt_names:\n              - exact: localhost\n              - exact: 127.0.0.1\n    typed_extension_protocol_options:\n      envoy.extensions.upstreams.http.v3.HttpProtocolOptions:\n        \"@type\": type.googleapis.com\/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\n        use_downstream_protocol_config:\n          http3_protocol_options: {}\n        common_http_protocol_options:\n          idle_timeout: 1s\n  )EOF\",\n                                                       Network::Address::IpVersion::v4);\n  auto cluster = makeCluster(yaml);","target":1,"flaw_line_index":0,"hash":"5f455e87-8385-4731-ab09-f72bb4957233","idx":"d188e638-90b2-4773-9cda-ab1e3a44be16"}
{"func_before":"        upstream_tls_context:\n          common_tls_context:\n            tls_certificates:\n            - certificate_chain:\n                filename: \"{{ test_rundir }}\/test\/extensions\/transport_sockets\/tls\/test_data\/san_uri_cert.pem\"\n              private_key:\n                filename: \"{{ test_rundir }}\/test\/extensions\/transport_sockets\/tls\/test_data\/san_uri_key.pem\"\n            validation_context:\n              trusted_ca:\n                filename: \"{{ test_rundir }}\/test\/extensions\/transport_sockets\/tls\/test_data\/ca_cert.pem\"\n              match_typed_subject_alt_names:\n              - matcher:\n                  exact: localhost\n                san_type: URI\n              - matcher:\n                  exact: 127.0.0.1\n                san_type: IP_ADDRESS\n    typed_extension_protocol_options:\n      envoy.extensions.upstreams.http.v3.HttpProtocolOptions:\n        \"@type\": type.googleapis.com\/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\n        use_downstream_protocol_config:\n          http3_protocol_options: {}\n        common_http_protocol_options:\n          idle_timeout: 1s\n  )EOF\",\n                                                       Network::Address::IpVersion::v4);\n  auto cluster = makeCluster(yaml);","target":0,"flaw_line_index":0,"hash":"80c62180-9406-4e68-841c-46bc202e8bd2","idx":"d4996662-cffc-4436-bd4b-53f1a98630da"}
{"func_before":"\t\/*\n\t * Issue flush and toggle pending_idx.  This makes pending_idx\n\t * different from running_idx, which means flush is in flight.\n\t *\/\n\tfq->flush_pending_idx ^= 1;\n\n\tblk_rq_init(q, flush_rq);\n\n\t\/*\n\t * Borrow tag from the first request since they can't\n\t * be in flight at the same time.\n\t *\/\n\tif (q->mq_ops) {\n\t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n\t\tflush_rq->tag = first_rq->tag;\n\t}\n\n\tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;\n\tflush_rq->end_io = flush_end_io;\n\n\treturn blk_flush_queue_rq(flush_rq, false);\n}","target":1,"flaw_line_index":0,"hash":"9b8936bc-a436-40da-ba8d-aac8278510d4","idx":"0c13c1f9-a434-48a1-8e96-db376f60bee3"}
{"func_before":"\t\/*\n\t * Issue flush and toggle pending_idx.  This makes pending_idx\n\t * different from running_idx, which means flush is in flight.\n\t *\/\n\tfq->flush_pending_idx ^= 1;\n\n\tblk_rq_init(q, flush_rq);\n\n\t\/*\n\t * Borrow tag from the first request since they can't\n\t * be in flight at the same time. And acquire the tag's\n\t * ownership for flush req.\n\t *\/\n\tif (q->mq_ops) {\n\t\tstruct blk_mq_hw_ctx *hctx;\n\n\t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n\t\tflush_rq->tag = first_rq->tag;\n\t\tfq->orig_rq = first_rq;\n\n\t\thctx = q->mq_ops->map_queue(q, first_rq->mq_ctx->cpu);\n\t\tblk_mq_tag_set_rq(hctx, first_rq->tag, flush_rq);\n\t}\n\n\tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;\n\tflush_rq->end_io = flush_end_io;\n\n\treturn blk_flush_queue_rq(flush_rq, false);\n}","target":0,"flaw_line_index":0,"hash":"de31db4b-7299-4d6b-82a7-6171c32caf82","idx":"6689018a-51a5-49e7-aad2-d1eab79b4766"}
{"func_before":"    krb5_key_salt_tuple         *new_ks_tuple = NULL;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    check_1_6_dummy(entry, mask, n_ks_tuple, ks_tuple, &password);\n\n    \/*\n     * Argument sanity checking, and opening up the DB\n     *\/\n    if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_LAST_SUCCESS) || (mask & KADM5_LAST_FAILED) ||\n       (mask & KADM5_FAIL_AUTH_COUNT))\n        return KADM5_BAD_MASK;\n    if ((mask & KADM5_KEY_DATA) && entry->n_key_data != 0)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if (entry == NULL)\n        return EINVAL;\n\n    \/*\n     * Check to see if the principal exists\n     *\/\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n\n    switch(ret) {\n    case KADM5_UNK_PRINC:\n        break;\n    case 0:","target":1,"flaw_line_index":0,"hash":"2b92cabb-89e8-4bd9-ae85-cc2eeea6b553","idx":"af397c58-a26c-44d8-817f-65c2e7d839ba"}
{"func_before":"\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    check_1_6_dummy(entry, mask, n_ks_tuple, ks_tuple, &password);\n\n    \/*\n     * Argument sanity checking, and opening up the DB\n     *\/\n    if (entry == NULL)\n        return EINVAL;\n    if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_LAST_SUCCESS) || (mask & KADM5_LAST_FAILED) ||\n       (mask & KADM5_FAIL_AUTH_COUNT))\n        return KADM5_BAD_MASK;\n    if ((mask & KADM5_KEY_DATA) && entry->n_key_data != 0)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && entry->policy == NULL)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n\n    \/*\n     * Check to see if the principal exists\n     *\/\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);\n\n    switch(ret) {\n    case KADM5_UNK_PRINC:\n        break;\n    case 0:","target":0,"flaw_line_index":0,"hash":"329d48df-16d6-4c1e-b86a-dde9e76d0258","idx":"a0c7d2aa-f00a-46b8-9e35-ef9af2ceebfb"}
{"func_before":"\n\tDBG(SAVE, ul_debug(\"device %s, type %s\", dev->bid_name, dev->bid_type ?\n\t\t   dev->bid_type : \"(null)\"));\n\n\tfprintf(file, \"<device DEVNO=\\\"0x%04lx\\\" TIME=\\\"%ld.%ld\\\"\",\n\t\t\t(unsigned long) dev->bid_devno,\n\t\t\t(long) dev->bid_time,\n\t\t\t(long) dev->bid_utime);\n\n\tif (dev->bid_pri)\n\t\tfprintf(file, \" PRI=\\\"%d\\\"\", dev->bid_pri);\n\tlist_for_each(p, &dev->bid_tags) {\n\t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n\t\tfprintf(file, \" %s=\\\"%s\\\"\", tag->bit_name,tag->bit_val);\n\t}\n\tfprintf(file, \">%s<\/device>\\n\", dev->bid_name);\n\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"49e62e18-99b9-486d-96ae-a04b927f18fe","idx":"44869777-1589-40a4-8771-07acbd9ff289"}
{"func_before":"\tDBG(SAVE, ul_debug(\"device %s, type %s\", dev->bid_name, dev->bid_type ?\n\t\t   dev->bid_type : \"(null)\"));\n\n\tfprintf(file, \"<device DEVNO=\\\"0x%04lx\\\" TIME=\\\"%ld.%ld\\\"\",\n\t\t\t(unsigned long) dev->bid_devno,\n\t\t\t(long) dev->bid_time,\n\t\t\t(long) dev->bid_utime);\n\n\tif (dev->bid_pri)\n\t\tfprintf(file, \" PRI=\\\"%d\\\"\", dev->bid_pri);\n\n\tlist_for_each(p, &dev->bid_tags) {\n\t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n\n\t\tfputc(' ', file);\t\t\t\/* space between tags *\/\n\t\tfputs(tag->bit_name, file);\t\t\/* tag NAME *\/\n\t\tfputc('=', file);\t\t\t\/* separator between NAME and VALUE *\/\n\t\tsave_quoted(tag->bit_val, file);\t\/* tag \"VALUE\" *\/\n\t}\n\tfprintf(file, \">%s<\/device>\\n\", dev->bid_name);\n\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"a9a13ac5-7334-41d8-aca5-63e7a48a4498","idx":"63094a37-7b4c-4af2-8770-dfed038c1b59"}
{"func_before":"  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {\n    auto col_params = new CollectiveParams();\n    auto done_with_cleanup = [col_params, done = std::move(done)]() {\n      done();\n      col_params->Unref();\n    };\n    core::RefCountPtr<CollectiveGroupResource> resource;\n    OP_REQUIRES_OK_ASYNC(c, LookupResource(c, HandleFromInput(c, 1), &resource),\n                         done);\n\n    Tensor group_assignment = c->input(2);\n\n    OP_REQUIRES_OK_ASYNC(\n        c,\n        FillCollectiveParams(col_params, group_assignment, REDUCTION_COLLECTIVE,\n                             resource.get()),\n        done);\n    col_params->instance.shape = c->input(0).shape();\n    col_params->merge_op = merge_op_.get();","target":1,"flaw_line_index":0,"hash":"3d4a11eb-85c8-4fde-9aa8-6d9ece532763","idx":"1ce262af-7e2b-4a3c-9a61-ad4f9fa793b0"}
{"func_before":"  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {\n    auto col_params = new CollectiveParams();\n    auto done_with_cleanup = [col_params, done = std::move(done)]() {\n      done();\n      col_params->Unref();\n    };\n    core::RefCountPtr<CollectiveGroupResource> resource;\n    OP_REQUIRES_OK_ASYNC(c, LookupResource(c, HandleFromInput(c, 1), &resource),\n                         done_with_cleanup);\n\n    Tensor group_assignment = c->input(2);\n\n    OP_REQUIRES_OK_ASYNC(\n        c,\n        FillCollectiveParams(col_params, group_assignment, REDUCTION_COLLECTIVE,\n                             resource.get()),\n        done);\n    col_params->instance.shape = c->input(0).shape();\n    col_params->merge_op = merge_op_.get();","target":0,"flaw_line_index":0,"hash":"aef2e0e0-f1f0-4c67-8106-53f7b07d08f3","idx":"2d778edf-606a-4b57-b8b5-23417ff53810"}
{"func_before":"    return tsl::errors::Unimplemented(\n        \"int8 -> float fused conv is disabled for this cuDNN version. See \"\n        \"go\/nvbugs\/3326122\");\n  }\n\n  if (activation_mode != dnn::ActivationMode::kRelu &&\n      activation_mode != dnn::ActivationMode::kRelu6 &&\n      activation_mode != dnn::ActivationMode::kElu &&\n      activation_mode != dnn::ActivationMode::kLeakyRelu &&\n      activation_mode != dnn::ActivationMode::kNone) {\n    return tsl::Status(port::error::INVALID_ARGUMENT,\n                       \"CuDNN fusion only supports activations of \"\n                       \"{Relu, Relu6, Elu, <None>}.\");\n  }\n\n  if (!actually_use_cudnn_frontend) {\n    std::vector<dnn::AlgorithmDesc> algorithms;\n\n    auto cuda_compute_capability = stream->GetCudaComputeCapability();\n    if (!GetConvolveAlgorithms(cuda_compute_capability, input_type,\n                               &algorithms)) {\n      return tsl::Status(port::error::UNKNOWN,\n                         \"Listing fused convolve algorithms failed.\");\n    }\n\n    for (const auto& algo : algorithms) {\n      \/\/ Only CUDNN_CONVOLUTION_FWD_ALGO_IMPLICIT_PRECOMP_GEMM is supported\n      \/\/ for identity activation, other algs seem to quietly do Relu. See\n      \/\/ https:\/\/docs.nvidia.com\/deeplearning\/sdk\/cudnn-developer-guide\/index.html#cudnnConvolutionBiasActivationForward\n      if (activation_mode == dnn::ActivationMode::kNone &&\n          algo.algo_id() != CUDNN_CONVOLUTION_FWD_ALGO_IMPLICIT_PRECOMP_GEMM) {\n        continue;\n    return ::tsl::OkStatus();\n  }\n\n#if CUDNN_VERSION >= 8100 && TF_ENABLE_CUDNN_FRONTEND\n  auto cudnn = cudnn_->GetHandle(parent_, stream);\n  auto op_graph_status = GetCudnnFusedOperationGraph(\n      kind, input_type, bias_type, output_type, conv_scale, side_input_scale,\n      leakyrelu_alpha, input_descriptor, filter_descriptor, bias_descriptor,\n      output_descriptor, convolution_descriptor, activation_mode, cudnn);\n  if (!op_graph_status.status().ok()) {\n    return tsl::Status(port::error::INTERNAL,\n                       absl::StrCat(\"Cudnn graph failed to build: \",\n                                    op_graph_status.status().ToString()));\n  }\n  auto op_graph = std::move(op_graph_status).value();\n\n  bool need_side_input =\n      SideInputNeeded(activation_mode, conv_scale, side_input_scale);\n  return CreateOpRunners<dnn::FusedConvSignature>(\n      stream, cudnn, parent_, cudnn_.get(), std::move(op_graph), kind,\n      input_type, {'x', 'w', 'z', 'b', 'y'}, use_fallback, out_exec_plans,","target":1,"flaw_line_index":0,"hash":"9f11d4ac-6374-49d7-9137-d0bb2b936aeb","idx":"7e02d582-8270-4554-96ae-ef8b1ea7f84b"}
{"func_before":"    return tsl::errors::Unimplemented(\n        \"int8 -> float fused conv is disabled for this cuDNN version. See \"\n        \"go\/nvbugs\/3326122\");\n  }\n\n  if (activation_mode != dnn::ActivationMode::kRelu &&\n      activation_mode != dnn::ActivationMode::kRelu6 &&\n      activation_mode != dnn::ActivationMode::kElu &&\n      activation_mode != dnn::ActivationMode::kLeakyRelu &&\n      activation_mode != dnn::ActivationMode::kNone) {\n    return tsl::Status(tsl::error::INVALID_ARGUMENT,\n                       \"CuDNN fusion only supports activations of \"\n                       \"{Relu, Relu6, Elu, <None>}.\");\n  }\n\n  if (!actually_use_cudnn_frontend) {\n    std::vector<dnn::AlgorithmDesc> algorithms;\n\n    auto cuda_compute_capability = stream->GetCudaComputeCapability();\n    if (!GetConvolveAlgorithms(cuda_compute_capability, input_type,\n                               &algorithms)) {\n      return tsl::Status(tsl::error::UNKNOWN,\n                         \"Listing fused convolve algorithms failed.\");\n    }\n\n    for (const auto& algo : algorithms) {\n      \/\/ Only CUDNN_CONVOLUTION_FWD_ALGO_IMPLICIT_PRECOMP_GEMM is supported\n      \/\/ for identity activation, other algs seem to quietly do Relu. See\n      \/\/ https:\/\/docs.nvidia.com\/deeplearning\/sdk\/cudnn-developer-guide\/index.html#cudnnConvolutionBiasActivationForward\n      if (activation_mode == dnn::ActivationMode::kNone &&\n          algo.algo_id() != CUDNN_CONVOLUTION_FWD_ALGO_IMPLICIT_PRECOMP_GEMM) {\n        continue;\n    return ::tsl::OkStatus();\n  }\n\n#if CUDNN_VERSION >= 8100 && TF_ENABLE_CUDNN_FRONTEND\n  auto cudnn = cudnn_->GetHandle(parent_, stream);\n  auto op_graph_status = GetCudnnFusedOperationGraph(\n      kind, input_type, bias_type, output_type, conv_scale, side_input_scale,\n      leakyrelu_alpha, input_descriptor, filter_descriptor, bias_descriptor,\n      output_descriptor, convolution_descriptor, activation_mode, cudnn);\n  if (!op_graph_status.status().ok()) {\n    return tsl::Status(tsl::error::INTERNAL,\n                       absl::StrCat(\"Cudnn graph failed to build: \",\n                                    op_graph_status.status().ToString()));\n  }\n  auto op_graph = std::move(op_graph_status).value();\n\n  bool need_side_input =\n      SideInputNeeded(activation_mode, conv_scale, side_input_scale);\n  return CreateOpRunners<dnn::FusedConvSignature>(\n      stream, cudnn, parent_, cudnn_.get(), std::move(op_graph), kind,\n      input_type, {'x', 'w', 'z', 'b', 'y'}, use_fallback, out_exec_plans,","target":0,"flaw_line_index":0,"hash":"9c1a38b2-9a0d-4f7b-a135-92a2dd4ff849","idx":"120bd514-d6f7-4abf-815b-635c38d3a9b2"}
{"func_before":"ikev1_attrmap_print(netdissect_options *ndo,\n\t\t    const u_char *p, const u_char *ep,\n\t\t    const struct attrmap *map, size_t nmap)\n{\n\tint totlen;\n\tuint32_t t, v;\n\n\tif (p[0] & 0x80)\n\t\ttotlen = 4;\n\telse\n\t\ttotlen = 4 + EXTRACT_16BITS(&p[2]);\n\tif (ep < p + totlen) {\n\t\tND_PRINT((ndo,\"[|attr]\"));\n\t\treturn ep + 1;\n\t}\n\n\tND_PRINT((ndo,\"(\"));\n\tt = EXTRACT_16BITS(&p[0]) & 0x7fff;\n\tif (map && t < nmap && map[t].type)\n\t\tND_PRINT((ndo,\"type=%s \", map[t].type));\n\telse\n\t\tND_PRINT((ndo,\"type=#%d \", t));\n\tif (p[0] & 0x80) {\n\t\tND_PRINT((ndo,\"value=\"));\n\t\tv = EXTRACT_16BITS(&p[2]);\n\t\tif (map && t < nmap && v < map[t].nvalue && map[t].value[v])\n\t\t\tND_PRINT((ndo,\"%s\", map[t].value[v]));\n\t\telse\n\t\t\trawprint(ndo, (const uint8_t *)&p[2], 2);\n\t} else {\n\t\tND_PRINT((ndo,\"len=%d value=\", EXTRACT_16BITS(&p[2])));\n\t\trawprint(ndo, (const uint8_t *)&p[4], EXTRACT_16BITS(&p[2]));\n\t}\n\tND_PRINT((ndo,\")\"));\n\treturn p + totlen;\n}","target":1,"flaw_line_index":0,"hash":"5b63c097-8592-40e2-9af4-7c1c412c7b1f","idx":"39965098-351b-49df-a2a8-ff19a3f4f0d5"}
{"func_before":"ikev1_attrmap_print(netdissect_options *ndo,\n\t\t    const u_char *p, const u_char *ep2,\n\t\t    const struct attrmap *map, size_t nmap)\n{\n\tint totlen;\n\tuint32_t t, v;\n\n\tND_TCHECK(p[0]);\n\tif (p[0] & 0x80)\n\t\ttotlen = 4;\n\telse {\n\t\tND_TCHECK_16BITS(&p[2]);\n\t\ttotlen = 4 + EXTRACT_16BITS(&p[2]);\n\t}\n\tif (ep2 < p + totlen) {\n\t\tND_PRINT((ndo,\"[|attr]\"));\n\t\treturn ep2 + 1;\n\t}\n\n\tND_TCHECK_16BITS(&p[0]);\n\tND_PRINT((ndo,\"(\"));\n\tt = EXTRACT_16BITS(&p[0]) & 0x7fff;\n\tif (map && t < nmap && map[t].type)\n\t\tND_PRINT((ndo,\"type=%s \", map[t].type));\n\telse\n\t\tND_PRINT((ndo,\"type=#%d \", t));\n\tif (p[0] & 0x80) {\n\t\tND_PRINT((ndo,\"value=\"));\n\t\tND_TCHECK_16BITS(&p[2]);\n\t\tv = EXTRACT_16BITS(&p[2]);\n\t\tif (map && t < nmap && v < map[t].nvalue && map[t].value[v])\n\t\t\tND_PRINT((ndo,\"%s\", map[t].value[v]));\n\t\telse {\n\t\t\tif (!rawprint(ndo, (const uint8_t *)&p[2], 2)) {\n\t\t\t\tND_PRINT((ndo,\")\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tND_PRINT((ndo,\"len=%d value=\", totlen - 4));\n\t\tif (!rawprint(ndo, (const uint8_t *)&p[4], totlen - 4)) {\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tgoto trunc;\n\t\t}\n\t}\n\tND_PRINT((ndo,\")\"));\n\treturn p + totlen;\n\ntrunc:\n\treturn NULL;\n}","target":0,"flaw_line_index":0,"hash":"fad1a3c7-7f9f-4f0f-9808-fd4715cdf68f","idx":"1cf8dfc9-9c0b-4d75-ba0e-6ab6ccaba72b"}
{"func_before":"int pure_strcmp(const char * const s1, const char * const s2)\n{\n    return pure_memcmp(s1, s2, strlen(s1) + 1U);\n}","target":1,"flaw_line_index":0,"hash":"79bf423f-177f-49db-aec1-674203f53f50","idx":"723c5b92-20e3-4899-8724-f8d0389a4f59"}
{"func_before":"int pure_strcmp(const char * const s1, const char * const s2)\n{\n    const size_t s1_len = strlen(s1);\n    const size_t s2_len = strlen(s2);\n    const size_t len = (s1_len < s2_len) ? s1_len : s2_len;\n\n    return pure_memcmp(s1, s2, len + 1);\n}","target":0,"flaw_line_index":0,"hash":"817aecaf-ae2d-4370-a396-819f2ad52f7f","idx":"e059ea9c-5db1-49d3-b612-17081caa3bfb"}
{"func_before":"_libssh2_packet_add(LIBSSH2_SESSION * session, unsigned char *data,\n                    size_t datalen, int macstate)\n{\n    int rc = 0;\n    char *message = NULL;\n    char *language = NULL;\n    size_t message_len = 0;\n    size_t language_len = 0;\n    LIBSSH2_CHANNEL *channelp = NULL;\n    size_t data_head = 0;\n    unsigned char msg = data[0];\n\n    switch(session->packAdd_state) {\n    case libssh2_NB_state_idle:\n        _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                       \"Packet type %d received, length=%d\",\n\n            \/*\n              byte      SSH_MSG_DISCONNECT\n              uint32    reason code\n              string    description in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            *\/\n\n        case SSH_MSG_DISCONNECT:\n            if(datalen >= 5) {\n                size_t reason = _libssh2_ntohu32(data + 1);\n\n                if(datalen >= 9) {\n                    message_len = _libssh2_ntohu32(data + 5);\n\n                    if(message_len < datalen-13) {\n                        \/* 9 = packet_type(1) + reason(4) + message_len(4) *\/\n                        message = (char *) data + 9;\n\n                        language_len =\n                            _libssh2_ntohu32(data + 9 + message_len);\n                        language = (char *) data + 9 + message_len + 4;\n\n                        if(language_len > (datalen-13-message_len)) {\n                            \/* bad input, clear info *\/\n                            language = message = NULL;\n                            language_len = message_len = 0;\n                        }\n                    }\n                    else\n                        \/* bad size, clear it *\/\n                        message_len = 0;\n                }\n                if(session->ssh_msg_disconnect) {\n                    LIBSSH2_DISCONNECT(session, reason, message,\n                                       message_len, language, language_len);\n                }\n                _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                               \"Disconnect(%d): %s(%s)\", reason,\n                               message, language);\n            }\n\n            LIBSSH2_FREE(session, data);\n            session->socket_state = LIBSSH2_SOCKET_DISCONNECTED;\n            session->packAdd_state = libssh2_NB_state_idle;\n            return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_DISCONNECT,\n                                  \"socket disconnect\");\n              boolean   always_display\n              string    message in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            *\/\n\n        case SSH_MSG_DEBUG:\n            if(datalen >= 2) {\n                int always_display = data[1];\n\n                if(datalen >= 6) {\n                    message_len = _libssh2_ntohu32(data + 2);\n\n                    if(message_len <= (datalen - 10)) {\n                        \/* 6 = packet_type(1) + display(1) + message_len(4) *\/\n                        message = (char *) data + 6;\n                        language_len = _libssh2_ntohu32(data + 6 +\n                                                        message_len);\n\n                        if(language_len <= (datalen - 10 - message_len))\n                            language = (char *) data + 10 + message_len;\n                    }\n                }\n\n                if(session->ssh_msg_debug) {\n                    LIBSSH2_DEBUG(session, always_display, message,\n                                  message_len, language, language_len);\n                }\n            }\n            \/*\n             * _libssh2_debug will actually truncate this for us so\n             * that it's not an inordinate about of data\n             *\/\n            _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                           \"Debug Packet: %s\", message);\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n              string    request name in US-ASCII only\n              boolean   want reply\n              ....      request-specific data follows\n            *\/\n\n        case SSH_MSG_GLOBAL_REQUEST:\n            if(datalen >= 5) {\n                uint32_t len = 0;\n                unsigned char want_reply = 0;\n                len = _libssh2_ntohu32(data + 1);\n                if(datalen >= (6 + len)) {\n                    want_reply = data[5 + len];\n                    _libssh2_debug(session,\n                                   LIBSSH2_TRACE_CONN,\n                                   \"Received global request type %.*s (wr %X)\",\n                                   len, data + 5, want_reply);\n                }\n\n\n                if(want_reply) {\n                    static const unsigned char packet =","target":1,"flaw_line_index":0,"hash":"87c4cadb-1a20-47ec-9845-975df887f82a","idx":"07185880-094e-476f-a29f-ac9e29e62e53"}
{"func_before":"_libssh2_packet_add(LIBSSH2_SESSION * session, unsigned char *data,\n                    size_t datalen, int macstate)\n{\n    int rc = 0;\n    unsigned char *message = NULL;\n    unsigned char *language = NULL;\n    size_t message_len = 0;\n    size_t language_len = 0;\n    LIBSSH2_CHANNEL *channelp = NULL;\n    size_t data_head = 0;\n    unsigned char msg = data[0];\n\n    switch(session->packAdd_state) {\n    case libssh2_NB_state_idle:\n        _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                       \"Packet type %d received, length=%d\",\n\n            \/*\n              byte      SSH_MSG_DISCONNECT\n              uint32    reason code\n              string    description in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            *\/\n\n        case SSH_MSG_DISCONNECT:\n            if(datalen >= 5) {\n                uint32_t reason = 0;\n                struct string_buf buf;\n                buf.data = (unsigned char *)data;\n                buf.dataptr = buf.data;\n                buf.len = datalen;\n                buf.dataptr++; \/* advance past type *\/\n\n                _libssh2_get_u32(&buf, &reason);\n                _libssh2_get_string(&buf, &message, &message_len);\n                _libssh2_get_string(&buf, &language, &language_len);\n\n                if(session->ssh_msg_disconnect) {\n                    LIBSSH2_DISCONNECT(session, reason, (const char *)message,\n                                       message_len, (const char *)language,\n                                       language_len);\n                }\n\n                _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                               \"Disconnect(%d): %s(%s)\", reason,\n                               message, language);\n            }\n\n            LIBSSH2_FREE(session, data);\n            session->socket_state = LIBSSH2_SOCKET_DISCONNECTED;\n            session->packAdd_state = libssh2_NB_state_idle;\n            return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_DISCONNECT,\n                                  \"socket disconnect\");\n              boolean   always_display\n              string    message in ISO-10646 UTF-8 encoding [RFC3629]\n              string    language tag [RFC3066]\n            *\/\n\n        case SSH_MSG_DEBUG:\n            if(datalen >= 2) {\n                int always_display = data[1];\n\n                if(datalen >= 6) {\n                    struct string_buf buf;\n                    buf.data = (unsigned char *)data;\n                    buf.dataptr = buf.data;\n                    buf.len = datalen;\n                    buf.dataptr += 2; \/* advance past type & always display *\/\n\n                    _libssh2_get_string(&buf, &message, &message_len);\n                    _libssh2_get_string(&buf, &language, &language_len);\n                }\n\n                if(session->ssh_msg_debug) {\n                    LIBSSH2_DEBUG(session, always_display,\n                                  (const char *)message,\n                                  message_len, (const char *)language,\n                                  language_len);\n                }\n            }\n\n            \/*\n             * _libssh2_debug will actually truncate this for us so\n             * that it's not an inordinate about of data\n             *\/\n            _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                           \"Debug Packet: %s\", message);\n            LIBSSH2_FREE(session, data);\n            session->packAdd_state = libssh2_NB_state_idle;\n            return 0;\n\n              string    request name in US-ASCII only\n              boolean   want reply\n              ....      request-specific data follows\n            *\/\n\n        case SSH_MSG_GLOBAL_REQUEST:\n            if(datalen >= 5) {\n                uint32_t len = 0;\n                unsigned char want_reply = 0;\n                len = _libssh2_ntohu32(data + 1);\n                if((len <= (UINT_MAX - 6)) && (datalen >= (6 + len))) {\n                    want_reply = data[5 + len];\n                    _libssh2_debug(session,\n                                   LIBSSH2_TRACE_CONN,\n                                   \"Received global request type %.*s (wr %X)\",\n                                   len, data + 5, want_reply);\n                }\n\n\n                if(want_reply) {\n                    static const unsigned char packet =","target":0,"flaw_line_index":0,"hash":"8c2a7ce3-96e9-41eb-b4b6-c444ac328d03","idx":"6d1295eb-6cdd-407d-83c1-7edadb77618f"}
{"func_before":"void recovery_character(const char *character)\n{\n    if (!awaiting_character) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n\n    if (strlen(mnemonic) + 1 > MNEMONIC_BUF - 1) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage,\n                        \"Too many characters attempted during recovery\");","target":1,"flaw_line_index":0,"hash":"c59c4d97-2b75-4bdf-b1c9-8833735e7109","idx":"8674e350-fa6f-48da-b813-74a924f8a895"}
{"func_before":"void recovery_character(const char *character)\n{\n    if (!awaiting_character || !recovery_started) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }\n\n    if (strlen(mnemonic) + 1 > MNEMONIC_BUF - 1) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage,\n                        \"Too many characters attempted during recovery\");","target":0,"flaw_line_index":0,"hash":"55ec2ee0-7ba3-483d-a1e5-8369b45b4fc8","idx":"d4ad72d1-4025-4563-9197-c59916170772"}
{"func_before":"\t    jumpidx = curwin->w_jumplistidx - 1;\n\t    if (jumpidx < 0)\n\t\tjumpidx = curwin->w_jumplistlen - 1;\n\n\t    forward = jumpidx;\n\t    while (jumpidx != curwin->w_jumplistidx)\n\t    {\n\t\tbuf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    if (buf == curbuf || !buf->b_p_bl)\n\t\t\tbuf = NULL;\t\/\/ skip current and unlisted bufs\n\t\t    else if (buf->b_ml.ml_mfp == NULL)\n\t\t    {\n\t\t\t\/\/ skip unloaded buf, but may keep it for later\n\t\t\tif (bp == NULL)\n\t\t\t    bp = buf;\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t}\n\t\tif (buf != NULL)   \/\/ found a valid buffer: stop searching\n\t\t    break;\n\t    {\n\t\tif (buf == NULL)\n\t\t{\n\t\t    if (!forward)\t\/\/ tried both directions\n\t\t\tbreak;\n\t\t    buf = curbuf->b_prev;\n\t\t    forward = FALSE;\n\t\t    continue;\n\t\t}\n\t\t\/\/ in non-help buffer, try to skip help buffers, and vv\n\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl)\n\t\t{\n\t\t    if (buf->b_ml.ml_mfp != NULL)   \/\/ found loaded buffer\n\t\t\tbreak;\n\t\t    if (bp == NULL)\t\/\/ remember unloaded buf for later\n\t\t\tbp = buf;\n\t\t}\n\t\tif (forward)\n\t\t    buf = buf->b_next;\n\t\telse\n\t\t    buf = buf->b_prev;\n\t    }\n\t}\n\tif (buf == NULL)\t\/\/ No loaded buffer, use unloaded one\n\t    buf = bp;\n\tif (buf == NULL)\t\/\/ No loaded buffer, find listed one\n\t{\n\t    FOR_ALL_BUFFERS(buf)\n\t\tif (buf->b_p_bl && buf != curbuf)\n\t\t    break;\n\t}\n\tif (buf == NULL)\t\/\/ Still no buffer, just take one\n\t{\n\t    if (curbuf->b_next != NULL)\n\t\tbuf = curbuf->b_next;\n\t    else\n\t\tbuf = curbuf->b_prev;\n\t}\n    }\n\n    if (buf == NULL)\n    {\n\t\/\/ Autocommands must have wiped out all other buffers.  Only option\n\t\/\/ now is to make the current buffer empty.\n\treturn empty_curbuf(FALSE, (flags & DOBUF_FORCEIT), action);\n    }\n","target":1,"flaw_line_index":0,"hash":"101b1f34-1e0c-4b73-8a48-9dafb0c22d18","idx":"4bd3c3ea-adb6-407e-ac73-b6237ac61819"}
{"func_before":"\t    jumpidx = curwin->w_jumplistidx - 1;\n\t    if (jumpidx < 0)\n\t\tjumpidx = curwin->w_jumplistlen - 1;\n\n\t    forward = jumpidx;\n\t    while (jumpidx != curwin->w_jumplistidx)\n\t    {\n\t\tbuf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    \/\/ Skip current and unlisted bufs.  Also skip a quickfix\n\t\t    \/\/ buffer, it might be deleted soon.\n\t\t    if (buf == curbuf || !buf->b_p_bl\n#if defined(FEAT_QUICKFIX)\n\t\t\t    || bt_quickfix(buf)\n#endif\n\t\t\t    )\n\t\t\tbuf = NULL;\n\t\t    else if (buf->b_ml.ml_mfp == NULL)\n\t\t    {\n\t\t\t\/\/ skip unloaded buf, but may keep it for later\n\t\t\tif (bp == NULL)\n\t\t\t    bp = buf;\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t}\n\t\tif (buf != NULL)   \/\/ found a valid buffer: stop searching\n\t\t    break;\n\t    {\n\t\tif (buf == NULL)\n\t\t{\n\t\t    if (!forward)\t\/\/ tried both directions\n\t\t\tbreak;\n\t\t    buf = curbuf->b_prev;\n\t\t    forward = FALSE;\n\t\t    continue;\n\t\t}\n\t\t\/\/ in non-help buffer, try to skip help buffers, and vv\n\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl\n#if defined(FEAT_QUICKFIX)\n\t\t\t    && !bt_quickfix(buf)\n#endif\n\t\t\t   )\n\t\t{\n\t\t    if (buf->b_ml.ml_mfp != NULL)   \/\/ found loaded buffer\n\t\t\tbreak;\n\t\t    if (bp == NULL)\t\/\/ remember unloaded buf for later\n\t\t\tbp = buf;\n\t\t}\n\t\tif (forward)\n\t\t    buf = buf->b_next;\n\t\telse\n\t\t    buf = buf->b_prev;\n\t    }\n\t}\n\tif (buf == NULL)\t\/\/ No loaded buffer, use unloaded one\n\t    buf = bp;\n\tif (buf == NULL)\t\/\/ No loaded buffer, find listed one\n\t{\n\t    FOR_ALL_BUFFERS(buf)\n\t\tif (buf->b_p_bl && buf != curbuf\n#if defined(FEAT_QUICKFIX)\n\t\t\t    && !bt_quickfix(buf)\n#endif\n\t\t       )\n\t\t    break;\n\t}\n\tif (buf == NULL)\t\/\/ Still no buffer, just take one\n\t{\n\t    if (curbuf->b_next != NULL)\n\t\tbuf = curbuf->b_next;\n\t    else\n\t\tbuf = curbuf->b_prev;\n#if defined(FEAT_QUICKFIX)\n\t    if (bt_quickfix(buf))\n\t\tbuf = NULL;\n#endif\n\t}\n    }\n\n    if (buf == NULL)\n    {\n\t\/\/ Autocommands must have wiped out all other buffers.  Only option\n\t\/\/ now is to make the current buffer empty.\n\treturn empty_curbuf(FALSE, (flags & DOBUF_FORCEIT), action);\n    }\n","target":0,"flaw_line_index":0,"hash":"2fef74e2-1bb6-4633-8e82-4e14d43fa8e1","idx":"527c7f39-3346-4986-abb5-e2b75a0e29e9"}
{"func_before":"                        break;\n                    }\n                    tlen -=8;\n                    tptr +=8;\n                }\n                break;\n\n        case BGPTYPE_PMSI_TUNNEL:\n        {\n                uint8_t tunnel_type, flags;\n\n                tunnel_type = *(tptr+1);\n                flags = *tptr;\n                tlen = len;\n\n                ND_TCHECK2(tptr[0], 5);\n                ND_PRINT((ndo, \"\\n\\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u\",\n                       tok2str(bgp_pmsi_tunnel_values, \"Unknown\", tunnel_type),\n                       tunnel_type,\n                       bittok2str(bgp_pmsi_flag_values, \"none\", flags),\n                       EXTRACT_24BITS(tptr+2)>>4));\n\n                tptr +=5;\n                tlen -= 5;\n\n                switch (tunnel_type) {","target":1,"flaw_line_index":0,"hash":"6cc71b06-690d-4b11-a39f-314e3ab76f2d","idx":"bd04ec2e-3b33-44fb-9d74-c3bc36e52a4e"}
{"func_before":"                    }\n                    tlen -=8;\n                    tptr +=8;\n                }\n                break;\n\n        case BGPTYPE_PMSI_TUNNEL:\n        {\n                uint8_t tunnel_type, flags;\n\n                ND_TCHECK2(tptr[0], 5);\n                tunnel_type = *(tptr+1);\n                flags = *tptr;\n                tlen = len;\n\n                ND_PRINT((ndo, \"\\n\\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u\",\n                       tok2str(bgp_pmsi_tunnel_values, \"Unknown\", tunnel_type),\n                       tunnel_type,\n                       bittok2str(bgp_pmsi_flag_values, \"none\", flags),\n                       EXTRACT_24BITS(tptr+2)>>4));\n\n                tptr +=5;\n                tlen -= 5;\n\n                switch (tunnel_type) {","target":0,"flaw_line_index":0,"hash":"473c7edb-62d1-4eac-8311-21e4f994c470","idx":"44428ced-8ce1-4ebf-bba4-abd2bb1a2b4b"}
{"func_before":"ast2obj_arg(void* _o)\n{\n    arg_ty o = (arg_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    result = PyType_GenericNew(arg_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_identifier(o->arg);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_arg, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_expr(o->annotation);","target":1,"flaw_line_index":0,"hash":"9cf67ca0-e407-493d-87cf-c34d3cc57ed8","idx":"5116fcd8-7544-43e9-92f3-0c08ec5743dc"}
{"func_before":"ast2obj_arg(void* _o)\n{\n    arg_ty o = (arg_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_RETURN_NONE;\n    }\n\n    result = PyType_GenericNew(arg_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_identifier(o->arg);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_arg, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_expr(o->annotation);","target":0,"flaw_line_index":0,"hash":"3eaef93c-fe9d-4f93-8a61-71c23a0b99e3","idx":"017efccb-580d-4c32-9f44-b5190a61f2c6"}
{"func_before":"    case TType::T_LIST: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readListBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readListEnd();\n      return;\n    }\n    default:\n      return;\n  }\n}","target":1,"flaw_line_index":0,"hash":"d7db338d-22b0-44bb-a595-b210cffa0cf3","idx":"b8eb7175-7edf-443f-9139-ae521292aa8e"}
{"func_before":"    case TType::T_LIST: {\n      TType elemType;\n      uint32_t i, size;\n      prot.readListBegin(elemType, size);\n      for (i = 0; i < size; i++) {\n        apache::thrift::skip(prot, elemType);\n      }\n      prot.readListEnd();\n      return;\n    }\n    default: {\n      TProtocolException::throwInvalidSkipType(arg_type);\n    }\n  }\n}","target":0,"flaw_line_index":0,"hash":"682f6264-933f-4c6f-ae98-614e46ef83c6","idx":"f58467ec-39e4-4adf-8937-83c4095ab71d"}
{"func_before":"static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic->pending_events;\n}","target":1,"flaw_line_index":0,"hash":"98228aa6-46a2-4205-af89-6db47c646c32","idx":"d9683130-2774-4798-865b-f7da210d381e"}
{"func_before":"static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_has_lapic(vcpu) && vcpu->arch.apic->pending_events;\n}","target":0,"flaw_line_index":0,"hash":"e0e1c22a-08d4-459c-987c-442b4814b5c1","idx":"4feeb9ca-5677-4e0a-a683-07323a96dd5e"}
{"func_before":"TEST_P(SslSocketTest, Ipv6San) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}\/test\/config\/integration\/certs\/upstreamcacert.pem\"\n      match_subject_alt_names:\n        exact: \"::1\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}\/test\/config\/integration\/certs\/upstreamlocalhostcert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}\/test\/config\/integration\/certs\/upstreamlocalhostkey.pem\"\n)EOF\";","target":1,"flaw_line_index":0,"hash":"b520987e-5608-4e93-95d7-d8fe2085031d","idx":"15121bf1-127e-44c8-bbc7-373056f28e14"}
{"func_before":"TEST_P(SslSocketTest, Ipv6San) {\n  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}\/test\/config\/integration\/certs\/upstreamcacert.pem\"\n      match_typed_subject_alt_names:\n      - san_type: IP_ADDRESS\n        matcher:\n          exact: \"::1\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:\n      certificate_chain:\n        filename: \"{{ test_rundir }}\/test\/config\/integration\/certs\/upstreamlocalhostcert.pem\"\n      private_key:\n        filename: \"{{ test_rundir }}\/test\/config\/integration\/certs\/upstreamlocalhostkey.pem\"\n)EOF\";","target":0,"flaw_line_index":0,"hash":"14325f15-b533-4443-a78e-592d3a6b647d","idx":"ed28d199-17ec-4594-9524-ef6392a0f3cd"}
{"func_before":"    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int i, count, name_len, ret;\n    char name[1024];\n\n    avio_rl64(pb);            \/\/ reserved 16 bytes\n    avio_rl64(pb);            \/\/ ...\n    count = avio_rl32(pb);    \/\/ markers count\n    avio_rl16(pb);            \/\/ reserved 2 bytes\n    name_len = avio_rl16(pb); \/\/ name length\n    for (i = 0; i < name_len; i++)\n        avio_r8(pb); \/\/ skip the name\n\n    for (i = 0; i < count; i++) {\n        int64_t pres_time;\n        int name_len;\n\n        avio_rl64(pb);             \/\/ offset, 8 bytes\n        pres_time = avio_rl64(pb); \/\/ presentation time\n        pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             \/\/ entry length\n        avio_rl32(pb);             \/\/ send time\n        avio_rl32(pb);             \/\/ flags\n        name_len = avio_rl32(pb);  \/\/ name length\n        if ((ret = avio_get_str16le(pb, name_len * 2, name,\n                                    sizeof(name))) < name_len)","target":1,"flaw_line_index":0,"hash":"51954b8c-4478-423b-a14d-928c98b8229a","idx":"4c04300a-3dc1-4eea-8fa9-4be4d1744872"}
{"func_before":"    AVIOContext *pb = s->pb;\n    ASFContext *asf = s->priv_data;\n    int i, count, name_len, ret;\n    char name[1024];\n\n    avio_rl64(pb);            \/\/ reserved 16 bytes\n    avio_rl64(pb);            \/\/ ...\n    count = avio_rl32(pb);    \/\/ markers count\n    avio_rl16(pb);            \/\/ reserved 2 bytes\n    name_len = avio_rl16(pb); \/\/ name length\n    avio_skip(pb, name_len);\n\n    for (i = 0; i < count; i++) {\n        int64_t pres_time;\n        int name_len;\n\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n\n        avio_rl64(pb);             \/\/ offset, 8 bytes\n        pres_time = avio_rl64(pb); \/\/ presentation time\n        pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             \/\/ entry length\n        avio_rl32(pb);             \/\/ send time\n        avio_rl32(pb);             \/\/ flags\n        name_len = avio_rl32(pb);  \/\/ name length\n        if ((ret = avio_get_str16le(pb, name_len * 2, name,\n                                    sizeof(name))) < name_len)","target":0,"flaw_line_index":0,"hash":"c565c9b6-b89d-4d9a-98a0-472e6ae1a0b3","idx":"7dc089c5-4605-4f82-a686-2e2524a255cb"}
{"func_before":"                                   platform.ValueOrDie()->Name(), \": \",\n                                   status.ToString());\n    }\n  }\n\n  xla::LocalClientOptions client_options;\n  client_options.set_platform(platform.ValueOrDie());\n  client_options.set_intra_op_parallelism_threads(\n      device->tensorflow_cpu_worker_threads()->num_threads);\n\n  string allowed_gpus =\n      flr->config_proto()->gpu_options().visible_device_list();\n  TF_ASSIGN_OR_RETURN(absl::optional<std::set<int>> gpu_ids,\n                      ParseVisibleDeviceList(allowed_gpus));\n  client_options.set_allowed_devices(gpu_ids);\n\n  auto client = xla::ClientLibrary::GetOrCreateLocalClient(client_options);\n  if (!client.ok()) {\n    return client.status();\n  }\n  const XlaOpRegistry::DeviceRegistration* registration;\n  if (!XlaOpRegistry::GetCompilationDevice(platform_info.device_type().type(),\n                                           &registration)) {\n    return errors::InvalidArgument(\"No JIT device registered for \",\n                                   platform_info.device_type().type());","target":1,"flaw_line_index":0,"hash":"53b333e8-2526-44b9-9155-9bd2b7fd54cd","idx":"d9c6a3f6-e5fa-46e8-9e51-242b479e1242"}
{"func_before":"                                   platform.ValueOrDie()->Name(), \": \",\n                                   status.ToString());\n    }\n  }\n\n  xla::LocalClientOptions client_options;\n  client_options.set_platform(platform.ValueOrDie());\n  client_options.set_intra_op_parallelism_threads(\n      device->tensorflow_cpu_worker_threads()->num_threads);\n\n  if (flr->config_proto()) {\n    string allowed_gpus =\n        flr->config_proto()->gpu_options().visible_device_list();\n    TF_ASSIGN_OR_RETURN(absl::optional<std::set<int>> gpu_ids,\n                        ParseVisibleDeviceList(allowed_gpus));\n    client_options.set_allowed_devices(gpu_ids);\n  }\n\n  auto client = xla::ClientLibrary::GetOrCreateLocalClient(client_options);\n  if (!client.ok()) {\n    return client.status();\n  }\n  const XlaOpRegistry::DeviceRegistration* registration;\n  if (!XlaOpRegistry::GetCompilationDevice(platform_info.device_type().type(),\n                                           &registration)) {\n    return errors::InvalidArgument(\"No JIT device registered for \",\n                                   platform_info.device_type().type());","target":0,"flaw_line_index":0,"hash":"0ace0829-1779-4fce-917a-3a8f18a0067c","idx":"6a2f1fb6-21f1-455a-b420-754ae817fb6a"}
{"func_before":"\tunsigned long lr;\n\tlong level = 0;\n\tstruct signal_frame_64 __user *sigframe;\n\tunsigned long __user *fp, *uregs;\n\n\tnext_ip = perf_instruction_pointer(regs);\n\tlr = regs->link;\n\tsp = regs->gpr[1];\n\tperf_callchain_store(entry, next_ip);\n\n\tfor (;;) {\n\t\tfp = (unsigned long __user *) sp;\n\t\tif (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &next_sp))\n\t\t\treturn;\n\t\tif (level > 0 && read_user_stack_64(&fp[2], &next_ip))\n\t\t\treturn;\n\n\t\t\/*\n\t\t * Note: the next_sp - sp >= signal frame size check\n\t\t * is true when next_sp < sp, which can happen when\n\t\t * transitioning from an alternate signal stack to the","target":1,"flaw_line_index":0,"hash":"67122e46-ffef-44d7-90bb-da38f4623b0d","idx":"486cc25d-a7f3-465f-9ef9-d38979988e0b"}
{"func_before":"\tunsigned long lr;\n\tlong level = 0;\n\tstruct signal_frame_64 __user *sigframe;\n\tunsigned long __user *fp, *uregs;\n\n\tnext_ip = perf_instruction_pointer(regs);\n\tlr = regs->link;\n\tsp = regs->gpr[1];\n\tperf_callchain_store(entry, next_ip);\n\n\twhile (entry->nr < PERF_MAX_STACK_DEPTH) {\n\t\tfp = (unsigned long __user *) sp;\n\t\tif (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &next_sp))\n\t\t\treturn;\n\t\tif (level > 0 && read_user_stack_64(&fp[2], &next_ip))\n\t\t\treturn;\n\n\t\t\/*\n\t\t * Note: the next_sp - sp >= signal frame size check\n\t\t * is true when next_sp < sp, which can happen when\n\t\t * transitioning from an alternate signal stack to the","target":0,"flaw_line_index":0,"hash":"1d2b453b-d709-414c-95fe-e0f310f3408c","idx":"9a824ce2-6b77-47d7-b9ae-92fdc01a65e7"}
{"func_before":"\t\tif (cursor->hashval != sbp->hash) {\n\t\t\tcursor->hashval = sbp->hash;\n\t\t\tcursor->offset = 0;\n\t\t}\n\t\terror = context->put_listent(context,\n\t\t\t\t\tsbp->flags,\n\t\t\t\t\tsbp->name,\n\t\t\t\t\tsbp->namelen,\n\t\t\t\t\tsbp->valuelen,\n\t\t\t\t\t&sbp->name[sbp->namelen]);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\n\tkmem_free(sbuf);\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"1d605d96-07d1-4763-bd2e-f95d4e98721c","idx":"6aec4757-f54f-4b2c-8dad-68e12f6ddff6"}
{"func_before":"\t\tif (cursor->hashval != sbp->hash) {\n\t\t\tcursor->hashval = sbp->hash;\n\t\t\tcursor->offset = 0;\n\t\t}\n\t\terror = context->put_listent(context,\n\t\t\t\t\tsbp->flags,\n\t\t\t\t\tsbp->name,\n\t\t\t\t\tsbp->namelen,\n\t\t\t\t\tsbp->valuelen,\n\t\t\t\t\t&sbp->name[sbp->namelen]);\n\t\tif (error) {\n\t\t\tkmem_free(sbuf);\n\t\t\treturn error;\n\t\t}\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n\n\tkmem_free(sbuf);\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"82efe816-1558-4863-b19c-1f637b5d9492","idx":"5e142303-95e8-449d-ab98-f711132d68c5"}
{"func_before":"void handle_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        uint8_t buf[64];\n        memcpy(buf, msg, sizeof(buf));\n\n        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n        uint32_t msgSize = buf[8]        |\n                ((uint32_t)buf[7]) <<  8 |\n                ((uint32_t)buf[6]) << 16 |\n                ((uint32_t)buf[5]) << 24;\n\n        if (msgSize > 64 - 9) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n            return;\n        }\n\n        \/\/ Determine callback handler and message map type.\n        const MessagesMap_t *entry = message_map_entry(NORMAL_MSG, msgId, IN_MSG);\n        if (!entry) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n            return;\n        }\n\n        tiny_dispatch(entry, buf + 9, msgSize);\n    } else {\n        usb_rx_helper(msg, len, NORMAL_MSG);\n    }\n}","target":1,"flaw_line_index":0,"hash":"a0888616-ce7b-486a-94a9-65c600ef2ba5","idx":"1f40cdba-8733-4e15-90df-e397d8212a45"}
{"func_before":"void handle_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        msg_read_tiny(msg, len);\n    } else {\n        usb_rx_helper(msg, len, NORMAL_MSG);\n    }\n}","target":0,"flaw_line_index":0,"hash":"211de683-bba2-4e6a-a318-3ca5906dc23e","idx":"e9c0d8da-ce06-43fe-8c74-a10f54b4a1d1"}
{"func_before":"        if (frame->color_range != AVCOL_RANGE_UNSPECIFIED)\n            print_str(\"color_range\", av_color_range_name(frame->color_range));\n        else\n            print_str_opt(\"color_range\", av_color_range_name(frame->color_range));\n\n        if (frame->colorspace != AVCOL_SPC_UNSPECIFIED)\n            print_str(\"color_space\", av_color_space_name(frame->colorspace));\n        else\n            print_str_opt(\"color_space\", av_color_space_name(frame->colorspace));\n\n        if (frame->color_primaries != AVCOL_PRI_UNSPECIFIED)\n            print_str(\"color_primaries\", av_color_primaries_name(frame->color_primaries));\n        else\n            print_str_opt(\"color_primaries\", av_color_primaries_name(frame->color_primaries));\n\n        if (frame->color_trc != AVCOL_TRC_UNSPECIFIED)\n            print_str(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n        else\n            print_str_opt(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n\n        if (frame->chroma_location != AVCHROMA_LOC_UNSPECIFIED)\n            print_str(\"chroma_location\", av_chroma_location_name(frame->chroma_location));\n        else\n            print_str_opt(\"chroma_location\", av_chroma_location_name(frame->chroma_location));","target":1,"flaw_line_index":0,"hash":"1500440e-aa90-4d67-9845-db5079070138","idx":"452b256a-5691-4b32-a949-579fe35d56c0"}
{"func_before":"        if (frame->color_range != AVCOL_RANGE_UNSPECIFIED)\n            print_str(\"color_range\", av_color_range_name(frame->color_range));\n        else\n            print_str_opt(\"color_range\", av_color_range_name(frame->color_range));\n\n        if (frame->colorspace != AVCOL_SPC_UNSPECIFIED)\n            print_str(\"color_space\", av_color_space_name(frame->colorspace));\n        else\n            print_str_opt(\"color_space\", av_color_space_name(frame->colorspace));\n\n        print_primaries(w, frame->color_primaries);\n\n        if (frame->color_trc != AVCOL_TRC_UNSPECIFIED)\n            print_str(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n        else\n            print_str_opt(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n\n        if (frame->chroma_location != AVCHROMA_LOC_UNSPECIFIED)\n            print_str(\"chroma_location\", av_chroma_location_name(frame->chroma_location));\n        else\n            print_str_opt(\"chroma_location\", av_chroma_location_name(frame->chroma_location));","target":0,"flaw_line_index":0,"hash":"d38a2425-a708-44c1-90a7-32212888db0e","idx":"d4f96bda-0cb5-4644-a5db-2b3724e5dbdf"}
{"func_before":"void IOBuf::reserveSlow(std::size_t minHeadroom, std::size_t minTailroom) {\n  size_t newCapacity = (size_t)length_ + minHeadroom + minTailroom;\n  DCHECK_LT(newCapacity, UINT32_MAX);\n\n  \/\/ reserveSlow() is dangerous if anyone else is sharing the buffer, as we may\n  \/\/ reallocate and free the original buffer.  It should only ever be called if\n  \/\/ we are the only user of the buffer.\n  DCHECK(!isSharedOne());\n\n  \/\/ We'll need to reallocate the buffer.\n  \/\/ There are a few options.\n  \/\/ - If we have enough total room, move the data around in the buffer\n  \/\/   and adjust the data_ pointer.","target":1,"flaw_line_index":0,"hash":"42306aae-a739-4420-a94e-bace028705c1","idx":"a43b39df-ab19-4ddb-b5a9-8d82c3e06522"}
{"func_before":"void IOBuf::reserveSlow(std::size_t minHeadroom, std::size_t minTailroom) {\n  size_t newCapacity = length_;\n  if (!checked_add(&newCapacity, newCapacity, minHeadroom) ||\n      !checked_add(&newCapacity, newCapacity, minTailroom) ||\n      newCapacity > kMaxIOBufSize) {\n    \/\/ overflow\n    throw_exception<std::bad_alloc>();\n  }\n\n  \/\/ reserveSlow() is dangerous if anyone else is sharing the buffer, as we may\n  \/\/ reallocate and free the original buffer.  It should only ever be called if\n  \/\/ we are the only user of the buffer.\n  DCHECK(!isSharedOne());\n\n  \/\/ We'll need to reallocate the buffer.\n  \/\/ There are a few options.\n  \/\/ - If we have enough total room, move the data around in the buffer\n  \/\/   and adjust the data_ pointer.","target":0,"flaw_line_index":0,"hash":"67bf8010-502e-4a1d-86ff-d3b28408582f","idx":"f16919de-6662-46f9-8dda-e9fba9b0628b"}
{"func_before":"static int msg_parse_fetch (IMAP_HEADER *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp;\n\n  if (!s)\n    return -1;\n\n  while (*s)\n  {\n    SKIPWS (s);\n\n    if (ascii_strncasecmp (\"FLAGS\", s, 5) == 0)\n    {\n    {\n      s += 12;\n      SKIPWS (s);\n      if (*s != '\\\"')\n      {\n        dprint (1, (debugfile, \"msg_parse_fetch(): bogus INTERNALDATE entry: %s\\n\", s));\n        return -1;\n      }\n      s++;\n      ptmp = tmp;\n      while (*s && *s != '\\\"')\n        *ptmp++ = *s++;\n      if (*s != '\\\"')\n        return -1;\n      s++; \/* skip past the trailing \" *\/\n      *ptmp = 0;\n      h->received = imap_parse_date (tmp);\n    }\n    else if (ascii_strncasecmp (\"RFC822.SIZE\", s, 11) == 0)\n    {\n      s += 11;\n      SKIPWS (s);\n      ptmp = tmp;\n      while (isdigit ((unsigned char) *s))\n        *ptmp++ = *s++;\n      *ptmp = 0;\n      if (mutt_atol (tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if (!ascii_strncasecmp (\"BODY\", s, 4) ||\n      !ascii_strncasecmp (\"RFC822.HEADER\", s, 13))\n    {\n      \/* handle above, in msg_fetch_header *\/\n      return -2;\n    }","target":1,"flaw_line_index":0,"hash":"33fbcdea-897a-4806-b1b1-d4ae246944ec","idx":"e91b96eb-83c9-4c71-85c2-14ae59db9e9d"}
{"func_before":"static int msg_parse_fetch (IMAP_HEADER *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp;\n  size_t dlen;\n\n  if (!s)\n    return -1;\n\n  while (*s)\n  {\n    SKIPWS (s);\n\n    if (ascii_strncasecmp (\"FLAGS\", s, 5) == 0)\n    {\n    {\n      s += 12;\n      SKIPWS (s);\n      if (*s != '\\\"')\n      {\n        dprint (1, (debugfile, \"msg_parse_fetch(): bogus INTERNALDATE entry: %s\\n\", s));\n        return -1;\n      }\n      s++;\n      ptmp = tmp;\n      dlen = sizeof(tmp) - 1;\n      while (*s && *s != '\\\"' && dlen)\n      {\n        *ptmp++ = *s++;\n        dlen--;\n      }\n      if (*s != '\\\"')\n        return -1;\n      s++; \/* skip past the trailing \" *\/\n      *ptmp = 0;\n      h->received = imap_parse_date (tmp);\n    }\n    else if (ascii_strncasecmp (\"RFC822.SIZE\", s, 11) == 0)\n    {\n      s += 11;\n      SKIPWS (s);\n      ptmp = tmp;\n      dlen = sizeof(tmp) - 1;\n      while (isdigit ((unsigned char) *s) && dlen)\n      {\n        *ptmp++ = *s++;\n        dlen--;\n      }\n      *ptmp = 0;\n      if (mutt_atol (tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if (!ascii_strncasecmp (\"BODY\", s, 4) ||\n      !ascii_strncasecmp (\"RFC822.HEADER\", s, 13))\n    {\n      \/* handle above, in msg_fetch_header *\/\n      return -2;\n    }","target":0,"flaw_line_index":0,"hash":"a1668e34-0b6f-4bd0-804f-6f14888f1f30","idx":"40b195bd-12cc-453e-90be-fe6823143573"}
{"func_before":"static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint16 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n","target":1,"flaw_line_index":0,"hash":"f5b1dbeb-f376-4e13-8f90-dee90719319d","idx":"44d583cc-0ae9-4be0-88d1-282187d58032"}
{"func_before":"static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint32 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n\n        if (scanline_size == 0) {\n                TIFFError(\"\", \"TIFF scanline size is zero!\");    \n                return 0;\n        }\n","target":0,"flaw_line_index":0,"hash":"fd319a2f-af1b-49f2-89a7-4da03fec9a61","idx":"ee1b87ba-cdb5-4577-a24d-6c6ae2ce1dbe"}
{"func_before":"MONGO_EXPORT int bson_append_binary( bson *b, const char *name, char type, const char *str, int len ) {\n    if ( type == BSON_BIN_BINARY_OLD ) {\n        int subtwolen = len + 4;\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+4+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32( b, &subtwolen );\n        bson_append_byte( b, type );\n        bson_append32( b, &len );\n        bson_append( b, str, len );\n    }\n    else {\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32( b, &len );\n        bson_append_byte( b, type );\n        bson_append( b, str, len );\n    }\n    return BSON_OK;\n}","target":1,"flaw_line_index":0,"hash":"d7b0c759-65d1-4121-93c5-f87367c89e6f","idx":"2ffef15b-6e88-4083-be76-ae7ea6456742"}
{"func_before":"MONGO_EXPORT int bson_append_binary( bson *b, const char *name, char type, const char *str, size_t len ) {\n    if ( type == BSON_BIN_BINARY_OLD ) {\n        int subtwolen = len + 4;\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+4+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32_as_int( b, ( int )subtwolen );\n        bson_append_byte( b, type );\n        bson_append32_as_int( b, ( int )len );\n        bson_append( b, str, len );\n    }\n    else {\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32_as_int( b, ( int )len );\n        bson_append_byte( b, type );\n        bson_append( b, str, len );\n    }\n    return BSON_OK;\n}","target":0,"flaw_line_index":0,"hash":"62747370-6291-4ee2-af95-9f7d6550ebcc","idx":"cc1e0871-abd7-4d6c-aef5-fcbe0c9ba356"}
{"func_before":"static void show_object(struct object *obj,\n\t\t\tstruct strbuf *path, const char *component,\n\t\t\tvoid *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tfinish_object(obj, path, component, cb_data);\n\tif (info->flags & REV_LIST_QUIET)\n\t\treturn;\n\tshow_object_with_name(stdout, obj, path, component);\n}","target":1,"flaw_line_index":0,"hash":"efafbc62-ebd7-497f-b431-716aab4e0467","idx":"47a66348-8e5e-48d3-87db-f86c002a2ed0"}
{"func_before":"static void show_object(struct object *obj, const char *name, void *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tfinish_object(obj, name, cb_data);\n\tif (info->flags & REV_LIST_QUIET)\n\t\treturn;\n\tshow_object_with_name(stdout, obj, name);\n}","target":0,"flaw_line_index":0,"hash":"f22a15b6-41b1-4237-a778-134d3ddb2d22","idx":"199b03c6-c18f-4a6b-9bec-13730dbb0429"}
{"func_before":"          if (LLVM_LIKELY(numVal == uintVal) && \/\/ Only integers.\n              LLVM_LIKELY(uintVal >= ip->iSwitchImm.op4) && \/\/ Bounds checking.\n              LLVM_LIKELY(uintVal <= ip->iSwitchImm.op5)) \/\/ Bounds checking.\n          {\n            \/\/ Calculate the offset into the bytecode where the jump table for\n            \/\/ this SwitchImm starts.\n            const uint8_t *tablestart = (const uint8_t *)llvh::alignAddr(\n                (const uint8_t *)ip + ip->iSwitchImm.op2, sizeof(uint32_t));\n\n            \/\/ Read the offset from the table.\n            const uint32_t *loc =\n                (const uint32_t *)tablestart + uintVal - ip->iSwitchImm.op4;\n\n            ip = IPADD(*loc);\n            DISPATCH;\n          }\n        }\n        \/\/ Wrong type or out of range, jump to default.\n        ip = IPADD(ip->iSwitchImm.op3);\n        DISPATCH;\n      }\n      LOAD_CONST(","target":1,"flaw_line_index":0,"hash":"d366a55f-a838-486d-a387-afde3f3d5aab","idx":"1395a655-8b65-43e6-b6b9-e9e221641aa9"}
{"func_before":"          if (LLVM_LIKELY(numVal == uintVal) && \/\/ Only integers.\n              LLVM_LIKELY(uintVal >= ip->iSwitchImm.op4) && \/\/ Bounds checking.\n              LLVM_LIKELY(uintVal <= ip->iSwitchImm.op5)) \/\/ Bounds checking.\n          {\n            \/\/ Calculate the offset into the bytecode where the jump table for\n            \/\/ this SwitchImm starts.\n            const uint8_t *tablestart = (const uint8_t *)llvh::alignAddr(\n                (const uint8_t *)ip + ip->iSwitchImm.op2, sizeof(uint32_t));\n\n            \/\/ Read the offset from the table.\n            \/\/ Must be signed to account for backwards branching.\n            const int32_t *loc =\n                (const int32_t *)tablestart + uintVal - ip->iSwitchImm.op4;\n\n            ip = IPADD(*loc);\n            DISPATCH;\n          }\n        }\n        \/\/ Wrong type or out of range, jump to default.\n        ip = IPADD(ip->iSwitchImm.op3);\n        DISPATCH;\n      }\n      LOAD_CONST(","target":0,"flaw_line_index":0,"hash":"a0ea2f69-1301-4077-b088-8650ca5d2422","idx":"75d0c250-2816-4af8-9d14-46a2b14359f9"}
{"func_before":"\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (collen > 0)\n\t\t\t\t{\n\t\t\t\t\tcolor = CVAL(in);\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (replen > 0)\n\t\t\t\t{\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (collen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = CVAL(in);\n\t\t\t\t\tif (x & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tx = x + 1;\n\t\t\t\t\t\tcolor = -x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tcolor = x;\n\t\t\t\t\t}\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (replen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tindexh++;","target":1,"flaw_line_index":0,"hash":"41102421-f4f6-4e36-9b4e-23b06f3d14d6","idx":"c9c7f95e-a0cb-42be-9a90-ab8515e115f8"}
{"func_before":"\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && collen > 0)\n\t\t\t\t{\n\t\t\t\t\tcolor = CVAL(in);\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && replen > 0)\n\t\t\t\t{\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t{\n\t\t\t\tcode = CVAL(in);\n\t\t\t\treplen = code & 0xf;\n\t\t\t\tcollen = (code >> 4) & 0xf;\n\t\t\t\trevcode = (replen << 4) | collen;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && collen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = CVAL(in);\n\t\t\t\t\tif (x & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tx = x + 1;\n\t\t\t\t\t\tcolor = -x;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t\tcolor = x;\n\t\t\t\t\t}\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && replen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tindexh++;","target":0,"flaw_line_index":0,"hash":"123342dd-1200-4ed7-a586-f2cd08fa9bcb","idx":"5d1fad54-d114-438b-9a6e-40c6778076bb"}
{"func_before":"RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;","target":1,"flaw_line_index":0,"hash":"24909410-7238-4b60-b37a-0a2e59e15667","idx":"7eee4113-847d-4c8c-849d-4305e1c84ae7"}
{"func_before":"RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin || !bin->segment_entries) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);\n\t\tif (!bs) {\n\t\t\treturn segments;\n\t\t}\n\t\tNE_image_segment_entry *se = &bin->segment_entries[i];\n\t\tbs->size = se->length;","target":0,"flaw_line_index":0,"hash":"1689808e-1982-44b7-8a15-24721763116c","idx":"b0835e91-0d43-4e7f-8fa9-67c236057d28"}
{"func_before":"\t\t}\n\t\tn->m_pkthdr.len -= len0;\n\t\tolen = m0->m_pkthdr.len;\n\t\tm0->m_pkthdr.len = len0;\n\t\tif (remain == 0) {\n\t\t\tn->m_next = m->m_next;\n\t\t\tm->m_next = NULL;\n\t\t\tn->m_len = 0;\n\t\t\treturn (n);\n\t\t}\n\t\tif (m->m_flags & M_EXT)\n\t\t\tgoto extpacket;\n\t\tif (remain > MHLEN) {\n\t\t\t\/* m can't be the lead packet *\/\n\t\t\tm_align(n, 0);\n\t\t\tn->m_next = m_split(m, len, wait);\n\t\t\tif (n->m_next == NULL) {\n\t\t\t\t(void) m_free(n);\n\t\t\t\tm0->m_pkthdr.len = olen;\n\t\t\t\treturn (NULL);\n\t\t\t} else {\n\t\t\t\tn->m_len = 0;\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t} else\n\t\t\tm_align(n, remain);\n\t} else if (remain == 0) {\n\t\tn = m->m_next;\n\t\tm->m_next = NULL;\n\t\treturn (n);\n\t} else {\n\t\tMGET(n, wait, m->m_type);\n\t\tif (n == NULL)\n\t\t\treturn (NULL);\n\t\tm_align(n, remain);\n\t}\nextpacket:\n\tif (m->m_flags & M_EXT) {\n\t\tn->m_ext = m->m_ext;\n\t\tMCLADDREFERENCE(m, n);\n\t\tn->m_data = m->m_data + len;\n\t} else {\n\t\tmemcpy(mtod(n, caddr_t), mtod(m, caddr_t) + len, remain);\n\t}\n\tn->m_len = remain;\n\tm->m_len = len;\n\tn->m_next = m->m_next;\n\tm->m_next = NULL;\n\treturn (n);\n}","target":1,"flaw_line_index":0,"hash":"8180a7f2-ff62-4e5c-bf56-b0db8c652aff","idx":"2f7ee598-c904-480f-95cd-a8f034385989"}
{"func_before":"\t\t}\n\t\tn->m_pkthdr.len -= len0;\n\t\tolen = m0->m_pkthdr.len;\n\t\tm0->m_pkthdr.len = len0;\n\t\tif (remain == 0) {\n\t\t\tn->m_next = m->m_next;\n\t\t\tm->m_next = NULL;\n\t\t\tn->m_len = 0;\n\t\t\treturn (n);\n\t\t}\n\t\tif ((m->m_flags & M_EXT) == 0 && remain > MHLEN) {\n\t\t\t\/* m can't be the lead packet *\/\n\t\t\tm_align(n, 0);\n\t\t\tn->m_next = m_split(m, len, wait);\n\t\t\tif (n->m_next == NULL) {\n\t\t\t\t(void) m_free(n);\n\t\t\t\tm0->m_pkthdr.len = olen;\n\t\t\t\treturn (NULL);\n\t\t\t} else {\n\t\t\t\tn->m_len = 0;\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t}\n\t} else if (remain == 0) {\n\t\tn = m->m_next;\n\t\tm->m_next = NULL;\n\t\treturn (n);\n\t} else {\n\t\tMGET(n, wait, m->m_type);\n\t\tif (n == NULL)\n\t\t\treturn (NULL);\n\t}\n\tif (m->m_flags & M_EXT) {\n\t\tn->m_ext = m->m_ext;\n\t\tMCLADDREFERENCE(m, n);\n\t\tn->m_data = m->m_data + len;\n\t} else {\n\t\tm_align(n, remain);\n\t\tmemcpy(mtod(n, caddr_t), mtod(m, caddr_t) + len, remain);\n\t}\n\tn->m_len = remain;\n\tm->m_len = len;\n\tn->m_next = m->m_next;\n\tm->m_next = NULL;\n\treturn (n);\n}","target":0,"flaw_line_index":0,"hash":"1bae4dff-bf03-4b12-9217-af960de0ba80","idx":"0e601fcb-705a-44f2-bed1-765102936b5d"}
{"func_before":"\t\t\tdo {\n\t\t\t\tspl_filesystem_dir_read(intern TSRMLS_CC);\n\t\t\t} while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n\t\t}\n\t\tintern->u.dir.index = index;\n\t\tbreak;\n\tcase SPL_FS_FILE:\n\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"An object of class %s cannot be cloned\", old_object->ce->name);\n\t\tbreak;\n\t}\n\t\n\tintern->file_class = source->file_class;\n\tintern->info_class = source->info_class;\n\tintern->oth = source->oth;\n\tintern->oth_handler = source->oth_handler;\n\n\tzend_objects_clone_members(new_object, new_obj_val, old_object, handle TSRMLS_CC);\n\n\tif (intern->oth_handler && intern->oth_handler->clone) {\n\t\tintern->oth_handler->clone(source, intern TSRMLS_CC);\n\t}","target":1,"flaw_line_index":0,"hash":"801001af-29c1-43bf-a15f-68dd29f71a5e","idx":"42e59ed2-2cff-458a-8a51-f87a7a3a1f18"}
{"func_before":"\t\t\tdo {\n\t\t\t\tspl_filesystem_dir_read(intern TSRMLS_CC);\n\t\t\t} while (skip_dots && spl_filesystem_is_dot(intern->u.dir.entry.d_name));\n\t\t}\n\t\tintern->u.dir.index = index;\n\t\tbreak;\n\tcase SPL_FS_FILE:\n\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"An object of class %s cannot be cloned\", old_object->ce->name);\n\t\tbreak;\n\t}\n\n\tintern->file_class = source->file_class;\n\tintern->info_class = source->info_class;\n\tintern->oth = source->oth;\n\tintern->oth_handler = source->oth_handler;\n\n\tzend_objects_clone_members(new_object, new_obj_val, old_object, handle TSRMLS_CC);\n\n\tif (intern->oth_handler && intern->oth_handler->clone) {\n\t\tintern->oth_handler->clone(source, intern TSRMLS_CC);\n\t}","target":0,"flaw_line_index":0,"hash":"d19fb8ee-0e4a-4e1c-8576-c2f7c1bce314","idx":"1b5f2925-cddf-44b6-96a7-0f4a01cc76c6"}
{"func_before":"\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t\/* Setup the next registration attempt *\/\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh \/ 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t\/* Setup the next registration a little early *\/\n\treg->expire = iax2_sched_replace(reg->expire, sched, ","target":1,"flaw_line_index":0,"hash":"98cb087e-bfc3-4b43-92ff-e7d09e97fc2c","idx":"9fce2b67-d5ca-4c4b-a7b7-8086a9610603"}
{"func_before":"\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t\/* Setup the next registration attempt *\/\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh \/ 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t\/* Setup the next registration a little early *\/\n\treg->expire = iax2_sched_replace(reg->expire, sched, ","target":0,"flaw_line_index":0,"hash":"1a9de670-dac0-404c-af21-94d65d8f26e4","idx":"8c03042f-5c7b-43e6-a6cf-faa42d7f54fa"}
{"func_before":"static int sendMessageAndForget(short ptype, short paylen, const void* payload) {\n    int ret;\n\n    \/\/ Unlike regular sockets, ENet sockets aren't safe to invoke from multiple\n    \/\/ threads at once. We have to synchronize them with a lock.\n    if (ServerMajorVersion >= 5) {\n        PltLockMutex(&enetMutex);\n        ret = sendMessageEnet(ptype, paylen, payload);\n        PltUnlockMutex(&enetMutex);\n    }\n    else {\n        ret = sendMessageTcp(ptype, paylen, payload);\n    }\n\n    return ret;\n}","target":1,"flaw_line_index":0,"hash":"187ab9b3-1ea2-444a-91d6-240b30e27527","idx":"396f5714-a7c0-4f45-83b0-9e3066166ad4"}
{"func_before":"static int sendMessageAndForget(short ptype, short paylen, const void* payload) {\n    int ret;\n\n    \/\/ Unlike regular sockets, ENet sockets aren't safe to invoke from multiple\n    \/\/ threads at once. We have to synchronize them with a lock.\n    if (AppVersionQuad[0] >= 5) {\n        PltLockMutex(&enetMutex);\n        ret = sendMessageEnet(ptype, paylen, payload);\n        PltUnlockMutex(&enetMutex);\n    }\n    else {\n        ret = sendMessageTcp(ptype, paylen, payload);\n    }\n\n    return ret;\n}","target":0,"flaw_line_index":0,"hash":"428d7494-8355-4e51-8a6c-3b83f23f63e8","idx":"b34613e7-f64c-4c64-a28d-b690f9254ab5"}
{"func_before":"\tstruct crypto_alg *alg;\n\n\tif (!name)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tmask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);\n\ttype &= mask;\n\n\talg = crypto_alg_lookup(name, type, mask);\n\tif (!alg) {\n\t\trequest_module(\"%s\", name);\n\n\t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n\t\t      CRYPTO_ALG_NEED_FALLBACK))\n\t\t\trequest_module(\"%s-all\", name);\n\n\t\talg = crypto_alg_lookup(name, type, mask);\n\t}\n\n\tif (alg)\n\t\treturn crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;\n\n\treturn crypto_larval_add(name, type, mask);\n}","target":1,"flaw_line_index":0,"hash":"269b5fbb-675e-4bd5-b2f4-4efbddf4a546","idx":"986d07c2-9168-4e24-82c3-eef5909e460d"}
{"func_before":"\tstruct crypto_alg *alg;\n\n\tif (!name)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tmask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);\n\ttype &= mask;\n\n\talg = crypto_alg_lookup(name, type, mask);\n\tif (!alg) {\n\t\trequest_module(\"crypto-%s\", name);\n\n\t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n\t\t      CRYPTO_ALG_NEED_FALLBACK))\n\t\t\trequest_module(\"crypto-%s-all\", name);\n\n\t\talg = crypto_alg_lookup(name, type, mask);\n\t}\n\n\tif (alg)\n\t\treturn crypto_is_larval(alg) ? crypto_larval_wait(alg) : alg;\n\n\treturn crypto_larval_add(name, type, mask);\n}","target":0,"flaw_line_index":0,"hash":"054eda11-56ff-4e60-8efb-46e011e59f76","idx":"abdac056-5dc1-4189-a429-ee966be280bd"}
{"func_before":"static int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info;\n\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\treturn do_send_specific(tgid, pid, sig, &info);\n}","target":1,"flaw_line_index":0,"hash":"821da2c3-926e-4c45-9222-d2cd29b85945","idx":"fcbf553c-2f25-4315-a0c2-055fb558da84"}
{"func_before":"static int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info = {};\n\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\treturn do_send_specific(tgid, pid, sig, &info);\n}","target":0,"flaw_line_index":0,"hash":"55d149d6-6a8b-4489-a6e2-aa56cae95674","idx":"8d2ca5a5-1d37-438c-a916-3e4da6d42a41"}
{"func_before":"chpass_principal3_2_svc(chpass3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_chpass_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","target":1,"flaw_line_index":0,"hash":"4bcc14ef-1a94-4499-af1c-9ef34fd7928a","idx":"649fa735-47bb-42d4-add8-a7533d41ef35"}
{"func_before":"chpass_principal3_2_svc(chpass3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n    if ((ret.code = check_handle((void *)handle)))\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_chpass_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","target":0,"flaw_line_index":0,"hash":"c87bbc1f-955d-4e99-9b6b-b1691576c1de","idx":"53d7cedf-d0de-42bb-92e9-c8aa85d30bd3"}
{"func_before":"ngx_http_lua_copy_request_headers(ngx_http_request_t *sr, ngx_http_request_t *r)\n{\n    ngx_table_elt_t                 *header;\n    ngx_list_part_t                 *part;\n    ngx_uint_t                       i;\n\n    if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    dd(\"before: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n\n    part = &r->headers_in.headers.part;\n    header = part->elts;\n\n    for (i = 0; \/* void *\/; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        dd(\"setting request header %.*s: %.*s\", (int) header[i].key.len,\n           header[i].key.data, (int) header[i].value.len,\n           header[i].value.data);\n\n        if (ngx_http_lua_set_input_header(sr, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    dd(\"after: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n\n    return NGX_OK;\n}","target":1,"flaw_line_index":0,"hash":"aa4f3525-245d-4519-a74c-f8131db0c0b0","idx":"edc72a06-f83b-4697-850d-d824807f4cb1"}
{"func_before":"ngx_http_lua_copy_request_headers(ngx_http_request_t *sr,\n    ngx_http_request_t *pr, int pr_not_chunked)\n{\n    ngx_table_elt_t                 *clh, *header;\n    ngx_list_part_t                 *part;\n    ngx_uint_t                       i;\n    u_char                          *p;\n    off_t                            len;\n\n    dd(\"before: parent req headers count: %d\",\n       (int) pr->headers_in.headers.part.nelts);\n\n    if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    if (sr->request_body && !pr_not_chunked) {\n\n        \/* craft our own Content-Length *\/\n\n        len = sr->request_body->buf ? ngx_buf_size(sr->request_body->buf) : 0;\n\n        clh = ngx_list_push(&sr->headers_in.headers);\n        if (clh == NULL) {\n            return NGX_ERROR;\n        }\n\n        clh->hash = ngx_http_lua_content_length_hash;\n        clh->key = ngx_http_lua_content_length_header_key;\n        clh->lowcase_key = ngx_pnalloc(sr->pool, clh->key.len);\n        if (clh->lowcase_key == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_strlow(clh->lowcase_key, clh->key.data, clh->key.len);\n\n        p = ngx_palloc(sr->pool, NGX_OFF_T_LEN);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        clh->value.data = p;\n        clh->value.len = ngx_sprintf(clh->value.data, \"%O\", len)\n                         - clh->value.data;\n\n        sr->headers_in.content_length = clh;\n        sr->headers_in.content_length_n = len;\n\n        dd(\"sr crafted content-length: %.*s\",\n           (int) sr->headers_in.content_length->value.len,\n           sr->headers_in.content_length->value.data);\n    }\n\n    \/* copy the parent request's headers *\/\n\n    part = &pr->headers_in.headers.part;\n    header = part->elts;\n\n    for (i = 0; \/* void *\/; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        if (!pr_not_chunked && header[i].key.len == sizeof(\"Content-Length\") - 1\n            && ngx_strncasecmp(header[i].key.data, (u_char *) \"Content-Length\",\n                               sizeof(\"Content-Length\") - 1) == 0)\n        {\n            continue;\n        }\n\n        dd(\"sr copied req header %.*s: %.*s\", (int) header[i].key.len,\n           header[i].key.data, (int) header[i].value.len,\n           header[i].value.data);\n\n        if (ngx_http_lua_set_input_header(sr, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    dd(\"after: parent req headers count: %d\",\n       (int) pr->headers_in.headers.part.nelts);\n\n    return NGX_OK;\n}","target":0,"flaw_line_index":0,"hash":"af8cae60-0c7c-4933-903f-5663f03bbd5a","idx":"a23efc5f-53e3-4be2-8428-e35e8acd4ecd"}
{"func_before":"void fp2_write_bin(uint8_t *bin, int len, const fp2_t a, int pack) {\n\tfp2_t t;\n\n\tfp2_null(t);\n\n\tRLC_TRY {\n\t\tfp2_new(t);\n\n\t\tif (pack && fp2_test_cyc(a)) {\n\t\t\tif (len < RLC_FP_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);","target":1,"flaw_line_index":0,"hash":"3e089ec9-a615-4821-90d0-e960292f9a78","idx":"6838f341-7740-42b8-b6e2-63e53d4b90e9"}
{"func_before":"void fp2_write_bin(uint8_t *bin, size_t len, const fp2_t a, int pack) {\n\tfp2_t t;\n\n\tfp2_null(t);\n\n\tRLC_TRY {\n\t\tfp2_new(t);\n\n\t\tif (pack && fp2_test_cyc(a)) {\n\t\t\tif (len < RLC_FP_BYTES + 1) {\n\t\t\t\tRLC_THROW(ERR_NO_BUFFER);","target":0,"flaw_line_index":0,"hash":"bf1028d3-276e-48e9-89bb-5a35820037cc","idx":"ac1f327d-c57a-4e3e-99fe-cb93b578b85c"}
{"func_before":"static int my_login(pTHX_ SV* dbh, imp_dbh_t *imp_dbh)\n{\n  SV* sv;\n  HV* hv;\n  char* dbname;\n  char* host;\n  char* port;\n  char* user;\n  char* password;\n  char* mysql_socket;\n  int   result;\n  D_imp_xxh(dbh);\n\n  \/* TODO- resolve this so that it is set only if DBI is 1.607 *\/\n#define TAKE_IMP_DATA_VERSION 1\n#if TAKE_IMP_DATA_VERSION\n  if (DBIc_has(imp_dbh, DBIcf_IMPSET))\n  { \/* eg from take_imp_data() *\/\n    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n  if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,\" \\\n\t\t  \"host = %s, port = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\",\n\t\t  host ? host : \"NULL\",\n\t\t  port ? port : \"NULL\");\n\n  if (!imp_dbh->pmysql) {\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\n  }\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\n  if (!result)\n      Safefree(imp_dbh->pmysql);\n  return result;\n}","target":1,"flaw_line_index":0,"hash":"0930c1cb-f867-40e9-9639-b0ec2dee8d2d","idx":"ae70d4e6-2d04-45d9-96cb-a8a1653a8b94"}
{"func_before":"{\n  SV* sv;\n  HV* hv;\n  char* dbname;\n  char* host;\n  char* port;\n  char* user;\n  char* password;\n  char* mysql_socket;\n  int   result;\n  int\tfresh = 0;\n  D_imp_xxh(dbh);\n\n  \/* TODO- resolve this so that it is set only if DBI is 1.607 *\/\n#define TAKE_IMP_DATA_VERSION 1\n#if TAKE_IMP_DATA_VERSION\n  if (DBIc_has(imp_dbh, DBIcf_IMPSET))\n  { \/* eg from take_imp_data() *\/\n    if (DBIc_has(imp_dbh, DBIcf_ACTIVE))\n    {\n      if (DBIc_TRACE_LEVEL(imp_xxh) >= 2)\n    PerlIO_printf(DBIc_LOGPIO(imp_xxh),\n\t\t  \"imp_dbh->my_login : dbname = %s, uid = %s, pwd = %s,\" \\\n\t\t  \"host = %s, port = %s\\n\",\n\t\t  dbname ? dbname : \"NULL\",\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\",\n\t\t  host ? host : \"NULL\",\n\t\t  port ? port : \"NULL\");\n\n  if (!imp_dbh->pmysql) {\n     fresh = 1;\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\n  }\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\n  if (fresh && !result) {\n      \/* Prevent leaks, but do not free in case of a reconnect. See #97625 *\/\n      do_error(dbh, mysql_errno(imp_dbh->pmysql),\n              mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n      Safefree(imp_dbh->pmysql);\n      imp_dbh->pmysql = NULL;\n  }\n  return result;\n}","target":0,"flaw_line_index":0,"hash":"7384ec76-7914-4e05-93a7-c9fd30dc4e29","idx":"626aea8d-688b-4388-94b2-22bc0e431ce4"}
{"func_before":"\tif (a->getType() == IAction::Move) {\n\t\tIMoveAction *ma = (IMoveAction*)a;\n\n\t\tma->from_inv.applyCurrentPlayer(player->getName());\n\t\tma->to_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ma->from_inv);\n\t\tif (ma->from_inv != ma->to_inv)\n\t\t\tm_inventory_mgr->setInventoryModified(ma->to_inv);\n\n\t\tbool from_inv_is_current_player =\n\t\t\t(ma->from_inv.type == InventoryLocation::PLAYER) &&\n\t\t\t(ma->from_inv.name == player->getName());\n\n\t\tbool to_inv_is_current_player =\n\t\t\t(ma->to_inv.type == InventoryLocation::PLAYER) &&\n\t\t\t(ma->to_inv.name == player->getName());\n\n\t\tInventoryLocation *remote = from_inv_is_current_player ?\n\t\t\t&ma->to_inv : &ma->from_inv;\n\n\t\t\/\/ Check for out-of-range interaction\n\t\tif (remote->type == InventoryLocation::NODEMETA) {\n\t\t\tv3f node_pos   = intToFloat(remote->p, BS);\n\t\t\tv3f player_pos = player->getPlayerSAO()->getEyePosition();\n\t\t\tf32 d = player_pos.getDistanceFrom(node_pos);\n\t\t\tif (!checkInteractDistance(player, d, \"inventory\"))","target":1,"flaw_line_index":0,"hash":"328dcc80-25cc-46a6-a476-193c5dbe84fe","idx":"b524d91b-efc8-4653-b5df-abe45ac3a97a"}
{"func_before":"\tif (a->getType() == IAction::Move) {\n\t\tIMoveAction *ma = (IMoveAction*)a;\n\n\t\tma->from_inv.applyCurrentPlayer(player->getName());\n\t\tma->to_inv.applyCurrentPlayer(player->getName());\n\n\t\tm_inventory_mgr->setInventoryModified(ma->from_inv);\n\t\tif (ma->from_inv != ma->to_inv)\n\t\t\tm_inventory_mgr->setInventoryModified(ma->to_inv);\n\n\t\tbool from_inv_is_current_player = false;\n\t\tif (ma->from_inv.type == InventoryLocation::PLAYER) {\n\t\t\tif (ma->from_inv.name != player->getName())\n\t\t\t\treturn;\n\t\t\tfrom_inv_is_current_player = true;\n\t\t}\n\t\t\n\t\tbool to_inv_is_current_player = false;\n\t\tif (ma->to_inv.type == InventoryLocation::PLAYER) {\n\t\t\tif (ma->to_inv.name != player->getName())\n\t\t\t\treturn;\n\t\t\tto_inv_is_current_player = true;\n\t\t}\n\n\t\tInventoryLocation *remote = from_inv_is_current_player ?\n\t\t\t&ma->to_inv : &ma->from_inv;\n\n\t\t\/\/ Check for out-of-range interaction\n\t\tif (remote->type == InventoryLocation::NODEMETA) {\n\t\t\tv3f node_pos   = intToFloat(remote->p, BS);\n\t\t\tv3f player_pos = player->getPlayerSAO()->getEyePosition();\n\t\t\tf32 d = player_pos.getDistanceFrom(node_pos);\n\t\t\tif (!checkInteractDistance(player, d, \"inventory\"))","target":0,"flaw_line_index":0,"hash":"425080d0-bb7b-4175-88f3-7a0557bff214","idx":"51dc8449-6c13-4dd0-92e9-1d1930f17ce7"}
{"func_before":"  idata->cmddata = NULL;\n  \/* noselect is for a gmail quirk (#3445) *\/\n  if (!list.name || list.noselect)\n    return;\n\n  mutt_debug(3, \"Subscribing to %s\\n\", list.name);\n\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  \/* escape \\ and \" *\/\n  imap_quote_string(errstr, sizeof(errstr), list.name);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \"\\\"\");\n  mutt_buffer_init(&token);\n  mutt_buffer_init(&err);\n  err.data = errstr;\n  err.dsize = sizeof(errstr);","target":1,"flaw_line_index":0,"hash":"0fe0888b-e6bf-4e57-b998-6c72084c99a1","idx":"c365ccf5-073d-4de3-83bf-e760e464957f"}
{"func_before":"  idata->cmddata = NULL;\n  \/* noselect is for a gmail quirk (#3445) *\/\n  if (!list.name || list.noselect)\n    return;\n\n  mutt_debug(3, \"Subscribing to %s\\n\", list.name);\n\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  \/* escape \\ and \" *\/\n  imap_quote_string(errstr, sizeof(errstr), list.name, true);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \"\\\"\");\n  mutt_buffer_init(&token);\n  mutt_buffer_init(&err);\n  err.data = errstr;\n  err.dsize = sizeof(errstr);","target":0,"flaw_line_index":0,"hash":"236ccc34-62ca-4e3c-9ae7-05c7b2daf650","idx":"e85332ab-1402-49c9-9af8-9fb8a3c94e0a"}
{"func_before":"construct_command_line(struct manager_ctx *manager, struct server *server)\n{\n    static char cmd[BUF_SIZE];\n    char *method = manager->method;\n    int i;\n\n    build_config(working_dir, server);\n\n    if (server->method) method = server->method;\n    memset(cmd, 0, BUF_SIZE);\n    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s\/.shadowsocks_%s.pid -c %s\/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n\n    if (manager->acl != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n    }\n    if (manager->timeout != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n    }\n#ifdef HAVE_SETRLIMIT","target":1,"flaw_line_index":0,"hash":"e817fa2a-c2c4-4608-b1c7-37ea921db0de","idx":"a6545297-ccc2-478c-b6e3-adb6a4174044"}
{"func_before":"construct_command_line(struct manager_ctx *manager, struct server *server)\n{\n    static char cmd[BUF_SIZE];\n    int i;\n    int port;\n\n    port = atoi(server->port);\n\n    build_config(working_dir, manager, server);\n\n    memset(cmd, 0, BUF_SIZE);\n    snprintf(cmd, BUF_SIZE,\n             \"%s --manager-address %s -f %s\/.shadowsocks_%d.pid -c %s\/.shadowsocks_%d.conf\",\n             executable, manager->manager_address, working_dir, port, working_dir, port);\n\n    if (manager->acl != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n    }\n    if (manager->timeout != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n    }\n#ifdef HAVE_SETRLIMIT","target":0,"flaw_line_index":0,"hash":"5293d2c4-87b2-40ba-8f9d-c39324aa547d","idx":"cfe936aa-196b-465d-9952-d712063f190a"}
{"func_before":"         \/\/Compute CRC over the current MAC address\n         crc = ksz8851CalcCrc(&entry->addr, sizeof(MacAddr));\n         \/\/Calculate the corresponding index in the table\n         k = (crc >> 26) & 0x3F;\n         \/\/Update hash table contents\n         hashTable[k \/ 16] |= (1 << (k % 16));\n      }\n   }\n\n   \/\/Write the hash table to the KSZ8851 controller\n   ksz8851WriteReg(interface, KSZ8851_REG_MAHTR0, hashTable[0]);\n   ksz8851WriteReg(interface, KSZ8851_REG_MAHTR1, hashTable[1]);\n   ksz8851WriteReg(interface, KSZ8851_REG_MAHTR2, hashTable[2]);\n   ksz8851WriteReg(interface, KSZ8851_REG_MAHTR3, hashTable[3]);\n\n   \/\/Debug message\n   TRACE_DEBUG(\"  MAHTR0 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_REG_MAHTR0));\n   TRACE_DEBUG(\"  MAHTR1 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_REG_MAHTR1));\n   TRACE_DEBUG(\"  MAHTR2 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_REG_MAHTR2));\n   TRACE_DEBUG(\"  MAHTR3 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_REG_MAHTR3));\n\n   \/\/Successful processing\n   return NO_ERROR;\n}","target":1,"flaw_line_index":0,"hash":"28468123-b340-4b25-9b64-7804a3b86e0f","idx":"52b4442b-b6e6-4d9b-aece-2e745a8f395f"}
{"func_before":"         \/\/Compute CRC over the current MAC address\n         crc = ksz8851CalcCrc(&entry->addr, sizeof(MacAddr));\n         \/\/Calculate the corresponding index in the table\n         k = (crc >> 26) & 0x3F;\n         \/\/Update hash table contents\n         hashTable[k \/ 16] |= (1 << (k % 16));\n      }\n   }\n\n   \/\/Write the hash table to the KSZ8851 controller\n   ksz8851WriteReg(interface, KSZ8851_MAHTR0, hashTable[0]);\n   ksz8851WriteReg(interface, KSZ8851_MAHTR1, hashTable[1]);\n   ksz8851WriteReg(interface, KSZ8851_MAHTR2, hashTable[2]);\n   ksz8851WriteReg(interface, KSZ8851_MAHTR3, hashTable[3]);\n\n   \/\/Debug message\n   TRACE_DEBUG(\"  MAHTR0 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_MAHTR0));\n   TRACE_DEBUG(\"  MAHTR1 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_MAHTR1));\n   TRACE_DEBUG(\"  MAHTR2 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_MAHTR2));\n   TRACE_DEBUG(\"  MAHTR3 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_MAHTR3));\n\n   \/\/Successful processing\n   return NO_ERROR;\n}","target":0,"flaw_line_index":0,"hash":"aec65ccf-2f9e-482e-8e82-2288e7655c6e","idx":"06ffdf32-210a-4ad8-9224-4fa4b6061c23"}
{"func_before":"static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n\n\tif (is_guest_mode(vcpu))\n\t\tmsr_bitmap = vmx_msr_bitmap_nested;\n\telse if (vcpu->arch.apic_base & X2APIC_ENABLE) {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}","target":1,"flaw_line_index":0,"hash":"d13490a4-ab1c-483b-8240-0fde256edbff","idx":"0dc7421d-8ea1-4e95-883b-6246a6f8aaf0"}
{"func_before":"static void vmx_set_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tunsigned long *msr_bitmap;\n\n\tif (is_guest_mode(vcpu))\n\t\tmsr_bitmap = vmx_msr_bitmap_nested;\n\telse if (cpu_has_secondary_exec_ctrls() &&\n\t\t (vmcs_read32(SECONDARY_VM_EXEC_CONTROL) &\n\t\t  SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE)) {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy;\n\t}","target":0,"flaw_line_index":0,"hash":"6f990132-dcf3-4894-9133-18596f09c9d6","idx":"73bdbf57-21fd-4751-97ff-121ea636c990"}
{"func_before":"checked_xmalloc (size_t size)\n{\n    alloc_limit_assert (\"checked_xmalloc\", size);\n    return xmalloc (size);\n}","target":1,"flaw_line_index":0,"hash":"e3850221-966a-47da-98e9-2ff46817bdc6","idx":"69228f8d-ed9f-413e-b90d-4c2229f9b9dc"}
{"func_before":"checked_xmalloc (size_t num, size_t size)\n{\n    size_t res;\n    if (check_mul_overflow(num, size, &res))\n        abort();\n\n    alloc_limit_assert (\"checked_xmalloc\", res);\n    return xmalloc (num, size);\n}","target":0,"flaw_line_index":0,"hash":"8aebbc7f-0fa6-40d0-966d-38d7c1251978","idx":"75043174-424c-45cc-83bb-c2d825661343"}
{"func_before":"static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t value;\n\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, &value, 1, 1000);\n\treturn ret >= 0 ? value : ret;\n}","target":1,"flaw_line_index":0,"hash":"0a27871a-bd8f-4591-ab63-3befe3726f41","idx":"9201804c-e238-48cf-b19b-e57aaee6c208"}
{"func_before":"static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t *buffer;\n\tuint8_t value;\n\n\tbuffer = kmalloc(1, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, buffer, 1, 1000);\n\n\tif (ret >= 0) {\n\t\tvalue = buffer[0];\n\t\tkfree(buffer);\n\t\treturn value;\n\t} else {\n\t\tkfree(buffer);\n\t\treturn ret;\n\t}\n}","target":0,"flaw_line_index":0,"hash":"a082fa25-9642-4a69-8bc1-5c7c6f6d8906","idx":"ae327dce-e731-4fba-9b1c-c578678a37c1"}
{"func_before":"                                 std::string &boundary) {\n  if (req.ranges.size() > 1) {\n    boundary = detail::make_multipart_data_boundary();\n\n    auto it = res.headers.find(\"Content-Type\");\n    if (it != res.headers.end()) {\n      content_type = it->second;\n      res.headers.erase(it);\n    }\n\n    res.headers.emplace(\"Content-Type\",\n                        \"multipart\/byteranges; boundary=\" + boundary);\n  }\n\n  auto type = detail::encoding_type(req, res);\n\n  if (res.body.empty()) {\n    if (res.content_length_ > 0) {\n      size_t length = 0;\n      if (req.ranges.empty()) {\n        length = res.content_length_;\n      } else if (req.ranges.size() == 1) {","target":1,"flaw_line_index":0,"hash":"9e5c7c70-683f-4e4c-af36-d2e024e5838b","idx":"d4c00f81-602c-45a7-a428-64336cae06f3"}
{"func_before":"                                 std::string &boundary) {\n  if (req.ranges.size() > 1) {\n    boundary = detail::make_multipart_data_boundary();\n\n    auto it = res.headers.find(\"Content-Type\");\n    if (it != res.headers.end()) {\n      content_type = it->second;\n      res.headers.erase(it);\n    }\n\n    res.set_header(\"Content-Type\",\n                   \"multipart\/byteranges; boundary=\" + boundary);\n  }\n\n  auto type = detail::encoding_type(req, res);\n\n  if (res.body.empty()) {\n    if (res.content_length_ > 0) {\n      size_t length = 0;\n      if (req.ranges.empty()) {\n        length = res.content_length_;\n      } else if (req.ranges.size() == 1) {","target":0,"flaw_line_index":0,"hash":"86fa541d-744c-4fee-ad4a-c18e2dc4a2eb","idx":"9c708d6b-b910-4993-b84d-fa9b3cfbc07f"}
{"func_before":"    \/\/ and checking return code means an explicit GetLastError() comparison.  Instead\n    \/\/ rely on subsequent WinHttpQueryHeaders() to fail.\n    WinHttpQueryHeaders(\n        requestHandle,\n        WINHTTP_QUERY_RAW_HEADERS_CRLF,\n        WINHTTP_HEADER_NAME_BY_INDEX,\n        WINHTTP_NO_OUTPUT_BUFFER,\n        &responseHeadersTempLength,\n        WINHTTP_NO_HEADER_INDEX);\n\n    if ((responseHeadersTemp = (wchar_t*)malloc((size_t)responseHeadersTempLength + 2)) == NULL)\n    {\n        result = HTTPAPI_ALLOC_FAILED;\n        LogError(\"malloc failed: (result = %\" PRI_MU_ENUM \")\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n    }\n    else if (! WinHttpQueryHeaders(\n            requestHandle,\n            WINHTTP_QUERY_RAW_HEADERS_CRLF,\n            WINHTTP_HEADER_NAME_BY_INDEX,\n            responseHeadersTemp,\n            &responseHeadersTempLength,\n        {\n            size_t tokenTemp_size;\n\n            tokenTemp_size = WideCharToMultiByte(CP_ACP, 0, token, -1, NULL, 0, NULL, NULL);\n            if (tokenTemp_size == 0)\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"WideCharToMultiByte failed\");\n                break;\n            }\n            else if ((tokenTemp = (char*)malloc(sizeof(char) * tokenTemp_size)) == NULL)\n            {\n                result = HTTPAPI_ALLOC_FAILED;\n                LogError(\"malloc failed\");\n                break;\n            }\n            else if (WideCharToMultiByte(CP_ACP, 0, token, -1, tokenTemp, (int)tokenTemp_size, NULL, NULL) == 0)\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"WideCharToMultiByte failed\");\n                break;","target":1,"flaw_line_index":0,"hash":"5f3995b7-8264-447a-8c71-073568379fc1","idx":"4ebdbb59-5aed-416c-903c-ea62d27b0ebe"}
{"func_before":"    \/\/ and checking return code means an explicit GetLastError() comparison.  Instead\n    \/\/ rely on subsequent WinHttpQueryHeaders() to fail.\n    WinHttpQueryHeaders(\n        requestHandle,\n        WINHTTP_QUERY_RAW_HEADERS_CRLF,\n        WINHTTP_HEADER_NAME_BY_INDEX,\n        WINHTTP_NO_OUTPUT_BUFFER,\n        &responseHeadersTempLength,\n        WINHTTP_NO_HEADER_INDEX);\n\n    size_t malloc_size = safe_add_size_t((size_t)responseHeadersTempLength, 2);\n    if (malloc_size == SIZE_MAX)\n    {\n        LogError(\"Invalid malloc size\");\n        responseHeadersTemp = NULL;\n    }\n    else\n    {\n        responseHeadersTemp = (wchar_t*)malloc(malloc_size);\n    }\n\n    if (responseHeadersTemp == NULL)\n    {\n        result = HTTPAPI_ALLOC_FAILED;\n        LogError(\"malloc failed: (result = %\" PRI_MU_ENUM \")\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n    }\n    else if (! WinHttpQueryHeaders(\n            requestHandle,\n            WINHTTP_QUERY_RAW_HEADERS_CRLF,\n            WINHTTP_HEADER_NAME_BY_INDEX,\n            responseHeadersTemp,\n            &responseHeadersTempLength,\n        {\n            size_t tokenTemp_size;\n\n            tokenTemp_size = WideCharToMultiByte(CP_ACP, 0, token, -1, NULL, 0, NULL, NULL);\n            if (tokenTemp_size == 0)\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"WideCharToMultiByte failed\");\n                break;\n            }\n            else if ((malloc_size = safe_multiply_size_t(sizeof(char), tokenTemp_size)) == SIZE_MAX)\n            {\n                result = HTTPAPI_ALLOC_FAILED;\n                LogError(\"invalid malloc size\");\n                break;\n            }\n            else if ((tokenTemp = (char*)malloc(malloc_size)) == NULL)\n            {\n                result = HTTPAPI_ALLOC_FAILED;\n                LogError(\"malloc failed\");\n                break;\n            }\n            else if (WideCharToMultiByte(CP_ACP, 0, token, -1, tokenTemp, (int)tokenTemp_size, NULL, NULL) == 0)\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"WideCharToMultiByte failed\");\n                break;","target":0,"flaw_line_index":0,"hash":"21ff7433-b7e0-4da9-b0f9-6fb4a2b42d8a","idx":"8ad0700e-762a-4973-91b8-45788fb10a94"}
{"func_before":"    } else {\n        direct = 0;\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n\n    for (p = 0; p < 4 && in->data[p]; p++) {\n        int w = inlink->w;\n        int h = inlink->h;\n        int r = s->radius;\n        if (p) {\n            w = s->chroma_w;\n            h = s->chroma_h;\n            r = s->chroma_r;\n        }\n\n        if (FFMIN(w, h) > 2 * r)","target":1,"flaw_line_index":0,"hash":"5992ceec-73a5-4d68-bc2e-a4cab8e4f44b","idx":"5f5a3eb6-2c22-4814-b2f2-37f0e4c4baf5"}
{"func_before":"    } else {\n        direct = 0;\n        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n        if (!out) {\n            av_frame_free(&in);\n            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n\n    for (p = 0; p < 4 && in->data[p] && in->linesize[p]; p++) {\n        int w = inlink->w;\n        int h = inlink->h;\n        int r = s->radius;\n        if (p) {\n            w = s->chroma_w;\n            h = s->chroma_h;\n            r = s->chroma_r;\n        }\n\n        if (FFMIN(w, h) > 2 * r)","target":0,"flaw_line_index":0,"hash":"ecdf08a9-05be-445c-8f26-2e86062fdcc5","idx":"77d9c715-06e5-47fa-a15d-ba64ef274706"}
{"func_before":"    if (ret) {\n        L_ERROR(\"output directory %s not made\\n\", procName, dirout);\n        return 1;\n    }\n\n        \/* Capture the filenames in the input directory *\/\n    if ((safiles = getFilenamesInDirectory(dirin)) == NULL)\n        return ERROR_INT(\"safiles not made\", procName, 1);\n\n        \/* Generate output text file names *\/\n    sprintf(charbuf, \"%s\/%s.html\", dirout, rootname);\n    mainname = stringNew(charbuf);\n    sprintf(charbuf, \"%s\/%s-links.html\", dirout, rootname);\n    linkname = stringNew(charbuf);\n    linknameshort = stringJoin(rootname, \"-links.html\");\n\n        \/* Generate the thumbs and views *\/\n    sathumbs = sarrayCreate(0);\n    saviews = sarrayCreate(0);\n    nfiles = sarrayGetCount(safiles);\n    index = 0;\n    for (i = 0; i < nfiles; i++) {\n        fname = sarrayGetString(safiles, i, L_NOCOPY);\n            fprintf(stderr, \"file %s not a readable image\\n\", fullname);\n            lept_free(fullname);\n            continue;\n        }\n        lept_free(fullname);\n\n            \/* Make and store the thumbnail images *\/\n        pixGetDimensions(pix, &w, NULL, &d);\n        factor = (l_float32)thumbwidth \/ (l_float32)w;\n        pixthumb = pixScale(pix, factor, factor);\n        sprintf(charbuf, \"%s_thumb_%03d\", rootname, index);\n        sarrayAddString(sathumbs, charbuf, L_COPY);\n        outname = genPathname(dirout, charbuf);\n        WriteFormattedPix(outname, pixthumb);\n        lept_free(outname);\n        pixDestroy(&pixthumb);\n\n            \/* Make and store the view images *\/\n        factor = (l_float32)viewwidth \/ (l_float32)w;\n        if (factor >= 1.0)\n            pixview = pixClone(pix);   \/* no upscaling *\/","target":1,"flaw_line_index":0,"hash":"a28be27c-ae33-43aa-bc72-54da6ca8f10a","idx":"e8a6acf9-b008-4030-b51c-b2ab74dd700e"}
{"func_before":"    if (ret) {\n        L_ERROR(\"output directory %s not made\\n\", procName, dirout);\n        return 1;\n    }\n\n        \/* Capture the filenames in the input directory *\/\n    if ((safiles = getFilenamesInDirectory(dirin)) == NULL)\n        return ERROR_INT(\"safiles not made\", procName, 1);\n\n        \/* Generate output text file names *\/\n    snprintf(charbuf, sizeof(charbuf), \"%s\/%s.html\", dirout, rootname);\n    mainname = stringNew(charbuf);\n    snprintf(charbuf, sizeof(charbuf), \"%s\/%s-links.html\", dirout, rootname);\n    linkname = stringNew(charbuf);\n    linknameshort = stringJoin(rootname, \"-links.html\");\n\n        \/* Generate the thumbs and views *\/\n    sathumbs = sarrayCreate(0);\n    saviews = sarrayCreate(0);\n    nfiles = sarrayGetCount(safiles);\n    index = 0;\n    for (i = 0; i < nfiles; i++) {\n        fname = sarrayGetString(safiles, i, L_NOCOPY);\n            fprintf(stderr, \"file %s not a readable image\\n\", fullname);\n            lept_free(fullname);\n            continue;\n        }\n        lept_free(fullname);\n\n            \/* Make and store the thumbnail images *\/\n        pixGetDimensions(pix, &w, NULL, &d);\n        factor = (l_float32)thumbwidth \/ (l_float32)w;\n        pixthumb = pixScale(pix, factor, factor);\n        snprintf(charbuf, sizeof(charbuf), \"%s_thumb_%03d\", rootname, index);\n        sarrayAddString(sathumbs, charbuf, L_COPY);\n        outname = genPathname(dirout, charbuf);\n        WriteFormattedPix(outname, pixthumb);\n        lept_free(outname);\n        pixDestroy(&pixthumb);\n\n            \/* Make and store the view images *\/\n        factor = (l_float32)viewwidth \/ (l_float32)w;\n        if (factor >= 1.0)\n            pixview = pixClone(pix);   \/* no upscaling *\/","target":0,"flaw_line_index":0,"hash":"212eabe0-0428-4b95-ba84-3dfeda8c804a","idx":"24e14618-bcd4-41ab-92d7-870c771cbc2f"}
{"func_before":"AllocateCudnnConvolutionBackwardDataWorkspace(\n    Stream* stream, const CudnnHandle& cudnn,\n    const CudnnTensorDescriptor& input_nd, const CudnnFilterDescriptor& filter,\n    const CudnnConvolutionDescriptor& conv,\n    const CudnnTensorDescriptor& output_nd,\n    const dnn::AlgorithmDesc& algorithm_desc,\n    ScratchAllocator* scratch_allocator) {\n  if (IsTensorMathOpSet(conv) != algorithm_desc.tensor_ops_enabled()) {\n    return tsl::Status(\n        port::error::INTERNAL,\n        \"Mismatch between cudnn conv and algorithm descriptors.\");\n  }\n\n  \/\/ Query the size of the workspace and allocate it.\n  size_t size_in_bytes;\n  if (algorithm_desc.workspace_size()) {\n    size_in_bytes = *algorithm_desc.workspace_size();\n  } else {\n    RETURN_IF_CUDNN_ERROR(cudnnGetConvolutionBackwardDataWorkspaceSize(\n        cudnn.handle(),\n        \/*convDesc=*\/conv.handle(),\n        \/*dxDesc=*\/input_nd.handle(),\n        \/*algo=*\/ToConvBackwardDataAlgo(algorithm_desc),\n        \/*sizeInBytes=*\/&size_in_bytes));\n  }\n\n  int64_t size_in_bytes_int64_t = size_in_bytes;\n\n  if (ABSL_PREDICT_FALSE(size_in_bytes_int64_t < 0)) {\n    return tsl::Status(\n        port::error::INTERNAL,\n        \"cudnnGetConvolutionBackwardDataWorkspaceSize() returned \"\n        \"negative sizeInBytes value. This could be a cudnn bug.\");\n  }\n\n  if (size_in_bytes_int64_t == 0) {\n    return DeviceMemory<uint8_t>();\n  }\n\n  if (ABSL_PREDICT_FALSE(!scratch_allocator)) {\n    return tsl::Status(port::error::INVALID_ARGUMENT,\n                       \"No scratch allocator provided\");\n  }\n\n  return scratch_allocator->AllocateBytes(size_in_bytes);\n}","target":1,"flaw_line_index":0,"hash":"9afd2197-00e7-4def-a819-4bb31fa1b13f","idx":"102d4d92-628a-4cc5-90ff-f8dec92e4aec"}
{"func_before":"AllocateCudnnConvolutionBackwardDataWorkspace(\n    Stream* stream, const CudnnHandle& cudnn,\n    const CudnnTensorDescriptor& input_nd, const CudnnFilterDescriptor& filter,\n    const CudnnConvolutionDescriptor& conv,\n    const CudnnTensorDescriptor& output_nd,\n    const dnn::AlgorithmDesc& algorithm_desc,\n    ScratchAllocator* scratch_allocator) {\n  if (IsTensorMathOpSet(conv) != algorithm_desc.tensor_ops_enabled()) {\n    return tsl::Status(\n        tsl::error::INTERNAL,\n        \"Mismatch between cudnn conv and algorithm descriptors.\");\n  }\n\n  \/\/ Query the size of the workspace and allocate it.\n  size_t size_in_bytes;\n  if (algorithm_desc.workspace_size()) {\n    size_in_bytes = *algorithm_desc.workspace_size();\n  } else {\n    RETURN_IF_CUDNN_ERROR(cudnnGetConvolutionBackwardDataWorkspaceSize(\n        cudnn.handle(),\n        \/*convDesc=*\/conv.handle(),\n        \/*dxDesc=*\/input_nd.handle(),\n        \/*algo=*\/ToConvBackwardDataAlgo(algorithm_desc),\n        \/*sizeInBytes=*\/&size_in_bytes));\n  }\n\n  int64_t size_in_bytes_int64_t = size_in_bytes;\n\n  if (ABSL_PREDICT_FALSE(size_in_bytes_int64_t < 0)) {\n    return tsl::Status(\n        tsl::error::INTERNAL,\n        \"cudnnGetConvolutionBackwardDataWorkspaceSize() returned \"\n        \"negative sizeInBytes value. This could be a cudnn bug.\");\n  }\n\n  if (size_in_bytes_int64_t == 0) {\n    return DeviceMemory<uint8_t>();\n  }\n\n  if (ABSL_PREDICT_FALSE(!scratch_allocator)) {\n    return tsl::Status(tsl::error::INVALID_ARGUMENT,\n                       \"No scratch allocator provided\");\n  }\n\n  return scratch_allocator->AllocateBytes(size_in_bytes);\n}","target":0,"flaw_line_index":0,"hash":"c042b163-f251-4fb4-acb6-36eb5eb00005","idx":"558d4137-cf17-4ef5-be37-c6af2b72d934"}
{"func_before":"rs_filter_graph(RSFilter *filter)\n{\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\tGString *str = g_string_new(\"digraph G {\\n\");\n\n\trs_filter_graph_helper(str, filter);\n\n\tg_string_append_printf(str, \"}\\n\");\n\tg_file_set_contents(\"\/tmp\/rs-filter-graph\", str->str, str->len, NULL);\n\n\tif (0 != system(\"dot -Tpng >\/tmp\/rs-filter-graph.png <\/tmp\/rs-filter-graph\"))\n\t\tg_warning(\"Calling dot failed\");\n\tif (0 != system(\"gnome-open \/tmp\/rs-filter-graph.png\"))\n\t\tg_warning(\"Calling gnome-open failed.\");\n\n\tg_string_free(str, TRUE);\n}","target":1,"flaw_line_index":0,"hash":"c86c2244-8096-4d44-a7b3-f5dec8a0055d","idx":"c9f64be8-85b6-4c28-ab6a-abb36a83fca2"}
{"func_before":"rs_filter_graph(RSFilter *filter)\n{\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\tgchar *dot_filename;\n\tgchar *png_filename;\n\tgchar *command_line;\n\tGString *str = g_string_new(\"digraph G {\\n\");\n\n\trs_filter_graph_helper(str, filter);\n\n\tg_string_append_printf(str, \"}\\n\");\n\n\t\/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible *\/\n\tdot_filename = g_strdup_printf(\"\/tmp\/rs-filter-graph.%u\", g_random_int());\n\tpng_filename = g_strdup_printf(\"%s.%u.png\", dot_filename, g_random_int());\n\n\tg_file_set_contents(dot_filename, str->str, str->len, NULL);\n\n\tcommand_line = g_strdup_printf(\"dot -Tpng >%s <%s\", png_filename, dot_filename);\n\tif (0 != system(command_line))\n\t\tg_warning(\"Calling dot failed\");\n\tg_free(command_line);\n\n\tcommand_line = g_strdup_printf(\"gnome-open %s\", png_filename);\n\tif (0 != system(command_line))\n\t\tg_warning(\"Calling gnome-open failed.\");\n\tg_free(command_line);\n\n\tg_free(dot_filename);\n\tg_free(png_filename);\n\tg_string_free(str, TRUE);\n}","target":0,"flaw_line_index":0,"hash":"fdcc07ba-5b9a-4786-ad70-3cdb687c69a3","idx":"63bf14b2-a85d-4ff5-a976-2728c1084462"}
{"func_before":"void HeaderMapImpl::insertByKey(HeaderString&& key, HeaderString&& value) {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.getStringView());\n  if (cb) {\n    key.clear();\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    if (*ref_lookup_response.entry_ == nullptr) {\n      maybeCreateInline(ref_lookup_response.entry_, *ref_lookup_response.key_, std::move(value));\n    } else {\n      appendToHeader((*ref_lookup_response.entry_)->value(), value.getStringView());\n      value.clear();\n    }\n  } else {\n    std::list<HeaderEntryImpl>::iterator i = headers_.insert(std::move(key), std::move(value));\n    i->entry_ = i;\n  }\n}","target":1,"flaw_line_index":0,"hash":"f16df127-a66c-4a32-9c09-6d96bab50095","idx":"d4fc0b44-f183-4c8c-8ac4-bde38ec139ce"}
{"func_before":"void HeaderMapImpl::insertByKey(HeaderString&& key, HeaderString&& value) {\n  EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.getStringView());\n  if (cb) {\n    key.clear();\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    if (*ref_lookup_response.entry_ == nullptr) {\n      maybeCreateInline(ref_lookup_response.entry_, *ref_lookup_response.key_, std::move(value));\n    } else {\n      const uint64_t added_size =\n          appendToHeader((*ref_lookup_response.entry_)->value(), value.getStringView());\n      addSize(added_size);\n      value.clear();\n    }\n  } else {\n    addSize(key.size() + value.size());\n    std::list<HeaderEntryImpl>::iterator i = headers_.insert(std::move(key), std::move(value));\n    i->entry_ = i;\n  }\n}","target":0,"flaw_line_index":0,"hash":"099b93cf-2b73-4baf-9059-7d8a0e0de664","idx":"26756d28-1031-4eeb-bc95-cfac02c6583b"}
{"func_before":"  STI = &Fn.getSubtarget<ARMSubtarget>();\n  TL = STI->getTargetLowering();\n  AFI = Fn.getInfo<ARMFunctionInfo>();\n  TII = STI->getInstrInfo();\n  TRI = STI->getRegisterInfo();\n\n  RegClassInfoValid = false;\n  isThumb2 = AFI->isThumb2Function();\n  isThumb1 = AFI->isThumbFunction() && !isThumb2;\n\n  bool Modified = false;\n  for (MachineBasicBlock &MBB : Fn) {\n    Modified |= LoadStoreMultipleOpti(MBB);\n    if (STI->hasV5TOps() && !AFI->shouldSignReturnAddress())\n      Modified |= MergeReturnIntoLDM(MBB);\n    if (isThumb1)\n      Modified |= CombineMovBx(MBB);\n  }\n\n  Allocator.DestroyAll();\n  return Modified;\n}","target":1,"flaw_line_index":0,"hash":"8aea922c-e8fa-456b-be86-f273abb66d1f","idx":"59a16452-5bec-45f9-8626-57f7534a16d4"}
{"func_before":"  STI = &Fn.getSubtarget<ARMSubtarget>();\n  TL = STI->getTargetLowering();\n  AFI = Fn.getInfo<ARMFunctionInfo>();\n  TII = STI->getInstrInfo();\n  TRI = STI->getRegisterInfo();\n\n  RegClassInfoValid = false;\n  isThumb2 = AFI->isThumb2Function();\n  isThumb1 = AFI->isThumbFunction() && !isThumb2;\n\n  bool Modified = false, ModifiedLDMReturn = false;\n  for (MachineBasicBlock &MBB : Fn) {\n    Modified |= LoadStoreMultipleOpti(MBB);\n    if (STI->hasV5TOps() && !AFI->shouldSignReturnAddress())\n      ModifiedLDMReturn |= MergeReturnIntoLDM(MBB);\n    if (isThumb1)\n      Modified |= CombineMovBx(MBB);\n  }\n  Modified |= ModifiedLDMReturn;\n\n  \/\/ If we merged a BX instruction into an LDM, we need to re-calculate whether\n  \/\/ LR is restored. This check needs to consider the whole function, not just\n  \/\/ the instruction(s) we changed, because there may be other BX returns which\n  \/\/ still need LR to be restored.\n  if (ModifiedLDMReturn)\n    ARMFrameLowering::updateLRRestored(Fn);\n\n  Allocator.DestroyAll();\n  return Modified;\n}","target":0,"flaw_line_index":0,"hash":"9dfcb104-7183-464b-8f8a-a5dfbd43c1b9","idx":"1df9686c-9cfc-4635-80a3-2cb3cce6ea4e"}
{"func_before":"static void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )\":mongo:\", 7 );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, strlen( pass ) );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n}","target":1,"flaw_line_index":0,"hash":"ddcc8249-d6c0-4d04-a3a6-2af4b0c02bfa","idx":"73b1b5c6-9c88-46a3-8a3f-184998d45f2e"}
{"func_before":"static void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, ( int )strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )\":mongo:\", 7 );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, ( int )strlen( pass ) );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n}","target":0,"flaw_line_index":0,"hash":"4943ff09-73c0-4a8d-adfd-d00cc1eb5e84","idx":"a8200a99-00a1-4c0c-83e4-3c9bbb7f9039"}
{"func_before":"  void *uidl;\n  char buf[LONG_STRING];\n  char path[_POSIX_PATH_MAX];\n  progress_t progressbar;\n  POP_DATA *pop_data = (POP_DATA *)ctx->data;\n  POP_CACHE *cache;\n  HEADER *h = ctx->hdrs[msgno];\n  unsigned short bcache = 1;\n\n  \/* see if we already have the message in body cache *\/\n  if ((msg->fp = mutt_bcache_get (pop_data->bcache, h->data)))\n    return 0;\n\n  \/*\n   * see if we already have the message in our cache in\n   * case $message_cachedir is unset\n   *\/\n  cache = &pop_data->cache[h->index % POP_CACHE_LEN];\n\n  if (cache->path)\n  {\n    {\n      mutt_error _(\"The message index is incorrect. Try reopening the mailbox.\");\n      mutt_sleep (2);\n      return -1;\n    }\n\n    mutt_progress_init (&progressbar, _(\"Fetching message...\"),\n\t\t\tMUTT_PROGRESS_SIZE, NetInc, h->content->length + h->content->offset - 1);\n\n    \/* see if we can put in body cache; use our cache as fallback *\/\n    if (!(msg->fp = mutt_bcache_put (pop_data->bcache, h->data, 1)))\n    {\n      \/* no *\/\n      bcache = 0;\n      mutt_mktemp (path, sizeof (path));\n      if (!(msg->fp = safe_fopen (path, \"w+\")))\n      {\n\tmutt_perror (path);\n\tmutt_sleep (2);\n\treturn -1;\n      }\n      mutt_error _(\"Can't write message to temporary file!\");\n      mutt_sleep (2);\n      return -1;\n    }\n  }\n\n  \/* Update the header information.  Previously, we only downloaded a\n   * portion of the headers, those required for the main display.\n   *\/\n  if (bcache)\n    mutt_bcache_commit (pop_data->bcache, h->data);\n  else\n  {\n    cache->index = h->index;\n    cache->path = safe_strdup (path);\n  }\n  rewind (msg->fp);\n  uidl = h->data;\n\n  \/* we replace envelop, key in subj_hash has to be updated as well *\/\n  if (ctx->subj_hash && h->env->real_subj)","target":1,"flaw_line_index":0,"hash":"4c0796b9-958c-4cd2-9532-ba982003807f","idx":"5e5d5e5c-a729-4e13-bf16-c62729bb4dd4"}
{"func_before":"  void *uidl;\n  char buf[LONG_STRING];\n  char path[_POSIX_PATH_MAX];\n  progress_t progressbar;\n  POP_DATA *pop_data = (POP_DATA *)ctx->data;\n  POP_CACHE *cache;\n  HEADER *h = ctx->hdrs[msgno];\n  unsigned short bcache = 1;\n\n  \/* see if we already have the message in body cache *\/\n  if ((msg->fp = mutt_bcache_get (pop_data->bcache, cache_id (h->data))))\n    return 0;\n\n  \/*\n   * see if we already have the message in our cache in\n   * case $message_cachedir is unset\n   *\/\n  cache = &pop_data->cache[h->index % POP_CACHE_LEN];\n\n  if (cache->path)\n  {\n    {\n      mutt_error _(\"The message index is incorrect. Try reopening the mailbox.\");\n      mutt_sleep (2);\n      return -1;\n    }\n\n    mutt_progress_init (&progressbar, _(\"Fetching message...\"),\n\t\t\tMUTT_PROGRESS_SIZE, NetInc, h->content->length + h->content->offset - 1);\n\n    \/* see if we can put in body cache; use our cache as fallback *\/\n    if (!(msg->fp = mutt_bcache_put (pop_data->bcache, cache_id (h->data), 1)))\n    {\n      \/* no *\/\n      bcache = 0;\n      mutt_mktemp (path, sizeof (path));\n      if (!(msg->fp = safe_fopen (path, \"w+\")))\n      {\n\tmutt_perror (path);\n\tmutt_sleep (2);\n\treturn -1;\n      }\n      mutt_error _(\"Can't write message to temporary file!\");\n      mutt_sleep (2);\n      return -1;\n    }\n  }\n\n  \/* Update the header information.  Previously, we only downloaded a\n   * portion of the headers, those required for the main display.\n   *\/\n  if (bcache)\n    mutt_bcache_commit (pop_data->bcache, cache_id (h->data));\n  else\n  {\n    cache->index = h->index;\n    cache->path = safe_strdup (path);\n  }\n  rewind (msg->fp);\n  uidl = h->data;\n\n  \/* we replace envelop, key in subj_hash has to be updated as well *\/\n  if (ctx->subj_hash && h->env->real_subj)","target":0,"flaw_line_index":0,"hash":"a77a99c9-18ef-4c5c-a317-e12a626e9346","idx":"115b7c94-90a7-4bc5-a7cf-fc1fd452021a"}
{"func_before":"inline typename V::VariantType FBUnserializer<V>::unserializeThing() {\n  size_t code = nextCode();\n\n  switch (code) {\n    case FB_SERIALIZE_BYTE:\n    case FB_SERIALIZE_I16:\n    case FB_SERIALIZE_I32:\n    case FB_SERIALIZE_I64:\n      return V::fromInt64(unserializeInt64());\n    case FB_SERIALIZE_VARCHAR:\n    case FB_SERIALIZE_STRING:\n      return V::fromString(unserializeString());\n    case FB_SERIALIZE_STRUCT:\n      return V::fromMap(unserializeMap());\n    case FB_SERIALIZE_NULL:\n      ++p_;\n      return V::createNull();\n    case FB_SERIALIZE_DOUBLE:\n      return V::fromDouble(unserializeDouble());\n    case FB_SERIALIZE_BOOLEAN:\n      return V::fromBool(unserializeBoolean());\n    case FB_SERIALIZE_VECTOR:\n      return V::fromVector(unserializeVector());\n    case FB_SERIALIZE_LIST:\n      return V::fromVector(unserializeList());\n    case FB_SERIALIZE_SET:\n      return V::fromSet(unserializeSet());\n    default:\n      throw UnserializeError(\"Invalid code: \" + folly::to<std::string>(code)\n                             + \" at location \" + folly::to<std::string>(p_));\n  }\n}","target":1,"flaw_line_index":0,"hash":"ebd554a6-4076-4e1e-a9fd-9634c0228bd5","idx":"d0589f4c-7341-4d52-8cbe-276fd979c632"}
{"func_before":"FBUnserializer<V>::unserializeThing(size_t depth) {\n  if (UNLIKELY(depth > 1024)) {\n    throw UnserializeError(\"depth > 1024\");\n  }\n\n  size_t code = nextCode();\n\n  switch (code) {\n    case FB_SERIALIZE_BYTE:\n    case FB_SERIALIZE_I16:\n    case FB_SERIALIZE_I32:\n    case FB_SERIALIZE_I64:\n      return V::fromInt64(unserializeInt64());\n    case FB_SERIALIZE_VARCHAR:\n    case FB_SERIALIZE_STRING:\n      return V::fromString(unserializeString());\n    case FB_SERIALIZE_STRUCT:\n      return V::fromMap(unserializeMap(depth));\n    case FB_SERIALIZE_NULL:\n      ++p_;\n      return V::createNull();\n    case FB_SERIALIZE_DOUBLE:\n      return V::fromDouble(unserializeDouble());\n    case FB_SERIALIZE_BOOLEAN:\n      return V::fromBool(unserializeBoolean());\n    case FB_SERIALIZE_VECTOR:\n      return V::fromVector(unserializeVector(depth));\n    case FB_SERIALIZE_LIST:\n      return V::fromVector(unserializeList(depth));\n    case FB_SERIALIZE_SET:\n      return V::fromSet(unserializeSet(depth));\n    default:\n      throw UnserializeError(\"Invalid code: \" + folly::to<std::string>(code)\n                             + \" at location \" + folly::to<std::string>(p_));\n  }\n}","target":0,"flaw_line_index":0,"hash":"d4aed766-0058-4567-8154-fa203a31ef46","idx":"8ec7ccb6-8e52-4744-9cfd-0d49212ab4b4"}
{"func_before":"void svhandler_flash_erase_sector(void) {\n  uint32_t sector = _param_1;\n\n  \/\/ Do not allow firmware to erase bootstrap or bootloader sectors.\n  if ((sector == FLASH_BOOTSTRAP_SECTOR) ||\n      (sector >= FLASH_BOOT_SECTOR_FIRST && sector <= FLASH_BOOT_SECTOR_LAST)) {\n    return;\n  }\n\n  \/\/ Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n\n  \/\/ Erase the sector.\n  flash_erase_sector(sector, FLASH_CR_PROGRAM_X32);\n\n  \/\/ Return flash status.\n  _param_1 = !!flash_chk_status();","target":1,"flaw_line_index":0,"hash":"11d57a4a-9313-4735-bd51-f37930b9a2ea","idx":"ee355c3b-ec03-4527-89ba-2dcd5d9f32fa"}
{"func_before":"void svhandler_flash_erase_sector(void) {\n  uint8_t sector = _param_1;\n\n  \/\/ Verify requested sector is allowed.\n  if (!allow_svhandler_flash_sector_num(sector)) return;\n\n  \/\/ Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n\n  \/\/ Erase the sector.\n  flash_erase_sector(sector, FLASH_CR_PROGRAM_X32);\n\n  \/\/ Return flash status.\n  _param_1 = !!flash_chk_status();","target":0,"flaw_line_index":0,"hash":"8df2f5ab-efa2-4413-8fcb-86e6ffb44fb8","idx":"9c7223c2-19aa-4abb-870f-f43a88aa8b0b"}
{"func_before":"static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\n\tif (submodule_url_is_relative(url)) {\n\t\t\/*\n\t\t * This could be appended to an http URL and url-decoded;\n\t\t * check for malicious characters.\n\t\t *\/\n\t\tchar *decoded = url_decode(url);\n\t\tint has_nl = !!strchr(decoded, '\\n');\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\t}\n\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n","target":1,"flaw_line_index":0,"hash":"a12ff191-58f3-45a6-965c-7349ac7fc7c2","idx":"7aefc5c7-46fc-43a0-88b4-e261aa4a809b"}
{"func_before":"static int check_submodule_url(const char *url)\n{\n\tconst char *curl_url;\n\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\n\tif (submodule_url_is_relative(url)) {\n\t\tchar *decoded;\n\t\tconst char *next;\n\t\tint has_nl;\n\n\t\t\/*\n\t\t * This could be appended to an http URL and url-decoded;\n\t\t * check for malicious characters.\n\t\t *\/\n\t\tdecoded = url_decode(url);\n\t\thas_nl = !!strchr(decoded, '\\n');\n\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\n\t\t\/*\n\t\t * URLs which escape their root via \"..\/\" can overwrite\n\t\t * the host field and previous components, resolving to\n\t\t * URLs like https::example.com\/submodule.git that were\n\t\t * susceptible to CVE-2020-11008.\n\t\t *\/\n\t\tif (count_leading_dotdots(url, &next) > 0 &&\n\t\t    *next == ':')\n\t\t\treturn -1;\n\t}\n\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;\n\t\tint ret = credential_from_url_gently(&c, curl_url, 1);\n\t\tcredential_clear(&c);\n\t\treturn ret;\n\t}\n","target":0,"flaw_line_index":0,"hash":"9244f96f-eb0d-4bb5-b073-a065d9b38028","idx":"ecc24056-f68e-4471-8895-34155e5c6530"}
{"func_before":"\n  init_graph->AddEdge(init_handle, 0, init_assign, 0);\n  init_graph->AddEdge(init_const, 0, init_assign, 1);\n  FHandle fhandle;\n  const string fname =\n      strings::StrCat(ndef->name(), \"_init_ord_\", device_ordinal);\n\n  TF_RETURN_IF_ERROR(\n      InstantiatePartition(*init_graph, fname, device, &fhandle, nullptr));\n\n  FunctionLibraryRuntime::Options opts;\n  opts.step_container = ctx->step_container();\n  opts.cancellation_manager = ctx->cancellation_manager();\n  opts.stats_collector = ctx->stats_collector();\n\n  \/\/ Blocking on threads in the same thread pool is disallowed because\n  \/\/ concurrent warm-up requests can exhaust the default thread pool.\n  \/\/ Create a new thread pool to initialize variables on TPU.\n  std::function<void(std::function<void()>)> runner =\n      [this](std::function<void()> fn) { pool_.Schedule(fn); };\n  opts.runner = &runner;","target":1,"flaw_line_index":0,"hash":"db66665b-9822-442f-ba81-eb9b97e89ea9","idx":"3af7fecf-3edf-4e0d-ab01-68cba9a12c91"}
{"func_before":"\n  init_graph->AddEdge(init_handle, 0, init_assign, 0);\n  init_graph->AddEdge(init_const, 0, init_assign, 1);\n  FHandle fhandle;\n  const string fname =\n      strings::StrCat(ndef->name(), \"_init_ord_\", device_ordinal);\n\n  TF_RETURN_IF_ERROR(\n      InstantiatePartition(*init_graph, fname, device, &fhandle, nullptr));\n\n  FunctionLibraryRuntime::Options opts(ctx->step_id());\n  opts.step_container = ctx->step_container();\n  opts.cancellation_manager = ctx->cancellation_manager();\n  opts.stats_collector = ctx->stats_collector();\n\n  \/\/ Blocking on threads in the same thread pool is disallowed because\n  \/\/ concurrent warm-up requests can exhaust the default thread pool.\n  \/\/ Create a new thread pool to initialize variables on TPU.\n  std::function<void(std::function<void()>)> runner =\n      [this](std::function<void()> fn) { pool_.Schedule(fn); };\n  opts.runner = &runner;","target":0,"flaw_line_index":0,"hash":"fb4ec5a8-5c50-4fd6-b85d-50b22e36e5c1","idx":"b6ba63fd-7a87-4015-9b09-d15a4313aef3"}
{"func_before":" \/* Safer we flip this to TRUE perl side if we detect a mod_perl env. *\/\n  imp_dbh->auto_reconnect = FALSE;\n\n  \/* HELMUT *\/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;  \/* initialize mysql_enable_utf8 *\/\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    do_error(dbh, mysql_errno(imp_dbh->pmysql),\n            mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n    return FALSE;\n  }\n\n    \/*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     *\/\n    DBIc_ACTIVE_on(imp_dbh);\n\n    \/* Tell DBI, that dbh->destroy should be called for this handle *\/\n    DBIc_on(imp_dbh, DBIcf_IMPSET);","target":1,"flaw_line_index":0,"hash":"63d5f7b9-0b30-4a21-8f0c-450465853cf1","idx":"f607148e-f516-4467-8b8e-c3f0dfe3203c"}
{"func_before":" \/* Safer we flip this to TRUE perl side if we detect a mod_perl env. *\/\n  imp_dbh->auto_reconnect = FALSE;\n\n  \/* HELMUT *\/\n#if defined(sv_utf8_decode) && MYSQL_VERSION_ID >=SERVER_PREPARE_VERSION\n  imp_dbh->enable_utf8 = FALSE;  \/* initialize mysql_enable_utf8 *\/\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    if(imp_dbh->pmysql)\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n    return FALSE;\n  }\n\n    \/*\n     *  Tell DBI, that dbh->disconnect should be called for this handle\n     *\/\n    DBIc_ACTIVE_on(imp_dbh);\n\n    \/* Tell DBI, that dbh->destroy should be called for this handle *\/\n    DBIc_on(imp_dbh, DBIcf_IMPSET);","target":0,"flaw_line_index":0,"hash":"563ce24b-7b50-4f22-b39e-8ecb03eb53c4","idx":"a44aa011-ed49-429b-a353-2277411baa19"}
{"func_before":"    {\n\n        if (buffer == NULL)\n        {\n            http_instance->is_io_error = 1;\n            LogError(\"NULL pointer error\");\n        }\n        else\n        {\n            \/* Here we got some bytes so we'll buffer them so the receive functions can consumer it *\/\n            new_received_bytes = (unsigned char*)realloc(http_instance->received_bytes, http_instance->received_bytes_count + size);\n            if (new_received_bytes == NULL)\n            {\n                http_instance->is_io_error = 1;\n                LogError(\"Error allocating memory for received data\");\n            }\n            else\n            {\n                http_instance->received_bytes = new_received_bytes;\n                if (memcpy(http_instance->received_bytes + http_instance->received_bytes_count, buffer, size) == NULL)\n                {","target":1,"flaw_line_index":0,"hash":"547a994e-2f9a-440e-9d84-eca10ffdf099","idx":"3b544d69-f17c-4c3c-b9d5-037b9a8b8ae7"}
{"func_before":"    {\n\n        if (buffer == NULL)\n        {\n            http_instance->is_io_error = 1;\n            LogError(\"NULL pointer error\");\n        }\n        else\n        {\n            \/* Here we got some bytes so we'll buffer them so the receive functions can consumer it *\/\n            size_t malloc_size = http_instance->received_bytes_count + size;\n            if (malloc_size < size)\n            {\n                \/\/ check for int overflow\n                new_received_bytes = NULL;\n                LogError(\"Invalid size parameter\");\n            }\n            else\n            {\n                new_received_bytes = (unsigned char*)realloc(http_instance->received_bytes, malloc_size);\n            }\n\n            if (new_received_bytes == NULL)\n            {\n                http_instance->is_io_error = 1;\n                LogError(\"Error allocating memory for received data\");\n            }\n            else\n            {\n                http_instance->received_bytes = new_received_bytes;\n                if (memcpy(http_instance->received_bytes + http_instance->received_bytes_count, buffer, size) == NULL)\n                {","target":0,"flaw_line_index":0,"hash":"aa49da71-3e68-405a-9ce4-7940b6a29dbe","idx":"ec5c9d5b-45a3-4fd5-9e9d-54761e8c45e5"}
{"func_before":"void MSG_WriteBits( msg_t *msg, int value, int bits ) {\n\tint\ti;\n\n\toldsize += bits;\n\n\t\/\/ this isn't an exact overflow check, but close enough\n\tif ( msg->maxsize - msg->cursize < 4 ) {\n\t\tmsg->overflowed = qtrue;\n\t\treturn;\n\t}\n\n\tif ( bits == 0 || bits < -31 || bits > 32 ) {\n\t\tCom_Error( ERR_DROP, \"MSG_WriteBits: bad bits %i\", bits );\n\t}\n\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t}\n\n\tif ( msg->oob ) {\n\t\tif ( bits == 8 ) {\n\t\t\tmsg->data[msg->cursize] = value;\n\t\t\tmsg->cursize += 1;\n\t\t\tmsg->bit += 8;\n\t\t} else if ( bits == 16 ) {\n\t\t\tshort temp = value;\n\n\t\t\tCopyLittleShort( &msg->data[msg->cursize], &temp );\n\t\t\tmsg->cursize += 2;\n\t\t\tmsg->bit += 16;\n\t\t\tCopyLittleLong( &msg->data[msg->cursize], &value );\n\t\t\tmsg->cursize += 4;\n\t\t\tmsg->bit += 32;\n\t\t} else {\n\t\t\tCom_Error( ERR_DROP, \"can't write %d bits\", bits );\n\t\t}\n\t} else {\n\t\tvalue &= (0xffffffff >> (32 - bits));\n\t\tif ( bits&7 ) {\n\t\t\tint nbits;\n\t\t\tnbits = bits&7;\n\t\t\tfor( i = 0; i < nbits; i++ ) {\n\t\t\t\tHuff_putBit( (value & 1), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 1);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif ( bits ) {\n\t\t\tfor( i = 0; i < bits; i += 8 ) {\n\t\t\t\tHuff_offsetTransmit( &msgHuff.compressor, (value & 0xff), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 8);\n\t\t\t}\n\t\t}\n\t\tmsg->cursize = (msg->bit >> 3) + 1;\n\t}\n}","target":1,"flaw_line_index":0,"hash":"71fdf0f6-fce3-430f-82e3-b065b4a65398","idx":"8c5e7b63-af07-43eb-9534-8494372e1f06"}
{"func_before":"void MSG_WriteBits( msg_t *msg, int value, int bits ) {\n\tint\ti;\n\n\toldsize += bits;\n\n\tif ( msg->overflowed ) {\n\t\treturn;\n\t}\n\n\tif ( bits == 0 || bits < -31 || bits > 32 ) {\n\t\tCom_Error( ERR_DROP, \"MSG_WriteBits: bad bits %i\", bits );\n\t}\n\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t}\n\n\tif ( msg->oob ) {\n\t\tif ( msg->cursize + ( bits >> 3 ) > msg->maxsize ) {\n\t\t\tmsg->overflowed = qtrue;\n\t\t\treturn;\n\t\t}\n\n\t\tif ( bits == 8 ) {\n\t\t\tmsg->data[msg->cursize] = value;\n\t\t\tmsg->cursize += 1;\n\t\t\tmsg->bit += 8;\n\t\t} else if ( bits == 16 ) {\n\t\t\tshort temp = value;\n\n\t\t\tCopyLittleShort( &msg->data[msg->cursize], &temp );\n\t\t\tmsg->cursize += 2;\n\t\t\tmsg->bit += 16;\n\t\t\tmsg->cursize += 4;\n\t\t\tmsg->bit += 32;\n\t\t} else {\n\t\t\tCom_Error( ERR_DROP, \"can't write %d bits\", bits );\n\t\t}\n\t} else {\n\t\tvalue &= (0xffffffff >> (32 - bits));\n\t\tif ( bits&7 ) {\n\t\t\tint nbits;\n\t\t\tnbits = bits&7;\n\t\t\tif ( msg->bit + nbits > msg->maxsize << 3 ) {\n\t\t\t\tmsg->overflowed = qtrue;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor( i = 0; i < nbits; i++ ) {\n\t\t\t\tHuff_putBit( (value & 1), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 1);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif ( bits ) {\n\t\t\tfor( i = 0; i < bits; i += 8 ) {\n\t\t\t\tHuff_offsetTransmit( &msgHuff.compressor, (value & 0xff), msg->data, &msg->bit, msg->maxsize << 3 );\n\t\t\t\tvalue = (value >> 8);\n\n\t\t\t\tif ( msg->bit > msg->maxsize << 3 ) {\n\t\t\t\t\tmsg->overflowed = qtrue;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsg->cursize = (msg->bit >> 3) + 1;\n\t}\n}","target":0,"flaw_line_index":0,"hash":"5bed4882-cb2f-4d56-9088-a83b84481626","idx":"494983c9-749b-413b-ab1c-e15d9aa913f8"}
{"func_before":"    for(j = 0; j < 3; j++) {\n      \/* Reverse the neighboring facets if necessary. *\/\n      if(stl->neighbors_start[facet_num].which_vertex_not[j] > 2) {\n        \/* If the facet has a neighbor that is -1, it means that edge isn't shared by another facet *\/\n        if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n          stl_reverse_facet\n          (stl, stl->neighbors_start[facet_num].neighbor[j]);\n        }\n      }\n      \/* If this edge of the facet is connected: *\/\n      if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n        \/* If we haven't fixed this facet yet, add it to the list: *\/\n        if(norm_sw[stl->neighbors_start[facet_num].neighbor[j]] != 1) {\n          \/* Add node to beginning of list. *\/\n          newn = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n          if(newn == NULL) perror(\"stl_fix_normal_directions\");\n          newn->facet_num = stl->neighbors_start[facet_num].neighbor[j];\n          newn->next = head->next;\n          head->next = newn;\n        }\n      }","target":1,"flaw_line_index":0,"hash":"03369106-3f5c-4b2f-8e4d-b7808ea547f4","idx":"7cd7d510-0b2d-4fea-9f44-aa8d07016f48"}
{"func_before":"    for(j = 0; j < 3; j++) {\n      \/* Reverse the neighboring facets if necessary. *\/\n      if(stl->neighbors_start[facet_num].which_vertex_not[j] > 2) {\n        \/* If the facet has a neighbor that is -1, it means that edge isn't shared by another facet *\/\n        if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n          stl_reverse_facet\n          (stl, stl->neighbors_start[facet_num].neighbor[j]);\n        }\n      }\n      \/* If this edge of the facet is connected: *\/\n      if(stl->neighbors_start[facet_num].neighbor[j] != -1 &&\n         stl->neighbors_start[facet_num].neighbor[j] < stl->stats.number_of_facets*sizeof(char)) {\n        \/* If we haven't fixed this facet yet, add it to the list: *\/\n        if(norm_sw[stl->neighbors_start[facet_num].neighbor[j]] != 1) {\n          \/* Add node to beginning of list. *\/\n          newn = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n          if(newn == NULL) perror(\"stl_fix_normal_directions\");\n          newn->facet_num = stl->neighbors_start[facet_num].neighbor[j];\n          newn->next = head->next;\n          head->next = newn;\n        }\n      }","target":0,"flaw_line_index":0,"hash":"1107f7c7-9642-4372-af14-87c7ed45a345","idx":"b485d4de-674f-44e0-a544-e858c6a4c627"}
{"func_before":"static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length, \n                                         uint32 width, uint16 spp,\n                                         struct dump_opts *dump)\n  {\n  int i, j, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;\n  int32  bytes_read = 0;\n  uint16 bps, nstrips, planar, strips_per_sample;\n  uint32 src_rowsize, dst_rowsize, rows_processed, rps;\n  uint32 rows_this_strip = 0;\n  tsample_t s;\n  tstrip_t  strip;\n  tsize_t scanlinesize = TIFFScanlineSize(in);\n  tsize_t stripsize    = TIFFStripSize(in);\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *buff = NULL;\n  unsigned char *dst = NULL;\n","target":1,"flaw_line_index":0,"hash":"301e1343-bd37-43a0-8164-7d44257fc4b5","idx":"eae7a798-bd30-4e1d-998d-54ca3c011980"}
{"func_before":"static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length, \n                                         uint32 width, uint16 spp,\n                                         struct dump_opts *dump)\n  {\n  int i, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;\n  uint32 j;\n  int32  bytes_read = 0;\n  uint16 bps, planar;\n  uint32 nstrips;\n  uint32 strips_per_sample;\n  uint32 src_rowsize, dst_rowsize, rows_processed, rps;\n  uint32 rows_this_strip = 0;\n  tsample_t s;\n  tstrip_t  strip;\n  tsize_t scanlinesize = TIFFScanlineSize(in);\n  tsize_t stripsize    = TIFFStripSize(in);\n  unsigned char *srcbuffs[MAX_SAMPLES];\n  unsigned char *buff = NULL;\n  unsigned char *dst = NULL;\n","target":0,"flaw_line_index":0,"hash":"b9624dda-75ac-4ed4-af6d-4a9550401ded","idx":"3adc6cf8-8fdc-4d4b-a3e1-b610ce15cddb"}
{"func_before":"    \/\/ attributes as type variables.\n    \/\/ See https:\/\/www.tensorflow.org\/guide\/create_op#type_polymorphism.\n    \/\/ Once the op signature can be defined entirely in FullType, this\n    \/\/ convention can be deprecated.\n    \/\/\n    \/\/ Note: While this code performs some basic verifications, it generally\n    \/\/ assumes consistent op defs and attributes. If more complete\n    \/\/ verifications are needed, they should be done by separately, and in a\n    \/\/ way that can be reused for type inference.\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        if (attr == nullptr) {\n          return Status(\n              error::INVALID_ARGUMENT,\n              absl::StrCat(\"Could not find an attribute for key \", arg->s()));\n        }\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);","target":1,"flaw_line_index":0,"hash":"8f5267f1-080d-4062-ac8c-51364e96044a","idx":"52245c88-d9ba-4b11-8725-03fdead32dbc"}
{"func_before":"    \/\/ attributes as type variables.\n    \/\/ See https:\/\/www.tensorflow.org\/guide\/create_op#type_polymorphism.\n    \/\/ Once the op signature can be defined entirely in FullType, this\n    \/\/ convention can be deprecated.\n    \/\/\n    \/\/ Note: While this code performs some basic verifications, it generally\n    \/\/ assumes consistent op defs and attributes. If more complete\n    \/\/ verifications are needed, they should be done by separately, and in a\n    \/\/ way that can be reused for type inference.\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(j);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        if (attr == nullptr) {\n          return Status(\n              error::INVALID_ARGUMENT,\n              absl::StrCat(\"Could not find an attribute for key \", arg->s()));\n        }\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);","target":0,"flaw_line_index":0,"hash":"72c9d677-0643-4312-94a5-66b4e2ebe69a","idx":"cf2873b3-661e-4755-9431-e5c12c0e726f"}
{"func_before":"static int lmf_header_load(lmf_header *lmfh, RBuffer *buf, Sdb *db) {\n\tif (r_buf_size (buf) < sizeof (lmf_header)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, \"iiiiiiiicccciiiicc\", 1) < QNX_HDR_SIZE) {\n\t\treturn false;\n\t}\n\tr_strf_buffer (32);\n\tsdb_set (db, \"qnx.version\", r_strf (\"0x%xH\", lmfh->version), 0);\n\tsdb_set (db, \"qnx.cflags\", r_strf (\"0x%xH\", lmfh->cflags), 0);\n\tsdb_set (db, \"qnx.cpu\", r_strf (\"0x%xH\", lmfh->cpu), 0);\n\tsdb_set (db, \"qnx.fpu\", r_strf (\"0x%xH\", lmfh->fpu), 0);\n\tsdb_set (db, \"qnx.code_index\", r_strf (\"0x%x\", lmfh->code_index), 0);\n\tsdb_set (db, \"qnx.stack_index\", r_strf (\"0x%x\", lmfh->stack_index), 0);\n\tsdb_set (db, \"qnx.heap_index\", r_strf (\"0x%x\", lmfh->heap_index), 0);","target":1,"flaw_line_index":0,"hash":"44bb31b8-b65d-4bdd-a043-2420cd523828","idx":"673804db-4404-4228-8831-3d7f91631cfc"}
{"func_before":"static int lmf_header_load(lmf_header *lmfh, RBuffer *buf, Sdb *db) {\n\tif (r_buf_size (buf) < sizeof (lmf_header)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, \"iiiiiiiicccciiiicc\", 1) != QNX_HDR_SIZE) {\n\t\treturn false;\n\t}\n\tr_strf_buffer (32);\n\tsdb_set (db, \"qnx.version\", r_strf (\"0x%xH\", lmfh->version), 0);\n\tsdb_set (db, \"qnx.cflags\", r_strf (\"0x%xH\", lmfh->cflags), 0);\n\tsdb_set (db, \"qnx.cpu\", r_strf (\"0x%xH\", lmfh->cpu), 0);\n\tsdb_set (db, \"qnx.fpu\", r_strf (\"0x%xH\", lmfh->fpu), 0);\n\tsdb_set (db, \"qnx.code_index\", r_strf (\"0x%x\", lmfh->code_index), 0);\n\tsdb_set (db, \"qnx.stack_index\", r_strf (\"0x%x\", lmfh->stack_index), 0);\n\tsdb_set (db, \"qnx.heap_index\", r_strf (\"0x%x\", lmfh->heap_index), 0);","target":0,"flaw_line_index":0,"hash":"15d610e6-cb98-4476-bb71-920404051dcd","idx":"cca10ec4-c5a4-4e4c-b37f-aa7429bc3b4f"}
{"func_before":"int jas_matrix_resize(jas_matrix_t *matrix, int numrows, int numcols)\n{\n\tint size;\n\tint i;\n\n\tsize = numrows * numcols;\n\tif (size > matrix->datasize_ || numrows > matrix->maxrows_) {\n\t\treturn -1;\n\t}\n\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\n\tfor (i = 0; i < numrows; ++i) {","target":1,"flaw_line_index":0,"hash":"ab6cd52a-0875-40e3-8e44-69b2f23024d5","idx":"1b8651d9-466c-4201-a71e-7064ead5cf62"}
{"func_before":"int jas_matrix_resize(jas_matrix_t *matrix, jas_matind_t numrows,\n  jas_matind_t numcols)\n{\n\tjas_matind_t size;\n\tjas_matind_t i;\n\n\tsize = numrows * numcols;\n\tif (size > matrix->datasize_ || numrows > matrix->maxrows_) {\n\t\treturn -1;\n\t}\n\n\tmatrix->numrows_ = numrows;\n\tmatrix->numcols_ = numcols;\n\n\tfor (i = 0; i < numrows; ++i) {","target":0,"flaw_line_index":0,"hash":"0188d043-e930-46d3-9a5e-25aaf4fe074b","idx":"b988f00d-b344-4ab6-8077-7968481a90c8"}
{"func_before":"  string body;\n  if (reqHeaders->count(\"Cookie\") != 0) {\n    string cookies = (*reqHeaders)[\"Cookie\"];\n    string sessionIdString = cookies.substr(cookies.find(\"=\") + 1);\n    sessionId = stoll(sessionIdString, nullptr);\n    auto usersessionIt = sessionMap.find(sessionId);\n    if (usersessionIt == sessionMap.end()){\n      cout << \"Bad session ID, redirecting to login.\" << endl;\n      body = getLogin();\n    } else\n      uid = sessionMap[sessionId];\n  }\n  map<string, string> resHeaders;\n  resHeaders[\"Server\"] = \"CSE461\";\n  resHeaders[\"Content-Type\"] = \"text\/html; charset=UTF-8\";\n\n  if (uri.compare(\"\/cal\") == 0 && uid == -1) {\n    cout << \"login page\" << endl;\n    \/\/ login page\n    body = getLogin();\n  } else if (uri.compare(\"\/cal\") == 0 && uid != -1) {","target":1,"flaw_line_index":0,"hash":"9769bbd4-803b-4143-a98a-ffa394c78bbd","idx":"dc9dfbe1-1b04-4584-9cbe-53fa48f2f425"}
{"func_before":"  string body;\n  if (reqHeaders->count(\"Cookie\") != 0) {\n    string cookies = (*reqHeaders)[\"Cookie\"];\n    string sessionIdString = cookies.substr(cookies.find(\"=\") + 1);\n    sessionId = stoll(sessionIdString, nullptr);\n    auto usersessionIt = sessionMap.find(sessionId);\n    if (usersessionIt == sessionMap.end()){\n      cout << \"Bad session ID, redirecting to login.\" << endl;\n      body = getLogin();\n    } else\n      uid = usersessionIt->second;\n  }\n  map<string, string> resHeaders;\n  resHeaders[\"Server\"] = \"CSE461\";\n  resHeaders[\"Content-Type\"] = \"text\/html; charset=UTF-8\";\n\n  if (uri.compare(\"\/cal\") == 0 && uid == -1) {\n    cout << \"login page\" << endl;\n    \/\/ login page\n    body = getLogin();\n  } else if (uri.compare(\"\/cal\") == 0 && uid != -1) {","target":0,"flaw_line_index":0,"hash":"3ba91acc-5c20-4c26-a661-383acac475d2","idx":"0baa3059-babf-4d27-87e6-b085e12b679c"}
{"func_before":"    struct Dwarf_Line_Registers_s * regs,\n    Dwarf_Bool is_single_table, Dwarf_Bool is_actuals_table)\n{\n    dwarfstring m1;\n\n    dwarfstring_constructor_static(&m1,locallinebuf,\n        sizeof(locallinebuf));\n    if(!is_single_table && is_actuals_table) {\n        dwarfstring_append_printf_s(&m1,\"%-15s \",(char *)prefix);\n        dwarfstring_append_printf_i(&m1,\"%3d \",opcode);\n        dwarfstring_append_printf_u(&m1,\"0x%\" DW_PR_XZEROS DW_PR_DUx ,\n            regs->lr_address);\n        dwarfstring_append_printf_u(&m1,\"\/%01u\",regs->lr_op_index);\n        dwarfstring_append_printf_u(&m1,\" %5lu\", regs->lr_line);\n        dwarfstring_append_printf_u(&m1,\" %3d\",regs->lr_isa);\n        dwarfstring_append_printf_i(&m1,\"   %1d\", regs->lr_basic_block);\n        dwarfstring_append_printf_i(&m1,\"%1d\\n\",  regs->lr_end_sequence);\n        _dwarf_printf(dbg,dwarfstring_string(&m1));\n        dwarfstring_destructor(&m1);\n        return;\n    }\n    if(!is_single_table && !is_actuals_table) {\n        dwarfstring_append_printf_i(&m1,\n            \"[%3d] \"  \/* row number *\/, curr_line);\n        dwarfstring_append_printf_s(&m1,\n            \"%-15s \",(char *)prefix);\n        dwarfstring_append_printf_i(&m1,\n            regs->lr_prologue_end ||\n            regs->lr_epilogue_begin ||\n            regs->lr_isa ||\n            regs->lr_is_stmt ||\n            regs->lr_call_context ||\n            regs->lr_subprogram) {\n            dwarfstring_append_printf_u(&m1,\n                \"   x%02\" DW_PR_DUx ,\n                regs->lr_discriminator); \/* DWARF4 *\/\n            dwarfstring_append_printf_u(&m1,\n                \"  x%02\" DW_PR_DUx , regs->lr_call_context); \/* EXPERIMENTAL *\/\n            dwarfstring_append_printf_u(&m1,\n                \"  x%02\" DW_PR_DUx , regs->lr_subprogram); \/* EXPERIMENTAL *\/\n            dwarfstring_append_printf_i(&m1,\n                \"  %1d\", regs->lr_is_stmt);\n            dwarfstring_append_printf_i(&m1,\n                \"%1d\", (int) regs->lr_isa);\n            dwarfstring_append_printf_i(&m1,\n                \"%1d\", regs->lr_prologue_end); \/* DWARF3 *\/\n            dwarfstring_append_printf_i(&m1,\n                \"%1d\", regs->lr_epilogue_begin); \/* DWARF3 *\/\n        }\n        dwarfstring_append(&m1,\"\\n\");","target":1,"flaw_line_index":0,"hash":"bca78ebd-e2f7-4d1e-a9fe-aa5a7203f18e","idx":"9909039b-3c36-46f5-8327-69f6d104517c"}
{"func_before":"    struct Dwarf_Line_Registers_s * regs,\n    Dwarf_Bool is_single_table, Dwarf_Bool is_actuals_table)\n{\n    dwarfstring m1;\n\n    dwarfstring_constructor_static(&m1,locallinebuf,\n        sizeof(locallinebuf));\n    if(!is_single_table && is_actuals_table) {\n        dwarfstring_append_printf_s(&m1,\"%-15s \",(char *)prefix);\n        dwarfstring_append_printf_i(&m1,\"%3d \",opcode);\n        dwarfstring_append_printf_u(&m1,\"0x%\" DW_PR_XZEROS DW_PR_DUx,\n            regs->lr_address);\n        dwarfstring_append_printf_u(&m1,\"\/%01u\",regs->lr_op_index);\n        dwarfstring_append_printf_u(&m1,\" %5lu\", regs->lr_line);\n        dwarfstring_append_printf_u(&m1,\" %3d\",regs->lr_isa);\n        dwarfstring_append_printf_i(&m1,\"   %1d\",\n            regs->lr_basic_block);\n        dwarfstring_append_printf_i(&m1,\"%1d\\n\",\n            regs->lr_end_sequence);\n        _dwarf_printf(dbg,dwarfstring_string(&m1));\n        dwarfstring_destructor(&m1);\n        return;\n    }\n    if(!is_single_table && !is_actuals_table) {\n        dwarfstring_append_printf_i(&m1,\n            \"[%3d] \"  \/* row number *\/, curr_line);\n        dwarfstring_append_printf_s(&m1,\n            \"%-15s \",(char *)prefix);\n        dwarfstring_append_printf_i(&m1,\n            regs->lr_prologue_end ||\n            regs->lr_epilogue_begin ||\n            regs->lr_isa ||\n            regs->lr_is_stmt ||\n            regs->lr_call_context ||\n            regs->lr_subprogram) {\n            dwarfstring_append_printf_u(&m1,\n                \"   x%02\" DW_PR_DUx ,\n                regs->lr_discriminator); \/* DWARF4 *\/\n            dwarfstring_append_printf_u(&m1,\n                \"  x%02\" DW_PR_DUx,\n                regs->lr_call_context); \/* EXPERIMENTAL *\/\n            dwarfstring_append_printf_u(&m1,\n                \"  x%02\" DW_PR_DUx ,\n                regs->lr_subprogram); \/* EXPERIMENTAL *\/\n            dwarfstring_append_printf_i(&m1,\n                \"  %1d\", regs->lr_is_stmt);\n            dwarfstring_append_printf_i(&m1,\n                \"%1d\", (int) regs->lr_isa);\n            dwarfstring_append_printf_i(&m1,\n                \"%1d\", regs->lr_prologue_end); \/* DWARF3 *\/\n            dwarfstring_append_printf_i(&m1,\n                \"%1d\", regs->lr_epilogue_begin); \/* DWARF3 *\/\n        }\n        dwarfstring_append(&m1,\"\\n\");","target":0,"flaw_line_index":0,"hash":"caac9158-65cc-4c5c-b767-98064ca407d8","idx":"8ce18607-e3b2-4f97-a808-945da86c3d42"}
{"func_before":"static inline u32 net_hash_mix(const struct net *net)\n{\n#ifdef CONFIG_NET_NS\n\treturn (u32)(((unsigned long)net) >> ilog2(sizeof(*net)));\n#else\n\treturn 0;\n#endif\n}","target":1,"flaw_line_index":0,"hash":"3f05a038-5d1b-4f84-a68b-79b8746cf1e0","idx":"c2791754-3d14-45d3-8036-18d486d1c92f"}
{"func_before":"static inline u32 net_hash_mix(const struct net *net)\n{\n\treturn net->hash_mix;\n}","target":0,"flaw_line_index":0,"hash":"adbe95f6-09eb-4a0e-a517-de01944c9104","idx":"7bf789ea-ec5b-457f-9c3a-8c3d5aece922"}
{"func_before":"\tDBG_dump(\"verify_sh decrypted SIG1:\", s, sig_len));\n    DBG(DBG_CRYPT, DBG_log(\"pad_len calculated: %d hash_len: %d\", padlen, (int)hash_len));\n\n    \/* skip padding *\/\n    if(s[0]    != 0x00\n       || s[1] != 0x01\n       || s[padlen+2] != 0x00) {\n\treturn \"3\"\"SIG padding does not check out\";\n    }\n\n    s += padlen + 3;\n    (*psig) = s;\n\n    \/* return SUCCESS *\/\n    return NULL;\n}","target":1,"flaw_line_index":0,"hash":"678c5317-a46a-452e-9346-448346cea737","idx":"5f19278d-7d1d-4db9-9379-bed210fc3211"}
{"func_before":"\tDBG_dump(\"verify_sh decrypted SIG1:\", s, sig_len));\n    DBG(DBG_CRYPT, DBG_log(\"pad_len calculated: %d hash_len: %d\", padlen, (int)hash_len));\n\n    \/* skip padding *\/\n    if(s[0]    != 0x00\n       || s[1] != 0x01\n       || s[padlen+2] != 0x00) {\n\treturn \"3\"\"SIG padding does not check out\";\n    }\n\n    \/* signature starts after ASN wrapped padding [00,01,FF..FF,00] *\/\n    (*psig) = s + padlen + 3;\n\n    \/* verify padding contents *\/\n    {\n        const u_char *p;\n        size_t cnt_ffs = 0;\n\n        for (p = s+2; p < s+padlen+2; p++)\n            if (*p == 0xFF)\n                cnt_ffs ++;\n\n        if (cnt_ffs != padlen)\n            return \"4\" \"invalid Padding String\";\n    }\n\n    \/* return SUCCESS *\/\n    return NULL;\n}","target":0,"flaw_line_index":0,"hash":"5a99a736-b4eb-43e1-bc40-05c8d6b7a805","idx":"f4214179-f94f-4b28-a0e3-4d9d61b112a3"}
{"func_before":"static void pp_mil_k8(fp8_t r, ep2_t *t, ep2_t *q, ep_t *p, int m, bn_t a) {\n\tfp8_t l;\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep2_t *_q = RLC_ALLOCA(ep2_t, m);\n\tint i, j, len = bn_bits(a) + 1;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tif (m == 0) {\n\t\treturn;\n\t}\n\n\tfp8_null(l);\n\n\tRLC_TRY {\n\t\tfp8_new(l);","target":1,"flaw_line_index":0,"hash":"5adc5954-dbbe-4495-8a99-7393bcde7c5e","idx":"a97b4bf6-6a40-4747-8e35-a248351a5c5c"}
{"func_before":"static void pp_mil_k8(fp8_t r, ep2_t *t, ep2_t *q, ep_t *p, int m, bn_t a) {\n\tfp8_t l;\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep2_t *_q = RLC_ALLOCA(ep2_t, m);\n\tsize_t len = bn_bits(a) + 1;\n\tint i, j;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tif (m == 0) {\n\t\treturn;\n\t}\n\n\tfp8_null(l);\n\n\tRLC_TRY {\n\t\tfp8_new(l);","target":0,"flaw_line_index":0,"hash":"a707e18d-2358-4afd-9c02-2c1c0eb96535","idx":"e0743d68-3e25-4589-997c-44761e2989c6"}
{"func_before":"\nstatic void bfq_idle_slice_timer_body(struct bfq_queue *bfqq)\n{\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tenum bfqq_expiration reason;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\tbfq_clear_bfqq_wait_request(bfqq);\n\n\tif (bfqq != bfqd->in_service_queue) {\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t\treturn;\n\t}\n\n\tif (bfq_bfqq_budget_timeout(bfqq))\n\t\t\/*\n\t\t * Also here the queue can be safely expired\n\t\t * for budget timeout without wasting\n\t\t * guarantees\n\t\t *\/\n\t\treason = BFQQE_BUDGET_TIMEOUT;\n\telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n\t\t\/*\n\t\t * The queue may not be empty upon timer expiration,\n\t\t * because we may not disable the timer when the\n\t\t * first request of the in-service queue arrives\n\t\t * during disk idling.\n\t\t *\/\n\t\treason = BFQQE_TOO_IDLE;\n\telse\n\t\tgoto schedule_dispatch;\n\n\tbfq_bfqq_expire(bfqd, bfqq, true, reason);\n\nschedule_dispatch:\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\tbfq_schedule_dispatch(bfqd);","target":1,"flaw_line_index":0,"hash":"a838872e-8846-40e9-bb56-35f8db64389a","idx":"193ace6a-5eee-4629-bd76-6ebdc76d6ca8"}
{"func_before":"static void\nbfq_idle_slice_timer_body(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\tenum bfqq_expiration reason;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\n\t\/*\n\t * Considering that bfqq may be in race, we should firstly check\n\t * whether bfqq is in service before doing something on it. If\n\t * the bfqq in race is not in service, it has already been expired\n\t * through __bfq_bfqq_expire func and its wait_request flags has\n\t * been cleared in __bfq_bfqd_reset_in_service func.\n\t *\/\n\tif (bfqq != bfqd->in_service_queue) {\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t\treturn;\n\t}\n\n\tbfq_clear_bfqq_wait_request(bfqq);\n\n\tif (bfq_bfqq_budget_timeout(bfqq))\n\t\t\/*\n\t\t * Also here the queue can be safely expired\n\t\t * for budget timeout without wasting\n\t\t * guarantees\n\t\t *\/\n\t\treason = BFQQE_BUDGET_TIMEOUT;\n\telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n\t\t\/*\n\t\t * The queue may not be empty upon timer expiration,\n\t\t * because we may not disable the timer when the\n\t\t * first request of the in-service queue arrives\n\t\t * during disk idling.\n\t\t *\/\n\t\treason = BFQQE_TOO_IDLE;\n\telse\n\t\tgoto schedule_dispatch;\n\n\tbfq_bfqq_expire(bfqd, bfqq, true, reason);\n\nschedule_dispatch:\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\tbfq_schedule_dispatch(bfqd);","target":0,"flaw_line_index":0,"hash":"3f069213-0ce6-4f60-922d-a5fc6575906b","idx":"8723357f-ff72-4d5c-890f-058e7f05a74f"}
{"func_before":"\t\tif (ms->search.s == NULL)\n\t\t\treturn 0;\n\n\t\tl = 0;\n\t\trc = file_regcomp(&rx, m->value.s,\n\t\t    REG_EXTENDED|REG_NEWLINE|\n\t\t    ((m->str_flags & STRING_IGNORE_CASE) ? REG_ICASE : 0));\n\t\tif (rc) {\n\t\t\tfile_regerror(&rx, rc, ms);\n\t\t\tv = (uint64_t)-1;\n\t\t} else {\n\t\t\tregmatch_t pmatch[1];\n#ifndef REG_STARTEND\n#define\tREG_STARTEND\t0\n\t\t\tsize_t l = ms->search.s_len - 1;\n\t\t\tchar c = ms->search.s[l];\n\t\t\t((char *)(intptr_t)ms->search.s)[l] = '\\0';\n#else\n\t\t\tpmatch[0].rm_so = 0;\n\t\t\tpmatch[0].rm_eo = ms->search.s_len;\n#endif\n\t\t\trc = file_regexec(&rx, (const char *)ms->search.s,\n\t\t\t    1, pmatch, REG_STARTEND);\n#if REG_STARTEND == 0\n\t\t\t((char *)(intptr_t)ms->search.s)[l] = c;\n#endif\n\t\t\tswitch (rc) {\n\t\t\tcase 0:\n\t\t\t\tms->search.s += (int)pmatch[0].rm_so;\n\t\t\t\tms->search.offset += (size_t)pmatch[0].rm_so;","target":1,"flaw_line_index":0,"hash":"03206f73-107b-441f-bba1-1237eb5f36d5","idx":"fa1b777f-5cde-4bc9-9953-3b7c57d1c40a"}
{"func_before":"\t\t\treturn 0;\n\n\t\tl = 0;\n\t\trc = file_regcomp(&rx, m->value.s,\n\t\t    REG_EXTENDED|REG_NEWLINE|\n\t\t    ((m->str_flags & STRING_IGNORE_CASE) ? REG_ICASE : 0));\n\t\tif (rc) {\n\t\t\tfile_regerror(&rx, rc, ms);\n\t\t\tv = (uint64_t)-1;\n\t\t} else {\n#ifndef REG_STARTEND\n\t\t\tchar c;\n#endif\n\t\t\tregmatch_t pmatch[1];\n\t\t\tsize_t slen = ms->search.s_len;\n\t\t\t\/* Limit by offset if requested *\/\n\t\t\tif (m->str_range > 0)\n\t\t\t\tslen = MIN(slen, m->str_range);\n#ifndef REG_STARTEND\n#define\tREG_STARTEND\t0\n\t\t\tif (slen != 0)\n\t\t\t\tslen--;\n\t\t\tc = ms->search.s[slen];\n\t\t\t((char *)(intptr_t)ms->search.s)[slen] = '\\0';\n#else\n\t\t\tpmatch[0].rm_so = 0;\n\t\t\tpmatch[0].rm_eo = slen;\n#endif\n\t\t\trc = file_regexec(&rx, (const char *)ms->search.s,\n\t\t\t    1, pmatch, REG_STARTEND);\n#if REG_STARTEND == 0\n\t\t\t((char *)(intptr_t)ms->search.s)[l] = c;\n#endif\n\t\t\tswitch (rc) {\n\t\t\tcase 0:\n\t\t\t\tms->search.s += (int)pmatch[0].rm_so;\n\t\t\t\tms->search.offset += (size_t)pmatch[0].rm_so;","target":0,"flaw_line_index":0,"hash":"aa4d5f77-e882-4869-8516-69b9f0ebb4de","idx":"885a437f-e393-47d7-92aa-aec40f0b10a8"}
{"func_before":"mm_answer_pam_free_ctx(int sock, Buffer *m)\n{\n\n\tdebug3(\"%s\", __func__);\n\t(sshpam_device.free_ctx)(sshpam_ctxt);\n\tbuffer_clear(m);\n\tmm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"pam\";\n\treturn (sshpam_authok == sshpam_ctxt);\n}","target":1,"flaw_line_index":0,"hash":"e899d7d2-154c-44bc-b3b3-ba125f8c7646","idx":"c6bcb92a-36ba-4f74-9562-f7d418b5f24c"}
{"func_before":"mm_answer_pam_free_ctx(int sock, Buffer *m)\n{\n\tint r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;\n\n\tdebug3(\"%s\", __func__);\n\t(sshpam_device.free_ctx)(sshpam_ctxt);\n\tsshpam_ctxt = sshpam_authok = NULL;\n\tbuffer_clear(m);\n\tmm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"pam\";\n\treturn r;\n}","target":0,"flaw_line_index":0,"hash":"0f721a7c-9fee-4e27-b902-e822bed9ce3c","idx":"2d858c54-8146-4da9-ba87-39aa5bab2b30"}
{"func_before":"WRITE_JSON_ELEMENT(ArrStart) {\n    \/* increase depth, save: before first array entry no comma needed. *\/\n    ctx->commaNeeded[++ctx->depth] = false;\n    return writeChar(ctx, '[');\n}","target":1,"flaw_line_index":0,"hash":"9cb056e7-e339-4a33-8ded-2a3faa8ed930","idx":"20d1efb1-de47-41d2-ab76-31c0c4b6bd2b"}
{"func_before":"WRITE_JSON_ELEMENT(ObjStart) {\n    \/* increase depth, save: before first key-value no comma needed. *\/\n    if(ctx->depth >= UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    ctx->depth++;\n    ctx->commaNeeded[ctx->depth] = false;\n    return writeChar(ctx, '{');\n}","target":0,"flaw_line_index":0,"hash":"2bde2915-72c2-4178-8cbd-326b5cc492fa","idx":"38009e56-3476-4446-8dfb-f51215104b4d"}
{"func_before":"static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n","target":1,"flaw_line_index":0,"hash":"9f112a9e-277a-48af-8224-d7b25fc381c1","idx":"7aa075c7-7706-4654-9051-5dc1f96d1f6c"}
{"func_before":"static int nfc_genl_deactivate_target(struct sk_buff *skb,\n\t\t\t\t      struct genl_info *info)\n{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_TARGET_INDEX])\n\t\treturn -EINVAL;\n\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\ttarget_idx = nla_get_u32(info->attrs[NFC_ATTR_TARGET_INDEX]);\n","target":0,"flaw_line_index":0,"hash":"d3f30261-d1f9-4e51-8e3c-013a20d69ec7","idx":"ef1ca210-a77a-4136-bfaf-246b361df266"}
{"func_before":"      TF_RETURN_IF_ERROR(context->allocate_output(kEmptyRowIndicatorOutput,\n                                                  TensorShape({dense_rows}),\n                                                  &empty_row_indicator_t_ptr));\n      empty_row_indicator = empty_row_indicator_t_ptr->vec<bool>().data();\n    } else {\n      TF_RETURN_IF_ERROR(context->allocate_temp(\n          DT_BOOL, TensorShape({dense_rows}), &empty_row_indicator_t));\n      empty_row_indicator = empty_row_indicator_t.vec<bool>().data();\n    }\n\n    TF_RETURN_IF_ERROR(wrap_kernel_call(ComputeEmptyRowIndicatorKernel<Tindex>,\n                                        \/*device=*\/device, \/*size=*\/dense_rows,\n                                        elements_per_row, empty_row_indicator));\n\n    \/\/ For each row, the number of empty rows up to and including that row.\n    Tensor num_empty_rows_through_t;\n    TF_RETURN_IF_ERROR(context->allocate_temp(\n        index_type, TensorShape({dense_rows}), &num_empty_rows_through_t));\n    auto num_empty_rows_through = num_empty_rows_through_t.flat<Tindex>();\n\n    gpuprim::TransformInputIterator<Tindex, CastFunctor<Tindex>, bool*>\n        empty_row_indicator_cast(empty_row_indicator, {});\n\n        OP_REQUIRES_OK_ASYNC(\n            context,\n            wrap_kernel_call(ScatterInputElementsKernel<T, Tindex>,\n                             \/*device=*\/device, \/*size=*\/N, dense_rows, rank,\n                             input_index_map, indices, values,\n                             num_empty_rows_through, output_indices,\n                             output_values, reverse_index_map),\n            done);\n      }\n\n      OP_REQUIRES_OK_ASYNC(\n          context,\n          wrap_kernel_call(ScatterNewElementsKernel<T, Tindex>,\n                           \/*device=*\/device, \/*size=*\/dense_rows, rank,\n                           default_value, num_empty_rows_through,\n                           input_row_ends, empty_row_indicator, output_indices,\n                           output_values),\n          done);\n\n      done();\n    };\n\n    context->device()\n        ->tensorflow_accelerator_device_info()\n        ->event_mgr->ThenExecute(stream, async_finish_computation);\n    return OkStatus();\n  }","target":1,"flaw_line_index":0,"hash":"52eee898-507a-4d3f-abdc-fb1ee63f2a21","idx":"41baa723-6957-4251-ae5a-cc1115f5d9cc"}
{"func_before":"      TF_RETURN_IF_ERROR(context->allocate_output(kEmptyRowIndicatorOutput,\n                                                  TensorShape({dense_rows}),\n                                                  &empty_row_indicator_t_ptr));\n      empty_row_indicator = empty_row_indicator_t_ptr->vec<bool>().data();\n    } else {\n      TF_RETURN_IF_ERROR(context->allocate_temp(\n          DT_BOOL, TensorShape({dense_rows}), &empty_row_indicator_t));\n      empty_row_indicator = empty_row_indicator_t.vec<bool>().data();\n    }\n\n    if (dense_rows > 0) {\n      TF_RETURN_IF_ERROR(\n          wrap_kernel_call(ComputeEmptyRowIndicatorKernel<Tindex>,\n                           \/*device=*\/device, \/*size=*\/dense_rows,\n                           elements_per_row, empty_row_indicator));\n    }\n\n    \/\/ For each row, the number of empty rows up to and including that row.\n    Tensor num_empty_rows_through_t;\n    TF_RETURN_IF_ERROR(context->allocate_temp(\n        index_type, TensorShape({dense_rows}), &num_empty_rows_through_t));\n    auto num_empty_rows_through = num_empty_rows_through_t.flat<Tindex>();\n\n    gpuprim::TransformInputIterator<Tindex, CastFunctor<Tindex>, bool*>\n        empty_row_indicator_cast(empty_row_indicator, {});\n\n        OP_REQUIRES_OK_ASYNC(\n            context,\n            wrap_kernel_call(ScatterInputElementsKernel<T, Tindex>,\n                             \/*device=*\/device, \/*size=*\/N, dense_rows, rank,\n                             input_index_map, indices, values,\n                             num_empty_rows_through, output_indices,\n                             output_values, reverse_index_map),\n            done);\n      }\n\n      if (dense_rows > 0) {\n        OP_REQUIRES_OK_ASYNC(\n            context,\n            wrap_kernel_call(ScatterNewElementsKernel<T, Tindex>,\n                             \/*device=*\/device, \/*size=*\/dense_rows, rank,\n                             default_value, num_empty_rows_through,\n                             input_row_ends, empty_row_indicator,\n                             output_indices, output_values),\n            done);\n      }\n\n      done();\n    };\n\n    context->device()\n        ->tensorflow_accelerator_device_info()\n        ->event_mgr->ThenExecute(stream, async_finish_computation);\n    return OkStatus();\n  }","target":0,"flaw_line_index":0,"hash":"d601d4a1-d4c4-4545-8bc8-bcf470ae800a","idx":"d543113f-129f-4759-bc46-346b568fa48f"}
{"func_before":"\t\t\t\t *\/\n\t\t\t\tif (sk->af ==\n\t\t\t\t    (*stp)->key[PF_SK_WIRE]->af &&\n\t\t\t\t    (((*stp)->direction == PF_OUT &&\n\t\t\t\t    PF_AEQ(&sn->addr, &sk->addr[1], sk->af)) ||\n\t\t\t\t    ((*stp)->direction == PF_IN &&\n\t\t\t\t    PF_AEQ(&sn->addr, &sk->addr[0], sk->af))) &&\n\t\t\t\t    ((*stp)->rule.ptr->flush &\n\t\t\t\t    PF_FLUSH_GLOBAL ||\n\t\t\t\t    (*stp)->rule.ptr == st->rule.ptr)) {\n\t\t\t\t\tst->timeout = PFTM_PURGE;\n\t\t\t\t\tpf_set_protostate(st, PF_PEER_BOTH,\n\t\t\t\t\t    TCPS_CLOSED);\n\t\t\t\t\tkilled++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pf_status.debug >= LOG_NOTICE)\n\t\t\t\taddlog(\", %u states killed\", killed);\n\t\t}\n\t\tif (pf_status.debug >= LOG_NOTICE)\n\t\t\taddlog(\"\\n\");\n\t}\n\n\t\/* kill this state *\/\n\t(*stp)->timeout = PFTM_PURGE;\n\tpf_set_protostate(*stp, PF_PEER_BOTH, TCPS_CLOSED);\n\treturn (1);\n}","target":1,"flaw_line_index":0,"hash":"3e733a2f-9b65-43e9-bb12-a0661be9d80c","idx":"d63116dd-86df-4e4c-a293-ffca50b625ae"}
{"func_before":"\t\t\t\t *\/\n\t\t\t\tif (sk->af ==\n\t\t\t\t    (*stp)->key[PF_SK_WIRE]->af &&\n\t\t\t\t    (((*stp)->direction == PF_OUT &&\n\t\t\t\t    PF_AEQ(&sn->addr, &sk->addr[1], sk->af)) ||\n\t\t\t\t    ((*stp)->direction == PF_IN &&\n\t\t\t\t    PF_AEQ(&sn->addr, &sk->addr[0], sk->af))) &&\n\t\t\t\t    ((*stp)->rule.ptr->flush &\n\t\t\t\t    PF_FLUSH_GLOBAL ||\n\t\t\t\t    (*stp)->rule.ptr == st->rule.ptr)) {\n\t\t\t\t\tpf_update_state_timeout(st, PFTM_PURGE);\n\t\t\t\t\tpf_set_protostate(st, PF_PEER_BOTH,\n\t\t\t\t\t    TCPS_CLOSED);\n\t\t\t\t\tkilled++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pf_status.debug >= LOG_NOTICE)\n\t\t\t\taddlog(\", %u states killed\", killed);\n\t\t}\n\t\tif (pf_status.debug >= LOG_NOTICE)\n\t\t\taddlog(\"\\n\");\n\t}\n\n\t\/* kill this state *\/\n\tpf_update_state_timeout(*stp, PFTM_PURGE);\n\tpf_set_protostate(*stp, PF_PEER_BOTH, TCPS_CLOSED);\n\treturn (1);\n}","target":0,"flaw_line_index":0,"hash":"f47fa995-d99b-40fd-8e38-8d4389074c39","idx":"e2d2038e-6fdc-4467-b795-dec14bf9964c"}
{"func_before":"static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain <= 0) {\n\t\t\t\/* 2.0.34: EOF is incorrect. We use 0 for\n\t\t\t * errors and EOF, just like fileGetbuf,\n\t\t\t * which is a simple fread() wrapper.\n\t\t\t * TBB. Original bug report: Daniel Cowgill. *\/\n\t\t\treturn 0; \/* NOT EOF *\/\n\t\t}\n\n\t\trlen = remain;\n\t}\n\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\n\treturn rlen;\n}","target":1,"flaw_line_index":0,"hash":"bf15f21c-57e1-459e-91f3-f34978368bd9","idx":"0b6f82fc-58f4-4fdb-b878-e33fa21db3ed"}
{"func_before":"static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)\n{\n\tint rlen, remain;\n\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tif (dp->pos < 0 || dp->pos >= dp->realSize) {\n\t\treturn 0;\n\t}\n\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain <= 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\trlen = remain;\n\t}\n\n\tif (dp->pos + rlen > dp->realSize) {\n\t\trlen = dp->realSize - dp->pos;\n\t}\n\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n\n\treturn rlen;\n}","target":0,"flaw_line_index":0,"hash":"72084c57-d647-43d3-a413-3196a7f4d9b9","idx":"62650ff1-c1c7-423e-8115-ed55258a1768"}
{"func_before":"int crxParamInit(CrxBandParam **param, uint64_t subbandMdatOffset,\n                 uint64_t subbandDataSize, uint32_t subbandWidth,\n                 uint32_t subbandHeight, int32_t supportsPartial,\n                 uint32_t roundedBitsMask, LibRaw_abstract_datastream *input)\n{\n  int32_t progrDataSize = supportsPartial ? 0 : sizeof(int32_t) * subbandWidth;\n  int32_t paramLength = 2 * subbandWidth + 4;\n  uint8_t *paramBuf = (uint8_t *)calloc(\n      1, sizeof(CrxBandParam) + sizeof(int32_t) * paramLength + progrDataSize);\n\n  if (!paramBuf)\n    return -1;\n\n  *param = (CrxBandParam *)paramBuf;\n\n  paramBuf += sizeof(CrxBandParam);\n\n  (*param)->paramData = (int32_t *)paramBuf;","target":1,"flaw_line_index":0,"hash":"4b0e2318-43c0-4e72-9d20-f84243a8fd67","idx":"08e28132-2b15-4185-8443-3744c8c86e66"}
{"func_before":"int crxParamInit(\n#ifdef LIBRAW_CR3_MEMPOOL\n\tlibraw_memmgr&  mm,\n#endif\t\n\tCrxBandParam **param, uint64_t subbandMdatOffset,\n                 uint64_t subbandDataSize, uint32_t subbandWidth,\n                 uint32_t subbandHeight, int32_t supportsPartial,\n                 uint32_t roundedBitsMask, LibRaw_abstract_datastream *input)\n{\n  int32_t progrDataSize = supportsPartial ? 0 : sizeof(int32_t) * subbandWidth;\n  int32_t paramLength = 2 * subbandWidth + 4;\n  uint8_t *paramBuf = (uint8_t *)\n#ifdef LIBRAW_CR3_MEMPOOL\n\t  mm.\n#endif\n\t  calloc(\n      1, sizeof(CrxBandParam) + sizeof(int32_t) * paramLength + progrDataSize);\n\n  if (!paramBuf)\n    return -1;\n\n  *param = (CrxBandParam *)paramBuf;\n\n  paramBuf += sizeof(CrxBandParam);\n\n  (*param)->paramData = (int32_t *)paramBuf;","target":0,"flaw_line_index":0,"hash":"d3a2a7ae-9064-4d2b-892c-5422703c0158","idx":"6da65afd-9014-451d-9d7e-e2fa51b8a58a"}
{"func_before":"HexInStream::HexInStream(InStream& is, int bufSize_)\n: bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_LEN), offset(0), in_stream(is)\n{\n  ptr = end = start = new U8[bufSize];\n}","target":1,"flaw_line_index":0,"hash":"6019bedc-de4e-4388-9e85-bd707a9f538c","idx":"1a62f29b-4d6b-4150-9b4e-3daffae20642"}
{"func_before":"HexInStream::HexInStream(InStream& is, size_t bufSize_)\n: bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_LEN), offset(0), in_stream(is)\n{\n  ptr = end = start = new U8[bufSize];\n}","target":0,"flaw_line_index":0,"hash":"474c99e4-2161-4985-8c45-7e307101002f","idx":"6db74c3b-25e3-4023-98fe-b99840fe10c3"}
{"func_before":"\t    case '_':\n\t      us[j++] = '_';\n\t      break;\n\t    default:\n\t      us[j++] = '_';\n\t      i--;\n\t      break;\n\t    }\n\t}\n      else\n\tus[j++] = caprtl_to_unicode[(int) s[i]];\n    }\n\n  return j;\n}","target":1,"flaw_line_index":0,"hash":"e2f2182b-72f0-4076-a7a0-7c937a72a1dd","idx":"7090b668-7cd6-46eb-86e5-c968cebe0720"}
{"func_before":"\t    case '_':\n\t      us[j++] = '_';\n\t      break;\n\t    default:\n\t      us[j++] = '_';\n\t      i--;\n\t      break;\n\t    }\n\t}\n      else\n      {\n        if ((int)s[i] < 0)\n          us[j++] = '?';\n        else\n          us[j++] = caprtl_to_unicode[(int) s[i]];\n      }\n    }\n\n  return j;\n}","target":0,"flaw_line_index":0,"hash":"cb74d1fa-8523-45cf-b196-c65e3f4540c7","idx":"76a0cfe7-8562-4fa4-9c9e-441cd7e340dc"}
{"func_before":"      printf(\"%s\\n\", *argv);\n      if ((chm = chmd->open(chmd, *argv))) {\n\n\t\/* build an ordered list of files for maximum extraction speed *\/\n\tfor (numf=0, file=chm->files; file; file = file->next) numf++;\n\tif ((f = (struct mschmd_file **) calloc(numf, sizeof(struct mschmd_file *)))) {\n\t  for (i=0, file=chm->files; file; file = file->next) f[i++] = file;\n\t  qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);\n\n\t  for (i = 0; i < numf; i++) {\n\t    char *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0);\n\t    printf(\"Extracting %s\\n\", outname);\n\t    ensure_filepath(outname);\n\t    if (chmd->extract(chmd, f[i], outname)) {\n\t      printf(\"%s: extract error on \\\"%s\\\": %s\\n\",\n\t\t     *argv, f[i]->filename, ERROR(chmd));\n\t    }\n\t    free(outname);\n\t  }\n\t  free(f);\n\t}","target":1,"flaw_line_index":0,"hash":"8f40a57a-ae12-46b4-91bf-950942a4010b","idx":"f3928433-a8aa-4ac1-b3e1-cb42f388a4c1"}
{"func_before":"      printf(\"%s\\n\", *argv);\n      if ((chm = chmd->open(chmd, *argv))) {\n\n\t\/* build an ordered list of files for maximum extraction speed *\/\n\tfor (numf=0, file=chm->files; file; file = file->next) numf++;\n\tif ((f = (struct mschmd_file **) calloc(numf, sizeof(struct mschmd_file *)))) {\n\t  for (i=0, file=chm->files; file; file = file->next) f[i++] = file;\n\t  qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);\n\n\t  for (i = 0; i < numf; i++) {\n\t    char *outname = create_output_name(f[i]->filename);\n\t    printf(\"Extracting %s\\n\", outname);\n\t    ensure_filepath(outname);\n\t    if (chmd->extract(chmd, f[i], outname)) {\n\t      printf(\"%s: extract error on \\\"%s\\\": %s\\n\",\n\t\t     *argv, f[i]->filename, ERROR(chmd));\n\t    }\n\t    free(outname);\n\t  }\n\t  free(f);\n\t}","target":0,"flaw_line_index":0,"hash":"28286cd7-cc43-4008-8bd3-7765a7274c69","idx":"69b4d53d-6c4b-4d45-9ad6-551546b02740"}
{"func_before":"    size_t count,\n    int flags,\n    const struct oe_sockaddr* dest_addr,\n    oe_socklen_t addrlen)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    if (!sock || (count && !buf))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_sendto_ocall(\n            &ret,\n            sock->host_fd,\n            buf,\n            count,\n            flags,\n            (struct oe_sockaddr*)dest_addr,\n            addrlen) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}","target":1,"flaw_line_index":0,"hash":"a21b8d85-507e-46d1-9074-7de2d747adef","idx":"56840501-909d-480c-9b60-b7b05c420c4e"}
{"func_before":"    size_t count,\n    int flags,\n    const struct oe_sockaddr* dest_addr,\n    oe_socklen_t addrlen)\n{\n    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    \/*\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https:\/\/pubs.opengroup.org\/onlinepubs\/9699919799\/functions\/sendto.html\n     * for more detail.\n     *\/\n    if (!sock || (count && !buf) || count > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_sendto_ocall(\n            &ret,\n            sock->host_fd,\n            buf,\n            count,\n            flags,\n            (struct oe_sockaddr*)dest_addr,\n            addrlen) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    \/*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The return value should not exceed count.\n     *\/\n    if (ret > (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}","target":0,"flaw_line_index":0,"hash":"df0be57c-b6d7-4555-9f4d-260c421f2c2f","idx":"0dab483f-9640-4bff-bfd8-f85df3a2e1d8"}
{"func_before":"\n\t\tdefault:\n\t\t\tif (hint)\n\t\t\t\tbreak;\n\n\t\t\tresult = L2CAP_CONF_UNKNOWN;\n\t\t\t*((u8 *) ptr++) = type;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (result == L2CAP_CONF_SUCCESS) {\n\t\t\/* Configure output options and let the other side know\n\t\t * which ones we don't like. *\/\n\n\t\tif (rfc.mode == L2CAP_MODE_BASIC) {\n\t\t\tif (mtu < pi->omtu)\n\t\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\t\telse {\n\t\t\t\tpi->omtu = mtu;\n\t\t\t\tpi->conf_state |= L2CAP_CONF_OUTPUT_DONE;\n\t\t\t}\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);\n\t\t} else {\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\tmemset(&rfc, 0, sizeof(rfc));\n\t\t\trfc.mode = L2CAP_MODE_BASIC;\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\t\t}\n\t}\n\n\trsp->scid   = cpu_to_le16(pi->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(0x0000);\n\n\treturn ptr - data;\n}","target":1,"flaw_line_index":0,"hash":"18fa3dd2-ef84-4526-bf22-7b809c07467f","idx":"5e7685b0-123a-45b0-9989-b977fcf13e45"}
{"func_before":"\t\tdefault:\n\t\t\tif (hint)\n\t\t\t\tbreak;\n\n\t\t\tresult = L2CAP_CONF_UNKNOWN;\n\t\t\t*((u8 *) ptr++) = type;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pi->num_conf_rsp || pi->num_conf_req)\n\t\tgoto done;\n\n\tswitch (pi->mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tpi->conf_state |= L2CAP_CONF_STATE2_DEVICE;\n\t\tif (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask))\n\t\t\treturn -ECONNREFUSED;\n\t\tbreak;\n\tdefault:\n\t\tpi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);\n\t\tbreak;\n\t}\n\ndone:\n\tif (pi->mode != rfc.mode) {\n\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\trfc.mode = pi->mode;\n\n\t\tif (pi->num_conf_rsp == 1)\n\t\t\treturn -ECONNREFUSED;\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\t}\n\n\n\tif (result == L2CAP_CONF_SUCCESS) {\n\t\t\/* Configure output options and let the other side know\n\t\t * which ones we don't like. *\/\n\n\t\tif (mtu < L2CAP_DEFAULT_MIN_MTU)\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\telse {\n\t\t\tpi->omtu = mtu;\n\t\t\tpi->conf_state |= L2CAP_CONF_MTU_DONE;\n\t\t}\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);\n\n\t\tswitch (rfc.mode) {\n\t\tcase L2CAP_MODE_BASIC:\n\t\t\tpi->fcs = L2CAP_FCS_NONE;\n\t\t\tpi->conf_state |= L2CAP_CONF_MODE_DONE;\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_ERTM:\n\t\t\tpi->remote_tx_win = rfc.txwin_size;\n\t\t\tpi->remote_max_tx = rfc.max_transmit;\n\t\t\tpi->max_pdu_size = rfc.max_pdu_size;\n\n\t\t\trfc.retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;\n\t\t\trfc.monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;\n\n\t\t\tpi->conf_state |= L2CAP_CONF_MODE_DONE;\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tpi->remote_tx_win = rfc.txwin_size;\n\t\t\tpi->max_pdu_size = rfc.max_pdu_size;\n\n\t\t\tpi->conf_state |= L2CAP_CONF_MODE_DONE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\tmemset(&rfc, 0, sizeof(rfc));\n\t\t\trfc.mode = pi->mode;\n\t\t}\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\n\t\tif (result == L2CAP_CONF_SUCCESS)\n\t\t\tpi->conf_state |= L2CAP_CONF_OUTPUT_DONE;\n\t}\n\trsp->scid   = cpu_to_le16(pi->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(0x0000);\n\n\treturn ptr - data;\n}","target":0,"flaw_line_index":0,"hash":"c1cc6f8b-4113-40a8-9a80-96102bf86a8d","idx":"19c95fb1-3c42-4649-82c0-c3e3423f97a7"}
{"func_before":"\t\tut8 *buf = calloc (section->size, 1);\n\t\tif (!buf) {\n\t\t\tbreak;\n\t\t}\n\t\tif (r_buf_read_at (obj->cache_buf, section->paddr + paddr, buf, section->size) < section->size) {\n\t\t\tfree (buf);\n\t\t\tbreak;\n\t\t}\n\t\tint j;\n\t\tint count = 0;\n\t\tfor (j = 0; j < section->size; j += 8) {\n\t\t\tut64 addr64 = K_RPTR (buf + j);\n\t\t\tut64 paddr64 = section->paddr + paddr + j;\n\t\t\tif (mode == R_K_CONSTRUCTOR_TO_ENTRY) {\n\t\t\t\tRBinAddr *ba = newEntry (paddr64, addr64, type);\n\t\t\t\tr_list_append (ret, ba);\n\t\t\t} else if (mode == R_K_CONSTRUCTOR_TO_SYMBOL) {\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tif (!sym) {\n\t\t\t\t\tbreak;\n\t\t\t\t}","target":1,"flaw_line_index":0,"hash":"5243ba1a-9790-4848-b742-2ee6cd2e209a","idx":"4f1c36a1-3629-40ab-b27a-040770ffe692"}
{"func_before":"\t\tut8 *buf = calloc (section->size, 1);\n\t\tif (!buf) {\n\t\t\tbreak;\n\t\t}\n\t\tif (r_buf_read_at (obj->cache_buf, section->paddr + paddr, buf, section->size) < section->size) {\n\t\t\tfree (buf);\n\t\t\tbreak;\n\t\t}\n\t\tint j;\n\t\tint count = 0;\n\t\tfor (j = 0; j + 7 < section->size; j += 8) {\n\t\t\tut64 addr64 = K_RPTR (buf + j);\n\t\t\tut64 paddr64 = section->paddr + paddr + j;\n\t\t\tif (mode == R_K_CONSTRUCTOR_TO_ENTRY) {\n\t\t\t\tRBinAddr *ba = newEntry (paddr64, addr64, type);\n\t\t\t\tr_list_append (ret, ba);\n\t\t\t} else if (mode == R_K_CONSTRUCTOR_TO_SYMBOL) {\n\t\t\t\tRBinSymbol *sym = R_NEW0 (RBinSymbol);\n\t\t\t\tif (!sym) {\n\t\t\t\t\tbreak;\n\t\t\t\t}","target":0,"flaw_line_index":0,"hash":"6f91b1bb-f46a-4b95-b26e-d1669a8f5f57","idx":"2cfe0a0f-beaf-4040-988d-fc3e3ee97150"}
{"func_before":"{\n\tstruct thread_struct *prev = &prev_p->thread;\n\tstruct thread_struct *next = &next_p->thread;\n\tint cpu = smp_processor_id();\n\tstruct tss_struct *tss = &per_cpu(init_tss, cpu);\n\tunsigned fsindex, gsindex;\n\tfpu_switch_t fpu;\n\n\tfpu = switch_fpu_prepare(prev_p, next_p, cpu);\n\n\t\/*\n\t * Reload esp0, LDT and the page table pointer:\n\t *\/\n\tload_sp0(tss, next);\n\n\t\/*\n\t * Switch DS and ES.\n\t * This won't pick up thread selector changes, but I guess that is ok.\n\t *\/\n\tsavesegment(es, prev->es);\n\tif (unlikely(next->es | prev->es))\n\t\tloadsegment(es, next->es);\n\n\tsavesegment(ds, prev->ds);\n\tif (unlikely(next->ds | prev->ds))\n\t\tloadsegment(ds, next->ds);\n\n\n\t\/* We must save %fs and %gs before load_TLS() because\n\t * %fs and %gs may be cleared by load_TLS().\n\t *\n\t * (e.g. xen_load_tls())\n\t *\/\n\tsavesegment(fs, fsindex);\n\tsavesegment(gs, gsindex);\n\n\tload_TLS(next, cpu);\n\n\t\/*\n\t * Leave lazy mode, flushing any hypercalls made here.\n\t * This must be done before restoring TLS segments so\n\t * the GDT and LDT are properly updated, and must be\n\t * done before math_state_restore, so the TS bit is up\n\t * to date.\n\t *\/\n\tarch_end_context_switch(next_p);\n\n\t\/*\n\t * Switch FS and GS.\n\t *\n\t * Segment register != 0 always requires a reload.  Also\n\t * reload when it has changed.  When prev process used 64bit\n\t * base always reload to avoid an information leak.\n\t *\/\n\tif (unlikely(fsindex | next->fsindex | prev->fs)) {\n\t\tloadsegment(fs, next->fsindex);\n\t\t\/*\n\t\t * Check if the user used a selector != 0; if yes\n\t\t *  clear 64bit base, since overloaded base is always\n\t\t *  mapped to the Null selector\n\t\t *\/\n\t\tif (fsindex)\n\t\t\tprev->fs = 0;\n\t}\n\t\/* when next process has a 64bit base use it *\/\n\tif (next->fs)\n\t\twrmsrl(MSR_FS_BASE, next->fs);\n\tprev->fsindex = fsindex;\n\n\tif (unlikely(gsindex | next->gsindex | prev->gs)) {\n\t\tload_gs_index(next->gsindex);\n\t\tif (gsindex)\n\t\t\tprev->gs = 0;\n\t}\n\tif (next->gs)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, next->gs);\n\tprev->gsindex = gsindex;\n\n\tswitch_fpu_finish(next_p, fpu);\n\n\t\/*","target":1,"flaw_line_index":0,"hash":"a29e2265-ef19-4680-96b4-b043ed5d99cb","idx":"60b6f3e6-826d-4540-b5f7-8c283c9e8a08"}
{"func_before":"{\n\tstruct thread_struct *prev = &prev_p->thread;\n\tstruct thread_struct *next = &next_p->thread;\n\tint cpu = smp_processor_id();\n\tstruct tss_struct *tss = &per_cpu(init_tss, cpu);\n\tunsigned fsindex, gsindex;\n\tfpu_switch_t fpu;\n\n\tfpu = switch_fpu_prepare(prev_p, next_p, cpu);\n\n\t\/* Reload esp0 and ss1. *\/\n\tload_sp0(tss, next);\n\n\t\/* We must save %fs and %gs before load_TLS() because\n\t * %fs and %gs may be cleared by load_TLS().\n\t *\n\t * (e.g. xen_load_tls())\n\t *\/\n\tsavesegment(fs, fsindex);\n\tsavesegment(gs, gsindex);\n\n\t\/*\n\t * Load TLS before restoring any segments so that segment loads\n\t * reference the correct GDT entries.\n\t *\/\n\tload_TLS(next, cpu);\n\n\t\/*\n\t * Leave lazy mode, flushing any hypercalls made here.  This\n\t * must be done after loading TLS entries in the GDT but before\n\t * loading segments that might reference them, and and it must\n\t * be done before math_state_restore, so the TS bit is up to\n\t * date.\n\t *\/\n\tarch_end_context_switch(next_p);\n\n\t\/* Switch DS and ES.\n\t *\n\t * Reading them only returns the selectors, but writing them (if\n\t * nonzero) loads the full descriptor from the GDT or LDT.  The\n\t * LDT for next is loaded in switch_mm, and the GDT is loaded\n\t * above.\n\t *\n\t * We therefore need to write new values to the segment\n\t * registers on every context switch unless both the new and old\n\t * values are zero.\n\t *\n\t * Note that we don't need to do anything for CS and SS, as\n\t * those are saved and restored as part of pt_regs.\n\t *\/\n\tsavesegment(es, prev->es);\n\tif (unlikely(next->es | prev->es))\n\t\tloadsegment(es, next->es);\n\n\tsavesegment(ds, prev->ds);\n\tif (unlikely(next->ds | prev->ds))\n\t\tloadsegment(ds, next->ds);\n\n\t\/*\n\t * Switch FS and GS.\n\t *\n\t * These are even more complicated than FS and GS: they have\n\t * 64-bit bases are that controlled by arch_prctl.  Those bases\n\t * only differ from the values in the GDT or LDT if the selector\n\t * is 0.\n\t *\n\t * Loading the segment register resets the hidden base part of\n\t * the register to 0 or the value from the GDT \/ LDT.  If the\n\t * next base address zero, writing 0 to the segment register is\n\t * much faster than using wrmsr to explicitly zero the base.\n\t *\n\t * The thread_struct.fs and thread_struct.gs values are 0\n\t * if the fs and gs bases respectively are not overridden\n\t * from the values implied by fsindex and gsindex.  They\n\t * are nonzero, and store the nonzero base addresses, if\n\t * the bases are overridden.\n\t *\n\t * (fs != 0 && fsindex != 0) || (gs != 0 && gsindex != 0) should\n\t * be impossible.\n\t *\n\t * Therefore we need to reload the segment registers if either\n\t * the old or new selector is nonzero, and we need to override\n\t * the base address if next thread expects it to be overridden.\n\t *\n\t * This code is unnecessarily slow in the case where the old and\n\t * new indexes are zero and the new base is nonzero -- it will\n\t * unnecessarily write 0 to the selector before writing the new\n\t * base address.\n\t *\n\t * Note: This all depends on arch_prctl being the only way that\n\t * user code can override the segment base.  Once wrfsbase and\n\t * wrgsbase are enabled, most of this code will need to change.\n\t *\/\n\tif (unlikely(fsindex | next->fsindex | prev->fs)) {\n\t\tloadsegment(fs, next->fsindex);\n\n\t\t\/*\n\t\t * If user code wrote a nonzero value to FS, then it also\n\t\t * cleared the overridden base address.\n\t\t *\n\t\t * XXX: if user code wrote 0 to FS and cleared the base\n\t\t * address itself, we won't notice and we'll incorrectly\n\t\t * restore the prior base address next time we reschdule\n\t\t * the process.\n\t\t *\/\n\t\tif (fsindex)\n\t\t\tprev->fs = 0;\n\t}\n\tif (next->fs)\n\t\twrmsrl(MSR_FS_BASE, next->fs);\n\tprev->fsindex = fsindex;\n\n\tif (unlikely(gsindex | next->gsindex | prev->gs)) {\n\t\tload_gs_index(next->gsindex);\n\n\t\t\/* This works (and fails) the same way as fsindex above. *\/\n\t\tif (gsindex)\n\t\t\tprev->gs = 0;\n\t}\n\tif (next->gs)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, next->gs);\n\tprev->gsindex = gsindex;\n\n\tswitch_fpu_finish(next_p, fpu);\n\n\t\/*","target":0,"flaw_line_index":0,"hash":"4c951003-1627-46f7-a1b5-69e0150fe7c8","idx":"5bc15a82-391c-4a5b-a454-5e2f3b778d6f"}
{"func_before":"int TLSInStream::readTLS(U8* buf, int len, bool wait)\n{\n  int n;\n\n  n = in->check(1, 1, wait);\n  if (n == 0)\n    return 0;\n\n  n = gnutls_record_recv(session, (void *) buf, len);\n  if (n == GNUTLS_E_INTERRUPTED || n == GNUTLS_E_AGAIN)\n    return 0;\n\n  if (n < 0) throw TLSException(\"readTLS\", n);\n\n  return n;\n}","target":1,"flaw_line_index":0,"hash":"5da7a1ac-3ac1-44a7-9c8b-b981cec110ef","idx":"cfb882cf-ef71-413e-b8cf-78bf334d43e9"}
{"func_before":"size_t TLSInStream::readTLS(U8* buf, size_t len, bool wait)\n{\n  int n;\n\n  n = in->check(1, 1, wait);\n  if (n == 0)\n    return 0;\n\n  n = gnutls_record_recv(session, (void *) buf, len);\n  if (n == GNUTLS_E_INTERRUPTED || n == GNUTLS_E_AGAIN)\n    return 0;\n\n  if (n < 0) throw TLSException(\"readTLS\", n);\n\n  return n;\n}","target":0,"flaw_line_index":0,"hash":"c191f47a-d878-4032-89c6-6795bca62dfd","idx":"66602b2b-c42e-4090-ad1e-1d6c34b8342b"}
{"func_before":"static s16 swf_get_s16(SWFReader *read)\n{\n\ts16 val;\n\tu8 v1;\n\tv1 = swf_read_int(read, 8);\n\tval = swf_read_sint(read, 8);\n\tval = (val<<8)&0xFF00;\n\tval |= (v1&0xFF);\n\treturn val;\n}","target":1,"flaw_line_index":0,"hash":"ddaccb9a-5ae2-47e3-85cf-db164533d54e","idx":"be3dc88f-16fb-4646-970e-136a0c96bcd2"}
{"func_before":"static s16 swf_get_s16(SWFReader *read)\n{\n\treturn (s16) gf_bs_read_u16_le(read->bs);\n}","target":0,"flaw_line_index":0,"hash":"8c006f68-1546-44f5-adf0-8d1a3ebc8f89","idx":"73493d0e-2280-4d90-a4b7-970d1e9d5f3e"}
{"func_before":"      {\n         \/\/Decrypt the Base64-encoded string\n         error = base64Decode(token, osStrlen(token), token, &n);\n\n         \/\/Successful decoding?\n         if(!error)\n         {\n            \/\/Properly terminate the string\n            token[n] = '\\0';\n            \/\/Check whether a separator is present\n            separator = strchr(token, ':');\n\n            \/\/Separator found?\n            if(separator != NULL)\n            {\n               \/\/Split the line\n               *separator = '\\0';\n\n               \/\/Save user name\n               strSafeCopy(connection->request.auth.user,\n                  token, HTTP_SERVER_USERNAME_MAX_LEN);\n\n      \/\/Use the relevant authentication scheme\n      connection->request.auth.mode = HTTP_AUTH_MODE_DIGEST;\n      \/\/Get the first parameter\n      token = osStrtok_r(NULL, \",\", &p);\n\n      \/\/Parse the Authorization header field\n      while(token != NULL)\n      {\n         \/\/Check whether a separator is present\n         separator = strchr(token, '=');\n\n         \/\/Separator found?\n         if(separator != NULL)\n         {\n            \/\/Split the string\n            *separator = '\\0';\n\n            \/\/Get field name and value\n            name = strTrimWhitespace(token);\n            value = strTrimWhitespace(separator + 1);","target":1,"flaw_line_index":0,"hash":"1d40e2e5-c8e4-4966-8392-e82247395570","idx":"41a24254-4272-4835-891f-c6e430d07b26"}
{"func_before":"      {\n         \/\/Decrypt the Base64-encoded string\n         error = base64Decode(token, osStrlen(token), token, &n);\n\n         \/\/Successful decoding?\n         if(!error)\n         {\n            \/\/Properly terminate the string\n            token[n] = '\\0';\n            \/\/Check whether a separator is present\n            separator = osStrchr(token, ':');\n\n            \/\/Separator found?\n            if(separator != NULL)\n            {\n               \/\/Split the line\n               *separator = '\\0';\n\n               \/\/Save user name\n               strSafeCopy(connection->request.auth.user,\n                  token, HTTP_SERVER_USERNAME_MAX_LEN);\n\n      \/\/Use the relevant authentication scheme\n      connection->request.auth.mode = HTTP_AUTH_MODE_DIGEST;\n      \/\/Get the first parameter\n      token = osStrtok_r(NULL, \",\", &p);\n\n      \/\/Parse the Authorization header field\n      while(token != NULL)\n      {\n         \/\/Check whether a separator is present\n         separator = osStrchr(token, '=');\n\n         \/\/Separator found?\n         if(separator != NULL)\n         {\n            \/\/Split the string\n            *separator = '\\0';\n\n            \/\/Get field name and value\n            name = strTrimWhitespace(token);\n            value = strTrimWhitespace(separator + 1);","target":0,"flaw_line_index":0,"hash":"7ee70436-e380-4494-bd53-2cb4775e67dc","idx":"453a4dd3-e9d8-4131-a5a5-bcb2c7361e88"}
{"func_before":"        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);\n        if (!hashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \"bad DT_HASH %#x\", v_hsh);\n            throwCantPack(msg);\n        }\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket]; (void)chains;\n\n        unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        if (!nbucket\n        || (nbucket>>31) || (file_size\/sizeof(unsigned)) <= (2*nbucket)  \/\/ FIXME: weak\n        || ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2  \/\/ headers\n                + sizeof(*buckets)*nbucket  \/\/ buckets\n                + sizeof(*chains) *nbucket  \/\/ chains\n           ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \"bad DT_HASH nbucket=%#x  len=%#x\",\n                nbucket, (v_sym - v_hsh));\n            throwCantPack(msg);\n            throwCantPack(msg);\n        }\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;\n      \/\/unsigned     const *const gashend = &hasharr[n_bucket];  \/\/ minimum\n\n        upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);\n        if (!n_bucket || !n_bitmask\n        || (-1+ n_bitmask) & n_bitmask  \/\/ not a power of 2\n        || 8*sizeof(upx_uint64_t) <= gnu_shift  \/\/ shifted result always == 0\n        || (n_bucket>>30)  \/\/ fie on fuzzers\n        || (n_bitmask>>30)\n        || (file_size\/sizeof(unsigned)) <= ((sizeof(*bitmask)\/sizeof(unsigned))*n_bitmask + 2*n_bucket)  \/\/ FIXME: weak\n        \/\/ FIXME: next test does work for Android?\n        || ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4  \/\/ headers\n                + sizeof(*bitmask)*n_bitmask  \/\/ bitmask\n                + sizeof(*buckets)*n_bucket  \/\/ buckets\n                + sizeof(*hasharr)*n_bucket  \/\/ hasharr","target":1,"flaw_line_index":0,"hash":"9da99fff-8765-40e7-96cb-5c232eea81c2","idx":"5ef74fe2-f139-4f47-ba27-52ac7b976567"}
{"func_before":"        hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH);\n        if (!hashtab) {\n            char msg[40]; snprintf(msg, sizeof(msg),\n               \"bad DT_HASH %#x\", v_hsh);\n            throwCantPack(msg);\n        }\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket]; (void)chains;\n\n        unsigned const v_sym = !x_sym ? 0 : get_te32(&dynp0[-1+ x_sym].d_val);\n        if (!nbucket || !v_sym\n        || (nbucket>>31) || (file_size\/sizeof(unsigned)) <= (2*nbucket)  \/\/ FIXME: weak\n        || ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2  \/\/ headers\n                + sizeof(*buckets)*nbucket  \/\/ buckets\n                + sizeof(*chains) *nbucket  \/\/ chains\n           ))\n        ) {\n            char msg[90]; snprintf(msg, sizeof(msg),\n                \"bad DT_HASH nbucket=%#x  len=%#x\",\n                nbucket, (v_sym - v_hsh));\n            throwCantPack(msg);\n            throwCantPack(msg);\n        }\n        unsigned const n_bucket = get_te32(&gashtab[0]);\n        unsigned const n_bitmask = get_te32(&gashtab[2]);\n        unsigned const gnu_shift = get_te32(&gashtab[3]);\n        upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;\n      \/\/unsigned     const *const gashend = &hasharr[n_bucket];  \/\/ minimum\n\n        upx_uint64_t const v_sym = !x_sym ? 0 : get_te64(&dynp0[-1+ x_sym].d_val);\n        if (!n_bucket || !n_bitmask || !v_sym\n        || (-1+ n_bitmask) & n_bitmask  \/\/ not a power of 2\n        || 8*sizeof(upx_uint64_t) <= gnu_shift  \/\/ shifted result always == 0\n        || (n_bucket>>30)  \/\/ fie on fuzzers\n        || (n_bitmask>>30)\n        || (file_size\/sizeof(unsigned)) <= ((sizeof(*bitmask)\/sizeof(unsigned))*n_bitmask + 2*n_bucket)  \/\/ FIXME: weak\n        \/\/ FIXME: next test does work for Android?\n        || ((v_gsh < v_sym) && (v_sym - v_gsh) < (sizeof(unsigned)*4  \/\/ headers\n                + sizeof(*bitmask)*n_bitmask  \/\/ bitmask\n                + sizeof(*buckets)*n_bucket  \/\/ buckets\n                + sizeof(*hasharr)*n_bucket  \/\/ hasharr","target":0,"flaw_line_index":0,"hash":"71dbba3d-e001-4897-aa95-e87a8d39e4b4","idx":"eec7fb8c-0637-4747-b8be-a917fcb40411"}
{"func_before":"xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n\tint count, i;\n\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > XFS_ACL_MAX_ENTRIES)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {","target":1,"flaw_line_index":0,"hash":"ac6bc7b4-696c-4034-ae78-a7526ab6417d","idx":"348f2fbe-9aa5-4678-aeb3-fdc0a23c4af3"}
{"func_before":"xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n\tunsigned int count, i;\n\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > XFS_ACL_MAX_ENTRIES)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\n\tacl = posix_acl_alloc(count, GFP_KERNEL);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {","target":0,"flaw_line_index":0,"hash":"a0bea1c8-9345-4676-9878-4e877e9b7f5f","idx":"fcb894e0-ee5a-4b69-b86f-bc9b6dd22d43"}
{"func_before":"\n\t\/*\n\t * Log the unexpected fixups, and then pass them on to perf.\n\t *\n\t * We intentionally don't report the expected cases to perf as\n\t * otherwise the trapped I\/O case will skew the results too much\n\t * to be useful.\n\t *\/\n\tif (!expected) {\n\t\tunaligned_fixups_notify(current, instruction, regs);\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0,\n\t\t\t      regs, address);\n\t}\n\n\tret = -EFAULT;\n\tswitch (instruction&0xF000) {\n\tcase 0x0000:\n\t\tif (instruction==0x000B) {\n\t\t\t\/* rts *\/\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0)","target":1,"flaw_line_index":0,"hash":"0ce95792-ca85-42c8-9324-f9a4311ce3f0","idx":"524901a8-5d8e-4b52-b92c-63ef5e792e2d"}
{"func_before":"\n\t\/*\n\t * Log the unexpected fixups, and then pass them on to perf.\n\t *\n\t * We intentionally don't report the expected cases to perf as\n\t * otherwise the trapped I\/O case will skew the results too much\n\t * to be useful.\n\t *\/\n\tif (!expected) {\n\t\tunaligned_fixups_notify(current, instruction, regs);\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1,\n\t\t\t      regs, address);\n\t}\n\n\tret = -EFAULT;\n\tswitch (instruction&0xF000) {\n\tcase 0x0000:\n\t\tif (instruction==0x000B) {\n\t\t\t\/* rts *\/\n\t\t\tret = handle_delayslot(regs, instruction, ma);\n\t\t\tif (ret==0)","target":0,"flaw_line_index":0,"hash":"c767f392-c8d4-4972-92f0-bdceaee58687","idx":"1d356a8c-7334-4e5e-b766-38a4e10ca232"}
{"func_before":"int DSA_verify(int type, const unsigned char *dgst, int dgst_len,\n\t     const unsigned char *sigbuf, int siglen, DSA *dsa)\n\t{\n\tDSA_SIG *s;\n\tint ret=-1;\n\n\ts = DSA_SIG_new();\n\tif (s == NULL) return(ret);\n\tif (d2i_DSA_SIG(&s,&sigbuf,siglen) == NULL) goto err;\n\tret=DSA_do_verify(dgst,dgst_len,s,dsa);\nerr:\n\tDSA_SIG_free(s);\n\treturn(ret);\n\t}","target":1,"flaw_line_index":0,"hash":"23a730fc-ba1d-419b-bfda-fb75b3c6fca1","idx":"d7e9f936-f88d-4802-9c50-3ee910fc131f"}
{"func_before":"int DSA_verify(int type, const unsigned char *dgst, int dgst_len,\n\t     const unsigned char *sigbuf, int siglen, DSA *dsa)\n\t{\n\tDSA_SIG *s;\n\tconst unsigned char *p = sigbuf;\n\tunsigned char *der = NULL;\n\tint derlen = -1;\n\tint ret=-1;\n\n\ts = DSA_SIG_new();\n\tif (s == NULL) return(ret);\n\tif (d2i_DSA_SIG(&s,&p,siglen) == NULL) goto err;\n\t\/* Ensure signature uses DER and doesn't have trailing garbage *\/\n\tderlen = i2d_DSA_SIG(s, &der);\n\tif (derlen != siglen || memcmp(sigbuf, der, derlen))\n\t\tgoto err;\n\tret=DSA_do_verify(dgst,dgst_len,s,dsa);\nerr:\n\tif (derlen > 0)\n\t\t{\n\t\tOPENSSL_cleanse(der, derlen);\n\t\tOPENSSL_free(der);\n\t\t}\n\tDSA_SIG_free(s);\n\treturn(ret);\n\t}","target":0,"flaw_line_index":0,"hash":"9c2005cb-f0b1-4d8e-9cc8-eb87e791f943","idx":"afa9e674-03cd-41e3-95ee-f65db279f3c6"}
{"func_before":"getlogin_r (name, name_len)\n     char *name;\n     size_t name_len;\n{\n  char tty_pathname[2 + 2 * NAME_MAX];\n  char *real_tty_path = tty_pathname;\n  int result = 0;\n  struct utmp *ut, line, buffer;\n\n  {\n    int d = __open (\"\/dev\/tty\", 0);\n    if (d < 0)\n      return errno;\n\n    result = __ttyname_r (d, real_tty_path, sizeof (tty_pathname));\n    (void) __close (d);\n\n    if (result != 0)\n      {\n\t__set_errno (result);\n\treturn result;\n      }\n  }\n\n  real_tty_path += 5;\t\t\/* Remove \"\/dev\/\".  *\/\n\n  __setutent ();\n  strncpy (line.ut_line, real_tty_path, sizeof line.ut_line);\n  if (__getutline_r (&line, &buffer, &ut) < 0)\n    {\n      if (errno == ESRCH)\n\t\/* The caller expects ENOENT if nothing is found.  *\/\n\tresult = ENOENT;\n      else\n\tresult = errno;\n    }\n  else\n    {\n      size_t needed = strlen (ut->ut_line) + 1;\n\n      if (needed < name_len)\n\t{\n\t  __set_errno (ERANGE);\n\t  result = ERANGE;\n\t}\n      else\n\t{\n\t  memcpy (name, ut->ut_line, needed);\n\t  result = 0;\n\t}\n    }\n  __endutent ();\n\n  return result;\n}","target":1,"flaw_line_index":0,"hash":"c7b2f830-dd2e-4174-929b-a4fc0898b84e","idx":"5ef6bff5-7305-454e-8dd4-5f9e44efaa72"}
{"func_before":"getlogin_r (name, name_len)\n     char *name;\n     size_t name_len;\n{\n  char tty_pathname[2 + 2 * NAME_MAX];\n  char *real_tty_path = tty_pathname;\n  int result = 0;\n  struct utmp *ut, line, buffer;\n\n  \/* Get name of tty connected to fd 0.  Return if not a tty or\n     if fd 0 isn't open.  Note that a lot of documentation says that\n     getlogin() is based on the controlling terminal---what they\n     really mean is \"the terminal connected to standard input\".  The\n     getlogin() implementation of DEC Unix, SunOS, Solaris, HP-UX all\n     return NULL if fd 0 has been closed, so this is the compatible\n     thing to do.  Note that ttyname(open(\"\/dev\/tty\")) on those\n     systems returns \/dev\/tty, so that is not a possible solution for\n     getlogin().  *\/\n\n  result = __ttyname_r (0, real_tty_path, sizeof (tty_pathname));\n  \n  if (result != 0)\n    return result;\n\n  real_tty_path += 5;\t\t\/* Remove \"\/dev\/\".  *\/\n\n  __setutent ();\n  strncpy (line.ut_line, real_tty_path, sizeof line.ut_line);\n  if (__getutline_r (&line, &buffer, &ut) < 0)\n    {\n      if (errno == ESRCH)\n\t\/* The caller expects ENOENT if nothing is found.  *\/\n\tresult = ENOENT;\n      else\n\tresult = errno;\n    }\n  else\n    {\n      size_t needed = strlen (ut->ut_user) + 1;\n\n      if (needed > name_len)\n\t{\n\t  __set_errno (ERANGE);\n\t  result = ERANGE;\n\t}\n      else\n\t{\n\t  memcpy (name, ut->ut_user, needed);\n\t  result = 0;\n\t}\n    }\n  __endutent ();\n\n  return result;\n}","target":0,"flaw_line_index":0,"hash":"b29ae5cb-b344-4d0f-8537-cd0e81fdfbe9","idx":"1029f2a2-49cc-4f49-91d9-ff055facecae"}
{"func_before":"static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {\n\tD eprintf (\"Dragons at 0x%x\\n\", off);\n\tut64 size = r_buf_size (buf);\n\tif (off >= size) {\n\t\treturn NULL;\n\t}\n\tsize -= off;\n\tif (!size) {\n\t\treturn NULL;\n\t}\n\tut8 *b = malloc (size);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tint available = r_buf_read_at (buf, off, b, size);\n\tif (available != size) {\n\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\treturn NULL;","target":1,"flaw_line_index":0,"hash":"97608bd3-73b9-434a-83e3-6eb1b64bd200","idx":"2375d7fc-6e7c-4c0e-869a-078936718146"}
{"func_before":"static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {\n\tD eprintf (\"Dragons at 0x%x\\n\", off);\n\tst64 size = r_buf_size (buf);\n\tif (off >= size) {\n\t\treturn NULL;\n\t}\n\tsize -= off;\n\tif (!size) {\n\t\treturn NULL;\n\t}\n\tif (size < 32) {\n\t\treturn NULL;\n\t}\n\tut8 *b = malloc (size);\n\tif (!b) {\n\t\treturn NULL;\n\t}\n\tint available = r_buf_read_at (buf, off, b, size);\n\tif (available != size) {\n\t\teprintf (\"Warning: r_buf_read_at failed\\n\");\n\t\treturn NULL;","target":0,"flaw_line_index":0,"hash":"1bad42b4-7458-4bed-996f-d22a425e33a9","idx":"db6942f9-4e1f-4ad9-90fe-f9dc41597a49"}
{"func_before":"\tireq->snd_wscale\t= tcp_opt.snd_wscale;\n\tireq->sack_ok\t\t= tcp_opt.sack_ok;\n\tireq->wscale_ok\t\t= tcp_opt.wscale_ok;\n\tireq->tstamp_ok\t\t= tcp_opt.saw_tstamp;\n\treq->ts_recent\t\t= tcp_opt.saw_tstamp ? tcp_opt.rcv_tsval : 0;\n\n\t\/* We throwed the options of the initial SYN away, so we hope\n\t * the ACK carries the same options again (see RFC1122 4.2.3.8)\n\t *\/\n\tif (opt && opt->optlen) {\n\t\tint opt_size = sizeof(struct ip_options) + opt->optlen;\n\n\t\tireq->opt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (ireq->opt != NULL && ip_options_echo(ireq->opt, skb)) {\n\t\t\tkfree(ireq->opt);\n\t\t\tireq->opt = NULL;\n\t\t}\n\t}\n\n\tif (security_inet_conn_request(sk, skb, req)) {\n\t\treqsk_free(req);\n\t\tgoto out;\n\t}\n","target":1,"flaw_line_index":0,"hash":"1bb74d80-4608-4a18-afa2-c14e3dee32a3","idx":"226e33ae-3e96-4037-bb62-771e8ada0af8"}
{"func_before":"\tireq->snd_wscale\t= tcp_opt.snd_wscale;\n\tireq->sack_ok\t\t= tcp_opt.sack_ok;\n\tireq->wscale_ok\t\t= tcp_opt.wscale_ok;\n\tireq->tstamp_ok\t\t= tcp_opt.saw_tstamp;\n\treq->ts_recent\t\t= tcp_opt.saw_tstamp ? tcp_opt.rcv_tsval : 0;\n\n\t\/* We throwed the options of the initial SYN away, so we hope\n\t * the ACK carries the same options again (see RFC1122 4.2.3.8)\n\t *\/\n\tif (opt && opt->optlen) {\n\t\tint opt_size = sizeof(struct ip_options_rcu) + opt->optlen;\n\n\t\tireq->opt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (ireq->opt != NULL && ip_options_echo(&ireq->opt->opt, skb)) {\n\t\t\tkfree(ireq->opt);\n\t\t\tireq->opt = NULL;\n\t\t}\n\t}\n\n\tif (security_inet_conn_request(sk, skb, req)) {\n\t\treqsk_free(req);\n\t\tgoto out;\n\t}\n","target":0,"flaw_line_index":0,"hash":"ebb4ce6a-35c8-4140-ab4d-fea62e4dc662","idx":"4fa19986-ed28-4173-a45c-da7fe366fe12"}
{"func_before":"mrb_proc_init_copy(mrb_state *mrb, mrb_value self)\n{\n  mrb_value proc = mrb_get_arg1(mrb);\n\n  if (!mrb_proc_p(proc)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"not a proc\");\n  }\n  mrb_proc_copy(mrb_proc_ptr(self), mrb_proc_ptr(proc));\n  return self;\n}","target":1,"flaw_line_index":0,"hash":"d3a4a73e-6c96-4c88-bab5-987902a1c8a5","idx":"52507c4a-cbf7-47b5-8baf-d430b14bcbf5"}
{"func_before":"mrb_proc_init_copy(mrb_state *mrb, mrb_value self)\n{\n  mrb_value proc = mrb_get_arg1(mrb);\n\n  if (!mrb_proc_p(proc)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"not a proc\");\n  }\n  mrb_proc_copy(mrb, mrb_proc_ptr(self), mrb_proc_ptr(proc));\n  return self;\n}","target":0,"flaw_line_index":0,"hash":"d74215c8-a417-415f-a04f-1031ad18a8e7","idx":"bc604c9a-1e5e-446d-af40-d79a00e78ccf"}
{"func_before":"           this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        dialog.setCheckBox(new QCheckBox(tr(\"Do not show this anymore.\", \"Automatic upgrade check dialog\")));\n        Settings.setCheckUpgradeAutomatic(dialog.exec() == QMessageBox::Yes);\n        if (dialog.checkBox()->isChecked())\n            Settings.setAskUpgradeAutomatic(false);\n    }\n    showStatusMessage(\"Checking for upgrade...\");\n    m_network.get(QNetworkRequest(QUrl(\"http:\/\/check.shotcut.org\/version.json\")));\n}","target":1,"flaw_line_index":0,"hash":"382f4614-dfe8-43da-a5bd-e70b8c8ebb3f","idx":"f31a4cbb-1ccf-470e-945e-9440262f501e"}
{"func_before":"           this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        dialog.setCheckBox(new QCheckBox(tr(\"Do not show this anymore.\", \"Automatic upgrade check dialog\")));\n        Settings.setCheckUpgradeAutomatic(dialog.exec() == QMessageBox::Yes);\n        if (dialog.checkBox()->isChecked())\n            Settings.setAskUpgradeAutomatic(false);\n    }\n    showStatusMessage(\"Checking for upgrade...\");\n    m_network.get(QNetworkRequest(QUrl(\"https:\/\/check.shotcut.org\/version.json\")));\n}","target":0,"flaw_line_index":0,"hash":"06d96f5b-5d12-40fa-83ec-c9594d0b6610","idx":"d503b266-8935-4b64-a645-f585af58c4d7"}
{"func_before":"            goto end;\n        }\n    } else {\n        sixel_allocator_ref(allocator);\n    }\n\n    if (ncolors < 0) {\n        ncolors = 256;\n        quality_mode = SIXEL_QUALITY_HIGHCOLOR;\n    } else {\n        if (ncolors > SIXEL_PALETTE_MAX) {\n            ncolors = 256;\n        } else if (ncolors < 2) {\n            ncolors = 2;\n        }\n        quality_mode = SIXEL_QUALITY_LOW;\n    }\n    headsize = sizeof(sixel_dither_t);\n    datasize = (size_t)(ncolors * 3);\n    wholesize = headsize + datasize;\n\n    *ppdither = (sixel_dither_t *)sixel_allocator_malloc(allocator, wholesize);\n    if (*ppdither == NULL) {\n        sixel_allocator_unref(allocator);","target":1,"flaw_line_index":0,"hash":"c26f99c6-96da-499c-82cc-55b5f38261d4","idx":"5abfaef1-cef5-4c88-8fdb-f7f2a55657a9"}
{"func_before":"        }\n    } else {\n        sixel_allocator_ref(allocator);\n    }\n\n    if (ncolors < 0) {\n        ncolors = 256;\n        quality_mode = SIXEL_QUALITY_HIGHCOLOR;\n    } else {\n        if (ncolors > SIXEL_PALETTE_MAX) {\n            status = SIXEL_BAD_INPUT;\n            ncolors = 256;\n        } else if (ncolors < 1) {\n            status = SIXEL_BAD_INPUT;\n            sixel_helper_set_additional_message(\n                \"sixel_dither_new: palette colors must be more than 0\");\n            goto end;\n        }\n        quality_mode = SIXEL_QUALITY_LOW;\n    }\n    headsize = sizeof(sixel_dither_t);\n    datasize = (size_t)(ncolors * 3);\n    wholesize = headsize + datasize;\n\n    *ppdither = (sixel_dither_t *)sixel_allocator_malloc(allocator, wholesize);\n    if (*ppdither == NULL) {\n        sixel_allocator_unref(allocator);","target":0,"flaw_line_index":0,"hash":"55a25d63-fb02-407d-8967-c8f5ce8d53c3","idx":"1bd570e8-5cd5-4638-a76d-9ac980d23b0a"}
{"func_before":"static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n}","target":1,"flaw_line_index":0,"hash":"afb2b253-563c-45a1-bcb1-65a4433757d3","idx":"0e450fd2-7e08-4cb2-af98-de0ad6da4861"}
{"func_before":"static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n}","target":0,"flaw_line_index":0,"hash":"d97412d3-ee6f-4a75-b2f4-2ad20637262c","idx":"824bf62e-cd72-4f9c-a359-cccb08791e0b"}
{"func_before":"\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tmutex_lock(&key_construction_mutex);\n\n\t\/* can't instantiate twice *\/\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\t\/* instantiate the key *\/\n\t\tret = key->type->instantiate(key, prep);\n\n\t\tif (ret == 0) {\n\t\t\t\/* mark the key as being instantiated *\/\n\t\t\tatomic_inc(&key->user->nikeys);\n\t\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\n\t\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\t\tawaken = 1;\n\n\t\t\t\/* and link it into the destination keyring *\/\n\t\t\tif (keyring) {\n\t\t\t\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\t\t\t\tset_bit(KEY_FLAG_KEEP, &key->flags);\n\n\t\t\t\t__key_link(key, _edit);","target":1,"flaw_line_index":0,"hash":"10b58233-2bbd-4c01-82ac-65fcc612afb0","idx":"2f56977a-eac3-4e98-ac36-61f67f571bbf"}
{"func_before":"\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tmutex_lock(&key_construction_mutex);\n\n\t\/* can't instantiate twice *\/\n\tif (key->state == KEY_IS_UNINSTANTIATED) {\n\t\t\/* instantiate the key *\/\n\t\tret = key->type->instantiate(key, prep);\n\n\t\tif (ret == 0) {\n\t\t\t\/* mark the key as being instantiated *\/\n\t\t\tatomic_inc(&key->user->nikeys);\n\t\t\tmark_key_instantiated(key, 0);\n\n\t\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\t\tawaken = 1;\n\n\t\t\t\/* and link it into the destination keyring *\/\n\t\t\tif (keyring) {\n\t\t\t\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\t\t\t\tset_bit(KEY_FLAG_KEEP, &key->flags);\n\n\t\t\t\t__key_link(key, _edit);","target":0,"flaw_line_index":0,"hash":"4d3ec9d0-7811-4791-915a-14f277d0ad2e","idx":"697b6c90-0029-46f9-8f33-2c8df067e852"}
{"func_before":"    case HEVC_NAL_BLA_N_LP:\n    case HEVC_NAL_IDR_W_RADL:\n    case HEVC_NAL_IDR_N_LP:\n    case HEVC_NAL_CRA_NUT:\n    case HEVC_NAL_RADL_N:\n    case HEVC_NAL_RADL_R:\n    case HEVC_NAL_RASL_N:\n    case HEVC_NAL_RASL_R:\n        ret = hls_slice_header(s);\n        if (ret < 0)\n            return ret;\n\n        if (\n            (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONINTRA && s->sh.slice_type != HEVC_SLICE_I) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONKEY && !IS_IRAP(s))) {\n            break;\n        }\n\n        if (s->sh.first_slice_in_pic_flag) {\n            if (s->ref) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Two slices reporting being the first in the same frame.\\n\");\n                goto fail;\n            }\n            if (s->max_ra == INT_MAX) {\n                if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {\n                    s->max_ra = s->poc;\n                } else {\n                    if (IS_IDR(s))\n                        s->max_ra = INT_MIN;\n                }\n            }\n\n            if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&","target":1,"flaw_line_index":0,"hash":"95c273db-ebb5-439a-b5b0-ee48549f0709","idx":"b54a0e26-1da9-4cea-a461-6508406bd1e6"}
{"func_before":"    case HEVC_NAL_IDR_W_RADL:\n    case HEVC_NAL_IDR_N_LP:\n    case HEVC_NAL_CRA_NUT:\n    case HEVC_NAL_RADL_N:\n    case HEVC_NAL_RADL_R:\n    case HEVC_NAL_RASL_N:\n    case HEVC_NAL_RASL_R:\n        ret = hls_slice_header(s);\n        if (ret < 0)\n            return ret;\n        if (ret == 1) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n\n        if (\n            (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONINTRA && s->sh.slice_type != HEVC_SLICE_I) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONKEY && !IS_IRAP(s))) {\n            break;\n        }\n\n        if (s->sh.first_slice_in_pic_flag) {\n            if (s->max_ra == INT_MAX) {\n                if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {\n                    s->max_ra = s->poc;\n                } else {\n                    if (IS_IDR(s))\n                        s->max_ra = INT_MIN;\n                }\n            }\n\n            if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&","target":0,"flaw_line_index":0,"hash":"b9db1a72-4b9f-48b7-9313-05580016059f","idx":"42abc904-5c00-4c1c-b025-4972b625eac2"}
{"func_before":"uint16_t enc28j60ReadPhyReg(NetInterface *interface, uint16_t address)\n{\n   uint16_t data;\n\n   \/\/Write register address\n   enc28j60WriteReg(interface, ENC28J60_REG_MIREGADR, address & REG_ADDR_MASK);\n\n   \/\/Start read operation\n   enc28j60WriteReg(interface, ENC28J60_REG_MICMD, MICMD_MIIRD);\n   \/\/Wait for the read operation to complete\n   while((enc28j60ReadReg(interface, ENC28J60_REG_MISTAT) & MISTAT_BUSY) != 0)\n   {\n   }\n\n   \/\/Clear command register\n   enc28j60WriteReg(interface, ENC28J60_REG_MICMD, 0);\n\n   \/\/Read the lower 8 bits\n   data = enc28j60ReadReg(interface, ENC28J60_REG_MIRDL);\n   \/\/Read the upper 8 bits\n   data |= enc28j60ReadReg(interface, ENC28J60_REG_MIRDH) << 8;\n\n   \/\/Return register contents\n   return data;\n}","target":1,"flaw_line_index":0,"hash":"22c311d3-93bd-4a9c-918f-1525f5491cc5","idx":"d9c1f3a1-f7f1-447f-8bbd-5f25da920b10"}
{"func_before":"uint16_t enc28j60ReadPhyReg(NetInterface *interface, uint16_t address)\n{\n   uint16_t data;\n\n   \/\/Write register address\n   enc28j60WriteReg(interface, ENC28J60_MIREGADR, address & REG_ADDR_MASK);\n\n   \/\/Start read operation\n   enc28j60WriteReg(interface, ENC28J60_MICMD, ENC28J60_MICMD_MIIRD);\n   \/\/Wait for the read operation to complete\n   while((enc28j60ReadReg(interface, ENC28J60_MISTAT) & ENC28J60_MISTAT_BUSY) != 0)\n   {\n   }\n\n   \/\/Clear command register\n   enc28j60WriteReg(interface, ENC28J60_MICMD, 0);\n\n   \/\/Read the lower 8 bits\n   data = enc28j60ReadReg(interface, ENC28J60_MIRDL);\n   \/\/Read the upper 8 bits\n   data |= enc28j60ReadReg(interface, ENC28J60_MIRDH) << 8;\n\n   \/\/Return register contents\n   return data;\n}","target":0,"flaw_line_index":0,"hash":"88785dae-ee17-44e7-be5d-5ac24b13b8f8","idx":"d7f52a15-97d4-4388-bdd9-8ffa33926bab"}
{"func_before":"static bool new_idmap_permitted(const struct file *file, \n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\t\/* Allow mapping to your own filesystem ids *\/\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, current_fsuid()))\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, current_fsgid()))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\t\/* Allow anyone to set a mapping that doesn't require privilege *\/\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\n\t\/* Allow the specified ids if we have the appropriate capability\n\t * (CAP_SETUID or CAP_SETGID) over the parent user namespace.","target":1,"flaw_line_index":0,"hash":"54f1495a-1fa7-4c4c-90e7-4e78bfeaa26b","idx":"b92af457-de1e-4f85-8e72-199e4aeaf6c4"}
{"func_before":"static bool new_idmap_permitted(const struct file *file, \n\t\t\t\tstruct user_namespace *ns, int cap_setid,\n\t\t\t\tstruct uid_gid_map *new_map)\n{\n\t\/* Allow mapping to your own filesystem ids *\/\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, file->f_cred->fsuid))\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, file->f_cred->fsgid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\t\/* Allow anyone to set a mapping that doesn't require privilege *\/\n\tif (!cap_valid(cap_setid))\n\t\treturn true;\n\n\t\/* Allow the specified ids if we have the appropriate capability\n\t * (CAP_SETUID or CAP_SETGID) over the parent user namespace.","target":0,"flaw_line_index":0,"hash":"c487ed6d-7ec6-4dff-8f32-488481f63977","idx":"b02cf21b-de2c-408a-85f7-2d6f12be8ce2"}
{"func_before":"R_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAnnotation *annotation = NULL;\n\tRBinJavaElementValuePair *evps = NULL;\n\tut64 offset = 0;\n\tannotation = R_NEW0 (RBinJavaAnnotation);\n\tif (!annotation) {\n\t\treturn NULL;\n\t}\n\t\/\/ (ut16) read and set annotation_value.type_idx;\n\tannotation->type_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\t\/\/ (ut16) read and set annotation_value.num_element_value_pairs;\n\tannotation->num_element_value_pairs = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tannotation->element_value_pairs = r_list_newf (r_bin_java_element_pair_free);","target":1,"flaw_line_index":0,"hash":"6a357928-2643-4bba-8215-26251def1c8c","idx":"7e2e796a-6c16-47a4-88eb-c5fb842d2be9"}
{"func_before":"R_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaElementValuePair *evps = NULL;\n\tut64 offset = 0;\n\tif (sz < 8) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAnnotation *annotation = R_NEW0 (RBinJavaAnnotation);\n\tif (!annotation) {\n\t\treturn NULL;\n\t}\n\t\/\/ (ut16) read and set annotation_value.type_idx;\n\tannotation->type_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\t\/\/ (ut16) read and set annotation_value.num_element_value_pairs;\n\tannotation->num_element_value_pairs = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tannotation->element_value_pairs = r_list_newf (r_bin_java_element_pair_free);","target":0,"flaw_line_index":0,"hash":"0824fc9b-b471-4805-8106-640bb55ebf84","idx":"f42feb25-e0ed-4b1b-8bfc-fa12339ca40a"}
{"func_before":"static s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si)\n{\n\ts32 pps_id, num_ref_idx_l0_active_minus1 = 0, num_ref_idx_l1_active_minus1 = 0;\n\n\t\/*s->current_picture.reference= h->nal_ref_idc != 0;*\/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif (pps_id > 255) return -1;\n\tsi->pps = &avc->pps[pps_id];\n\tif (!si->pps->slice_group_count) return -2;\n\tsi->sps = &avc->sps[si->pps->sps_id];\n\tif (!si->sps->log2_max_frame_num) return -2;\n\tavc->sps_active_idx = si->pps->sps_id;\n\tavc->pps_active_idx = pps_id;\n\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");\n\n\tsi->field_pic_flag = 0;","target":1,"flaw_line_index":0,"hash":"59eeb4ef-3894-4437-a6ed-6df910e5b7ca","idx":"5437fe0d-15c3-40e0-a0e5-6658d265a4e7"}
{"func_before":"static s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si)\n{\n\ts32 pps_id, num_ref_idx_l0_active_minus1 = 0, num_ref_idx_l1_active_minus1 = 0;\n\n\t\/*s->current_picture.reference= h->nal_ref_idc != 0;*\/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id > 255)) return -1;\n\tsi->pps = &avc->pps[pps_id];\n\tif (!si->pps->slice_group_count) return -2;\n\tsi->sps = &avc->sps[si->pps->sps_id];\n\tif (!si->sps->log2_max_frame_num) return -2;\n\tavc->sps_active_idx = si->pps->sps_id;\n\tavc->pps_active_idx = pps_id;\n\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");\n\n\tsi->field_pic_flag = 0;","target":0,"flaw_line_index":0,"hash":"740835b9-7cc6-49d6-8e0c-4049ab86f70e","idx":"51e875f5-04d2-42e1-82eb-e04702c59fd0"}
{"func_before":"\n\tcase SO_RCVLOWAT:\n\t\tv.val = sk->sk_rcvlowat;\n\t\tbreak;\n\n\tcase SO_SNDLOWAT:\n\t\tv.val = 1;\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tv.val = test_bit(SOCK_PASSCRED, &sock->flags) ? 1 : 0;\n\t\tbreak;\n\n\tcase SO_PEERCRED:\n\t{\n\t\tstruct ucred peercred;\n\t\tif (len > sizeof(peercred))\n\t\t\tlen = sizeof(peercred);\n\t\tcred_to_ucred(sk->sk_peer_pid, sk->sk_peer_cred, &peercred);\n\t\tif (copy_to_user(optval, &peercred, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t\/* Dubious BSD thing... Probably nobody even uses it, but\n\t * the UNIX standard wants it for whatever reason... -DaveM\n\t *\/\n\tcase SO_ACCEPTCONN:\n\t\tv.val = sk->sk_state == TCP_LISTEN;\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tv.val = test_bit(SOCK_PASSSEC, &sock->flags) ? 1 : 0;\n\t\tbreak;\n\n\tcase SO_PEERSEC:\n\t\treturn security_socket_getpeersec_stream(sock, optval, optlen, len);\n\n\tcase SO_MARK:\n\t\tv.val = sk->sk_mark;\n\t\tbreak;\n\n\tcase SO_RXQ_OVFL:","target":1,"flaw_line_index":0,"hash":"a7cb7778-5eec-41fb-b5f6-f1bed29a8fae","idx":"0918cd17-8c87-4067-b86a-e021733609f3"}
{"func_before":"\n\tcase SO_RCVLOWAT:\n\t\tv.val = sk->sk_rcvlowat;\n\t\tbreak;\n\n\tcase SO_SNDLOWAT:\n\t\tv.val = 1;\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tv.val = !!test_bit(SOCK_PASSCRED, &sock->flags);\n\t\tbreak;\n\n\tcase SO_PEERCRED:\n\t{\n\t\tstruct ucred peercred;\n\t\tif (len > sizeof(peercred))\n\t\t\tlen = sizeof(peercred);\n\t\tcred_to_ucred(sk->sk_peer_pid, sk->sk_peer_cred, &peercred);\n\t\tif (copy_to_user(optval, &peercred, len))\n\t\t\treturn -EFAULT;\n\t}\n\n\t\/* Dubious BSD thing... Probably nobody even uses it, but\n\t * the UNIX standard wants it for whatever reason... -DaveM\n\t *\/\n\tcase SO_ACCEPTCONN:\n\t\tv.val = sk->sk_state == TCP_LISTEN;\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tv.val = !!test_bit(SOCK_PASSSEC, &sock->flags);\n\t\tbreak;\n\n\tcase SO_PEERSEC:\n\t\treturn security_socket_getpeersec_stream(sock, optval, optlen, len);\n\n\tcase SO_MARK:\n\t\tv.val = sk->sk_mark;\n\t\tbreak;\n\n\tcase SO_RXQ_OVFL:","target":0,"flaw_line_index":0,"hash":"a14fd285-34ab-4354-bd97-c3457603eb02","idx":"d4f9edfe-4357-4954-8206-fbe97fc5975a"}
{"func_before":"int crxReadImageHeaders(crx_data_header_t *hdr, CrxImage *img, uint8_t *mdatPtr,\n                        uint32_t mdatSize)\n{\n  int nTiles = img->tileRows * img->tileCols;\n\n  if (!nTiles)\n    return -1;\n\n  if (!img->tiles)\n  {\n    img->tiles = (CrxTile *)malloc(\n        sizeof(CrxTile) * nTiles +\n        sizeof(CrxPlaneComp) * nTiles * img->nPlanes +\n        sizeof(CrxSubband) * nTiles * img->nPlanes * img->subbandCount);\n    if (!img->tiles)\n      return -1;\n\n    \/\/ memory areas in allocated chunk\n    CrxTile *tile = img->tiles;\n    CrxPlaneComp *comps = (CrxPlaneComp *)(tile + nTiles);\n    CrxSubband *bands = (CrxSubband *)(comps + img->nPlanes * nTiles);\n\n    for (int curTile = 0; curTile < nTiles; curTile++, tile++)\n    {","target":1,"flaw_line_index":0,"hash":"96457cba-31d9-4f8f-ad53-5298782be1e9","idx":"33d0df62-11fa-47f3-8754-8486b6440295"}
{"func_before":"int crxReadImageHeaders(crx_data_header_t *hdr, CrxImage *img, uint8_t *mdatPtr,\n                        uint32_t mdatSize)\n{\n  int nTiles = img->tileRows * img->tileCols;\n\n  if (!nTiles)\n    return -1;\n\n  if (!img->tiles)\n  {\n    img->tiles = (CrxTile *)\n#ifdef LIBRAW_CR3_MEMPOOL\n\t\timg->memmgr.\n#endif\n\t\tcalloc(\n        sizeof(CrxTile) * nTiles +\n        sizeof(CrxPlaneComp) * nTiles * img->nPlanes +\n        sizeof(CrxSubband) * nTiles * img->nPlanes * img->subbandCount,1);\n    if (!img->tiles)\n      return -1;\n\n    \/\/ memory areas in allocated chunk\n    CrxTile *tile = img->tiles;\n    CrxPlaneComp *comps = (CrxPlaneComp *)(tile + nTiles);\n    CrxSubband *bands = (CrxSubband *)(comps + img->nPlanes * nTiles);\n\n    for (int curTile = 0; curTile < nTiles; curTile++, tile++)\n    {","target":0,"flaw_line_index":0,"hash":"4e144964-670a-4835-9420-f6b99d9f99db","idx":"4be59c15-449c-41c3-ad17-1d18572a8e85"}
{"func_before":"\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\/*reset global QP*\/\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t\/*register global QP*\/\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\n\t\/*register TWICE: once for the command, and for the scenegraph globalQP*\/\n\tnode->sgprivate->num_instances = 2;\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}","target":1,"flaw_line_index":0,"hash":"93da7aa5-7400-4c75-b359-db21696d16e9","idx":"79c33409-8f69-4094-9c41-ddef13995db8"}
{"func_before":"\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t\/*reset global QP*\/\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\t\/\/if node was just created (num_instances == 0), unregister\n\t\t\/\/otherwise (USE node) don't do anything\n\t\tif (!node->sgprivate->num_instances) {\n\t\t\tnode->sgprivate->num_instances = 1;\n\t\t\tgf_node_unregister(node, NULL);\n\t\t}\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t\/*register global QP*\/\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\n\t\/*register TWICE: once for the command, and for the scenegraph globalQP*\/\n\tgf_node_unregister(node, NULL);\n\tgf_node_unregister(node, NULL);\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}","target":0,"flaw_line_index":0,"hash":"7102bfdd-b308-4c17-8d30-72760d39918b","idx":"092edbfa-69e3-4e23-a16f-0c1578eed400"}
{"func_before":"\tkey2 = FUTEX_KEY_INIT;\n\tret = get_futex_key(uaddr2, fshared, &key2);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = &rt_waiter;\n\tq.requeue_pi_key = &key2;\n\n\t\/* Prepare to wait on uaddr. *\/\n\tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n\tif (ret)\n\t\tgoto out_key2;\n\n\t\/* Queue the futex_q, drop the hb lock, wait for wakeup. *\/\n\tfutex_wait_queue_me(hb, &q, to);\n\n\tspin_lock(&hb->lock);\n\tret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);\n\tspin_unlock(&hb->lock);\n\tif (ret)\n\t\tgoto out_put_keys;\n\n\t\/*\n\t * In order for us to be here, we know our q.key == key2, and since\n\t * we took the hb->lock above, we also know that futex_requeue() has\n\t * completed and we no longer have to concern ourselves with a wakeup\n\t * race with the atomic proxy lock acquition by the requeue code.\n\t *\/\n\n\t\/* Check if the requeue code acquired the second futex for us. *\/\n\tif (!q.rt_waiter) {\n\t\t\/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case.\n\t\t *\/\n\t\tif (q.pi_state && (q.pi_state->owner != current)) {\n\t\t\tspin_lock(q.lock_ptr);","target":1,"flaw_line_index":0,"hash":"c14f6e4d-3f16-4e8b-b7c1-8cfddb1de673","idx":"87b76558-068e-447d-bb1b-a5735d0fe3ed"}
{"func_before":"\tkey2 = FUTEX_KEY_INIT;\n\tret = get_futex_key(uaddr2, fshared, &key2);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = &rt_waiter;\n\tq.requeue_pi_key = &key2;\n\n\t\/*\n\t * Prepare to wait on uaddr. On success, increments q.key (key1) ref\n\t * count.\n\t *\/\n\tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n\tif (ret)\n\t\tgoto out_key2;\n\n\t\/* Queue the futex_q, drop the hb lock, wait for wakeup. *\/\n\tfutex_wait_queue_me(hb, &q, to);\n\n\tspin_lock(&hb->lock);\n\tret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);\n\tspin_unlock(&hb->lock);\n\tif (ret)\n\t\tgoto out_put_keys;\n\n\t\/*\n\t * In order for us to be here, we know our q.key == key2, and since\n\t * we took the hb->lock above, we also know that futex_requeue() has\n\t * completed and we no longer have to concern ourselves with a wakeup\n\t * race with the atomic proxy lock acquisition by the requeue code. The\n\t * futex_requeue dropped our key1 reference and incremented our key2\n\t * reference count.\n\t *\/\n\n\t\/* Check if the requeue code acquired the second futex for us. *\/\n\tif (!q.rt_waiter) {\n\t\t\/*\n\t\t * Got the lock. We might not be the anticipated owner if we\n\t\t * did a lock-steal - fix up the PI-state in that case.\n\t\t *\/\n\t\tif (q.pi_state && (q.pi_state->owner != current)) {\n\t\t\tspin_lock(q.lock_ptr);","target":0,"flaw_line_index":0,"hash":"0ba88cc4-7f88-4ea4-9a8b-0448b2673a70","idx":"68457c2d-4649-4cb2-a207-9bd42ad64333"}
{"func_before":"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_sli(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tunsigned *sli_cnt,\n\t\t\t\t\tpjmedia_rtcp_fb_sli sli[])\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    unsigned cnt, i;\n\n    PJ_ASSERT_RETURN(buf && sli_cnt && sli, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n\n    \/* PLI uses pt==RTCP_PSFB and FMT==2 *\/\n    if (hdr->pt != RTCP_PSFB || hdr->count != 2)\n\treturn PJ_ENOTFOUND;\n\n    cnt = pj_ntohs((pj_uint16_t)hdr->length) - 2;\n    if (length < (cnt+3)*4)\n\treturn PJ_ETOOSMALL;\n\n    *sli_cnt = PJ_MIN(*sli_cnt, cnt);\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < *sli_cnt; ++i) {\n\t\/* 'first' takes 13 bit *\/\n\tsli[i].first = (p[0] << 5) + ((p[1] & 0xF8) >> 3);\n\t\/* 'number' takes 13 bit *\/","target":1,"flaw_line_index":0,"hash":"e81e67bb-8583-4890-8e7f-3497be372164","idx":"57b9625e-e01d-4f7e-8742-1b25be533e5c"}
{"func_before":"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_sli(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tunsigned *sli_cnt,\n\t\t\t\t\tpjmedia_rtcp_fb_sli sli[])\n{\n    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;\n    pj_uint8_t *p;\n    unsigned cnt, i;\n\n    PJ_ASSERT_RETURN(buf && sli_cnt && sli, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_fb_common), PJ_ETOOSMALL);\n\n    \/* PLI uses pt==RTCP_PSFB and FMT==2 *\/\n    if (hdr->rtcp_common.pt != RTCP_PSFB || hdr->rtcp_common.count != 2)\n\treturn PJ_ENOTFOUND;\n\n    cnt = pj_ntohs((pj_uint16_t)hdr->rtcp_common.length) - 2;\n    if (length < (cnt+3)*4)\n\treturn PJ_ETOOSMALL;\n\n    *sli_cnt = PJ_MIN(*sli_cnt, cnt);\n\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < *sli_cnt; ++i) {\n\t\/* 'first' takes 13 bit *\/\n\tsli[i].first = (p[0] << 5) + ((p[1] & 0xF8) >> 3);\n\t\/* 'number' takes 13 bit *\/","target":0,"flaw_line_index":0,"hash":"7a99d6f0-d7b9-459b-b286-f7b51b6efe33","idx":"5b324fdf-c676-47fb-8f29-b14f0ae17cf7"}
{"func_before":"\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\n\tif (PageDirty(page)) {\n\t\tclear_page_dirty_for_io(page);\n\t\t\/*\n\t\t * Want to mark the page and the radix tree as dirty, and\n\t\t * redo the accounting that clear_page_dirty_for_io undid,\n\t\t * but we can't use set_page_dirty because that function\n\t\t * is actually a signal that all of the page has become dirty.\n\t\t * Whereas only part of our page may be dirty.\n\t\t *\/\n\t\tif (PageSwapBacked(page))\n\t\t\tSetPageDirty(newpage);\n\t\telse\n\t\t\t__set_page_dirty_nobuffers(newpage);\n \t}\n\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\n\t\/*\n\t * Copy NUMA information to the new page, to prevent over-eager\n\t * future migrations of this same page.\n\t *\/","target":1,"flaw_line_index":0,"hash":"bf1959d0-b14a-4b4d-9e27-54c7b27a847f","idx":"024eb3e7-6e3c-4dcc-82cc-eaa2f46346d7"}
{"func_before":"\tif (TestClearPageActive(page)) {\n\t\tVM_BUG_ON_PAGE(PageUnevictable(page), page);\n\t\tSetPageActive(newpage);\n\t} else if (TestClearPageUnevictable(page))\n\t\tSetPageUnevictable(newpage);\n\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\n\t\/* Move dirty on pages not done by migrate_page_move_mapping() *\/\n\tif (PageDirty(page))\n\t\tSetPageDirty(newpage);\n\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);\n\n\t\/*\n\t * Copy NUMA information to the new page, to prevent over-eager\n\t * future migrations of this same page.\n\t *\/","target":0,"flaw_line_index":0,"hash":"acc386b9-52a1-436e-93fb-651e26f82ae7","idx":"e4e250a4-3d09-4fe8-bc35-253c10c8dc2c"}
{"func_before":"    if (indexObj == nullptr)\n    {\n        \/\/ Default\n        indices.push_back(static_cast<int64_t>(0));\n        indices.push_back(size);\n    }\n    else\n    {\n        const PdfArray* arr;\n        if (!indexObj->TryGetArray(arr))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream \/Index\");\n\n        for (auto index : *arr)\n            indices.push_back(index.GetNumber());\n    }\n\n    \/\/ indices must be a multiple of 2\n    if (indices.size() % 2 != 0)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream \/Index\");\n}","target":1,"flaw_line_index":0,"hash":"44fc1e4c-25d6-4790-be59-2f453d03e64e","idx":"6317993a-be80-4fb1-883a-802da1f05346"}
{"func_before":"    if (indexObj == nullptr)\n    {\n        \/\/ Default\n        indices.push_back(static_cast<int64_t>(0));\n        indices.push_back(size);\n    }\n    else\n    {\n        const PdfArray* arr;\n        if (!indexObj->TryGetArray(arr))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream, \"Invalid XRef Stream \/Index\");\n\n        for (auto index : *arr)\n            indices.push_back(index.GetNumber());\n    }\n\n    \/\/ indices must be a multiple of 2\n    if (indices.size() % 2 != 0)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream, \"Invalid XRef Stream \/Index\");\n}","target":0,"flaw_line_index":0,"hash":"6926dfff-f23e-439f-8c02-c04bf5d4bbe8","idx":"f89c1c8e-24ac-4c58-8841-823ce51a4697"}
{"func_before":"dn2ancestor(\n    Slapi_Backend *be,\n    const Slapi_DN\t*sdn,\n\tSlapi_DN *ancestordn,\n    back_txn\t\t*txn,\n    int\t\t\t*err\n)\n{\n\tstruct backentry *e = NULL;\n\n\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> dn2ancestor \\\"%s\\\"\\n\", slapi_sdn_get_dn(sdn), 0, 0 );\n\n    \/* first, check to see if the given sdn is empty or a root suffix of the\n       given backend - if so, it has no parent *\/\n    if (!slapi_sdn_isempty(sdn) && !slapi_be_issuffix( be, sdn )) {\n        Slapi_DN ancestorndn;\n        const char *ptr;\n\n        \/* assign ancestordn to the parent of the given dn *\/\n        ptr = slapi_dn_find_parent(slapi_sdn_get_dn(sdn));\n        \/* assign the ancestordn dn pointer to the parent of dn from sdn - sdn \"owns\"\n          the dn and ndn byref at the same time.  Whenever you call set_dn or set_ndn,\n          it calls slapi_sdn_done which wipes out the previous contents.  I suppose I\n          could have added another API to allow you to pass them both in.  Also, using\n          slapi_sdn_get_ndn(ancestordn) every time would result in making a copy then\n          normalizing the copy every time - not efficient.\n          So, why not just use a char* for the ancestorndn?  Because dn2entry requires\n          a Slapi_DN with the normalized dn.\n        *\/\n\n        \/* stop when we get to \"\", or a backend suffix point *\/\n        while (!e && !slapi_sdn_isempty(&ancestorndn) && !slapi_be_issuffix( be, &ancestorndn )) {\n            \/* find the entry - it uses the ndn, so no further conversion is necessary *\/\n            e= dn2entry(be,&ancestorndn,txn,err);\n            if (!e) {\n                \/* not found, so set ancestordn to its parent and try again *\/\n                ptr = slapi_dn_find_parent(slapi_sdn_get_ndn(&ancestorndn));\n                \/* keep in mind that ptr points to the raw ndn pointer inside\n                   ancestorndn which is still the ndn string \"owned\" by sdn, the\n                   original dn we started with - we are careful not to touch\n                   or change it *\/\n                slapi_sdn_set_ndn_byref(&ancestorndn, ptr); \/* wipe out the previous contents *\/","target":1,"flaw_line_index":0,"hash":"de27b9b3-a8b5-45bd-ba90-117a81839ec0","idx":"a5d4caba-5d4d-41cd-8e25-8af709752086"}
{"func_before":"dn2ancestor(\n    Slapi_Backend *be,\n    const Slapi_DN\t*sdn,\n    Slapi_DN *ancestordn,\n    back_txn\t\t*txn,\n    int\t\t\t*err,\n    int allow_suffix\n)\n{\n    struct backentry *e = NULL;\n\n    LDAPDebug( LDAP_DEBUG_TRACE, \"=> dn2ancestor \\\"%s\\\"\\n\", slapi_sdn_get_dn(sdn), 0, 0 );\n\n    \/* first, check to see if the given sdn is empty or a root suffix of the\n       given backend - if so, it has no parent *\/\n    if (!slapi_sdn_isempty(sdn) && !slapi_be_issuffix( be, sdn )) {\n        Slapi_DN ancestorndn;\n        const char *ptr;\n\n        \/* assign ancestordn to the parent of the given dn *\/\n        ptr = slapi_dn_find_parent(slapi_sdn_get_dn(sdn));\n        \/* assign the ancestordn dn pointer to the parent of dn from sdn - sdn \"owns\"\n          the dn and ndn byref at the same time.  Whenever you call set_dn or set_ndn,\n          it calls slapi_sdn_done which wipes out the previous contents.  I suppose I\n          could have added another API to allow you to pass them both in.  Also, using\n          slapi_sdn_get_ndn(ancestordn) every time would result in making a copy then\n          normalizing the copy every time - not efficient.\n          So, why not just use a char* for the ancestorndn?  Because dn2entry requires\n          a Slapi_DN with the normalized dn.\n        *\/\n\n        \/* stop when we get to \"\", or a backend suffix point *\/\n        while (!e && !slapi_sdn_isempty(&ancestorndn)) {\n            if (!allow_suffix) {\n                \/* Original behavior. *\/\n                if (slapi_be_issuffix(be, &ancestorndn)) {\n                    break;\n                }\n            }\n            \/* find the entry - it uses the ndn, so no further conversion is necessary *\/\n            e= dn2entry(be,&ancestorndn,txn,err);\n            if (!e) {\n                \/* not found, so set ancestordn to its parent and try again *\/\n                ptr = slapi_dn_find_parent(slapi_sdn_get_ndn(&ancestorndn));\n                \/* keep in mind that ptr points to the raw ndn pointer inside\n                   ancestorndn which is still the ndn string \"owned\" by sdn, the\n                   original dn we started with - we are careful not to touch\n                   or change it *\/\n                slapi_sdn_set_ndn_byref(&ancestorndn, ptr); \/* wipe out the previous contents *\/","target":0,"flaw_line_index":0,"hash":"c33f4a58-9750-44a9-bc50-5e3a72c426c7","idx":"067424cd-c6d4-4fa9-91d1-323ee369d1ba"}
{"func_before":"{\n\tint err;\n\tint noblock;\n\tstruct vmci_datagram *dg;\n\tsize_t payload_len;\n\tstruct sk_buff *skb;\n\n\tnoblock = flags & MSG_DONTWAIT;\n\n\tif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\n\t\treturn -EOPNOTSUPP;\n\n\t\/* Retrieve the head sk_buff from the socket's receive queue. *\/\n\terr = 0;\n\tskb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);\n\tif (err)\n\t\treturn err;\n\n\tif (!skb)\n\t\treturn -EAGAIN;\n\n\t\tpayload_len = len;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\t\/* Place the datagram payload in the user's iovec. *\/\n\terr = skb_copy_datagram_iovec(skb, sizeof(*dg), msg->msg_iov,\n\t\tpayload_len);\n\tif (err)\n\t\tgoto out;\n\n\tmsg->msg_namelen = 0;\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_vm *vm_addr;\n\n\t\t\/* Provide the address of the sender. *\/\n\t\tvm_addr = (struct sockaddr_vm *)msg->msg_name;\n\t\tvsock_addr_init(vm_addr, dg->src.context, dg->src.resource);\n\t\tmsg->msg_namelen = sizeof(*vm_addr);\n\t}\n\terr = payload_len;\n","target":1,"flaw_line_index":0,"hash":"5db1e97f-e3b7-4419-8ce7-8e9b7a4ef712","idx":"ab4ed1b3-9099-4f46-b959-94aad178e880"}
{"func_before":"\tint err;\n\tint noblock;\n\tstruct vmci_datagram *dg;\n\tsize_t payload_len;\n\tstruct sk_buff *skb;\n\n\tnoblock = flags & MSG_DONTWAIT;\n\n\tif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg->msg_namelen = 0;\n\n\t\/* Retrieve the head sk_buff from the socket's receive queue. *\/\n\terr = 0;\n\tskb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);\n\tif (err)\n\t\treturn err;\n\n\tif (!skb)\n\t\treturn -EAGAIN;\n\n\tif (payload_len > len) {\n\t\tpayload_len = len;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\t\/* Place the datagram payload in the user's iovec. *\/\n\terr = skb_copy_datagram_iovec(skb, sizeof(*dg), msg->msg_iov,\n\t\tpayload_len);\n\tif (err)\n\t\tgoto out;\n\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_vm *vm_addr;\n\n\t\t\/* Provide the address of the sender. *\/\n\t\tvm_addr = (struct sockaddr_vm *)msg->msg_name;\n\t\tvsock_addr_init(vm_addr, dg->src.context, dg->src.resource);\n\t\tmsg->msg_namelen = sizeof(*vm_addr);\n\t}\n\terr = payload_len;\n","target":0,"flaw_line_index":0,"hash":"2b47dbee-0271-4c43-bdfa-c3fc20f5c82d","idx":"e1ffa419-ba21-4c08-b72f-fa671d2c1d3e"}
{"func_before":"server_partial_file_request(struct httpd *env, struct client *clt, char *path,\n    struct stat *st, char *range_str)\n{\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct media_type\t*media, multipart_media;\n\tstruct range\t\t*range;\n\tstruct evbuffer\t\t*evb = NULL;\n\tsize_t\t\t\t content_length;\n\tint\t\t\t code = 500, fd = -1, i, nranges, ret;\n\tuint32_t\t\t boundary;\n\tchar\t\t\t content_range[64];\n\tconst char\t\t*errstr = NULL;\n\n\t\/* Ignore range request for methods other than GET *\/\n\tif (desc->http_method != HTTP_METHOD_GET)\n\t\treturn server_file_request(env, clt, path, st);\n\n\tif ((range = parse_range(range_str, st->st_size, &nranges)) == NULL) {\n\t\tcode = 416;\n\t\t(void)snprintf(content_range, sizeof(content_range),\n\t\t    \"bytes *\/%lld\", st->st_size);\n\t\terrstr = content_range;\n\t\tgoto abort;\n\t}\n\n\t\/* Now open the file, should be readable or we have another problem *\/\n\tif ((fd = open(path, O_RDONLY)) == -1)\n\t\tgoto abort;\n\n\tmedia = media_find_config(env, srv_conf, path);\n\tif ((evb = evbuffer_new()) == NULL) {\n\t\terrstr = \"failed to allocate file buffer\";\n\t\tgoto abort;\n\t}\n\n\tif (nranges == 1) {\n\t\t(void)snprintf(content_range, sizeof(content_range),\n\t\t    \"bytes %lld-%lld\/%lld\", range->start, range->end,\n\t\t    st->st_size);\n\t\tif (kv_add(&resp->http_headers, \"Content-Range\",\n\t\t    content_range) == NULL)\n\t\t\tgoto abort;\n\n\t\tcontent_length = range->end - range->start + 1;\n\t\tif (buffer_add_range(fd, evb, range) == 0)\n\t\t\tgoto abort;\n\n\t} else {\n\t\tcontent_length = 0;\n\t\tboundary = arc4random();\n\t\t\/* Generate a multipart payload of byteranges *\/\n\t\twhile (nranges--) {\n\t\t\tif ((i = evbuffer_add_printf(evb, \"\\r\\n--%ud\\r\\n\",\n\t\t\t    boundary)) == -1)\n\t\t\t\tgoto abort;\n\n\t\t\tcontent_length += i;\n\t\t\tif ((i = evbuffer_add_printf(evb,\n\t\t\t    \"Content-Type: %s\/%s\\r\\n\",\n\t\t\t    media->media_type, media->media_subtype)) == -1)\n\t\t\t\tgoto abort;\n\n\t\t\tcontent_length += i;\n\t\t\tif ((i = evbuffer_add_printf(evb,\n\t\t\t    \"Content-Range: bytes %lld-%lld\/%lld\\r\\n\\r\\n\",\n\t\t\t    range->start, range->end, st->st_size)) == -1)\n\t\t\t\tgoto abort;\n\n\t\t\tcontent_length += i;\n\t\t\tif (buffer_add_range(fd, evb, range) == 0)\n\t\t\t\tgoto abort;\n\n\t\t\tcontent_length += range->end - range->start + 1;\n\t\t\trange++;\n\t\t}\n\n\t\tif ((i = evbuffer_add_printf(evb, \"\\r\\n--%ud--\\r\\n\",\n\t\t    boundary)) == -1)\n\t\t\tgoto abort;\n\n\t\tcontent_length += i;\n\n\t\t\/* prepare multipart\/byteranges media type *\/\n\t\t(void)strlcpy(multipart_media.media_type, \"multipart\",\n\t\t    sizeof(multipart_media.media_type));\n\t\t(void)snprintf(multipart_media.media_subtype,\n\t\t    sizeof(multipart_media.media_subtype),\n\t\t    \"byteranges; boundary=%ud\", boundary);\n\t\tmedia = &multipart_media;\n\t}\n\n\tclose(fd);\n\tfd = -1;\n\n\tret = server_response_http(clt, 206, media, content_length,\n\t    MINIMUM(time(NULL), st->st_mtim.tv_sec));\n\tswitch (ret) {\n\tcase -1:\n\t\tgoto fail;\n\tcase 0:\n\t\t\/* Connection is already finished *\/\n\t\tgoto done;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (server_bufferevent_write_buffer(clt, evb) == -1)\n\t\tgoto fail;\n\n\tbufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);\n\tif (clt->clt_persist)\n\t\tclt->clt_toread = TOREAD_HTTP_HEADER;\n\telse\n\t\tclt->clt_toread = TOREAD_HTTP_NONE;\n\tclt->clt_done = 0;\n\n done:\n\tevbuffer_free(evb);\n\tserver_reset_http(clt);\n\treturn (0);\n fail:\n\tbufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);\n\tbufferevent_free(clt->clt_bev);\n\tclt->clt_bev = NULL;\n abort:\n\tif (evb != NULL)\n\t\tevbuffer_free(evb);\n\tif (fd != -1)\n\t\tclose(fd);\n\tif (errstr == NULL)\n\t\terrstr = strerror(errno);\n\tserver_abort_http(clt, code, errstr);\n\treturn (-1);\n}","target":1,"flaw_line_index":0,"hash":"92639567-f7db-4d43-b102-797553da6504","idx":"e359a89c-b5fa-4e6c-a8dc-aee173bf3686"}
{"func_before":"server_partial_file_request(struct httpd *env, struct client *clt, char *path,\n    struct stat *st, char *range_str)\n{\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct media_type\t*media, multipart_media;\n\tstruct range_data\t*r = &clt->clt_ranges;\n\tstruct range\t\t*range;\n\tsize_t\t\t\t content_length = 0;\n\tint\t\t\t code = 500, fd = -1, i, nranges, ret;\n\tchar\t\t\t content_range[64];\n\tconst char\t\t*errstr = NULL;\n\n\t\/* Ignore range request for methods other than GET *\/\n\tif (desc->http_method != HTTP_METHOD_GET)\n\t\treturn server_file_request(env, clt, path, st);\n\n\tif ((nranges = parse_ranges(clt, range_str, st->st_size)) < 1) {\n\t\tcode = 416;\n\t\t(void)snprintf(content_range, sizeof(content_range),\n\t\t    \"bytes *\/%lld\", st->st_size);\n\t\terrstr = content_range;\n\t\tgoto abort;\n\t}\n\n\t\/* Now open the file, should be readable or we have another problem *\/\n\tif ((fd = open(path, O_RDONLY)) == -1)\n\t\tgoto abort;\n\n\tmedia = media_find_config(env, srv_conf, path);\n\tr->range_media = media;\n\n\tif (nranges == 1) {\n\t\trange = &r->range[0];\n\t\t(void)snprintf(content_range, sizeof(content_range),\n\t\t    \"bytes %lld-%lld\/%lld\", range->start, range->end,\n\t\t    st->st_size);\n\t\tif (kv_add(&resp->http_headers, \"Content-Range\",\n\t\t    content_range) == NULL)\n\t\t\tgoto abort;\n\n\t\trange = &r->range[0];\n\t\tcontent_length += range->end - range->start + 1;\n\t} else {\n\t\t\/* Add boundary, all parts will be handled by the callback *\/\n\t\tarc4random_buf(&clt->clt_boundary, sizeof(clt->clt_boundary));\n\n\t\t\/* Calculate Content-Length of the complete multipart body *\/\n\t\tfor (i = 0; i < nranges; i++) {\n\t\t\trange = &r->range[i];\n\n\t\t\t\/* calculate Content-Length of the complete body *\/\n\t\t\tif ((ret = snprintf(NULL, 0,\n\t\t\t    \"\\r\\n--%llu\\r\\n\"\n\t\t\t    \"Content-Type: %s\/%s\\r\\n\"\n\t\t\t    \"Content-Range: bytes %lld-%lld\/%lld\\r\\n\\r\\n\",\n\t\t\t    clt->clt_boundary,\n\t\t\t    media->media_type, media->media_subtype,\n\t\t\t    range->start, range->end, st->st_size)) < 0)\n\t\t\t\tgoto abort;\n\n\t\t\t\/* Add data length *\/\n\t\t\tcontent_length += ret + range->end - range->start + 1;\n\n\t\t}\n\t\tif ((ret = snprintf(NULL, 0, \"\\r\\n--%llu--\\r\\n\",\n\t\t    clt->clt_boundary)) < 0)\n\t\t\tgoto abort;\n\t\tcontent_length += ret;\n\n\t\t\/* prepare multipart\/byteranges media type *\/\n\t\t(void)strlcpy(multipart_media.media_type, \"multipart\",\n\t\t    sizeof(multipart_media.media_type));\n\t\t(void)snprintf(multipart_media.media_subtype,\n\t\t    sizeof(multipart_media.media_subtype),\n\t\t    \"byteranges; boundary=%llu\", clt->clt_boundary);\n\t\tmedia = &multipart_media;\n\t}\n\n\t\/* Start with first range *\/\n\tr->range_toread = TOREAD_HTTP_RANGE;\n\n\tret = server_response_http(clt, 206, media, content_length,\n\t    MINIMUM(time(NULL), st->st_mtim.tv_sec));\n\tswitch (ret) {\n\tcase -1:\n\t\tgoto fail;\n\tcase 0:\n\t\t\/* Connection is already finished *\/\n\t\tclose(fd);\n\t\tgoto done;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tclt->clt_fd = fd;\n\tif (clt->clt_srvbev != NULL)\n\t\tbufferevent_free(clt->clt_srvbev);\n\n\tclt->clt_srvbev_throttled = 0;\n\tclt->clt_srvbev = bufferevent_new(clt->clt_fd, server_read_httprange,\n\t    server_write, server_file_error, clt);\n\tif (clt->clt_srvbev == NULL) {\n\t\terrstr = \"failed to allocate file buffer event\";\n\t\tgoto fail;\n\t}\n\n\t\/* Adjust read watermark to the socket output buffer size *\/\n\tbufferevent_setwatermark(clt->clt_srvbev, EV_READ, 0,\n\t    clt->clt_sndbufsiz);\n\n\tbufferevent_settimeout(clt->clt_srvbev,\n\t    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);\n\tbufferevent_enable(clt->clt_srvbev, EV_READ);\n\tbufferevent_disable(clt->clt_bev, EV_READ);\n\n done:\n\tserver_reset_http(clt);\n\treturn (0);\n fail:\n\tbufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);\n\tbufferevent_free(clt->clt_bev);\n\tclt->clt_bev = NULL;\n abort:\n\tif (fd != -1)\n\t\tclose(fd);\n\tif (errstr == NULL)\n\t\terrstr = strerror(errno);\n\tserver_abort_http(clt, code, errstr);\n\treturn (-1);\n}","target":0,"flaw_line_index":0,"hash":"dcd40a0e-3ae4-424a-93b7-b8fd4020dcc8","idx":"64f6a154-66a5-41aa-8a53-923487a60df7"}
{"func_before":"\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\n\t\tcb->args[0] = 1;\n\n\t\terr = nlmsg_parse(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t  xfrma_policy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (attrs[XFRMA_ADDRESS_FILTER]) {\n\t\t\tfilter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),\n\t\t\t\t\t sizeof(*filter), GFP_KERNEL);\n\t\t\tif (filter == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t}\n\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\n\treturn skb->len;\n}","target":1,"flaw_line_index":0,"hash":"79af9880-e358-4c30-b201-1739ba4b462c","idx":"7cb5dfcb-69d3-4db4-9fb1-7f4b744223ac"}
{"func_before":"\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\n\t\terr = nlmsg_parse(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t  xfrma_policy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (attrs[XFRMA_ADDRESS_FILTER]) {\n\t\t\tfilter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),\n\t\t\t\t\t sizeof(*filter), GFP_KERNEL);\n\t\t\tif (filter == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t\tcb->args[0] = 1;\n\t}\n\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\n\treturn skb->len;\n}","target":0,"flaw_line_index":0,"hash":"711a011c-54e7-4a4c-82bb-7c6ae189665c","idx":"0138dd0e-b219-44e1-966d-c43929e619a1"}
{"func_before":"\tretpoline_generic:\n\t\tmode = retp_compiler() ? SPECTRE_V2_RETPOLINE_GENERIC :\n\t\t\t\t\t SPECTRE_V2_RETPOLINE_MINIMAL;\n\t\tsetup_force_cpu_cap(X86_FEATURE_RETPOLINE);\n\t}\n\n\tspectre_v2_enabled = mode;\n\tpr_info(\"%s\\n\", spectre_v2_strings[mode]);\n\n\t\/*\n\t * If neither SMEP nor PTI are available, there is a risk of\n\t * hitting userspace addresses in the RSB after a context switch\n\t * from a shallow call stack to a deeper one. To prevent this fill\n\t * the entire RSB, even when using IBRS.\n\t *\n\t * Skylake era CPUs have a separate issue with *underflow* of the\n\t * RSB, when they will predict 'ret' targets from the generic BTB.\n\t * The proper mitigation for this is IBRS. If IBRS is not supported\n\t * or deactivated in favour of retpolines the RSB fill on context\n\t * switch is required.\n\t *\/\n\tif ((!boot_cpu_has(X86_FEATURE_PTI) &&\n\t     !boot_cpu_has(X86_FEATURE_SMEP)) || is_skylake_era()) {\n\t\tsetup_force_cpu_cap(X86_FEATURE_RSB_CTXSW);\n\t\tpr_info(\"Spectre v2 mitigation: Filling RSB on context switch\\n\");\n\t}\n\n\t\/* Initialize Indirect Branch Prediction Barrier if supported *\/\n\tif (boot_cpu_has(X86_FEATURE_IBPB)) {\n\t\tsetup_force_cpu_cap(X86_FEATURE_USE_IBPB);\n\t\tpr_info(\"Spectre v2 mitigation: Enabling Indirect Branch Prediction Barrier\\n\");\n\t}\n\n\t\/*\n\t * Retpoline means the kernel is safe because it has no indirect\n\t * branches. But firmware isn't, so use IBRS to protect that.","target":1,"flaw_line_index":0,"hash":"c5d6aaf9-9d9f-49be-ae59-0d915e9ddf78","idx":"561f0c58-1a58-42b4-b1aa-7393e962cd51"}
{"func_before":"\tretpoline_generic:\n\t\tmode = retp_compiler() ? SPECTRE_V2_RETPOLINE_GENERIC :\n\t\t\t\t\t SPECTRE_V2_RETPOLINE_MINIMAL;\n\t\tsetup_force_cpu_cap(X86_FEATURE_RETPOLINE);\n\t}\n\n\tspectre_v2_enabled = mode;\n\tpr_info(\"%s\\n\", spectre_v2_strings[mode]);\n\n\t\/*\n\t * If spectre v2 protection has been enabled, unconditionally fill\n\t * RSB during a context switch; this protects against two independent\n\t * issues:\n\t *\n\t *\t- RSB underflow (and switch to BTB) on Skylake+\n\t *\t- SpectreRSB variant of spectre v2 on X86_BUG_SPECTRE_V2 CPUs\n\t *\/\n\tsetup_force_cpu_cap(X86_FEATURE_RSB_CTXSW);\n\tpr_info(\"Spectre v2 \/ SpectreRSB mitigation: Filling RSB on context switch\\n\");\n\n\t\/* Initialize Indirect Branch Prediction Barrier if supported *\/\n\tif (boot_cpu_has(X86_FEATURE_IBPB)) {\n\t\tsetup_force_cpu_cap(X86_FEATURE_USE_IBPB);\n\t\tpr_info(\"Spectre v2 mitigation: Enabling Indirect Branch Prediction Barrier\\n\");\n\t}\n\n\t\/*\n\t * Retpoline means the kernel is safe because it has no indirect\n\t * branches. But firmware isn't, so use IBRS to protect that.","target":0,"flaw_line_index":0,"hash":"85627cc4-43da-458f-b853-bafbbc518473","idx":"81779e38-95fa-451b-9efc-e50ea93d74ff"}
{"func_before":"\tfor (auth = auth_switch; auth->name; auth++) {\n\t    if (IS_DISABLED(auth))\n\t\tcontinue;\n\t    num_methods++;\n\t    if (auth->setup != NULL) {\n\t\tstatus = (auth->setup)(ctx, pw, &prompt, auth);\n\t\tif (status == AUTH_FAILURE)\n\t\t    SET(auth->flags, FLAG_DISABLED);\n\t\telse if (status == AUTH_NONINTERACTIVE)\n\t\t    goto done;\n\t\telse if (status == AUTH_ERROR || user_interrupted())\n\t\t    goto done;\t\t\/* assume error msg already printed *\/\n\t    }\n\t}\n\tif (num_methods == 0) {\n\t    audit_failure(ctx, ctx->runas.argv,\n\t\tN_(\"no authentication methods\"));\n\t    log_warningx(ctx, SLOG_SEND_MAIL,\n\t\tN_(\"Unable to initialize authentication methods.\"));\n\t    debug_return_int(-1);\n\t}\n\tcase AUTH_INTR:\n\tcase AUTH_FAILURE:\n\t    if (ntries != 0)\n\t\tSET(validated, FLAG_BAD_PASSWORD);\n\t    log_auth_failure(ctx, validated, ntries);\n\t    ret = false;\n\t    break;\n\tcase AUTH_NONINTERACTIVE:\n\t    SET(validated, FLAG_NO_USER_INPUT);\n\t    FALLTHROUGH;\n\tcase AUTH_ERROR:\n\tdefault:\n\t    log_auth_failure(ctx, validated, 0);\n\t    ret = -1;\n\t    break;\n    }\n\n    debug_return_int(ret);\n}","target":1,"flaw_line_index":0,"hash":"56244bc0-96c9-493b-a52c-d91fdd9e21db","idx":"9864d4a6-28cc-4103-b89e-1d8f68fe5705"}
{"func_before":"\tfor (auth = auth_switch; auth->name; auth++) {\n\t    if (IS_DISABLED(auth))\n\t\tcontinue;\n\t    num_methods++;\n\t    if (auth->setup != NULL) {\n\t\tstatus = (auth->setup)(ctx, pw, &prompt, auth);\n\t\tif (status == AUTH_FAILURE)\n\t\t    SET(auth->flags, FLAG_DISABLED);\n\t\telse if (status == AUTH_NONINTERACTIVE)\n\t\t    goto done;\n\t\telse if (status != AUTH_SUCCESS || user_interrupted())\n\t\t    goto done;\t\t\/* assume error msg already printed *\/\n\t    }\n\t}\n\tif (num_methods == 0) {\n\t    audit_failure(ctx, ctx->runas.argv,\n\t\tN_(\"no authentication methods\"));\n\t    log_warningx(ctx, SLOG_SEND_MAIL,\n\t\tN_(\"Unable to initialize authentication methods.\"));\n\t    debug_return_int(-1);\n\t}\n\t    break;\n\tcase AUTH_INTR:\n\tcase AUTH_FAILURE:\n\t    if (ntries != 0)\n\t\tSET(validated, FLAG_BAD_PASSWORD);\n\t    log_auth_failure(ctx, validated, ntries);\n\t    ret = false;\n\t    break;\n\tcase AUTH_NONINTERACTIVE:\n\t    SET(validated, FLAG_NO_USER_INPUT);\n\t    FALLTHROUGH;\n\tdefault:\n\t    log_auth_failure(ctx, validated, 0);\n\t    ret = -1;\n\t    break;\n    }\n\n    debug_return_int(ret);\n}","target":0,"flaw_line_index":0,"hash":"66417ee8-26b6-48da-be13-0764094c2938","idx":"fc6f297e-e16b-4eef-ada6-1b1bba7bbe92"}
{"func_before":"forbidden_name(struct compiling *c, identifier name, const node *n,\n               int full_checks)\n{\n    assert(PyUnicode_Check(name));\n    if (PyUnicode_CompareWithASCIIString(name, \"__debug__\") == 0) {\n        ast_error(c, n, \"assignment to keyword\");\n        return 1;\n    }\n    if (full_checks) {\n        const char * const *p;\n        for (p = FORBIDDEN; *p; p++) {\n            if (PyUnicode_CompareWithASCIIString(name, *p) == 0) {\n                ast_error(c, n, \"assignment to keyword\");\n                return 1;\n            }\n        }\n    }\n    return 0;\n}","target":1,"flaw_line_index":0,"hash":"6a06d752-85c4-4b6b-aa12-c92e956306e3","idx":"9fe3bcc5-41a6-4ac5-bd0a-f515e131f82f"}
{"func_before":"forbidden_name(struct compiling *c, identifier name, const node *n,\n               int full_checks)\n{\n    assert(PyUnicode_Check(name));\n    if (_PyUnicode_EqualToASCIIString(name, \"__debug__\")) {\n        ast_error(c, n, \"assignment to keyword\");\n        return 1;\n    }\n    if (full_checks) {\n        const char * const *p;\n        for (p = FORBIDDEN; *p; p++) {\n            if (_PyUnicode_EqualToASCIIString(name, *p)) {\n                ast_error(c, n, \"assignment to keyword\");\n                return 1;\n            }\n        }\n    }\n    return 0;\n}","target":0,"flaw_line_index":0,"hash":"82d99669-94cf-45be-b36b-96d25b58cf50","idx":"bf992be8-a746-4ef1-9215-0f87b5a7f12e"}
{"func_before":"\t\t\toptions |= MBREX(regex_default_options);\n\t\t\tsyntax = MBREX(regex_default_syntax);\n\t\t}\n\t}\n\tif (Z_TYPE_PP(arg_pattern_zval) == IS_STRING) {\n\t\targ_pattern = Z_STRVAL_PP(arg_pattern_zval);\n\t\targ_pattern_len = Z_STRLEN_PP(arg_pattern_zval);\n\t} else {\n\t\t\/* FIXME: this code is not multibyte aware! *\/\n\t\tconvert_to_long_ex(arg_pattern_zval);\n\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\t\n\t\tpat_buf[1] = '\\0';\n\n\t\targ_pattern = pat_buf;\n\t\targ_pattern_len = 1;\t\n\t}\n\t\/* create regex pattern buffer *\/\n\tre = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);\n\tif (re == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (eval || is_callable) {\n\t\tpbuf = &eval_buf;\n\t\tdescription = zend_make_compiled_string_description(\"mbregex replace\" TSRMLS_CC);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsmart_str_appendl(pbuf, p, fwd);\n\t\t\t\t\t\tp += fwd;\n\t\t\t\t\t\ti += fwd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\tif (eval) {\n\t\t\t\tzval v;\n\t\t\t\t\/* null terminate buffer *\/\n\t\t\t\tsmart_str_0(&eval_buf);\n\t\t\t\t\/* do eval *\/\n\t\t\t\tif (zend_eval_stringl(eval_buf.c, eval_buf.len, &v, description TSRMLS_CC) == FAILURE) {\n\t\t\t\t\tefree(description);\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC,E_ERROR, \"Failed evaluating code: %s%s\", PHP_EOL, eval_buf.c);\n\t\t\t\t\t\/* zend_error() does not return in this case *\/\n\t\t\t\t}\n\n\t\t\t\t\/* result of eval *\/\n\t\t\t\tconvert_to_string(&v);\n\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL(v), Z_STRLEN(v));\n\t\t\t\t\/* Clean up *\/\n\t\t\t\teval_buf.len = 0;\n\t\t\t\tzval_dtor(&v);\n\t\t\t} else if (is_callable) {\n\t\t\t\tzval *retval_ptr;\n\t\t\t\tzval **args[1];\n\t\t\t\tzval *subpats;\n\t\t\t\tint i;\n\t\t\t\t\n\t\t\t\tMAKE_STD_ZVAL(subpats);\n\t\t\t\tarray_init(subpats);\n\t\t\t\t\n\t\t\t\tfor (i = 0; i < regs->num_regs; i++) {\n\t\t\t\t\tadd_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);\n\t\t\t\t}\t\t\t\t\n\t\t\t\t\n\t\t\t\targs[0] = &subpats;\n\t\t\t\t\/* null terminate buffer *\/\n\t\t\t\tsmart_str_0(&eval_buf);\n\t\t\t\t\n\t\t\t\targ_replace_fci.param_count = 1;\n\t\t\t\targ_replace_fci.params = args;\n\t\t\t\targ_replace_fci.retval_ptr_ptr = &retval_ptr;\n\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {\n\t\t\t\t\tconvert_to_string_ex(&retval_ptr);\n\t\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));\n\t\t\t\t\teval_buf.len = 0;\n\t\t\t\t\tzval_ptr_dtor(&retval_ptr);\n\t\t\t\t} else {\n\t\t\t\t\tefree(description);\n\t\t\t\t\tif (!EG(exception)) {\n\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call custom replacement function\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tzval_ptr_dtor(&subpats);\n\t\t\t}\n\n\t\t\tn = regs->end[0];\n\t\t\tif ((pos - (OnigUChar *)string) < n) {\n\t\t\t\tpos = (OnigUChar *)string + n;\n\t\t\t} else {\n\t\t\t\tif (pos < string_lim) {\n\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1); \n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t} else { \/* nomatch *\/\n\t\t\t\/* stick that last bit of string on our output *\/\n\t\t\tif (string_lim - pos > 0) {\n\t\t\t\tsmart_str_appendl(&out_buf, pos, string_lim - pos);\n\t\t\t}\n\t\t}\n\t\tonig_region_free(regs, 0);\n\n\tif (description) {\n\t\tefree(description);\n\t}\n\tif (regs != NULL) {\n\t\tonig_region_free(regs, 1);\n\t}\n\tsmart_str_free(&eval_buf);\n\n\tif (err <= -2) {\n\t\tsmart_str_free(&out_buf);\t\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tsmart_str_appendc(&out_buf, '\\0');\n\t\tRETVAL_STRINGL((char *)out_buf.c, out_buf.len - 1, 0);\n\t}\n}","target":1,"flaw_line_index":0,"hash":"e1a59489-dfd5-452b-b72b-bf633c94ed33","idx":"0c4d7a4c-edb2-4270-9912-53465de54247"}
{"func_before":"\t\t\toptions |= MBREX(regex_default_options);\n\t\t\tsyntax = MBREX(regex_default_syntax);\n\t\t}\n\t}\n\tif (Z_TYPE_PP(arg_pattern_zval) == IS_STRING) {\n\t\targ_pattern = Z_STRVAL_PP(arg_pattern_zval);\n\t\targ_pattern_len = Z_STRLEN_PP(arg_pattern_zval);\n\t} else {\n\t\t\/* FIXME: this code is not multibyte aware! *\/\n\t\tconvert_to_long_ex(arg_pattern_zval);\n\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\n\t\tpat_buf[1] = '\\0';\n\n\t\targ_pattern = pat_buf;\n\t\targ_pattern_len = 1;\n\t}\n\t\/* create regex pattern buffer *\/\n\tre = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);\n\tif (re == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (eval || is_callable) {\n\t\tpbuf = &eval_buf;\n\t\tdescription = zend_make_compiled_string_description(\"mbregex replace\" TSRMLS_CC);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsmart_str_appendl(pbuf, p, fwd);\n\t\t\t\t\t\tp += fwd;\n\t\t\t\t\t\ti += fwd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (eval) {\n\t\t\t\tzval v;\n\t\t\t\t\/* null terminate buffer *\/\n\t\t\t\tsmart_str_0(&eval_buf);\n\t\t\t\t\/* do eval *\/\n\t\t\t\tif (zend_eval_stringl(eval_buf.c, eval_buf.len, &v, description TSRMLS_CC) == FAILURE) {\n\t\t\t\t\tefree(description);\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC,E_ERROR, \"Failed evaluating code: %s%s\", PHP_EOL, eval_buf.c);\n\t\t\t\t\t\/* zend_error() does not return in this case *\/\n\t\t\t\t}\n\n\t\t\t\t\/* result of eval *\/\n\t\t\t\tconvert_to_string(&v);\n\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL(v), Z_STRLEN(v));\n\t\t\t\t\/* Clean up *\/\n\t\t\t\teval_buf.len = 0;\n\t\t\t\tzval_dtor(&v);\n\t\t\t} else if (is_callable) {\n\t\t\t\tzval *retval_ptr = NULL;\n\t\t\t\tzval **args[1];\n\t\t\t\tzval *subpats;\n\t\t\t\tint i;\n\n\t\t\t\tMAKE_STD_ZVAL(subpats);\n\t\t\t\tarray_init(subpats);\n\n\t\t\t\tfor (i = 0; i < regs->num_regs; i++) {\n\t\t\t\t\tadd_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);\n\t\t\t\t}\n\n\t\t\t\targs[0] = &subpats;\n\t\t\t\t\/* null terminate buffer *\/\n\t\t\t\tsmart_str_0(&eval_buf);\n\n\t\t\t\targ_replace_fci.param_count = 1;\n\t\t\t\targ_replace_fci.params = args;\n\t\t\t\targ_replace_fci.retval_ptr_ptr = &retval_ptr;\n\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {\n\t\t\t\t\tconvert_to_string_ex(&retval_ptr);\n\t\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));\n\t\t\t\t\teval_buf.len = 0;\n\t\t\t\t\tzval_ptr_dtor(&retval_ptr);\n\t\t\t\t} else {\n\t\t\t\t\tif (!EG(exception)) {\n\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call custom replacement function\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tzval_ptr_dtor(&subpats);\n\t\t\t}\n\n\t\t\tn = regs->end[0];\n\t\t\tif ((pos - (OnigUChar *)string) < n) {\n\t\t\t\tpos = (OnigUChar *)string + n;\n\t\t\t} else {\n\t\t\t\tif (pos < string_lim) {\n\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1);\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t} else { \/* nomatch *\/\n\t\t\t\/* stick that last bit of string on our output *\/\n\t\t\tif (string_lim - pos > 0) {\n\t\t\t\tsmart_str_appendl(&out_buf, pos, string_lim - pos);\n\t\t\t}\n\t\t}\n\t\tonig_region_free(regs, 0);\n\n\tif (description) {\n\t\tefree(description);\n\t}\n\tif (regs != NULL) {\n\t\tonig_region_free(regs, 1);\n\t}\n\tsmart_str_free(&eval_buf);\n\n\tif (err <= -2) {\n\t\tsmart_str_free(&out_buf);\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tsmart_str_appendc(&out_buf, '\\0');\n\t\tRETVAL_STRINGL((char *)out_buf.c, out_buf.len - 1, 0);\n\t}\n}","target":0,"flaw_line_index":0,"hash":"764c6fda-cc48-4bd2-bf2c-aa3fc7997110","idx":"4e7a6a1f-b28f-48bc-8409-37cbb9c4e31a"}
{"func_before":"\t\t\t\/\/ section for deletion - when it is a file\n\t\t\t\/\/ that got some data again. We can do it\n\t\t\t\/\/ because we only erase the files afterwards.\n\t\t\tdeleted_sections.erase (filename);\n\n\t\t\tif (!s.isDirty ()) {\n\t\t\t    y2debug (\"Skipping file %s that was not changed.\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\ts.initReadBy ();\n\t\t\t\/\/ ensure that the directories exist\n\t\t\tPathname pn (filename);\n\t\t\tPathInfo::assert_dir (pn.dirname ());\n\t\t\tofstream of(filename.c_str());\n\t\t\tif (!of.good())\n\t\t\t{\n\t\t\t    bugs++;\n\t\t\t    y2error (\"Can not open file %s for write\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\twrite_helper (s, of, 0);\n\t\t\ts.clean();\n\t\t\tof.close ();\n\t\t    }\n\t\telse\n\t\t    {\n\t\t\ty2error (\"Value %s encountered at multifile top level\",\n\t\t\t\t ci->e ().getName ());\n\t\t    }\n\t    }\n\n\t\/\/ FIXME: update time stamps of files...\n\n\t\/\/ erase removed files...\n\tfor (set<string>::iterator i = deleted_sections.begin (); i!=deleted_sections.end();i++)\n\t    if (multi_files.find (*i) != multi_files.end ()) {\n\t\ty2debug (\"Removing file %s\\n\", (*i).c_str());\n\t\tunlink ((*i).c_str());\n\t    }\n    }\n    else\n    {\n\t\/\/ ensure that the directories exist\n\tPathname pn (file);\n\tPathInfo::assert_dir (pn.dirname ());\n\tofstream of(file.c_str());\n\tif (!of.good())\n\t{\n\t    y2error (\"Can not open file %s for write\", file.c_str());\n\t    return -1;\n\t}\n\n\twrite_helper (inifile, of, 0);\n\n\tof.close();\n\ttimestamp = getTimeStamp ();\n    }\n    inifile.clean ();\n    return bugs ? -1 : 0;\n}","target":1,"flaw_line_index":0,"hash":"6da36bda-eccc-4f9d-8399-f77d91067e4f","idx":"4b3b7b38-3366-43f3-9593-931159a313bf"}
{"func_before":"\t\t\t\/\/ section for deletion - when it is a file\n\t\t\t\/\/ that got some data again. We can do it\n\t\t\t\/\/ because we only erase the files afterwards.\n\t\t\tdeleted_sections.erase (filename);\n\n\t\t\tif (!s.isDirty ()) {\n\t\t\t    y2debug (\"Skipping file %s that was not changed.\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\ts.initReadBy ();\n                        bugs += write_file(filename, s);\n\t\t    }\n\t\telse\n\t\t    {\n\t\t\ty2error (\"Value %s encountered at multifile top level\",\n\t\t\t\t ci->e ().getName ());\n\t\t    }\n\t    }\n\n\t\/\/ FIXME: update time stamps of files...\n\n\t\/\/ erase removed files...\n\tfor (set<string>::iterator i = deleted_sections.begin (); i!=deleted_sections.end();i++)\n\t    if (multi_files.find (*i) != multi_files.end ()) {\n\t\ty2debug (\"Removing file %s\\n\", (*i).c_str());\n\t\tunlink ((*i).c_str());\n\t    }\n    }\n    else\n    {\n        bugs += write_file(file, inifile);\n\ttimestamp = getTimeStamp ();\n    }\n    return bugs ? -1 : 0;\n}","target":0,"flaw_line_index":0,"hash":"e6d98c91-aff3-4546-993c-9575491ecee2","idx":"44031cd6-c26c-46c9-88f9-5e98ae29f332"}
{"func_before":"  *\/\n  buff_size= 33 + USERNAME_LENGTH + data_len + 9 + NAME_LEN + NAME_LEN + connect_attrs_len + 9;\n  buff= my_alloca(buff_size);\n\n  mysql->client_flag|= mysql->options.client_flag;\n  mysql->client_flag|= CLIENT_CAPABILITIES;\n\n  if (mysql->client_flag & CLIENT_MULTI_STATEMENTS)\n    mysql->client_flag|= CLIENT_MULTI_RESULTS;\n\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  if (mysql->options.ssl_key || mysql->options.ssl_cert ||\n      mysql->options.ssl_ca || mysql->options.ssl_capath ||\n      mysql->options.ssl_cipher ||\n      (mysql->options.extension && mysql->options.extension->ssl_crl) || \n      (mysql->options.extension && mysql->options.extension->ssl_crlpath))\n    mysql->options.use_ssl= 1;\n  if (mysql->options.use_ssl)\n    mysql->client_flag|= CLIENT_SSL;\n#endif \/* HAVE_OPENSSL && !EMBEDDED_LIBRARY*\/\n  if (mpvio->db)\n    mysql->client_flag|= CLIENT_CONNECT_WITH_DB;\n  else\n    mysql->client_flag&= ~CLIENT_CONNECT_WITH_DB;\n\n  \/* Remove options that server doesn't support *\/\n  mysql->client_flag= mysql->client_flag &\n                       (~(CLIENT_COMPRESS | CLIENT_SSL | CLIENT_PROTOCOL_41) \n                       | mysql->server_capabilities);\n    memset(buff+9, 0, 32-9);\n    end= buff+32;\n  }\n  else\n  {\n    int2store(buff, mysql->client_flag);\n    int3store(buff+2, net->max_packet_size);\n    end= buff+5;\n  }\n#ifdef HAVE_OPENSSL\n  if (mysql->client_flag & CLIENT_SSL)\n  {\n    \/* Do the SSL layering. *\/\n    struct st_mysql_options *options= &mysql->options;\n    struct st_VioSSLFd *ssl_fd;\n    enum enum_ssl_init_error ssl_init_error;\n    const char *cert_error;\n    unsigned long ssl_error;\n\n    \/*\n      Send mysql->client_flag, max_packet_size - unencrypted otherwise\n      the server does not know we want to do SSL\n    *\/\n    MYSQL_TRACE(SEND_SSL_REQUEST, mysql, (end - buff, (const unsigned char*)buff));\n    if (my_net_write(net, (uchar*)buff, (size_t) (end-buff)) || net_flush(net))\n    {\n      set_mysql_extended_error(mysql, CR_SERVER_LOST, unknown_sqlstate,\n                               ER(CR_SERVER_LOST_EXTENDED),\n    if ((mysql->client_flag & CLIENT_SSL_VERIFY_SERVER_CERT) &&\n        ssl_verify_server_cert(net->vio, mysql->host, &cert_error))\n    {\n      set_mysql_extended_error(mysql, CR_SSL_CONNECTION_ERROR, unknown_sqlstate,\n                               ER(CR_SSL_CONNECTION_ERROR), cert_error);\n      goto error;\n    }\n\n    MYSQL_TRACE(SSL_CONNECTED, mysql, ());\n    MYSQL_TRACE_STAGE(mysql, AUTHENTICATE);\n  }\n#endif \/* HAVE_OPENSSL *\/\n\n  DBUG_PRINT(\"info\",(\"Server version = '%s'  capabilites: %lu  status: %u  client_flag: %lu\",\n\t\t     mysql->server_version, mysql->server_capabilities,\n\t\t     mysql->server_status, mysql->client_flag));\n\n  compile_time_assert(MYSQL_USERNAME_LENGTH == USERNAME_LENGTH);\n\n  \/* This needs to be changed as it's not useful with big packets *\/\n  if (mysql->user[0])","target":1,"flaw_line_index":0,"hash":"36d09d20-2f06-467f-a855-e657b7cd30cf","idx":"0af52f13-1363-417c-8344-bbe02f751240"}
{"func_before":"  buff_size= 33 + USERNAME_LENGTH + data_len + 9 + NAME_LEN + NAME_LEN + connect_attrs_len + 9;\n  buff= my_alloca(buff_size);\n\n  mysql->client_flag|= mysql->options.client_flag;\n  mysql->client_flag|= CLIENT_CAPABILITIES;\n\n  if (mysql->client_flag & CLIENT_MULTI_STATEMENTS)\n    mysql->client_flag|= CLIENT_MULTI_RESULTS;\n\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  \/* consider SSL if any of the SSL mysql_options() is issued *\/\n  if (mysql->options.ssl_key || mysql->options.ssl_cert ||\n      mysql->options.ssl_ca || mysql->options.ssl_capath ||\n      mysql->options.ssl_cipher ||\n      (mysql->options.extension && mysql->options.extension->ssl_crl) ||\n      (mysql->options.extension && mysql->options.extension->ssl_crlpath) ||\n      (mysql->options.extension && mysql->options.extension->ssl_enforce))\n    mysql->options.use_ssl = TRUE;\n  if (mysql->options.use_ssl)\n    mysql->client_flag |= CLIENT_SSL;\n#endif \/* HAVE_OPENSSL && !EMBEDDED_LIBRARY*\/\n  if (mpvio->db)\n    mysql->client_flag|= CLIENT_CONNECT_WITH_DB;\n  else\n    mysql->client_flag&= ~CLIENT_CONNECT_WITH_DB;\n\n  \/* Remove options that server doesn't support *\/\n  mysql->client_flag= mysql->client_flag &\n                       (~(CLIENT_COMPRESS | CLIENT_SSL | CLIENT_PROTOCOL_41) \n                       | mysql->server_capabilities);\n    memset(buff+9, 0, 32-9);\n    end= buff+32;\n  }\n  else\n  {\n    int2store(buff, mysql->client_flag);\n    int3store(buff+2, net->max_packet_size);\n    end= buff+5;\n  }\n#ifdef HAVE_OPENSSL\n\n  if (mysql->options.extension && mysql->options.extension->ssl_enforce)\n  {\n    \/*\n      ssl_enforce=1 means enforce ssl\n      Don't fallback on unencrypted connection.\n    *\/\n    \/* can't turn enforce on without turning on use_ssl too *\/\n    DBUG_ASSERT(mysql->options.use_ssl);\n    \/* enforce=true takes precendence over use=false *\/\n    if (!(mysql->server_capabilities & CLIENT_SSL))\n    {\n      set_mysql_extended_error(mysql, CR_SSL_CONNECTION_ERROR, unknown_sqlstate,\n                               ER(CR_SSL_CONNECTION_ERROR),\n                               \"SSL is required but the server doesn't \"\n                               \"support it\"\n                               );\n      goto error;\n    }\n  }\n\n  \/*\n\n   use_ssl=0 => Disable ssl and connect using unencrypted channel if server\n     allows it\n\n   use_ssl=1, ssl_enforce=0 (default) => attempt ssl connection if possible but\n     fallback on unencrypted connection if possible.\n\n  *\/\n  if ((mysql->server_capabilities & CLIENT_SSL) && mysql->options.use_ssl)\n  {\n    \/* Do the SSL layering. *\/\n    struct st_mysql_options *options= &mysql->options;\n    struct st_VioSSLFd *ssl_fd;\n    enum enum_ssl_init_error ssl_init_error;\n    const char *cert_error;\n    unsigned long ssl_error;\n\n    if (!mysql->options.ssl_cipher)\n    {\n      SET_OPTION(ssl_cipher, default_ssl_cipher);\n    }\n\n    \/*\n      Send mysql->client_flag, max_packet_size - unencrypted otherwise\n      the server does not know we want to do SSL\n    *\/\n    MYSQL_TRACE(SEND_SSL_REQUEST, mysql, (end - buff, (const unsigned char*)buff));\n    if (my_net_write(net, (uchar*)buff, (size_t) (end-buff)) || net_flush(net))\n    {\n      set_mysql_extended_error(mysql, CR_SERVER_LOST, unknown_sqlstate,\n                               ER(CR_SERVER_LOST_EXTENDED),\n        ssl_verify_server_cert(net->vio, mysql->host, &cert_error))\n    {\n      set_mysql_extended_error(mysql, CR_SSL_CONNECTION_ERROR, unknown_sqlstate,\n                               ER(CR_SSL_CONNECTION_ERROR), cert_error);\n      goto error;\n    }\n\n    MYSQL_TRACE(SSL_CONNECTED, mysql, ());\n    MYSQL_TRACE_STAGE(mysql, AUTHENTICATE);\n  }\n\n#endif \/* HAVE_OPENSSL *\/\n\n  DBUG_PRINT(\"info\",(\"Server version = '%s'  capabilites: %lu  status: %u  client_flag: %lu\",\n\t\t     mysql->server_version, mysql->server_capabilities,\n\t\t     mysql->server_status, mysql->client_flag));\n\n  compile_time_assert(MYSQL_USERNAME_LENGTH == USERNAME_LENGTH);\n\n  \/* This needs to be changed as it's not useful with big packets *\/\n  if (mysql->user[0])","target":0,"flaw_line_index":0,"hash":"60fe8d18-0a9c-443d-b2e4-8d94d4d01162","idx":"fe223ad5-69ee-4f27-a983-c8bc07cc3087"}
{"func_before":"  lua_CFunction f;\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  \/* C closure *\/\n      f = clCvalue(s2v(func))->f;\n      goto Cfunc;\n    case LUA_VLCF:  \/* light C function *\/\n      f = fvalue(s2v(func));\n     Cfunc: {\n      int n;  \/* number of returns *\/\n      CallInfo *ci = next_ci(L);\n      checkstackp(L, LUA_MINSTACK, func);  \/* ensure minimum stack size *\/\n      ci->nresults = nresults;\n      ci->callstatus = CIST_C;\n      ci->top = L->top + LUA_MINSTACK;\n      ci->func = func;\n      L->ci = ci;\n      lua_assert(ci->top <= L->stack_last);\n      if (L->hookmask & LUA_MASKCALL) {\n        int narg = cast_int(L->top - func) - 1;\n        luaD_hook(L, LUA_HOOKCALL, -1, 1, narg);\n      }\n      lua_unlock(L);\n      n = (*f)(L);  \/* do the actual call *\/\n      lua_lock(L);\n      api_checknelems(L, n);\n      luaD_poscall(L, ci, n);\n      break;\n    }\n    case LUA_VLCL: {  \/* Lua function *\/\n      CallInfo *ci = next_ci(L);\n      Proto *p = clLvalue(s2v(func))->p;\n      int narg = cast_int(L->top - func) - 1;  \/* number of real arguments *\/\n      int nfixparams = p->numparams;\n      int fsize = p->maxstacksize;  \/* frame size *\/\n      checkstackp(L, fsize, func);\n      ci->nresults = nresults;\n      ci->u.l.savedpc = p->code;  \/* starting point *\/\n      ci->callstatus = 0;\n      ci->top = func + 1 + fsize;\n      ci->func = func;\n      L->ci = ci;\n      for (; narg < nfixparams; narg++)\n        setnilvalue(s2v(L->top++));  \/* complete missing arguments *\/\n      lua_assert(ci->top <= L->stack_last);\n      luaV_execute(L, ci);  \/* run the function *\/\n      break;\n    }\n    default: {  \/* not a function *\/\n      checkstackp(L, 1, func);  \/* space for metamethod *\/\n      luaD_tryfuncTM(L, func);  \/* try to get '__call' metamethod *\/\n      goto retry;  \/* try again with metamethod *\/\n    }\n  }\n}","target":1,"flaw_line_index":0,"hash":"966d1a1b-46df-45f5-b94c-5ced1a7706bb","idx":"61e26ed0-2418-4c02-bd2c-455f038e7a62"}
{"func_before":"  lua_CFunction f;\n retry:\n  switch (ttypetag(s2v(func))) {\n    case LUA_VCCL:  \/* C closure *\/\n      f = clCvalue(s2v(func))->f;\n      goto Cfunc;\n    case LUA_VLCF:  \/* light C function *\/\n      f = fvalue(s2v(func));\n     Cfunc: {\n      int n;  \/* number of returns *\/\n      CallInfo *ci;\n      checkstackGCp(L, LUA_MINSTACK, func);  \/* ensure minimum stack size *\/\n      L->ci = ci = next_ci(L);\n      ci->nresults = nresults;\n      ci->callstatus = CIST_C;\n      ci->top = L->top + LUA_MINSTACK;\n      ci->func = func;\n      lua_assert(ci->top <= L->stack_last);\n      if (L->hookmask & LUA_MASKCALL) {\n        int narg = cast_int(L->top - func) - 1;\n        luaD_hook(L, LUA_HOOKCALL, -1, 1, narg);\n      }\n      lua_unlock(L);\n      n = (*f)(L);  \/* do the actual call *\/\n      lua_lock(L);\n      api_checknelems(L, n);\n      luaD_poscall(L, ci, n);\n      break;\n    }\n    case LUA_VLCL: {  \/* Lua function *\/\n      CallInfo *ci;\n      Proto *p = clLvalue(s2v(func))->p;\n      int narg = cast_int(L->top - func) - 1;  \/* number of real arguments *\/\n      int nfixparams = p->numparams;\n      int fsize = p->maxstacksize;  \/* frame size *\/\n      checkstackGCp(L, fsize, func);\n      L->ci = ci = next_ci(L);\n      ci->nresults = nresults;\n      ci->u.l.savedpc = p->code;  \/* starting point *\/\n      ci->callstatus = 0;\n      ci->top = func + 1 + fsize;\n      ci->func = func;\n      L->ci = ci;\n      for (; narg < nfixparams; narg++)\n        setnilvalue(s2v(L->top++));  \/* complete missing arguments *\/\n      lua_assert(ci->top <= L->stack_last);\n      luaV_execute(L, ci);  \/* run the function *\/\n      break;\n    }\n    default: {  \/* not a function *\/\n      checkstackGCp(L, 1, func);  \/* space for metamethod *\/\n      luaD_tryfuncTM(L, func);  \/* try to get '__call' metamethod *\/\n      goto retry;  \/* try again with metamethod *\/\n    }\n  }\n}","target":0,"flaw_line_index":0,"hash":"d2cf67f6-cc60-4b11-a098-491cd2c643a0","idx":"f7aa89db-b4fd-4b8c-bc60-7912d91ddf5c"}
{"func_before":"                                          {batch_size}, &output_debug_info_t));\n    \/\/ Will contain serialized protos, per example.\n    auto output_debug_info = output_debug_info_t->flat<tstring>();\n    const int32 last_tree = resource->num_trees() - 1;\n\n    \/\/ For each given example, traverse through all trees keeping track of the\n    \/\/ features used to split and the associated logits at each point along the\n    \/\/ path. Note: feature_ids has one less value than logits_path because the\n    \/\/ first value of each logit path will be the bias.\n    auto do_work = [&resource, &bucketized_features, &output_debug_info,\n                    last_tree](int32 start, int32 end) {\n      for (int32 i = start; i < end; ++i) {\n        \/\/ Proto to store debug outputs, per example.\n        boosted_trees::DebugOutput example_debug_info;\n        \/\/ Initial bias prediction. E.g., prediction based off training mean.\n        const auto& tree_logits = resource->node_value(0, 0);\n        DCHECK_EQ(tree_logits.size(), 1);\n        float tree_logit = resource->GetTreeWeight(0) * tree_logits[0];\n        example_debug_info.add_logits_path(tree_logit);\n        int32 node_id = 0;\n        int32 tree_id = 0;","target":1,"flaw_line_index":0,"hash":"c40c1926-82af-4ade-a434-713633f168e5","idx":"add9c943-ecee-4617-8884-fda50afc5206"}
{"func_before":"                                          {batch_size}, &output_debug_info_t));\n    \/\/ Will contain serialized protos, per example.\n    auto output_debug_info = output_debug_info_t->flat<tstring>();\n    const int32 last_tree = resource->num_trees() - 1;\n\n    \/\/ For each given example, traverse through all trees keeping track of the\n    \/\/ features used to split and the associated logits at each point along the\n    \/\/ path. Note: feature_ids has one less value than logits_path because the\n    \/\/ first value of each logit path will be the bias.\n    auto do_work = [&resource, &bucketized_features, &output_debug_info,\n                    last_tree](int64 start, int64 end) {\n      for (int32 i = start; i < end; ++i) {\n        \/\/ Proto to store debug outputs, per example.\n        boosted_trees::DebugOutput example_debug_info;\n        \/\/ Initial bias prediction. E.g., prediction based off training mean.\n        const auto& tree_logits = resource->node_value(0, 0);\n        DCHECK_EQ(tree_logits.size(), 1);\n        float tree_logit = resource->GetTreeWeight(0) * tree_logits[0];\n        example_debug_info.add_logits_path(tree_logit);\n        int32 node_id = 0;\n        int32 tree_id = 0;","target":0,"flaw_line_index":0,"hash":"eab53fe5-06d4-4c2f-814b-a4ecbb48ecf2","idx":"6bbc037f-67af-4b3e-b334-8248246f65cd"}
{"func_before":"\n{\n    struct yyguts_t dummy_yyguts;\n\n    re_yyset_extra (yy_user_defined, &dummy_yyguts);\n\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n\t\n    *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n\t\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n    \n    \/* By setting to 0xAA, we expose bugs in\n    yy_init_globals. Leave at 0x00 for releases. *\/\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n    \n    re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n    \n    return yy_init_globals ( *ptr_yy_globals );","target":1,"flaw_line_index":0,"hash":"10beee34-ebcb-406e-8520-e6964b56b2de","idx":"3ba793a2-4e6d-493b-93cb-873d836ef547"}
{"func_before":"\n{\n    struct yyguts_t dummy_yyguts;\n\n    re_yyset_extra (yy_user_defined, &dummy_yyguts);\n\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n\n    *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n\n    \/* By setting to 0xAA, we expose bugs in\n    yy_init_globals. Leave at 0x00 for releases. *\/\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n\n    re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n\n    return yy_init_globals ( *ptr_yy_globals );","target":0,"flaw_line_index":0,"hash":"a3aa5a34-c8ce-46e0-b794-dfc424157826","idx":"d2e9a854-b4cf-401a-ba98-a47bf8cf9196"}
{"func_before":"\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tsize_t skblen;\n\tint err;\n\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\n\t\treturn err;\n\t}\n\n\tskblen = skb->len;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\n\t\tif (test_bit(BT_SK_PKT_STATUS, &bt_sk(sk)->flags)) {\n\t\t\tu8 pkt_status = hci_skb_pkt_status(skb);\n\n\t\t\tput_cmsg(msg, SOL_BLUETOOTH, BT_SCM_PKT_STATUS,\n\t\t\t\t sizeof(pkt_status), &pkt_status);\n\t\t}\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skblen;\n\n\treturn err ? : copied;\n}","target":1,"flaw_line_index":0,"hash":"2c236076-a478-4022-9b1d-d8b9aa5f0cf4","idx":"65893976-2ce5-473d-8f6c-da44e1a1c419"}
{"func_before":"\tstruct sk_buff *skb;\n\tsize_t copied;\n\tsize_t skblen;\n\tint err;\n\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tlock_sock(sk);\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\terr = 0;\n\n\t\trelease_sock(sk);\n\t\treturn err;\n\t}\n\n\tskblen = skb->len;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\n\t\tif (test_bit(BT_SK_PKT_STATUS, &bt_sk(sk)->flags)) {\n\t\t\tu8 pkt_status = hci_skb_pkt_status(skb);\n\n\t\t\tput_cmsg(msg, SOL_BLUETOOTH, BT_SCM_PKT_STATUS,\n\t\t\t\t sizeof(pkt_status), &pkt_status);\n\t\t}\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\trelease_sock(sk);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skblen;\n\n\treturn err ? : copied;\n}","target":0,"flaw_line_index":0,"hash":"87903b39-cfd1-45b4-a57a-2a589e7a1438","idx":"9e91d659-adae-4869-9dfe-352c2bf6a2dd"}
{"func_before":"            d = div_result.quotient;\n            div_result = d.divided_by(2);\n            ++r;\n        }\n    }\n    if (r == 0) {\n        \/\/ n - 1 is odd, so n was even. But there is only one even prime:\n        return n == 2;\n    }\n\n    for (auto a : tests) {\n        \/\/ Technically: ASSERT(2 <= a && a <= n - 2)\n        ASSERT(a < n);\n        auto x = ModularPower(a, d, n);\n        if (x == 1 || x == predecessor)\n            continue;\n        bool skip_this_witness = false;\n        \/\/ r − 1 iterations.\n        for (size_t i = 0; i < r - 1; ++i) {\n            x = ModularPower(x, 2, n);\n            if (x == predecessor) {","target":1,"flaw_line_index":0,"hash":"9a213059-5d02-4ab2-b232-362fe1116676","idx":"1cb4c02c-35b5-4d50-b77e-b88ade323bab"}
{"func_before":"            d = div_result.quotient;\n            div_result = d.divided_by(2);\n            ++r;\n        }\n    }\n    if (r == 0) {\n        \/\/ n - 1 is odd, so n was even. But there is only one even prime:\n        return n == 2;\n    }\n\n    for (auto& a : tests) {\n        \/\/ Technically: ASSERT(2 <= a && a <= n - 2)\n        ASSERT(a < n);\n        auto x = ModularPower(a, d, n);\n        if (x == 1 || x == predecessor)\n            continue;\n        bool skip_this_witness = false;\n        \/\/ r − 1 iterations.\n        for (size_t i = 0; i < r - 1; ++i) {\n            x = ModularPower(x, 2, n);\n            if (x == predecessor) {","target":0,"flaw_line_index":0,"hash":"e9800a4c-fa0c-4968-8398-55c8379590d6","idx":"74d82263-c980-45f0-8355-8ffb52f15fd0"}
{"func_before":"    all_nodes_.insert(std::make_pair(div_node->name(), div_node));\n    *apply_gradients_node->mutable_input(gradient_pos[apply_gradients_op]) =\n        div_node->name();\n  }\n  LOG(INFO) << \"Graph size after adding div nodes: \" << all_nodes_.size();\n\n  std::vector<const NodeDef*> train_nodes;\n  TF_RETURN_IF_ERROR(ComputeTransitiveFanin(graph_, item.fetch, &train_nodes));\n  LOG(INFO) << \"Number of training nodes: \" << train_nodes.size();\n\n  const NodeDef* dequeue_node;\n  for (const auto& train_node : train_nodes) {\n    if (IsDequeueOp(*train_node)) {\n      dequeue_node = train_node;\n      break;\n    }\n  }\n\n  std::vector<const NodeDef*> input_nodes;\n  if (dequeue_node) {\n    LOG(INFO) << \"Dequeue node: \" << dequeue_node->name();","target":1,"flaw_line_index":0,"hash":"b4104eb6-0619-4633-adb0-80ad287acfb1","idx":"5cae4cd5-c048-4f05-a405-4bc1d228fbee"}
{"func_before":"    all_nodes_.insert(std::make_pair(div_node->name(), div_node));\n    *apply_gradients_node->mutable_input(gradient_pos[apply_gradients_op]) =\n        div_node->name();\n  }\n  LOG(INFO) << \"Graph size after adding div nodes: \" << all_nodes_.size();\n\n  std::vector<const NodeDef*> train_nodes;\n  TF_RETURN_IF_ERROR(ComputeTransitiveFanin(graph_, item.fetch, &train_nodes));\n  LOG(INFO) << \"Number of training nodes: \" << train_nodes.size();\n\n  const NodeDef* dequeue_node = nullptr;\n  for (const auto& train_node : train_nodes) {\n    if (IsDequeueOp(*train_node)) {\n      dequeue_node = train_node;\n      break;\n    }\n  }\n\n  std::vector<const NodeDef*> input_nodes;\n  if (dequeue_node) {\n    LOG(INFO) << \"Dequeue node: \" << dequeue_node->name();","target":0,"flaw_line_index":0,"hash":"919fb830-d8ef-47e6-ba29-1695191b9777","idx":"008c8b47-c486-4641-8025-32872739f1a5"}
{"func_before":"\tif (fd >= fdt->max_fds)\n\t\tgoto out_unlock;\n\tfile = fdt->fd[fd];\n\tif (!file)\n\t\tgoto out_unlock;\n\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n\tget_file(file);\n\t*res = file;\n\treturn filp_close(file, files);\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\t*res = NULL;\n\treturn -ENOENT;\n}","target":1,"flaw_line_index":0,"hash":"c5be253a-acd6-45c4-8727-e36772c43cfc","idx":"eaa7a5f8-12f0-4269-a57c-1309c6c961b8"}
{"func_before":"\tif (fd >= fdt->max_fds)\n\t\tgoto out_unlock;\n\tfile = fdt->fd[fd];\n\tif (!file)\n\t\tgoto out_unlock;\n\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n\tget_file(file);\n\t*res = file;\n\treturn 0;\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\t*res = NULL;\n\treturn -ENOENT;\n}","target":0,"flaw_line_index":0,"hash":"dce7935e-dc08-4ff3-9836-61c212feaa9f","idx":"64482f07-ce9b-408b-baf4-8266f4d03de6"}
{"func_before":"ast_for_async_stmt(struct compiling *c, const node *n)\n{\n    \/* async_stmt: ASYNC (funcdef | with_stmt | for_stmt) *\/\n    REQ(n, async_stmt);\n    REQ(CHILD(n, 0), ASYNC);\n\n    switch (TYPE(CHILD(n, 1))) {\n        case funcdef:\n            return ast_for_funcdef_impl(c, CHILD(n, 1), NULL,\n                                        1 \/* is_async *\/);\n        case with_stmt:\n            return ast_for_with_stmt(c, CHILD(n, 1),\n                                     1 \/* is_async *\/);\n\n        case for_stmt:\n            return ast_for_for_stmt(c, CHILD(n, 1),\n                                    1 \/* is_async *\/);\n\n        default:\n            PyErr_Format(PyExc_SystemError,\n                         \"invalid async stament: %s\",\n                         STR(CHILD(n, 1)));\n            return NULL;\n    }\n}","target":1,"flaw_line_index":0,"hash":"b929e241-7c1e-41db-b7c0-06ba851b23e4","idx":"8066c532-c400-4ed6-bbb0-1f049d0c113c"}
{"func_before":"ast_for_async_stmt(struct compiling *c, const node *n)\n{\n    \/* async_stmt: 'async' (funcdef | with_stmt | for_stmt) *\/\n    REQ(n, async_stmt);\n    REQ(CHILD(n, 0), NAME);\n    assert(strcmp(STR(CHILD(n, 0)), \"async\") == 0);\n\n    switch (TYPE(CHILD(n, 1))) {\n        case funcdef:\n            return ast_for_funcdef_impl(c, n, NULL,\n                                        true \/* is_async *\/);\n        case with_stmt:\n            return ast_for_with_stmt(c, n,\n                                     true \/* is_async *\/);\n\n        case for_stmt:\n            return ast_for_for_stmt(c, n,\n                                    true \/* is_async *\/);\n\n        default:\n            PyErr_Format(PyExc_SystemError,\n                         \"invalid async stament: %s\",\n                         STR(CHILD(n, 1)));\n            return NULL;\n    }\n}","target":0,"flaw_line_index":0,"hash":"d71dd7c4-e018-40a5-bf37-113fb149170f","idx":"b151f934-6edd-446a-9bcf-802211ad6363"}
{"func_before":"\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tvoid *kbuf;\n\tint ret;\n\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\n\tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_kbuf;\n\t}\n\n\tif (!eptdev->ept) {\n\t\tret = -EPIPE;\n\t\tgoto unlock_eptdev;\n\t}","target":1,"flaw_line_index":0,"hash":"2bf0c6b8-f04e-49fd-9d94-7f787b62399a","idx":"569c0c18-6ede-4ed3-9aed-995e1ffeb346"}
{"func_before":"\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tvoid *kbuf;\n\tint ret;\n\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from)) {\n\t\tret = -EFAULT;\n\t\tgoto free_kbuf;\n\t}\n\n\tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_kbuf;\n\t}\n\n\tif (!eptdev->ept) {\n\t\tret = -EPIPE;\n\t\tgoto unlock_eptdev;\n\t}","target":0,"flaw_line_index":0,"hash":"691a3912-f3c2-4d62-bf79-06b6fd285cda","idx":"e43678b1-0cf9-4386-9131-6f1d88d6b923"}
{"func_before":"net_bind(short unsigned *port, int type, const char *log_service_name)\n{\n  struct addrinfo hints = { 0 };\n  struct addrinfo *servinfo;\n  struct addrinfo *ptr;\n  const char *cfgaddr;\n  char addr[INET6_ADDRSTRLEN];\n  char strport[8];\n  int yes = 1;\n  int no = 0;\n  int fd;\n  int ret;\n\n  cfgaddr = cfg_getstr(cfg_getsec(cfg, \"general\"), \"bind_address\");\n\n    }\n\n  freeaddrinfo(servinfo);\n\n  if (!ptr)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not create service '%s' with address %s, port %hu: %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", *port, strerror(errno));\n      goto error;\n    }\n\n  \/\/ Get the port that was assigned\n  ret = getsockname(fd, ptr->ai_addr, &ptr->ai_addrlen);\n  if (ret < 0)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not find address of service '%s': %s\\n\", log_service_name, strerror(errno));\n      goto error;\n    }\n\n  net_port_get(port, (union net_sockaddr *)ptr->ai_addr);\n  net_address_get(addr, sizeof(addr), (union net_sockaddr *)ptr->ai_addr);\n\n  DPRINTF(E_DBG, L_MISC, \"Service '%s' bound to %s, port %hu, socket %d\\n\", log_service_name, addr, *port, fd);\n\n  return fd;\n\n error:\n  close(fd);\n  return -1;\n}","target":1,"flaw_line_index":0,"hash":"6df122dc-3e20-4c12-952f-643638825db9","idx":"24e26fb0-0a6e-4ce4-97ca-c4f84a19b3b4"}
{"func_before":"net_bind(short unsigned *port, int type, const char *log_service_name)\n{\n  struct addrinfo hints = { 0 };\n  struct addrinfo *servinfo;\n  struct addrinfo *ptr;\n  union net_sockaddr naddr = { 0 };\n  socklen_t naddr_len = sizeof(naddr);\n  const char *cfgaddr;\n  char addr[INET6_ADDRSTRLEN];\n  char strport[8];\n  int yes = 1;\n  int no = 0;\n  int fd;\n  int ret;\n\n  cfgaddr = cfg_getstr(cfg_getsec(cfg, \"general\"), \"bind_address\");\n\n    }\n\n  freeaddrinfo(servinfo);\n\n  if (!ptr)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not create service '%s' with address %s, port %hu: %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", *port, strerror(errno));\n      goto error;\n    }\n\n  \/\/ Get our address (as string) and the port that was assigned (necessary when\n  \/\/ caller didn't specify a port)\n  ret = getsockname(fd, &naddr.sa, &naddr_len);\n  if (ret < 0)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Error finding address of service '%s': %s\\n\", log_service_name, strerror(errno));\n      goto error;\n    }\n  else if (naddr_len > sizeof(naddr))\n    {\n      DPRINTF(E_LOG, L_MISC, \"Unexpected address length of service '%s'\\n\", log_service_name);\n      goto error;\n    }\n\n  net_port_get(port, &naddr);\n  net_address_get(addr, sizeof(addr), &naddr);\n\n  DPRINTF(E_DBG, L_MISC, \"Service '%s' bound to %s, port %hu, socket %d\\n\", log_service_name, addr, *port, fd);\n\n  return fd;\n\n error:\n  close(fd);\n  return -1;\n}","target":0,"flaw_line_index":0,"hash":"76ea9fb4-4597-44ec-9593-0a7e02f264e0","idx":"ab6b0788-4e71-4d22-810b-d54f533c0fe7"}
{"func_before":"void TPUPartitionedCallOp::ExecuteFunctions(\n    const std::vector<DeviceAndFHandle>& functions, OpKernelContext* ctx,\n    int device_ordinal, int64_t ordinal_selector_req_id, DoneCallback done) {\n  profiler::TraceMe trace_me(\"TPUPartitionedCallOp-ExecuteFunctions\");\n  FunctionLibraryRuntime::Options opts;\n  opts.step_container = ctx->step_container();\n  opts.stats_collector = ctx->stats_collector();\n  \/\/ TODO(akshayka): Consider selecting a runner on a per-device basis,\n  \/\/ i.e., using device-specific threadpools when available.\n  opts.runner = ctx->runner();\n  opts.source_device = local_device_name_;\n  opts.run_all_kernels_inline = ctx->run_all_kernels_inline();\n\n  OpInputList arguments;\n  OP_REQUIRES_OK_ASYNC(ctx, ctx->input_list(\"args\", &arguments), done);","target":1,"flaw_line_index":0,"hash":"41d9fb72-c69a-422d-97a6-11136de33378","idx":"42dd10e8-591b-4902-a4b9-bb5058ea8348"}
{"func_before":"void TPUPartitionedCallOp::ExecuteFunctions(\n    const std::vector<DeviceAndFHandle>& functions, OpKernelContext* ctx,\n    int device_ordinal, int64_t ordinal_selector_req_id, DoneCallback done) {\n  profiler::TraceMe trace_me(\"TPUPartitionedCallOp-ExecuteFunctions\");\n  FunctionLibraryRuntime::Options opts(ctx->step_id());\n  opts.step_container = ctx->step_container();\n  opts.stats_collector = ctx->stats_collector();\n  \/\/ TODO(akshayka): Consider selecting a runner on a per-device basis,\n  \/\/ i.e., using device-specific threadpools when available.\n  opts.runner = ctx->runner();\n  opts.source_device = local_device_name_;\n  opts.run_all_kernels_inline = ctx->run_all_kernels_inline();\n\n  OpInputList arguments;\n  OP_REQUIRES_OK_ASYNC(ctx, ctx->input_list(\"args\", &arguments), done);","target":0,"flaw_line_index":0,"hash":"fdf948d7-8fb5-40fd-bab2-e270de950244","idx":"ecda51fe-8cc9-44c3-a3a3-0207362b4d57"}
{"func_before":"ast_for_for_stmt(struct compiling *c, const node *n0, bool is_async)\n{\n    const node * const n = is_async ? CHILD(n0, 1) : n0;\n    asdl_seq *_target, *seq = NULL, *suite_seq;\n    expr_ty expression;\n    expr_ty target, first;\n    const node *node_target;\n    int end_lineno, end_col_offset;\n    \/* for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite] *\/\n    REQ(n, for_stmt);\n\n    if (NCH(n) == 9) {\n        seq = ast_for_suite(c, CHILD(n, 8));\n        if (!seq)\n            return NULL;\n    }\n\n    node_target = CHILD(n, 1);\n    _target = ast_for_exprlist(c, node_target, Store);\n    if (!_target)\n        return NULL;\n    \/* Check the # of children rather than the length of _target, since\n       for x, in ... has 1 element in _target, but still requires a Tuple. *\/\n    if (NCH(node_target) == 1)\n        target = first;\n    else\n        target = Tuple(_target, Store, first->lineno, first->col_offset,\n                       node_target->n_end_lineno, node_target->n_end_col_offset,\n                       c->c_arena);\n\n    expression = ast_for_testlist(c, CHILD(n, 3));\n    if (!expression)\n        return NULL;\n    suite_seq = ast_for_suite(c, CHILD(n, 5));\n    if (!suite_seq)\n        return NULL;\n\n    if (seq != NULL) {\n        get_last_end_pos(seq, &end_lineno, &end_col_offset);\n    } else {\n        get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n    }\n    if (is_async)\n        return AsyncFor(target, expression, suite_seq, seq,\n                        LINENO(n0), n0->n_col_offset,\n                        end_lineno, end_col_offset, c->c_arena);\n    else\n        return For(target, expression, suite_seq, seq,\n                   LINENO(n), n->n_col_offset,\n                   end_lineno, end_col_offset, c->c_arena);\n}","target":1,"flaw_line_index":0,"hash":"860f4e75-829c-4a91-b73d-dc4b78569cc3","idx":"9ec08e7b-696d-4ead-9feb-2502a9f00028"}
{"func_before":"ast_for_for_stmt(struct compiling *c, const node *n0, bool is_async)\n{\n    const node * const n = is_async ? CHILD(n0, 1) : n0;\n    asdl_seq *_target, *seq = NULL, *suite_seq;\n    expr_ty expression;\n    expr_ty target, first;\n    const node *node_target;\n    int end_lineno, end_col_offset;\n    int has_type_comment;\n    string type_comment;\n    \/* for_stmt: 'for' exprlist 'in' testlist ':' [TYPE_COMMENT] suite ['else' ':' suite] *\/\n    REQ(n, for_stmt);\n\n    has_type_comment = TYPE(CHILD(n, 5)) == TYPE_COMMENT;\n\n    if (NCH(n) == 9 + has_type_comment) {\n        seq = ast_for_suite(c, CHILD(n, 8 + has_type_comment));\n        if (!seq)\n            return NULL;\n    }\n\n    node_target = CHILD(n, 1);\n    _target = ast_for_exprlist(c, node_target, Store);\n    if (!_target)\n        return NULL;\n    \/* Check the # of children rather than the length of _target, since\n       for x, in ... has 1 element in _target, but still requires a Tuple. *\/\n    if (NCH(node_target) == 1)\n        target = first;\n    else\n        target = Tuple(_target, Store, first->lineno, first->col_offset,\n                       node_target->n_end_lineno, node_target->n_end_col_offset,\n                       c->c_arena);\n\n    expression = ast_for_testlist(c, CHILD(n, 3));\n    if (!expression)\n        return NULL;\n    suite_seq = ast_for_suite(c, CHILD(n, 5 + has_type_comment));\n    if (!suite_seq)\n        return NULL;\n\n    if (seq != NULL) {\n        get_last_end_pos(seq, &end_lineno, &end_col_offset);\n    } else {\n        get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n    }\n\n    if (has_type_comment) {\n        type_comment = NEW_TYPE_COMMENT(CHILD(n, 5));\n        if (!type_comment)\n            return NULL;\n    }\n    else\n        type_comment = NULL;\n\n    if (is_async)\n        return AsyncFor(target, expression, suite_seq, seq, type_comment,\n                        LINENO(n0), n0->n_col_offset,\n                        end_lineno, end_col_offset, c->c_arena);\n    else\n        return For(target, expression, suite_seq, seq, type_comment,\n                   LINENO(n), n->n_col_offset,\n                   end_lineno, end_col_offset, c->c_arena);\n}","target":0,"flaw_line_index":0,"hash":"6347d4d0-58f4-4bff-9c2e-afac76e084c9","idx":"5915ffc7-a2b9-406d-b773-5200af4c7be0"}
{"func_before":"              fclose(file2);\n\n            if (file1)\n              fclose(file1);\n          }\n          else\n          {\n            ismatch = 1;\n          }\n\n          if (ismatch && remove(groups[g].files[f].file->d_name) == 0)\n          {\n            set_file_action(&groups[g].files[f], FILEACTION_DELIST, deletiontally);\n\n            deletedbytes += groups[g].files[f].file->size;\n            ++totaldeleted;\n\n            if (loginfo)\n              log_file_deleted(loginfo, groups[g].files[f].file->d_name);\n          }\n          else","target":1,"flaw_line_index":0,"hash":"ef2bb7a0-1fed-421e-b456-0f1c34e2667d","idx":"e21251d0-ee06-4dbc-b423-96bb44f16865"}
{"func_before":"              fclose(file2);\n\n            if (file1)\n              fclose(file1);\n          }\n          else\n          {\n            ismatch = 1;\n          }\n\n          if (ismatch && removeifnotchanged(groups[g].files[f].file, 0) == 0)\n          {\n            set_file_action(&groups[g].files[f], FILEACTION_DELIST, deletiontally);\n\n            deletedbytes += groups[g].files[f].file->size;\n            ++totaldeleted;\n\n            if (loginfo)\n              log_file_deleted(loginfo, groups[g].files[f].file->d_name);\n          }\n          else","target":0,"flaw_line_index":0,"hash":"d4f219d2-4be5-45a4-90c2-b860731fb3a8","idx":"3eb13050-32a4-4de3-8917-ff7db43da89b"}
{"func_before":"    }\n    printf(\"Media byte 0x%02x (%s)\\n\", b->media, get_media_descr(b->media));\n    printf(\"%10d bytes per logical sector\\n\", GET_UNALIGNED_W(b->sector_size));\n    printf(\"%10d bytes per cluster\\n\", fs->cluster_size);\n    printf(\"%10d reserved sector%s\\n\", le16toh(b->reserved),\n\t   le16toh(b->reserved) == 1 ? \"\" : \"s\");\n    printf(\"First FAT starts at byte %llu (sector %llu)\\n\",\n\t   (unsigned long long)fs->fat_start,\n\t   (unsigned long long)fs->fat_start \/ lss);\n    printf(\"%10d FATs, %d bit entries\\n\", b->fats, fs->fat_bits);\n    printf(\"%10d bytes per FAT (= %u sectors)\\n\", fs->fat_size,\n\t   fs->fat_size \/ lss);\n    if (!fs->root_cluster) {\n\tprintf(\"Root directory starts at byte %llu (sector %llu)\\n\",\n\t       (unsigned long long)fs->root_start,\n\t       (unsigned long long)fs->root_start \/ lss);\n\tprintf(\"%10d root directory entries\\n\", fs->root_entries);\n    } else {\n\tprintf(\"Root directory start at cluster %lu (arbitrary size)\\n\",\n\t       (unsigned long)fs->root_cluster);\n    }\n    printf(\"Data area starts at byte %llu (sector %llu)\\n\",","target":1,"flaw_line_index":0,"hash":"64af8a80-d16d-476d-888a-f1e7bb07365d","idx":"6789522e-7992-4a75-9422-4c7454651ed6"}
{"func_before":"    }\n    printf(\"Media byte 0x%02x (%s)\\n\", b->media, get_media_descr(b->media));\n    printf(\"%10d bytes per logical sector\\n\", GET_UNALIGNED_W(b->sector_size));\n    printf(\"%10d bytes per cluster\\n\", fs->cluster_size);\n    printf(\"%10d reserved sector%s\\n\", le16toh(b->reserved),\n\t   le16toh(b->reserved) == 1 ? \"\" : \"s\");\n    printf(\"First FAT starts at byte %llu (sector %llu)\\n\",\n\t   (unsigned long long)fs->fat_start,\n\t   (unsigned long long)fs->fat_start \/ lss);\n    printf(\"%10d FATs, %d bit entries\\n\", b->fats, fs->fat_bits);\n    printf(\"%10lld bytes per FAT (= %llu sectors)\\n\", (long long)fs->fat_size,\n\t   (long long)fs->fat_size \/ lss);\n    if (!fs->root_cluster) {\n\tprintf(\"Root directory starts at byte %llu (sector %llu)\\n\",\n\t       (unsigned long long)fs->root_start,\n\t       (unsigned long long)fs->root_start \/ lss);\n\tprintf(\"%10d root directory entries\\n\", fs->root_entries);\n    } else {\n\tprintf(\"Root directory start at cluster %lu (arbitrary size)\\n\",\n\t       (unsigned long)fs->root_cluster);\n    }\n    printf(\"Data area starts at byte %llu (sector %llu)\\n\",","target":0,"flaw_line_index":0,"hash":"0a709f02-1f14-4e50-9b5f-bd2ccffb67cc","idx":"a99095bd-ad47-4cb0-a018-ce62438acb5a"}
{"func_before":"static void ep4_mul_sim_plain(ep4_t r, const ep4_t p, const bn_t k,\n\t\tconst ep4_t q, const bn_t m, ep4_t *t) {\n\tint i, l, l0, l1, n0, n1, w, gen;\n\tint8_t naf0[2 * RLC_FP_BITS + 1], naf1[2 * RLC_FP_BITS + 1], *_k, *_m;\n\tep4_t t0[1 << (EP_WIDTH - 2)];\n\tep4_t t1[1 << (EP_WIDTH - 2)];\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\t\tep4_null(t0[i]);\n\t\t\t\tep4_new(t0[i]);\n\t\t\t}\n\t\t\tep4_tab(t0, p, EP_WIDTH);\n\t\t\tt = (ep4_t *)t0;","target":1,"flaw_line_index":0,"hash":"68092cf8-8cdb-4e23-911b-da1d0f8a001b","idx":"554d94ac-de57-4431-8837-6954785cb1cd"}
{"func_before":"static void ep4_mul_sim_plain(ep4_t r, const ep4_t p, const bn_t k,\n\t\tconst ep4_t q, const bn_t m, ep4_t *t) {\n\tint i, n0, n1, w, gen;\n\tint8_t naf0[2 * RLC_FP_BITS + 1], naf1[2 * RLC_FP_BITS + 1], *_k, *_m;\n\tep4_t t0[1 << (EP_WIDTH - 2)];\n\tep4_t t1[1 << (EP_WIDTH - 2)];\n\tsize_t l, l0, l1;\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\t\tep4_null(t0[i]);\n\t\t\t\tep4_new(t0[i]);\n\t\t\t}\n\t\t\tep4_tab(t0, p, EP_WIDTH);\n\t\t\tt = (ep4_t *)t0;","target":0,"flaw_line_index":0,"hash":"bfaa08d9-7be7-47b3-9301-5127a2a97077","idx":"7b0bbea3-7788-4fe6-b447-68da47c7e9ae"}
{"func_before":"        (i + buffersStolen + 1 == count);\n    bytes = eorAwareSSLWrite(ssl_, sslWriteBuf, int(len), trackEor);\n\n    if (bytes <= 0) {\n      int error = SSL_get_error(ssl_.get(), int(bytes));\n      if (error == SSL_ERROR_WANT_WRITE) {\n        \/\/ The caller will register for write event if not already.\n        *partialWritten = uint32_t(offset);\n        return WriteResult(totalWritten);\n      }\n      auto writeResult = interpretSSLError(int(bytes), error);\n      if (writeResult.writeReturn < 0) {\n        return writeResult;\n      } \/\/ else fall through to below to correctly record totalWritten\n    }\n\n    totalWritten += bytes;\n\n    if (bytes == (ssize_t)len) {\n      \/\/ The full iovec is written.\n      (*countWritten) += 1 + buffersStolen;\n      i += buffersStolen;\n      \/\/ continue\n    } else {","target":1,"flaw_line_index":0,"hash":"4ec62de3-6e2e-4719-ac77-826fc15075ff","idx":"55f7e41c-8b61-4289-a3d2-7badf2c87966"}
{"func_before":"        (i + buffersStolen + 1 == count);\n    bytes = eorAwareSSLWrite(ssl_, sslWriteBuf, int(len), trackEor);\n\n    if (bytes <= 0) {\n      int error = SSL_get_error(ssl_.get(), int(bytes));\n      if (error == SSL_ERROR_WANT_WRITE) {\n        \/\/ The caller will register for write event if not already.\n        *partialWritten = uint32_t(offset);\n        return WriteResult(totalWritten);\n      }\n      return interpretSSLError(int(bytes), error);\n    }\n\n    totalWritten += bytes;\n\n    if (bytes == (ssize_t)len) {\n      \/\/ The full iovec is written.\n      (*countWritten) += 1 + buffersStolen;\n      i += buffersStolen;\n      \/\/ continue\n    } else {","target":0,"flaw_line_index":0,"hash":"a14cbda1-7832-4aee-a421-697eb6adedc0","idx":"c2800c3d-33fa-427c-86c2-1f1cd8b0b6e1"}
{"func_before":"\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\n\tif (url_len < 1)\n\t\treturn false;\n\n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n\n\tif (port_len) {\n\t\tchar *slash;\n\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '\/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");","target":1,"flaw_line_index":0,"hash":"e011fa38-a63e-4c24-91db-74bb034e150b","idx":"12dd8306-34df-4622-8bc4-881efa72c4bb"}
{"func_before":"\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\n\tif (url_len < 1)\n\t\treturn false;\n\n\tsnprintf(url_address, 254, \"%.*s\", url_len, url_begin);\n\n\tif (port_len) {\n\t\tchar *slash;\n\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '\/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");","target":0,"flaw_line_index":0,"hash":"d192c32b-ce42-4a28-8625-2d5db2ff112e","idx":"9c0a39f6-73ab-438a-ac28-3bc0acc476bf"}
{"func_before":"    \/\/ convention can be deprecated.\n    \/\/\n    \/\/ Note: While this code performs some basic verifications, it generally\n    \/\/ assumes consistent op defs and attributes. If more complete\n    \/\/ verifications are needed, they should be done by separately, and in a\n    \/\/ way that can be reused for type inference.\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        DCHECK(attr != nullptr);\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());\n          }\n\n        } else if (attr->value_case() == AttrValue::kType) {\n          map_dtype_to_tensor(attr->type(), arg);\n","target":1,"flaw_line_index":0,"hash":"dd43df8d-5c89-4273-9f31-8c76b5f4dcb1","idx":"17fc83b3-4392-495f-a92a-ab3b4fed6a90"}
{"func_before":"    \/\/ convention can be deprecated.\n    \/\/\n    \/\/ Note: While this code performs some basic verifications, it generally\n    \/\/ assumes consistent op defs and attributes. If more complete\n    \/\/ verifications are needed, they should be done by separately, and in a\n    \/\/ way that can be reused for type inference.\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        if (attr == nullptr) {\n          return Status(\n              error::INVALID_ARGUMENT,\n              absl::StrCat(\"Could not find an attribute for key \", arg->s()));\n        }\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());\n          }\n\n        } else if (attr->value_case() == AttrValue::kType) {\n          map_dtype_to_tensor(attr->type(), arg);\n","target":0,"flaw_line_index":0,"hash":"5d19931d-a914-422a-8ddc-ccef3b47a9e0","idx":"a2d4a1ed-6c83-4efa-a935-9f82e9b5f75c"}
{"func_before":"static void do_free_keypair(struct rsa_keypair *key)\n{\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->d);\n\tcrypto_bignum_free(key->n);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->q);\n\tcrypto_bignum_free(key->qp);\n\tcrypto_bignum_free(key->dp);\n\tcrypto_bignum_free(key->dq);\n}","target":1,"flaw_line_index":0,"hash":"1580b513-3284-46a5-81fa-d393e4d20469","idx":"0920b404-288f-43dd-9469-f7249c0347b5"}
{"func_before":"static void do_free_keypair(struct rsa_keypair *key)\n{\n\tcrypto_bignum_free(&key->e);\n\tcrypto_bignum_free(&key->d);\n\tcrypto_bignum_free(&key->n);\n\tcrypto_bignum_free(&key->p);\n\tcrypto_bignum_free(&key->q);\n\tcrypto_bignum_free(&key->qp);\n\tcrypto_bignum_free(&key->dp);\n\tcrypto_bignum_free(&key->dq);\n}","target":0,"flaw_line_index":0,"hash":"1ca06fff-8759-4b30-9957-31c2491d2a6e","idx":"202e70d1-f0a0-46e9-af24-1b8cb8dd1b33"}
{"func_before":"int xmkstemp(char **tmpname, char *dir)\n{\n\tchar *localtmp;\n\tchar *tmpenv;\n\tmode_t old_mode;\n\tint fd, rc;\n\n\t\/* Some use cases must be capable of being moved atomically\n\t * with rename(2), which is the reason why dir is here.  *\/\n\tif (dir != NULL)\n\t\ttmpenv = dir;\n\telse\n\t\ttmpenv = getenv(\"TMPDIR\");\n\n\tif (tmpenv)\n\t\trc = asprintf(&localtmp, \"%s\/%s.XXXXXX\", tmpenv,\n\t\t\t  program_invocation_short_name);\n\telse\n\t\trc = asprintf(&localtmp, \"%s\/%s.XXXXXX\", _PATH_TMP,\n\t\t\t  program_invocation_short_name);\n\n\tif (rc < 0)\n\t\treturn -1;\n\n\told_mode = umask(077);\n\tfd = mkostemp(localtmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);\n\tumask(old_mode);\n\tif (fd == -1) {\n\t\tfree(localtmp);\n\t\tlocaltmp = NULL;\n\t}","target":1,"flaw_line_index":0,"hash":"844c5926-f1b5-40b8-8378-5bd976a525fa","idx":"1df626ba-17ab-4bac-9295-6cd5dbea56a9"}
{"func_before":"int xmkstemp(char **tmpname, const char *dir, const char *prefix)\n{\n\tchar *localtmp;\n\tconst char *tmpenv;\n\tmode_t old_mode;\n\tint fd, rc;\n\n\t\/* Some use cases must be capable of being moved atomically\n\t * with rename(2), which is the reason why dir is here.  *\/\n\ttmpenv = dir ? dir : getenv(\"TMPDIR\");\n\tif (!tmpenv)\n\t\ttmpenv = _PATH_TMP;\n\n\trc = asprintf(&localtmp, \"%s\/%s.XXXXXX\", tmpenv, prefix);\n\tif (rc < 0)\n\t\treturn -1;\n\n\told_mode = umask(077);\n\tfd = mkostemp(localtmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);\n\tumask(old_mode);\n\tif (fd == -1) {\n\t\tfree(localtmp);\n\t\tlocaltmp = NULL;\n\t}","target":0,"flaw_line_index":0,"hash":"5b2ce325-8d48-476b-994f-8abd48fd65ce","idx":"bc591ad2-effd-4ad5-ac9a-02bde9694d80"}
{"func_before":"const char* Jsi_ValueToString(Jsi_Interp *interp, Jsi_Value *v, int *lenPtr)\n{\n    Jsi_Number d;\n    const char *ntxt = \"undefined\";\n    int kflag = 1;\n    int isKey = 0;\n    char *key = NULL;\n    if (!v)\n        goto done;\n    if (lenPtr) *lenPtr = 0;\n    char unibuf[200];\n    switch(v->vt) {\n        case JSI_VT_STRING:\n            ntxt = v->d.s.str;\n            goto done;\n        case JSI_VT_UNDEF:\n            break;\n        case JSI_VT_BOOL:\n            ntxt = v->d.val ? \"true\":\"false\";\n            break;\n        case JSI_VT_NULL:","target":1,"flaw_line_index":0,"hash":"b2f7ee7c-bf78-4324-a2ae-ec8a05783c6e","idx":"b944d272-bfd6-4fd3-a9ef-711e33b04020"}
{"func_before":"const char* Jsi_ValueToString(Jsi_Interp *interp, Jsi_Value *v, int *lenPtr)\n{\n    Jsi_Number d;\n    const char *ntxt = \"undefined\";\n    int kflag = 1;\n    int isKey = 0;\n    char *key = NULL;\n    if (!v)\n        goto done;\n    if (lenPtr) *lenPtr = 0;\n    char unibuf[JSI_MAX_NUMBER_STRING*2];\n    switch(v->vt) {\n        case JSI_VT_STRING:\n            ntxt = v->d.s.str;\n            goto done;\n        case JSI_VT_UNDEF:\n            break;\n        case JSI_VT_BOOL:\n            ntxt = v->d.val ? \"true\":\"false\";\n            break;\n        case JSI_VT_NULL:","target":0,"flaw_line_index":0,"hash":"67c14096-41ed-4902-8480-80c08779f65c","idx":"0c7a53c5-bec2-407a-bf0c-ed021f9eb337"}
{"func_before":"\n\tlen = netlink_send(fd, message);\n\tif (len < 0) {\n\t\tsyslog(LOG_ERR, \"netlink_send failed; error:%d\", len);\n\t\tclose(fd);\n\t\texit(-1);\n\t}\n\n\tpfd.fd = fd;\n\n\twhile (1) {\n\t\tpfd.events = POLLIN;\n\t\tpfd.revents = 0;\n\t\tpoll(&pfd, 1, -1);\n\n\t\tlen = recv(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0);\n\n\t\tif (len < 0) {\n\t\t\tsyslog(LOG_ERR, \"recv failed; error:%d\", len);\n\t\t\tclose(fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tincoming_msg = (struct nlmsghdr *)kvp_recv_buffer;\n\t\tincoming_cn_msg = (struct cn_msg *)NLMSG_DATA(incoming_msg);\n\t\thv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data;\n\n\t\tswitch (hv_msg->kvp_hdr.operation) {\n\t\tcase KVP_OP_REGISTER:","target":1,"flaw_line_index":0,"hash":"74b3b605-e32a-4842-8621-ce379b75d864","idx":"154f4557-3eea-4c43-8a8d-0f65cfeeab83"}
{"func_before":"\tlen = netlink_send(fd, message);\n\tif (len < 0) {\n\t\tsyslog(LOG_ERR, \"netlink_send failed; error:%d\", len);\n\t\tclose(fd);\n\t\texit(-1);\n\t}\n\n\tpfd.fd = fd;\n\n\twhile (1) {\n\t\tstruct sockaddr *addr_p = (struct sockaddr *) &addr;\n\t\tsocklen_t addr_l = sizeof(addr);\n\t\tpfd.events = POLLIN;\n\t\tpfd.revents = 0;\n\t\tpoll(&pfd, 1, -1);\n\n\t\tlen = recvfrom(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0,\n\t\t\t\taddr_p, &addr_l);\n\n\t\tif (len < 0 || addr.nl_pid) {\n\t\t\tsyslog(LOG_ERR, \"recvfrom failed; pid:%u error:%d %s\",\n\t\t\t\t\taddr.nl_pid, errno, strerror(errno));\n\t\t\tclose(fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tincoming_msg = (struct nlmsghdr *)kvp_recv_buffer;\n\t\tincoming_cn_msg = (struct cn_msg *)NLMSG_DATA(incoming_msg);\n\t\thv_msg = (struct hv_kvp_msg *)incoming_cn_msg->data;\n\n\t\tswitch (hv_msg->kvp_hdr.operation) {\n\t\tcase KVP_OP_REGISTER:","target":0,"flaw_line_index":0,"hash":"35233d11-df06-4b46-8349-35e310e4e897","idx":"286dc2e9-d196-4525-8b7f-f2d537d83ec4"}
{"func_before":"static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si)\n{\n\ts32 pps_id;\n\n\t\/*s->current_picture.reference= h->nal_ref_idc != 0;*\/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif (pps_id > 255)\n\t\treturn -1;\n\tsi->pps = &avc->pps[pps_id];\n\tsi->pps->id = pps_id;\n\tif (!si->pps->slice_group_count)\n\t\treturn -2;\n\tsi->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT];\n\tif (!si->sps->log2_max_frame_num)\n\t\treturn -2;\n\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");","target":1,"flaw_line_index":0,"hash":"19bd88ab-0d75-4b25-8890-a525a968485c","idx":"e7863701-e271-42a2-bba6-443d8643c62b"}
{"func_before":"static s32 svc_parse_slice(GF_BitStream *bs, AVCState *avc, AVCSliceInfo *si)\n{\n\ts32 pps_id;\n\n\t\/*s->current_picture.reference= h->nal_ref_idc != 0;*\/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id > 255))\n\t\treturn -1;\n\tsi->pps = &avc->pps[pps_id];\n\tsi->pps->id = pps_id;\n\tif (!si->pps->slice_group_count)\n\t\treturn -2;\n\tsi->sps = &avc->sps[si->pps->sps_id + GF_SVC_SSPS_ID_SHIFT];\n\tif (!si->sps->log2_max_frame_num)\n\t\treturn -2;\n\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");","target":0,"flaw_line_index":0,"hash":"47d8eba1-7fec-4ff3-b524-4e83f3f11aac","idx":"632dca32-7ef7-4a72-8532-498872df80c5"}
{"func_before":"\t\n\t\/* Populate our address from the given *\/\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t\/* If this is a trunk, update it now *\/\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;","target":1,"flaw_line_index":0,"hash":"e63d9189-8cbc-40dd-a3d7-336e5a315984","idx":"030b8b50-1832-4e4e-8375-e2127659cf07"}
{"func_before":"\t\n\t\/* Populate our address from the given *\/\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t\/* If this is a trunk, update it now *\/\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;","target":0,"flaw_line_index":0,"hash":"aba278ac-d831-4265-a357-cc8fd295101f","idx":"435ed5bd-79a0-4972-aedb-8f2fbec52b9e"}
{"func_before":"    memset(&stt, 0, sizeof (StreamTcpThread));\n    memset(&tcph, 0, sizeof (TCPHdr));\n    FLOW_INITIALIZE(&f);\n    p->flow = &f;\n\n    StreamTcpUTInit(&stt.ra_ctx);\n    stream_config.async_oneside = TRUE;\n\n    tcph.th_win = htons(5480);\n    tcph.th_seq = htonl(10);\n    tcph.th_ack = htonl(11);\n    tcph.th_flags = TH_SYN;\n    p->tcph = &tcph;\n\n    FAIL_IF(StreamTcpPacket(&tv, p, &stt, &pq) == -1);\n\n    p->tcph->th_seq = htonl(11);\n    p->tcph->th_ack = htonl(11);\n    p->tcph->th_flags = TH_ACK;\n    p->flowflags = FLOW_PKT_TOSERVER;\n","target":1,"flaw_line_index":0,"hash":"f8e9bafb-98ae-4e8c-b0f9-b1bbd105815c","idx":"a173acaa-5bc9-469f-977f-7e553eb8b63c"}
{"func_before":"    memset(&stt, 0, sizeof (StreamTcpThread));\n    memset(&tcph, 0, sizeof (TCPHdr));\n    FLOW_INITIALIZE(&f);\n    p->flow = &f;\n\n    StreamTcpUTInit(&stt.ra_ctx);\n    stream_config.async_oneside = TRUE;\n\n    tcph.th_win = htons(5480);\n    tcph.th_seq = htonl(10);\n    tcph.th_ack = 0;\n    tcph.th_flags = TH_SYN;\n    p->tcph = &tcph;\n\n    FAIL_IF(StreamTcpPacket(&tv, p, &stt, &pq) == -1);\n\n    p->tcph->th_seq = htonl(11);\n    p->tcph->th_ack = htonl(11);\n    p->tcph->th_flags = TH_ACK;\n    p->flowflags = FLOW_PKT_TOSERVER;\n","target":0,"flaw_line_index":0,"hash":"723cbc15-631c-4dc4-beda-da8e8537b59d","idx":"39c56a5b-011d-41f6-80ae-865a6e5197dc"}
{"func_before":"static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t\tunsigned int dataoff, unsigned int *timeouts)\n{\n\treturn true;\n}","target":1,"flaw_line_index":0,"hash":"4ab293d4-f22f-4455-89ee-4bd6d98b40ee","idx":"3eaa7201-dd66-41a0-addd-0542d8db175c"}
{"func_before":"static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t\tunsigned int dataoff, unsigned int *timeouts)\n{\n\treturn nf_generic_should_process(nf_ct_protonum(ct));\n}","target":0,"flaw_line_index":0,"hash":"ad1a4070-9a36-4632-81d0-62970fb7c9eb","idx":"54989ce3-7050-40b4-b814-0501e802dab9"}
{"func_before":"\tff = (float) (ff \/ FMAXINT); \/* shift radix point by 32 bits *\/\n\tf = (uint32_t) (ff * 1000000000.0);  \/* treat fraction as parts per\n\t\t\t\t\t\tbillion *\/\n\tND_PRINT(\"%u.%09d\", i, f);\n\n\t\/*\n\t * print the time in human-readable format.\n\t *\/\n\tif (i) {\n\t\ttime_t seconds = i - JAN_1970;\n\t\tstruct tm *tm;\n\t\tchar time_buf[128];\n\n\t\ttm = localtime(&seconds);\n\t\tstrftime(time_buf, sizeof (time_buf), \"%Y\/%m\/%d %H:%M:%S\", tm);\n\t\tND_PRINT(\" (%s)\", time_buf);\n\t}\n}","target":1,"flaw_line_index":0,"hash":"9d93051d-8c63-45e7-8a2f-4c8e573deab8","idx":"4b625154-39bb-4eb5-91e9-e784b2f3e92e"}
{"func_before":"\t\tff += FMAXINT;\n\tff = (float) (ff \/ FMAXINT); \/* shift radix point by 32 bits *\/\n\tf = (uint32_t) (ff * 1000000000.0);  \/* treat fraction as parts per\n\t\t\t\t\t\tbillion *\/\n\tND_PRINT(\"%u.%09d\", i, f);\n\n\t\/*\n\t * print the time in human-readable format.\n\t *\/\n\tif (i) {\n\t\ttime_t seconds = i - JAN_1970;\n\t\tchar time_buf[128];\n\n\t\tND_PRINT(\" (%s)\",\n\t\t    nd_format_time(time_buf, sizeof (time_buf), \"%Y\/%m\/%d %H:%M:%S\",\n\t\t      localtime(&seconds)));\n\t}\n}","target":0,"flaw_line_index":0,"hash":"9fc59be9-c1d9-4de9-b3b8-bab4c2bf0ec6","idx":"2d154146-0491-45df-867a-bef82d39839a"}
{"func_before":"static int snd_timer_start_slave(struct snd_timer_instance *timeri)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&slave_active_lock, flags);\n\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\tif (timeri->master)\n\t\tlist_add_tail(&timeri->active_list,\n\t\t\t      &timeri->master->slave_active_head);\n\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\treturn 1; \/* delayed start *\/\n}","target":1,"flaw_line_index":0,"hash":"4d7577a4-0811-4efc-8d10-949bd8aa875e","idx":"033b1e12-8e90-4499-af26-bd069c806342"}
{"func_before":"static int snd_timer_start_slave(struct snd_timer_instance *timeri)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&slave_active_lock, flags);\n\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\tif (timeri->master && timeri->timer) {\n\t\tspin_lock(&timeri->timer->lock);\n\t\tlist_add_tail(&timeri->active_list,\n\t\t\t      &timeri->master->slave_active_head);\n\t\tspin_unlock(&timeri->timer->lock);\n\t}\n\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\treturn 1; \/* delayed start *\/\n}","target":0,"flaw_line_index":0,"hash":"ef054bd6-1ba5-49b8-9c8e-08a92184a31c","idx":"e5dc8343-91bf-400c-a18f-422a3f263648"}
{"func_before":"\t\t\t\tres = -EBUSY;\n\t\t\t\tgoto err_undo_flags;\n\t\t\t}\n\n\t\t\t\/* Flush unicast and multicast addresses *\/\n\t\t\tdev_uc_flush(bond_dev);\n\t\t\tdev_mc_flush(bond_dev);\n\n\t\t\tif (slave_dev->type != ARPHRD_ETHER)\n\t\t\t\tbond_setup_by_slave(bond_dev, slave_dev);\n\t\t\telse\n\t\t\t\tether_setup(bond_dev);\n\n\t\t\tnetdev_bonding_change(bond_dev,\n\t\t\t\t\t      NETDEV_POST_TYPE_CHANGE);\n\t\t}\n\t} else if (bond_dev->type != slave_dev->type) {\n\t\tpr_err(\"%s ether type (%d) is different from other slaves (%d), can not enslave it.\\n\",\n\t\t       slave_dev->name,\n\t\t       slave_dev->type, bond_dev->type);\n\t\tres = -EINVAL;\n\t\tgoto err_undo_flags;","target":1,"flaw_line_index":0,"hash":"931480ff-fda4-473e-9550-7ea34d5089f1","idx":"9b41d4bb-f00a-40e2-bf42-bfd863980ca6"}
{"func_before":"\t\t\t\tres = -EBUSY;\n\t\t\t\tgoto err_undo_flags;\n\t\t\t}\n\n\t\t\t\/* Flush unicast and multicast addresses *\/\n\t\t\tdev_uc_flush(bond_dev);\n\t\t\tdev_mc_flush(bond_dev);\n\n\t\t\tif (slave_dev->type != ARPHRD_ETHER)\n\t\t\t\tbond_setup_by_slave(bond_dev, slave_dev);\n\t\t\telse {\n\t\t\t\tether_setup(bond_dev);\n\t\t\t\tbond_dev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\t\t\t}\n\n\t\t\tnetdev_bonding_change(bond_dev,\n\t\t\t\t\t      NETDEV_POST_TYPE_CHANGE);\n\t\t}\n\t} else if (bond_dev->type != slave_dev->type) {\n\t\tpr_err(\"%s ether type (%d) is different from other slaves (%d), can not enslave it.\\n\",\n\t\t       slave_dev->name,\n\t\t       slave_dev->type, bond_dev->type);\n\t\tres = -EINVAL;\n\t\tgoto err_undo_flags;","target":0,"flaw_line_index":0,"hash":"ef2188ff-aa98-48b8-a62c-201e7cc74b6d","idx":"9ae9ff5e-8809-4b22-a8f6-03fd5241f9ff"}
{"func_before":"static struct page *alloc_huge_page(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long addr, int avoid_reserve)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *page;\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tlong chg;\n\n\t\/*\n\t * Processes that did not create the mapping will have no reserves and\n\t * will not have accounted against quota. Check that the quota can be\n\t * made before satisfying the allocation\n\t * MAP_NORESERVE mappings may also need pages and quota allocated\n\t * if no reserve mapping overlaps.\n\t *\/\n\tchg = vma_needs_reservation(h, vma, addr);\n\tif (chg < 0)\n\t\treturn ERR_PTR(-VM_FAULT_OOM);\n\tif (chg)\n\t\tif (hugetlb_get_quota(inode->i_mapping, chg))\n\t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n\n\tspin_lock(&hugetlb_lock);\n\tpage = dequeue_huge_page_vma(h, vma, addr, avoid_reserve);\n\tspin_unlock(&hugetlb_lock);\n\n\tif (!page) {\n\t\tpage = alloc_buddy_huge_page(h, NUMA_NO_NODE);\n\t\tif (!page) {\n\t\t\thugetlb_put_quota(inode->i_mapping, chg);\n\t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n\t\t}\n\t}\n\n\tset_page_private(page, (unsigned long) mapping);\n\n\tvma_commit_reservation(h, vma, addr);\n\n\treturn page;\n}","target":1,"flaw_line_index":0,"hash":"14dccb41-d7d7-4220-80c9-72f710308e04","idx":"2ed2dbe0-f61c-431a-babb-9707be5b8999"}
{"func_before":"static struct page *alloc_huge_page(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long addr, int avoid_reserve)\n{\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *page;\n\tlong chg;\n\n\t\/*\n\t * Processes that did not create the mapping will have no\n\t * reserves and will not have accounted against subpool\n\t * limit. Check that the subpool limit can be made before\n\t * satisfying the allocation MAP_NORESERVE mappings may also\n\t * need pages and subpool limit allocated allocated if no reserve\n\t * mapping overlaps.\n\t *\/\n\tchg = vma_needs_reservation(h, vma, addr);\n\tif (chg < 0)\n\t\treturn ERR_PTR(-VM_FAULT_OOM);\n\tif (chg)\n\t\tif (hugepage_subpool_get_pages(spool, chg))\n\t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n\n\tspin_lock(&hugetlb_lock);\n\tpage = dequeue_huge_page_vma(h, vma, addr, avoid_reserve);\n\tspin_unlock(&hugetlb_lock);\n\n\tif (!page) {\n\t\tpage = alloc_buddy_huge_page(h, NUMA_NO_NODE);\n\t\tif (!page) {\n\t\t\thugepage_subpool_put_pages(spool, chg);\n\t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n\t\t}\n\t}\n\n\tset_page_private(page, (unsigned long)spool);\n\n\tvma_commit_reservation(h, vma, addr);\n\n\treturn page;\n}","target":0,"flaw_line_index":0,"hash":"21919f70-9dbe-4f38-808e-f816714fcee7","idx":"8aa4621d-a09c-497c-96fb-5344ee7d111e"}
{"func_before":"\n    \/* Parse report rpt_types *\/\n    while ((pj_int32_t*)rb_hdr < (pj_int32_t*)pkt + pkt_len)\n    {\t\n\trb_len = pj_ntohs((pj_uint16_t)rb_hdr->length);\n\n\t\/* Just skip any block with length == 0 (no report content) *\/\n\tif (rb_len) {\n\t    switch (rb_hdr->bt) {\n\t\tcase BT_RR_TIME:\n\t\t    rb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*) rb_hdr;\n\t\t    break;\n\t\tcase BT_DLRR:\n\t\t    rb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*) rb_hdr;\n\t\t    break;\n\t\tcase BT_STATS:\n\t\t    rb_stats = (pjmedia_rtcp_xr_rb_stats*) rb_hdr;\n\t\t    break;\n\t\tcase BT_VOIP_METRICS:\n\t\t    rb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*) rb_hdr;\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t}\n\trb_hdr = (pjmedia_rtcp_xr_rb_header*)\n\t\t ((pj_int32_t*)rb_hdr + rb_len + 1);\n    }\n\n    \/* Receiving RR Time *\/","target":1,"flaw_line_index":0,"hash":"523aa670-9496-487c-b344-da1d027019dc","idx":"83db943c-2c02-4b74-a6f0-b1e6897d1a01"}
{"func_before":"\n    \/* Parse report rpt_types *\/\n    while ((pj_int32_t*)rb_hdr < (pj_int32_t*)pkt + pkt_len)\n    {\t\n\trb_len = pj_ntohs((pj_uint16_t)rb_hdr->length);\n\n\t\/* Just skip any block with length == 0 (no report content) *\/\n\tif (rb_len) {\n\t    switch (rb_hdr->bt) {\n\t\tcase BT_RR_TIME:\n\t\t    if ((char*)rb_hdr + sizeof(*rb_rr_time) <=\n\t\t\t(char*)pkt + size) \n\t\t    {\n\t\t\trb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*)rb_hdr;\n\t\t    }\n\t\t    break;\n\t\tcase BT_DLRR:\n\t\t    if ((char*)rb_hdr + sizeof(*rb_dlrr) <=\n\t\t\t(char*)pkt + size)\n\t\t    {\n\t\t\trb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*)rb_hdr;\n\t\t    }\n\t\t    break;\n\t\tcase BT_STATS:\n\t\t    if ((char*)rb_hdr + sizeof(*rb_stats) <=\n\t\t\t(char*)pkt + size)\n\t\t    {\n\t\t\trb_stats = (pjmedia_rtcp_xr_rb_stats*)rb_hdr;\n\t\t    }\n\t\t    break;\n\t\tcase BT_VOIP_METRICS:\n\t\t    if ((char*)rb_hdr + sizeof(*rb_voip_mtc) <=\n\t\t\t(char*)pkt + size)\n\t\t    {\n\t\t\trb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*)rb_hdr;\n\t\t    }\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t}\n\trb_hdr = (pjmedia_rtcp_xr_rb_header*)\n\t\t ((pj_int32_t*)rb_hdr + rb_len + 1);\n    }\n\n    \/* Receiving RR Time *\/","target":0,"flaw_line_index":0,"hash":"2b6cb3d8-4db6-485f-836e-204d4f8e3289","idx":"ccce9b48-78f9-42c1-a9db-2c51146c416d"}
{"func_before":"void Logger::addPeer(const QString &ip, bool blocked, const QString &reason)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), ip, blocked, reason };\n    m_peers.push_back(temp);\n\n    if (m_peers.size() >= MAX_LOG_MESSAGES)\n        m_peers.pop_front();\n\n    emit newLogPeer(temp);\n}","target":1,"flaw_line_index":0,"hash":"0ea34310-3a0c-4aa7-b7ee-0416ce08b208","idx":"d6692bb7-4cf5-4f9e-80a3-8c0f95e25128"}
{"func_before":"void Logger::addPeer(const QString &ip, bool blocked, const QString &reason)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), Utils::String::toHtmlEscaped(ip), blocked, Utils::String::toHtmlEscaped(reason) };\n    m_peers.push_back(temp);\n\n    if (m_peers.size() >= MAX_LOG_MESSAGES)\n        m_peers.pop_front();\n\n    emit newLogPeer(temp);\n}","target":0,"flaw_line_index":0,"hash":"c8f0079b-8045-4cdd-a44a-a1e84b756749","idx":"4a44dcc3-9539-49f6-803b-16b9d7dcd646"}
{"func_before":"\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t\/* Copy the address and add cmsg data. *\/\n\tif (family == AF_INET) {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_port = 0 \/* skb->h.uh->source *\/;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\n\t\tif (isk->cmsg_flags)\n\t\t\tip_cmsg_recv(msg, skb);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (family == AF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tstruct ipv6hdr *ip6 = ipv6_hdr(skb);\n\t\tstruct sockaddr_in6 *sin6 =\n\t\t\t(struct sockaddr_in6 *)msg->msg_name;\n\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = 0;\n\t\tsin6->sin6_addr = ip6->saddr;\n\t\tsin6->sin6_flowinfo = 0;\n\t\tif (np->sndflow)\n\t\t\tsin6->sin6_flowinfo = ip6_flowinfo(ip6);\n\n\t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t\t  IP6CB(skb)->iif);\n\t\t*addr_len = sizeof(*sin6);\n\n\t\tif (inet6_sk(sk)->rxopt.all)\n\t\t\tpingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);\n#endif\n\t} else {\n\t\tBUG();\n\t}\n\n\terr = copied;\n","target":1,"flaw_line_index":0,"hash":"3cc43368-0e97-48c3-adea-0da291c1f20d","idx":"bde7f137-1902-4f41-91be-0b93f640b61b"}
{"func_before":"\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_timestamp(msg, sk, skb);\n\n\t\/* Copy the address and add cmsg data. *\/\n\tif (family == AF_INET) {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\n\t\tif (sin) {\n\t\t\tsin->sin_family = AF_INET;\n\t\t\tsin->sin_port = 0 \/* skb->h.uh->source *\/;\n\t\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t\t*addr_len = sizeof(*sin);\n\t\t}\n\n\t\tif (isk->cmsg_flags)\n\t\t\tip_cmsg_recv(msg, skb);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t} else if (family == AF_INET6) {\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tstruct ipv6hdr *ip6 = ipv6_hdr(skb);\n\t\tstruct sockaddr_in6 *sin6 =\n\t\t\t(struct sockaddr_in6 *)msg->msg_name;\n\n\t\tif (sin6) {\n\t\t\tsin6->sin6_family = AF_INET6;\n\t\t\tsin6->sin6_port = 0;\n\t\t\tsin6->sin6_addr = ip6->saddr;\n\t\t\tsin6->sin6_flowinfo = 0;\n\t\t\tif (np->sndflow)\n\t\t\t\tsin6->sin6_flowinfo = ip6_flowinfo(ip6);\n\t\t\tsin6->sin6_scope_id =\n\t\t\t\tipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t    IP6CB(skb)->iif);\n\t\t\t*addr_len = sizeof(*sin6);\n\t\t}\n\n\t\tif (inet6_sk(sk)->rxopt.all)\n\t\t\tpingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);\n#endif\n\t} else {\n\t\tBUG();\n\t}\n\n\terr = copied;\n","target":0,"flaw_line_index":0,"hash":"caf8b449-92ca-4208-9cb9-cdb7bdff6080","idx":"264a6045-2be1-45d9-94f4-ba5d501b00e0"}
{"func_before":"\t\tast_log(LOG_WARNING, \"midget packet received (%d of %d min)\\n\", res, (int) sizeof(*mh));\n\t\treturn 1;\n\t}\n\tif ((vh->zeros == 0) && (ntohs(vh->callno) & 0x8000)) {\n\t\tif (res < sizeof(*vh)) {\n\t\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\\n\", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));\n\t\t\treturn 1;\n\t\t}\n\n\t\t\/* This is a video frame, get call number *\/\n\t\tfr->callno = find_callno(ntohs(vh->callno) & ~0x8000, dcallno, &sin, new, fd);\n\t\tminivid = 1;\n\t} else if ((meta->zeros == 0) && !(ntohs(meta->metacmd) & 0x8000))\n\t\treturn socket_process_meta(res, meta, &sin, fd, fr);\n\n#ifdef DEBUG_SUPPORT\n\tif (iaxdebug && (res >= sizeof(*fh)))\n\t\tiax_showframe(NULL, fh, 1, &sin, res - sizeof(*fh));\n#endif\n\tif (ntohs(mh->callno) & IAX_FLAG_FULL) {\n\t\tif (res < sizeof(*fh)) {\n\t\t\t\t\t\t       (f.subclass == IAX_COMMAND_POKE) || (f.subclass == IAX_COMMAND_FWDOWNL) ||\n\t\t\t\t\t\t       (f.subclass == IAX_COMMAND_REGREL)))\n\t\t\tnew = NEW_ALLOW;\n\t} else {\n\t\t\/* Don't know anything about it yet *\/\n\t\tf.frametype = AST_FRAME_NULL;\n\t\tf.subclass = 0;\n\t}\n\n\tif (!fr->callno)\n\t\tfr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, new, fd);\n\n\tif (fr->callno > 0)\n\t\tast_mutex_lock(&iaxsl[fr->callno]);\n\n\tif (!fr->callno || !iaxs[fr->callno]) {\n\t\t\/* A call arrived for a nonexistent destination.  Unless it's an \"inval\"\n\t\t   frame, reply with an inval *\/\n\t\tif (ntohs(mh->callno) & IAX_FLAG_FULL) {\n\t\t\t\/* We can only raw hangup control frames *\/\n\t\t\tif (((f.subclass != IAX_COMMAND_INVAL) &&","target":1,"flaw_line_index":0,"hash":"92525ea7-d04e-4b62-b415-abe6a2382470","idx":"2e1156ea-2c91-4570-b182-342dbf5e9039"}
{"func_before":"\t\tast_log(LOG_WARNING, \"midget packet received (%d of %d min)\\n\", res, (int) sizeof(*mh));\n\t\treturn 1;\n\t}\n\tif ((vh->zeros == 0) && (ntohs(vh->callno) & 0x8000)) {\n\t\tif (res < sizeof(*vh)) {\n\t\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\\n\", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));\n\t\t\treturn 1;\n\t\t}\n\n\t\t\/* This is a video frame, get call number *\/\n\t\tfr->callno = find_callno(ntohs(vh->callno) & ~0x8000, dcallno, &sin, new, fd, 0);\n\t\tminivid = 1;\n\t} else if ((meta->zeros == 0) && !(ntohs(meta->metacmd) & 0x8000))\n\t\treturn socket_process_meta(res, meta, &sin, fd, fr);\n\n#ifdef DEBUG_SUPPORT\n\tif (iaxdebug && (res >= sizeof(*fh)))\n\t\tiax_showframe(NULL, fh, 1, &sin, res - sizeof(*fh));\n#endif\n\tif (ntohs(mh->callno) & IAX_FLAG_FULL) {\n\t\tif (res < sizeof(*fh)) {\n\t\t\t\t\t\t       (f.subclass == IAX_COMMAND_POKE) || (f.subclass == IAX_COMMAND_FWDOWNL) ||\n\t\t\t\t\t\t       (f.subclass == IAX_COMMAND_REGREL)))\n\t\t\tnew = NEW_ALLOW;\n\t} else {\n\t\t\/* Don't know anything about it yet *\/\n\t\tf.frametype = AST_FRAME_NULL;\n\t\tf.subclass = 0;\n\t}\n\n\tif (!fr->callno)\n\t\tfr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, new, fd, ntohs(mh->callno) & IAX_FLAG_FULL);\n\n\tif (fr->callno > 0)\n\t\tast_mutex_lock(&iaxsl[fr->callno]);\n\n\tif (!fr->callno || !iaxs[fr->callno]) {\n\t\t\/* A call arrived for a nonexistent destination.  Unless it's an \"inval\"\n\t\t   frame, reply with an inval *\/\n\t\tif (ntohs(mh->callno) & IAX_FLAG_FULL) {\n\t\t\t\/* We can only raw hangup control frames *\/\n\t\t\tif (((f.subclass != IAX_COMMAND_INVAL) &&","target":0,"flaw_line_index":0,"hash":"8c37ccc6-014b-46f9-b0b7-98a5726b3bb0","idx":"04cf0057-3476-48a2-89ad-96c569a3bc7c"}
{"func_before":"\t\/* search the beginning of the number *\/\n\twhile ( p<end && (*p==' ' || *p=='\\t' || (*p=='\\r' && *(p+1)=='\\n') ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)\n\t\tgoto error;\n\t\/* parse the number *\/\n\tsize = 0;\n\tnumber = 0;\n\twhile (p<end && *p>='0' && *p<='9') {\n\t\tnumber = number*10 + (*p)-'0';\n\t\tif (number<0) {\n\t\t\tLM_ERR(\"number overflow at pos %d in len number [%.*s]\\n\",\n\t\t\t\t(int)(p-buffer),(int)(end-buffer), buffer);\n\t\t\treturn 0;\n\t\t}\n\t\tsize ++;\n\t\tp++;\n\t}\n\tif (p==end || size==0)\n\t\tgoto error;\n\t\/* now we should have only spaces at the end *\/\n\twhile ( p<end && (*p==' ' || *p=='\\t' ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)","target":1,"flaw_line_index":0,"hash":"11449450-6a44-42cd-a7d6-28b0800746c9","idx":"147609ca-1a33-41c3-b2e0-f0d65f94201e"}
{"func_before":"\t\/* search the beginning of the number *\/\n\twhile ( p<end && (*p==' ' || *p=='\\t' || (*p=='\\r' && *(p+1)=='\\n') ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)\n\t\tgoto error;\n\t\/* parse the number *\/\n\tsize = 0;\n\tnumber = 0;\n\twhile (p<end && *p>='0' && *p<='9') {\n\t\t\/* do not actually cause an integer overflow, as it is UB! --liviu *\/\n\t\tif (number > 214748363) {\n\t\t\tLM_ERR(\"integer overflow risk at pos %d in len number [%.*s]\\n\",\n\t\t\t\t(int)(p-buffer),(int)(end-buffer), buffer);\n\t\t\treturn 0;\n\t\t}\n\n\t\tnumber = number*10 + (*p)-'0';\n\t\tsize ++;\n\t\tp++;\n\t}\n\tif (p==end || size==0)\n\t\tgoto error;\n\t\/* now we should have only spaces at the end *\/\n\twhile ( p<end && (*p==' ' || *p=='\\t' ||\n\t(*p=='\\n' && (*(p+1)==' '||*(p+1)=='\\t')) ))\n\t\tp++;\n\tif (p==end)","target":0,"flaw_line_index":0,"hash":"3310336c-7402-4de9-b6c6-c00f380aa9a8","idx":"ad4add8d-a5d4-416d-9ab0-345897555357"}
{"func_before":"        positive result.  It differs from  % or fmod() which returns a\n        'truncated modulus' result, where floor() is replaced by trunc()\n        and could return a negative result (which is clipped).\n      *\/\n      result=pixel+value;\n      result-=(QuantumRange+1.0)*floor((double) result\/(QuantumRange+1.0));\n      break;\n    }\n    case AndEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel & (size_t) (value+0.5));\n      break;\n    }\n    case CosineEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*(0.5*cos((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case DivideEvaluateOperator:\n    {\n      break;\n    }\n    case LaplacianNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        LaplacianNoise,value);\n      break;\n    }\n    case LeftShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel << (size_t) (value+0.5));\n      break;\n    }\n    case LogEvaluateOperator:\n    {\n      if ((QuantumScale*pixel) >= MagickEpsilon)\n        result=(MagickRealType) (QuantumRange*log((double) (QuantumScale*value*\n          pixel+1.0))\/log((double) (value+1.0)));\n      break;\n    }\n    case MaxEvaluateOperator:\n        MultiplicativeGaussianNoise,value);\n      break;\n    }\n    case MultiplyEvaluateOperator:\n    {\n      result=(MagickRealType) (value*pixel);\n      break;\n    }\n    case OrEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel | (size_t) (value+0.5));\n      break;\n    }\n    case PoissonNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        PoissonNoise,value);\n      break;\n    }\n    case PowEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*pow((double) (QuantumScale*pixel),\n        (double) value));\n      break;\n    }\n    case RightShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel >> (size_t) (value+0.5));\n      break;\n    }\n    case RootMeanSquareEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel*pixel+value);\n      break;\n    }\n    case SetEvaluateOperator:\n    {\n      result=value;\n      break;\n    }\n    case UniformNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        UniformNoise,value);\n      break;\n    }\n    case XorEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel ^ (size_t) (value+0.5));\n      break;\n    }\n  }\n  return(result);\n}","target":1,"flaw_line_index":0,"hash":"bb13f62b-f93c-461f-b356-e4710944baab","idx":"96d5a7ad-5cd5-45f5-a52d-14e1b4fcc09e"}
{"func_before":"        positive result.  It differs from  % or fmod() which returns a\n        'truncated modulus' result, where floor() is replaced by trunc()\n        and could return a negative result (which is clipped).\n      *\/\n      result=pixel+value;\n      result-=(QuantumRange+1.0)*floor((double) result\/(QuantumRange+1.0));\n      break;\n    }\n    case AndEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel & (ssize_t) (value+0.5));\n      break;\n    }\n    case CosineEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*(0.5*cos((double) (2.0*MagickPI*\n        QuantumScale*pixel*value))+0.5));\n      break;\n    }\n    case DivideEvaluateOperator:\n    {\n      break;\n    }\n    case LaplacianNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        LaplacianNoise,value);\n      break;\n    }\n    case LeftShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel << (ssize_t) (value+0.5));\n      break;\n    }\n    case LogEvaluateOperator:\n    {\n      if ((QuantumScale*pixel) >= MagickEpsilon)\n        result=(MagickRealType) (QuantumRange*log((double) (QuantumScale*value*\n          pixel+1.0))\/log((double) (value+1.0)));\n      break;\n    }\n    case MaxEvaluateOperator:\n        MultiplicativeGaussianNoise,value);\n      break;\n    }\n    case MultiplyEvaluateOperator:\n    {\n      result=(MagickRealType) (value*pixel);\n      break;\n    }\n    case OrEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel | (ssize_t) (value+0.5));\n      break;\n    }\n    case PoissonNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        PoissonNoise,value);\n      break;\n    }\n    case PowEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*pow((double) (QuantumScale*pixel),\n        (double) value));\n      break;\n    }\n    case RightShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel >> (ssize_t) (value+0.5));\n      break;\n    }\n    case RootMeanSquareEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel*pixel+value);\n      break;\n    }\n    case SetEvaluateOperator:\n    {\n      result=value;\n      break;\n    }\n    case UniformNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        UniformNoise,value);\n      break;\n    }\n    case XorEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel ^ (ssize_t) (value+0.5));\n      break;\n    }\n  }\n  return(result);\n}","target":0,"flaw_line_index":0,"hash":"43146aed-d9bf-4cbb-acaf-7d9f9704bed6","idx":"c5cf1ebe-ed39-4b57-b1df-98665cc909b1"}
{"func_before":"static u16 read_16(cdk_stream_t s)\n{\n\tbyte buf[2];\n\tsize_t nread;\n\n\tassert(s != NULL);\n\n\tstream_read(s, buf, 2, &nread);\n\tif (nread != 2)\n\t\treturn (u16) - 1;\n\treturn buf[0] << 8 | buf[1];\n}","target":1,"flaw_line_index":0,"hash":"97241c64-85ee-42d5-8db6-bec7cbecdf4a","idx":"78633d9c-af36-48a1-a522-92c6d754922f"}
{"func_before":"static u16 read_16(cdk_stream_t s)\n{\n\tbyte buf[2];\n\tsize_t nread = 0;\n\n\tassert(s != NULL);\n\n\tstream_read(s, buf, 2, &nread);\n\tif (nread != 2)\n\t\treturn (u16) - 1;\n\treturn buf[0] << 8 | buf[1];\n}","target":0,"flaw_line_index":0,"hash":"c8214e03-b6cd-45f6-9f9f-436e44f76ffd","idx":"c25f3589-af0c-4d21-b5af-c84a4dd64972"}
{"func_before":"__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n{\n\tstatic u32 ip6_proxy_idents_hashrnd __read_mostly;\n\tstruct in6_addr buf[2];\n\tstruct in6_addr *addrs;\n\tu32 id;\n\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n\tif (!addrs)\n\t\treturn 0;\n\n\tnet_get_random_once(&ip6_proxy_idents_hashrnd,\n\t\t\t    sizeof(ip6_proxy_idents_hashrnd));\n\n\tid = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,\n\t\t\t\t &addrs[1], &addrs[0]);\n\treturn htonl(id);\n}","target":1,"flaw_line_index":0,"hash":"77371f63-8286-4c87-9fc3-263b50161597","idx":"1409d316-4043-463d-93d4-457fff3e8353"}
{"func_before":"__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n{\n\tstruct in6_addr buf[2];\n\tstruct in6_addr *addrs;\n\tu32 id;\n\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   skb_network_offset(skb) +\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n\tif (!addrs)\n\t\treturn 0;\n\n\tid = __ipv6_select_ident(net, &addrs[1], &addrs[0]);\n\treturn htonl(id);\n}","target":0,"flaw_line_index":0,"hash":"7d1c19ac-c9e5-4a63-ae1b-919b443246d0","idx":"b5e19b4b-3f50-448b-afbc-1309c5a3fdf8"}
{"func_before":"void fb_read_bin(fb_t a, const uint8_t *bin, int len) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tif (len != RLC_FB_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tRLC_TRY {","target":1,"flaw_line_index":0,"hash":"95199b3b-69dd-4e97-963a-d72a142d7749","idx":"754db74c-cc5a-4d86-aeba-998afedde807"}
{"func_before":"void fb_read_bin(fb_t a, const uint8_t *bin, size_t len) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tif (len != RLC_FB_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\n\tRLC_TRY {","target":0,"flaw_line_index":0,"hash":"14dde67d-4df4-4dfd-abaf-dcd085eabe1a","idx":"ba326e86-e785-4a7f-b9c8-a5ecc221d7b7"}
{"func_before":"static void outbound_phy_packet_callback(struct fw_packet *packet,\n\t\t\t\t\t struct fw_card *card, int status)\n{\n\tstruct outbound_phy_packet_event *e =\n\t\tcontainer_of(packet, struct outbound_phy_packet_event, p);\n\n\tswitch (status) {\n\t\/* expected: *\/\n\tcase ACK_COMPLETE:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\t\/* should never happen with PHY packets: *\/\n\tcase ACK_PENDING:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\tcase ACK_BUSY_X:\n\tcase ACK_BUSY_A:\n\tcase ACK_BUSY_B:\te->phy_packet.rcode = RCODE_BUSY;\tbreak;\n\tcase ACK_DATA_ERROR:\te->phy_packet.rcode = RCODE_DATA_ERROR;\tbreak;\n\tcase ACK_TYPE_ERROR:\te->phy_packet.rcode = RCODE_TYPE_ERROR;\tbreak;\n\t\/* stale generation; cancelled; on certain controllers: no ack *\/\n\tdefault:\t\te->phy_packet.rcode = status;\t\tbreak;\n\t}\n\te->phy_packet.data[0] = packet->timestamp;\n\n\tqueue_event(e->client, &e->event, &e->phy_packet,\n\t\t    sizeof(e->phy_packet) + e->phy_packet.length, NULL, 0);\n\tclient_put(e->client);\n}","target":1,"flaw_line_index":0,"hash":"b34715da-4969-46cb-b2f5-817b3af37572","idx":"28284517-3635-4644-bf7c-dc2f84e3de2f"}
{"func_before":"static void outbound_phy_packet_callback(struct fw_packet *packet,\n\t\t\t\t\t struct fw_card *card, int status)\n{\n\tstruct outbound_phy_packet_event *e =\n\t\tcontainer_of(packet, struct outbound_phy_packet_event, p);\n\tstruct client *e_client;\n\n\tswitch (status) {\n\t\/* expected: *\/\n\tcase ACK_COMPLETE:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\t\/* should never happen with PHY packets: *\/\n\tcase ACK_PENDING:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\tcase ACK_BUSY_X:\n\tcase ACK_BUSY_A:\n\tcase ACK_BUSY_B:\te->phy_packet.rcode = RCODE_BUSY;\tbreak;\n\tcase ACK_DATA_ERROR:\te->phy_packet.rcode = RCODE_DATA_ERROR;\tbreak;\n\tcase ACK_TYPE_ERROR:\te->phy_packet.rcode = RCODE_TYPE_ERROR;\tbreak;\n\t\/* stale generation; cancelled; on certain controllers: no ack *\/\n\tdefault:\t\te->phy_packet.rcode = status;\t\tbreak;\n\t}\n\te->phy_packet.data[0] = packet->timestamp;\n\n\te_client = e->client;\n\tqueue_event(e->client, &e->event, &e->phy_packet,\n\t\t    sizeof(e->phy_packet) + e->phy_packet.length, NULL, 0);\n\tclient_put(e_client);\n}","target":0,"flaw_line_index":0,"hash":"01b65e27-bbcf-4b28-a15c-a86d8c946094","idx":"ca5e3c69-01d0-4f10-b16e-f5f29bcc29b6"}
{"func_before":"\t}\n\tif (!drop)\n\t{\n\t    switch (mode)\n\t    {\n\t\tcase PASTE_CMDLINE:\n\t\t    put_on_cmdline(buf, idx, TRUE);\n\t\t    break;\n\n\t\tcase PASTE_EX:\n\t\t    if (gap != NULL && ga_grow(gap, idx) == OK)\n\t\t    {\n\t\t\tmch_memmove((char *)gap->ga_data + gap->ga_len,\n\t\t\t\t\t\t\t     buf, (size_t)idx);\n\t\t\tgap->ga_len += idx;\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_INSERT:\n\t\t    if (stop_arrow() == OK)\n\t\t    {","target":1,"flaw_line_index":0,"hash":"04457a07-75c2-462d-95fe-2e244479918a","idx":"a4260058-ccf3-47bf-b90e-f4ffc912906f"}
{"func_before":"\t}\n\tif (!drop)\n\t{\n\t    switch (mode)\n\t    {\n\t\tcase PASTE_CMDLINE:\n\t\t    put_on_cmdline(buf, idx, TRUE);\n\t\t    break;\n\n\t\tcase PASTE_EX:\n\t\t    \/\/ add one for the NUL that is going to be appended\n\t\t    if (gap != NULL && ga_grow(gap, idx + 1) == OK)\n\t\t    {\n\t\t\tmch_memmove((char *)gap->ga_data + gap->ga_len,\n\t\t\t\t\t\t\t     buf, (size_t)idx);\n\t\t\tgap->ga_len += idx;\n\t\t    }\n\t\t    break;\n\n\t\tcase PASTE_INSERT:\n\t\t    if (stop_arrow() == OK)\n\t\t    {","target":0,"flaw_line_index":0,"hash":"352dedfa-2f92-4e24-8c9d-030f02a800de","idx":"c53dc5ca-afed-4ad4-b5ef-f2996a434a93"}
{"func_before":"int ZlibInStream::pos()\n{\n  return offset + ptr - start;\n}","target":1,"flaw_line_index":0,"hash":"c59f7534-8e4d-4d30-b7c1-7af7e5250e89","idx":"67eb6de9-5ecb-4100-ace9-369125597215"}
{"func_before":"size_t ZlibInStream::pos()\n{\n  return offset + ptr - start;\n}","target":0,"flaw_line_index":0,"hash":"9c8f146d-b1d1-45c8-9052-8cf52f907e20","idx":"e054471b-b96b-4125-9b55-020b8611144b"}
{"func_before":"int udpv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions opt_space;\n\tstruct udp_sock *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n\tstruct in6_addr *daddr, *final_p, final;\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_len = msg->msg_namelen;\n\tint ulen = len;\n\tint hlimit = -1;\n\tint tclass = -1;\n\tint dontfrag = -1;\n\tint corkreq = up->corkflag || msg->msg_flags&MSG_MORE;\n\tint err;\n\t\t}\n\t\tif ((fl6.flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (!flowlabel)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t\tconnected = 0;\n\t}\n\tif (!opt)\n\t\topt = np->opt;\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tif (!ipv6_addr_any(daddr))\n\t\tfl6.daddr = *daddr;\n\telse\n\t\tfl6.daddr.s6_addr[15] = 0x1; \/* :: means loopback (BSD'ism) *\/\n\tif (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))\n#endif\n\t\t\t\t      NULL);\n\t\t} else {\n\t\t\tdst_release(dst);\n\t\t}\n\t\tdst = NULL;\n\t}\n\nout:\n\tdst_release(dst);\n\tfl6_sock_release(flowlabel);\n\tif (!err)\n\t\treturn len;\n\t\/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t *\/\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {","target":1,"flaw_line_index":0,"hash":"ecb41688-0d73-4676-b825-30c07ccea947","idx":"5fe6c538-b077-4e7d-81bc-606bb93152cd"}
{"func_before":"int udpv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\n{\n\tstruct ipv6_txoptions opt_space;\n\tstruct udp_sock *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n\tstruct in6_addr *daddr, *final_p, final;\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ipv6_txoptions *opt_to_free = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_len = msg->msg_namelen;\n\tint ulen = len;\n\tint hlimit = -1;\n\tint tclass = -1;\n\tint dontfrag = -1;\n\tint corkreq = up->corkflag || msg->msg_flags&MSG_MORE;\n\tint err;\n\t\t}\n\t\tif ((fl6.flowlabel&IPV6_FLOWLABEL_MASK) && !flowlabel) {\n\t\t\tflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\n\t\t\tif (!flowlabel)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t\tconnected = 0;\n\t}\n\tif (!opt) {\n\t\topt = txopt_get(np);\n\t\topt_to_free = opt;\n\t}\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\n\tfl6.flowi6_proto = sk->sk_protocol;\n\tif (!ipv6_addr_any(daddr))\n\t\tfl6.daddr = *daddr;\n\telse\n\t\tfl6.daddr.s6_addr[15] = 0x1; \/* :: means loopback (BSD'ism) *\/\n\tif (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))\n\t\t\t\t      NULL);\n\t\t} else {\n\t\t\tdst_release(dst);\n\t\t}\n\t\tdst = NULL;\n\t}\n\nout:\n\tdst_release(dst);\n\tfl6_sock_release(flowlabel);\n\ttxopt_put(opt_to_free);\n\tif (!err)\n\t\treturn len;\n\t\/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise\n\t * we don't have a good statistic (IpOutDiscards but it can be too many\n\t * things).  We could add another new stat but at least for now that\n\t * seems like overkill.\n\t *\/\n\tif (err == -ENOBUFS || test_bit(SOCK_NOSPACE, &sk->sk_socket->flags)) {","target":0,"flaw_line_index":0,"hash":"d5fae2fc-d50a-43b5-8a60-dbb26bbb1f2b","idx":"75ad4fb8-554f-4f31-9b28-e9830097b92f"}
{"func_before":"        if (pindex->pprev)\n            pindex->pprev->pnext = NULL;\n\n    \/\/ Connect longer branch\n    BOOST_FOREACH(CBlockIndex* pindex, vConnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = pindex;\n\n    \/\/ Resurrect memory transactions that were in the disconnected branch\n    BOOST_FOREACH(CTransaction& tx, vResurrect)\n        tx.AcceptToMemoryPool(txdb, false);\n\n    \/\/ Delete redundant memory transactions that are in the connected branch\n    BOOST_FOREACH(CTransaction &tx, vDelete) {\n        mempool.remove(tx);\n        mempool.removeConflicts(tx);\n    }\n\n    printf(\"REORGANIZE: done\\n\");\n\n    return true;","target":1,"flaw_line_index":0,"hash":"894ce6c8-ac55-4b78-ac8c-aa92fddad0ba","idx":"52c9ac77-5a5d-449f-a036-52fd880bd40e"}
{"func_before":"        if (pindex->pprev)\n            pindex->pprev->pnext = NULL;\n\n    \/\/ Connect longer branch\n    BOOST_FOREACH(CBlockIndex* pindex, vConnect)\n        if (pindex->pprev)\n            pindex->pprev->pnext = pindex;\n\n    \/\/ Resurrect memory transactions that were in the disconnected branch\n    BOOST_FOREACH(CTransaction& tx, vResurrect)\n      tx.AcceptToMemoryPool(txdb, true, false);\n\n    \/\/ Delete redundant memory transactions that are in the connected branch\n    BOOST_FOREACH(CTransaction &tx, vDelete) {\n        mempool.remove(tx);\n        mempool.removeConflicts(tx);\n    }\n\n    printf(\"REORGANIZE: done\\n\");\n\n    return true;","target":0,"flaw_line_index":0,"hash":"4e7571f8-5518-4005-bd25-e4f969be8259","idx":"4a220442-e052-4cd3-a7d0-1bf7aed7c113"}
{"func_before":"static int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n\t       sizeof(ualg->cru_driver_name));\n\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n\t       CRYPTO_MAX_ALG_NAME);\n\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\n\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"larval\");\n\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n\t\t\t    sizeof(struct crypto_report_larval), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n","target":1,"flaw_line_index":0,"hash":"80820659-d040-4479-b3ba-dc352b649ffe","idx":"81fff292-6c63-4287-919d-3827bfcf1fd7"}
{"func_before":"static int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tstrncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrncpy(ualg->cru_driver_name, alg->cra_driver_name,\n\t\tsizeof(ualg->cru_driver_name));\n\tstrncpy(ualg->cru_module_name, module_name(alg->cra_module),\n\t\tsizeof(ualg->cru_module_name));\n\n\tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\n\t\tstrncpy(rl.type, \"larval\", sizeof(rl.type));\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n\t\t\t    sizeof(struct crypto_report_larval), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}\n\n\tif (alg->cra_type && alg->cra_type->report) {\n\t\tif (alg->cra_type->report(skb, alg))\n\t\t\tgoto nla_put_failure;\n","target":0,"flaw_line_index":0,"hash":"c7c4bf3b-c416-4eb0-8eb7-9664b8253cfc","idx":"6a0fbec3-d1b9-4e02-beb8-c0d0f735154a"}
{"func_before":"\ttimes.nb_items = names.nb_items = count;\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 di;\n\t\tGF_ISOSample *s = gf_isom_get_sample(file, chap_tk, i+1, &di);\n\t\tif (!s) continue;\n\t\tGF_BitStream *bs = gf_bs_new(s->data, s->dataLength, GF_BITSTREAM_READ);\n\t\tGF_TextSample *txt = gf_isom_parse_text_sample(bs);\n\t\tif (txt) {\n\t\t\ttimes.vals[i] = (u32) s->DTS;\n\t\t\tnames.vals[i] = gf_strdup(txt->text);\n\t\t\tgf_isom_delete_text_sample(txt);\n\t\t}\n\t\tgf_bs_del(bs);\n\t\tgf_isom_sample_del(&s);\n\t}\n\tp.type = GF_PROP_UINT_LIST;\n\tp.value.uint_list = times;\n\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_TIMES, &p);\n\tgf_free(times.vals);\n","target":1,"flaw_line_index":0,"hash":"d46a5902-f147-4881-8fe6-be831608ce5e","idx":"aa20cd0a-c134-4c63-a02d-06e3480229bc"}
{"func_before":"\ttimes.nb_items = names.nb_items = count;\n\n\tfor (i=0; i<count; i++) {\n\t\tu32 di;\n\t\tGF_ISOSample *s = gf_isom_get_sample(file, chap_tk, i+1, &di);\n\t\tif (!s) continue;\n\t\tGF_BitStream *bs = gf_bs_new(s->data, s->dataLength, GF_BITSTREAM_READ);\n\t\tGF_TextSample *txt = gf_isom_parse_text_sample(bs);\n\t\tif (txt) {\n\t\t\ttimes.vals[i] = (u32) s->DTS;\n\t\t\tnames.vals[i] = gf_strdup(txt->text ? txt->text : \"\");\n\t\t\tgf_isom_delete_text_sample(txt);\n\t\t}\n\t\tgf_bs_del(bs);\n\t\tgf_isom_sample_del(&s);\n\t}\n\tp.type = GF_PROP_UINT_LIST;\n\tp.value.uint_list = times;\n\tgf_filter_pid_set_property(opid, GF_PROP_PID_CHAP_TIMES, &p);\n\tgf_free(times.vals);\n","target":0,"flaw_line_index":0,"hash":"329c23d9-2e93-4a2d-936b-6055fff2d9ec","idx":"69194ba7-07a8-4ff9-8af3-e0655387d512"}
{"func_before":"tvb_get_manuf_name(tvbuff_t *tvb, gint offset)\n{\n    return get_manuf_name(tvb_get_ptr(tvb, offset, 3));\n}","target":1,"flaw_line_index":0,"hash":"f6c28d21-31d4-4057-83af-cc00c1b02591","idx":"2a8131e4-a75d-4ee8-81ff-a36c493f0bbb"}
{"func_before":"tvb_get_manuf_name(tvbuff_t *tvb, gint offset)\n{\n    guint8 buf[6] = { 0 };\n    tvb_memcpy(tvb, buf, offset, 3);\n    return get_manuf_name(buf, sizeof(buf));\n}","target":0,"flaw_line_index":0,"hash":"b764d718-f3cf-424d-9add-8b9763323bb4","idx":"dbcbcd7c-82ef-41c8-8afc-b7f8c0284d98"}
{"func_before":"int jas_memdump(FILE *out, void *data, size_t len)\n{\n\tsize_t i;\n\tsize_t j;\n\tuchar *dp;\n\tdp = data;\n\tfor (i = 0; i < len; i += 16) {\n\t\tfprintf(out, \"%04zx:\", i);\n\t\tfor (j = 0; j < 16; ++j) {\n\t\t\tif (i + j < len) {\n\t\t\t\tfprintf(out, \" %02x\", dp[i + j]);\n\t\t\t}\n\t\t}\n\t\tfprintf(out, \"\\n\");\n\t}","target":1,"flaw_line_index":0,"hash":"1c4f91c6-dc2b-47af-8457-b09f54fe5dd2","idx":"5986ee83-5520-452b-8047-d4c73862d6de"}
{"func_before":"int jas_memdump(FILE *out, void *data, size_t len)\n{\n\tsize_t i;\n\tsize_t j;\n\tjas_uchar *dp;\n\tdp = data;\n\tfor (i = 0; i < len; i += 16) {\n\t\tfprintf(out, \"%04zx:\", i);\n\t\tfor (j = 0; j < 16; ++j) {\n\t\t\tif (i + j < len) {\n\t\t\t\tfprintf(out, \" %02x\", dp[i + j]);\n\t\t\t}\n\t\t}\n\t\tfprintf(out, \"\\n\");\n\t}","target":0,"flaw_line_index":0,"hash":"ae019a5f-0c34-4069-b38b-a150afa003cd","idx":"b33c9c8d-ebc2-4611-8e4c-30d7b89c314f"}
{"func_before":"\n      if (C_SslForceTls)\n        ans = MUTT_YES;\n      else if ((ans = query_quadoption(C_SslStarttls,\n                                       _(\"Secure connection with TLS?\"))) == MUTT_ABORT)\n      {\n        goto err_close_conn;\n      }\n      if (ans == MUTT_YES)\n      {\n        enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_NO_FLAGS);\n        if (rc == IMAP_EXEC_FATAL)\n          goto bail;\n        if (rc != IMAP_EXEC_ERROR)\n        {\n          if (mutt_ssl_starttls(adata->conn))\n          {\n            mutt_error(_(\"Could not negotiate TLS connection\"));\n            goto err_close_conn;\n          }\n          else","target":1,"flaw_line_index":0,"hash":"a8a0a7ad-f201-4903-b4ce-1d7d9f5ca56d","idx":"dd3827f3-90d1-48fe-b185-51fdd0b0680e"}
{"func_before":"\n      if (C_SslForceTls)\n        ans = MUTT_YES;\n      else if ((ans = query_quadoption(C_SslStarttls,\n                                       _(\"Secure connection with TLS?\"))) == MUTT_ABORT)\n      {\n        goto err_close_conn;\n      }\n      if (ans == MUTT_YES)\n      {\n        enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_SINGLE);\n        \/\/ Clear any data after the STARTTLS acknowledgement\n        mutt_socket_empty(adata->conn);\n\n        if (rc == IMAP_EXEC_FATAL)\n          goto bail;\n        if (rc != IMAP_EXEC_ERROR)\n        {\n          if (mutt_ssl_starttls(adata->conn))\n          {\n            mutt_error(_(\"Could not negotiate TLS connection\"));\n            goto err_close_conn;\n          }\n          else","target":0,"flaw_line_index":0,"hash":"c2fd06bb-5c7d-4064-8a26-a3ff720e2c4d","idx":"8e4f2dc7-9132-42cb-b6ca-2ba1344e5a01"}
{"func_before":"    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n\n    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in));\n\n    const Tensor* num_buckets_t;\n    OP_REQUIRES_OK(context, context->input(\"num_buckets\", &num_buckets_t));\n    const int64 num_buckets = num_buckets_t->scalar<int64>()();\n\n    const Tensor* strong_hash_t;\n    OP_REQUIRES_OK(context, context->input(\"strong_hash\", &strong_hash_t));\n    const bool strong_hash = strong_hash_t->scalar<bool>()();\n\n    const Tensor* salt_t;","target":1,"flaw_line_index":0,"hash":"f9913cc1-f4aa-4a88-8897-c1c3a020c0b0","idx":"6e77ecc9-7272-43e3-aecd-765d16fac6f0"}
{"func_before":"    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n\n    \/\/ Set internal_type to invalid_type so that the check will be ignored.\n    DataType internal_type = DT_INVALID;\n    OP_REQUIRES_OK(\n        context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,\n                               dense_list_in, internal_type));\n\n    const Tensor* num_buckets_t;\n    OP_REQUIRES_OK(context, context->input(\"num_buckets\", &num_buckets_t));\n    const int64 num_buckets = num_buckets_t->scalar<int64>()();\n\n    const Tensor* strong_hash_t;\n    OP_REQUIRES_OK(context, context->input(\"strong_hash\", &strong_hash_t));\n    const bool strong_hash = strong_hash_t->scalar<bool>()();\n\n    const Tensor* salt_t;","target":0,"flaw_line_index":0,"hash":"ee74dec0-4c34-49c3-b76e-0563f4e06f11","idx":"4b8944c4-3bb7-46b5-a3de-3166019d0f41"}
{"func_before":"int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n  int new_mi_size;\n\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n  }\n\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    \/\/ Create the segmentation map structure and set to 0.\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n\n  if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n    if (!cm->above_context) goto fail;\n\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n\n  return 0;\n\nfail:\n  \/\/ clear the mi_* values to force a realloc on resync\n  vp9_set_mb_mi(cm, 0, 0);\n  vp9_free_context_buffers(cm);\n  return 1;\n}","target":1,"flaw_line_index":0,"hash":"10809fa9-cd30-454b-ab36-c0c7a301aade","idx":"4a90c7f4-ce7a-4d43-b89a-4b1af1a3b8f2"}
{"func_before":"int vp9_alloc_context_buffers(VP9_COMMON *cm, int width, int height) {\n  int new_mi_size;\n\n  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n  }\n  if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n    if (!cm->above_context) goto fail;\n\n    vpx_free(cm->above_seg_context);\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    \/\/ Create the segmentation map structure and set to 0.\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n\n  return 0;\n\nfail:\n  \/\/ clear the mi_* values to force a realloc on resync\n  vp9_set_mb_mi(cm, 0, 0);\n  vp9_free_context_buffers(cm);\n  return 1;\n}","target":0,"flaw_line_index":0,"hash":"5f281d41-40d4-46f2-8701-a0a1d91ea615","idx":"50d4ef13-f02a-4b34-9874-e8158d0fb645"}
{"func_before":"\t\tif (edp->nargs > SUN_EMUL_NARGS - 1) {\n\t\t\tbcopy(edp->args + 1, edp->args,\n\t\t\t    (SUN_EMUL_NARGS - 1) * sizeof(edp->args[0]));\n\t\t\tedp->args[edp->nargs = SUN_EMUL_NARGS - 1] = 0;\n\t\t}\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\n\tcase ';':\t\t\/* argument terminator *\/\n\t\tedp->nargs++;\n\t\tbreak;\n\n\tdefault:\t\t\/* end of escape sequence *\/\n\t\toargs = edp->nargs++;\n\t\tif (edp->nargs > SUN_EMUL_NARGS)\n\t\t\tedp->nargs = SUN_EMUL_NARGS;\n\t\trc = wsemul_sun_control(edp, instate);\n\t\tif (rc != 0) {\n\t\t\t\/* undo nargs progress *\/\n\t\t\tedp->nargs = oargs;\n\n\t\t\treturn rc;\n\t\t}\n\t\tedp->state = SUN_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}","target":1,"flaw_line_index":0,"hash":"fa69d528-be69-4c46-a33d-2a3554783524","idx":"4fa98202-8b2a-4864-9587-973fd9922aff"}
{"func_before":"\t\tif (edp->nargs > SUN_EMUL_NARGS - 1) {\n\t\t\tbcopy(edp->args + 1, edp->args,\n\t\t\t    (SUN_EMUL_NARGS - 1) * sizeof(edp->args[0]));\n\t\t\tedp->args[edp->nargs = SUN_EMUL_NARGS - 1] = 0;\n\t\t}\n\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\n\tcase ';':\t\t\/* argument terminator *\/\n\t\tif (edp->nargs < SUN_EMUL_NARGS)\n\t\t\tedp->nargs++;\n\t\tbreak;\n\n\tdefault:\t\t\/* end of escape sequence *\/\n\t\toargs = edp->nargs;\n\t\tif (edp->nargs < SUN_EMUL_NARGS)\n\t\t\tedp->nargs++;\n\t\trc = wsemul_sun_control(edp, instate);\n\t\tif (rc != 0) {\n\t\t\t\/* undo nargs progress *\/\n\t\t\tedp->nargs = oargs;\n\n\t\t\treturn rc;\n\t\t}\n\t\tedp->state = SUN_EMUL_STATE_NORMAL;\n\t\tbreak;\n\t}","target":0,"flaw_line_index":0,"hash":"4a1b6e54-5a62-43b4-b544-636c1edd8dc6","idx":"6de9a285-dfd7-45c7-9c25-05e684454390"}
{"func_before":"\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn Boolean::New(Isolate::GetCurrent(), result);\n\t\t}","target":1,"flaw_line_index":0,"hash":"f0d68aaa-ddeb-475c-8bcb-3e61d689f884","idx":"4a314b4b-3186-47f9-8b33-2560fefb0b99"}
{"func_before":"\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn Undefined(Isolate::GetCurrent());\n\t\t}","target":0,"flaw_line_index":0,"hash":"55c7579b-fea0-4e66-8d5d-05cc55e98391","idx":"6c6fccac-39e2-4ce9-8ff1-983e674919d6"}
{"func_before":"\tif (!BIO_dgram_is_sctp(SSL_get_rbio(s)))\n  \t\t{\n#endif\n\t\t\/* Check whether this is a repeat, or aged record.\n\t\t * Don't check if we're listening and this message is\n\t\t * a ClientHello. They can look as if they're replayed,\n\t\t * since they arrive from different connections and\n\t\t * would be dropped unnecessarily.\n\t\t *\/\n\t\tif (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&\n\t\t    *p == SSL3_MT_CLIENT_HELLO) &&\n\t\t    !dtls1_record_replay_check(s, bitmap))\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\ts->packet_length=0; \/* dump this record *\/\n\t\t\tgoto again;     \/* get another record *\/\n\t\t\t}\n#ifndef OPENSSL_NO_SCTP\n  \t\t}\n#endif\n","target":1,"flaw_line_index":0,"hash":"334fdc4e-0bd1-4829-be59-21f6b7d665de","idx":"5442588f-6ae8-49ef-81fc-f2ed792066d0"}
{"func_before":"\tif (!BIO_dgram_is_sctp(SSL_get_rbio(s)))\n  \t\t{\n#endif\n\t\t\/* Check whether this is a repeat, or aged record.\n\t\t * Don't check if we're listening and this message is\n\t\t * a ClientHello. They can look as if they're replayed,\n\t\t * since they arrive from different connections and\n\t\t * would be dropped unnecessarily.\n\t\t *\/\n\t\tif (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&\n\t\t    s->packet_length > DTLS1_RT_HEADER_LENGTH &&\n\t\t    s->packet[DTLS1_RT_HEADER_LENGTH] == SSL3_MT_CLIENT_HELLO) &&\n\t\t    !dtls1_record_replay_check(s, bitmap))\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\ts->packet_length=0; \/* dump this record *\/\n\t\t\tgoto again;     \/* get another record *\/\n\t\t\t}\n#ifndef OPENSSL_NO_SCTP\n  \t\t}\n#endif\n","target":0,"flaw_line_index":0,"hash":"3b0c7e21-8bbc-4314-b58a-6fc8c8507cca","idx":"afebfe3f-4814-4562-827f-26dc847657a9"}
{"func_before":"\n\t\/\/here we have to handle that in a clever way\n\tto_read = (u32) ptr->size;\n\ttmpName = (char*)gf_malloc(sizeof(char) * to_read);\n\tif (!tmpName) return GF_OUT_OF_MEM;\n\t\/\/get the data\n\tgf_bs_read_data(bs, tmpName, to_read);\n\n\t\/\/then get the break\n\ti = 0;\n\twhile ( (tmpName[i] != 0) && (i < to_read) ) {\n\t\ti++;\n\t}\n\t\/\/check the data is consistent\n\tif (i == to_read) {\n\t\tgf_free(tmpName);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t\/\/no NULL char, URL is not specified\n\tif (i == to_read - 1) {\n\t\tptr->nameURN = tmpName;","target":1,"flaw_line_index":0,"hash":"b526b488-daec-4b18-8aa6-d65d4d9b11df","idx":"3090ee64-a61c-40f2-969c-9e91461a45d0"}
{"func_before":"\n\t\/\/here we have to handle that in a clever way\n\tto_read = (u32) ptr->size;\n\ttmpName = (char*)gf_malloc(sizeof(char) * to_read);\n\tif (!tmpName) return GF_OUT_OF_MEM;\n\t\/\/get the data\n\tgf_bs_read_data(bs, tmpName, to_read);\n\n\t\/\/then get the break\n\ti = 0;\n\twhile ( (i < to_read) && (tmpName[i] != 0) ) {\n\t\ti++;\n\t}\n\t\/\/check the data is consistent\n\tif (i == to_read) {\n\t\tgf_free(tmpName);\n\t\treturn GF_ISOM_INVALID_FILE;\n\t}\n\t\/\/no NULL char, URL is not specified\n\tif (i == to_read - 1) {\n\t\tptr->nameURN = tmpName;","target":0,"flaw_line_index":0,"hash":"f84e033f-61d2-4872-8359-0853f4f4dd81","idx":"c2e2d189-317b-42e6-a8c2-6c739cf09aca"}
{"func_before":"\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {\n\t\tr_asn1_free_object (object);\n\t\tfree (container);\n\t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}","target":1,"flaw_line_index":0,"hash":"8f5fc338-824a-4801-a597-798833d22e79","idx":"904357a1-fe3e-406f-8412-48b3b260374f"}
{"func_before":"\tRASN1Object *object;\n\tRCMS *container;\n\tif (!buffer || !length) {\n\t\treturn NULL;\n\t}\n\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects ||\n\t\t!object->list.objects[0] || !object->list.objects[1] ||\n\t\tobject->list.objects[1]->list.length != 1) {\n\t\tr_asn1_free_object (object);\n\t\tfree (container);\n\t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);\n\tr_pkcs7_parse_signeddata (&container->signedData, object->list.objects[1]->list.objects[0]);\n\tr_asn1_free_object (object);\n\treturn container;\n}","target":0,"flaw_line_index":0,"hash":"d7a48997-3767-4fea-9df4-b856f6e1e528","idx":"8a07a57a-897d-4325-9800-69d6ce430e50"}
{"func_before":"parse_memory(VALUE klass, VALUE data)\n{\n  xmlParserCtxtPtr ctxt;\n\n  if (NIL_P(data)) {\n    rb_raise(rb_eArgError, \"data cannot be nil\");\n  }\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n\n  ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                   (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }","target":1,"flaw_line_index":0,"hash":"f313a735-f80c-42be-8f06-c8f9caf6cd52","idx":"3542375c-8f83-46f4-aa9f-9f659593c3a8"}
{"func_before":"parse_memory(VALUE klass, VALUE data)\n{\n  xmlParserCtxtPtr ctxt;\n\n  Check_Type(data, T_STRING);\n\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n\n  ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                   (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }","target":0,"flaw_line_index":0,"hash":"62e70ec2-8ddd-4db2-b822-4a97bb96ecf0","idx":"510fd38a-8f0e-4d17-b6f8-ce8a1c54c8bf"}
{"func_before":"      if (low_prev) {\n        if (*low > s)\n          *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);\n        else\n          *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                 (pprev ? pprev : str), p);\n      }\n    }\n    else {\n      if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n        *low = p - reg->dmax;\n        if (*low > s) {\n          *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n                                          *low, (const UChar** )low_prev);\n          if (low_prev && IS_NULL(*low_prev))\n            *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                   (pprev ? pprev : s), *low);\n        }\n        else {\n          if (low_prev)\n            *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                   (pprev ? pprev : str), *low);\n        }\n      }\n    }\n    \/* no needs to adjust *high, *high is used as range check only *\/\n    *high = p - reg->dmin;\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr,\n    \"forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\\n\",\n\t    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);","target":1,"flaw_line_index":0,"hash":"a7be4ad5-62d6-4038-9db9-2379a871de8b","idx":"1fc02640-1cf1-4457-9143-fdcff52552ae"}
{"func_before":"      if (low_prev) {\n        if (*low > s)\n          *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);\n        else\n          *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                 (pprev ? pprev : str), p);\n      }\n    }\n    else {\n      if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n        if (p - str < reg->dmax) {\n          *low = (UChar* )str;\n          if (low_prev)\n            *low_prev = onigenc_get_prev_char_head(reg->enc, str, *low);\n        }\n        else {\n          *low = p - reg->dmax;\n          if (*low > s) {\n            *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n                                                 *low, (const UChar** )low_prev);\n            if (low_prev && IS_NULL(*low_prev))\n              *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : s), *low);\n          }\n          else {\n            if (low_prev)\n              *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : str), *low);\n          }\n        }\n      }\n    }\n    \/* no needs to adjust *high, *high is used as range check only *\/\n    *high = p - reg->dmin;\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr,\n    \"forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\\n\",\n\t    (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);","target":0,"flaw_line_index":0,"hash":"9d5e22a1-8bf2-4f05-aaaf-efcf270e7aa1","idx":"5d43ed37-1f2c-4dce-aeab-e745b02968e8"}
{"func_before":"\n      if(buffer && row < screen->rows && col < screen->cols)\n        *new_cell = buffer[row * screen->cols + col];\n      else {\n        new_cell->chars[0] = 0;\n        new_cell->pen = screen->pen;\n      }\n    }\n  }\n\n  if(buffer)\n    vterm_allocator_free(screen->vt, buffer);\n\n  return new_buffer;\n}","target":1,"flaw_line_index":0,"hash":"4606a1f0-aaf1-4340-8d2b-3cbed7869723","idx":"73db8035-056c-46f1-901f-ec9728c57df8"}
{"func_before":"\n      if(buffer && row < screen->rows && col < screen->cols)\n        *new_cell = buffer[row * screen->cols + col];\n      else {\n        new_cell->chars[0] = 0;\n        new_cell->pen = screen->pen;\n      }\n    }\n  }\n\n  vterm_allocator_free(screen->vt, buffer);\n\n  return new_buffer;\n}","target":0,"flaw_line_index":0,"hash":"eea91d94-bb6d-47b5-b8ba-6f0c01433309","idx":"44b01a14-93ca-4124-8ffc-b301e2582341"}
{"func_before":"find_auth_end (FlatpakProxyClient *client, Buffer *buffer)\n{\n  guchar *match;\n  int i;\n\n  \/* First try to match any leftover at the start *\/\n  if (client->auth_end_offset > 0)\n    {\n      gsize left = strlen (AUTH_END_STRING) - client->auth_end_offset;\n      gsize to_match = MIN (left, buffer->pos);\n      \/* Matched at least up to to_match *\/\n      if (memcmp (buffer->data, &AUTH_END_STRING[client->auth_end_offset], to_match) == 0)\n        {\n          client->auth_end_offset += to_match;\n\n          \/* Matched all *\/\n          if (client->auth_end_offset == strlen (AUTH_END_STRING))\n            return to_match;\n\n          \/* Matched to end of buffer *\/\n          return -1;\n        }\n\n      \/* Did not actually match at start *\/\n      client->auth_end_offset = -1;\n    }\n\n  \/* Look for whole match inside buffer *\/\n  match = memmem (buffer, buffer->pos,\n                  AUTH_END_STRING, strlen (AUTH_END_STRING));\n  if (match != NULL)\n    return match - buffer->data + strlen (AUTH_END_STRING);\n\n  \/* Record longest prefix match at the end *\/\n  for (i = MIN (strlen (AUTH_END_STRING) - 1, buffer->pos); i > 0; i--)\n    {\n      if (memcmp (buffer->data + buffer->pos - i, AUTH_END_STRING, i) == 0)\n        {\n          client->auth_end_offset = i;\n          break;\n        }\n    }\n\n  return -1;\n}","target":1,"flaw_line_index":0,"hash":"f53b5b52-07a6-4cec-b718-82466baec861","idx":"ddf0c301-2313-4139-9ee8-b41c6feac90b"}
{"func_before":"find_auth_end (FlatpakProxyClient *client, Buffer *buffer)\n{\n  goffset offset = 0;\n  gsize original_size = client->auth_buffer->len;\n\n  \/* Add the new data to the remaining data from last iteration *\/\n  g_byte_array_append (client->auth_buffer, buffer->data, buffer->pos);\n\n  while (TRUE)\n    {\n      guint8 *line_start = client->auth_buffer->data + offset;\n      gsize remaining_data = client->auth_buffer->len - offset;\n      guint8 *line_end;\n\n      line_end = memmem (line_start, remaining_data,\n                         AUTH_LINE_SENTINEL, strlen (AUTH_LINE_SENTINEL));\n      if (line_end) \/* Found end of line *\/\n        {\n          offset = (line_end + strlen (AUTH_LINE_SENTINEL) - line_start);\n\n          if (!auth_line_is_valid (line_start, line_end))\n            return FIND_AUTH_END_ABORT;\n\n          *line_end = 0;\n          if (auth_line_is_begin (line_start))\n            return offset - original_size;\n\n          \/* continue with next line *\/\n        }\n      else\n        {\n          \/* No end-of-line in this buffer *\/\n          g_byte_array_remove_range (client->auth_buffer, 0, offset);\n\n          \/* Abort if more than 16k before newline, similar to what dbus-daemon does *\/\n          if (client->auth_buffer->len >= 16*1024)\n            return FIND_AUTH_END_ABORT;\n\n          return FIND_AUTH_END_CONTINUE;\n        }\n    }\n}","target":0,"flaw_line_index":0,"hash":"d6c1c63a-e928-4d74-8dc4-932070a32d72","idx":"78733f67-2d7e-40e6-8b3d-d1e9cde82bc3"}
{"func_before":"\t\t\tibuf->ops = NULL;\n\t\t\topipe->nrbufs++;\n\t\t\tipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);\n\t\t\tipipe->nrbufs--;\n\t\t\tinput_wakeup = true;\n\t\t} else {\n\t\t\t\/*\n\t\t\t * Get a reference to this pipe buffer,\n\t\t\t * so we can copy the contents over.\n\t\t\t *\/\n\t\t\tpipe_buf_get(ipipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\n\t\t\t\/*\n\t\t\t * Don't inherit the gift flag, we need to\n\t\t\t * prevent multiple steals of this page.\n\t\t\t *\/\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\t\tobuf->len = len;\n\t\t\topipe->nrbufs++;","target":1,"flaw_line_index":0,"hash":"7c098e65-5e0b-4100-b59c-89da80c15d27","idx":"e37ad469-7709-4a85-ac10-139d9d71da7a"}
{"func_before":"\t\t\tibuf->ops = NULL;\n\t\t\topipe->nrbufs++;\n\t\t\tipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);\n\t\t\tipipe->nrbufs--;\n\t\t\tinput_wakeup = true;\n\t\t} else {\n\t\t\t\/*\n\t\t\t * Get a reference to this pipe buffer,\n\t\t\t * so we can copy the contents over.\n\t\t\t *\/\n\t\t\tif (!pipe_buf_get(ipipe, ibuf)) {\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*obuf = *ibuf;\n\n\t\t\t\/*\n\t\t\t * Don't inherit the gift flag, we need to\n\t\t\t * prevent multiple steals of this page.\n\t\t\t *\/\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\t\tobuf->len = len;\n\t\t\topipe->nrbufs++;","target":0,"flaw_line_index":0,"hash":"3f138f9f-a9f9-4349-be14-b43e4db8d5da","idx":"cc2e318a-a616-46dd-9b53-1167386016f9"}
{"func_before":"{\n    int ret = 0;\n    int id = 1;\n    Packet *p1 = NULL;\n    DefragTracker *tracker1 = NULL, *tracker2 = NULL;\n\n    DefragInit();\n\n    \/* Build a packet, its not a fragment but shouldn't matter for\n     * this test. *\/\n    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n    if (p1 == NULL) {\n        goto end;\n    }\n\n    \/* Get a tracker. It shouldn't look like its already in use. *\/\n    tracker1 = DefragGetTracker(NULL, NULL, p1);\n    if (tracker1 == NULL) {\n        goto end;\n    }\n    if (tracker1->seen_last) {","target":1,"flaw_line_index":0,"hash":"2f34301a-6740-4b8c-83df-8bcb8a13bfa5","idx":"0a99e4eb-1904-4cf2-b778-206beab11ab6"}
{"func_before":"{\n    int ret = 0;\n    int id = 1;\n    Packet *p1 = NULL;\n    DefragTracker *tracker1 = NULL, *tracker2 = NULL;\n\n    DefragInit();\n\n    \/* Build a packet, its not a fragment but shouldn't matter for\n     * this test. *\/\n    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n    if (p1 == NULL) {\n        goto end;\n    }\n\n    \/* Get a tracker. It shouldn't look like its already in use. *\/\n    tracker1 = DefragGetTracker(NULL, NULL, p1);\n    if (tracker1 == NULL) {\n        goto end;\n    }\n    if (tracker1->seen_last) {","target":0,"flaw_line_index":0,"hash":"91e62f1e-2e85-4a95-86cd-be3ced34d23d","idx":"e22bdf39-a8c3-4080-acf8-fd2554e02b4d"}
{"func_before":"static void xen_irq_lateeoi_locked(struct irq_info *info)\n{\n\tevtchn_port_t evtchn;\n\n\tevtchn = info->evtchn;\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn;\n\n\tunmask_evtchn(evtchn);\n}","target":1,"flaw_line_index":0,"hash":"1e94bfa4-303c-4816-9641-f3d5fb05b9ad","idx":"94f7f74c-1bb7-407e-90eb-1e312737e22a"}
{"func_before":"static void xen_irq_lateeoi_locked(struct irq_info *info)\n{\n\tevtchn_port_t evtchn;\n\tunsigned int cpu;\n\n\tevtchn = info->evtchn;\n\tif (!VALID_EVTCHN(evtchn) || !list_empty(&info->eoi_list))\n\t\treturn;\n\n\tcpu = info->eoi_cpu;\n\tif (info->eoi_time && info->irq_epoch == per_cpu(irq_epoch, cpu)) {\n\t\tlateeoi_list_add(info);\n\t\treturn;\n\t}\n\n\tinfo->eoi_time = 0;\n\tunmask_evtchn(evtchn);\n}","target":0,"flaw_line_index":0,"hash":"d46bc080-bbfb-477e-bc7f-54655328afbe","idx":"724ca691-a76b-47da-a6ec-426be6737d13"}
{"func_before":"int context_init(SERVICE_OPTIONS *section) { \/* init TLS context *\/\n    \/* create TLS context *\/\n#if OPENSSL_VERSION_NUMBER>=0x10100000L\n    if(section->option.client)\n        section->ctx=SSL_CTX_new(TLS_client_method());\n    else \/* server mode *\/\n        section->ctx=SSL_CTX_new(TLS_server_method());\n    if(!SSL_CTX_set_min_proto_version(section->ctx,\n            section->min_proto_version)) {\n        s_log(LOG_ERR, \"Failed to set the minimum protocol version 0x%X\",\n            section->min_proto_version);\n        return 1; \/* FAILED *\/\n#else \/* OPENSSL_VERSION_NUMBER<0x10100000L *\/\n    if(section->option.client)\n        section->ctx=SSL_CTX_new(section->client_method);\n    else \/* server mode *\/\n        section->ctx=SSL_CTX_new(section->server_method);\n#endif \/* OPENSSL_VERSION_NUMBER<0x10100000L *\/\n    if(!section->ctx) {\n        sslerror(\"SSL_CTX_new\");\n        return 1; \/* FAILED *\/\n    }\n    \/* for callbacks *\/\n    if(!SSL_CTX_set_ex_data(section->ctx, index_ssl_ctx_opt, section)) {\n        sslerror(\"SSL_CTX_set_ex_data\");\n        return 1; \/* FAILED *\/\n    }\n    current_section=section; \/* setup current section for callbacks *\/\n\n    \/* ciphers *\/\n    if(section->cipher_list) {\n        s_log(LOG_DEBUG, \"Ciphers: %s\", section->cipher_list);\n        if(!SSL_CTX_set_cipher_list(section->ctx, section->cipher_list)) {\n            sslerror(\"SSL_CTX_set_cipher_list\");\n            return 1; \/* FAILED *\/\n        }\n    }\n\n        section->ssl_options_set, section->ssl_options_clear);\n#else \/* OpenSSL older than 0.9.8m *\/\n    s_log(LOG_DEBUG, \"TLS options: 0x%08lX (+0x%08lX)\",\n        SSL_CTX_get_options(section->ctx), section->ssl_options_set);\n#endif \/* OpenSSL 0.9.8m or later *\/\n\n    \/* initialize OpenSSL CONF options *\/\n    if(conf_init(section))\n        return 1; \/* FAILED *\/\n\n    \/* mode *\/\n#ifdef SSL_MODE_RELEASE_BUFFERS\n    SSL_CTX_set_mode(section->ctx,\n        SSL_MODE_ENABLE_PARTIAL_WRITE |\n        SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER |\n        SSL_MODE_RELEASE_BUFFERS);\n#else\n    SSL_CTX_set_mode(section->ctx,\n        SSL_MODE_ENABLE_PARTIAL_WRITE |\n        SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);\n#endif\n    SSL_CTX_set_info_callback(section->ctx, info_callback);\n\n    \/* load certificate and private key to be verified by the peer server *\/\n    if(auth_init(section))\n        return 1; \/* FAILED *\/\n\n    \/* initialize verification of the peer server certificate *\/\n    if(verify_init(section))\n        return 1; \/* FAILED *\/\n\n    \/* initialize the DH\/ECDH key agreement in the server mode *\/\n    if(!section->option.client) {\n#ifndef OPENSSL_NO_TLSEXT\n        SSL_CTX_set_tlsext_servername_callback(section->ctx, servername_cb);\n#endif \/* OPENSSL_NO_TLSEXT *\/\n#ifndef OPENSSL_NO_DH\n        dh_init(section); \/* ignore the result (errors are not critical) *\/\n#endif \/* OPENSSL_NO_DH *\/\n#ifndef OPENSSL_NO_ECDH\n        ecdh_init(section); \/* ignore the result (errors are not critical) *\/\n#endif \/* OPENSSL_NO_ECDH *\/\n    }\n\n    return 0; \/* OK *\/\n}","target":1,"flaw_line_index":0,"hash":"28de5d87-85a1-4dda-a1db-c1fe6f6fda2f","idx":"4739f3f5-8d78-4c46-ae58-db1030c678fd"}
{"func_before":"int context_init(SERVICE_OPTIONS *section) { \/* init TLS context *\/\n    \/* create a new TLS context *\/\n#if OPENSSL_VERSION_NUMBER>=0x10100000L\n    if(section->option.client)\n        section->ctx=SSL_CTX_new(TLS_client_method());\n    else \/* server mode *\/\n        section->ctx=SSL_CTX_new(TLS_server_method());\n    if(!SSL_CTX_set_min_proto_version(section->ctx,\n            section->min_proto_version)) {\n        s_log(LOG_ERR, \"Failed to set the minimum protocol version 0x%X\",\n            section->min_proto_version);\n        return 1; \/* FAILED *\/\n#else \/* OPENSSL_VERSION_NUMBER<0x10100000L *\/\n    if(section->option.client)\n        section->ctx=SSL_CTX_new(section->client_method);\n    else \/* server mode *\/\n        section->ctx=SSL_CTX_new(section->server_method);\n#endif \/* OPENSSL_VERSION_NUMBER<0x10100000L *\/\n    if(!section->ctx) {\n        sslerror(\"SSL_CTX_new\");\n        return 1; \/* FAILED *\/\n    }\n\n    \/* allow callbacks to access their SERVICE_OPTIONS structure *\/\n    if(!SSL_CTX_set_ex_data(section->ctx, index_ssl_ctx_opt, section)) {\n        sslerror(\"SSL_CTX_set_ex_data\");\n        return 1; \/* FAILED *\/\n    }\n    current_section=section; \/* setup current section for callbacks *\/\n\n#if OPENSSL_VERSION_NUMBER>=0x10100000L\n    \/* set the security level *\/\n    if(section->security_level>=0) {\n        \/* set the user-specified value *\/\n        SSL_CTX_set_security_level(section->ctx, section->security_level);\n        s_log(LOG_INFO, \"User-specified security level set: %d\",\n            section->security_level);\n    } else if(SSL_CTX_get_security_level(section->ctx)<DEFAULT_SECURITY_LEVEL) {\n        \/* set our default, as it is more secure than the OpenSSL default *\/\n        SSL_CTX_set_security_level(section->ctx, DEFAULT_SECURITY_LEVEL);\n        s_log(LOG_INFO, \"stunnel default security level set: %d\",\n            DEFAULT_SECURITY_LEVEL);\n    } else { \/* our default is not more secure than the OpenSSL default *\/\n        s_log(LOG_INFO, \"OpenSSL security level is used: %d\",\n            SSL_CTX_get_security_level(section->ctx));\n    }\n#endif \/* OpenSSL 1.1.0 or later *\/\n\n    \/* ciphers *\/\n    if(section->cipher_list) {\n        s_log(LOG_DEBUG, \"Ciphers: %s\", section->cipher_list);\n        if(!SSL_CTX_set_cipher_list(section->ctx, section->cipher_list)) {\n            sslerror(\"SSL_CTX_set_cipher_list\");\n            return 1; \/* FAILED *\/\n        }\n    }\n\n        section->ssl_options_set, section->ssl_options_clear);\n#else \/* OpenSSL older than 0.9.8m *\/\n    s_log(LOG_DEBUG, \"TLS options: 0x%08lX (+0x%08lX)\",\n        SSL_CTX_get_options(section->ctx), section->ssl_options_set);\n#endif \/* OpenSSL 0.9.8m or later *\/\n\n    \/* initialize OpenSSL CONF options *\/\n    if(conf_init(section))\n        return 1; \/* FAILED *\/\n\n    \/* setup mode of operation for the TLS state machine *\/\n#ifdef SSL_MODE_RELEASE_BUFFERS\n    SSL_CTX_set_mode(section->ctx,\n        SSL_MODE_ENABLE_PARTIAL_WRITE |\n        SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER |\n        SSL_MODE_RELEASE_BUFFERS);\n#else\n    SSL_CTX_set_mode(section->ctx,\n        SSL_MODE_ENABLE_PARTIAL_WRITE |\n        SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER);\n#endif\n    SSL_CTX_set_info_callback(section->ctx, info_callback);\n\n    \/* load certificate and private key to be verified by the peer server *\/\n    if(auth_init(section))\n        return 1; \/* FAILED *\/\n\n    \/* initialize verification of the peer server certificate *\/\n    if(verify_init(section))\n        return 1; \/* FAILED *\/\n\n    \/* initialize the DH\/ECDH key agreement *\/\n#ifndef OPENSSL_NO_TLSEXT\n    if(!section->option.client)\n        SSL_CTX_set_tlsext_servername_callback(section->ctx, servername_cb);\n#endif \/* OPENSSL_NO_TLSEXT *\/\n#ifndef OPENSSL_NO_DH\n    dh_init(section); \/* ignore the result (errors are not critical) *\/\n#endif \/* OPENSSL_NO_DH *\/\n#ifndef OPENSSL_NO_ECDH\n    ecdh_init(section); \/* ignore the result (errors are not critical) *\/\n#endif \/* OPENSSL_NO_ECDH *\/\n\n    return 0; \/* OK *\/\n}","target":0,"flaw_line_index":0,"hash":"f9155e0b-eeb2-417a-ae2a-64c6c7f9d210","idx":"3413e523-fa76-499e-868d-a5b843d06f30"}
{"func_before":"sudo_passwd_verify(const struct sudoers_context *ctx, struct passwd *pw,\n    const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback)\n{\n    char des_pass[9], *epass;\n    char *pw_epasswd = auth->data;\n    size_t pw_len;\n    int matched = 0;\n    debug_decl(sudo_passwd_verify, SUDOERS_DEBUG_AUTH);\n\n    \/* An empty plain-text password must match an empty encrypted password. *\/\n    if (pass[0] == '\\0')\n\tdebug_return_int(pw_epasswd[0] ? AUTH_FAILURE : AUTH_SUCCESS);\n\n    \/*\n     * Truncate to 8 chars if standard DES since not all crypt()'s do this.\n     *\/\n    pw_len = strlen(pw_epasswd);\n    if (pw_len == DESLEN || HAS_AGEINFO(pw_epasswd, pw_len)) {\n\tstrlcpy(des_pass, pass, sizeof(des_pass));\n\tpass = des_pass;\n    }\n\n    \/*\n     * Normal UN*X password check.\n     * HP-UX may add aging info (separated by a ',') at the end so\n     * only compare the first DESLEN characters in that case.\n     *\/\n    epass = (char *) crypt(pass, pw_epasswd);\n    if (epass != NULL) {\n\tif (HAS_AGEINFO(pw_epasswd, pw_len) && strlen(epass) == DESLEN)\n\t    matched = !strncmp(pw_epasswd, epass, DESLEN);\n\telse\n\t    matched = !strcmp(pw_epasswd, epass);\n    }\n\n    explicit_bzero(des_pass, sizeof(des_pass));\n\n    debug_return_int(matched ? AUTH_SUCCESS : AUTH_FAILURE);\n}","target":1,"flaw_line_index":0,"hash":"affbc89e-234e-4308-973d-a80f00340bbf","idx":"f1553151-6641-4cce-b9eb-c190e681712e"}
{"func_before":"sudo_passwd_verify(const struct sudoers_context *ctx, struct passwd *pw,\n    const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback)\n{\n    char des_pass[9], *epass;\n    char *pw_epasswd = auth->data;\n    size_t pw_len;\n    int ret;\n    debug_decl(sudo_passwd_verify, SUDOERS_DEBUG_AUTH);\n\n    \/* An empty plain-text password must match an empty encrypted password. *\/\n    if (pass[0] == '\\0')\n\tdebug_return_int(pw_epasswd[0] ? AUTH_FAILURE : AUTH_SUCCESS);\n\n    \/*\n     * Truncate to 8 chars if standard DES since not all crypt()'s do this.\n     *\/\n    pw_len = strlen(pw_epasswd);\n    if (pw_len == DESLEN || HAS_AGEINFO(pw_epasswd, pw_len)) {\n\t(void)strlcpy(des_pass, pass, sizeof(des_pass));\n\tpass = des_pass;\n    }\n\n    \/*\n     * Normal UN*X password check.\n     * HP-UX may add aging info (separated by a ',') at the end so\n     * only compare the first DESLEN characters in that case.\n     *\/\n    epass = (char *) crypt(pass, pw_epasswd);\n    ret = AUTH_FAILURE;\n    if (epass != NULL) {\n\tif (HAS_AGEINFO(pw_epasswd, pw_len) && strlen(epass) == DESLEN) {\n\t    if (strncmp(pw_epasswd, epass, DESLEN) == 0)\n\t\tret = AUTH_SUCCESS;\n\t} else {\n\t    if (strcmp(pw_epasswd, epass) == 0)\n\t\tret = AUTH_SUCCESS;\n\t}\n    }\n\n    explicit_bzero(des_pass, sizeof(des_pass));\n\n    debug_return_int(ret);\n}","target":0,"flaw_line_index":0,"hash":"37c257a2-7ecf-4798-a208-aa056df185be","idx":"fa191404-3201-498a-9eef-63df6472de66"}
{"func_before":"\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (es) {\n\t\t\tts->ess[es->pid] = es;\n\t\t\tgf_list_add(pmt->program->streams, es);\n\t\t\tif (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);\n\n\t\t\tnb_es++;\n\t\t}\n\n\t\tif (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;\n\t}\n\n\t\/\/Table 2-139, implied hierarchy indexes\n\tif (nb_hevc_temp + nb_shvc + nb_shvc_temp + nb_mhvc+ nb_mhvc_temp) {\n\t\tfor (i=0; i<gf_list_count(pmt->program->streams); i++) {\n\t\t\tGF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);\n\t\t\tif ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;\n\t\t\tif (es->depends_on_pid) continue;\n\n\t\t\tswitch (es->stream_type) {","target":1,"flaw_line_index":0,"hash":"6ff07958-a007-45f0-b521-92ca2563761f","idx":"04ac6f6a-7714-46ca-acd0-30055cf7604f"}
{"func_before":"\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (es) {\n\t\t\tts->ess[es->pid] = es;\n\t\t\tgf_list_add(pmt->program->streams, es);\n\t\t\tif (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);\n\n\t\t\tnb_es++;\n\n\t\t\tif (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;\n\t\t}\n\t}\n\n\t\/\/Table 2-139, implied hierarchy indexes\n\tif (nb_hevc_temp + nb_shvc + nb_shvc_temp + nb_mhvc+ nb_mhvc_temp) {\n\t\tfor (i=0; i<gf_list_count(pmt->program->streams); i++) {\n\t\t\tGF_M2TS_PES *es = (GF_M2TS_PES *)gf_list_get(pmt->program->streams, i);\n\t\t\tif ( !(es->flags & GF_M2TS_ES_IS_PES)) continue;\n\t\t\tif (es->depends_on_pid) continue;\n\n\t\t\tswitch (es->stream_type) {","target":0,"flaw_line_index":0,"hash":"ea147489-9a80-45a7-b0d8-143080e8a02e","idx":"b2741f63-f860-42e9-8c2f-480c68edca84"}
{"func_before":"\/* static *\/ tsl::Status GpuDriver::GetGpuISAVersion(int* version,\n                                                     CUdevice device) {\n  return tsl::Status{\n      port::error::INTERNAL,\n      \"Feature not supported on CUDA platform (GetGpuISAVersion)\"};\n}","target":1,"flaw_line_index":0,"hash":"a4c70b6a-1a6f-41f7-93af-22f6e6b140db","idx":"99bf13b6-2e0f-4883-9e58-96afd5c24c3e"}
{"func_before":"\/* static *\/ tsl::Status GpuDriver::GetGpuISAVersion(int* version,\n                                                     CUdevice device) {\n  return tsl::Status{\n      tsl::error::INTERNAL,\n      \"Feature not supported on CUDA platform (GetGpuISAVersion)\"};\n}","target":0,"flaw_line_index":0,"hash":"2823d457-ae8d-4f6a-b06f-477664e34285","idx":"e84e745e-4abf-4756-9561-32483ac83916"}
{"func_before":"int Archive::Read(void *Data,size_t Size)\n{\n  size_t Result;\n  if (QOpen.Read(Data,Size,Result))\n    return (int)Result;\n  return File::Read(Data,Size);\n}","target":1,"flaw_line_index":0,"hash":"d94af6e3-cec4-4f8a-bd7c-4667aa08c768","idx":"750c272e-968e-4499-810d-42fb7b93cadb"}
{"func_before":"int Archive::Read(void *Data,size_t Size)\n{\n#ifdef USE_QOPEN\n  size_t QResult;\n  if (QOpen.Read(Data,Size,QResult))\n    return (int)QResult;\n#endif\n#ifdef USE_ARCMEM\n  size_t AResult;\n  if (ArcMem.Read(Data,Size,AResult))\n    return (int)AResult;\n#endif\n  return File::Read(Data,Size);\n}","target":0,"flaw_line_index":0,"hash":"0dc28f0e-fcb2-4c9e-abe7-b7822556636d","idx":"a131619d-85c4-433e-a01c-689e57ce554a"}
{"func_before":"    char_u\t*s;\n\n    \/\/ check if it is a valid value for 'complete' -- Acevedo\n    for (s = *varp; *s;)\n    {\n\twhile (*s == ',' || *s == ' ')\n\t    s++;\n\tif (!*s)\n\t    break;\n\tif (vim_strchr((char_u *)\".wbuksid]tU\", *s) == NULL)\n\t    return illegal_char(args->os_errbuf, *s);\n\tif (*++s != NUL && *s != ',' && *s != ' ')\n\t{\n\t    if (s[-1] == 'k' || s[-1] == 's')\n\t    {\n\t\t\/\/ skip optional filename after 'k' and 's'\n\t\twhile (*s && *s != ',' && *s != ' ')\n\t\t{\n\t\t    if (*s == '\\\\' && s[1] != NUL)\n\t\t\t++s;\n\t\t    ++s;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (args->os_errbuf != NULL)\n\t\t{\n\t\t    sprintf((char *)args->os_errbuf,\n\t\t\t    _(e_illegal_character_after_chr), *--s);\n\t\t    return args->os_errbuf;\n\t\t}\n\t\treturn \"\";\n\t    }\n\t}\n    }\n\n    return NULL;\n}","target":1,"flaw_line_index":0,"hash":"9e5b67d3-9108-4cfd-b771-0a49228004c3","idx":"84c212b1-fb1a-43b9-b4f4-7762ab1a5383"}
{"func_before":"    char_u\t*s;\n\n    \/\/ check if it is a valid value for 'complete' -- Acevedo\n    for (s = *varp; *s;)\n    {\n\twhile (*s == ',' || *s == ' ')\n\t    s++;\n\tif (!*s)\n\t    break;\n\tif (vim_strchr((char_u *)\".wbuksid]tU\", *s) == NULL)\n\t    return illegal_char(args->os_errbuf, args->os_errbuflen, *s);\n\tif (*++s != NUL && *s != ',' && *s != ' ')\n\t{\n\t    if (s[-1] == 'k' || s[-1] == 's')\n\t    {\n\t\t\/\/ skip optional filename after 'k' and 's'\n\t\twhile (*s && *s != ',' && *s != ' ')\n\t\t{\n\t\t    if (*s == '\\\\' && s[1] != NUL)\n\t\t\t++s;\n\t\t    ++s;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tif (args->os_errbuf != NULL)\n\t\t{\n\t\t    snprintf((char *)args->os_errbuf, args->os_errbuflen,\n\t\t\t    _(e_illegal_character_after_chr), *--s);\n\t\t    return args->os_errbuf;\n\t\t}\n\t\treturn \"\";\n\t    }\n\t}\n    }\n\n    return NULL;\n}","target":0,"flaw_line_index":0,"hash":"e63a61c4-e32d-40c2-8156-97714d743dcc","idx":"91414af7-8d9d-458e-b0db-497632616aba"}
{"func_before":"    void runTest() override\n    {\n        beginTest (\"ZIP\");\n\n        ZipFile::Builder builder;\n        StringArray entryNames { \"first\", \"second\", \"third\" };\n        HashMap<String, MemoryBlock> blocks;\n\n        for (auto& entryName : entryNames)\n        {\n            auto& block = blocks.getReference (entryName);\n            MemoryOutputStream mo (block, false);\n            mo << entryName;\n            mo.flush();\n            builder.addEntry (new MemoryInputStream (block, false), 9, entryName, Time::getCurrentTime());\n        }\n\n        MemoryBlock data;\n        MemoryOutputStream mo (data, false);\n        builder.writeToStream (mo, nullptr);\n        MemoryInputStream mi (data, false);\n\n        ZipFile zip (mi);\n\n        expectEquals (zip.getNumEntries(), entryNames.size());\n\n        for (auto& entryName : entryNames)\n        {\n            auto* entry = zip.getEntry (entryName);\n            std::unique_ptr<InputStream> input (zip.createStreamForEntry (*entry));\n            expectEquals (input->readEntireStreamAsString(), entryName);\n        }\n    }","target":1,"flaw_line_index":0,"hash":"f387d1da-50c4-42b4-b755-add5eece8d2b","idx":"e8acec5b-b8fe-4dc9-876a-ea5c2d7d62ef"}
{"func_before":"    void runTest() override\n    {\n        beginTest (\"ZIP\");\n\n        StringArray entryNames { \"first\", \"second\", \"third\" };\n        auto data = createZipMemoryBlock (entryNames);\n        MemoryInputStream mi (data, false);\n        ZipFile zip (mi);\n\n        expectEquals (zip.getNumEntries(), entryNames.size());\n\n        for (auto& entryName : entryNames)\n        {\n            auto* entry = zip.getEntry (entryName);\n            std::unique_ptr<InputStream> input (zip.createStreamForEntry (*entry));\n            expectEquals (input->readEntireStreamAsString(), entryName);\n        }\n\n        beginTest (\"ZipSlip\");\n        runZipSlipTest();\n    }","target":0,"flaw_line_index":0,"hash":"01d326e9-b451-44bf-90dd-0102010a26a9","idx":"d30b46f3-8808-4b4a-bbbd-6ee6baf21c5b"}
{"func_before":"\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_set(args);\n\n\t\/*\n\t * Find a \"hole\" in the attribute address space large enough for\n\t * us to drop the new attribute's value into. Because CRC enable\n\t * attributes have headers, we can't just do a straight byte to FSB\n\t * conversion and have to take the header space into account.\n\t *\/\n\tblkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\terror = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,\n\t\t\t\t\t\t   XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\n\targs->rmtblkno = lblkno = (xfs_dablk_t)lfileoff;\n\targs->rmtblkcnt = blkcnt;\n\n\t\/*\n\t * Roll through the \"value\", allocating blocks on disk as required.\n\t}\n\n\t\/*\n\t * Roll through the \"value\", copying the attribute value to the\n\t * already-allocated blocks.  Blocks are written synchronously\n\t * so that we can know they are all on disk before we turn off\n\t * the INCOMPLETE flag.\n\t *\/\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tvaluelen = args->valuelen;\n\twhile (valuelen > 0) {\n\t\tstruct xfs_buf\t*bp;\n\t\txfs_daddr_t\tdblkno;\n\t\tint\t\tdblkcnt;\n\n\t\tASSERT(blkcnt > 0);\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)lblkno,","target":1,"flaw_line_index":0,"hash":"bce08b1a-6c39-4c87-9ad7-f0426bd8fec8","idx":"0efd83b6-bcef-4521-910b-d4d09308ed3e"}
{"func_before":"\tint\t\t\toffset = 0;\n\n\ttrace_xfs_attr_rmtval_set(args);\n\n\t\/*\n\t * Find a \"hole\" in the attribute address space large enough for\n\t * us to drop the new attribute's value into. Because CRC enable\n\t * attributes have headers, we can't just do a straight byte to FSB\n\t * conversion and have to take the header space into account.\n\t *\/\n\tblkcnt = xfs_attr3_rmt_blocks(mp, args->rmtvaluelen);\n\terror = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,\n\t\t\t\t\t\t   XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\n\targs->rmtblkno = lblkno = (xfs_dablk_t)lfileoff;\n\targs->rmtblkcnt = blkcnt;\n\n\t\/*\n\t * Roll through the \"value\", allocating blocks on disk as required.\n\t}\n\n\t\/*\n\t * Roll through the \"value\", copying the attribute value to the\n\t * already-allocated blocks.  Blocks are written synchronously\n\t * so that we can know they are all on disk before we turn off\n\t * the INCOMPLETE flag.\n\t *\/\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tstruct xfs_buf\t*bp;\n\t\txfs_daddr_t\tdblkno;\n\t\tint\t\tdblkcnt;\n\n\t\tASSERT(blkcnt > 0);\n\n\t\txfs_bmap_init(args->flist, args->firstblock);\n\t\tnmap = 1;\n\t\terror = xfs_bmapi_read(dp, (xfs_fileoff_t)lblkno,","target":0,"flaw_line_index":0,"hash":"6edcf62f-b2b0-4845-bdc1-48d71a33c0db","idx":"b0359bf9-9ed8-4a0e-8d15-a2a5024ad59c"}
{"func_before":"static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,\n        bigint *modulus, bigint *pub_exp)\n{\n    int i, size;\n    bigint *decrypted_bi, *dat_bi;\n    bigint *bir = NULL;\n    uint8_t *block = (uint8_t *)malloc(sig_len);\n\n    \/* decrypt *\/\n    dat_bi = bi_import(ctx, sig, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    \/* convert to a normal block *\/\n    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);\n\n    bi_export(ctx, decrypted_bi, block, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    i = 10; \/* start at the first possible non-padded byte *\/\n    while (block[i++] && i < sig_len);\n    size = sig_len - i;\n\n    \/* get only the bit we want *\/\n    if (size > 0)\n    {\n        int len;\n        const uint8_t *sig_ptr = get_signature(&block[i], &len);\n\n        if (sig_ptr)\n        {\n            bir = bi_import(ctx, sig_ptr, len);\n        }\n    }\n    free(block);\n    \/* save a few bytes of memory *\/\n    bi_clear_cache(ctx);\n    return bir;\n}","target":1,"flaw_line_index":0,"hash":"e5d089ec-34bc-4d13-8812-222521ca2b9c","idx":"29a31f3a-186d-4b0b-aa9a-cb5a0ac1103f"}
{"func_before":"static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len, uint8_t sig_type,\n        bigint *modulus, bigint *pub_exp)\n{\n    int i;\n    bigint *decrypted_bi, *dat_bi;\n    bigint *bir = NULL;\n    uint8_t *block = (uint8_t *)malloc(sig_len);\n\n    const uint8_t *sig_prefix = NULL;\n    uint8_t sig_prefix_size = 0, hash_len = 0;\n    \/* adjust our expections *\/\n    switch (sig_type)\n    {\n        case SIG_TYPE_MD5:\n            sig_prefix = sig_prefix_md5;\n            sig_prefix_size = sizeof(sig_prefix_md5);\n        break;\n        case SIG_TYPE_SHA1:\n            sig_prefix = sig_prefix_sha1;\n            sig_prefix_size = sizeof(sig_prefix_sha1);\n        break;\n        case SIG_TYPE_SHA256:\n            sig_prefix = sig_prefix_sha256;\n            sig_prefix_size = sizeof(sig_prefix_sha256);\n        break;\n        case SIG_TYPE_SHA384:\n            sig_prefix = sig_prefix_sha384;\n            sig_prefix_size = sizeof(sig_prefix_sha384);\n        break;\n        case SIG_TYPE_SHA512:\n            sig_prefix = sig_prefix_sha512;\n            sig_prefix_size = sizeof(sig_prefix_sha512);\n        break;\n    }\n    if (sig_prefix)\n        hash_len = sig_prefix[sig_prefix_size - 1];\n\n    \/* check length (#A) *\/\n    if (sig_len < 2 + 8 + 1 + sig_prefix_size + hash_len)\n        goto err;\n\n    \/* decrypt *\/\n    dat_bi = bi_import(ctx, sig, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    \/* convert to a normal block *\/\n    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);\n\n    bi_export(ctx, decrypted_bi, block, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    \/* check the first 2 bytes *\/\n    if (block[0] != 0 || block[1] != 1)\n        goto err;\n\n    \/* check the padding *\/\n    i = 2; \/* start at the first padding byte *\/\n    while (i < sig_len - 1 - sig_prefix_size - hash_len)\n    { \/* together with (#A), we require at least 8 bytes of padding *\/\n        if (block[i++] != 0xFF)\n            goto err;\n    }\n\n    \/* check end of padding *\/\n    if (block[i++] != 0)\n        goto err;\n\n    \/* check the ASN.1 metadata *\/\n    if (memcmp_P(block+i, sig_prefix, sig_prefix_size))\n        goto err;\n\n    \/* now we can get the hash we need *\/\n    bir = bi_import(ctx, block + i + sig_prefix_size, hash_len);\n\nerr:\n    free(block);\n    \/* save a few bytes of memory *\/\n    bi_clear_cache(ctx);\n    return bir;\n}","target":0,"flaw_line_index":0,"hash":"31d798c2-6c60-49db-9878-bb2f71b73b81","idx":"02aef7f9-6d88-45a4-ac29-0033dc614452"}
{"func_before":"                errors::InvalidArgument(\"pooling_ratio field must \"\n                                        \"specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional max pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      \/\/ If both seeds are not set when deterministic_ is true, force set seeds.\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();","target":1,"flaw_line_index":0,"hash":"84d89071-4918-45dc-9327-a8d2e4edca0c","idx":"83ad4367-0be3-4771-ae44-6b984fd48562"}
{"func_before":"                errors::InvalidArgument(\"pooling_ratio field must \"\n                                        \"specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional max pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      \/\/ If both seeds are not set when deterministic_ is true, force set seeds.\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();","target":0,"flaw_line_index":0,"hash":"38a8f444-4b64-4d4e-ae5f-07df4f7be83e","idx":"8969fee1-32eb-48b7-8323-3a5014cf3600"}
{"func_before":"\t\texfat_debug(\"failed to get stream dentry\\n\");\n\t\t*skip_dentries = 2;\n\t\tgoto skip_dset;\n\t}\n\n\t*new_node = NULL;\n\tnode = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tfor (i = 2; i <= file_de->file_num_ext; i++) {\n\t\tret = exfat_de_iter_get(iter, i, &dentry);\n\t\tif (ret || dentry->type != EXFAT_NAME)\n\t\t\tbreak;\n\t\tmemcpy(node->name +\n\t\t       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,\n\t\t       sizeof(dentry->name_unicode));\n\t}\n\n\tnode->first_clus = le32_to_cpu(stream_de->stream_start_clu);\n\tnode->is_contiguous =","target":1,"flaw_line_index":0,"hash":"a867eadd-4073-4c0e-abe3-ceea154d36dc","idx":"c6c12750-c46f-4d78-817b-aa094740324b"}
{"func_before":"\t\texfat_debug(\"failed to get stream dentry\\n\");\n\t\t*skip_dentries = 2;\n\t\tgoto skip_dset;\n\t}\n\n\t*new_node = NULL;\n\tnode = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tfor (i = 2; i <= MIN(file_de->file_num_ext, 1 + MAX_NAME_DENTRIES); i++) {\n\t\tret = exfat_de_iter_get(iter, i, &dentry);\n\t\tif (ret || dentry->type != EXFAT_NAME)\n\t\t\tbreak;\n\t\tmemcpy(node->name +\n\t\t       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,\n\t\t       sizeof(dentry->name_unicode));\n\t}\n\n\tnode->first_clus = le32_to_cpu(stream_de->stream_start_clu);\n\tnode->is_contiguous =","target":0,"flaw_line_index":0,"hash":"443f06b0-fbab-404e-9ea7-16d68eaa6595","idx":"f0c68f99-8a99-4c5c-a579-497d63290580"}
{"func_before":"\t}\n\n\t\/* On a TCP-style socket, block for at most linger_time if set. *\/\n\tif (sctp_style(sk, TCP) && timeout)\n\t\tsctp_wait_for_close(sk, timeout);\n\n\t\/* This will run the backlog queue.  *\/\n\trelease_sock(sk);\n\n\t\/* Supposedly, no process has access to the socket, but\n\t * the net layers still may.\n\t *\/\n\tlocal_bh_disable();\n\tbh_lock_sock(sk);\n\n\t\/* Hold the sock, since sk_common_release() will put sock_put()\n\t * and we have just a little more cleanup.\n\t *\/\n\tsock_hold(sk);\n\tsk_common_release(sk);\n\n\tbh_unlock_sock(sk);\n\tlocal_bh_enable();\n\n\tsock_put(sk);\n\n\tSCTP_DBG_OBJCNT_DEC(sock);\n}","target":1,"flaw_line_index":0,"hash":"cf731dd7-b04e-4d30-b222-9df935fbb822","idx":"31c407d4-6ca3-4552-b512-d2b419695421"}
{"func_before":"\n\t\/* On a TCP-style socket, block for at most linger_time if set. *\/\n\tif (sctp_style(sk, TCP) && timeout)\n\t\tsctp_wait_for_close(sk, timeout);\n\n\t\/* This will run the backlog queue.  *\/\n\trelease_sock(sk);\n\n\t\/* Supposedly, no process has access to the socket, but\n\t * the net layers still may.\n\t * Also, sctp_destroy_sock() needs to be called with addr_wq_lock\n\t * held and that should be grabbed before socket lock.\n\t *\/\n\tspin_lock_bh(&net->sctp.addr_wq_lock);\n\tbh_lock_sock(sk);\n\n\t\/* Hold the sock, since sk_common_release() will put sock_put()\n\t * and we have just a little more cleanup.\n\t *\/\n\tsock_hold(sk);\n\tsk_common_release(sk);\n\n\tbh_unlock_sock(sk);\n\tspin_unlock_bh(&net->sctp.addr_wq_lock);\n\n\tsock_put(sk);\n\n\tSCTP_DBG_OBJCNT_DEC(sock);\n}","target":0,"flaw_line_index":0,"hash":"e5b323e5-29c1-4395-8612-467c84118abb","idx":"837fa7a5-9750-42ec-8a29-497e1bff216f"}
{"func_before":"static pyc_object *get_list_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (list size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_LIST;","target":1,"flaw_line_index":0,"hash":"6983e613-21dd-4fee-95ea-b10d4f2f82f1","idx":"2e0e372b-f77d-4733-8f21-84477085116f"}
{"func_before":"static pyc_object *get_list_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (list size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_LIST;","target":0,"flaw_line_index":0,"hash":"1f24d735-1040-4c57-b1b2-a022fb4b3e9f","idx":"6bf06298-5eba-497d-b05f-dfe13711806b"}
{"func_before":"\t\tlog_warn(\"sonmp\", \"failed to allocate remote port\");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\tif (length < SONMP_SIZE) {\n\t\tlog_warnx(\"sonmp\", \"too short SONMP frame received on %s\", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (PEEK_CMP(mcastaddr, sizeof(mcastaddr)) != 0)\n\t\t\/* There is two multicast address. We just handle only one of\n\t\t * them. *\/\n\t\tgoto malformed;\n\t\/* We skip to LLC PID *\/\n\tPEEK_DISCARD(ETHER_ADDR_LEN); PEEK_DISCARD_UINT16;\n\tPEEK_DISCARD(6);","target":1,"flaw_line_index":0,"hash":"6d1770d6-b56c-4726-970a-f5027f56ad55","idx":"b272d40d-bc85-49ee-a754-f6b4b42a7471"}
{"func_before":"\t\tlog_warn(\"sonmp\", \"failed to allocate remote port\");\n\t\tfree(chassis);\n\t\treturn -1;\n\t}\n#ifdef ENABLE_DOT1\n\tTAILQ_INIT(&port->p_vlans);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\tif (length < SONMP_SIZE + 2*ETHER_ADDR_LEN + sizeof(u_int16_t)) {\n\t\tlog_warnx(\"sonmp\", \"too short SONMP frame received on %s\", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (PEEK_CMP(mcastaddr, sizeof(mcastaddr)) != 0)\n\t\t\/* There is two multicast address. We just handle only one of\n\t\t * them. *\/\n\t\tgoto malformed;\n\t\/* We skip to LLC PID *\/\n\tPEEK_DISCARD(ETHER_ADDR_LEN); PEEK_DISCARD_UINT16;\n\tPEEK_DISCARD(6);","target":0,"flaw_line_index":0,"hash":"97b4c0a5-cf6d-459d-af05-67111bc6f3b6","idx":"7a3b699f-3dcc-4ffe-843a-3a08cf934f21"}
{"func_before":"unsigned char *base64decode(const char *buf, size_t *size)\n{\n\tif (!buf || !size) return NULL;\n\tsize_t len = (*size > 0) ? *size : strlen(buf);\n\tif (len <= 0) return NULL;\n\tunsigned char *outbuf = (unsigned char*)malloc((len\/4)*3+3);\n\tconst char *ptr = buf;\n\tint p = 0;\n\tsize_t l = 0;\n\n\tdo {\n\t\tptr += strspn(ptr, \"\\r\\n\\t \");\n\t\tif (*ptr == '\\0' || ptr >= buf+len) {\n\t\t\tbreak;\n\t\t}\n\t\tl = strcspn(ptr, \"\\r\\n\\t \");\n\t\tif (l > 3 && ptr+l <= buf+len) {\n\t\t\tp+=base64decode_block(outbuf+p, ptr, l);\n\t\t\tptr += l;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t} while (1);\n\n\toutbuf[p] = 0;\n\t*size = p;\n\treturn outbuf;\n}","target":1,"flaw_line_index":0,"hash":"7e9a73a5-af7a-4f6a-95f1-c7e54d3e38c6","idx":"d0122664-284b-4e1e-a373-e3496822e0e1"}
{"func_before":"unsigned char *base64decode(const char *buf, size_t *size)\n{\n\tif (!buf || !size) return NULL;\n\tsize_t len = (*size > 0) ? *size : strlen(buf);\n\tif (len <= 0) return NULL;\n\tunsigned char *outbuf = (unsigned char*)malloc((len\/4)*3+3);\n\tconst char *ptr = buf;\n\tint p = 0;\n\tint wv, w1, w2, w3, w4;\n\tint tmpval[4];\n\tint tmpcnt = 0;\n\n\tdo {\n\t\twhile (ptr < buf+len && (*ptr == ' ' || *ptr == '\\t' || *ptr == '\\n' || *ptr == '\\r')) {\n\t\t\tptr++;\n\t\t}\n\t\tif (*ptr == '\\0' || ptr >= buf+len) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((wv = base64_table[(int)(unsigned char)*ptr++]) == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\ttmpval[tmpcnt++] = wv;\n\t\tif (tmpcnt == 4) {\n\t\t\ttmpcnt = 0;\n\t\t\tw1 = tmpval[0];\n\t\t\tw2 = tmpval[1];\n\t\t\tw3 = tmpval[2];\n\t\t\tw4 = tmpval[3];\n\n\t\t\tif (w2 >= 0) {\n\t\t\t\toutbuf[p++] = (unsigned char)(((w1 << 2) + (w2 >> 4)) & 0xFF);\n\t\t\t}\n\t\t\tif (w3 >= 0) {\n\t\t\t\toutbuf[p++] = (unsigned char)(((w2 << 4) + (w3 >> 2)) & 0xFF);\n\t\t\t}\n\t\t\tif (w4 >= 0) {\n\t\t\t\toutbuf[p++] = (unsigned char)(((w3 << 6) + w4) & 0xFF);\n\t\t\t}\n\t\t}\n\t} while (1);\n\n\toutbuf[p] = 0;\n\t*size = p;\n\treturn outbuf;\n}","target":0,"flaw_line_index":0,"hash":"33179ed1-138c-47dd-9f7e-28f2d243c2ca","idx":"8b7cce4b-b761-477a-9d80-2b00766bd03e"}
{"func_before":"\t *\/\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\t\/* Fallback to buffered I\/O if we do not support append dio. *\/\n\tif (iocb->ki_pos + iter->count > i_size_read(inode) &&\n\t    !ocfs2_supports_append_dio(osb))\n\t\treturn 0;\n\n\tif (iov_iter_rw(iter) == READ)\n\t\tget_block = ocfs2_get_block;\n\telse\n\t\tget_block = ocfs2_dio_get_block;\n\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t    iter, get_block,\n\t\t\t\t    ocfs2_dio_end_io, NULL, 0);\n}","target":1,"flaw_line_index":0,"hash":"0a17746a-08bd-439d-938d-43b8cfa632f1","idx":"b77e7bec-150c-4379-9f9f-a8f2ca508125"}
{"func_before":"\t *\/\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\treturn 0;\n\n\t\/* Fallback to buffered I\/O if we do not support append dio. *\/\n\tif (iocb->ki_pos + iter->count > i_size_read(inode) &&\n\t    !ocfs2_supports_append_dio(osb))\n\t\treturn 0;\n\n\tif (iov_iter_rw(iter) == READ)\n\t\tget_block = ocfs2_lock_get_block;\n\telse\n\t\tget_block = ocfs2_dio_wr_get_block;\n\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t    iter, get_block,\n\t\t\t\t    ocfs2_dio_end_io, NULL, 0);\n}","target":0,"flaw_line_index":0,"hash":"fe54f951-cb06-45fb-8690-2cc06e3aa380","idx":"3cf1315a-f095-4174-a521-b5e03e562cad"}
{"func_before":"static void __net_random_once_deferred(struct work_struct *w)\n{\n\tstruct __net_random_once_work *work =\n\t\tcontainer_of(w, struct __net_random_once_work, work);\n\tif (!static_key_enabled(work->key))\n\t\tstatic_key_slow_inc(work->key);\n\tkfree(work);\n}","target":1,"flaw_line_index":0,"hash":"02afeab5-252d-4f5d-a74e-ff537c4c9ea6","idx":"1ace78b6-2f69-4151-8bb5-b419d8f432be"}
{"func_before":"static void __net_random_once_deferred(struct work_struct *w)\n{\n\tstruct __net_random_once_work *work =\n\t\tcontainer_of(w, struct __net_random_once_work, work);\n\tBUG_ON(!static_key_enabled(work->key));\n\tstatic_key_slow_dec(work->key);\n\tkfree(work);\n}","target":0,"flaw_line_index":0,"hash":"1333b620-9fef-4a7a-8ab9-631919dcc7c2","idx":"0e510216-1543-4d54-a7d5-e791d00d63e0"}
{"func_before":"\t\t\tstruct rt6_info *rt)\n\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\t\/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t *\/\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\n\t\t\/* reserve space for Hardware header *\/\n\t\tskb_reserve(skb, hh_len);\n\n\t\t\/* create space for UDP\/IP header *\/\n\n\t\t\/* initialize network header pointer *\/\n\t\tskb_reset_network_header(skb);\n\n\t\t\/* initialize protocol header pointer *\/\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\t}\n\n\terr = skb_append_datato_frags(sk,skb, getfrag, from,\n\t\t\t\t      (length - transhdrlen));\n\tif (!err) {\n\t\tstruct frag_hdr fhdr;\n\n\t\t\/* Specify the length of each IPv6 datagram fragment.\n\t\t * It has to be a multiple of 8.\n\t\t *\/\n\t\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\tipv6_select_ident(&fhdr, rt);\n\t\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\n\t\treturn 0;\n\t}\n\t\/* There is not enough support do UPD LSO,\n\t * so follow normal path\n\t *\/\n\tkfree_skb(skb);\n\n\treturn err;\n}","target":1,"flaw_line_index":0,"hash":"041b3ea9-4da6-410b-999f-703330e3e402","idx":"dc69b5c6-2a83-4032-99f3-8ce87107d4f5"}
{"func_before":"\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\t\/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t *\/\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tstruct frag_hdr fhdr;\n\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\n\t\t\/* reserve space for Hardware header *\/\n\t\tskb_reserve(skb, hh_len);\n\n\t\t\/* create space for UDP\/IP header *\/\n\t\tskb_put(skb,fragheaderlen + transhdrlen);\n\n\t\t\/* initialize network header pointer *\/\n\t\tskb_reset_network_header(skb);\n\n\t\t\/* initialize protocol header pointer *\/\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\n\t\t\/* Specify the length of each IPv6 datagram fragment.\n\t\t * It has to be a multiple of 8.\n\t\t *\/\n\t\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\tipv6_select_ident(&fhdr, rt);\n\t\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t}\n\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}","target":0,"flaw_line_index":0,"hash":"dc0f726c-caa8-4d4b-b549-949c170a6249","idx":"8f81cee5-b2bc-462b-a2f1-d2874cabb5d6"}
{"func_before":"\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to non-matching domain url '%s'\",\n\t\t\t\tpool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tport = (char *)json_string_value(json_array_get(val, 1));\n\tif (!port)\n\t\tport = pool->stratum_port;\n\n\tsprintf(address, \"%s:%s\", url, port);\n\n\tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n\t\treturn false;\n\n\tapplog(LOG_WARNING, \"Stratum reconnect requested from pool %d to %s\", pool->pool_no, address);\n\n\tclear_pool_work(pool);\n\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);","target":1,"flaw_line_index":0,"hash":"8ab5b546-a963-4529-9d52-55a658e5dcde","idx":"b1628e80-1881-4bb4-839b-30e8695d7a83"}
{"func_before":"\t\t\tapplog(LOG_ERR, \"Denied stratum reconnect request to non-matching domain url '%s'\",\n\t\t\t\tpool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tport = (char *)json_string_value(json_array_get(val, 1));\n\tif (!port)\n\t\tport = pool->stratum_port;\n\n\tsnprintf(address, 254, \"%s:%s\", url, port);\n\n\tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n\t\treturn false;\n\n\tapplog(LOG_WARNING, \"Stratum reconnect requested from pool %d to %s\", pool->pool_no, address);\n\n\tclear_pool_work(pool);\n\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);","target":0,"flaw_line_index":0,"hash":"9da72ffb-88d5-4f8e-a892-6cc16398cf8c","idx":"553bb092-51de-4106-a926-b40eab821888"}
{"func_before":"Status GetMatchingPaths(FileSystem* fs, Env* env, const string& pattern,\n                        std::vector<string>* results) {\n  results->clear();\n  if (pattern.empty()) {\n    return Status::OK();\n  }\n\n  string fixed_prefix = pattern.substr(0, pattern.find_first_of(\"*?[\\\\\"));\n  string eval_pattern = pattern;\n  string dir(io::Dirname(fixed_prefix));\n  \/\/ If dir is empty then we need to fix up fixed_prefix and eval_pattern to\n  \/\/ include . as the top level directory.\n  if (dir.empty()) {\n    dir = \".\";\n    fixed_prefix = io::JoinPath(dir, fixed_prefix);\n    eval_pattern = io::JoinPath(dir, eval_pattern);\n  }\n  bool is_directory = pattern[pattern.size() - 1] == '\/';\n#ifdef PLATFORM_WINDOWS\n  is_directory = is_directory || pattern[pattern.size() - 1] == '\\\\';\n#endif\n  std::vector<string> dirs;\n  if (!is_directory) {\n    dirs.emplace_back(eval_pattern);\n  }\n  StringPiece tmp_dir(io::Dirname(eval_pattern));\n  while (tmp_dir.size() > dir.size()) {\n    dirs.emplace_back(string(tmp_dir));\n    tmp_dir = io::Dirname(tmp_dir);\n  }\n  dirs.emplace_back(dir);\n  std::reverse(dirs.begin(), dirs.end());\n  \/\/ Setup a parallel BFS to explore everything under dir.\n  std::deque<std::pair<string, int>> dir_q;\n  std::deque<std::pair<string, int>> next_dir_q;\n  dir_q.emplace_back(std::make_pair(dirs[0], 0));\n  Status ret;  \/\/ Status to return.\n  mutex results_mutex;\n  condition_variable results_cond;\n  mutex next_que_mutex;\n  condition_variable next_que_cond;\n  while (!dir_q.empty()) {\n    next_dir_q.clear();\n    std::vector<Status> new_rets(dir_q.size());\n    auto handle_level = [fs, &results, &dir_q, &next_dir_q, &new_rets,\n                         &is_directory, &dirs, &results_mutex, &results_cond,\n                         &next_que_mutex, &next_que_cond](int i) {\n      string current_dir = dir_q.at(i).first;\n      int dir_index = dir_q.at(i).second;\n      dir_index++;\n      std::vector<string> children;\n      Status s = fs->GetChildren(current_dir, &children);\n      \/\/ In case PERMISSION_DENIED is encountered, we bail here.\n      if (s.code() == tensorflow::error::PERMISSION_DENIED) {\n        return;\n      }\n      new_rets[i] = s;\n      if (children.empty()) return;\n\n      \/\/ children_dir_status holds is_dir status for children. It can have three\n      \/\/ possible values: OK for true; FAILED_PRECONDITION for false; CANCELLED\n      \/\/ if we don't calculate IsDirectory (we might do that because there isn't\n      \/\/ any point in exploring that child path).\n      std::vector<Status> children_dir_status;\n\n      \/\/ This IsDirectory call can be expensive for some FS. Parallelizing it.\n      children_dir_status.resize(children.size());\n      auto handle_children = [fs, &current_dir, &children, &dirs, dir_index,\n                              is_directory, &children_dir_status](int j) {\n        const string child_path = io::JoinPath(current_dir, children[j]);\n        if (!fs->Match(child_path, dirs[dir_index])) {\n          children_dir_status[j] =\n              Status(tensorflow::error::CANCELLED, \"Operation not needed\");\n        } else if (dir_index != dirs.size() - 1) {\n          children_dir_status[j] = fs->IsDirectory(child_path);\n        } else {\n          children_dir_status[j] =\n              is_directory ? fs->IsDirectory(child_path) : Status::OK();\n        }\n      };\n      ForEach(0, children.size(), handle_children);\n\n      for (size_t j = 0; j < children.size(); ++j) {\n        const string child_path = io::JoinPath(current_dir, children[j]);\n        \/\/ If the IsDirectory call was cancelled we bail.\n        if (children_dir_status[j].code() == tensorflow::error::CANCELLED) {\n          continue;\n        }\n        if (children_dir_status[j].ok()) {\n          if (dir_index != dirs.size() - 1) {\n            mutex_lock lk(next_que_mutex);\n            next_dir_q.emplace_back(std::make_pair(child_path, dir_index));\n            next_que_cond.notify_one();\n          } else {\n            mutex_lock lk(results_mutex);\n            results->emplace_back(child_path);\n            results_cond.notify_one();\n          }\n        }\n      }\n    };\n    ForEach(0, dir_q.size(), handle_level);\n\n    ret.Update(new_rets[dir_q.size() - 1]);\n    std::swap(dir_q, next_dir_q);\n  }\n  return ret;\n}","target":1,"flaw_line_index":0,"hash":"86359a31-3c46-454d-8a13-b8c6ca31fbb0","idx":"76a712b6-f2a2-4218-b55a-ff5fde657217"}
{"func_before":"Status GetMatchingPaths(FileSystem* fs, Env* env, const string& pattern,\n                        std::vector<string>* results) {\n  \/\/ Check that `fs`, `env` and `results` are non-null.\n  if (fs == nullptr || env == nullptr || results == nullptr) {\n    return Status(tensorflow::error::INVALID_ARGUMENT,\n                  \"Filesystem calls GetMatchingPaths with nullptr arguments\");\n  }\n\n  \/\/ By design, we don't match anything on empty pattern\n  results->clear();\n  if (pattern.empty()) {\n    return Status::OK();\n  }\n\n  \/\/ The pattern can contain globbing characters at multiple levels, e.g.:\n  \/\/\n  \/\/   foo\/ba?\/baz\/f*r\n  \/\/\n  \/\/ To match the full pattern, we must match every prefix subpattern and then\n  \/\/ operate on the children for each match. Thus, we separate all subpatterns\n  \/\/ in the `dirs` vector below.\n  std::vector<std::string> dirs = AllDirectoryPrefixes(pattern);\n\n  \/\/ We can have patterns that have several parents where no globbing is being\n  \/\/ done, for example, `foo\/bar\/baz\/*`. We don't need to expand the directories\n  \/\/ which don't contain the globbing characters.\n  int matching_index = GetFirstGlobbingEntry(dirs);\n\n  \/\/ If we don't have globbing characters in the pattern then it specifies a\n  \/\/ path in the filesystem. We add it to the result set if it exists.\n  if (matching_index == dirs.size()) {\n    if (fs->FileExists(pattern).ok()) {\n      results->emplace_back(pattern);\n    }\n    return Status::OK();\n  }\n\n  \/\/ To expand the globbing, we do a BFS from `dirs[matching_index-1]`.\n  \/\/ At every step, we work on a pair `{dir, ix}` such that `dir` is a real\n  \/\/ directory, `ix < dirs.size() - 1` and `dirs[ix+1]` is a globbing pattern.\n  \/\/ To expand the pattern, we select from all the children of `dir` only those\n  \/\/ that match against `dirs[ix+1]`.\n  \/\/ If there are more entries in `dirs` after `dirs[ix+1]` this mean we have\n  \/\/ more patterns to match. So, we add to the queue only those children that\n  \/\/ are also directories, paired with `ix+1`.\n  \/\/ If there are no more entries in `dirs`, we return all children as part of\n  \/\/ the answer.\n  \/\/ Since we can get into a combinatorial explosion issue (e.g., pattern\n  \/\/ `\/*\/*\/*`), we process the queue in parallel. Each parallel processing takes\n  \/\/ elements from `expand_queue` and adds them to `next_expand_queue`, after\n  \/\/ which we swap these two queues (similar to double buffering algorithms).\n  \/\/ PRECONDITION: `IsGlobbingPattern(dirs[0]) == false`\n  \/\/ PRECONDITION: `matching_index > 0`\n  \/\/ INVARIANT: If `{d, ix}` is in queue, then `d` and `dirs[ix]` are at the\n  \/\/            same level in the filesystem tree.\n  \/\/ INVARIANT: If `{d, _}` is in queue, then `IsGlobbingPattern(d) == false`.\n  \/\/ INVARIANT: If `{d, _}` is in queue, then `d` is a real directory.\n  \/\/ INVARIANT: If `{_, ix}` is in queue, then `ix < dirs.size() - 1`.\n  \/\/ INVARIANT: If `{_, ix}` is in queue, `IsGlobbingPattern(dirs[ix + 1])`.\n  std::deque<std::pair<string, int>> expand_queue;\n  std::deque<std::pair<string, int>> next_expand_queue;\n  expand_queue.emplace_back(dirs[matching_index - 1], matching_index - 1);\n\n  \/\/ Adding to `result` or `new_expand_queue` need to be protected by mutexes\n  \/\/ since there are multiple threads writing to these.\n  mutex result_mutex;\n  mutex queue_mutex;\n\n  while (!expand_queue.empty()) {\n    next_expand_queue.clear();\n\n    \/\/ The work item for every item in `expand_queue`.\n    \/\/ pattern, we process them in parallel.\n    auto handle_level = [&fs, &results, &dirs, &expand_queue,\n                         &next_expand_queue, &result_mutex,\n                         &queue_mutex](int i) {\n      \/\/ See invariants above, all of these are valid accesses.\n      const auto& queue_item = expand_queue.at(i);\n      const std::string& parent = queue_item.first;\n      const int index = queue_item.second + 1;\n      const std::string& match_pattern = dirs[index];\n\n      \/\/ Get all children of `parent`. If this fails, return early.\n      std::vector<std::string> children;\n      Status s = fs->GetChildren(parent, &children);\n      if (s.code() == tensorflow::error::PERMISSION_DENIED) {\n        return;\n      }\n\n      \/\/ Also return early if we don't have any children\n      if (children.empty()) {\n        return;\n      }\n\n      \/\/ Since we can get extremely many children here and on some filesystems\n      \/\/ `IsDirectory` is expensive, we process the children in parallel.\n      \/\/ We also check that children match the pattern in parallel, for speedup.\n      \/\/ We store the status of the match and `IsDirectory` in\n      \/\/ `children_status` array, one element for each children.\n      std::vector<Status> children_status(children.size());\n      auto handle_children = [&fs, &match_pattern, &parent, &children,\n                              &children_status](int j) {\n        const std::string path = io::JoinPath(parent, children[j]);\n        if (!fs->Match(path, match_pattern)) {\n          children_status[j] =\n              Status(tensorflow::error::CANCELLED, \"Operation not needed\");\n        } else {\n          children_status[j] = fs->IsDirectory(path);\n        }\n      };\n      ForEach(0, children.size(), handle_children);\n\n      \/\/ At this point, pairing `children` with `children_status` will tell us\n      \/\/ if a children:\n      \/\/   * does not match the pattern\n      \/\/   * matches the pattern and is a directory\n      \/\/   * matches the pattern and is not a directory\n      \/\/ We fully ignore the first case.\n      \/\/ If we matched the last pattern (`index == dirs.size() - 1`) then all\n      \/\/ remaining children get added to the result.\n      \/\/ Otherwise, only the directories get added to the next queue.\n      for (size_t j = 0; j < children.size(); j++) {\n        if (children_status[j].code() == tensorflow::error::CANCELLED) {\n          continue;\n        }\n\n        const std::string path = io::JoinPath(parent, children[j]);\n        if (index == dirs.size() - 1) {\n          mutex_lock l(result_mutex);\n          results->emplace_back(path);\n        } else if (children_status[j].ok()) {\n          mutex_lock l(queue_mutex);\n          next_expand_queue.emplace_back(path, index);\n        }\n      }\n    };\n    ForEach(0, expand_queue.size(), handle_level);\n\n    \/\/ After evaluating one level, swap the \"buffers\"\n    std::swap(expand_queue, next_expand_queue);\n  }\n\n  return Status::OK();\n}","target":0,"flaw_line_index":0,"hash":"b6e9734a-1e4a-4d66-8c71-15ce93f08ed4","idx":"ed2431e5-9ff7-4b9a-9264-291c00e80602"}
{"func_before":"\t\treturn;\n\ttsk->sysvsem.undo_list = NULL;\n\n\tif (!atomic_dec_and_test(&ulp->refcnt))\n\t\treturn;\n\n\tfor (;;) {\n\t\tstruct sem_array *sma;\n\t\tstruct sem_undo *un;\n\t\tstruct list_head tasks;\n\t\tint semid;\n\t\tint i;\n\n\t\trcu_read_lock();\n\t\tun = list_entry_rcu(ulp->list_proc.next,\n\t\t\t\t    struct sem_undo, list_proc);\n\t\tif (&un->list_proc == &ulp->list_proc)\n\t\t\tsemid = -1;\n\t\t else\n\t\t\tsemid = un->semid;\n\t\trcu_read_unlock();\n\n\t\tif (semid == -1)\n\t\t\tbreak;\n\n\t\tsma = sem_lock_check(tsk->nsproxy->ipc_ns, un->semid);\n\n\t\t\/* exit_sem raced with IPC_RMID, nothing to do *\/\n\t\tif (IS_ERR(sma))\n\t\t\tcontinue;\n\n\t\tun = __lookup_undo(ulp, semid);\n\t\tif (un == NULL) {\n\t\t\t\/* exit_sem raced with IPC_RMID+semget() that created\n\t\t\t * exactly the same semid. Nothing to do.\n\t\t\t *\/\n\t\t\tsem_unlock(sma);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\/* remove un from the linked lists *\/\n\t\tassert_spin_locked(&sma->sem_perm.lock);\n\t\tlist_del(&un->list_id);\n\n\t\tspin_lock(&ulp->lock);\n\t\tlist_del_rcu(&un->list_proc);\n\t\tspin_unlock(&ulp->lock);\n\t\t\t\tif (semaphore->semval < 0)\n\t\t\t\t\tsemaphore->semval = 0;\n\t\t\t\tif (semaphore->semval > SEMVMX)\n\t\t\t\t\tsemaphore->semval = SEMVMX;\n\t\t\t\tsemaphore->sempid = task_tgid_vnr(current);\n\t\t\t}\n\t\t}\n\t\t\/* maybe some queued-up processes were waiting for this *\/\n\t\tINIT_LIST_HEAD(&tasks);\n\t\tdo_smart_update(sma, NULL, 0, 1, &tasks);\n\t\tsem_unlock(sma);\n\t\twake_up_sem_queue_do(&tasks);\n\n\t\tkfree_rcu(un, rcu);\n\t}\n\tkfree(ulp);\n}","target":1,"flaw_line_index":0,"hash":"2a0abefb-a677-4bec-bbea-6868bc4dcdfe","idx":"355da2fd-d4f8-4f86-a6e7-3e0ece995029"}
{"func_before":"\t\treturn;\n\ttsk->sysvsem.undo_list = NULL;\n\n\tif (!atomic_dec_and_test(&ulp->refcnt))\n\t\treturn;\n\n\tfor (;;) {\n\t\tstruct sem_array *sma;\n\t\tstruct sem_undo *un;\n\t\tstruct list_head tasks;\n\t\tint semid, i;\n\n\t\trcu_read_lock();\n\t\tun = list_entry_rcu(ulp->list_proc.next,\n\t\t\t\t    struct sem_undo, list_proc);\n\t\tif (&un->list_proc == &ulp->list_proc)\n\t\t\tsemid = -1;\n\t\t else\n\t\t\tsemid = un->semid;\n\n\t\tif (semid == -1) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\n\t\tsma = sem_obtain_object_check(tsk->nsproxy->ipc_ns, un->semid);\n\t\t\/* exit_sem raced with IPC_RMID, nothing to do *\/\n\t\tif (IS_ERR(sma)) {\n\t\t\trcu_read_unlock();\n\t\t\tcontinue;\n\t\t}\n\n\t\tsem_lock(sma, NULL, -1);\n\t\tun = __lookup_undo(ulp, semid);\n\t\tif (un == NULL) {\n\t\t\t\/* exit_sem raced with IPC_RMID+semget() that created\n\t\t\t * exactly the same semid. Nothing to do.\n\t\t\t *\/\n\t\t\tsem_unlock(sma, -1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\/* remove un from the linked lists *\/\n\t\tassert_spin_locked(&sma->sem_perm.lock);\n\t\tlist_del(&un->list_id);\n\n\t\tspin_lock(&ulp->lock);\n\t\tlist_del_rcu(&un->list_proc);\n\t\tspin_unlock(&ulp->lock);\n\t\t\t\tif (semaphore->semval < 0)\n\t\t\t\t\tsemaphore->semval = 0;\n\t\t\t\tif (semaphore->semval > SEMVMX)\n\t\t\t\t\tsemaphore->semval = SEMVMX;\n\t\t\t\tsemaphore->sempid = task_tgid_vnr(current);\n\t\t\t}\n\t\t}\n\t\t\/* maybe some queued-up processes were waiting for this *\/\n\t\tINIT_LIST_HEAD(&tasks);\n\t\tdo_smart_update(sma, NULL, 0, 1, &tasks);\n\t\tsem_unlock(sma, -1);\n\t\twake_up_sem_queue_do(&tasks);\n\n\t\tkfree_rcu(un, rcu);\n\t}\n\tkfree(ulp);\n}","target":0,"flaw_line_index":0,"hash":"220ca338-efba-47c0-82c6-4f056c3a619f","idx":"4208deab-e000-496b-9087-c9e4ebb51f68"}
{"func_before":"static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\n\/* Eliminate warning about unused variable. *\/\nbox = 0;\nout = 0;\n\treturn -1;\n}","target":1,"flaw_line_index":0,"hash":"a95506c7-60f5-47b2-a709-78836090cfac","idx":"e55f83b1-6538-4351-925e-fdd1781e278c"}
{"func_before":"static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\n\t\/* Eliminate warning about unused variable. *\/\n\tbox = 0;\n\tout = 0;\n\treturn -1;\n}","target":0,"flaw_line_index":0,"hash":"c3b2b285-d57b-4ae3-9790-ab5b26dc3d11","idx":"81119d17-df16-4fd5-9451-0ec00bf1aa3f"}
{"func_before":"{\n\tstruct nlattr *tb[NFTA_EXPR_MAX + 1];\n\tconst struct nft_expr_type *type;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,\n\t\t\t\t\t  nft_expr_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_EXPR_DATA])\n\t\treturn -EINVAL;\n\n\ttype = __nft_expr_type_get(ctx->family, tb[NFTA_EXPR_NAME]);\n\tif (!type)\n\t\treturn -ENOENT;\n\n\tif (!type->inner_ops)\n\t\treturn -EOPNOTSUPP;\n\n\terr = nla_parse_nested_deprecated(info->tb, type->maxattr,","target":1,"flaw_line_index":0,"hash":"ed1e2a6e-5ca8-4911-ac23-932acaeb2686","idx":"005db52d-66d1-466b-acc0-000437cc0b8f"}
{"func_before":"{\n\tstruct nlattr *tb[NFTA_EXPR_MAX + 1];\n\tconst struct nft_expr_type *type;\n\tint err;\n\n\terr = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,\n\t\t\t\t\t  nft_expr_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_EXPR_DATA] || !tb[NFTA_EXPR_NAME])\n\t\treturn -EINVAL;\n\n\ttype = __nft_expr_type_get(ctx->family, tb[NFTA_EXPR_NAME]);\n\tif (!type)\n\t\treturn -ENOENT;\n\n\tif (!type->inner_ops)\n\t\treturn -EOPNOTSUPP;\n\n\terr = nla_parse_nested_deprecated(info->tb, type->maxattr,","target":0,"flaw_line_index":0,"hash":"ab36ff6c-30e2-4d46-996c-280f447c0633","idx":"3f820e86-420a-4927-95dc-f769f6462128"}
{"func_before":"void mt_init(mtrand *mt, uint32_t seed) {\n  int i;\n  mt->mt_buffer_[0] = seed;\n  mt->mt_index_ = MT_LEN;\n  for (i = 1; i < MT_LEN; i++) {\n    \/* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. *\/\n    \/* In the previous versions, MSBs of the seed affect   *\/\n    \/* only MSBs of the array mt[].                        *\/\n    \/* 2002\/01\/09 modified by Makoto Matsumoto             *\/\n    mt->mt_buffer_[i] =\n\t(1812433253UL * (mt->mt_buffer_[i-1] ^ \n\t\t\t (mt->mt_buffer_[i-1] >> 30)) + i);\n  }\n}","target":1,"flaw_line_index":0,"hash":"695d39d2-863a-4384-af50-3b35aa36c2fa","idx":"bb5d27ca-93fa-4296-a21d-07ea0a760ec5"}
{"func_before":"void mt_init(mtrand *mt, uint32_t seed) {\n  int i;\n  mt->mt_buffer_[0] = seed;\n  mt->mt_index_ = MT_LEN;\n  for (i = 1; i < MT_LEN; i++) {\n    \/* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. *\/\n    \/* In the previous versions, MSBs of the seed affect   *\/\n    \/* only MSBs of the array mt[].                        *\/\n    \/* 2002\/01\/09 modified by Makoto Matsumoto             *\/\n    mt->mt_buffer_[i] =\n\t(1812433253UL * (mt->mt_buffer_[i-1] ^\n\t\t\t (mt->mt_buffer_[i-1] >> 30)) + i);\n  }\n}","target":0,"flaw_line_index":0,"hash":"8ec8a218-1c03-4ebb-b1d6-654afdb4e3cf","idx":"308eda76-8de7-4ab6-8c27-3af4d79873d4"}
{"func_before":"static void exif_process_APP12(image_info_type *ImageInfo,\n                               char *buffer, size_t length) {\n  size_t l1, l2=0;\n  if ((l1 = php_strnlen(buffer+2, length-2)) > 0) {\n    exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Company\",\n                     TAG_NONE, TAG_FMT_STRING, l1, buffer+2);\n    if (length > 2+l1+1) {\n      l2 = php_strnlen(buffer+2+l1+1, length-2-l1+1);\n      exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Info\",\n                       TAG_NONE, TAG_FMT_STRING, l2, buffer+2+l1+1);\n    }\n  }\n}","target":1,"flaw_line_index":0,"hash":"5969fe61-a2ff-46e1-a8be-5abc821d9e90","idx":"3eb9d94f-8605-4df2-8589-b51f60bac905"}
{"func_before":"static void exif_process_APP12(image_info_type *ImageInfo,\n                               char *buffer, size_t length) {\n  size_t l1, l2=0;\n  if ((l1 = php_strnlen(buffer+2, length-2)) > 0) {\n    exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Company\",\n                     TAG_NONE, TAG_FMT_STRING, l1, buffer+2);\n    if (length > 2+l1+1) {\n      l2 = php_strnlen(buffer+2+l1+1, length-2-l1-1);\n      exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Info\",\n                       TAG_NONE, TAG_FMT_STRING, l2, buffer+2+l1+1);\n    }\n  }\n}","target":0,"flaw_line_index":0,"hash":"c7c5d007-a43a-4b65-aedd-4e2708ed8801","idx":"ed568f73-d479-4462-ba61-fae7376586b1"}
{"func_before":"#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)\n\t\/*\n\t * write op is only supported for ipc_flood_count or\n\t * ipc_flood_duration_ms debugfs entries atm.\n\t * ipc_flood_count floods the DSP with the number of IPC's specified.\n\t * ipc_duration_ms test floods the DSP for the time specified\n\t * in the debugfs entry.\n\t *\/\n\tdentry = file->f_path.dentry;\n\tif (strcmp(dentry->d_name.name, \"ipc_flood_count\") &&\n\t    strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\"))\n\t\treturn -EINVAL;\n\n\tif (!strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\"))\n\t\tflood_duration_test = true;\n\n\t\/* test completion criterion *\/\n\tif (flood_duration_test)\n\t\tret = kstrtoul(string, 0, &ipc_duration_ms);\n\telse\n\t\tret = kstrtoul(string, 0, &ipc_count);\n\tif (ret < 0)","target":1,"flaw_line_index":0,"hash":"7bbf5524-0f08-4519-aa5f-454060913b99","idx":"32084eb8-ba36-43cd-9c4d-749d7056face"}
{"func_before":"#if IS_ENABLED(CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST)\n\t\/*\n\t * write op is only supported for ipc_flood_count or\n\t * ipc_flood_duration_ms debugfs entries atm.\n\t * ipc_flood_count floods the DSP with the number of IPC's specified.\n\t * ipc_duration_ms test floods the DSP for the time specified\n\t * in the debugfs entry.\n\t *\/\n\tdentry = file->f_path.dentry;\n\tif (strcmp(dentry->d_name.name, \"ipc_flood_count\") &&\n\t    strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\")) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\"))\n\t\tflood_duration_test = true;\n\n\t\/* test completion criterion *\/\n\tif (flood_duration_test)\n\t\tret = kstrtoul(string, 0, &ipc_duration_ms);\n\telse\n\t\tret = kstrtoul(string, 0, &ipc_count);\n\tif (ret < 0)","target":0,"flaw_line_index":0,"hash":"e61cf285-4d98-499d-86f9-2fa3e3bd5ce0","idx":"f5413847-eb67-4920-b704-3bf40a1fd9cf"}
{"func_before":"TEST_CASE_METHOD(TestFixture, \"ECDSA AES keygen and signature test\", \"[ecdsa-aes-key-sig-gen]\") {\n    vector<char> errMsg(BUF_LEN, 0);\n    int errStatus = 0;\n    vector <uint8_t> encrPrivKey(BUF_LEN, 0);\n    vector<char> pubKeyX(BUF_LEN, 0);\n    vector<char> pubKeyY(BUF_LEN, 0);\n\n    uint32_t encLen = 0;\n    PRINT_SRC_LINE\n    auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), &encLen,\n                                             pubKeyX.data(),\n                                             pubKeyY.data());\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    string hex = SAMPLE_HEX_HASH;\n    vector<char> signatureR(BUF_LEN, 0);\n    vector<char> signatureS(BUF_LEN, 0);","target":1,"flaw_line_index":0,"hash":"df5f55d1-93dd-41ce-8f5f-d6026ae94f71","idx":"85f4695b-d5d7-4cbb-9632-a374c5e113d5"}
{"func_before":"TEST_CASE_METHOD(TestFixture, \"ECDSA AES keygen and signature test\", \"[ecdsa-aes-key-sig-gen]\") {\n    vector<char> errMsg(BUF_LEN, 0);\n    int errStatus = 0;\n    vector <uint8_t> encrPrivKey(BUF_LEN, 0);\n    vector<char> pubKeyX(BUF_LEN, 0);\n    vector<char> pubKeyY(BUF_LEN, 0);\n\n    uint64_t encLen = 0;\n    PRINT_SRC_LINE\n    auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), &encLen,\n                                             pubKeyX.data(),\n                                             pubKeyY.data());\n    REQUIRE(status == SGX_SUCCESS);\n    REQUIRE(errStatus == SGX_SUCCESS);\n\n    string hex = SAMPLE_HEX_HASH;\n    vector<char> signatureR(BUF_LEN, 0);\n    vector<char> signatureS(BUF_LEN, 0);","target":0,"flaw_line_index":0,"hash":"d68e886f-7947-43d4-98d6-029a13e5d1f2","idx":"e6a40d50-1837-4050-8e72-c98fe607516b"}
{"func_before":"asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n\n\tif (timeout == NULL)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n\n\tif (get_compat_timespec(&ktspec, timeout))\n\t\treturn -EFAULT;\n\n\tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n\t\tdatagrams = -EFAULT;\n\n\treturn datagrams;\n}","target":1,"flaw_line_index":0,"hash":"acccd870-bea7-4937-b4d1-6b7d97261eaf","idx":"6ae4d136-29a3-4c4f-8af7-2e2da769683f"}
{"func_before":"asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,\n\t\t\t\t    unsigned int vlen, unsigned int flags,\n\t\t\t\t    struct compat_timespec __user *timeout)\n{\n\tint datagrams;\n\tstruct timespec ktspec;\n\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\n\tif (timeout == NULL)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n\n\tif (compat_get_timespec(&ktspec, timeout))\n\t\treturn -EFAULT;\n\n\tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && compat_put_timespec(&ktspec, timeout))\n\t\tdatagrams = -EFAULT;\n\n\treturn datagrams;\n}","target":0,"flaw_line_index":0,"hash":"3bdc541c-3438-4753-8276-f1fe996b0f0a","idx":"f1ba24ab-388a-4538-b109-a0bf654e990f"}
{"func_before":"static int jas_iccgetuint32(jas_stream_t *in, jas_iccuint32_t *val)\n{\n\tulonglong tmp;\n\tif (jas_iccgetuint(in, 4, &tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"d5702972-d145-4f84-9a28-fb60e0c71ec4","idx":"6b7c3cf7-5168-4672-af46-8360e2699652"}
{"func_before":"static int jas_iccgetuint32(jas_stream_t *in, jas_iccuint32_t *val)\n{\n\tjas_ulonglong tmp;\n\tif (jas_iccgetuint(in, 4, &tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"62aa7472-d70b-4d98-b922-b753fb3c91bf","idx":"36e62bf0-c2fa-4462-bc0e-74f30c3c78bc"}
{"func_before":"  int ret;\n\n  test_setup ();\n\n  if ((ret = test_make_inputs (stream, has_source ? & ssize : NULL, & tsize)))\n    {\n      return ret;\n    }\n\n  \/* First encode *\/\n  snprintf_func (ecmd, TESTBUFSIZE, \"%s %s -f %s %s %s %s %s %s %s\", \n\t    program_name, test_softcfg_str,\n\t    has_adler32 ? \"\" : \"-n \",\n\t    has_apphead ? \"-A=encode_apphead \" : \"-A= \",\n\t    has_secondary ? \"-S djw \" : \"-S none \",\n\t    has_source ? \"-s \" : \"\",\n\t    has_source ? TEST_SOURCE_FILE : \"\",\n\t    TEST_TARGET_FILE,\n\t    TEST_DELTA_FILE);\n\n  if ((ret = system (ecmd)) != 0)\n    {\n      XPR(NT \"encode command: %s\\n\", ecmd);\n      stream->msg = \"encode cmd failed\";\n      return XD3_INTERNAL;\n    }\n\n  \/* Now recode *\/\n  snprintf_func (recmd, TESTBUFSIZE,\n\t    \"%s recode %s -f %s %s %s %s %s\", program_name, test_softcfg_str,\n\t    recoded_adler32 ? \"\" : \"-n \",\n\t    !change_apphead ? \"\" : \n\t        (recoded_apphead ? \"-A=recode_apphead \" : \"-A= \"),\n\t    recoded_secondary ? \"-S djw \" : \"-S none \",\n\t    TEST_DELTA_FILE,\n\t    TEST_COPY_FILE);\n\n  if ((ret = system (recmd)) != 0)\n    {\n      XPR(NT \"recode command: %s\\n\", recmd);\n      stream->msg = \"recode cmd failed\";\n      return XD3_INTERNAL;","target":1,"flaw_line_index":0,"hash":"0f57e112-80c2-4d77-87a8-78af1cf858e4","idx":"dfddf23b-2354-40e6-86f5-7387259a48d5"}
{"func_before":"  int ret;\n\n  test_setup ();\n\n  if ((ret = test_make_inputs (stream, has_source ? & ssize : NULL, & tsize)))\n    {\n      return ret;\n    }\n\n  \/* First encode *\/\n  snprintf_func (ecmd, TESTBUFSIZE, \"%s %s -f %s %s %s %s %s %s %s\",\n\t    program_name, test_softcfg_str,\n\t    has_adler32 ? \"\" : \"-n \",\n\t    has_apphead ? \"-A=encode_apphead \" : \"-A= \",\n\t    has_secondary ? \"-S djw \" : \"-S none \",\n\t    has_source ? \"-s \" : \"\",\n\t    has_source ? TEST_SOURCE_FILE : \"\",\n\t    TEST_TARGET_FILE,\n\t    TEST_DELTA_FILE);\n\n  if ((ret = system (ecmd)) != 0)\n    {\n      XPR(NT \"encode command: %s\\n\", ecmd);\n      stream->msg = \"encode cmd failed\";\n      return XD3_INTERNAL;\n    }\n\n  \/* Now recode *\/\n  snprintf_func (recmd, TESTBUFSIZE,\n\t    \"%s recode %s -f %s %s %s %s %s\", program_name, test_softcfg_str,\n\t    recoded_adler32 ? \"\" : \"-n \",\n\t    !change_apphead ? \"\" :\n\t        (recoded_apphead ? \"-A=recode_apphead \" : \"-A= \"),\n\t    recoded_secondary ? \"-S djw \" : \"-S none \",\n\t    TEST_DELTA_FILE,\n\t    TEST_COPY_FILE);\n\n  if ((ret = system (recmd)) != 0)\n    {\n      XPR(NT \"recode command: %s\\n\", recmd);\n      stream->msg = \"recode cmd failed\";\n      return XD3_INTERNAL;","target":0,"flaw_line_index":0,"hash":"0a85aa3e-fdee-4b9d-a8e1-9ae5c73448a6","idx":"7f756287-12cc-40e4-9fd0-589125ea7777"}
{"func_before":"\t\tmd->page_order = req_schp->page_order;\n\t\tmd->nr_entries = req_schp->k_use_sg;\n\t\tmd->offset = 0;\n\t\tmd->null_mapped = hp->dxferp ? 0 : 1;\n\t\tif (dxfer_dir == SG_DXFER_TO_FROM_DEV)\n\t\t\tmd->from_user = 1;\n\t\telse\n\t\t\tmd->from_user = 0;\n\t}\n\n\tif (unlikely(iov_count > MAX_UIOVEC))\n\t\treturn -EINVAL;\n\n\tif (iov_count) {\n\t\tint size = sizeof(struct iovec) * iov_count;\n\t\tstruct iovec *iov;\n\t\tstruct iov_iter i;\n\n\t\tiov = memdup_user(hp->dxferp, size);\n\t\tif (IS_ERR(iov))\n\t\t\treturn PTR_ERR(iov);\n\n\t\tiov_iter_init(&i, rw, iov, iov_count,\n\t\t\t      min_t(size_t, hp->dxfer_len,\n\t\t\t\t    iov_length(iov, iov_count)));\n\n\t\tres = blk_rq_map_user_iov(q, rq, md, &i, GFP_ATOMIC);\n\t\tkfree(iov);\n\t} else\n\t\tres = blk_rq_map_user(q, rq, md, hp->dxferp,\n\t\t\t\t      hp->dxfer_len, GFP_ATOMIC);\n\n\tif (!res) {\n\t\tsrp->bio = rq->bio;\n","target":1,"flaw_line_index":0,"hash":"742780a6-629a-4d3b-9079-6b8e9d1bb037","idx":"06288726-56b3-42c7-afd2-8068c73515c6"}
{"func_before":"\t\tmd->pages = req_schp->pages;\n\t\tmd->page_order = req_schp->page_order;\n\t\tmd->nr_entries = req_schp->k_use_sg;\n\t\tmd->offset = 0;\n\t\tmd->null_mapped = hp->dxferp ? 0 : 1;\n\t\tif (dxfer_dir == SG_DXFER_TO_FROM_DEV)\n\t\t\tmd->from_user = 1;\n\t\telse\n\t\t\tmd->from_user = 0;\n\t}\n\n\tif (iov_count) {\n\t\tstruct iovec *iov = NULL;\n\t\tstruct iov_iter i;\n\n\t\tres = import_iovec(rw, hp->dxferp, iov_count, 0, &iov, &i);\n\t\tif (res < 0)\n\t\t\treturn res;\n\n\t\tiov_iter_truncate(&i, hp->dxfer_len);\n\n\t\tres = blk_rq_map_user_iov(q, rq, md, &i, GFP_ATOMIC);\n\t\tkfree(iov);\n\t} else\n\t\tres = blk_rq_map_user(q, rq, md, hp->dxferp,\n\t\t\t\t      hp->dxfer_len, GFP_ATOMIC);\n\n\tif (!res) {\n\t\tsrp->bio = rq->bio;\n","target":0,"flaw_line_index":0,"hash":"a5459e47-ab96-4ae7-afb3-e1814dc006f5","idx":"9464ef65-5609-415d-9661-e7db499f90b6"}
{"func_before":"int dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tconst struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\t__be16 orig_sport, orig_dport;\n\t__be32 daddr, nexthop;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\tint err;\n\n\tdp->dccps_role = DCCP_ROLE_CLIENT;\n\n\tif (addr_len < sizeof(struct sockaddr_in))\n\t\treturn -EINVAL;\n\n\tif (usin->sin_family != AF_INET)\n\t\treturn -EAFNOSUPPORT;\n\n\tnexthop = daddr = usin->sin_addr.s_addr;\n\tif (inet->opt != NULL && inet->opt->srr) {\n\t\tif (daddr == 0)\n\t\t\treturn -EINVAL;\n\t\tnexthop = inet->opt->faddr;\n\t}\n\n\torig_sport = inet->inet_sport;\n\torig_dport = usin->sin_port;\n\trt = ip_route_connect(&fl4, nexthop, inet->inet_saddr,\n\t\t\t      RT_CONN_FLAGS(sk), sk->sk_bound_dev_if,\n\t\t\t      IPPROTO_DCCP,\n\t\t\t      orig_sport, orig_dport, sk, true);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\tif (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {\n\t\tip_rt_put(rt);\n\t\treturn -ENETUNREACH;\n\t}\n\n\tif (inet->opt == NULL || !inet->opt->srr)\n\t\tdaddr = rt->rt_dst;\n\n\tif (inet->inet_saddr == 0)\n\t\tinet->inet_saddr = rt->rt_src;\n\tinet->inet_rcv_saddr = inet->inet_saddr;\n\n\tinet->inet_dport = usin->sin_port;\n\tinet->inet_daddr = daddr;\n\n\tinet_csk(sk)->icsk_ext_hdr_len = 0;\n\tif (inet->opt != NULL)\n\t\tinet_csk(sk)->icsk_ext_hdr_len = inet->opt->optlen;\n\t\/*\n\t * Socket identity is still unknown (sport may be zero).\n\t * However we set state to DCCP_REQUESTING and not releasing socket\n\t * lock select source port, enter ourselves into the hash tables and\n\t * complete initialization after this.\n\t *\/\n\tdccp_set_state(sk, DCCP_REQUESTING);\n\terr = inet_hash_connect(&dccp_death_row, sk);\n\tif (err != 0)\n\t\tgoto failure;","target":1,"flaw_line_index":0,"hash":"6e22deab-9b6e-4c2f-afc0-e15bb85f82d5","idx":"d7db454f-ef87-4cc9-a454-56412752c35c"}
{"func_before":"int dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)\n{\n\tconst struct sockaddr_in *usin = (struct sockaddr_in *)uaddr;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\t__be16 orig_sport, orig_dport;\n\t__be32 daddr, nexthop;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\tint err;\n\tstruct ip_options_rcu *inet_opt;\n\n\tdp->dccps_role = DCCP_ROLE_CLIENT;\n\n\tif (addr_len < sizeof(struct sockaddr_in))\n\t\treturn -EINVAL;\n\n\tif (usin->sin_family != AF_INET)\n\t\treturn -EAFNOSUPPORT;\n\n\tnexthop = daddr = usin->sin_addr.s_addr;\n\n\tinet_opt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t     sock_owned_by_user(sk));\n\tif (inet_opt != NULL && inet_opt->opt.srr) {\n\t\tif (daddr == 0)\n\t\t\treturn -EINVAL;\n\t\tnexthop = inet_opt->opt.faddr;\n\t}\n\n\torig_sport = inet->inet_sport;\n\torig_dport = usin->sin_port;\n\trt = ip_route_connect(&fl4, nexthop, inet->inet_saddr,\n\t\t\t      RT_CONN_FLAGS(sk), sk->sk_bound_dev_if,\n\t\t\t      IPPROTO_DCCP,\n\t\t\t      orig_sport, orig_dport, sk, true);\n\tif (IS_ERR(rt))\n\t\treturn PTR_ERR(rt);\n\n\tif (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {\n\t\tip_rt_put(rt);\n\t\treturn -ENETUNREACH;\n\t}\n\n\tif (inet_opt == NULL || !inet_opt->opt.srr)\n\t\tdaddr = rt->rt_dst;\n\n\tif (inet->inet_saddr == 0)\n\t\tinet->inet_saddr = rt->rt_src;\n\tinet->inet_rcv_saddr = inet->inet_saddr;\n\n\tinet->inet_dport = usin->sin_port;\n\tinet->inet_daddr = daddr;\n\n\tinet_csk(sk)->icsk_ext_hdr_len = 0;\n\tif (inet_opt)\n\t\tinet_csk(sk)->icsk_ext_hdr_len = inet_opt->opt.optlen;\n\t\/*\n\t * Socket identity is still unknown (sport may be zero).\n\t * However we set state to DCCP_REQUESTING and not releasing socket\n\t * lock select source port, enter ourselves into the hash tables and\n\t * complete initialization after this.\n\t *\/\n\tdccp_set_state(sk, DCCP_REQUESTING);\n\terr = inet_hash_connect(&dccp_death_row, sk);\n\tif (err != 0)\n\t\tgoto failure;","target":0,"flaw_line_index":0,"hash":"d8ca2518-3e1d-4c5e-bebf-1dc99e09275f","idx":"01bdde05-5a92-483b-b02d-8250fed7d93f"}
{"func_before":"void trustedEncryptKeyAES(int *errStatus, char *errString, const char *key,\n                          uint8_t *encryptedPrivateKey, uint32_t *enc_len) {\n    LOG_INFO(__FUNCTION__);\n\n    *errString = 0;\n    *errStatus = UNKNOWN_ERROR;\n\n    CHECK_STATE(key);\n    CHECK_STATE(encryptedPrivateKey);\n\n    *errStatus = UNKNOWN_ERROR;\n\n    int status = AES_encrypt_DH((char *)key, encryptedPrivateKey, BUF_LEN);\n\n    CHECK_STATUS2(\"AES encrypt failed with status %d\");\n\n    *enc_len = strlen(key) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n    SAFE_CHAR_BUF(decryptedKey, BUF_LEN);\n\n    status = AES_decrypt_DH(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);\n\n    CHECK_STATUS2(\"trustedDecryptKey failed with status %d\");\n\n    uint64_t decryptedKeyLen = strnlen(decryptedKey, MAX_KEY_LENGTH);\n\n    if (decryptedKeyLen == MAX_KEY_LENGTH) {\n        snprintf(errString, BUF_LEN, \"Decrypted key is not null terminated\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    *errStatus = -8;\n\n    if (strncmp(key, decryptedKey, MAX_KEY_LENGTH) != 0) {\n        snprintf(errString, BUF_LEN, \"Decrypted key does not match original key\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    SET_SUCCESS\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}","target":1,"flaw_line_index":0,"hash":"4db698a6-7c31-4da3-a555-3710f08edb3f","idx":"4b67db02-08f0-4d0d-a155-4495ac9458e9"}
{"func_before":"void trustedEncryptKeyAES(int *errStatus, char *errString, const char *key,\n                          uint8_t *encryptedPrivateKey, uint64_t *enc_len) {\n    LOG_INFO(__FUNCTION__);\n\n    *errString = 0;\n    *errStatus = UNKNOWN_ERROR;\n\n    CHECK_STATE(key);\n    CHECK_STATE(encryptedPrivateKey);\n\n    *errStatus = UNKNOWN_ERROR;\n\n    int status = AES_encrypt((char *)key, encryptedPrivateKey, BUF_LEN,\n                             DKG, DECRYPTABLE, enc_len);\n\n    CHECK_STATUS2(\"AES encrypt failed with status %d\");\n\n    SAFE_CHAR_BUF(decryptedKey, BUF_LEN);\n\n    status = AES_decrypt(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);\n\n    CHECK_STATUS2(\"trustedDecryptKey failed with status %d\");\n\n    uint64_t decryptedKeyLen = strnlen(decryptedKey, MAX_KEY_LENGTH);\n\n    if (decryptedKeyLen == MAX_KEY_LENGTH) {\n        snprintf(errString, BUF_LEN, \"Decrypted key is not null terminated\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    *errStatus = -8;\n\n    if (strncmp(key, decryptedKey, MAX_KEY_LENGTH) != 0) {\n        snprintf(errString, BUF_LEN, \"Decrypted key does not match original key\");\n        LOG_ERROR(key);\n        LOG_ERROR(decryptedKey);\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    SET_SUCCESS\n    clean:\n    ;\n    LOG_INFO(__FUNCTION__ );\n    LOG_INFO(\"SGX call completed\");\n}","target":0,"flaw_line_index":0,"hash":"52054d6c-1959-4501-9d72-b82031928db9","idx":"9a406600-d34a-4c3a-9b1a-31dcd76bde58"}
{"func_before":"string sanitize_proprietary_tags(string input_string)\n{\n  unsigned int i;\n  size_t input_string_size;\n  bool strip = false;\n  bool tag_open = false;\n  int tag_open_idx = 0; \/\/Are we within < > ?\n  bool closing_tag_open = false; \/\/Are we within <\/ > ?\n  int orig_tag_open_idx = 0;\n  bool proprietary_tag = false; \/\/Are we within a proprietary element?\n  bool proprietary_closing_tag = false;\n  int crop_end_idx = 0;\n  char buffer[READ_BUFFER_SIZE] = \"\";\n  char tagname[READ_BUFFER_SIZE] = \"\";\n  int tagname_idx = 0;\n  char close_tagname[READ_BUFFER_SIZE] = \"\";\n\n  for (i = 0; i < READ_BUFFER_SIZE; i++)\n  {\n    buffer[i] = 0;\n    tagname[i] = 0;\n    close_tagname[i] = 0;\n  }\n\n  input_string_size = input_string.size();\n\n  for (i = 0; i < input_string_size; i++)\n  {\n    if (input_string.c_str()[i] == '<')\n    {\n      tag_open = true;\n      tag_open_idx = i;\n      if (proprietary_tag == true && input_string.c_str()[i+1] == '\/')\n      {\n        \/\/We are now in a closing tag\n        closing_tag_open = true;\n        \/\/cout<<\"Comparaison: \"<<tagname<<\"|\"<<&(input_string.c_str()[i+2])<<\"|\"<<strlen(tagname)<<endl;","target":1,"flaw_line_index":0,"hash":"4cd85163-9d76-4645-933d-c18da163eb46","idx":"e9bfca43-27bc-45f0-a8aa-683adff412f0"}
{"func_before":"string sanitize_proprietary_tags(string input_string)\n{\n  unsigned int i;\n  bool strip = false;\n  bool tag_open = false;\n  int tag_open_idx = 0; \/\/Are we within < > ?\n  bool closing_tag_open = false; \/\/Are we within <\/ > ?\n  int orig_tag_open_idx = 0;\n  bool proprietary_tag = false; \/\/Are we within a proprietary element?\n  bool proprietary_closing_tag = false;\n  int crop_end_idx = 0;\n  char buffer[READ_BUFFER_SIZE] = \"\";\n  char tagname[READ_BUFFER_SIZE] = \"\";\n  int tagname_idx = 0;\n  char close_tagname[READ_BUFFER_SIZE] = \"\";\n\n  for (i = 0; i < READ_BUFFER_SIZE; i++)\n  {\n    buffer[i] = 0;\n    tagname[i] = 0;\n    close_tagname[i] = 0;\n  }\n\n  size_t input_string_size = input_string.size();\n\n  \/\/ Minimum workaround to prevent buffer overflow: Stop iterating\n  \/\/ once the (fixed!) size of the output buffers is reached. In\n  \/\/ response to\n  \/\/ https:\/\/www.talosintelligence.com\/vulnerability_reports\/TALOS-2017-0317\n  \/\/\n  \/\/ However, this code is a huge mess anyway and is in no way\n  \/\/ anything like up-to-date C++ code. Please, anyone, replace it\n  \/\/ with something more modern. Thanks. - cstim, 2017-09-17.\n  for (i = 0; i < std::min(input_string_size, size_t(READ_BUFFER_SIZE)); i++)\n  {\n    if (input_string.c_str()[i] == '<')\n    {\n      tag_open = true;\n      tag_open_idx = i;\n      if (proprietary_tag == true && input_string.c_str()[i+1] == '\/')\n      {\n        \/\/We are now in a closing tag\n        closing_tag_open = true;\n        \/\/cout<<\"Comparaison: \"<<tagname<<\"|\"<<&(input_string.c_str()[i+2])<<\"|\"<<strlen(tagname)<<endl;","target":0,"flaw_line_index":0,"hash":"7062c9e0-a9ec-4f24-a350-416901c0f050","idx":"97a6249e-0ea1-4b53-a85c-1a8314251a68"}
{"func_before":"    }\n    \/* XmlPrologTok has now set the encoding based on the BOM it found, and we\n       must move s and nextPtr forward to consume the BOM.\n\n       If we didn't, and got XML_TOK_NONE from the next XmlPrologTok call, we\n       would leave the BOM in the buffer and return. On the next call to this\n       function, our XmlPrologTok call would return XML_TOK_INVALID, since it\n       is not valid to have multiple BOMs.\n    *\/\n    else if (tok == XML_TOK_BOM) {\n#  ifdef XML_DTD\n      if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                    XML_ACCOUNT_DIRECT)) {\n        accountingOnAbort(parser);\n        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      }\n#  endif\n\n      *nextPtr = next;\n      s = next;\n    }","target":1,"flaw_line_index":0,"hash":"c265c943-b1ac-408e-9224-56204fdb83dd","idx":"0e512009-5c00-4fec-a4f1-789a9c3f89ac"}
{"func_before":"    }\n    \/* XmlPrologTok has now set the encoding based on the BOM it found, and we\n       must move s and nextPtr forward to consume the BOM.\n\n       If we didn't, and got XML_TOK_NONE from the next XmlPrologTok call, we\n       would leave the BOM in the buffer and return. On the next call to this\n       function, our XmlPrologTok call would return XML_TOK_INVALID, since it\n       is not valid to have multiple BOMs.\n    *\/\n    else if (tok == XML_TOK_BOM) {\n#  if defined(XML_DTD) || XML_GE == 1\n      if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                    XML_ACCOUNT_DIRECT)) {\n        accountingOnAbort(parser);\n        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      }\n#  endif\n\n      *nextPtr = next;\n      s = next;\n    }","target":0,"flaw_line_index":0,"hash":"606fbd32-6bbb-4664-a651-b11e7ebe6df6","idx":"b73291fc-25d1-4c51-b27f-d660229c5935"}
{"func_before":"\n\t\/* Before first pass, make a rough estimation of addrs[]\n\t * each bpf instruction is translated to less than 64 bytes\n\t *\/\n\tfor (proglen = 0, i = 0; i < prog->len; i++) {\n\t\tproglen += 64;\n\t\taddrs[i] = proglen;\n\t}\n\tctx.cleanup_addr = proglen;\n\n\tfor (pass = 0; pass < 10; pass++) {\n\t\tproglen = do_jit(prog, addrs, image, oldproglen, &ctx);\n\t\tif (proglen <= 0) {\n\t\t\timage = NULL;\n\t\t\tif (header)\n\t\t\t\tbpf_jit_binary_free(header);\n\t\t\tgoto out;\n\t\t}\n\t\tif (image) {\n\t\t\tif (proglen != oldproglen) {\n\t\t\t\tpr_err(\"bpf_jit: proglen=%d != oldproglen=%d\\n\",","target":1,"flaw_line_index":0,"hash":"0c3ffdbe-50d4-412e-9456-05eb7bbcdad9","idx":"d1717851-645e-43e7-8a60-aecbf3072903"}
{"func_before":"\n\t\/* Before first pass, make a rough estimation of addrs[]\n\t * each bpf instruction is translated to less than 64 bytes\n\t *\/\n\tfor (proglen = 0, i = 0; i < prog->len; i++) {\n\t\tproglen += 64;\n\t\taddrs[i] = proglen;\n\t}\n\tctx.cleanup_addr = proglen;\n\n\t\/* JITed image shrinks with every pass and the loop iterates\n\t * until the image stops shrinking. Very large bpf programs\n\t * may converge on the last pass. In such case do one more\n\t * pass to emit the final image\n\t *\/\n\tfor (pass = 0; pass < 10 || image; pass++) {\n\t\tproglen = do_jit(prog, addrs, image, oldproglen, &ctx);\n\t\tif (proglen <= 0) {\n\t\t\timage = NULL;\n\t\t\tif (header)\n\t\t\t\tbpf_jit_binary_free(header);\n\t\t\tgoto out;\n\t\t}\n\t\tif (image) {\n\t\t\tif (proglen != oldproglen) {\n\t\t\t\tpr_err(\"bpf_jit: proglen=%d != oldproglen=%d\\n\",","target":0,"flaw_line_index":0,"hash":"0cd65df5-2dd1-42b8-88bd-93d58f4572f3","idx":"0de7563a-772d-47fd-adae-b7c693fa79f5"}
{"func_before":"int mi_repair_parallel(MI_CHECK *param, register MI_INFO *info,\n\t\t\tconst char * name, int rep_quick)\n{\n  int got_error;\n  uint i,key, total_key_length, istep;\n  ulong rec_length;\n  ha_rows start_records;\n  my_off_t new_header_length,del;\n  File new_file;\n  MI_SORT_PARAM *sort_param=0;\n  MYISAM_SHARE *share=info->s;\n  ulong   *rec_per_key_part;\n    threads did either detach from the share by remove_io_thread()\n    already or they were not yet started (if the error happend before\n    creating the threads).\n  *\/\n  if (!rep_quick)\n    (void) end_io_cache(&new_data_cache);\n  if (!got_error)\n  {\n    \/* Replace the actual file with the temporary file *\/\n    if (new_file >= 0)\n    {\n      mysql_file_close(new_file, MYF(0));\n      info->dfile=new_file= -1;\n      if (change_to_newfile(share->data_file_name, MI_NAME_DEXT, DATA_TMP_EXT,\n\t\t\t    (param->testflag & T_BACKUP_DATA ?\n\t\t\t     MYF(MY_REDEL_MAKE_BACKUP): MYF(0))) ||\n\t  mi_open_datafile(info,share,name,-1))\n\tgot_error=1;\n    }\n  }\n  if (got_error)\n  {\n    if (! param->error_printed)\n      mi_check_print_error(param,\"%d when fixing table\",my_errno);\n    if (new_file >= 0)\n    {","target":1,"flaw_line_index":0,"hash":"f3091ce1-96ab-405a-bdd9-a84f11bed545","idx":"ae1c1226-7a10-47a8-b85e-ecc075654d41"}
{"func_before":"int mi_repair_parallel(MI_CHECK *param, register MI_INFO *info,\n                       const char * name, int rep_quick, my_bool no_copy_stat)\n{\n  int got_error;\n  uint i,key, total_key_length, istep;\n  ulong rec_length;\n  ha_rows start_records;\n  my_off_t new_header_length,del;\n  File new_file;\n  MI_SORT_PARAM *sort_param=0;\n  MYISAM_SHARE *share=info->s;\n  ulong   *rec_per_key_part;\n    already or they were not yet started (if the error happend before\n    creating the threads).\n  *\/\n  if (!rep_quick)\n    (void) end_io_cache(&new_data_cache);\n  if (!got_error)\n  {\n    \/* Replace the actual file with the temporary file *\/\n    if (new_file >= 0)\n    {\n      myf flags= 0;\n      if (param->testflag & T_BACKUP_DATA)\n        flags |= MY_REDEL_MAKE_BACKUP;\n      if (no_copy_stat)\n        flags |= MY_REDEL_NO_COPY_STAT;\n      mysql_file_close(new_file, MYF(0));\n      info->dfile=new_file= -1;\n      if (change_to_newfile(share->data_file_name, MI_NAME_DEXT, DATA_TMP_EXT,\n\t\t\t    flags) ||\n\t  mi_open_datafile(info,share,name,-1))\n\tgot_error=1;\n    }\n  }\n  if (got_error)\n  {\n    if (! param->error_printed)\n      mi_check_print_error(param,\"%d when fixing table\",my_errno);\n    if (new_file >= 0)\n    {","target":0,"flaw_line_index":0,"hash":"9a9ee7f7-45d7-45e1-8962-86693e945f5d","idx":"dc40fdd5-9033-4348-bd94-f0892d9e9ab6"}
{"func_before":"\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"5d716b78-6820-49de-a537-276afbb3d66e","idx":"02ffa6cc-0ec2-4abd-a0a5-0d4a8ea777f7"}
{"func_before":"\t}\n\n\textra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);\n\tif (!extra_response) {\n\t\tpr_err(\"Unable to allocate memory for\"\n\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrlcpy(extra_response->key, key, sizeof(extra_response->key));\n\tstrlcpy(extra_response->value, NOTUNDERSTOOD,\n\t\tsizeof(extra_response->value));\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"46baebd3-5a86-4abb-9bfd-808c7264cc80","idx":"efc9d6aa-ce66-4715-bb45-8890bc231d42"}
{"func_before":"void fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, const bn_t d) {\n\tint i, l, n0, n1, l0, l1;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;\n\tfp24_t r, t0[1 << (EP_WIDTH - 2)];\n\tfp24_t s, t1[1 << (EP_WIDTH - 2)];\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp24_exp_cyc(e, c, d);\n\t}\n\n\tif (bn_is_zero(d)) {\n\t\treturn fp24_exp_cyc(e, a, b);\n\t}\n\n\tfp24_null(r);\n\tfp24_null(s);\n\n\tRLC_TRY {\n\t\tfp24_new(r);\n\t\tfp24_new(s);\n\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n\t\t\tfp24_null(t0[i]);\n\t\t\tfp24_null(t1[i]);\n\t\t\tfp24_new(t0[i]);\n\t\t\tfp24_new(t1[i]);\n\t\t}\n\n#if FP_WIDTH > 2\n\t\tfp24_sqr(t0[0], a);\n\t\tfp24_mul(t0[1], t0[0], a);\n\t\tfor (int i = 2; i < (1 << (FP_WIDTH - 2)); i++) {\n#endif\n\t\tfp24_copy(t0[0], a);\n\t\tfp24_copy(t1[0], c);\n\n\t\tl0 = l1 = RLC_FP_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, b, FP_WIDTH);\n\t\tbn_rec_naf(naf1, &l1, d, FP_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfor (i = 0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(d) == RLC_NEG) {\n\t\t\tfor (i = 0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\n\t\t_k = naf0 + l - 1;\n\t\t_m = naf1 + l - 1;\n\n\t\tfp24_set_dig(r, 1);\n\t\tfor (i = l - 1; i >= 0; i--, _k--, _m--) {\n\t\t\tfp24_sqr(r, r);\n\n\t\t\tn0 = *_k;\n\t\t\tn1 = *_m;\n\n\t\t\tif (n0 > 0) {\n\t\t\t\tfp24_mul(r, r, t0[n0 \/ 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\tfp24_inv_cyc(s, t0[-n0 \/ 2]);\n\t\t}\n\n\t\tfp24_copy(e, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp24_free(r);\n\t\tfp24_free(s);\n\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp24_free(t0[i]);\n\t\t\tfp24_free(t1[i]);\n\t\t}\n\t}\n}","target":1,"flaw_line_index":0,"hash":"381e5482-edb4-4690-af60-aa1c745efb17","idx":"53fbf6b6-e3d8-4a27-aa6f-0b3385449399"}
{"func_before":"void fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, const bn_t d) {\n\tint n0, n1;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;\n\tfp24_t r, t0[1 << (EP_WIDTH - 2)];\n\tfp24_t s, t1[1 << (EP_WIDTH - 2)];\n\tsize_t l, l0, l1;\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp24_exp_cyc(e, c, d);\n\t}\n\n\tif (bn_is_zero(d)) {\n\t\treturn fp24_exp_cyc(e, a, b);\n\t}\n\n\tfp24_null(r);\n\tfp24_null(s);\n\n\tRLC_TRY {\n\t\tfp24_new(r);\n\t\tfp24_new(s);\n\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n\t\t\tfp24_null(t0[i]);\n\t\t\tfp24_null(t1[i]);\n\t\t\tfp24_new(t0[i]);\n\t\t\tfp24_new(t1[i]);\n\t\t}\n\n#if FP_WIDTH > 2\n\t\tfp24_sqr(t0[0], a);\n\t\tfp24_mul(t0[1], t0[0], a);\n\t\tfor (int i = 2; i < (1 << (FP_WIDTH - 2)); i++) {\n#endif\n\t\tfp24_copy(t0[0], a);\n\t\tfp24_copy(t1[0], c);\n\n\t\tl0 = l1 = RLC_FP_BITS + 1;\n\t\tbn_rec_naf(naf0, &l0, b, FP_WIDTH);\n\t\tbn_rec_naf(naf1, &l1, d, FP_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfor (size_t i = 0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(d) == RLC_NEG) {\n\t\t\tfor (size_t i = 0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\n\t\t_k = naf0 + l - 1;\n\t\t_m = naf1 + l - 1;\n\n\t\tfp24_set_dig(r, 1);\n\t\tfor (int i = l - 1; i >= 0; i--, _k--, _m--) {\n\t\t\tfp24_sqr(r, r);\n\n\t\t\tn0 = *_k;\n\t\t\tn1 = *_m;\n\n\t\t\tif (n0 > 0) {\n\t\t\t\tfp24_mul(r, r, t0[n0 \/ 2]);\n\t\t\t}\n\t\t\tif (n0 < 0) {\n\t\t\t\tfp24_inv_cyc(s, t0[-n0 \/ 2]);\n\t\t}\n\n\t\tfp24_copy(e, r);\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp24_free(r);\n\t\tfp24_free(s);\n\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp24_free(t0[i]);\n\t\t\tfp24_free(t1[i]);\n\t\t}\n\t}\n}","target":0,"flaw_line_index":0,"hash":"1efe5579-f25b-4bcf-92e2-8be4f305a413","idx":"92edf706-5070-467b-8513-094e52111cd7"}
{"func_before":"const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  \/* access to vararg values? *\/\n      return findvararg(ci, -n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  \/* no 'standard' name? *\/\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) {  \/* is 'n' inside 'ci' stack? *\/\n      \/* generic name for any valid slot *\/\n      name = isLua(ci) ? \"(temporary)\" : \"(C temporary)\";\n    }\n    else","target":1,"flaw_line_index":0,"hash":"d8dac704-fd53-4ce4-b91e-5257ff40ddb8","idx":"d1258e5b-c024-408a-b763-1e215c52d849"}
{"func_before":"const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  \/* access to vararg values? *\/\n      return findvararg(ci, n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  \/* no 'standard' name? *\/\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;\n    if (limit - base >= n && n > 0) {  \/* is 'n' inside 'ci' stack? *\/\n      \/* generic name for any valid slot *\/\n      name = isLua(ci) ? \"(temporary)\" : \"(C temporary)\";\n    }\n    else","target":0,"flaw_line_index":0,"hash":"5168173d-fc89-47dc-ab4b-16bb900bae80","idx":"1729031c-b47d-434f-a469-99961a7fbd28"}
{"func_before":"\t\tunsigned long base;\n\t\tunsigned long truesize;\n\n\t\tlen = from->iov_len - offset;\n\t\tif (!len) {\n\t\t\toffset = 0;\n\t\t\t++from;\n\t\t\tcontinue;\n\t\t}\n\t\tbase = (unsigned long)from->iov_base + offset;\n\t\tsize = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;\n\t\tnum_pages = get_user_pages_fast(base, size, 0, &page[i]);\n\t\tif ((num_pages != size) ||\n\t\t    (num_pages > MAX_SKB_FRAGS - skb_shinfo(skb)->nr_frags)) {\n\t\t\tfor (i = 0; i < num_pages; i++)\n\t\t\t\tput_page(page[i]);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\ttruesize = size * PAGE_SIZE;\n\t\tskb->data_len += len;\n\t\tskb->len += len;\n\t\tskb->truesize += truesize;\n\t\tatomic_add(truesize, &skb->sk->sk_wmem_alloc);\n\t\twhile (len) {","target":1,"flaw_line_index":0,"hash":"e2d3ab5b-252c-4613-af5f-5a3e72afc663","idx":"bb99b6fa-73a9-4e9e-a60c-396a8986f6ac"}
{"func_before":"\t\tunsigned long truesize;\n\n\t\tlen = from->iov_len - offset;\n\t\tif (!len) {\n\t\t\toffset = 0;\n\t\t\t++from;\n\t\t\tcontinue;\n\t\t}\n\t\tbase = (unsigned long)from->iov_base + offset;\n\t\tsize = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;\n\t\tif (i + size > MAX_SKB_FRAGS)\n\t\t\treturn -EMSGSIZE;\n\t\tnum_pages = get_user_pages_fast(base, size, 0, &page[i]);\n\t\tif (num_pages != size) {\n\t\t\tfor (i = 0; i < num_pages; i++)\n\t\t\t\tput_page(page[i]);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\ttruesize = size * PAGE_SIZE;\n\t\tskb->data_len += len;\n\t\tskb->len += len;\n\t\tskb->truesize += truesize;\n\t\tatomic_add(truesize, &skb->sk->sk_wmem_alloc);\n\t\twhile (len) {","target":0,"flaw_line_index":0,"hash":"6b419cff-0125-43ef-adc1-48e2654e1dc3","idx":"d0df1594-ece9-4e42-9739-d86fe49ebe9e"}
{"func_before":"static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    \n    int i, n = 0, len = Jsi_ObjGetLength(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = Jsi_ObjGetLength(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))\n            Jsi_ObjArrayAdd(interp, nobj, t);\n        if ((++n + clen)>interp->maxArrayList)\n            return Jsi_LogError(\"array size exceeded\");\n    }\n    return rc;","target":1,"flaw_line_index":0,"hash":"60d23d03-574e-4821-8da0-2c2eb0b5dbf1","idx":"518e8ffd-718c-4fc0-9e69-700613be504f"}
{"func_before":"static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    \n    int i, n = 0, len = jsi_SizeOfArray(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = jsi_SizeOfArray(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))\n            Jsi_ObjArrayAdd(interp, nobj, t);\n        if ((++n + clen)>interp->maxArrayList)\n            return Jsi_LogError(\"array size exceeded\");\n    }\n    return rc;","target":0,"flaw_line_index":0,"hash":"ec95fc47-0490-481f-b3a5-450fd0fc6db4","idx":"baaf5954-6d82-4048-b346-d0af96968d72"}
{"func_before":"        n = ( (unsigned int) ssl->in_msg[i + 1] << 8 )\n            | (unsigned int) ssl->in_msg[i + 2];\n        i += 3;\n\n        if( n < 128 || i + n > ssl->in_hslen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n            return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        ret = x509parse_crt( ssl->session_negotiate->peer_cert, ssl->in_msg + i,\n                             n );\n        if( ret != 0 )\n        {\n            SSL_DEBUG_RET( 1, \" x509parse_crt\", ret );\n            return( ret );\n        }\n\n        i += n;\n    }\n\n    SSL_DEBUG_CRT( 3, \"peer certificate\", ssl->session_negotiate->peer_cert );","target":1,"flaw_line_index":0,"hash":"87c2f3a3-6237-4062-908c-a356df516687","idx":"bc91daef-92e4-48e0-9868-13a7e916b41d"}
{"func_before":"        n = ( (unsigned int) ssl->in_msg[i + 1] << 8 )\n            | (unsigned int) ssl->in_msg[i + 2];\n        i += 3;\n\n        if( n < 128 || i + n > ssl->in_hslen )\n        {\n            SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n            return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        ret = x509parse_crt_der( ssl->session_negotiate->peer_cert,\n                                 ssl->in_msg + i, n );\n        if( ret != 0 )\n        {\n            SSL_DEBUG_RET( 1, \" x509parse_crt\", ret );\n            return( ret );\n        }\n\n        i += n;\n    }\n\n    SSL_DEBUG_CRT( 3, \"peer certificate\", ssl->session_negotiate->peer_cert );","target":0,"flaw_line_index":0,"hash":"5bb49f17-5eec-4b23-8803-ee0d11431c84","idx":"f1430874-7833-4499-95e8-f814fc0e7fb6"}
{"func_before":"bool ActiveStreamDecoderFilter::complete() { return parent_.state_.remote_complete_; }","target":1,"flaw_line_index":0,"hash":"1fdd242a-649a-4623-9280-96ca87cbebe6","idx":"ee93cc51-60fa-41a1-b6d1-0799f2d12aef"}
{"func_before":"bool ActiveStreamDecoderFilter::complete() { return parent_.state_.remote_decode_complete_; }","target":0,"flaw_line_index":0,"hash":"854b3dd0-7f4c-481f-a7a3-e1adb1521ad6","idx":"e100bccb-7890-47db-9f8c-ad985b2fcf3f"}
{"func_before":"\td = M_malloc_zero(len);\n\t\/* Return is length without NULL. *\/\n\tif (GetTempPath((DWORD)len, d) >= len) {\n\t\tM_free(d);\n\t\td = NULL;\n\t}\n#elif defined(__APPLE__)\n\td = M_fs_path_mac_tmpdir();\n#else\n\tconst char *const_temp;\n\t\/* Try Unix env var. *\/\n#  ifdef HAVE_SECURE_GETENV\n\tconst_temp = secure_getenv(\"TMPDIR\");\n#  else\n\tconst_temp = getenv(\"TMPDIR\");\n#  endif\n\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\td = M_strdup(const_temp);\n\t}\n\t\/* Fallback to some \"standard\" system paths. *\/\n\tif (d == NULL) {","target":1,"flaw_line_index":0,"hash":"f96121c8-1990-486e-b17c-d64cb8bf716c","idx":"b2ccbe81-b0db-432c-858c-981929b68e4b"}
{"func_before":"\td = M_malloc_zero(len);\n\t\/* Return is length without NULL. *\/\n\tif (GetTempPath((DWORD)len, d) >= len) {\n\t\tM_free(d);\n\t\td = NULL;\n\t}\n#elif defined(__APPLE__)\n\td = M_fs_path_mac_tmpdir();\n#else\n\tconst char *const_temp;\n\t\/* Unix doens't have a fancy function to get the standard\n\t * temporary directory an application can use. Instead there\n\t * is a convoluted set of possible paths that could be used.\n\t *\n\t * We're going to go though each one in a priority order and\n\t * verify if we can read and write the directory. If so then\n\t * that's the one that will be used. We are fine using access\n\t * here because it doesn't matter if the path ends up being\n\t * changed out from underneath us later on. When it's used\n\t * at that time it will fail. Right now we just want to get\n\t * a path that can be tried. *\/\n\n\t\/* Try Unix env vars.\n\t *\n\t * This is not ideal but a valid way to set the temporary directory\n\t * for a user. Per Single Unix Specification 4 and probably other things.\n\t *\/\n#  ifdef HAVE_SECURE_GETENV\n\tconst_temp = secure_getenv(\"TMPDIR\");\n#  else\n\tconst_temp = getenv(\"TMPDIR\");\n#  endif\n\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\td = M_strdup(const_temp);\n\t}\n\t\/* Fallback to some \"standard\" system paths. *\/\n\tif (d == NULL) {","target":0,"flaw_line_index":0,"hash":"c01e6baf-a54f-4ccb-9065-4e7674897b96","idx":"8e152347-5e53-43c6-8e55-51d5c700418a"}
{"func_before":"static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, int open_flags)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *deleg_cur;\n\tint ret = 0;\n\n\topen_flags &= (FMODE_READ|FMODE_WRITE);\n\n\trcu_read_lock();\n\tdeleg_cur = rcu_dereference(nfsi->delegation);\n\tif (deleg_cur == NULL)\n\t\tgoto no_delegation;\n\n\tspin_lock(&deleg_cur->lock);\n\tif (nfsi->delegation != deleg_cur ||\n\t    (deleg_cur->type & open_flags) != open_flags)\n\t\tgoto no_delegation_unlock;\n\n\tif (delegation == NULL)\n\t\tdelegation = &deleg_cur->stateid;\n\telse if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)\n\t\tgoto no_delegation_unlock;\n\n\tnfs_mark_delegation_referenced(deleg_cur);\n\t__update_open_stateid(state, open_stateid, &deleg_cur->stateid, open_flags);\n\tret = 1;\nno_delegation_unlock:\n\tspin_unlock(&deleg_cur->lock);\nno_delegation:\n\trcu_read_unlock();\n\n\tif (!ret && open_stateid != NULL) {\n\t\t__update_open_stateid(state, open_stateid, NULL, open_flags);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}","target":1,"flaw_line_index":0,"hash":"010a3c6f-8f08-42ab-8e46-95ffc56212ee","idx":"e60b5f42-15ca-44fb-be83-26de90867d7e"}
{"func_before":"static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, fmode_t fmode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *deleg_cur;\n\tint ret = 0;\n\n\tfmode &= (FMODE_READ|FMODE_WRITE);\n\n\trcu_read_lock();\n\tdeleg_cur = rcu_dereference(nfsi->delegation);\n\tif (deleg_cur == NULL)\n\t\tgoto no_delegation;\n\n\tspin_lock(&deleg_cur->lock);\n\tif (nfsi->delegation != deleg_cur ||\n\t    (deleg_cur->type & fmode) != fmode)\n\t\tgoto no_delegation_unlock;\n\n\tif (delegation == NULL)\n\t\tdelegation = &deleg_cur->stateid;\n\telse if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)\n\t\tgoto no_delegation_unlock;\n\n\tnfs_mark_delegation_referenced(deleg_cur);\n\t__update_open_stateid(state, open_stateid, &deleg_cur->stateid, fmode);\n\tret = 1;\nno_delegation_unlock:\n\tspin_unlock(&deleg_cur->lock);\nno_delegation:\n\trcu_read_unlock();\n\n\tif (!ret && open_stateid != NULL) {\n\t\t__update_open_stateid(state, open_stateid, NULL, fmode);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}","target":0,"flaw_line_index":0,"hash":"87aa69cf-577f-47d5-8ff3-84e2dde1c3ce","idx":"fa64c04c-22d4-44b0-8355-a0214cd885c3"}
{"func_before":"\n    const bool is_profiling = profile_result != nullptr;\n\n    std::unique_ptr<GpuTimer, GpuTimerDeleter> timer;\n    if (is_profiling) {\n      timer.reset(new GpuTimer(parent_));  \/\/ NOLINT\n      \/\/ The start and stop of the timer should be as close to the Cudnn call as\n      \/\/ possible. It is still possible for other threads to issue workload on\n      \/\/ to this stream. So it could take multiple profiling measurements.\n      if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n        return tsl::Status(port::error::INTERNAL, \"Failed to start timer\");\n      }\n    }\n\n    cudnnStatus_t status = cudnnBackendExecute(\n        cudnn.handle(), plan_.get_raw_desc(), variantPack.get_raw_desc());\n    RETURN_IF_CUDNN_ERROR(status);\n\n    if (is_profiling) {\n      if (!timer->Stop(AsGpuStream(stream))) {\n        return tsl::Status(port::error::INTERNAL, \"Failed to stop timer\");\n      }\n      TF_ASSIGN_OR_RETURN(auto desc, ToAlgorithmDesc());\n      profile_result->set_algorithm(desc);\n      profile_result->set_elapsed_time_in_ms(timer->GetElapsedMilliseconds());\n      profile_result->set_scratch_size(scratch_memory.size());\n\n      VLOG(4) << \"cudnn op with plan \" << plan_.getTag()\n              << \", workspace_size=\" << workspace_size << \" -> \"\n              << CudnnStatusToString(status) << \" in \"\n              << timer->GetElapsedMilliseconds() << \"ms\";","target":1,"flaw_line_index":0,"hash":"3e771a0c-7433-4fe7-b7db-64a941cbeb25","idx":"1e924ed3-7903-4005-ae02-c355ba5061ef"}
{"func_before":"\n    const bool is_profiling = profile_result != nullptr;\n\n    std::unique_ptr<GpuTimer, GpuTimerDeleter> timer;\n    if (is_profiling) {\n      timer.reset(new GpuTimer(parent_));  \/\/ NOLINT\n      \/\/ The start and stop of the timer should be as close to the Cudnn call as\n      \/\/ possible. It is still possible for other threads to issue workload on\n      \/\/ to this stream. So it could take multiple profiling measurements.\n      if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n        return tsl::Status(tsl::error::INTERNAL, \"Failed to start timer\");\n      }\n    }\n\n    cudnnStatus_t status = cudnnBackendExecute(\n        cudnn.handle(), plan_.get_raw_desc(), variantPack.get_raw_desc());\n    RETURN_IF_CUDNN_ERROR(status);\n\n    if (is_profiling) {\n      if (!timer->Stop(AsGpuStream(stream))) {\n        return tsl::Status(tsl::error::INTERNAL, \"Failed to stop timer\");\n      }\n      TF_ASSIGN_OR_RETURN(auto desc, ToAlgorithmDesc());\n      profile_result->set_algorithm(desc);\n      profile_result->set_elapsed_time_in_ms(timer->GetElapsedMilliseconds());\n      profile_result->set_scratch_size(scratch_memory.size());\n\n      VLOG(4) << \"cudnn op with plan \" << plan_.getTag()\n              << \", workspace_size=\" << workspace_size << \" -> \"\n              << CudnnStatusToString(status) << \" in \"\n              << timer->GetElapsedMilliseconds() << \"ms\";","target":0,"flaw_line_index":0,"hash":"a75aa684-b801-4c8d-b92a-67283981fd4a","idx":"c879c734-fdf5-4909-ae63-a794291f0685"}
{"func_before":"      void Init(void)\n      {\n        for(int i = 0;i < 18;i++) {\n          X[i].Init();\n          M[i].Init();\n        }\n      }","target":1,"flaw_line_index":0,"hash":"858db563-6ef2-41f1-9ff8-dd9d585a6936","idx":"774730c6-6a8a-4353-9922-a6a8023b8972"}
{"func_before":"      void Init(void)\n      {\n        for(int i = 0;i < MagnitudeContexts;i++) {\n          X[i].Init();\n          M[i].Init();\n        }\n      }","target":0,"flaw_line_index":0,"hash":"56386af8-e8c8-430c-a917-042646ad41f8","idx":"0eb7534e-7fb3-40ea-ba83-bd034d1a4eb3"}
{"func_before":"        getComputedSlotValue(propObj.get(), runtime, desc));\n    if (!accessor->getter)\n      return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n    \/\/ Execute the accessor on this object.\n    return accessor->getter.get(runtime)->executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    SymbolID id{};\n    LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n    auto propRes = vmcast<HostObject>(selfHandle.get())->get(id);\n    if (propRes == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return createPseudoHandle(*propRes);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return JSProxy::getComputed(propObj, runtime, *key, receiver);\n  }","target":1,"flaw_line_index":0,"hash":"60614041-2038-4e0f-b2a7-c1ec7cbb7c27","idx":"67f56126-f27c-49bd-a405-d4be90bc741a"}
{"func_before":"        getComputedSlotValue(propObj.get(), runtime, desc));\n    if (!accessor->getter)\n      return createPseudoHandle(HermesValue::encodeUndefinedValue());\n\n    \/\/ Execute the accessor on this object.\n    return accessor->getter.get(runtime)->executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    SymbolID id{};\n    LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n    auto propRes = vmcast<HostObject>(propObj.get())->get(id);\n    if (propRes == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return createPseudoHandle(*propRes);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");\n    CallResult<Handle<>> key = toPropertyKey(runtime, nameValPrimitiveHandle);\n    if (key == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return JSProxy::getComputed(propObj, runtime, *key, receiver);\n  }","target":0,"flaw_line_index":0,"hash":"ad9f92b1-d4f4-4d7a-9a86-d59fe1a33c0e","idx":"db2ffac0-9df5-40dc-a032-afe686fd738a"}
{"func_before":"\n            if (tls_io_instance->certificate != NULL)\n            {\n                \/\/ Free the memory if it has been previously allocated\n                free(tls_io_instance->certificate);\n                tls_io_instance->certificate = NULL;\n            }\n\n            \/\/ Store the certificate\n            len = strlen(cert);\n            tls_io_instance->certificate = malloc(len + 1);\n            if (tls_io_instance->certificate == NULL)\n            {\n                result = MU_FAILURE;\n            }\n            else\n            {\n                strcpy(tls_io_instance->certificate, cert);\n                result = 0;\n            }\n\n            \/\/ If we're previously connected then add the cert to the context\n            if (tls_io_instance->ssl_context != NULL)","target":1,"flaw_line_index":0,"hash":"418b0d10-20a6-4361-acf9-07ad49e17419","idx":"845a736f-9fb9-4206-a564-dd564f392dd3"}
{"func_before":"\n            if (tls_io_instance->certificate != NULL)\n            {\n                \/\/ Free the memory if it has been previously allocated\n                free(tls_io_instance->certificate);\n                tls_io_instance->certificate = NULL;\n            }\n\n            \/\/ Store the certificate\n            len = strlen(cert);\n            size_t malloc_size = safe_add_size_t(len, 1);\n            if (malloc_size == SIZE_MAX ||\n                (tls_io_instance->certificate = malloc(malloc_size)) == NULL)\n            {\n                LogError(\"malloc failure, size:%zu\", malloc_size);\n                result = MU_FAILURE;\n            }\n            else\n            {\n                strcpy(tls_io_instance->certificate, cert);\n                result = 0;\n            }\n\n            \/\/ If we're previously connected then add the cert to the context\n            if (tls_io_instance->ssl_context != NULL)","target":0,"flaw_line_index":0,"hash":"9c47c93b-1fd1-4b1a-9452-c5b5470b15a9","idx":"742480dd-d62b-45d5-89d6-afae0fd24576"}
{"func_before":"list_dbs(MYSQL *mysql,const char *wild)\n{\n  const char *header;\n  uint length, counter = 0;\n  ulong rowcount = 0L;\n  char tables[NAME_LEN+1], rows[NAME_LEN+1];\n  char query[255];\n  MYSQL_FIELD *field;\n  MYSQL_RES *result;\n  MYSQL_ROW row= NULL, rrow;\n\n  if (!(result=mysql_list_dbs(mysql,wild)))\n  {\n    fprintf(stderr,\"%s: Cannot list databases: %s\\n\",my_progname,\n\t    mysql_error(mysql));\n    return 1;\n  }\n\tif (mysql_affected_rows(mysql) > 0)\n\t{\n\t  sprintf(tables,\"%6lu\",(ulong) mysql_affected_rows(mysql));\n\t  rowcount = 0;\n\t  if (opt_verbose > 1)\n\t  {\n            \/* Print the count of tables and rows for each database *\/\n            MYSQL_ROW trow;\n\t    while ((trow = mysql_fetch_row(tresult)))\n\t    {\n\t      sprintf(query,\"SELECT COUNT(*) FROM `%s`\",trow[0]);\n\t      if (!(mysql_query(mysql,query)))\n\t      {\n\t\tMYSQL_RES *rresult;\n\t\tif ((rresult = mysql_store_result(mysql)))\n\t\t{\n\t\t  rrow = mysql_fetch_row(rresult);\n\t\t  rowcount += (ulong) strtoull(rrow[0], (char**) 0, 10);\n\t\t  mysql_free_result(rresult);\n\t\t}\n\t      }","target":1,"flaw_line_index":0,"hash":"d662e3b5-e63e-4eef-8563-152b8cbf7822","idx":"da1d9fcf-2073-48ec-a65c-f5f19574cb5f"}
{"func_before":"list_dbs(MYSQL *mysql,const char *wild)\n{\n  const char *header;\n  uint length, counter = 0;\n  ulong rowcount = 0L;\n  char tables[NAME_LEN+1], rows[NAME_LEN+1];\n  char query[NAME_LEN + 100];\n  MYSQL_FIELD *field;\n  MYSQL_RES *result;\n  MYSQL_ROW row= NULL, rrow;\n\n  if (!(result=mysql_list_dbs(mysql,wild)))\n  {\n    fprintf(stderr,\"%s: Cannot list databases: %s\\n\",my_progname,\n\t    mysql_error(mysql));\n    return 1;\n  }\n\tif (mysql_affected_rows(mysql) > 0)\n\t{\n\t  sprintf(tables,\"%6lu\",(ulong) mysql_affected_rows(mysql));\n\t  rowcount = 0;\n\t  if (opt_verbose > 1)\n\t  {\n            \/* Print the count of tables and rows for each database *\/\n            MYSQL_ROW trow;\n\t    while ((trow = mysql_fetch_row(tresult)))\n\t    {\n              my_snprintf(query, sizeof(query),\n                          \"SELECT COUNT(*) FROM `%s`\", trow[0]);\n\t      if (!(mysql_query(mysql,query)))\n\t      {\n\t\tMYSQL_RES *rresult;\n\t\tif ((rresult = mysql_store_result(mysql)))\n\t\t{\n\t\t  rrow = mysql_fetch_row(rresult);\n\t\t  rowcount += (ulong) strtoull(rrow[0], (char**) 0, 10);\n\t\t  mysql_free_result(rresult);\n\t\t}\n\t      }","target":0,"flaw_line_index":0,"hash":"2e347d5b-1f4e-47e2-9285-a9d499cd4e34","idx":"d11ee5da-d315-417d-9aeb-ca5c0a2061c8"}
{"func_before":"\tM_fs_file_t   *fd_old;\n\tM_fs_file_t   *fd_new;\n\tM_fs_info_t   *info         = NULL;\n\tunsigned char  temp[M_FS_BUF_SIZE];\n\tsize_t         read_len;\n\tsize_t         wrote_len;\n\tsize_t         wrote_total  = 0;\n\tsize_t         offset;\n\tM_fs_error_t   res;\n\n\t\/* We're going to create\/open\/truncate the new file, then as we read the contents from the old file we'll write it\n \t * to new file. *\/\n\tif (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n\t\t\/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without\n \t\t * any permissions and to ensure that anything that has the file already open won't be able to read the new\n\t\t * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition\n\t\t * between deleting and creating the file where someone could create the file and have access. However,\n\t\t * depending on the OS they may have access even if the file is created with no perms... *\/\n\t\tres = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\treturn res;\n\t\t}\n\t}\n\t\/* Open the old file *\/\n\tres = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\treturn res;\n\t}\n\n\tif (perms == NULL && mode & M_FS_FILE_MODE_PRESERVE_PERMS) {\n\t\tres = M_fs_info_file(&info, fd_old, M_FS_PATH_INFO_FLAGS_NONE);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tM_fs_file_close(fd_old);\n\t\t\treturn res;\n\t\t}\n\t\tperms = M_fs_info_get_perms(info);\n\t}\n\tres = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);\n\tM_fs_info_destroy(info);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_fs_file_close(fd_old);\n\t\treturn res;\n\t}\n\n\t\/* Copy the contents of old into new. *\/\n\twhile ((res = M_fs_file_read(fd_old, temp, sizeof(temp), &read_len, M_FS_FILE_RW_NORMAL)) == M_FS_ERROR_SUCCESS && read_len != 0) {\n\t\toffset = 0;","target":1,"flaw_line_index":0,"hash":"611e42f9-1a61-4eb5-99d6-0c73bcedf259","idx":"35487fc8-0f04-4702-b60c-ff8e59dcf98f"}
{"func_before":"{\n\tM_fs_file_t   *fd_old;\n\tM_fs_file_t   *fd_new;\n\tM_fs_info_t   *info         = NULL;\n\tunsigned char  temp[M_FS_BUF_SIZE];\n\tsize_t         read_len;\n\tsize_t         wrote_len;\n\tsize_t         wrote_total  = 0;\n\tsize_t         offset;\n\tM_fs_error_t   res;\n\n\t\/* Open the old file *\/\n\tres = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\treturn res;\n\t}\n\n\tif (perms == NULL && mode & M_FS_FILE_MODE_PRESERVE_PERMS) {\n\t\tres = M_fs_info_file(&info, fd_old, M_FS_PATH_INFO_FLAGS_NONE);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tM_fs_file_close(fd_old);\n\t\t\treturn res;\n\t\t}\n\t\tperms = M_fs_info_get_perms(info);\n\t}\n\n\t\/* We're going to create\/open\/truncate the new file, then as we read the contents from the old file we'll write it\n\t * to new file. *\/\n\tres = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);\n\tM_fs_info_destroy(info);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_fs_file_close(fd_old);\n\t\treturn res;\n\t}\n\n\t\/* Copy the contents of old into new. *\/\n\twhile ((res = M_fs_file_read(fd_old, temp, sizeof(temp), &read_len, M_FS_FILE_RW_NORMAL)) == M_FS_ERROR_SUCCESS && read_len != 0) {\n\t\toffset = 0;","target":0,"flaw_line_index":0,"hash":"e79e8f7d-02fc-4be2-be60-62eba9e59ab1","idx":"76023c70-d360-44ad-aa11-dc6c10e83967"}
{"func_before":"\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tint j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tmemcpy(file->name, d, len);\n\t\t\tfile->namelen = len;\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n","target":1,"flaw_line_index":0,"hash":"1ab5c99e-5d8b-48d0-b445-901a122ed51f","idx":"9cfa41fe-04e5-4bf0-9364-423cf7e1a1c6"}
{"func_before":"\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tsize_t j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tfile->namelen = MIN(sizeof file->name, len);\n\t\t\tmemcpy(file->name, d, file->namelen);\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n","target":0,"flaw_line_index":0,"hash":"18e34211-36bc-4319-830e-944c566bd742","idx":"c5957516-6a2a-4e75-bc63-7d706de8dddf"}
{"func_before":"    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n      \n      \/*\n        Mipmapcount includes the main image, so start from one\n      *\/\n      for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) w * h * pixel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n        \n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}","target":1,"flaw_line_index":0,"hash":"f06b985a-f5cc-4b56-8a7d-ce4a81b92ab5","idx":"db81d8f4-995b-4ac0-9fd8-48b70c6b92cb"}
{"func_before":"    {\n      w = DIV2(dds_info->width);\n      h = DIV2(dds_info->height);\n      \n      \/*\n        Mipmapcount includes the main image, so start from one\n      *\/\n      for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) w * h * pixel_size;\n        if (SeekBlob(image, offset, SEEK_CUR) < 0)\n          break;\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);\n}","target":0,"flaw_line_index":0,"hash":"92ea1b62-613c-4f3c-b39e-c114f7443842","idx":"a4ca2d7f-3349-4aaa-bb2d-e8c9f203bb6a"}
{"func_before":"\t\t.id\t\t= primary_event_id(event),\n\t\t.stream_id\t= event->id,\n\t};\n\n\tif (enable)\n\t\tthrottle_event.header.type = PERF_RECORD_UNTHROTTLE;\n\n\tperf_event_header__init_id(&throttle_event.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tthrottle_event.header.size, 1, 0);\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, throttle_event);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\tperf_output_end(&handle);\n}","target":1,"flaw_line_index":0,"hash":"c8460af9-5598-4203-a2f9-ff3c56481147","idx":"9700f151-b9e5-44cf-b7e4-1e3e5b7b27a2"}
{"func_before":"\t\t.id\t\t= primary_event_id(event),\n\t\t.stream_id\t= event->id,\n\t};\n\n\tif (enable)\n\t\tthrottle_event.header.type = PERF_RECORD_UNTHROTTLE;\n\n\tperf_event_header__init_id(&throttle_event.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tthrottle_event.header.size, 0);\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, throttle_event);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\tperf_output_end(&handle);\n}","target":0,"flaw_line_index":0,"hash":"b5374c6c-0cc6-4a44-8c42-299c02057078","idx":"4e7c11d8-4d08-43cb-8a5f-7c2f9d973d2e"}
{"func_before":"            }\n\n            bytes = GetDigestSize( session->authHash );\n\n            if( key.t.size == 0 )\n            {\n                session->sessionKey.t.size = 0;\n            }\n            else\n            {\n                rval = tpm_kdfa(sapi_context, session->authHash, &(key.b), label, &( session->nonceNewer.b ),\n                        &( session->nonceOlder.b ), bytes * 8, (TPM2B_MAX_BUFFER *)&( session->sessionKey ) );\n            }\n\n            if( rval != TPM_RC_SUCCESS )\n            {\n                return( TSS2_APP_RC_CREATE_SESSION_KEY_FAILED );\n            }\n        }\n\n        session->nonceTpmDecrypt.b.size = 0;","target":1,"flaw_line_index":0,"hash":"bf9a40be-46e2-4e36-8647-1b80d00caaff","idx":"d4b963de-d39b-4be6-a482-6f05e456c3d1"}
{"func_before":"            }\n\n            bytes = GetDigestSize( session->authHash );\n\n            if( key.t.size == 0 )\n            {\n                session->sessionKey.t.size = 0;\n            }\n            else\n            {\n                rval = tpm_kdfa(session->authHash, &(key.b), label, &( session->nonceNewer.b ),\n                        &( session->nonceOlder.b ), bytes * 8, (TPM2B_MAX_BUFFER *)&( session->sessionKey ) );\n            }\n\n            if( rval != TPM_RC_SUCCESS )\n            {\n                return( TSS2_APP_RC_CREATE_SESSION_KEY_FAILED );\n            }\n        }\n\n        session->nonceTpmDecrypt.b.size = 0;","target":0,"flaw_line_index":0,"hash":"e38a2b5c-e252-4b9b-b0ff-04811201457e","idx":"0c89f451-1d61-4c60-a85c-d30bb4657852"}
{"func_before":"void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tvoid *vapic;\n\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\t*(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr)) = data;\n\tkunmap_atomic(vapic);\n}","target":1,"flaw_line_index":0,"hash":"2a17c49f-0989-4ab2-94f0-cdf2952dea0b","idx":"456bdf10-c03b-4e66-965f-014205e1667c"}
{"func_before":"void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\ttpr = kvm_apic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\tsizeof(u32));\n}","target":0,"flaw_line_index":0,"hash":"745bfe30-351e-4af1-93a9-46b1331e364d","idx":"38628c6a-3f04-41df-a593-916465d2099f"}
{"func_before":"static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\t\/* Throw away the key data *\/\n\t\tif (key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tsecurity_key_free(key);\n\n\t\t\/* deal with the user's key tracking and quota *\/\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);","target":1,"flaw_line_index":0,"hash":"b6346fe4-0642-43ce-8dd2-a24d4b69966a","idx":"a6bee813-02f0-4a31-acc9-57c6d46b1996"}
{"func_before":"static noinline void key_gc_unused_keys(struct list_head *keys)\n{\n\twhile (!list_empty(keys)) {\n\t\tstruct key *key =\n\t\t\tlist_entry(keys->next, struct key, graveyard_link);\n\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\t\/* Throw away the key data if the key is instantiated *\/\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n\t\t    key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tsecurity_key_free(key);\n\n\t\t\/* deal with the user's key tracking and quota *\/\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);","target":0,"flaw_line_index":0,"hash":"45079774-fed6-4e5a-920c-afa78b43b6f1","idx":"cf58c04f-096a-4fdf-8911-bbb622b84c51"}
{"func_before":"\tvirtual ~CxFile() { };","target":1,"flaw_line_index":0,"hash":"677078f2-7268-4e51-9ab8-f0422da916e5","idx":"46f39e9a-01d8-48e8-b093-c9762380a097"}
{"func_before":"\tvirtual ~CxFile() { }","target":0,"flaw_line_index":0,"hash":"a63e863a-4329-4f82-a909-1feecdc04b8c","idx":"89797ba7-5bf9-40c0-b0ce-8b7c311ef550"}
{"func_before":"  ** ends in '\/' it is an error. *\/\n  if( bIsDir==0 ){\n    if( zName[nName-1]=='\/' ){\n      zErr = sqlite3_mprintf(\"non-directory name must not end with \/\");\n      rc = SQLITE_ERROR;\n      goto zipfile_step_out;\n    }\n  }else{\n    if( zName[nName-1]!='\/' ){\n      zName = zFree = sqlite3_mprintf(\"%s\/\", zName);\n      nName++;\n      if( zName==0 ){\n        rc = SQLITE_NOMEM;\n        goto zipfile_step_out;\n      }\n    }else{\n      while( nName>1 && zName[nName-2]=='\/' ) nName--;\n    }\n  }\n\n  \/* Assemble the ZipfileEntry object for the new zip archive entry *\/\n  e.cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;\n  e.cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;\n  e.cds.flags = ZIPFILE_NEWENTRY_FLAGS;\n  e.cds.iCompression = (u16)iMethod;","target":1,"flaw_line_index":0,"hash":"05b17dee-5973-4de6-a42f-ed902d3f363b","idx":"e7b6f479-2162-49d4-bf2a-2b148701e1b9"}
{"func_before":"  ** at the end of the path. Or, if this is not a directory and the path\n  ** ends in '\/' it is an error. *\/\n  if( bIsDir==0 ){\n    if( zName[nName-1]=='\/' ){\n      zErr = sqlite3_mprintf(\"non-directory name must not end with \/\");\n      rc = SQLITE_ERROR;\n      goto zipfile_step_out;\n    }\n  }else{\n    if( zName[nName-1]!='\/' ){\n      zName = zFree = sqlite3_mprintf(\"%s\/\", zName);\n      if( zName==0 ){\n        rc = SQLITE_NOMEM;\n        goto zipfile_step_out;\n      }\n      nName = (int)strlen(zName);\n    }else{\n      while( nName>1 && zName[nName-2]=='\/' ) nName--;\n    }\n  }\n\n  \/* Assemble the ZipfileEntry object for the new zip archive entry *\/\n  e.cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;\n  e.cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;\n  e.cds.flags = ZIPFILE_NEWENTRY_FLAGS;\n  e.cds.iCompression = (u16)iMethod;","target":0,"flaw_line_index":0,"hash":"4a7e296f-00cb-428b-842e-c8eb5bb5d459","idx":"e6be13e0-1cd0-470a-ad03-45867d44ccb8"}
{"func_before":"write_link_file(const NetplanNetDefinition* def, const char* rootdir, const char* path)\n{\n    GString* s = NULL;\n    mode_t orig_umask;\n\n    \/* Don't write .link files for virtual devices; they use .netdev instead.\n     * Don't write .link files for MODEM devices, as they aren't supported by networkd.\n     *\/\n    if (def->type >= NETPLAN_DEF_TYPE_VIRTUAL || def->type == NETPLAN_DEF_TYPE_MODEM)\n        return;\n\n    \/* do we need to write a .link file? *\/\n    if (!def->set_name &&\n        !def->wake_on_lan &&\n        (def->generic_segmentation_offload ? \"true\" : \"false\"));\n\n    if (def->generic_receive_offload != NETPLAN_TRISTATE_UNSET)\n        g_string_append_printf(s, \"GenericReceiveOffload=%s\\n\",\n        (def->generic_receive_offload ? \"true\" : \"false\"));\n\n    if (def->large_receive_offload != NETPLAN_TRISTATE_UNSET)\n        g_string_append_printf(s, \"LargeReceiveOffload=%s\\n\",\n        (def->large_receive_offload ? \"true\" : \"false\"));\n\n    orig_umask = umask(022);\n    _netplan_g_string_free_to_file(s, rootdir, path, \".link\");\n    umask(orig_umask);\n}","target":1,"flaw_line_index":0,"hash":"4014b7cb-054e-4371-8504-127d728d55cc","idx":"983c0d61-eb57-4f23-99c7-bde89df46b09"}
{"func_before":"write_link_file(const NetplanNetDefinition* def, const char* rootdir, const char* path)\n{\n    GString* s = NULL;\n\n    \/* Don't write .link files for virtual devices; they use .netdev instead.\n     * Don't write .link files for MODEM devices, as they aren't supported by networkd.\n     *\/\n    if (def->type >= NETPLAN_DEF_TYPE_VIRTUAL || def->type == NETPLAN_DEF_TYPE_MODEM)\n        return;\n\n    \/* do we need to write a .link file? *\/\n    if (!def->set_name &&\n        !def->wake_on_lan &&\n        (def->generic_segmentation_offload ? \"true\" : \"false\"));\n\n    if (def->generic_receive_offload != NETPLAN_TRISTATE_UNSET)\n        g_string_append_printf(s, \"GenericReceiveOffload=%s\\n\",\n        (def->generic_receive_offload ? \"true\" : \"false\"));\n\n    if (def->large_receive_offload != NETPLAN_TRISTATE_UNSET)\n        g_string_append_printf(s, \"LargeReceiveOffload=%s\\n\",\n        (def->large_receive_offload ? \"true\" : \"false\"));\n\n    _netplan_g_string_free_to_file_with_permissions(s, rootdir, path, \".link\", \"root\", \"root\", 0640);\n}","target":0,"flaw_line_index":0,"hash":"97515b6b-4073-406a-8460-d6d63a9a7862","idx":"e055dd87-633e-4a1b-8752-8ce567459ccd"}
{"func_before":"static void parse_generic_line(pj_scanner *scanner, pj_str_t *str,\n\t\t\t       volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINSDP;\n\n    \/* check equal sign *\/\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    \/* x= *\/\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    \/* get anything until newline (including whitespaces). *\/\n    pj_scan_get_until_chr(scanner, \"\\r\\n\", str);\n","target":1,"flaw_line_index":0,"hash":"4a6ae62b-bcea-4a77-a815-792381725824","idx":"3cc9a11d-24a2-4a59-994f-afd1741e4c9f"}
{"func_before":"static void parse_generic_line(pj_scanner *scanner, pj_str_t *str,\n\t\t\t       volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINSDP;\n\n    \/* check equal sign *\/\n    if ((scanner->curptr+1 >= scanner->end) || *(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    \/* x= *\/\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    \/* get anything until newline (including whitespaces). *\/\n    pj_scan_get_until_chr(scanner, \"\\r\\n\", str);\n","target":0,"flaw_line_index":0,"hash":"10273ffa-a2c5-40de-91fb-8256a9f2f5ae","idx":"2da52459-7b0f-4c83-9eed-a0092ee7ac33"}
{"func_before":"\t\txfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd;\n\t\tif ( xfr_cmd[0] == '\\0' ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** command disabled ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tfname = read_filename();\n\t\tif (fname == NULL) {\n\t\t\tfd_printf(STO, \"*** cannot read filename ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\trun_cmd(tty_fd, xfr_cmd, fname, NULL);\n\t\tfree(fname);\n\t\tbreak;\n\tcase KEY_BREAK:\n\t\tterm_break(tty_fd);\n\t\tfd_printf(STO, \"\\r\\n*** break sent ***\\r\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n","target":1,"flaw_line_index":0,"hash":"1b4e6e83-cfb8-4d7d-a7be-595f594c897c","idx":"b0237994-eb32-47c6-bbbb-fb408e5cb82a"}
{"func_before":"\t\txfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd;\n\t\tif ( xfr_cmd[0] == '\\0' ) {\n\t\t\tfd_printf(STO, \"\\r\\n*** command disabled ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tfname = read_filename();\n\t\tif (fname == NULL) {\n\t\t\tfd_printf(STO, \"*** cannot read filename ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\trun_cmd(tty_fd, xfr_cmd, fname);\n\t\tfree(fname);\n\t\tbreak;\n\tcase KEY_BREAK:\n\t\tterm_break(tty_fd);\n\t\tfd_printf(STO, \"\\r\\n*** break sent ***\\r\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n","target":0,"flaw_line_index":0,"hash":"b57e6ab8-1f71-4f81-8293-dac9b0b0cf13","idx":"e4c5d7dc-aed2-40f0-8f5e-29107aa74175"}
{"func_before":"\taddr_t offset;\n\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\t\/*\n\t\t * psw and gprs are stored on the stack\n\t\t *\/\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask) {\n\t\t\tunsigned long mask = PSW_MASK_USER;\n\n\t\t\tmask |= is_ri_task(child) ? PSW_MASK_RI : 0;\n\t\t\tif ((data & ~mask) != PSW_USER_BITS)\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW_MASK_EA) && !(data & PSW_MASK_BA))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {\n\t\t\/*\n\t\t * access registers are stored in the thread structure\n\t\t *\/\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT","target":1,"flaw_line_index":0,"hash":"a70ec373-901e-4e79-9450-79fa746def5c","idx":"04c8bcc7-d03a-4f64-af9d-b4ef08d873cb"}
{"func_before":"\taddr_t offset;\n\n\tif (addr < (addr_t) &dummy->regs.acrs) {\n\t\t\/*\n\t\t * psw and gprs are stored on the stack\n\t\t *\/\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask) {\n\t\t\tunsigned long mask = PSW_MASK_USER;\n\n\t\t\tmask |= is_ri_task(child) ? PSW_MASK_RI : 0;\n\t\t\tif ((data ^ PSW_USER_BITS) & ~mask)\n\t\t\t\t\/* Invalid psw mask. *\/\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW_MASK_ASC) == PSW_ASC_HOME)\n\t\t\t\t\/* Invalid address-space-control bits *\/\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW_MASK_EA) && !(data & PSW_MASK_BA))\n\t\t\t\t\/* Invalid addressing mode bits *\/\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {\n\t\t\/*\n\t\t * access registers are stored in the thread structure\n\t\t *\/\n\t\toffset = addr - (addr_t) &dummy->regs.acrs;\n#ifdef CONFIG_64BIT","target":0,"flaw_line_index":0,"hash":"e9591945-7059-4a01-836c-735f0bd28ec5","idx":"b6b6b349-e20a-427f-a50e-60cba5d01caf"}
{"func_before":"               tidx = i;\n               break;\n            }\n        }\n    }\n\n    if (src_end - src < 2)\n        return 0;\n    zsize = (src[0] << 8) | src[1]; src += 2;\n\n    if (src_end - src < zsize)\n        return AVERROR_INVALIDDATA;\n\n    ret = uncompress(c->kempf_buf, &dlen, src, zsize);\n    if (ret)\n        return AVERROR_INVALIDDATA;\n    src += zsize;\n\n    if (sub_type == 2) {\n        kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,\n                          NULL, 0, width, height, pal, npal, tidx);\n        return 0;\n    }\n\n    nblocks = *src++ + 1;\n    cblocks = 0;\n    bstride = FFALIGN(width, 16) >> 4;\n    \/\/ blocks are coded LSB and we need normal bitreader for JPEG data\n    bits = 0;\n    for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {\n        for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {\n            if (!bits) {\n                bitbuf = *src++;\n                bits   = 8;\n            }\n            coded = bitbuf & 1;\n            bits--;\n            bitbuf >>= 1;\n            cblocks += coded;\n            if (cblocks > nblocks)\n                return AVERROR_INVALIDDATA;\n            c->kempf_flags[j + i * bstride] = coded;","target":1,"flaw_line_index":0,"hash":"d3d67e97-8132-4dc7-9219-0c6d2b1c4ced","idx":"ccc9b2c5-e2ea-4a9e-ad39-ff851ce8b5fe"}
{"func_before":"               tidx = i;\n               break;\n            }\n        }\n    }\n\n    if (src_end - src < 2)\n        return 0;\n    zsize = (src[0] << 8) | src[1]; src += 2;\n\n    if (src_end - src < zsize + (sub_type != 2))\n        return AVERROR_INVALIDDATA;\n\n    ret = uncompress(c->kempf_buf, &dlen, src, zsize);\n    if (ret)\n        return AVERROR_INVALIDDATA;\n    src += zsize;\n\n    if (sub_type == 2) {\n        kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,\n                          NULL, 0, width, height, pal, npal, tidx);\n    }\n\n    nblocks = *src++ + 1;\n    cblocks = 0;\n    bstride = FFALIGN(width, 16) >> 4;\n    \/\/ blocks are coded LSB and we need normal bitreader for JPEG data\n    bits = 0;\n    for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {\n        for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {\n            if (!bits) {\n                if (src >= src_end)\n                    return AVERROR_INVALIDDATA;\n                bitbuf = *src++;\n                bits   = 8;\n            }\n            coded = bitbuf & 1;\n            bits--;\n            bitbuf >>= 1;\n            cblocks += coded;\n            if (cblocks > nblocks)\n                return AVERROR_INVALIDDATA;\n            c->kempf_flags[j + i * bstride] = coded;","target":0,"flaw_line_index":0,"hash":"323753a7-fa27-4c4b-b57f-1efca49fc2a1","idx":"74ce10e2-c74c-475b-86c1-7aa47cc64261"}
{"func_before":"parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n    int *err, gchar **err_info)\n{\n\tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n\tchar\tline[TOSHIBA_LINE_LENGTH];\n\tint\tnum_items_scanned;\n\tint\tpkt_len, pktnum, hr, min, sec, csec;\n\tchar\tchannel[10], direction[10];\n\tint\ti, hex_lines;\n\tguint8\t*pd;\n\n\t\/* Our file pointer should be on the line containing the\n\t * summary information for a packet. Read in that line and\n\t * extract the useful information\n\t *\/\n\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t*err = file_error(fh, err_info);\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t\/* Check for \"OFFSET 0001-0203\" at beginning of line *\/\n\t\tline[16] = '\\0';\n\n\t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n\n\tnum_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);\n\tif (num_items_scanned != 1) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n\t\treturn FALSE;\n\t}\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\tphdr->ts.secs = hr * 3600 + min * 60 + sec;\n\tphdr->ts.nsecs = csec * 10000000;\n\tphdr->caplen = pkt_len;\n\tphdr->len = pkt_len;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\t\t\/* XXX - is there an FCS in the frame? *\/\n\t\t\tpseudo_header->eth.fcs_len = -1;\n\t\t\tbreak;\n\t}\n\n\t\/* Make sure we have enough room for the packet *\/\n\tws_buffer_assure_space(buf, TOSHIBA_MAX_PACKET_LEN);\n\tpd = ws_buffer_start_ptr(buf);\n\n\t\/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data *\/\n\thex_lines = pkt_len \/ 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {","target":1,"flaw_line_index":0,"hash":"968c03d7-9a7f-40f7-9301-7e54311b2b61","idx":"102a3566-8efd-4d2a-8bf3-26914b43d844"}
{"func_before":"parse_toshiba_packet(FILE_T fh, struct wtap_pkthdr *phdr, Buffer *buf,\n    int *err, gchar **err_info)\n{\n\tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n\tchar\tline[TOSHIBA_LINE_LENGTH];\n\tint\tnum_items_scanned;\n\tguint\tpkt_len;\n\tint\tpktnum, hr, min, sec, csec;\n\tchar\tchannel[10], direction[10];\n\tint\ti, hex_lines;\n\tguint8\t*pd;\n\n\t\/* Our file pointer should be on the line containing the\n\t * summary information for a packet. Read in that line and\n\t * extract the useful information\n\t *\/\n\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t*err = file_error(fh, err_info);\n\t\t\t\t*err = WTAP_ERR_SHORT_READ;\n\t\t\t}\n\t\t\treturn FALSE;\n\t\t}\n\n\t\t\/* Check for \"OFFSET 0001-0203\" at beginning of line *\/\n\t\tline[16] = '\\0';\n\n\t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n\n\tnum_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);\n\tif (num_items_scanned != 1) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n\t\treturn FALSE;\n\t}\n\tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n\t\t\/*\n\t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t *\/\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"toshiba: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n\t\treturn FALSE;\n\t}\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\tphdr->ts.secs = hr * 3600 + min * 60 + sec;\n\tphdr->ts.nsecs = csec * 10000000;\n\tphdr->caplen = pkt_len;\n\tphdr->len = pkt_len;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tphdr->pkt_encap = WTAP_ENCAP_ETHERNET;\n\t\t\t\/* XXX - is there an FCS in the frame? *\/\n\t\t\tpseudo_header->eth.fcs_len = -1;\n\t\t\tbreak;\n\t}\n\n\t\/* Make sure we have enough room for the packet *\/\n\tws_buffer_assure_space(buf, pkt_len);\n\tpd = ws_buffer_start_ptr(buf);\n\n\t\/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data *\/\n\thex_lines = pkt_len \/ 16 + ((pkt_len % 16) ? 1 : 0);\n\n\tfor (i = 0; i < hex_lines; i++) {\n\t\tif (file_gets(line, TOSHIBA_LINE_LENGTH, fh) == NULL) {\n\t\t\t*err = file_error(fh, err_info);\n\t\t\tif (*err == 0) {","target":0,"flaw_line_index":0,"hash":"3f1abb54-75f0-43c2-9aa9-0b125332e169","idx":"698e454b-97f9-4c71-9fe6-ec8eee375852"}
{"func_before":"char *string_crypt(const char *key, const char *salt) {\n  assert(key);\n  assert(salt);\n\n  char random_salt[12];\n  if (!*salt) {\n    memcpy(random_salt,\"$1$\",3);\n    ito64(random_salt+3,rand(),8);\n    random_salt[11] = '\\0';\n    return string_crypt(key, random_salt);\n  }\n\n  if ((strlen(salt) > sizeof(\"$2X$00$\")) &&\n    (salt[0] == '$') &&\n    (salt[1] == '2') &&\n    (salt[2] >= 'a') && (salt[2] <= 'z') &&\n    (salt[3] == '$') &&\n    (salt[4] >= '0') && (salt[4] <= '3') &&\n    (salt[5] >= '0') && (salt[5] <= '9') &&\n    (salt[6] == '$')) {\n    \/\/ Bundled blowfish crypt()\n    char output[61];\n    if (php_crypt_blowfish_rn(key, salt, output, sizeof(output))) {\n      return strdup(output);\n    }\n\n  } else {\n    \/\/ System crypt() function\n#ifdef USE_PHP_CRYPT_R\n    return php_crypt_r(key, salt);\n#else\n    static Mutex mutex;\n    Lock lock(mutex);","target":1,"flaw_line_index":0,"hash":"e6f22e03-2f84-49e5-a62a-f090b5c0c763","idx":"632c2975-fba4-4a0d-a9cf-c4b8ba3357f8"}
{"func_before":"char *string_crypt(const char *key, const char *salt) {\n  assertx(key);\n  assertx(salt);\n\n  char random_salt[12];\n  if (!*salt) {\n    memcpy(random_salt,\"$1$\",3);\n    ito64(random_salt+3,rand(),8);\n    random_salt[11] = '\\0';\n    return string_crypt(key, random_salt);\n  }\n\n  auto const saltLen = strlen(salt);\n  if ((saltLen > sizeof(\"$2X$00$\")) &&\n    (salt[0] == '$') &&\n    (salt[1] == '2') &&\n    (salt[2] >= 'a') && (salt[2] <= 'z') &&\n    (salt[3] == '$') &&\n    (salt[4] >= '0') && (salt[4] <= '3') &&\n    (salt[5] >= '0') && (salt[5] <= '9') &&\n    (salt[6] == '$')) {\n    \/\/ Bundled blowfish crypt()\n    char output[61];\n\n    static constexpr size_t maxSaltLength = 123;\n    char paddedSalt[maxSaltLength + 1];\n    paddedSalt[0] = paddedSalt[maxSaltLength] = '\\0';\n\n    memset(&paddedSalt[1], '$', maxSaltLength - 1);\n    memcpy(paddedSalt, salt, std::min(maxSaltLength, saltLen));\n    paddedSalt[saltLen] = '\\0';\n\n    if (php_crypt_blowfish_rn(key, paddedSalt, output, sizeof(output))) {\n      return strdup(output);\n    }\n\n  } else {\n    \/\/ System crypt() function\n#ifdef USE_PHP_CRYPT_R\n    return php_crypt_r(key, salt);\n#else\n    static Mutex mutex;\n    Lock lock(mutex);","target":0,"flaw_line_index":0,"hash":"a989f941-6965-4d88-81b6-5a350e09f41b","idx":"830187e3-3b4d-43c9-8bbf-bc8cfa76f7df"}
{"func_before":"void gdImageCopyResized (gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int dstW, int dstH, int srcW, int srcH)\n{\n\tint c;\n\tint x, y;\n\tint tox, toy;\n\tint ydest;\n\tint i;\n\tint colorMap[gdMaxColors];\n\t\/* Stretch vectors *\/\n\tint *stx, *sty;\n\t\n\tif (overflow2(sizeof(int), srcW)) {\n\t\treturn;\n\t}\n\tif (overflow2(sizeof(int), srcH)) {\n\t\treturn;\n\t}\n\n\tstx = (int *) gdMalloc (sizeof (int) * srcW);\n\tsty = (int *) gdMalloc (sizeof (int) * srcH);\n","target":1,"flaw_line_index":0,"hash":"cda4812e-12e2-4da3-b751-9176361bbb04","idx":"78710069-45b5-4021-88fc-4e48984ad5f5"}
{"func_before":"void gdImageCopyResized (gdImagePtr dst, gdImagePtr src, int dstX, int dstY, int srcX, int srcY, int dstW, int dstH, int srcW, int srcH)\n{\n\tint c;\n\tint x, y;\n\tint tox, toy;\n\tint ydest;\n\tint i;\n\tint colorMap[gdMaxColors];\n\t\/* Stretch vectors *\/\n\tint *stx, *sty;\n\n\tif (overflow2(sizeof(int), srcW)) {\n\t\treturn;\n\t}\n\tif (overflow2(sizeof(int), srcH)) {\n\t\treturn;\n\t}\n\n\tstx = (int *) gdMalloc (sizeof (int) * srcW);\n\tsty = (int *) gdMalloc (sizeof (int) * srcH);\n","target":0,"flaw_line_index":0,"hash":"ca4781ea-846e-49e9-bde9-8ee7bf68f81b","idx":"3759fd94-3da8-49d7-9ed9-a6c32024e74e"}
{"func_before":"         * report success to client, but return\n         * SLAPI_BIND_FAIL so we don't\n         * authorize based on noauth credentials\n         *\/\n        slapi_send_ldap_result(pb, LDAP_SUCCESS, NULL, NULL, 0, NULL);\n        return (SLAPI_BIND_FAIL);\n    }\n\n    ec = dse_get_entry_copy(pdse, sdn, DSE_USE_LOCK);\n    if (ec == NULL) {\n        slapi_send_ldap_result(pb, LDAP_NO_SUCH_OBJECT, NULL, NULL, 0, NULL);\n        return (SLAPI_BIND_FAIL);\n    }\n\n    switch (method) {\n    case LDAP_AUTH_SIMPLE: {\n        Slapi_Value cv;\n        if (slapi_entry_attr_find(ec, \"userpassword\", &attr) != 0) {\n            slapi_send_ldap_result(pb, LDAP_INAPPROPRIATE_AUTH, NULL, NULL, 0, NULL);\n            slapi_entry_free(ec);\n            return SLAPI_BIND_FAIL;\n        }\n        bvals = attr_get_present_values(attr);\n\n        slapi_value_init_berval(&cv, cred);\n        if (slapi_pw_find_sv(bvals, &cv) != 0) {\n            slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n            slapi_entry_free(ec);\n            value_done(&cv);\n            return SLAPI_BIND_FAIL;\n        }\n        value_done(&cv);\n    } break;\n\n    default:\n        slapi_send_ldap_result(pb, LDAP_STRONG_AUTH_NOT_SUPPORTED, NULL, \"auth method not supported\", 0, NULL);","target":1,"flaw_line_index":0,"hash":"b633b253-613d-4844-b94c-429d2e08875f","idx":"4abee568-8d61-49ea-9a0c-e5e88a7f668f"}
{"func_before":"         * report success to client, but return\n         * SLAPI_BIND_FAIL so we don't\n         * authorize based on noauth credentials\n         *\/\n        slapi_send_ldap_result(pb, LDAP_SUCCESS, NULL, NULL, 0, NULL);\n        return (SLAPI_BIND_FAIL);\n    }\n\n    ec = dse_get_entry_copy(pdse, sdn, DSE_USE_LOCK);\n    if (ec == NULL) {\n        slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Entry does not exist\");\n        slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n        return (SLAPI_BIND_FAIL);\n    }\n\n    switch (method) {\n    case LDAP_AUTH_SIMPLE: {\n        Slapi_Value cv;\n        if (slapi_entry_attr_find(ec, \"userpassword\", &attr) != 0) {\n            slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Entry does not have userpassword set\");\n            slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n            slapi_entry_free(ec);\n            return SLAPI_BIND_FAIL;\n        }\n        bvals = attr_get_present_values(attr);\n\n        slapi_value_init_berval(&cv, cred);\n        if (slapi_pw_find_sv(bvals, &cv) != 0) {\n            slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Invalid credentials\");\n            slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n            slapi_entry_free(ec);\n            value_done(&cv);\n            return SLAPI_BIND_FAIL;\n        }\n        value_done(&cv);\n    } break;\n\n    default:\n        slapi_send_ldap_result(pb, LDAP_STRONG_AUTH_NOT_SUPPORTED, NULL, \"auth method not supported\", 0, NULL);","target":0,"flaw_line_index":0,"hash":"4d6c9a05-8f45-4ad4-b706-12a5bba7f9be","idx":"0134e605-3987-403a-82df-0af483b9240e"}
{"func_before":"ex_function(exarg_T *eap)\n{\n    (void)define_function(eap, NULL);\n}","target":1,"flaw_line_index":0,"hash":"26c7fec0-f9e5-4d5e-b5ad-b97a65c858f0","idx":"19473279-9f8f-4106-a2d4-70166e45022b"}
{"func_before":"ex_function(exarg_T *eap)\n{\n    char_u *line_to_free = NULL;\n\n    (void)define_function(eap, NULL, &line_to_free);\n    vim_free(line_to_free);\n}","target":0,"flaw_line_index":0,"hash":"d6e4d311-3264-480a-aff0-c2b0d6a9fad4","idx":"2d935e84-87a8-41b6-884c-97c79a1444e2"}
{"func_before":"void ed_mul_sim_lot(ed_t r, const ed_t p[], const bn_t k[], int n) {\n\tint i, j, l, *_l = RLC_ALLOCA(int, n);\n\ted_t *_p = RLC_ALLOCA(ed_t, n);\n\tint8_t *naf = NULL;\n\n\tRLC_TRY {\n\t\tl = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tl = RLC_MAX(l, bn_bits(k[i]) + 1);\n\t\t}\n\t\tnaf = RLC_ALLOCA(int8_t, n * l);\n\t\tif (naf == NULL || _p == NULL || _l == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}","target":1,"flaw_line_index":0,"hash":"215e9599-a456-4c1e-9be6-3242fb125008","idx":"662879bc-229f-4020-aa05-b66d65baeb34"}
{"func_before":"void ed_mul_sim_lot(ed_t r, const ed_t p[], const bn_t k[], int n) {\n\tint i, j;\n\tint8_t *naf = NULL;\n\ted_t *_p = RLC_ALLOCA(ed_t, n);\n\tsize_t l, *_l = RLC_ALLOCA(size_t, n);\n\n\tRLC_TRY {\n\t\tl = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tl = RLC_MAX(l, bn_bits(k[i]) + 1);\n\t\t}\n\t\tnaf = RLC_ALLOCA(int8_t, n * l);\n\t\tif (naf == NULL || _p == NULL || _l == NULL) {\n\t\t\tRLC_THROW(ERR_NO_MEMORY);\n\t\t}","target":0,"flaw_line_index":0,"hash":"0dc2c0b9-5553-4a4b-ad5f-f257e313489f","idx":"dab790e4-47d9-4f63-825e-128313e306bf"}
{"func_before":"static void ext4_free_io_end(ext4_io_end_t *io)\n{\n\tBUG_ON(!io);\n\tiput(io->inode);\n\tkfree(io);\n}","target":1,"flaw_line_index":0,"hash":"81a3d8f2-c4cd-4fdc-be9a-b7187945a3eb","idx":"f7d39a7b-3032-4226-8638-2ae176d9b619"}
{"func_before":"static void ext4_free_io_end(ext4_io_end_t *io)\n{\n\tBUG_ON(!io);\n\tif (io->page)\n\t\tput_page(io->page);\n\tiput(io->inode);\n\tkfree(io);\n}","target":0,"flaw_line_index":0,"hash":"7f8699c3-20b6-402b-87d0-1500453b2f33","idx":"b047a2a3-59d6-4e00-a1cd-821f682f91b8"}
{"func_before":"\t\tradlog_request(L_AUTH, 0, request, \"[%s]: invalid shell [%s]\",\n\t\t       name, pwd->pw_shell);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n#endif \/* OSFC2 *\/\n\n#if defined(HAVE_GETSPNAM) && !defined(M_UNIX)\n\t\/*\n\t *      Check if password has expired.\n\t *\/\n\tif (spwd && spwd->sp_expire > 0 &&\n\t    (request->timestamp \/ 86400) > spwd->sp_expire) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: password has expired\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n#if defined(__FreeBSD__) || defined(bsdi) || defined(_PWF_EXPIRE)\n\t\/*\n\t *\tCheck if password has expired.\n\t *\/\n\tif ((pwd->pw_expire > 0) &&\n\t    (request->timestamp > pwd->pw_expire)) {","target":1,"flaw_line_index":0,"hash":"db342f41-4d2d-41a6-a22d-2951db9fc315","idx":"784995de-d704-4ad3-968c-ef56a718a810"}
{"func_before":"\t\t       name, pwd->pw_shell);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n#endif \/* OSFC2 *\/\n\n#if defined(HAVE_GETSPNAM) && !defined(M_UNIX)\n\t\/*\n\t *      Check if password has expired.\n\t *\/\n\tif (spwd && spwd->sp_lstchg > 0 && spwd->sp_max >= 0 &&\n\t    (request->timestamp \/ 86400) > (spwd->sp_lstchg + spwd->sp_max)) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: password has expired\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n\t\/*\n\t *      Check if account has expired.\n\t *\/\n\tif (spwd && spwd->sp_expire > 0 &&\n\t    (request->timestamp \/ 86400) > spwd->sp_expire) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: account has expired\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n#if defined(__FreeBSD__) || defined(bsdi) || defined(_PWF_EXPIRE)\n\t\/*\n\t *\tCheck if password has expired.\n\t *\/\n\tif ((pwd->pw_expire > 0) &&\n\t    (request->timestamp > pwd->pw_expire)) {","target":0,"flaw_line_index":0,"hash":"0156c994-851a-4e17-9a4b-1d92d808c3ae","idx":"a609da6c-e974-401a-956e-decdfaa455ff"}
{"func_before":"    \/\/ we want to \"parse in place\" as much as possible, which allows us to\n    \/\/ forward an unmodified request without having to rebuild it.\n\n    const char *cm = command;\n    size_t cl = 0;\n    \/\/ min command length is 2, plus the \"\\r\\n\"\n    if (cmdlen < 4) {\n        return -1;\n    }\n\n    const char *s = memchr(command, ' ', cmdlen-2);\n    if (s != NULL) {\n        cl = s - command;\n    } else {\n        cl = cmdlen - 2;\n    }\n    pr->keytoken = 0;\n    pr->has_space = false;\n    pr->parsed = cl + 1;\n    pr->request = command;\n    pr->reqlen = cmdlen;\n    int token_max = PARSER_MAX_TOKENS;\n\n    int cmd = -1;\n    int type = CMD_TYPE_GENERIC;\n    int ret = 0;\n\n    switch (cl) {\n        case 0:","target":1,"flaw_line_index":0,"hash":"5ec0633d-e8c5-494b-b735-e93a37517b3c","idx":"0eda76ff-e367-4920-a094-a9907c18e794"}
{"func_before":"    \/\/ we want to \"parse in place\" as much as possible, which allows us to\n    \/\/ forward an unmodified request without having to rebuild it.\n\n    const char *cm = command;\n    size_t cl = 0;\n    \/\/ min command length is 2, plus the \"\\r\\n\"\n    if (cmdlen < 4) {\n        return -1;\n    }\n\n    \/\/ Commands can end with bare '\\n's. Depressingly I intended to be strict\n    \/\/ with a \\r\\n requirement but never did this and need backcompat.\n    \/\/ In this case we _know_ \\n is at cmdlen because we can't enter this\n    \/\/ function otherwise.\n    if (cm[cmdlen-2] == '\\r') {\n        pr->endlen = cmdlen - 2;\n    } else {\n        pr->endlen = cmdlen - 1;\n    }\n\n    const char *s = memchr(command, ' ', pr->endlen);\n    if (s != NULL) {\n        cl = s - command;\n    } else {\n        cl = pr->endlen;\n    }\n    pr->keytoken = 0;\n    pr->has_space = false;\n    pr->parsed = cl;\n    pr->request = command;\n    pr->reqlen = cmdlen;\n    int token_max = PARSER_MAX_TOKENS;\n\n    int cmd = -1;\n    int type = CMD_TYPE_GENERIC;\n    int ret = 0;\n\n    switch (cl) {\n        case 0:","target":0,"flaw_line_index":0,"hash":"628db4c4-6d13-4015-ba8e-9bb733eca9c5","idx":"3f74756e-66c8-48ec-bf5f-66c0f017e909"}
{"func_before":"ast2obj_alias(void* _o)\n{\n    alias_ty o = (alias_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    result = PyType_GenericNew(alias_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_identifier(o->name);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_identifier(o->asname);","target":1,"flaw_line_index":0,"hash":"6e8fabe0-66c6-4836-9d65-59b2bdb1a211","idx":"c20e810a-6431-4ac2-8100-b0faa5a79999"}
{"func_before":"ast2obj_alias(void* _o)\n{\n    alias_ty o = (alias_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_RETURN_NONE;\n    }\n\n    result = PyType_GenericNew(alias_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_identifier(o->name);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_name, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_identifier(o->asname);","target":0,"flaw_line_index":0,"hash":"3fdb8d29-b4bc-4654-994d-c1ce5e8df3a9","idx":"59b5bbae-938a-43cc-befc-0a173c011d77"}
{"func_before":"static pj_status_t ssl_flush_wbio(dtls_srtp *ds, unsigned idx)\n{\n    pj_size_t len;\n    pj_status_t status = PJ_SUCCESS;\n\n    pj_lock_acquire(ds->ossl_lock);\n\n    if (!ds->ossl_wbio[idx]) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_EGONE;\n    }\n\n    \/* Check whether there is data to send *\/\n    if (BIO_ctrl_pending(ds->ossl_wbio[idx]) > 0) {\n        \/* Yes, get and send it *\/\n        len = BIO_read(ds->ossl_wbio[idx], ds->buf[idx], sizeof(ds->buf));\n        if (len > 0) {\n            pj_lock_release(ds->ossl_lock);\n\n            status = send_raw(ds, idx, ds->buf[idx], len);\n            if (status != PJ_SUCCESS) {\n#if DTLS_DEBUG\n                pj_perror(2, ds->base.name, status, \"Send error\");\n#endif\n                \/* This error should be recoverable, remote will retransmit\n                 * its packet when not receiving from us.\n                 *\/\n            }\n            pj_lock_acquire(ds->ossl_lock);\n        }\n    }\n\n    if (!ds->ossl_ssl[idx]) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_EGONE;\n    }\n\n    \/* Just return if handshake completion procedure (key parsing, fingerprint\n     * verification, etc) has been done or handshake is still in progress.\n     *\/\n    if (ds->nego_completed[idx] || !SSL_is_init_finished(ds->ossl_ssl[idx])) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_SUCCESS;\n    }\n\n    \/* Yes, SSL handshake is done! *\/\n    ds->nego_completed[idx] = PJ_TRUE;\n    PJ_LOG(2,(ds->base.name, \"DTLS-SRTP negotiation for %s completed!\",\n                             CHANNEL_TO_STRING(idx)));\n\n    pj_lock_release(ds->ossl_lock);\n\n    \/* Stop the retransmission clock. Note that the clock may not be stopped\n     * if this function is called from clock thread context. We'll try again\n     * later in socket context.\n     *\/\n    if (ds->clock[idx])\n        pjmedia_clock_stop(ds->clock[idx]);\n\n    \/* Get SRTP key material *\/\n    status = ssl_get_srtp_material(ds, idx);","target":1,"flaw_line_index":0,"hash":"77f54831-9ea6-4ccb-8629-ca040d9a61d2","idx":"050054ca-08fb-4023-bd38-fbde8b81e6ca"}
{"func_before":"static pj_status_t ssl_flush_wbio(dtls_srtp *ds, unsigned idx)\n{\n    pj_size_t len;\n    pj_status_t status = PJ_SUCCESS;\n\n    DTLS_LOCK(ds);\n\n    if (!ds->ossl_wbio[idx]) {\n        DTLS_UNLOCK(ds);\n        return PJ_EGONE;\n    }\n\n    \/* Check whether there is data to send *\/\n    if (BIO_ctrl_pending(ds->ossl_wbio[idx]) > 0) {\n        \/* Yes, get and send it *\/\n        len = BIO_read(ds->ossl_wbio[idx], ds->buf[idx], sizeof(ds->buf));\n        if (len > 0) {\n            DTLS_UNLOCK(ds);\n\n            status = send_raw(ds, idx, ds->buf[idx], len);\n            if (status != PJ_SUCCESS) {\n#if DTLS_DEBUG\n                pj_perror(2, ds->base.name, status, \"Send error\");\n#endif\n                \/* This error should be recoverable, remote will retransmit\n                 * its packet when not receiving from us.\n                 *\/\n            }\n            DTLS_LOCK(ds);\n        }\n    }\n\n    if (!ds->ossl_ssl[idx]) {\n        DTLS_UNLOCK(ds);\n        return PJ_EGONE;\n    }\n\n    \/* Just return if handshake completion procedure (key parsing, fingerprint\n     * verification, etc) has been done or handshake is still in progress.\n     *\/\n    if (ds->nego_completed[idx] || !SSL_is_init_finished(ds->ossl_ssl[idx])) {\n        DTLS_UNLOCK(ds);\n        return PJ_SUCCESS;\n    }\n\n    \/* Yes, SSL handshake is done! *\/\n    ds->nego_completed[idx] = PJ_TRUE;\n    PJ_LOG(2,(ds->base.name, \"DTLS-SRTP negotiation for %s completed!\",\n                             CHANNEL_TO_STRING(idx)));\n\n    DTLS_UNLOCK(ds);\n\n    \/* Stop the retransmission clock. Note that the clock may not be stopped\n     * if this function is called from clock thread context. We'll try again\n     * later in socket context.\n     *\/\n    if (ds->clock[idx])\n        pjmedia_clock_stop(ds->clock[idx]);\n\n    \/* Get SRTP key material *\/\n    status = ssl_get_srtp_material(ds, idx);","target":0,"flaw_line_index":0,"hash":"382cfe1f-fcd5-4b53-8383-2ddddd1b4ac9","idx":"40f1c82d-3166-4ba7-800a-c4a78b709b2b"}
{"func_before":"header_put_be_int (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} \/* header_put_be_int *\/","target":1,"flaw_line_index":0,"hash":"2b11f221-b384-4b1f-90bf-1cf6f5ef0201","idx":"dd3431cc-baf8-45cd-baea-7de9569ca3b5"}
{"func_before":"header_put_be_int (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = x ;\n} \/* header_put_be_int *\/","target":0,"flaw_line_index":0,"hash":"973d3c7c-dffa-4e85-9431-d09090275ec9","idx":"371bf656-ade2-488c-88b4-25298d2e2420"}
{"func_before":"\t\t       size_t len, int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (addr_len)\n\t\t*addr_len = sizeof(*sin);\n\n\tif (flags & MSG_ERRQUEUE) {\n\t\terr = ip_recv_error(sk, msg, len);\n\t\tgoto out;\n\t}\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\tif (err)\n\t\tgoto done;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t\/* Copy the address. *\/\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tsin->sin_port = 0;\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t}\n\tif (inet->cmsg_flags)\n\t\tip_cmsg_recv(msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;","target":1,"flaw_line_index":0,"hash":"7b44caf4-f2aa-4669-b293-272d7dcb0084","idx":"d1538631-3dbf-4814-89cb-e2fdd1889e39"}
{"func_before":"static int raw_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\t       size_t len, int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (flags & MSG_ERRQUEUE) {\n\t\terr = ip_recv_error(sk, msg, len);\n\t\tgoto out;\n\t}\n\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\n\t\tgoto done;\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\t\/* Copy the address. *\/\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tsin->sin_port = 0;\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\t}\n\tif (inet->cmsg_flags)\n\t\tip_cmsg_recv(msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;","target":0,"flaw_line_index":0,"hash":"f65b56fd-96fe-4ffd-8505-2a090b047a22","idx":"1965f22c-7742-4e48-935d-9b8b2e002f13"}
{"func_before":"int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tu16 offset = sizeof(struct ipv6hdr);\n\tstruct ipv6_opt_hdr *exthdr =\n\t\t\t\t(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\n\twhile (offset + 1 <= packet_len) {\n\n\t\tswitch (**nexthdr) {\n\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\n\t\toffset += ipv6_optlen(exthdr);\n\t\t*nexthdr = &exthdr->nexthdr;\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t}\n\n\treturn offset;\n}","target":1,"flaw_line_index":0,"hash":"43393027-c261-4a51-b22b-d3fd90910bbb","idx":"495a0392-d0db-47f0-913d-43b5d7136068"}
{"func_before":"int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tu16 offset = sizeof(struct ipv6hdr);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\n\twhile (offset <= packet_len) {\n\t\tstruct ipv6_opt_hdr *exthdr;\n\n\t\tswitch (**nexthdr) {\n\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\tcase NEXTHDR_ROUTING:\n\t\t\tfound_rhdr = 1;\n\t\t\tbreak;\n\t\tcase NEXTHDR_DEST:\n#if IS_ENABLED(CONFIG_IPV6_MIP6)\n\t\t\tif (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)\n\t\t\t\tbreak;\n#endif\n\t\t\tif (found_rhdr)\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\n\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n\t\t\treturn -EINVAL;\n\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t\toffset += ipv6_optlen(exthdr);\n\t\t*nexthdr = &exthdr->nexthdr;\n\t}\n\n\treturn -EINVAL;\n}","target":0,"flaw_line_index":0,"hash":"7a44a373-a04b-4d1c-b264-96de46043136","idx":"bdbb1c08-13d1-44c3-8698-4f5e00652451"}
{"func_before":"          << device_src.opaque() << \", size=\" << size\n          << \", host_dst=\" << host_dst << \")\" << StackTraceIfVLOG10();\n\n  tsl::Status result;\n  SCOPED_TRACE(TraceListener::SynchronousMemcpyD2H, &result, device_src, size,\n               host_dst);\n\n  result = implementation_->SynchronousMemcpy(host_dst, device_src, size);\n  if (!result.ok()) {\n    result = tsl::Status(\n        port::error::INTERNAL,\n        absl::StrFormat(\"failed to synchronously memcpy device-to-host: device \"\n                        \"%p to host %p size %d: %s\",\n                        device_src.opaque(), host_dst, size,\n                        result.ToString()));\n  }\n\n  return result;\n}","target":1,"flaw_line_index":0,"hash":"76b3687c-905e-45bf-863e-984e35d0d000","idx":"8eb46eb9-ab23-4084-a23e-3c4180f34c80"}
{"func_before":"          << device_src.opaque() << \", size=\" << size\n          << \", host_dst=\" << host_dst << \")\" << StackTraceIfVLOG10();\n\n  tsl::Status result;\n  SCOPED_TRACE(TraceListener::SynchronousMemcpyD2H, &result, device_src, size,\n               host_dst);\n\n  result = implementation_->SynchronousMemcpy(host_dst, device_src, size);\n  if (!result.ok()) {\n    result = tsl::Status(\n        tsl::error::INTERNAL,\n        absl::StrFormat(\"failed to synchronously memcpy device-to-host: device \"\n                        \"%p to host %p size %d: %s\",\n                        device_src.opaque(), host_dst, size,\n                        result.ToString()));\n  }\n\n  return result;\n}","target":0,"flaw_line_index":0,"hash":"cf493efa-019a-49c2-8307-c82cd03ee894","idx":"673e842a-b617-4bab-83af-0635900d3ce5"}
{"func_before":"void fp24_exp_dig(fp24_t c, const fp24_t a, dig_t b) {\n\tbn_t _b;\n\tfp24_t t, v;\n\tint8_t u, naf[RLC_DIG + 1];\n\tint l;\n\n\tif (b == 0) {\n\t\tfp24_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(_b);\n\tfp24_null(t);\n\tfp24_null(v);\n","target":1,"flaw_line_index":0,"hash":"8d0694e5-6213-40e2-9035-f456a1477a36","idx":"7767875f-3a09-42ff-b79e-139b87a71c0f"}
{"func_before":"void fp24_exp_dig(fp24_t c, const fp24_t a, dig_t b) {\n\tbn_t _b;\n\tfp24_t t, v;\n\tint8_t u, naf[RLC_DIG + 1];\n\tsize_t l;\n\n\tif (b == 0) {\n\t\tfp24_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tbn_null(_b);\n\tfp24_null(t);\n\tfp24_null(v);\n","target":0,"flaw_line_index":0,"hash":"58b4668c-e22f-47b7-9bd1-f65936c4df12","idx":"9075971b-8b1f-40c5-bea6-657dc10c58f9"}
{"func_before":"static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tint err;\n\n\terr = crypto_ahash_export(req, state);\n\tif (err)\n\t\treturn err;\n\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = 1;\n\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\n\treturn err;\n}","target":1,"flaw_line_index":0,"hash":"07cff35f-f534-49d7-889a-3d7e090ab726","idx":"601c54d6-b249-47d6-9a7a-4e465cfac6e1"}
{"func_before":"static int hash_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tbool more;\n\tint err;\n\n\tlock_sock(sk);\n\tmore = ctx->more;\n\terr = more ? crypto_ahash_export(req, state) : 0;\n\trelease_sock(sk);\n\n\tif (err)\n\t\treturn err;\n\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = more;\n\n\tif (!more)\n\t\treturn err;\n\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);\n\t}\n\n\treturn err;\n}","target":0,"flaw_line_index":0,"hash":"a65b9c00-74c7-4e7d-a992-bbc3f982d452","idx":"b7e9f9c9-5ea4-4415-9ee8-496caae584e6"}
{"func_before":"static CURLcode ossl_connect_step1(struct Curl_easy *data,\n                                   struct connectdata *conn, int sockindex)\n{\n  CURLcode result = CURLE_OK;\n  char *ciphers;\n  SSL_METHOD_QUAL SSL_METHOD *req_method = NULL;\n  X509_LOOKUP *lookup = NULL;\n  curl_socket_t sockfd = conn->sock[sockindex];\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  ctx_option_t ctx_options = 0;\n\n#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n  bool sni;\n  const char * const hostname = SSL_HOST_NAME();\n\n#ifdef ENABLE_IPV6\n  struct in6_addr addr;\n#else\n  struct in_addr addr;\n#endif\n       send the data lowercase and subsequently there are now numerous servers\n       out there that don't work unless the name is lowercased *\/\n    Curl_strntolower(data->state.buffer, hostname, nlen);\n    data->state.buffer[nlen] = 0;\n    if(!SSL_set_tlsext_host_name(backend->handle, data->state.buffer))\n      infof(data, \"WARNING: failed to configure server name indication (SNI) \"\n            \"TLS extension\\n\");\n  }\n#endif\n\n  \/* Check if there's a cached ID we can\/should use here! *\/\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    void *ssl_sessionid = NULL;\n    int data_idx = ossl_get_ssl_data_index();\n    int connectdata_idx = ossl_get_ssl_conn_index();\n    int sockindex_idx = ossl_get_ssl_sockindex_index();\n    int proxy_idx = ossl_get_proxy_index();\n\n    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&\n       proxy_idx >= 0) {\n      \/* Store the data needed for the \"new session\" callback.\n       * The sockindex is stored as a pointer to an array element. *\/\n      SSL_set_ex_data(backend->handle, data_idx, data);\n      SSL_set_ex_data(backend->handle, connectdata_idx, conn);\n      SSL_set_ex_data(backend->handle, sockindex_idx, conn->sock + sockindex);\n#ifndef CURL_DISABLE_PROXY\n      SSL_set_ex_data(backend->handle, proxy_idx, SSL_IS_PROXY() ? (void *) 1:\n                      NULL);\n#else\n      SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n#endif\n\n    }\n\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn, SSL_IS_PROXY() ? TRUE : FALSE,\n                              &ssl_sessionid, NULL, sockindex)) {\n      \/* we got a session id, use it! *\/\n      if(!SSL_set_session(backend->handle, ssl_sessionid)) {\n        Curl_ssl_sessionid_unlock(data);\n        failf(data, \"SSL: SSL_set_session failed: %s\",\n              ossl_strerror(ERR_get_error(), error_buffer,\n                            sizeof(error_buffer)));\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      \/* Informational message *\/\n      infof(data, \"SSL re-using session ID\\n\");\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n#ifndef CURL_DISABLE_PROXY\n  if(conn->proxy_ssl[sockindex].use) {\n    BIO *const bio = BIO_new(BIO_f_ssl());\n    SSL *handle = conn->proxy_ssl[sockindex].backend->handle;\n    DEBUGASSERT(ssl_connection_complete == conn->proxy_ssl[sockindex].state);\n    DEBUGASSERT(handle != NULL);\n    DEBUGASSERT(bio != NULL);\n    BIO_set_ssl(bio, handle, FALSE);\n    SSL_set_bio(backend->handle, bio, bio);","target":1,"flaw_line_index":0,"hash":"5fd79c5e-437d-43f5-87b6-03284291c434","idx":"37c020db-86f0-4855-bb4b-878de97e49aa"}
{"func_before":"static CURLcode ossl_connect_step1(struct Curl_easy *data,\n                                   struct connectdata *conn, int sockindex)\n{\n  CURLcode result = CURLE_OK;\n  char *ciphers;\n  SSL_METHOD_QUAL SSL_METHOD *req_method = NULL;\n  X509_LOOKUP *lookup = NULL;\n  curl_socket_t sockfd = conn->sock[sockindex];\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  ctx_option_t ctx_options = 0;\n  void *ssl_sessionid = NULL;\n\n#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n  bool sni;\n  const char * const hostname = SSL_HOST_NAME();\n\n#ifdef ENABLE_IPV6\n  struct in6_addr addr;\n#else\n  struct in_addr addr;\n#endif\n       send the data lowercase and subsequently there are now numerous servers\n       out there that don't work unless the name is lowercased *\/\n    Curl_strntolower(data->state.buffer, hostname, nlen);\n    data->state.buffer[nlen] = 0;\n    if(!SSL_set_tlsext_host_name(backend->handle, data->state.buffer))\n      infof(data, \"WARNING: failed to configure server name indication (SNI) \"\n            \"TLS extension\\n\");\n  }\n#endif\n\n  ossl_associate_connection(data, conn, sockindex);\n\n  Curl_ssl_sessionid_lock(data);\n  if(!Curl_ssl_getsessionid(data, conn, SSL_IS_PROXY() ? TRUE : FALSE,\n                            &ssl_sessionid, NULL, sockindex)) {\n    \/* we got a session id, use it! *\/\n    if(!SSL_set_session(backend->handle, ssl_sessionid)) {\n      Curl_ssl_sessionid_unlock(data);\n      failf(data, \"SSL: SSL_set_session failed: %s\",\n            ossl_strerror(ERR_get_error(), error_buffer,\n                          sizeof(error_buffer)));\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    \/* Informational message *\/\n    infof(data, \"SSL re-using session ID\\n\");\n  }\n  Curl_ssl_sessionid_unlock(data);\n\n#ifndef CURL_DISABLE_PROXY\n  if(conn->proxy_ssl[sockindex].use) {\n    BIO *const bio = BIO_new(BIO_f_ssl());\n    SSL *handle = conn->proxy_ssl[sockindex].backend->handle;\n    DEBUGASSERT(ssl_connection_complete == conn->proxy_ssl[sockindex].state);\n    DEBUGASSERT(handle != NULL);\n    DEBUGASSERT(bio != NULL);\n    BIO_set_ssl(bio, handle, FALSE);\n    SSL_set_bio(backend->handle, bio, bio);","target":0,"flaw_line_index":0,"hash":"57725c1b-72ae-408e-aaed-b74e549a73c6","idx":"821fe4b5-81a5-401d-8503-ec24e18af7e1"}
{"func_before":"R_API bool r_socket_connect(RSocket *s, const char *host, const char *port, int proto, unsigned int timeout) {\n\tr_return_val_if_fail (s, false);\n#if __WINDOWS__\n\tstruct sockaddr_in sa;\n\tstruct hostent *he;\n\tWSADATA wsadata;\n\tTIMEVAL Timeout;\n\tTimeout.tv_sec = timeout;\n\tTimeout.tv_usec = 0;\n\n\tif (WSAStartup (MAKEWORD (1, 1), &wsadata) == SOCKET_ERROR) {\n\t\teprintf (\"Error creating socket.\");\n\t\treturn false;\n\t}\n\ts->fd = socket (AF_INET, SOCK_STREAM, 0);\n\tif (s->fd == R_INVALID_SOCKET) {\n\t\treturn false;\n\t}\n\n\tunsigned long iMode = 1;\n\tint iResult = ioctlsocket (s->fd, FIONBIO, &iMode);\n\tif (iResult != NO_ERROR) {\n\t\teprintf (\"ioctlsocket error: %d\\n\", iResult);\n\t}\n\tmemset (&sa, 0, sizeof (sa));\n\tsa.sin_family = AF_INET;\n\the = (struct hostent *)gethostbyname (host);\n\tif (he == (struct hostent*)0) {\n#ifdef _MSC_VER\n\t\tclosesocket (s->fd);\n#else\n\t\tclose (s->fd);\n#endif\n\t\treturn false;\n\t}\n\tsa.sin_addr = *((struct in_addr *)he->h_addr);\n\ts->port = r_socket_port_by_name (port);\n\ts->proto = proto;\n\tsa.sin_port = htons (s->port);\n\tif (!connect (s->fd, (const struct sockaddr*)&sa, sizeof (struct sockaddr))) {\n#ifdef _MSC_VER\n\t\tclosesocket (s->fd);\n#else\n\t\tclose (s->fd);\n#endif\n\t\treturn false;\n\t}\n\tiMode = 0;\n\tiResult = ioctlsocket (s->fd, FIONBIO, &iMode);\n\tif (iResult != NO_ERROR) {\n\t\teprintf (\"ioctlsocket error: %d\\n\", iResult);\n\t}\n\tif (timeout > 0) {\n\t\tr_socket_block_time (s, 1, timeout, 0);\n\t}\n\tfd_set Write, Err;\n\tFD_ZERO (&Write);\n\tFD_ZERO (&Err);\n\tFD_SET (s->fd, &Write);\n\tFD_SET (s->fd, &Err);\n\tselect (0, NULL, &Write, &Err, &Timeout);\n\tif (FD_ISSET (s->fd, &Write)) {\n\t\treturn true;\n\t}\n\treturn false;\n#elif __UNIX__\n\tint ret;\n\tstruct addrinfo hints = {0};\n\tstruct addrinfo *res, *rp;\n\tif (!proto) {\n\t\tproto = R_SOCKET_PROTO_TCP;\n\t}\n\tr_sys_signal (SIGPIPE, SIG_IGN);\n\tif (proto == R_SOCKET_PROTO_UNIX) {\n\t\tif (!__connect_unix (s, host)) {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\thints.ai_family = AF_UNSPEC; \/* Allow IPv4 or IPv6 *\/\n\t\thints.ai_protocol = proto;\n\t\tint gai = getaddrinfo (host, port, &hints, &res);\n\t\tif (gai != 0) {\n\t\t\teprintf (\"r_socket_connect: Error in getaddrinfo: %s (%s:%s)\\n\",\n\t\t\t\tgai_strerror (gai), host, port);\n\t\t\treturn false;\n\t\t}\n\t\tfor (rp = res; rp != NULL; rp = rp->ai_next) {\n\t\t\t}\n\n\t\t\tr_socket_block_time (s, 0, 0, 0);\n\t\t\tret = connect (s->fd, rp->ai_addr, rp->ai_addrlen);\n\n\t\t\tif (ret == 0) {\n\t\t\t\tfreeaddrinfo (res);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (errno == EINPROGRESS) {\n\t\t\t\tstruct timeval tv;\n\t\t\t\ttv.tv_sec = timeout;\n\t\t\t\ttv.tv_usec = 0;\n\t\t\t\tfd_set wfds;\n\t\t\t\tFD_ZERO(&wfds);\n\t\t\t\tFD_SET(s->fd, &wfds);\n\n\t\t\t\tif ((ret = select (s->fd + 1, NULL, &wfds, NULL, &tv)) != -1) {\n\t\t\t\t\tif (r_socket_is_connected (s)) {\n\t\t\t\t\t\tfreeaddrinfo (res);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tperror (\"connect\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_socket_close (s);\n\t\t}\n\t\tfreeaddrinfo (res);\n\t\tif (!rp) {\n\t\t\teprintf (\"Could not resolve address '%s' or failed to connect\\n\", host);\n\t\t\treturn false;\n\t\t}\n\t}\n#endif\n#if HAVE_LIB_SSL\n\tif (s->is_ssl) {\n\t\ts->ctx = SSL_CTX_new (SSLv23_client_method ());\n\t\tif (!s->ctx) {\n\t\t\tr_socket_free (s);\n\t\t\treturn false;\n\t\t}\n\t\ts->sfd = SSL_new (s->ctx);\n\t\tSSL_set_fd (s->sfd, s->fd);\n\t\tif (SSL_connect (s->sfd) != 1) {\n\t\t\tr_socket_free (s);\n\t\t\treturn false;\n\t\t}\n\t}\n#endif\n\treturn true;\n}","target":1,"flaw_line_index":0,"hash":"1a7facdd-2033-418e-9374-790ec3cd0265","idx":"b3bb4eaa-9eab-44d6-a3fe-a5fb37aed238"}
{"func_before":"R_API bool r_socket_connect(RSocket *s, const char *host, const char *port, int proto, unsigned int timeout) {\n\tr_return_val_if_fail (s, false);\n#if __WINDOWS__\n#define gai_strerror gai_strerrorA\n\tstruct sockaddr_in sa;\n\tWSADATA wsadata;\n\n\tif (WSAStartup (MAKEWORD (1, 1), &wsadata) == SOCKET_ERROR) {\n\t\teprintf (\"Error creating socket.\");\n\t\treturn false;\n\t}\n#endif\n\tint ret;\n\tstruct addrinfo hints = { 0 };\n\tstruct addrinfo *res, *rp;\n\tif (!proto) {\n\t\tproto = R_SOCKET_PROTO_TCP;\n\t}\n#if __UNIX__\n\tr_sys_signal (SIGPIPE, SIG_IGN);\n#endif\n\tif (proto == R_SOCKET_PROTO_UNIX) {\n#if __UNIX__\n\t\tif (!__connect_unix (s, host)) {\n\t\t\treturn false;\n\t\t}\n#endif\n\t} else {\n\t\thints.ai_family = AF_UNSPEC; \/* Allow IPv4 or IPv6 *\/\n\t\thints.ai_protocol = proto;\n\t\tint gai = getaddrinfo (host, port, &hints, &res);\n\t\tif (gai != 0) {\n\t\t\teprintf (\"r_socket_connect: Error in getaddrinfo: %s (%s:%s)\\n\",\n\t\t\t\tgai_strerror (gai), host, port);\n\t\t\treturn false;\n\t\t}\n\t\tfor (rp = res; rp != NULL; rp = rp->ai_next) {\n\t\t\t}\n\n\t\t\tr_socket_block_time (s, 0, 0, 0);\n\t\t\tret = connect (s->fd, rp->ai_addr, rp->ai_addrlen);\n\n\t\t\tif (ret == 0) {\n\t\t\t\tfreeaddrinfo (res);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (errno == EINPROGRESS) {\n\t\t\t\tstruct timeval tv = {timeout, 0};\n\t\t\t\tfd_set wfds;\n\t\t\t\tFD_ZERO (&wfds);\n\t\t\t\tFD_SET (s->fd, &wfds);\n\n\t\t\t\tif ((ret = select (s->fd + 1, NULL, &wfds, NULL, &tv)) != -1) {\n\t\t\t\t\tif (r_socket_is_connected (s)) {\n\t\t\t\t\t\tfreeaddrinfo (res);\n\t\t\t\t\t\tgoto success;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tperror (\"connect\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_socket_close (s);\n\t\t}\n\t\tfreeaddrinfo (res);\n\t\tif (!rp) {\n\t\t\teprintf (\"Could not resolve address '%s' or failed to connect\\n\", host);\n\t\t\treturn false;\n\t\t}\n\t}\nsuccess:\n#if HAVE_LIB_SSL\n\tif (s->is_ssl) {\n\t\ts->ctx = SSL_CTX_new (SSLv23_client_method ());\n\t\tif (!s->ctx) {\n\t\t\tr_socket_close (s);\n\t\t\treturn false;\n\t\t}\n\t\ts->sfd = SSL_new (s->ctx);\n\t\tSSL_set_fd (s->sfd, s->fd);\n\t\tint ret = SSL_connect (s->sfd);\n\t\tif (ret != 1) {\n\t\t\tint error = SSL_get_error (s->sfd, ret);\n\t\t\tint tries = 10;\n\t\t\twhile (tries && ret && (error == SSL_ERROR_WANT_READ || error == SSL_ERROR_WANT_WRITE)) {\n\t\t\t\tstruct timeval tv = {1, 0};\n\t\t\t\tfd_set rfds, wfds;\n\t\t\t\tFD_ZERO (&rfds);\n\t\t\t\tFD_ZERO (&wfds);\n\t\t\t\tif (error == SSL_ERROR_WANT_READ) {\n\t\t\t\t\tFD_SET (s->fd, &rfds);\n\t\t\t\t} else {\n\t\t\t\t\tFD_SET (s->fd, &wfds);\n\t\t\t\t}\n\t\t\t\tif ((ret = select (s->fd + 1, &rfds, &wfds, NULL, &tv)) < 1) {\n\t\t\t\t\tr_socket_close (s);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tret = SSL_connect (s->sfd);\n\t\t\t\tif (ret == 1) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\terror = SSL_get_error (s->sfd, ret);\n\t\t\t\ttries--;\n\t\t\t}\n\t\t\tr_socket_close (s);\n\t\t\treturn false;\n\t\t}\n\t}\n#endif\n\treturn true;\n}","target":0,"flaw_line_index":0,"hash":"7f0e0b90-505a-459a-ba87-5c09b3c6426a","idx":"f4048244-a5bd-41a4-9031-34af529f820f"}
{"func_before":"\t&& check_changed(curbuf, (p_awa ? CCGD_AW : 0)\n\t\t\t       | (other_file ? 0 : CCGD_MULTWIN)\n\t\t\t       | ((flags & ECMD_FORCEIT) ? CCGD_FORCEIT : 0)\n\t\t\t       | (eap == NULL ? 0 : CCGD_EXCMD)))\n    {\n\tif (fnum == 0 && other_file && ffname != NULL)\n\t    (void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);\n\tgoto theend;\n    }\n\n    \/*\n     * End Visual mode before switching to another buffer, so the text can be\n     * copied into the GUI selection buffer.\n     *\/\n    reset_VIsual();\n\n#if defined(FEAT_EVAL)\n    if ((command != NULL || newlnum > (linenr_T)0)\n\t    && *get_vim_var_str(VV_SWAPCOMMAND) == NUL)\n    {\n\tint\tlen;\n\tchar_u\t*p;\n\n\t\/\/ Set v:swapcommand for the SwapExists autocommands.\n\tif (command != NULL)","target":1,"flaw_line_index":0,"hash":"b0a3328d-ca98-427d-b6ac-a3c8a3e76f44","idx":"be0e1d43-21ac-46ed-81a4-7bbb312d41b4"}
{"func_before":"\t&& check_changed(curbuf, (p_awa ? CCGD_AW : 0)\n\t\t\t       | (other_file ? 0 : CCGD_MULTWIN)\n\t\t\t       | ((flags & ECMD_FORCEIT) ? CCGD_FORCEIT : 0)\n\t\t\t       | (eap == NULL ? 0 : CCGD_EXCMD)))\n    {\n\tif (fnum == 0 && other_file && ffname != NULL)\n\t    (void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);\n\tgoto theend;\n    }\n\n    \n     \/\/ End Visual mode before switching to another buffer, so the text can be\n     \/\/ copied into the GUI selection buffer.\n     \/\/ Careful: may trigger ModeChanged() autocommand\n     \n    \/\/ Should we block autocommands here?\n    reset_VIsual();\n\n    \/\/ autocommands freed window :(\n    if (oldwin != NULL && !win_valid(oldwin))\n\toldwin = NULL;\n\n#if defined(FEAT_EVAL)\n    if ((command != NULL || newlnum > (linenr_T)0)\n\t    && *get_vim_var_str(VV_SWAPCOMMAND) == NUL)\n    {\n\tint\tlen;\n\tchar_u\t*p;\n\n\t\/\/ Set v:swapcommand for the SwapExists autocommands.\n\tif (command != NULL)","target":0,"flaw_line_index":0,"hash":"cde18e13-4f84-4cd3-81f4-f7b628a3bff7","idx":"1d693c82-a6f4-45c7-8f32-c55a49692991"}
{"func_before":"raptor_libxml_getEntity(void* user_data, const xmlChar *name) {\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_getEntity(sax2->xc, name);\n}","target":1,"flaw_line_index":0,"hash":"93b250bc-7d88-400c-b685-32b3705d2d8d","idx":"641103ac-be8e-453f-85a6-f5b2db6b897c"}
{"func_before":"raptor_libxml_getEntity(void* user_data, const xmlChar *name)\n{\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  xmlParserCtxtPtr xc = sax2->xc;\n  xmlEntityPtr ret = NULL;\n\n  if(!xc)\n    return NULL;\n\n  if(!xc->inSubset) {\n    \/* looks for hardcoded set of entity names - lt, gt etc. *\/\n    ret = xmlGetPredefinedEntity(name);\n    if(ret) {\n      RAPTOR_DEBUG2(\"Entity '%s' found in predefined set\\n\", name);\n      return ret;\n    }\n  }\n\n  \/* This section uses xmlGetDocEntity which looks for entities in\n   * memory only, never from a file or URI \n   *\/\n  if(xc->myDoc && (xc->myDoc->standalone == 1)) {\n    RAPTOR_DEBUG2(\"Entity '%s' document is standalone\\n\", name);\n    \/* Document is standalone: no entities are required to interpret doc *\/\n    if(xc->inSubset == 2) {\n      xc->myDoc->standalone = 0;\n      ret = xmlGetDocEntity(xc->myDoc, name);\n      xc->myDoc->standalone = 1;\n    } else {\n      ret = xmlGetDocEntity(xc->myDoc, name);\n      if(!ret) {\n        xc->myDoc->standalone = 0;\n        ret = xmlGetDocEntity(xc->myDoc, name);\n        xc->myDoc->standalone = 1;\n      }\n    }\n  } else {\n    ret = xmlGetDocEntity(xc->myDoc, name);\n  }\n\n  if(ret && !ret->children &&\n    (ret->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {\n    \/* Entity is an external general parsed entity. It may be in a\n     * catalog file, user file or user URI\n     *\/\n    int val = 0;\n    xmlNodePtr children;\n    int load_entity = 0;\n\n    load_entity = RAPTOR_OPTIONS_GET_NUMERIC(sax2, RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES);\n    if(load_entity)\n      load_entity = raptor_sax2_check_load_uri_string(sax2, ret->URI);\n\n    if(!load_entity) {\n      RAPTOR_DEBUG2(\"Not getting entity URI %s by policy\\n\", ret->URI);\n      children = xmlNewText((const xmlChar*)\"\");\n    } else {\n      \/* Disable SAX2 handlers so that the SAX2 events do not all get\n       * sent to callbacks during dealing with the entity parsing.\n       *\/\n      sax2->enabled = 0;\n      val = xmlParseCtxtExternalEntity(xc, ret->URI, ret->ExternalID, &children);\n      sax2->enabled = 1;\n    }\n    \n    if(!val) {\n      xmlAddChildList((xmlNodePtr)ret, children);\n    } else {\n      xc->validate = 0;\n      return NULL;\n    }\n    \n    ret->owner = 1;\n\n    \/* Mark this entity as having been checked - never do this again *\/\n    if(!ret->checked)\n      ret->checked = 1;\n  }\n\n  return ret;\n}","target":0,"flaw_line_index":0,"hash":"ee84d407-46f1-4d8d-814b-68cbfe3a351c","idx":"06a31789-ce7d-4491-876c-335e1254504c"}
{"func_before":"void svhandler_flash_pgm_word(void) {\n  uint32_t dst = _param_1;\n  uint32_t src = _param_2;\n\n  \/\/ Do not allow firmware to erase bootstrap or bootloader sectors.\n  if ((dst >= BSTRP_FLASH_SECT_START) &&\n      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {\n    return;\n  }\n\n  if ((dst >= BLDR_FLASH_SECT_START) &&\n      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {\n    return;\n  }\n\n  \/\/ Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n\n  \/\/ Flash write.\n  flash_program_word(dst, src);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;","target":1,"flaw_line_index":0,"hash":"9122df7d-bc5c-496e-8aef-a6165df97d72","idx":"e5015968-52c4-4de9-b27a-d0afd8fb9cf3"}
{"func_before":"void svhandler_flash_pgm_word(void) {\n  uint32_t dst = _param_1;\n  uint32_t src = _param_2;\n\n  \/\/ Verify requested address range is allowed.\n  if (!allow_svhandler_flash_range(dst, dst + sizeof(uint32_t))) return;\n\n  \/\/ Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n\n  \/\/ Flash write.\n  flash_program_word(dst, src);\n  _param_1 = !!flash_chk_status();\n  _param_2 = 0;\n  _param_3 = 0;","target":0,"flaw_line_index":0,"hash":"91ade525-bbaa-4c54-9e76-0d70c2f9c9ec","idx":"0283556b-8979-4425-adf2-57efd04c8379"}
{"func_before":"                }\n        }\n    for(int i=0; i< S.height*S.width; i++)\n        {\n            imgdata.image[i][0] = lut[imgdata.image[i][0]];\n            imgdata.image[i][1] = lut[imgdata.image[i][1]];\n            imgdata.image[i][2] = lut[imgdata.image[i][2]];\n            imgdata.image[i][3] = lut[imgdata.image[i][3]];\n        }\n\n    C.data_maximum = lut[C.data_maximum];\n    C.maximum = lut[C.maximum];\n    \/\/ no need to adjust the minumum, black is already subtracted\n    free(lut);\n}","target":1,"flaw_line_index":0,"hash":"8ff17c9a-d4b1-4a77-b8c6-45f08cf6713a","idx":"bad710f6-5bea-4253-b2c6-546a1660183a"}
{"func_before":"                }\n        }\n    for(int i=0; i< S.height*S.width; i++)\n        {\n            imgdata.image[i][0] = lut[imgdata.image[i][0]];\n            imgdata.image[i][1] = lut[imgdata.image[i][1]];\n            imgdata.image[i][2] = lut[imgdata.image[i][2]];\n            imgdata.image[i][3] = lut[imgdata.image[i][3]];\n        }\n\n\tif(C.data_maximum <=TBLN)\n\t\tC.data_maximum = lut[C.data_maximum];\n\tif(C.maximum <= TBLN)\n\t\tC.maximum = lut[C.maximum];\n    \/\/ no need to adjust the minumum, black is already subtracted\n    free(lut);\n}","target":0,"flaw_line_index":0,"hash":"ca2242b4-9f30-441b-ab41-7bab17ece2f0","idx":"c251b4b2-d228-4f7f-898e-311f06dfc1b7"}
{"func_before":"ext4_xattr_block_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_entry *entry;\n\tsize_t size;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\n\terror = -ENODATA;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);","target":1,"flaw_line_index":0,"hash":"2e9f2990-5057-466c-b764-f6a9df4de944","idx":"2594b476-9f9e-49e9-8651-25d261d582ac"}
{"func_before":"ext4_xattr_block_get(struct inode *inode, int name_index, const char *name,\n\t\t     void *buffer, size_t buffer_size)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_entry *entry;\n\tsize_t size;\n\tint error;\n\tstruct mb2_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\n\terror = -ENODATA;\n\tif (!EXT4_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tea_idebug(inode, \"reading block %llu\",\n\t\t  (unsigned long long)EXT4_I(inode)->i_file_acl);\n\tbh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);","target":0,"flaw_line_index":0,"hash":"0e0bc64f-3eac-42f2-9673-b321984b62c2","idx":"0d5ede59-566f-4333-9788-c98d4e641c55"}
{"func_before":"\t\t\t\t\ti += 8;\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char *)hdrl_data+i,\"strf\",4)==0)\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n\t\t\t\t\tif(lasttag == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\talBITMAPINFOHEADER bih;\n\n\t\t\t\t\t\tmemcpy(&bih, hdrl_data + i, sizeof(alBITMAPINFOHEADER));\n\t\t\t\t\t\tAVI->bitmap_info_header = (alBITMAPINFOHEADER *)\n\t\t\t\t\t\t                          gf_malloc(str2ulong((unsigned char *)&bih.bi_size));\n\t\t\t\t\t\tif (AVI->bitmap_info_header != NULL)\n\t\t\t\t\t\t\tmemcpy(AVI->bitmap_info_header, hdrl_data + i,\n\t\t\t\t\t\t\t       str2ulong((unsigned char *)&bih.bi_size));\n\n\t\t\t\t\t\tAVI->width  = str2ulong(hdrl_data+i+4);\n\t\t\t\t\t\tAVI->height = str2ulong(hdrl_data+i+8);\n\t\t\t\t\t\tvids_strf_seen = 1;\n\t\t\t\t\t\t\/\/ThOe\n\t\t\t\t\t\tAVI->v_codecf_off = header_offset + i+16;\n\n\t\t\t\t\t\tmemcpy(AVI->compressor2, hdrl_data+i+16, 4);\n\t\t\t\t\t\tAVI->compressor2[4] = 0;\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].a_bits  = str2ushort(hdrl_data+i+14);\n\t\t\t\t\t\t\/\/            auds_strf_seen = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char*)hdrl_data+i,\"indx\",4) == 0) {\n\t\t\t\t\tchar *a;\n\n\t\t\t\t\tif(lasttag == 1) \/\/ V I D E O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*)hdrl_data+i;\n\n\t\t\t\t\t\tAVI->video_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemset(AVI->video_superindex, 0, sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->dwSize = str2ulong((unsigned char *)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->wLongsPerEntry = str2ushort((unsigned char *)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->video_superindex->bIndexSubType = *a;\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->dwChunkId, a, 4);\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t\/\/ 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->video_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->video_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t                                gf_malloc (AVI->video_superindex->wLongsPerEntry * AVI->video_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t\/\/ position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->video_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[avilib] dwChunkId \\\"%c%c%c%c\\\"\\n\", AVI->video_superindex->dwChunkId[0], AVI->video_superindex->dwChunkId[1],\n\t\t\t\t\t\t                                        AVI->video_superindex->dwChunkId[2], AVI->video_superindex->dwChunkId[3]));\n#endif\n\n\t\t\t\t\t\tAVI->is_opendml = 1;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2) \/\/ A U D I O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*) hdrl_data+i;\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->dwSize = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->wLongsPerEntry = str2ushort((unsigned char*)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->dwChunkId, a, 4);\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t\/\/ 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->track[AVI->aptr].audio_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t        gf_malloc (AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry *\n\t\t\t\t\t\t                   AVI->track[AVI->aptr].audio_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t\/\/ position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->track[AVI->aptr].audio_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);","target":1,"flaw_line_index":0,"hash":"4555d0ee-16a9-43ad-8d71-fad75b9b8f22","idx":"2206350d-f2b4-423a-a9db-878793d15d80"}
{"func_before":"\t\t\t\t\ti += 8;\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char *)hdrl_data+i,\"strf\",4)==0)\n\t\t\t\t{\n\t\t\t\t\ti += 8;\n\t\t\t\t\tif(lasttag == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\talBITMAPINFOHEADER bih;\n\n\t\t\t\t\t\tmemcpy(&bih, hdrl_data + i, sizeof(alBITMAPINFOHEADER));\n\t\t\t\t\t\tbih.bi_size = str2ulong((unsigned char *)&bih.bi_size);\n\n\t\t\t\t\t\tif (i + bih.bi_size > hdrl_len) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->bitmap_info_header = (alBITMAPINFOHEADER *) gf_malloc(bih.bi_size);\n\t\t\t\t\t\tif (AVI->bitmap_info_header != NULL)\n\t\t\t\t\t\t\tmemcpy(AVI->bitmap_info_header, hdrl_data + i, bih.bi_size);\n\n\t\t\t\t\t\tAVI->width  = str2ulong(hdrl_data+i+4);\n\t\t\t\t\t\tAVI->height = str2ulong(hdrl_data+i+8);\n\t\t\t\t\t\tvids_strf_seen = 1;\n\t\t\t\t\t\t\/\/ThOe\n\t\t\t\t\t\tAVI->v_codecf_off = header_offset + i+16;\n\n\t\t\t\t\t\tmemcpy(AVI->compressor2, hdrl_data+i+16, 4);\n\t\t\t\t\t\tAVI->compressor2[4] = 0;\n\n\t\t\t\t\t\t\/\/            auds_strf_seen = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(strnicmp((char*)hdrl_data+i,\"indx\",4) == 0) {\n\t\t\t\t\tchar *a;\n\n\t\t\t\t\tif(lasttag == 1) \/\/ V I D E O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*)hdrl_data+i;\n\t\t\t\t\t\tint avail = hdrl_len-i;\n\t\t\t\t\t\tif (avail<32) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->video_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemset(AVI->video_superindex, 0, sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->dwSize = str2ulong((unsigned char *)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->video_superindex->wLongsPerEntry = str2ushort((unsigned char *)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->video_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t\/\/ 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->video_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tavail -= 32;\n\t\t\t\t\t\tif (avail < AVI->video_superindex->nEntriesInUse*16) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->video_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t                                gf_malloc (AVI->video_superindex->wLongsPerEntry * AVI->video_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t\/\/ position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->video_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->video_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\t                                        AVI->video_superindex->dwChunkId[2], AVI->video_superindex->dwChunkId[3]));\n#endif\n\n\t\t\t\t\t\tAVI->is_opendml = 1;\n\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2) \/\/ A U D I O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*) hdrl_data+i;\n\t\t\t\t\t\tint avail = hdrl_len-i;\n\t\t\t\t\t\tif (avail<32) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->dwSize = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->wLongsPerEntry = str2ushort((unsigned char*)a);\n\t\t\t\t\t\ta += 2;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->bIndexSubType = *a;\n\t\t\t\t\t\ta += 1;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\t\/\/ 3 * reserved\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->track[AVI->aptr].audio_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tavail -= 32;\n\t\t\t\t\t\tif (avail < AVI->track[AVI->aptr].audio_superindex->nEntriesInUse*16) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t        gf_malloc (AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry *\n\t\t\t\t\t\t                   AVI->track[AVI->aptr].audio_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t\/\/ position of ix## chunks\n\t\t\t\t\t\tfor (j=0; j<AVI->track[AVI->aptr].audio_superindex->nEntriesInUse; ++j) {\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].qwOffset = str2ullong ((unsigned char*)a);\n\t\t\t\t\t\t\ta += 8;\n\t\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex[j].dwSize = str2ulong ((unsigned char*)a);","target":0,"flaw_line_index":0,"hash":"88e5262e-61e1-4240-a8e4-d31496a9f514","idx":"ab8daa20-ba77-4452-a3c1-1682a11d903b"}
{"func_before":"static void binder_deferred_fd_close(int fd)\n{\n\tstruct binder_task_work_cb *twcb;\n\n\ttwcb = kzalloc(sizeof(*twcb), GFP_KERNEL);\n\tif (!twcb)\n\t\treturn;\n\tinit_task_work(&twcb->twork, binder_do_fd_close);\n\t__close_fd_get_file(fd, &twcb->file);\n\tif (twcb->file)\n\t\ttask_work_add(current, &twcb->twork, TWA_RESUME);\n\telse\n\t\tkfree(twcb);\n}","target":1,"flaw_line_index":0,"hash":"6a3ab0d3-c6ae-47a4-9b06-430b89f7f92b","idx":"05699043-3c27-4beb-af43-02192532e617"}
{"func_before":"static void binder_deferred_fd_close(int fd)\n{\n\tstruct binder_task_work_cb *twcb;\n\n\ttwcb = kzalloc(sizeof(*twcb), GFP_KERNEL);\n\tif (!twcb)\n\t\treturn;\n\tinit_task_work(&twcb->twork, binder_do_fd_close);\n\t__close_fd_get_file(fd, &twcb->file);\n\tif (twcb->file) {\n\t\tfilp_close(twcb->file, current->files);\n\t\ttask_work_add(current, &twcb->twork, TWA_RESUME);\n\t} else {\n\t\tkfree(twcb);\n\t}\n}","target":0,"flaw_line_index":0,"hash":"8087d0be-0e49-406e-b170-35679d03ef8c","idx":"1fd8c8d5-1610-43a4-969e-9c56289935cc"}
{"func_before":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const auto* params = reinterpret_cast<TfLiteBidirectionalSequenceRNNParams*>(\n      node->builtin_data);\n\n  \/\/ Check we have all the inputs and outputs we need.\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 12);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size,\n                    params->merge_outputs ? 1 : 2);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* fw_input_weights =\n      GetInput(context, node, kFwWeightsTensor);\n  const TfLiteTensor* fw_recurrent_weights =\n      GetInput(context, node, kFwRecurrentWeightsTensor);\n  const TfLiteTensor* fw_bias = GetInput(context, node, kFwBiasTensor);\n  const TfLiteTensor* fw_hidden_state =\n      GetInput(context, node, kFwHiddenStateTensor);\n  const TfLiteTensor* bw_input_weights =\n      GetInput(context, node, kBwWeightsTensor);\n  const TfLiteTensor* bw_recurrent_weights =\n      GetInput(context, node, kBwRecurrentWeightsTensor);\n  const TfLiteTensor* bw_bias = GetInput(context, node, kBwBiasTensor);\n  const TfLiteTensor* bw_hidden_state =\n      GetInput(context, node, kBwHiddenStateTensor);\n\n  const TfLiteTensor* aux_input =\n      GetOptionalInputTensor(context, node, kAuxInputTensor);\n  const TfLiteTensor* fw_aux_input_weights =\n      GetOptionalInputTensor(context, node, kFwAuxWeightsTensor);\n  const TfLiteTensor* bw_aux_input_weights =\n      GetOptionalInputTensor(context, node, kBwAuxWeightsTensor);\n\n  const bool aux_inputs_weights_or_none =\n      ((fw_aux_input_weights != nullptr) &&\n    TfLiteIntArrayFree(node->temporaries);\n    if (has_aux_input) {\n      node->temporaries = TfLiteIntArrayCreate(kNumTemporaryTensors);\n    } else {\n      \/\/ No need to create a temporary tensor for the non-existent aux_input.\n      node->temporaries = TfLiteIntArrayCreate(kNumTemporaryTensors - 1);\n    }\n\n    node->temporaries->data[kInputQuantized] =\n        op_data->scratch_tensor_index + kInputQuantized;\n    TfLiteTensor* input_quantized =\n        GetTemporary(context, node, kInputQuantized);\n    input_quantized->type = fw_input_weights->type;\n    input_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {\n      TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                       input_quantized_size));\n    }\n\n    node->temporaries->data[kFwHiddenStateQuantized] =\n        op_data->scratch_tensor_index + kFwHiddenStateQuantized;\n    TfLiteTensor* fw_hidden_state_quantized =\n        GetTemporary(context, node, kFwHiddenStateQuantized);\n    fw_hidden_state_quantized->type = fw_input_weights->type;\n    fw_hidden_state_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(fw_hidden_state_quantized->dims,\n                             fw_hidden_state->dims)) {\n      TfLiteIntArray* fw_hidden_state_quantized_size =\n          TfLiteIntArrayCopy(fw_hidden_state->dims);\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, fw_hidden_state_quantized,\n                                         fw_hidden_state_quantized_size));\n    }\n\n    node->temporaries->data[kBwHiddenStateQuantized] =\n        op_data->scratch_tensor_index + kBwHiddenStateQuantized;\n    TfLiteTensor* bw_hidden_state_quantized =\n        GetTemporary(context, node, kBwHiddenStateQuantized);\n    bw_hidden_state_quantized->type = fw_input_weights->type;\n    bw_hidden_state_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(bw_hidden_state_quantized->dims,\n                             bw_hidden_state->dims)) {\n      TfLiteIntArray* bw_hidden_state_quantized_size =\n          TfLiteIntArrayCopy(bw_hidden_state->dims);\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, bw_hidden_state_quantized,\n                                         bw_hidden_state_quantized_size));\n    }\n\n    \/\/ Allocate temporary tensors to store scaling factors of quantization.\n    node->temporaries->data[kScalingFactors] =\n        op_data->scratch_tensor_index + kScalingFactors;\n    TfLiteTensor* scaling_factors =\n        GetTemporary(context, node, kScalingFactors);\n    scaling_factors->type = kTfLiteFloat32;\n    scaling_factors->allocation_type = kTfLiteArenaRw;\n    int scaling_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {\n      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);\n      scaling_factors_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,\n                                                       scaling_factors_size));\n    }\n    node->temporaries->data[kAccumScratch] =\n        op_data->scratch_tensor_index + kAccumScratch;\n    TfLiteTensor* accum_scratch = GetTemporary(context, node, kAccumScratch);\n    accum_scratch->type = kTfLiteInt32;\n    accum_scratch->allocation_type = kTfLiteArenaRw;\n    int accum_scratch_dims[2] = {std::max(fw_num_units, bw_num_units),\n                                 batch_size};\n    if (!TfLiteIntArrayEqualsArray(accum_scratch->dims, 2,\n                                   accum_scratch_dims)) {\n      TfLiteIntArray* accum_scratch_size = TfLiteIntArrayCreate(2);\n      accum_scratch_size->data[0] = accum_scratch_dims[0];\n      accum_scratch_size->data[1] = accum_scratch_dims[1];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, accum_scratch,\n                                                       accum_scratch_size));\n    }\n    node->temporaries->data[kZeroPoints] =\n        op_data->scratch_tensor_index + kZeroPoints;\n    TfLiteTensor* zero_points =\n        GetTemporary(context, node, \/*index=*\/kZeroPoints);\n    zero_points->type = kTfLiteInt32;\n    zero_points->allocation_type = kTfLiteArenaRw;\n    int zero_points_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(zero_points->dims, 1, zero_points_dims)) {\n      TfLiteIntArray* zero_points_size = TfLiteIntArrayCreate(1);\n      zero_points_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, zero_points,\n                                                       zero_points_size));\n    }\n    const int num_row_sums = has_aux_input ? 3 : 2;\n    node->temporaries->data[kFwRowSums] =\n        op_data->scratch_tensor_index + kFwRowSums;\n    TfLiteTensor* fw_row_sums =\n        GetTemporary(context, node, \/*index=*\/kFwRowSums);\n    fw_row_sums->type = kTfLiteInt32;\n    fw_row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int fw_row_sums_dims[2] = {num_row_sums, fw_num_units};\n    if (!TfLiteIntArrayEqualsArray(fw_row_sums->dims, 2, fw_row_sums_dims)) {\n      TfLiteIntArray* fw_row_sums_size = TfLiteIntArrayCreate(2);\n      fw_row_sums_size->data[0] = fw_row_sums_dims[0];\n      fw_row_sums_size->data[1] = fw_row_sums_dims[1];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, fw_row_sums,\n                                                       fw_row_sums_size));\n    }\n    node->temporaries->data[kBwRowSums] =\n        op_data->scratch_tensor_index + kBwRowSums;\n    TfLiteTensor* bw_row_sums = GetTemporary(context, node,\n                                             \/*index=*\/kBwRowSums);\n    bw_row_sums->type = kTfLiteInt32;\n    bw_row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int bw_row_sums_dims[2] = {num_row_sums, bw_num_units};\n    if (!TfLiteIntArrayEqualsArray(bw_row_sums->dims, 2, bw_row_sums_dims)) {\n      TfLiteIntArray* bw_row_sums_size = TfLiteIntArrayCreate(2);\n      bw_row_sums_size->data[0] = bw_row_sums_dims[0];\n      bw_row_sums_size->data[1] = bw_row_sums_dims[1];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, bw_row_sums,\n                                                       bw_row_sums_size));\n    }\n    if (has_aux_input) {\n      node->temporaries->data[kAuxInputQuantized] =\n          op_data->scratch_tensor_index + kAuxInputQuantized;\n      TfLiteTensor* aux_input_quantized =\n          GetTemporary(context, node, kAuxInputQuantized);\n      aux_input_quantized->type = fw_input_weights->type;\n      aux_input_quantized->allocation_type = kTfLiteArenaRw;\n      if (!TfLiteIntArrayEqual(aux_input_quantized->dims, aux_input->dims)) {\n        TfLiteIntArray* aux_input_quantized_size =\n            TfLiteIntArrayCopy(aux_input->dims);\n        TF_LITE_ENSURE_OK(context,\n                          context->ResizeTensor(context, aux_input_quantized,\n                                                aux_input_quantized_size));\n      }\n    }\n  }\n\n  \/\/ Resize outputs.\n  TfLiteTensor* fw_output = GetOutput(context, node, kFwOutputTensor);\n  TfLiteIntArray* fw_output_size_array = TfLiteIntArrayCreate(3);\n  fw_output_size_array->data[0] = (time_major) ? max_time : batch_size;\n  fw_output_size_array->data[1] = (time_major) ? batch_size : max_time;\n  fw_output_size_array->data[2] =\n      params->merge_outputs ? fw_num_units + bw_num_units : fw_num_units;\n  TF_LITE_ENSURE_OK(\n      context, context->ResizeTensor(context, fw_output, fw_output_size_array));\n  if (!params->merge_outputs) {\n    TfLiteTensor* bw_output = GetOutput(context, node, kBwOutputTensor);\n    TfLiteIntArray* bw_output_size_array = TfLiteIntArrayCreate(3);\n    bw_output_size_array->data[0] = batch_size;\n    bw_output_size_array->data[1] = max_time;\n    bw_output_size_array->data[2] = bw_num_units;\n    TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, bw_output,\n                                                     bw_output_size_array));\n  }\n\n  return kTfLiteOk;\n}","target":1,"flaw_line_index":0,"hash":"8ddd119b-315c-489b-ba54-26cb65a51816","idx":"a8faaabf-d8d2-4325-a609-ab9aa5be4039"}
{"func_before":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const auto* params = reinterpret_cast<TfLiteBidirectionalSequenceRNNParams*>(\n      node->builtin_data);\n\n  \/\/ Check we have all the inputs and outputs we need.\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 12);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size,\n                    params->merge_outputs ? 1 : 2);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  const TfLiteTensor* fw_input_weights;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kFwWeightsTensor,\n                                          &fw_input_weights));\n  const TfLiteTensor* fw_recurrent_weights;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kFwRecurrentWeightsTensor,\n                                 &fw_recurrent_weights));\n  const TfLiteTensor* fw_bias;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kFwBiasTensor, &fw_bias));\n  const TfLiteTensor* fw_hidden_state;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kFwHiddenStateTensor,\n                                          &fw_hidden_state));\n  const TfLiteTensor* bw_input_weights;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kBwWeightsTensor,\n                                          &bw_input_weights));\n  const TfLiteTensor* bw_recurrent_weights;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kBwRecurrentWeightsTensor,\n                                 &bw_recurrent_weights));\n  const TfLiteTensor* bw_bias;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kBwBiasTensor, &bw_bias));\n  const TfLiteTensor* bw_hidden_state;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kBwHiddenStateTensor,\n                                          &bw_hidden_state));\n\n  const TfLiteTensor* aux_input =\n      GetOptionalInputTensor(context, node, kAuxInputTensor);\n  const TfLiteTensor* fw_aux_input_weights =\n      GetOptionalInputTensor(context, node, kFwAuxWeightsTensor);\n  const TfLiteTensor* bw_aux_input_weights =\n      GetOptionalInputTensor(context, node, kBwAuxWeightsTensor);\n\n  const bool aux_inputs_weights_or_none =\n      ((fw_aux_input_weights != nullptr) &&\n    TfLiteIntArrayFree(node->temporaries);\n    if (has_aux_input) {\n      node->temporaries = TfLiteIntArrayCreate(kNumTemporaryTensors);\n    } else {\n      \/\/ No need to create a temporary tensor for the non-existent aux_input.\n      node->temporaries = TfLiteIntArrayCreate(kNumTemporaryTensors - 1);\n    }\n\n    node->temporaries->data[kInputQuantized] =\n        op_data->scratch_tensor_index + kInputQuantized;\n    TfLiteTensor* input_quantized;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, kInputQuantized,\n                                                &input_quantized));\n    input_quantized->type = fw_input_weights->type;\n    input_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {\n      TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                       input_quantized_size));\n    }\n\n    node->temporaries->data[kFwHiddenStateQuantized] =\n        op_data->scratch_tensor_index + kFwHiddenStateQuantized;\n    TfLiteTensor* fw_hidden_state_quantized;\n    TF_LITE_ENSURE_OK(context,\n                      GetTemporarySafe(context, node, kFwHiddenStateQuantized,\n                                       &fw_hidden_state_quantized));\n    fw_hidden_state_quantized->type = fw_input_weights->type;\n    fw_hidden_state_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(fw_hidden_state_quantized->dims,\n                             fw_hidden_state->dims)) {\n      TfLiteIntArray* fw_hidden_state_quantized_size =\n          TfLiteIntArrayCopy(fw_hidden_state->dims);\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, fw_hidden_state_quantized,\n                                         fw_hidden_state_quantized_size));\n    }\n\n    node->temporaries->data[kBwHiddenStateQuantized] =\n        op_data->scratch_tensor_index + kBwHiddenStateQuantized;\n    TfLiteTensor* bw_hidden_state_quantized;\n    TF_LITE_ENSURE_OK(context,\n                      GetTemporarySafe(context, node, kBwHiddenStateQuantized,\n                                       &bw_hidden_state_quantized));\n    bw_hidden_state_quantized->type = fw_input_weights->type;\n    bw_hidden_state_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(bw_hidden_state_quantized->dims,\n                             bw_hidden_state->dims)) {\n      TfLiteIntArray* bw_hidden_state_quantized_size =\n          TfLiteIntArrayCopy(bw_hidden_state->dims);\n      TF_LITE_ENSURE_OK(\n          context, context->ResizeTensor(context, bw_hidden_state_quantized,\n                                         bw_hidden_state_quantized_size));\n    }\n\n    \/\/ Allocate temporary tensors to store scaling factors of quantization.\n    node->temporaries->data[kScalingFactors] =\n        op_data->scratch_tensor_index + kScalingFactors;\n    TfLiteTensor* scaling_factors;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, kScalingFactors,\n                                                &scaling_factors));\n    scaling_factors->type = kTfLiteFloat32;\n    scaling_factors->allocation_type = kTfLiteArenaRw;\n    int scaling_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {\n      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);\n      scaling_factors_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,\n                                                       scaling_factors_size));\n    }\n    node->temporaries->data[kAccumScratch] =\n        op_data->scratch_tensor_index + kAccumScratch;\n    TfLiteTensor* accum_scratch;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, kAccumScratch,\n                                                &accum_scratch));\n    accum_scratch->type = kTfLiteInt32;\n    accum_scratch->allocation_type = kTfLiteArenaRw;\n    int accum_scratch_dims[2] = {std::max(fw_num_units, bw_num_units),\n                                 batch_size};\n    if (!TfLiteIntArrayEqualsArray(accum_scratch->dims, 2,\n                                   accum_scratch_dims)) {\n      TfLiteIntArray* accum_scratch_size = TfLiteIntArrayCreate(2);\n      accum_scratch_size->data[0] = accum_scratch_dims[0];\n      accum_scratch_size->data[1] = accum_scratch_dims[1];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, accum_scratch,\n                                                       accum_scratch_size));\n    }\n    node->temporaries->data[kZeroPoints] =\n        op_data->scratch_tensor_index + kZeroPoints;\n    TfLiteTensor* zero_points;\n    TF_LITE_ENSURE_OK(\n        context,\n        GetTemporarySafe(context, node, \/*index=*\/kZeroPoints, &zero_points));\n    zero_points->type = kTfLiteInt32;\n    zero_points->allocation_type = kTfLiteArenaRw;\n    int zero_points_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(zero_points->dims, 1, zero_points_dims)) {\n      TfLiteIntArray* zero_points_size = TfLiteIntArrayCreate(1);\n      zero_points_size->data[0] = batch_size;\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, zero_points,\n                                                       zero_points_size));\n    }\n    const int num_row_sums = has_aux_input ? 3 : 2;\n    node->temporaries->data[kFwRowSums] =\n        op_data->scratch_tensor_index + kFwRowSums;\n    TfLiteTensor* fw_row_sums;\n    TF_LITE_ENSURE_OK(\n        context,\n        GetTemporarySafe(context, node, \/*index=*\/kFwRowSums, &fw_row_sums));\n    fw_row_sums->type = kTfLiteInt32;\n    fw_row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int fw_row_sums_dims[2] = {num_row_sums, fw_num_units};\n    if (!TfLiteIntArrayEqualsArray(fw_row_sums->dims, 2, fw_row_sums_dims)) {\n      TfLiteIntArray* fw_row_sums_size = TfLiteIntArrayCreate(2);\n      fw_row_sums_size->data[0] = fw_row_sums_dims[0];\n      fw_row_sums_size->data[1] = fw_row_sums_dims[1];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, fw_row_sums,\n                                                       fw_row_sums_size));\n    }\n    node->temporaries->data[kBwRowSums] =\n        op_data->scratch_tensor_index + kBwRowSums;\n    TfLiteTensor* bw_row_sums;\n    TF_LITE_ENSURE_OK(\n        context,\n        GetTemporarySafe(context, node, \/*index=*\/kBwRowSums, &bw_row_sums));\n    bw_row_sums->type = kTfLiteInt32;\n    bw_row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int bw_row_sums_dims[2] = {num_row_sums, bw_num_units};\n    if (!TfLiteIntArrayEqualsArray(bw_row_sums->dims, 2, bw_row_sums_dims)) {\n      TfLiteIntArray* bw_row_sums_size = TfLiteIntArrayCreate(2);\n      bw_row_sums_size->data[0] = bw_row_sums_dims[0];\n      bw_row_sums_size->data[1] = bw_row_sums_dims[1];\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, bw_row_sums,\n                                                       bw_row_sums_size));\n    }\n    if (has_aux_input) {\n      node->temporaries->data[kAuxInputQuantized] =\n          op_data->scratch_tensor_index + kAuxInputQuantized;\n      TfLiteTensor* aux_input_quantized;\n      TF_LITE_ENSURE_OK(context,\n                        GetTemporarySafe(context, node, kAuxInputQuantized,\n                                         &aux_input_quantized));\n      aux_input_quantized->type = fw_input_weights->type;\n      aux_input_quantized->allocation_type = kTfLiteArenaRw;\n      if (!TfLiteIntArrayEqual(aux_input_quantized->dims, aux_input->dims)) {\n        TfLiteIntArray* aux_input_quantized_size =\n            TfLiteIntArrayCopy(aux_input->dims);\n        TF_LITE_ENSURE_OK(context,\n                          context->ResizeTensor(context, aux_input_quantized,\n                                                aux_input_quantized_size));\n      }\n    }\n  }\n\n  \/\/ Resize outputs.\n  TfLiteTensor* fw_output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kFwOutputTensor, &fw_output));\n  TfLiteIntArray* fw_output_size_array = TfLiteIntArrayCreate(3);\n  fw_output_size_array->data[0] = (time_major) ? max_time : batch_size;\n  fw_output_size_array->data[1] = (time_major) ? batch_size : max_time;\n  fw_output_size_array->data[2] =\n      params->merge_outputs ? fw_num_units + bw_num_units : fw_num_units;\n  TF_LITE_ENSURE_OK(\n      context, context->ResizeTensor(context, fw_output, fw_output_size_array));\n  if (!params->merge_outputs) {\n    TfLiteTensor* bw_output;\n    TF_LITE_ENSURE_OK(\n        context, GetOutputSafe(context, node, kBwOutputTensor, &bw_output));\n    TfLiteIntArray* bw_output_size_array = TfLiteIntArrayCreate(3);\n    bw_output_size_array->data[0] = batch_size;\n    bw_output_size_array->data[1] = max_time;\n    bw_output_size_array->data[2] = bw_num_units;\n    TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, bw_output,\n                                                     bw_output_size_array));\n  }\n\n  return kTfLiteOk;\n}","target":0,"flaw_line_index":0,"hash":"44e8762f-a6b8-4bb1-8c7b-212b63034c91","idx":"c6749e17-b735-49db-9f88-15901b1806ee"}
{"func_before":"R_API RBinJavaAttrInfo *r_bin_java_read_next_attr_from_buffer(ut8 *buffer, st64 sz, st64 buf_offset) {\n\tRBinJavaAttrInfo *attr = NULL;\n\tchar *name = NULL;\n\tut64 offset = 0;\n\tut16 name_idx;\n\tst64 nsz;\n\tRBinJavaAttrMetas *type_info = NULL;\n\n\tif (!buffer || ((int) sz) < 4 || buf_offset < 0) {\n\t\teprintf (\"r_bin_Java_read_next_attr_from_buffer: invalid buffer size %d\\n\", (int) sz);\n\t\treturn NULL;\n\t}\n\tname_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tnsz = R_BIN_JAVA_UINT (buffer, offset);\n\toffset += 4;\n\tname = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, name_idx);\n\tif (!name) {\n\t\tname = strdup (\"unknown\");\n\t}\n\tIFDBG eprintf(\"r_bin_java_read_next_attr: name_idx = %d is %s\\n\", name_idx, name);\n\ttype_info = r_bin_java_get_attr_type_by_name (name);\n\tif (type_info) {\n\t\tIFDBG eprintf(\"Typeinfo: %s, was %s\\n\", type_info->name, name);\n\t\t\/\/ printf (\"SZ %d %d %d\\n\", nsz, sz, buf_offset);\n\t\tif (nsz > sz) {\n\t\t\tfree (name);\n\t\t\treturn NULL;\n\t\t}\n\t\tif ((attr = type_info->allocs->new_obj (buffer, nsz, buf_offset))) {\n\t\t\tattr->metas->ord = (R_BIN_JAVA_GLOBAL_BIN->attr_idx++);\n\t\t}","target":1,"flaw_line_index":0,"hash":"6bb88ad8-77d5-46fd-a5eb-6040acb4cc7f","idx":"dca4f104-bb43-4128-9bd6-31b3a00a698f"}
{"func_before":"R_API RBinJavaAttrInfo *r_bin_java_read_next_attr_from_buffer(ut8 *buffer, st64 sz, st64 buf_offset) {\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 offset = 0;\n\tut16 name_idx;\n\tst64 nsz;\n\n\tif (!buffer || ((int) sz) < 4 || buf_offset < 0) {\n\t\teprintf (\"r_bin_Java_read_next_attr_from_buffer: invalid buffer size %d\\n\", (int) sz);\n\t\treturn NULL;\n\t}\n\tname_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tnsz = R_BIN_JAVA_UINT (buffer, offset);\n\toffset += 4;\n\n\tchar *name = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, name_idx);\n\tif (!name) {\n\t\tname = strdup (\"unknown\");\n\t}\n\tIFDBG eprintf(\"r_bin_java_read_next_attr: name_idx = %d is %s\\n\", name_idx, name);\n\tRBinJavaAttrMetas *type_info = r_bin_java_get_attr_type_by_name (name);\n\tif (type_info) {\n\t\tIFDBG eprintf(\"Typeinfo: %s, was %s\\n\", type_info->name, name);\n\t\t\/\/ printf (\"SZ %d %d %d\\n\", nsz, sz, buf_offset);\n\t\tif (nsz > sz) {\n\t\t\tfree (name);\n\t\t\treturn NULL;\n\t\t}\n\t\tif ((attr = type_info->allocs->new_obj (buffer, nsz, buf_offset))) {\n\t\t\tattr->metas->ord = (R_BIN_JAVA_GLOBAL_BIN->attr_idx++);\n\t\t}","target":0,"flaw_line_index":0,"hash":"2764a5ba-43a6-4557-b07d-25560cf53541","idx":"a21acc85-def2-4aac-9f6e-02d55b730536"}
{"func_before":"void fp3_write_bin(uint8_t *bin, int len, const fp3_t a) {\n\tif (len != 3 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp_write_bin(bin, RLC_FP_BYTES, a[0]);\n\tfp_write_bin(bin + RLC_FP_BYTES, RLC_FP_BYTES, a[1]);\n\tfp_write_bin(bin + 2 * RLC_FP_BYTES, RLC_FP_BYTES, a[2]);\n}","target":1,"flaw_line_index":0,"hash":"04350828-382b-44ca-b0e0-877d4c2647e6","idx":"bfe7ed44-2b7f-4c6f-b8c5-88369fded193"}
{"func_before":"void fp3_write_bin(uint8_t *bin, size_t len, const fp3_t a) {\n\tif (len != 3 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp_write_bin(bin, RLC_FP_BYTES, a[0]);\n\tfp_write_bin(bin + RLC_FP_BYTES, RLC_FP_BYTES, a[1]);\n\tfp_write_bin(bin + 2 * RLC_FP_BYTES, RLC_FP_BYTES, a[2]);\n}","target":0,"flaw_line_index":0,"hash":"ac482ed6-cfc7-4faa-83ec-e9f45b82e4a1","idx":"8c83ec0d-d505-41d3-9540-5ae8462e96dc"}
{"func_before":"\t    goto end;\n\n\tif (generic_gss_copy_oid(&temp_minor_status, selected_mech,\n\t\t\t\t &union_ctx_id->mech_type) != GSS_S_COMPLETE) {\n\t    free(union_ctx_id);\n\t    goto end;\n\t}\n\n\t\/* copy the supplied context handle *\/\n\tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n    } else\n\tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n\n    \/*\n     * get the appropriate cred handle from the union cred struct.\n     * defaults to GSS_C_NO_CREDENTIAL if there is no cred, which will\n     * use the default credential.\n     *\/\n    union_cred = (gss_union_cred_t) claimant_cred_handle;\n    input_cred_handle = gssint_get_mechanism_cred(union_cred, selected_mech);\n\n    \/*\n\ttime_req,\n\tinput_chan_bindings,\n\tinput_token,\n\tactual_mech_type,\n\toutput_token,\n\tret_flags,\n\ttime_rec);\n\n    if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n\t\/*\n\t * The spec says the preferred method is to delete all context info on\n\t * the first call to init, and on all subsequent calls make the caller\n\t * responsible for calling gss_delete_sec_context.  However, if the\n\t * mechanism decided to delete the internal context, we should also\n\t * delete the union context.\n\t *\/\n\tmap_error(minor_status, mech);\n\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n\t    *context_handle = GSS_C_NO_CONTEXT;\n\tif (*context_handle == GSS_C_NO_CONTEXT) {\n\t    free(union_ctx_id->mech_type->elements);\n\t    free(union_ctx_id->mech_type);\n\t    free(union_ctx_id);\n\t}\n    } else if (*context_handle == GSS_C_NO_CONTEXT) {\n\tunion_ctx_id->loopback = union_ctx_id;\n\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n    }\n","target":1,"flaw_line_index":0,"hash":"5e837f7c-dbd8-4823-87b4-fc82dd585c5d","idx":"b20e0b41-430a-48bd-a0ea-63e5fcdbe4e3"}
{"func_before":"\t    goto end;\n\n\tif (generic_gss_copy_oid(&temp_minor_status, selected_mech,\n\t\t\t\t &union_ctx_id->mech_type) != GSS_S_COMPLETE) {\n\t    free(union_ctx_id);\n\t    goto end;\n\t}\n\n\t\/* copy the supplied context handle *\/\n\tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n    } else {\n\tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n\t    status = GSS_S_NO_CONTEXT;\n\t    goto end;\n\t}\n    }\n\n    \/*\n     * get the appropriate cred handle from the union cred struct.\n     * defaults to GSS_C_NO_CREDENTIAL if there is no cred, which will\n     * use the default credential.\n     *\/\n    union_cred = (gss_union_cred_t) claimant_cred_handle;\n    input_cred_handle = gssint_get_mechanism_cred(union_cred, selected_mech);\n\n    \/*\n\ttime_req,\n\tinput_chan_bindings,\n\tinput_token,\n\tactual_mech_type,\n\toutput_token,\n\tret_flags,\n\ttime_rec);\n\n    if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n\t\/*\n\t * RFC 2744 5.19 requires that we not create a context on a failed\n\t * first call to init, and recommends that on a failed subsequent call\n\t * we make the caller responsible for calling gss_delete_sec_context.\n\t * Even if the mech deleted its context, keep the union context around\n\t * for the caller to delete.\n\t *\/\n\tmap_error(minor_status, mech);\n\tif (*context_handle == GSS_C_NO_CONTEXT) {\n\t    free(union_ctx_id->mech_type->elements);\n\t    free(union_ctx_id->mech_type);\n\t    free(union_ctx_id);\n\t}\n    } else if (*context_handle == GSS_C_NO_CONTEXT) {\n\tunion_ctx_id->loopback = union_ctx_id;\n\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n    }\n","target":0,"flaw_line_index":0,"hash":"15d3e2e0-7452-44bb-9b5d-62c687c5be17","idx":"6f5f2865-45d5-4cf3-a852-4906e63c271d"}
{"func_before":"    g_string_append(s, \"Before=network-pre.target\\n\");\n\n    g_hash_table_iter_init(&iter, pfs);\n    while (g_hash_table_iter_next (&iter, &key, NULL)) {\n        g_string_append_printf(s, \"After=sys-subsystem-net-devices-%s.device\\n\", (gchar*) key);\n    }\n\n    g_string_append(s, \"\\n[Service]\\nType=oneshot\\n\");\n    g_string_append_printf(s, \"ExecStart=\" SBINDIR \"\/netplan apply --sriov-only\\n\");\n\n    _netplan_g_string_free_to_file(s, rootdir, path, NULL);\n\n    _netplan_safe_mkdir_p_dir(link);\n    if (symlink(path, link) < 0 && errno != EEXIST) {\n        \/\/ LCOV_EXCL_START\n        g_set_error(error, G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT,\n                    \"failed to create enablement symlink: %m\");\n        return FALSE;\n        \/\/ LCOV_EXCL_STOP\n    }\n    return TRUE;","target":1,"flaw_line_index":0,"hash":"8964723f-4615-49f1-b5bf-64307e415b0e","idx":"2e184217-e8b2-4a97-ad81-feddeddf5836"}
{"func_before":"    g_string_append(s, \"Before=network-pre.target\\n\");\n\n    g_hash_table_iter_init(&iter, pfs);\n    while (g_hash_table_iter_next (&iter, &key, NULL)) {\n        g_string_append_printf(s, \"After=sys-subsystem-net-devices-%s.device\\n\", (gchar*) key);\n    }\n\n    g_string_append(s, \"\\n[Service]\\nType=oneshot\\n\");\n    g_string_append_printf(s, \"ExecStart=\" SBINDIR \"\/netplan apply --sriov-only\\n\");\n\n    _netplan_g_string_free_to_file_with_permissions(s, rootdir, path, NULL, \"root\", \"root\", 0640);\n\n    _netplan_safe_mkdir_p_dir(link);\n    if (symlink(path, link) < 0 && errno != EEXIST) {\n        \/\/ LCOV_EXCL_START\n        g_set_error(error, G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT,\n                    \"failed to create enablement symlink: %m\");\n        return FALSE;\n        \/\/ LCOV_EXCL_STOP\n    }\n    return TRUE;","target":0,"flaw_line_index":0,"hash":"cb378bb6-f217-44d3-a87e-984a2096f641","idx":"02f3336d-4efe-4a82-a405-a38bcdb5fa23"}
{"func_before":"usm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval = (struct usmStateReference *)\n        calloc(1, sizeof(struct usmStateReference));\n\n    return retval;\n}                               \/* end usm_malloc_usmStateReference() *\/","target":1,"flaw_line_index":0,"hash":"e49ea004-e66a-4196-b2dc-b7a303c96653","idx":"2bc16abc-c5f5-4720-b2ac-2358d97b5299"}
{"func_before":"usm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval;\n\n    retval = calloc(1, sizeof(struct usmStateReference));\n    if (retval)\n        retval->refcnt = 1;\n\n    return retval;\n}                               \/* end usm_malloc_usmStateReference() *\/","target":0,"flaw_line_index":0,"hash":"ba4ab4ca-fd22-47f9-8fe3-8839f8ea6a89","idx":"19619985-826f-4219-815c-a59ddea572d9"}
{"func_before":"IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(\n    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,\n    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {\n  ASSERT(codec_client_ != nullptr);\n  \/\/ Send the request to Envoy.\n  IntegrationStreamDecoderPtr response;\n  if (request_body_size) {\n    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);\n  } else {\n    response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  }\n  waitForNextUpstreamRequest(upstream_index);\n  \/\/ Send response headers, and end_stream if there is no response body.\n  upstream_request_->encodeHeaders(response_headers, response_size == 0);\n  \/\/ Send any response data, with end_stream true.\n  if (response_size) {\n    upstream_request_->encodeData(response_size, true);\n  }\n  \/\/ Wait for the response to be read by the codec client.\n  response->waitForEndStream();\n  return response;\n}","target":1,"flaw_line_index":0,"hash":"4a475f23-87a7-4cb2-a92a-b84a49cccd40","idx":"ffa986e7-b2c0-42e7-8af3-2bb1f06d9489"}
{"func_before":"IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(\n    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,\n    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index,\n    std::chrono::milliseconds time) {\n  ASSERT(codec_client_ != nullptr);\n  \/\/ Send the request to Envoy.\n  IntegrationStreamDecoderPtr response;\n  if (request_body_size) {\n    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);\n  } else {\n    response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  }\n  waitForNextUpstreamRequest(upstream_index, time);\n  \/\/ Send response headers, and end_stream if there is no response body.\n  upstream_request_->encodeHeaders(response_headers, response_size == 0);\n  \/\/ Send any response data, with end_stream true.\n  if (response_size) {\n    upstream_request_->encodeData(response_size, true);\n  }\n  \/\/ Wait for the response to be read by the codec client.\n  response->waitForEndStream();\n  return response;\n}","target":0,"flaw_line_index":0,"hash":"dd03a26c-3b4d-4ac9-af7c-40f0dbf3e04e","idx":"79cf3bfb-9b8a-4c91-838e-efb958c12b2a"}
{"func_before":"\t\t\tif (!nPlugins) \n\t\t\t{\n\t\t\t\tSendMessage(hPlugins, CB_ADDSTRING, 0, (LPARAM) sz_ID_NO_PLUGIN_DETECT);\n\t\t\t\tSendMessage(hPlugins, CB_SETCURSEL, 0, 0);\n\t\t\t}\n\t\t\telse\n\t\t\t\tSendMessage(hPlugins, CB_SELECTSTRING, 0, (LPARAM)_this->m_server->GetDSMPluginName());\n\n\t\t\t\/\/ Modif sf@2002\n\t\t\tSendMessage(GetDlgItem(hwnd, IDC_PLUGIN_CHECK), BM_SETCHECK, _this->m_server->IsDSMPluginEnabled(), 0);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_PLUGIN_BUTTON), _this->m_server->IsDSMPluginEnabled());\n\n\t\t\t\/\/ Query window option - Taken from TightVNC advanced properties \n\t\t\tBOOL queryEnabled = (_this->m_server->QuerySetting() == 4);\n\t\t\tSendMessage(GetDlgItem(hwnd, IDQUERY), BM_SETCHECK, queryEnabled, 0);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDQUERYTIMEOUT), queryEnabled);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_QUERYDISABLETIME), queryEnabled);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_DREFUSE), queryEnabled);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_DACCEPT), queryEnabled);\n\n\t\t\tSetDlgItemText(hwnd, IDC_SERVICE_COMMANDLINE, _this->service_commandline);\n\t\t\t\tif (newconn)\n\t\t\t\t{\n\t\t\t\t\tnewconn->DoDialog(true);\n\t\t\t\t\t\/\/ delete newconn; \/\/ NO ! Already done in vncConnDialog.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\/\/ sf@2002 - DSM Plugin\n\t\tcase IDC_PLUGIN_CHECK:\n\t\t\t{\n\t\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_PLUGIN_BUTTON),\n\t\t\t\t\tSendMessage(GetDlgItem(hwnd, IDC_PLUGIN_CHECK), BM_GETCHECK, 0, 0) == BST_CHECKED);\n\t\t\t}\n\t\t\treturn TRUE;\n\t\t\t\/\/ Marscha@2004 - authSSP: moved MSLogon checkbox back to admin props page\n\t\t\t\/\/ Reason: Different UI for old and new mslogon group config.\n\t\tcase IDC_MSLOGON_CHECKD:\n\t\t\t{\n\t\t\t\tBOOL bMSLogonChecked =\n\t\t\t\t(SendDlgItemMessage(hwnd, IDC_MSLOGON_CHECKD,\n\t\t\t\t\t\t\t\t\t\tBM_GETCHECK, 0, 0) == BST_CHECKED);\n\n\t\t\t{\n\t\t\t\tCheckVideoDriver(1);\n\t\t\t}\n\t\t\treturn TRUE;\n\t\tcase IDC_PLUGIN_BUTTON:\n\t\t\t{\n\t\t\t\tHWND hPlugin = GetDlgItem(hwnd, IDC_PLUGIN_CHECK);\n\t\t\t\tif (SendMessage(hPlugin, BM_GETCHECK, 0, 0) == BST_CHECKED)\n\t\t\t\t{\n\t\t\t\t\tTCHAR szPlugin[MAX_PATH];\n\t\t\t\t\tGetDlgItemText(hwnd, IDC_PLUGINS_COMBO, szPlugin, MAX_PATH);\n\t\t\t\t\tif (!_this->m_server->GetDSMPluginPointer()->IsLoaded())\n\t\t\t\t\t\t_this->m_server->GetDSMPluginPointer()->LoadPlugin(szPlugin, false);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t\/\/ sf@2003 - We check if the loaded plugin is the same than\n\t\t\t\t\t\t\/\/ the currently selected one or not\n\t\t\t\t\t\t_this->m_server->GetDSMPluginPointer()->DescribePlugin();\n\t\t\t\t\t\tif (_stricmp(_this->m_server->GetDSMPluginPointer()->GetPluginFileName(), szPlugin))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_this->m_server->GetDSMPluginPointer()->UnloadPlugin();","target":1,"flaw_line_index":0,"hash":"7e784b62-7744-4e33-8fdd-547016f3219a","idx":"416996e1-4cf6-42d0-b0b8-bdf6e13860cb"}
{"func_before":"\t\t\tif (!nPlugins) \n\t\t\t{\n\t\t\t\tSendMessage(hPlugins, CB_ADDSTRING, 0, (LPARAM) sz_ID_NO_PLUGIN_DETECT);\n\t\t\t\tSendMessage(hPlugins, CB_SETCURSEL, 0, 0);\n\t\t\t}\n\t\t\telse\n\t\t\t\tSendMessage(hPlugins, CB_SELECTSTRING, 0, (LPARAM)_this->m_server->GetDSMPluginName());\n\n\t\t\t\/\/ Modif sf@2002\n\t\t\tSendMessage(GetDlgItem(hwnd, IDC_PLUGIN_CHECK), BM_SETCHECK, _this->m_server->IsDSMPluginEnabled(), 0);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_PLUGIN_BUTTON),  (_this->m_server->AuthClientCount() == 0 ? _this->m_server->IsDSMPluginEnabled(): false));\n\n\t\t\t\/\/ Query window option - Taken from TightVNC advanced properties \n\t\t\tBOOL queryEnabled = (_this->m_server->QuerySetting() == 4);\n\t\t\tSendMessage(GetDlgItem(hwnd, IDQUERY), BM_SETCHECK, queryEnabled, 0);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDQUERYTIMEOUT), queryEnabled);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_QUERYDISABLETIME), queryEnabled);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_DREFUSE), queryEnabled);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_DACCEPT), queryEnabled);\n\n\t\t\tSetDlgItemText(hwnd, IDC_SERVICE_COMMANDLINE, _this->service_commandline);\n\t\t\t\tif (newconn)\n\t\t\t\t{\n\t\t\t\t\tnewconn->DoDialog(true);\n\t\t\t\t\t\/\/ delete newconn; \/\/ NO ! Already done in vncConnDialog.\n\t\t\t\t}\n\t\t\t}\n\n\t\t\/\/ sf@2002 - DSM Plugin\n\t\tcase IDC_PLUGIN_CHECK:\n\t\t\t{\n\t\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_PLUGIN_BUTTON), _this->m_server->AuthClientCount() == 0 \n\t\t\t\t\t\t? SendMessage(GetDlgItem(hwnd, IDC_PLUGIN_CHECK), BM_GETCHECK, 0, 0) == BST_CHECKED \n\t\t\t\t\t\t: BST_UNCHECKED);\n\t\t\t}\n\t\t\treturn TRUE;\n\t\t\t\/\/ Marscha@2004 - authSSP: moved MSLogon checkbox back to admin props page\n\t\t\t\/\/ Reason: Different UI for old and new mslogon group config.\n\t\tcase IDC_MSLOGON_CHECKD:\n\t\t\t{\n\t\t\t\tBOOL bMSLogonChecked =\n\t\t\t\t(SendDlgItemMessage(hwnd, IDC_MSLOGON_CHECKD,\n\t\t\t\t\t\t\t\t\t\tBM_GETCHECK, 0, 0) == BST_CHECKED);\n\n\t\t\t\tCheckVideoDriver(1);\n\t\t\t}\n\t\t\treturn TRUE;\n\t\tcase IDC_PLUGIN_BUTTON:\n\t\t\t{\n\t\t\t\tHWND hPlugin = GetDlgItem(hwnd, IDC_PLUGIN_CHECK);\n\t\t\t\tif (SendMessage(hPlugin, BM_GETCHECK, 0, 0) == BST_CHECKED)\n\t\t\t\t{\n\t\t\t\t\tTCHAR szPlugin[MAX_PATH];\n\t\t\t\t\tGetDlgItemText(hwnd, IDC_PLUGINS_COMBO, szPlugin, MAX_PATH);\n\t\t\t\t\tPathStripPathA(szPlugin);\n\n\t\t\t\t\tif (!_this->m_server->GetDSMPluginPointer()->IsLoaded())\n\t\t\t\t\t\t_this->m_server->GetDSMPluginPointer()->LoadPlugin(szPlugin, false);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t\/\/ sf@2003 - We check if the loaded plugin is the same than\n\t\t\t\t\t\t\/\/ the currently selected one or not\n\t\t\t\t\t\t_this->m_server->GetDSMPluginPointer()->DescribePlugin();\n\t\t\t\t\t\tif (_stricmp(_this->m_server->GetDSMPluginPointer()->GetPluginFileName(), szPlugin))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_this->m_server->GetDSMPluginPointer()->UnloadPlugin();","target":0,"flaw_line_index":0,"hash":"a3fd4c53-6a48-4eeb-8067-187705512c53","idx":"6a234c44-92bc-4f28-a45a-a25d8f706c09"}
{"func_before":"void ZlibInStream::deinit()\n{\n  assert(zs != NULL);\n  removeUnderlying();\n  inflateEnd(zs);\n  delete zs;\n  zs = NULL;\n}","target":1,"flaw_line_index":0,"hash":"63bf1251-46c0-4ade-81df-489fb0976fa8","idx":"38116b31-ef41-47f4-8add-26a3119307d9"}
{"func_before":"void ZlibInStream::deinit()\n{\n  assert(zs != NULL);\n  setUnderlying(NULL, 0);\n  inflateEnd(zs);\n  delete zs;\n  zs = NULL;\n}","target":0,"flaw_line_index":0,"hash":"dd86e2da-9718-4649-95b1-8520011a0640","idx":"bca797c7-1c83-46a7-97f7-22d9297f2197"}
{"func_before":"      rc = imap_cmd_step (idata);\n    while (rc == IMAP_CMD_CONTINUE);\n\n    if (rc != IMAP_CMD_RESPOND)\n    {\n      dprint (1, (debugfile, \"Error receiving server response.\\n\"));\n      gss_release_name (&min_stat, &target_name);\n      goto bail;\n    }\n\n    request_buf.length = mutt_from_base64 (buf2, idata->buf + 2);\n    request_buf.value = buf2;\n    sec_token = &request_buf;\n\n    \/* Write client data *\/\n    maj_stat = gss_init_sec_context (&min_stat, GSS_C_NO_CREDENTIAL, &context,\n      target_name, GSS_C_NO_OID, GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG, 0, \n      GSS_C_NO_CHANNEL_BINDINGS, sec_token, NULL, &send_token,\n      (unsigned int*) &cflags, NULL);\n    if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED)\n    {\n  \/* get security flags and buffer size *\/\n  do\n    rc = imap_cmd_step (idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc != IMAP_CMD_RESPOND)\n  {\n    dprint (1, (debugfile, \"Error receiving server response.\\n\"));\n    goto bail;\n  }\n  request_buf.length = mutt_from_base64 (buf2, idata->buf + 2);\n  request_buf.value = buf2;\n\n  maj_stat = gss_unwrap (&min_stat, context, &request_buf, &send_token,\n    &cflags, &quality);\n  if (maj_stat != GSS_S_COMPLETE)\n  {\n    print_gss_error(maj_stat, min_stat);\n    dprint (2, (debugfile, \"Couldn't unwrap security level data\\n\"));\n    gss_release_buffer (&min_stat, &send_token);\n    goto err_abort_cmd;","target":1,"flaw_line_index":0,"hash":"13b8d763-664c-4f23-9802-744fa4e3169f","idx":"c5adf6a2-c88b-4cd0-bd8f-64cc4f29a72b"}
{"func_before":"      rc = imap_cmd_step (idata);\n    while (rc == IMAP_CMD_CONTINUE);\n\n    if (rc != IMAP_CMD_RESPOND)\n    {\n      dprint (1, (debugfile, \"Error receiving server response.\\n\"));\n      gss_release_name (&min_stat, &target_name);\n      goto bail;\n    }\n\n    request_buf.length = mutt_from_base64 (buf2, idata->buf + 2, sizeof(buf2));\n    request_buf.value = buf2;\n    sec_token = &request_buf;\n\n    \/* Write client data *\/\n    maj_stat = gss_init_sec_context (&min_stat, GSS_C_NO_CREDENTIAL, &context,\n      target_name, GSS_C_NO_OID, GSS_C_MUTUAL_FLAG | GSS_C_SEQUENCE_FLAG, 0, \n      GSS_C_NO_CHANNEL_BINDINGS, sec_token, NULL, &send_token,\n      (unsigned int*) &cflags, NULL);\n    if (maj_stat != GSS_S_COMPLETE && maj_stat != GSS_S_CONTINUE_NEEDED)\n    {\n  \/* get security flags and buffer size *\/\n  do\n    rc = imap_cmd_step (idata);\n  while (rc == IMAP_CMD_CONTINUE);\n\n  if (rc != IMAP_CMD_RESPOND)\n  {\n    dprint (1, (debugfile, \"Error receiving server response.\\n\"));\n    goto bail;\n  }\n  request_buf.length = mutt_from_base64 (buf2, idata->buf + 2, sizeof(buf2));\n  request_buf.value = buf2;\n\n  maj_stat = gss_unwrap (&min_stat, context, &request_buf, &send_token,\n    &cflags, &quality);\n  if (maj_stat != GSS_S_COMPLETE)\n  {\n    print_gss_error(maj_stat, min_stat);\n    dprint (2, (debugfile, \"Couldn't unwrap security level data\\n\"));\n    gss_release_buffer (&min_stat, &send_token);\n    goto err_abort_cmd;","target":0,"flaw_line_index":0,"hash":"534efc59-b71a-4843-ab1a-f291327d1062","idx":"ac4ca7ae-b045-47de-9c40-0912dc4a0e9a"}
{"func_before":"\n\t\/* The following check ensures vaddr is a valid address in the VMA *\/\n\tgts = gru_find_thread_state(vma, TSID(vaddr, vma));\n\tif (!gts)\n\t\treturn VM_FAULT_SIGBUS;\n\nagain:\n\tmutex_lock(&gts->ts_ctxlock);\n\tpreempt_disable();\n\n\tgru_check_context_placement(gts);\n\n\tif (!gts->ts_gru) {\n\t\tSTAT(load_user_context);\n\t\tif (!gru_assign_gru_context(gts)) {\n\t\t\tpreempt_enable();\n\t\t\tmutex_unlock(&gts->ts_ctxlock);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule_timeout(GRU_ASSIGN_DELAY);  \/* true hack ZZZ *\/\n\t\t\texpires = gts->ts_steal_jiffies + GRU_STEAL_DELAY;\n\t\t\tif (time_before(expires, jiffies))","target":1,"flaw_line_index":0,"hash":"db053231-bf8c-45cc-9c5e-196f21f478e1","idx":"8e134772-70d2-4731-a6c2-a7e1b404e719"}
{"func_before":"\n\t\/* The following check ensures vaddr is a valid address in the VMA *\/\n\tgts = gru_find_thread_state(vma, TSID(vaddr, vma));\n\tif (!gts)\n\t\treturn VM_FAULT_SIGBUS;\n\nagain:\n\tmutex_lock(&gts->ts_ctxlock);\n\tpreempt_disable();\n\n\tif (gru_check_context_placement(gts)) {\n\t\tpreempt_enable();\n\t\tmutex_unlock(&gts->ts_ctxlock);\n\t\tgru_unload_context(gts, 1);\n\t\treturn VM_FAULT_NOPAGE;\n\t}\n\n\tif (!gts->ts_gru) {\n\t\tSTAT(load_user_context);\n\t\tif (!gru_assign_gru_context(gts)) {\n\t\t\tpreempt_enable();\n\t\t\tmutex_unlock(&gts->ts_ctxlock);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tschedule_timeout(GRU_ASSIGN_DELAY);  \/* true hack ZZZ *\/\n\t\t\texpires = gts->ts_steal_jiffies + GRU_STEAL_DELAY;\n\t\t\tif (time_before(expires, jiffies))","target":0,"flaw_line_index":0,"hash":"dabff013-d77b-466b-bf8b-e429aed28112","idx":"8f3448e7-188d-4b45-aacc-963a58d02988"}
{"func_before":"    int\t\tcurline,\n    hlf_T\t*attrp)\t\t\/\/ return: attributes of bad word or NULL\n\t\t\t\t\/\/ (only when \"dir\" is FORWARD)\n{\n    linenr_T\tlnum;\n    pos_T\tfound_pos;\n    int\t\tfound_len = 0;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\t*endp;\n    hlf_T\tattr;\n    int\t\tlen;\n#ifdef FEAT_SYN_HL\n    int\t\thas_syntax = syntax_present(wp);\n#endif\n    int\t\tcol;\n    int\t\tcan_spell;\n    char_u\t*buf = NULL;\n    int\t\tbuflen = 0;\n    int\t\tskip = 0;\n    int\t\tcapcol = -1;\n     * bad word (in the cursor line: before the cursor).\n     *\n     * We concatenate the start of the next line, so that wrapped words work\n     * (e.g. \"et<line-break>cetera\").  Doesn't work when searching backwards\n     * though...\n     *\/\n    lnum = wp->w_cursor.lnum;\n    CLEAR_POS(&found_pos);\n\n    while (!got_int)\n    {\n\tline = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\n\tlen = (int)STRLEN(line);\n\tif (buflen < len + MAXWLEN + 2)\n\t{\n\t    vim_free(buf);\n\t    buflen = len + MAXWLEN + 2;\n\t    buf = alloc(buflen);\n\t    if (buf == NULL)\n\t\tbreak;\n\t    col = getwhitecols(line);\n\t    if (check_need_cap(lnum, col))\n\t\tcapcol = col;\n\n\t    \/\/ Need to get the line again, may have looked at the previous\n\t    \/\/ one.\n\t    line = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\t}\n\n\t\/\/ Copy the line into \"buf\" and append the start of the next line if\n\t\/\/ possible.\n\tSTRCPY(buf, line);\n\tif (lnum < wp->w_buffer->b_ml.ml_line_count)\n\t    spell_cat_line(buf + STRLEN(buf),\n\t\t\t  ml_get_buf(wp->w_buffer, lnum + 1, FALSE), MAXWLEN);\n\n\tp = buf + skip;\n\tendp = buf + len;\n\twhile (p < endp)\n\t{\n\t    \/\/ When searching backward don't search after the cursor.  Unless\n\t    \/\/ included in a match crossing line boundaries.\n\t    if (attr == HLF_COUNT)\n\t\tskip = (int)(p - endp);\n\t    else\n\t\tskip = 0;\n\n\t    \/\/ Capcol skips over the inserted space.\n\t    --capcol;\n\n\t    \/\/ But after empty line check first word in next line\n\t    if (*skipwhite(line) == NUL)\n\t\tcapcol = 0;\n\t}\n\n\tline_breakcheck();\n    }\n\n    vim_free(buf);\n    return 0;\n}","target":1,"flaw_line_index":0,"hash":"e3524b0f-0c41-4174-8f6c-0c0da6c50548","idx":"dce33e68-3935-4db2-95a6-9c76afd85acd"}
{"func_before":"    int\t\tcurline,\n    hlf_T\t*attrp)\t\t\/\/ return: attributes of bad word or NULL\n\t\t\t\t\/\/ (only when \"dir\" is FORWARD)\n{\n    linenr_T\tlnum;\n    pos_T\tfound_pos;\n    int\t\tfound_len = 0;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\t*endp;\n    hlf_T\tattr = 0;\n    int\t\tlen;\n#ifdef FEAT_SYN_HL\n    int\t\thas_syntax = syntax_present(wp);\n#endif\n    int\t\tcol;\n    int\t\tcan_spell;\n    char_u\t*buf = NULL;\n    int\t\tbuflen = 0;\n    int\t\tskip = 0;\n    int\t\tcapcol = -1;\n     *\n     * We concatenate the start of the next line, so that wrapped words work\n     * (e.g. \"et<line-break>cetera\").  Doesn't work when searching backwards\n     * though...\n     *\/\n    lnum = wp->w_cursor.lnum;\n    CLEAR_POS(&found_pos);\n\n    while (!got_int)\n    {\n\tint empty_line;\n\n\tline = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\n\tlen = (int)STRLEN(line);\n\tif (buflen < len + MAXWLEN + 2)\n\t{\n\t    vim_free(buf);\n\t    buflen = len + MAXWLEN + 2;\n\t    buf = alloc(buflen);\n\t    if (buf == NULL)\n\t\tbreak;\n\t    col = getwhitecols(line);\n\t    if (check_need_cap(lnum, col))\n\t\tcapcol = col;\n\n\t    \/\/ Need to get the line again, may have looked at the previous\n\t    \/\/ one.\n\t    line = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\t}\n\n\t\/\/ Copy the line into \"buf\" and append the start of the next line if\n\t\/\/ possible.  Note: this ml_get_buf() may make \"line\" invalid, check\n\t\/\/ for empty line first.\n\tempty_line = *skipwhite(line) == NUL;\n\tSTRCPY(buf, line);\n\tif (lnum < wp->w_buffer->b_ml.ml_line_count)\n\t    spell_cat_line(buf + STRLEN(buf),\n\t\t\t  ml_get_buf(wp->w_buffer, lnum + 1, FALSE), MAXWLEN);\n\n\tp = buf + skip;\n\tendp = buf + len;\n\twhile (p < endp)\n\t{\n\t    \/\/ When searching backward don't search after the cursor.  Unless\n\t    \/\/ included in a match crossing line boundaries.\n\t    if (attr == HLF_COUNT)\n\t\tskip = (int)(p - endp);\n\t    else\n\t\tskip = 0;\n\n\t    \/\/ Capcol skips over the inserted space.\n\t    --capcol;\n\n\t    \/\/ But after empty line check first word in next line\n\t    if (empty_line)\n\t\tcapcol = 0;\n\t}\n\n\tline_breakcheck();\n    }\n\n    vim_free(buf);\n    return 0;\n}","target":0,"flaw_line_index":0,"hash":"36421936-0404-4131-b484-40d32bfeaee2","idx":"c6ff8a0e-2d13-4965-8cbc-f7d12f25c5c1"}
{"func_before":"\t\tif (dontfrag && (proto == IPPROTO_UDP || proto == IPPROTO_RAW)){\n\t\t\tipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\n\t\tif (proto == IPPROTO_UDP &&\n\t\t    (rt->dst.dev->features & NETIF_F_UFO)) {\n\n\t\t\terr = ip6_ufo_append_data(sk, getfrag, from, length,\n\t\t\t\t\t\t  hh_len, fragheaderlen,\n\t\t\t\t\t\t  transhdrlen, mtu, flags);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL)\n\t\tgoto alloc_new_skb;\n\n\twhile (length > 0) {","target":1,"flaw_line_index":0,"hash":"45b75c8e-8918-4023-997b-e8b4a3dfc7ca","idx":"bb7ef224-7c33-4d09-a22e-df7839bde909"}
{"func_before":"\t\tif (dontfrag && (proto == IPPROTO_UDP || proto == IPPROTO_RAW)){\n\t\t\tipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\n\t\tif (proto == IPPROTO_UDP &&\n\t\t    (rt->dst.dev->features & NETIF_F_UFO)) {\n\n\t\t\terr = ip6_ufo_append_data(sk, getfrag, from, length,\n\t\t\t\t\t\t  hh_len, fragheaderlen,\n\t\t\t\t\t\t  transhdrlen, mtu, flags, rt);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL)\n\t\tgoto alloc_new_skb;\n\n\twhile (length > 0) {","target":0,"flaw_line_index":0,"hash":"b9952890-8e7c-4088-b17a-888e33b4c0dd","idx":"fedc1057-9621-4486-ae4b-37fa011d4edd"}
{"func_before":"DWORD NSISCALL CreateRestrictedDirectory(LPCTSTR path)\n{\n  const SECURITY_INFORMATION si = OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION|DACL_SECURITY_INFORMATION|PROTECTED_DACL_SECURITY_INFORMATION;\n  PSID admingrpsid = GetAdminGrpSid();\n  SECURITY_DESCRIPTOR sd = { 1, 0, SE_DACL_PRESENT, admingrpsid, admingrpsid, NULL, GetAdminGrpAcl() };\n  SECURITY_ATTRIBUTES sa = { sizeof(SECURITY_ATTRIBUTES), &sd, FALSE };\n  DWORD ec = CreateDirectory(path, &sa) ? ERROR_SUCCESS : GetLastError();\n  if (ERROR_ALREADY_EXISTS == ec)\n    ec = SetFileSecurity(path, si, &sd) ? ERROR_SUCCESS : GetLastError();\n  return ec;\n}","target":1,"flaw_line_index":0,"hash":"82c937bb-2bfc-4507-a9e3-61fbc3d51ab8","idx":"833b2cd4-a3a6-4f5f-86c7-7e287d5c8573"}
{"func_before":"DWORD NSISCALL CreateRestrictedDirectory(LPCTSTR path)\n{\n  PSID admingrpsid = GetAdminGrpSid();\n  SECURITY_DESCRIPTOR sd = { 1, 0, SE_DACL_PRESENT, admingrpsid, admingrpsid, NULL, GetAdminGrpAcl() };\n  SECURITY_ATTRIBUTES sa = { sizeof(SECURITY_ATTRIBUTES), &sd, FALSE };\n  return CreateDirectory(path, &sa) ? ERROR_SUCCESS : GetLastError();\n}","target":0,"flaw_line_index":0,"hash":"f567e399-907d-43fa-8a93-abf81f03acf2","idx":"fc3b3e2f-e2d7-4358-bbc3-73095ffaeaff"}
{"func_before":"\n    if (p7->d.ptr == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);\n        return NULL;\n    }\n\n    i = OBJ_obj2nid(p7->type);\n    p7->state = PKCS7_S_HEADER;\n\n    switch (i) {\n    case NID_pkcs7_signed:\n        data_body = PKCS7_get_octet_string(p7->d.sign->contents);\n        if (!PKCS7_is_detached(p7) && data_body == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_INVALID_SIGNED_DATA_TYPE);\n            goto err;\n        }\n        md_sk = p7->d.sign->md_algs;\n        break;\n    case NID_pkcs7_signedAndEnveloped:\n        rsk = p7->d.signed_and_enveloped->recipientinfo;\n        md_sk = p7->d.signed_and_enveloped->md_algs;\n        data_body = p7->d.signed_and_enveloped->enc_data->enc_data;\n        enc_alg = p7->d.signed_and_enveloped->enc_data->algorithm;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    case NID_pkcs7_enveloped:\n        rsk = p7->d.enveloped->recipientinfo;\n        enc_alg = p7->d.enveloped->enc_data->algorithm;\n        data_body = p7->d.enveloped->enc_data->enc_data;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    default:\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\n        goto err;\n    }\n\n    \/* We will be checking the signature *\/\n    if (md_sk != NULL) {\n        for (i = 0; i < sk_X509_ALGOR_num(md_sk); i++) {\n            xa = sk_X509_ALGOR_value(md_sk, i);\n            if ((btmp = BIO_new(BIO_f_md())) == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB);\n                goto err;\n        ek = NULL;\n        OPENSSL_clear_free(tkey, tkeylen);\n        tkey = NULL;\n\n        if (out == NULL)\n            out = etmp;\n        else\n            BIO_push(out, etmp);\n        etmp = NULL;\n    }\n    if (PKCS7_is_detached(p7) || (in_bio != NULL)) {\n        bio = in_bio;\n    } else {\n        if (data_body->length > 0)\n            bio = BIO_new_mem_buf(data_body->data, data_body->length);\n        else {\n            bio = BIO_new(BIO_s_mem());\n            BIO_set_mem_eof_return(bio, 0);\n        }\n        if (bio == NULL)\n            goto err;","target":1,"flaw_line_index":0,"hash":"22075308-25c6-4139-9a76-fb14fd4ee312","idx":"23a78d3b-ac42-4ef1-bb33-b6d0374f684b"}
{"func_before":"    if (p7->d.ptr == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);\n        return NULL;\n    }\n\n    i = OBJ_obj2nid(p7->type);\n    p7->state = PKCS7_S_HEADER;\n\n    switch (i) {\n    case NID_pkcs7_signed:\n        \/*\n         * p7->d.sign->contents is a PKCS7 structure consisting of a contentType\n         * field and optional content.\n         * data_body is NULL if that structure has no (=detached) content\n         * or if the contentType is wrong (i.e., not \"data\").\n         *\/\n        data_body = PKCS7_get_octet_string(p7->d.sign->contents);\n        if (!PKCS7_is_detached(p7) && data_body == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_INVALID_SIGNED_DATA_TYPE);\n            goto err;\n        }\n        md_sk = p7->d.sign->md_algs;\n        break;\n    case NID_pkcs7_signedAndEnveloped:\n        rsk = p7->d.signed_and_enveloped->recipientinfo;\n        md_sk = p7->d.signed_and_enveloped->md_algs;\n        \/* data_body is NULL if the optional EncryptedContent is missing. *\/\n        data_body = p7->d.signed_and_enveloped->enc_data->enc_data;\n        enc_alg = p7->d.signed_and_enveloped->enc_data->algorithm;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    case NID_pkcs7_enveloped:\n        rsk = p7->d.enveloped->recipientinfo;\n        enc_alg = p7->d.enveloped->enc_data->algorithm;\n        \/* data_body is NULL if the optional EncryptedContent is missing. *\/\n        data_body = p7->d.enveloped->enc_data->enc_data;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    default:\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\n        goto err;\n    }\n\n    \/* Detached content must be supplied via in_bio instead. *\/\n    if (data_body == NULL && in_bio == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);\n        goto err;\n    }\n\n    \/* We will be checking the signature *\/\n    if (md_sk != NULL) {\n        for (i = 0; i < sk_X509_ALGOR_num(md_sk); i++) {\n            xa = sk_X509_ALGOR_value(md_sk, i);\n            if ((btmp = BIO_new(BIO_f_md())) == NULL) {\n                PKCS7err(PKCS7_F_PKCS7_DATADECODE, ERR_R_BIO_LIB);\n                goto err;\n        ek = NULL;\n        OPENSSL_clear_free(tkey, tkeylen);\n        tkey = NULL;\n\n        if (out == NULL)\n            out = etmp;\n        else\n            BIO_push(out, etmp);\n        etmp = NULL;\n    }\n    if (in_bio != NULL) {\n        bio = in_bio;\n    } else {\n        if (data_body->length > 0)\n            bio = BIO_new_mem_buf(data_body->data, data_body->length);\n        else {\n            bio = BIO_new(BIO_s_mem());\n            BIO_set_mem_eof_return(bio, 0);\n        }\n        if (bio == NULL)\n            goto err;","target":0,"flaw_line_index":0,"hash":"cb8c2105-9da9-45e5-b60a-493ed651ee24","idx":"e8731281-9c10-43f9-82a9-cd3eddd4b18c"}
{"func_before":"\tstruct files_struct *fd, *new_fd = NULL;\n\tstruct cred *new_cred = NULL;\n\tstruct nsproxy *new_nsproxy = NULL;\n\tint do_sysvsem = 0;\n\tint err;\n\n\t\/*\n\t * If unsharing a user namespace must also unshare the thread.\n\t *\/\n\tif (unshare_flags & CLONE_NEWUSER)\n\t\tunshare_flags |= CLONE_THREAD;\n\t\/*\n\t * If unsharing a pid namespace must also unshare the thread.\n\t *\/\n\tif (unshare_flags & CLONE_NEWPID)\n\t\tunshare_flags |= CLONE_THREAD;\n\t\/*\n\t * If unsharing a thread from a thread group, must also unshare vm.\n\t *\/\n\tif (unshare_flags & CLONE_THREAD)\n\t\tunshare_flags |= CLONE_VM;","target":1,"flaw_line_index":0,"hash":"a0279cc5-af9d-4577-9482-060664d4d73e","idx":"9c151f2b-6859-4009-95b3-5299bed31f95"}
{"func_before":"\tstruct files_struct *fd, *new_fd = NULL;\n\tstruct cred *new_cred = NULL;\n\tstruct nsproxy *new_nsproxy = NULL;\n\tint do_sysvsem = 0;\n\tint err;\n\n\t\/*\n\t * If unsharing a user namespace must also unshare the thread.\n\t *\/\n\tif (unshare_flags & CLONE_NEWUSER)\n\t\tunshare_flags |= CLONE_THREAD | CLONE_FS;\n\t\/*\n\t * If unsharing a pid namespace must also unshare the thread.\n\t *\/\n\tif (unshare_flags & CLONE_NEWPID)\n\t\tunshare_flags |= CLONE_THREAD;\n\t\/*\n\t * If unsharing a thread from a thread group, must also unshare vm.\n\t *\/\n\tif (unshare_flags & CLONE_THREAD)\n\t\tunshare_flags |= CLONE_VM;","target":0,"flaw_line_index":0,"hash":"f9ab91bf-7d6a-40c7-98a3-357e897c2766","idx":"f9b0bb3d-bd89-4a50-9588-7f3bb4118ca0"}
{"func_before":"static u32 crc32sum(u32 crc, u8 * RESTRICT buf, size_t size) {\n    while (size--) crc = crc32Table[(crc ^ *(buf++)) & 0xff] ^ (crc >> 8);\n    return crc;\n}","target":1,"flaw_line_index":0,"hash":"71152193-5c1e-48b8-94d8-0dac8ffcbd71","idx":"19f0536f-ae21-4aff-b35e-cfdbb8ae9d3a"}
{"func_before":"static u32 crc32sum(u32 crc, u8 * RESTRICT buf, size_t size) {\n    \/\/ Test endianness. The code needs to be different for LE and BE systems.\n    u32 test = 1;\n    if (*(u8 *) &test) {\n        while (size--) crc = crc32Table[(crc ^ *(buf++)) & 0xff] ^ (crc >> 8);\n        return crc;\n    } else {\n        while (size--) crc = crc32Table[((crc >> 24) ^ *(buf++)) & 0xff] ^ (crc << 8);\n        return crc;\n    }\n}","target":0,"flaw_line_index":0,"hash":"f73c5998-2f60-4ec4-8488-4f39a1919860","idx":"c2282a2d-0962-4115-93cd-003bb9d2c585"}
{"func_before":"#ifdef WIN32\n\tint addr_len;\n#else\n\tsocklen_t addr_len;\n#endif\n\tint result;\n\tstruct sockaddr_in addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(port);\n\n\taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n\n\treturn result;\n}","target":1,"flaw_line_index":0,"hash":"a4af0a77-006a-4c8b-b85f-3801b6b45e51","idx":"cec27bb8-3770-4687-8c9e-60dc226f0b03"}
{"func_before":"#ifdef WIN32\n\tint addr_len;\n#else\n\tsocklen_t addr_len;\n#endif\n\tint result;\n\tstruct sockaddr_in addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\taddr.sin_port = htons(port);\n\n\taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n\n\treturn result;\n}","target":0,"flaw_line_index":0,"hash":"8f541bed-6905-4c15-858f-8b3bcefa5d9e","idx":"49cc741b-fd48-4692-8202-dfeaee9fb8ab"}
{"func_before":"static bcon_error_t bson_append_bcon_with_state(bson *b, const bcon *bc, bcon_state_t start_state) {\n    bcon_error_t ret = BCON_OK;\n    bcon_state_t state = start_state;\n    char *key = 0;\n    char *typespec = 0;\n    unsigned char doc_stack[DOC_STACK_SIZE];\n    size_t doc_stack_pointer = 0;\n    size_t array_index = 0;\n    unsigned int array_index_stack[ARRAY_INDEX_STACK_SIZE];\n    size_t array_index_stack_pointer = 0;\n    char array_index_buffer[ARRAY_INDEX_BUFFER_SIZE]; \/* max BSON size *\/\n    int end_of_data;\n    const bcon *bcp;\n    for (end_of_data = 0, bcp = bc; ret == BCON_OK && !end_of_data; bcp++) {\n        bcon bci = *bcp;\n        char *s = bci.s;\n        switch (state) {\n        case State_Element:\n            switch (bcon_token(s)) {","target":1,"flaw_line_index":0,"hash":"8c018db4-becb-4b6d-9e2f-eca2cb24bfcf","idx":"7b36f356-6790-4070-adbc-b697a7b7a091"}
{"func_before":"static bcon_error_t bson_append_bcon_with_state(bson *b, const bcon *bc, bcon_state_t start_state) {\n    bcon_error_t ret = BCON_OK;\n    bcon_state_t state = start_state;\n    char *key = 0;\n    char *typespec = 0;\n    unsigned char doc_stack[DOC_STACK_SIZE];\n    size_t doc_stack_pointer = 0;\n    size_t array_index = 0;\n    size_t array_index_stack[ARRAY_INDEX_STACK_SIZE];\n    size_t array_index_stack_pointer = 0;\n    char array_index_buffer[ARRAY_INDEX_BUFFER_SIZE]; \/* max BSON size *\/\n    int end_of_data;\n    const bcon *bcp;\n    for (end_of_data = 0, bcp = bc; ret == BCON_OK && !end_of_data; bcp++) {\n        bcon bci = *bcp;\n        char *s = bci.s;\n        switch (state) {\n        case State_Element:\n            switch (bcon_token(s)) {","target":0,"flaw_line_index":0,"hash":"97b6fc6f-3a62-43b9-852e-821ca02ebf0d","idx":"d2a8ba96-abf9-47d4-8f7d-58db3186f42d"}
{"func_before":"void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n\n    \/\/if (block->host) {\n    \/\/    ram_block_notify_remove(block->host, block->max_length);\n    \/\/}\n\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    \/* Write list before version *\/\n    \/\/smp_wmb();\n    \/\/ call_rcu(block, reclaim_ramblock, rcu);\n    reclaim_ramblock(uc, block);\n}","target":1,"flaw_line_index":0,"hash":"52a48ea7-027b-4a9e-bfbf-46fc9ad03636","idx":"a9f54254-8f2e-4777-a831-cce1ae0c63f0"}
{"func_before":"void qemu_ram_free(struct uc_struct *uc, RAMBlock *block)\n{\n    if (!block) {\n        return;\n    }\n\n    \/\/if (block->host) {\n    \/\/    ram_block_notify_remove(block->host, block->max_length);\n    \/\/}\n\n    QLIST_REMOVE_RCU(block, next);\n    uc->ram_list.mru_block = NULL;\n    \/* Write list before version *\/\n    \/\/smp_wmb();\n    \/\/ call_rcu(block, reclaim_ramblock, rcu);\n    reclaim_ramblock(uc, block);\n}","target":0,"flaw_line_index":0,"hash":"d5893247-3946-4444-ae08-12352165a69d","idx":"b4939b8d-7e07-4ae4-9f4d-f8a0da94d299"}
{"func_before":"\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h\/v: %i \/ %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tswitch(tga->bits) {\n\tcase 8:\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\tgd_error(\"bps %i not supported\", tga->bits);\n\t\treturn -1;\n\t\tbreak;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n","target":1,"flaw_line_index":0,"hash":"d22722da-182a-4b06-bc0a-4e46257af543","idx":"7626b0c3-85aa-47b7-9971-dd637c2bdf15"}
{"func_before":"\ttga->fliph = (header[17] & 0x10) ? 1 : 0;\n\ttga->flipv = (header[17] & 0x20) ? 0 : 1;\n\n#if DEBUG\n\tprintf(\"format bps: %i\\n\", tga->bits);\n\tprintf(\"flip h\/v: %i \/ %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tif (!((tga->bits == TGA_BPP_24 && tga->alphabits == 0)\n\t\t|| (tga->bits == TGA_BPP_32 && tga->alphabits == 8)))\n\t{\n\t\tgd_error_ex(GD_WARNING, \"gd-tga: %u bits per pixel with %u alpha bits not supported\\n\",\n\t\t\ttga->bits, tga->alphabits);\n\t\treturn -1;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {\n\t\ttga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));\n\t\tif(tga->ident == NULL) {\n\t\t\treturn -1;\n\t\t}\n","target":0,"flaw_line_index":0,"hash":"ca653ca1-231d-4e1a-89d8-e822130a2d39","idx":"e9e81a6a-a8d2-489b-9b20-2186a29730bb"}
{"func_before":"\tHEVC_SPS *sps;\n\tHEVC_VPS *vps;\n\tHEVC_ProfileTierLevel ptl;\n\tBool multiLayerExtSpsFlag;\n\tu8 sps_ext_or_max_sub_layers_minus1, max_sub_layers_minus1;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\t\/\/nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif (vps_id >= 16) {\n\t\treturn -1;\n\t}\n\tmemset(&ptl, 0, sizeof(ptl));\n\tmax_sub_layers_minus1 = 0;\n\tsps_ext_or_max_sub_layers_minus1 = 0;\n\tif (layer_id == 0)\n\t\tmax_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\");\n\telse\n\t\tsps_ext_or_max_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \"sps_ext_or_max_sub_layers_minus1\");\n\tmultiLayerExtSpsFlag = (layer_id != 0) && (sps_ext_or_max_sub_layers_minus1 == 7);","target":1,"flaw_line_index":0,"hash":"c3455ea1-396a-4abb-82e7-ad6d73a6b8d6","idx":"48d380e5-bdee-420e-9de1-f4c57b7ab7cb"}
{"func_before":"\tHEVC_SPS *sps;\n\tHEVC_VPS *vps;\n\tHEVC_ProfileTierLevel ptl;\n\tBool multiLayerExtSpsFlag;\n\tu8 sps_ext_or_max_sub_layers_minus1, max_sub_layers_minus1;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\t\/\/nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif ((vps_id<0) || (vps_id >= 16)) {\n\t\treturn -1;\n\t}\n\tmemset(&ptl, 0, sizeof(ptl));\n\tmax_sub_layers_minus1 = 0;\n\tsps_ext_or_max_sub_layers_minus1 = 0;\n\tif (layer_id == 0)\n\t\tmax_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \"max_sub_layers_minus1\");\n\telse\n\t\tsps_ext_or_max_sub_layers_minus1 = gf_bs_read_int_log(bs, 3, \"sps_ext_or_max_sub_layers_minus1\");\n\tmultiLayerExtSpsFlag = (layer_id != 0) && (sps_ext_or_max_sub_layers_minus1 == 7);","target":0,"flaw_line_index":0,"hash":"08e94bc7-6a6e-4d8f-999c-f45fb46ec036","idx":"a29c5a56-b3e8-47b8-aab8-76ec75be9db9"}
{"func_before":"_isBidi (const uint32_t *label, size_t llen)\n{\n  while (llen-- > 0) {\n    int bc = uc_bidi_category (*label++);\n\n    if (bc == UC_BIDI_R || bc == UC_BIDI_AL || bc == UC_BIDI_AN)\n      return 1;\n  }\n\n  return 0;\n}","target":1,"flaw_line_index":0,"hash":"f98888c3-32c5-4817-b834-4fdd4608ec05","idx":"f430a563-15fc-44e1-a1c8-904078aeaa33"}
{"func_before":"_isBidi (const uint32_t *label, size_t llen)\n{\n  for (; (ssize_t) llen > 0; llen--) {\n    int bc = uc_bidi_category (*label++);\n\n    if (bc == UC_BIDI_R || bc == UC_BIDI_AL || bc == UC_BIDI_AN)\n      return 1;\n  }\n\n  return 0;\n}","target":0,"flaw_line_index":0,"hash":"c5fff530-e78c-4f16-b5d6-fd4f48640243","idx":"2260c70d-0110-4bad-9692-b0c85b20a2bf"}
{"func_before":"\tint err = 0;\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\n\t\/*\n\t * Use xrstors to restore context if it is enabled. xrstors supports\n\t * compacted format of xsave area which is not supported by xrstor.\n\t *\/\n\talternative_input(\n\t\t\"1: \" XRSTOR,\n\t\t\"1: \" XRSTORS,\n\t\tX86_FEATURE_XSAVES,\n\t\t\"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t: \"memory\");\n\n\tasm volatile(\"2:\\n\"\n\t\t     xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\n\treturn err;","target":1,"flaw_line_index":0,"hash":"12385441-c11f-4a74-b38a-d00c213dbba3","idx":"ae298557-3462-4382-a78e-85176f448122"}
{"func_before":"\tint err = 0;\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\n\t\/*\n\t * Use xrstors to restore context if it is enabled. xrstors supports\n\t * compacted format of xsave area which is not supported by xrstor.\n\t *\/\n\talternative_input(\n\t\t\"1: \" XRSTOR,\n\t\tXRSTORS,\n\t\tX86_FEATURE_XSAVES,\n\t\t\"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t: \"memory\");\n\n\tasm volatile(\"2:\\n\"\n\t\t     xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\n\treturn err;","target":0,"flaw_line_index":0,"hash":"d4f5f70f-1356-481a-aa9f-a42e4ca98d6d","idx":"7a35a05c-faa5-4f9a-9aa9-418322cda934"}
{"func_before":"tsl::StatusOr<Platform*> MultiPlatformManagerImpl::LookupByIdLocked(\n    const Platform::Id& id) {\n  auto it = id_map_.find(id);\n  if (it == id_map_.end()) {\n    return tsl::Status(\n        port::error::NOT_FOUND,\n        absl::StrFormat(\"could not find registered platform with id: %p\", id));\n  }\n  return it->second;\n}","target":1,"flaw_line_index":0,"hash":"cd77482c-bd38-400c-8297-80db013ab571","idx":"1dd12418-3072-4caf-b1fb-480fffc9f4c7"}
{"func_before":"tsl::StatusOr<Platform*> MultiPlatformManagerImpl::LookupByIdLocked(\n    const Platform::Id& id) {\n  auto it = id_map_.find(id);\n  if (it == id_map_.end()) {\n    return tsl::Status(\n        tsl::error::NOT_FOUND,\n        absl::StrFormat(\"could not find registered platform with id: %p\", id));\n  }\n  return it->second;\n}","target":0,"flaw_line_index":0,"hash":"de75913c-e548-4745-ae37-ef5a8ea5c0e6","idx":"cdbeb86c-4a7f-4ab1-9c58-ea3f3140026c"}
{"func_before":"PJ_DEF(void) pjsip_auth_create_digest( pj_str_t *result,\n\t\t\t\t       const pj_str_t *nonce,\n\t\t\t\t       const pj_str_t *nc,\n\t\t\t\t       const pj_str_t *cnonce,\n\t\t\t\t       const pj_str_t *qop,\n\t\t\t\t       const pj_str_t *uri,\n\t\t\t\t       const pj_str_t *realm,\n\t\t\t\t       const pjsip_cred_info *cred_info,\n\t\t\t\t       const pj_str_t *method)\n{\n    char ha1[PJSIP_MD5STRLEN];\n    char ha2[PJSIP_MD5STRLEN];\n    unsigned char digest[16];\n    pj_md5_context pms;\n\n    pj_assert(result->slen >= PJSIP_MD5STRLEN);\n\n    AUTH_TRACE_((THIS_FILE, \"Begin creating digest\"));\n\n\tMD5_APPEND( &pms, cred_info->username.ptr, cred_info->username.slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, realm->ptr, realm->slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, cred_info->data.ptr, cred_info->data.slen);\n\tpj_md5_final(&pms, digest);\n\n\tdigestNtoStr(digest, 16, ha1);\n\n    } else if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_DIGEST) {\n\tpj_assert(cred_info->data.slen == 32);\n\tpj_memcpy( ha1, cred_info->data.ptr, cred_info->data.slen );\n    } else {\n\tpj_assert(!\"Invalid data_type\");\n    }\n\n    AUTH_TRACE_((THIS_FILE, \"  ha1=%.32s\", ha1));\n\n    \/***\n     *** ha2 = MD5(method \":\" req_uri)\n     ***\/\n    pj_md5_init(&pms);\n    MD5_APPEND( &pms, method->ptr, method->slen);\n    MD5_APPEND( &pms, \":\", 1);\n    MD5_APPEND( &pms, ha2, PJSIP_MD5STRLEN);\n\n    \/* This is the final response digest. *\/\n    pj_md5_final(&pms, digest);\n\n    \/* Convert digest to string and store in chal->response. *\/\n    result->slen = PJSIP_MD5STRLEN;\n    digestNtoStr(digest, 16, result->ptr);\n\n    AUTH_TRACE_((THIS_FILE, \"  digest=%.32s\", result->ptr));\n    AUTH_TRACE_((THIS_FILE, \"Digest created\"));\n}","target":1,"flaw_line_index":0,"hash":"30d4a02c-7a49-411c-82d4-f14320e00f58","idx":"cf82a9d1-27e3-4caf-a327-69a60ba91c65"}
{"func_before":"PJ_DEF(pj_status_t) pjsip_auth_create_digest( pj_str_t *result,\n\t\t\t\t\t      const pj_str_t *nonce,\n\t\t\t\t\t      const pj_str_t *nc,\n\t\t\t\t\t      const pj_str_t *cnonce,\n\t\t\t\t\t      const pj_str_t *qop,\n\t\t\t\t\t      const pj_str_t *uri,\n\t\t\t\t\t      const pj_str_t *realm,\n\t\t\t\t\t      const pjsip_cred_info *cred_info,\n\t\t\t\t\t      const pj_str_t *method)\n{\n    char ha1[PJSIP_MD5STRLEN];\n    char ha2[PJSIP_MD5STRLEN];\n    unsigned char digest[16];\n    pj_md5_context pms;\n\n    pj_assert(result->slen >= PJSIP_MD5STRLEN);\n\n    AUTH_TRACE_((THIS_FILE, \"Begin creating digest\"));\n\n\tMD5_APPEND( &pms, cred_info->username.ptr, cred_info->username.slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, realm->ptr, realm->slen);\n\tMD5_APPEND( &pms, \":\", 1);\n\tMD5_APPEND( &pms, cred_info->data.ptr, cred_info->data.slen);\n\tpj_md5_final(&pms, digest);\n\n\tdigestNtoStr(digest, 16, ha1);\n\n    } else if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_DIGEST) {\n\tif (cred_info->data.slen != 32) {\n\t    pj_assert(!\"Invalid cred_info data length\");\n\t    pj_bzero(result->ptr, result->slen);\n\t    result->slen = 0;\n\t    return PJ_EINVAL;\n\t}\n\tpj_memcpy( ha1, cred_info->data.ptr, cred_info->data.slen );\n    } else {\n\tpj_assert(!\"Invalid data_type\");\n\tpj_bzero(result->ptr, result->slen);\n\tresult->slen = 0;\n\treturn PJ_EINVAL;\n    }\n\n    AUTH_TRACE_((THIS_FILE, \"  ha1=%.32s\", ha1));\n\n    \/***\n     *** ha2 = MD5(method \":\" req_uri)\n     ***\/\n    pj_md5_init(&pms);\n    MD5_APPEND( &pms, method->ptr, method->slen);\n    MD5_APPEND( &pms, \":\", 1);\n\n    \/* This is the final response digest. *\/\n    pj_md5_final(&pms, digest);\n\n    \/* Convert digest to string and store in chal->response. *\/\n    result->slen = PJSIP_MD5STRLEN;\n    digestNtoStr(digest, 16, result->ptr);\n\n    AUTH_TRACE_((THIS_FILE, \"  digest=%.32s\", result->ptr));\n    AUTH_TRACE_((THIS_FILE, \"Digest created\"));\n    return PJ_SUCCESS;\n}","target":0,"flaw_line_index":0,"hash":"151b732d-81a8-40da-bb39-2db6c2cc6560","idx":"eb40e26c-b4fb-4e22-a228-a2ae5973ad28"}
{"func_before":"    const std::unordered_map<std::string, std::string> &getCookies() const\n    {\n        return cookies();\n    }","target":1,"flaw_line_index":0,"hash":"b3c890a6-2640-444d-a130-97d2daaab825","idx":"51246610-ceff-4dc9-9821-37cd08fabfb7"}
{"func_before":"            &getCookies() const\n    {\n        return cookies();\n    }","target":0,"flaw_line_index":0,"hash":"f18da5d7-c49b-4310-90a3-8e9edab90bf9","idx":"07359c88-58d1-49e4-87c0-c6aef91c712f"}
{"func_before":"\t\terr = -ENOMEM;\n\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tflush_dcache_page(page);\n\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = tmp;\n\t\treq->num_pages++;\n\n\t\tiov_iter_advance(ii, tmp);\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < req->max_pages && offset == 0);","target":1,"flaw_line_index":0,"hash":"a590b1ad-d2cb-45af-8fa5-a910b9272ae0","idx":"8aef664e-4da8-4315-9ffa-ca857e9a60b3"}
{"func_before":"\t\tpage = grab_cache_page_write_begin(mapping, index, 0);\n\t\tif (!page)\n\t\t\tbreak;\n\n\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tflush_dcache_page(page);\n\n\t\tiov_iter_advance(ii, tmp);\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\t}\n\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = tmp;\n\t\treq->num_pages++;\n\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;\n\n\t\tif (!fc->big_writes)\n\t\t\tbreak;\n\t} while (iov_iter_count(ii) && count < fc->max_write &&\n\t\t req->num_pages < req->max_pages && offset == 0);","target":0,"flaw_line_index":0,"hash":"6ab42347-f03b-4fc8-92ef-cb8012f91162","idx":"034c3ca1-6aa3-4dcf-9ff1-6db650c79c10"}
{"func_before":"static void ep2_mul_sim_endom(ep2_t r, const ep2_t p, const bn_t k, ep2_t q,\n\t\tconst bn_t m) {\n\tint i, j, l, _l[4];\n\tbn_t _k[4], _m[4], n, u;\n\tint8_t naf0[4][RLC_FP_BITS + 1];\n\tint8_t naf1[4][RLC_FP_BITS + 1];\n\tep2_t _p[4], _q[4];\n\n\tbn_null(n);\n\tbn_null(u);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(u);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbn_null(_k[i]);\n\t\t\tbn_new(_k[i]);\n\t\t\tbn_null(_m[i]);\n\t\t\tbn_new(_m[i]);\n\t\t\tep2_null(_p[i]);\n\t\t\tep2_null(_q[i]);\n\t\t\tep2_new(_p[i]);\n\t\t\tep2_new(_q[i]);\n\t\t}\n\n\t\tep2_frb(_q[3], _q[2], 1);\n\n\t\tep2_curve_get_ord(n);\n\t\tfp_prime_get_par(u);\n\t\tbn_mod(_k[0], k, n);\n\t\tbn_rec_frb(_k, 4, _k[0], u, n, ep_curve_is_pairf() == EP_BN);\n\t\tbn_mod(_m[0], m, n);\n\t\tbn_rec_frb(_m, 4, _m[0], u, n, ep_curve_is_pairf() == EP_BN);\n\n\t\tl = 0;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\tbn_rec_naf(naf0[i], &_l[i], _k[i], 2);\n\t\t\tif (bn_sign(_k[i]) == RLC_NEG) {\n\t\t\t\tep2_neg(_p[i], _p[i]);\n\t\t\t}\n\t\t\tl = RLC_MAX(l, _l[i]);\n\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\tbn_rec_naf(naf1[i], &_l[i], _m[i], 2);\n\t\t\tif (bn_sign(_m[i]) == RLC_NEG) {\n\t\t\t\tep2_neg(_q[i], _q[i]);\n\t\t\t}\n\t\t\tl = RLC_MAX(l, _l[i]);\n\t\t}\n\n\t\tep2_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tep2_dbl(r, r);\n\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\tif (naf0[j][i] > 0) {\n\t\t\t\t\tep2_add(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t\tif (naf0[j][i] < 0) {\n\t\t\t\t\tep2_sub(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t\tif (naf1[j][i] > 0) {\n\t\t\t\t\tep2_add(r, r, _q[j]);\n\t\t\t\t}\n\t\t\t\tif (naf1[j][i] < 0) {\n\t\t\t}\n\t\t}\n\n\t\t\/* Convert r to affine coordinates. *\/\n\t\tep2_norm(r, r);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(u);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbn_free(_k[i]);\n\t\t\tbn_free(_m[i]);\n\t\t\tep2_free(_p[i]);\n\t\t\tep2_free(_q[i]);\n\t\t}\n\t}\n}","target":1,"flaw_line_index":0,"hash":"24cd913d-f46d-4d04-b181-34b058fd3d18","idx":"022d1e65-2aff-472b-a42b-4b0b11b0de32"}
{"func_before":"static void ep2_mul_sim_endom(ep2_t r, const ep2_t p, const bn_t k, ep2_t q,\n\t\tconst bn_t m) {\n\tsize_t l, _l[4];\n\tbn_t _k[4], _m[4], n, u;\n\tint8_t naf0[4][RLC_FP_BITS + 1];\n\tint8_t naf1[4][RLC_FP_BITS + 1];\n\tep2_t _p[4], _q[4];\n\n\tbn_null(n);\n\tbn_null(u);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(u);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tbn_null(_k[i]);\n\t\t\tbn_new(_k[i]);\n\t\t\tbn_null(_m[i]);\n\t\t\tbn_new(_m[i]);\n\t\t\tep2_null(_p[i]);\n\t\t\tep2_null(_q[i]);\n\t\t\tep2_new(_p[i]);\n\t\t\tep2_new(_q[i]);\n\t\t}\n\n\t\tep2_frb(_q[3], _q[2], 1);\n\n\t\tep2_curve_get_ord(n);\n\t\tfp_prime_get_par(u);\n\t\tbn_mod(_k[0], k, n);\n\t\tbn_rec_frb(_k, 4, _k[0], u, n, ep_curve_is_pairf() == EP_BN);\n\t\tbn_mod(_m[0], m, n);\n\t\tbn_rec_frb(_m, 4, _m[0], u, n, ep_curve_is_pairf() == EP_BN);\n\n\t\tl = 0;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\tbn_rec_naf(naf0[i], &_l[i], _k[i], 2);\n\t\t\tif (bn_sign(_k[i]) == RLC_NEG) {\n\t\t\t\tep2_neg(_p[i], _p[i]);\n\t\t\t}\n\t\t\tl = RLC_MAX(l, _l[i]);\n\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\tbn_rec_naf(naf1[i], &_l[i], _m[i], 2);\n\t\t\tif (bn_sign(_m[i]) == RLC_NEG) {\n\t\t\t\tep2_neg(_q[i], _q[i]);\n\t\t\t}\n\t\t\tl = RLC_MAX(l, _l[i]);\n\t\t}\n\n\t\tep2_set_infty(r);\n\t\tfor (int i = l - 1; i >= 0; i--) {\n\t\t\tep2_dbl(r, r);\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tif (naf0[j][i] > 0) {\n\t\t\t\t\tep2_add(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t\tif (naf0[j][i] < 0) {\n\t\t\t\t\tep2_sub(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t\tif (naf1[j][i] > 0) {\n\t\t\t\t\tep2_add(r, r, _q[j]);\n\t\t\t\t}\n\t\t\t\tif (naf1[j][i] < 0) {\n\t\t\t}\n\t\t}\n\n\t\t\/* Convert r to affine coordinates. *\/\n\t\tep2_norm(r, r);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(u);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tbn_free(_k[i]);\n\t\t\tbn_free(_m[i]);\n\t\t\tep2_free(_p[i]);\n\t\t\tep2_free(_q[i]);\n\t\t}\n\t}\n}","target":0,"flaw_line_index":0,"hash":"65a6eb45-a37b-4a41-ab47-16e6e3f14028","idx":"81ebdcc7-ec2e-4049-9613-3551db6db1e3"}
{"func_before":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteSpaceToDepthParams*>(node->builtin_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n#define TF_LITE_SPACE_TO_DEPTH(type, scalar)                               \\\n  tflite::SpaceToDepthParams op_params;                                    \\\n  op_params.block_size = params->block_size;                               \\\n  type::SpaceToDepth(op_params, GetTensorShape(input),                     \\\n                     GetTensorData<scalar>(input), GetTensorShape(output), \\\n                     GetTensorData<scalar>(output))\n  switch (input->type) {  \/\/ Already know in\/out types are same.\n    case kTfLiteFloat32:\n      if (kernel_type == kReference) {","target":1,"flaw_line_index":0,"hash":"f1d5c52a-6cce-4388-9023-0c45e5dc2186","idx":"b66c21af-05b0-40c2-8f3b-f2aa933852c3"}
{"func_before":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteSpaceToDepthParams*>(node->builtin_data);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n#define TF_LITE_SPACE_TO_DEPTH(type, scalar)                               \\\n  tflite::SpaceToDepthParams op_params;                                    \\\n  op_params.block_size = params->block_size;                               \\\n  type::SpaceToDepth(op_params, GetTensorShape(input),                     \\\n                     GetTensorData<scalar>(input), GetTensorShape(output), \\\n                     GetTensorData<scalar>(output))\n  switch (input->type) {  \/\/ Already know in\/out types are same.\n    case kTfLiteFloat32:\n      if (kernel_type == kReference) {","target":0,"flaw_line_index":0,"hash":"70a8098f-5e5a-4dde-9c6c-01122400db0b","idx":"07c17c55-4bd9-449c-ba0c-111dce14263c"}
{"func_before":"static size_t ntlm_av_pair_get_next_offset(NTLM_AV_PAIR* pAvPair)\n{\n\treturn ntlm_av_pair_get_len(pAvPair) + sizeof(NTLM_AV_PAIR);\n}","target":1,"flaw_line_index":0,"hash":"114fb3be-3ad1-47ef-905d-86ec94bd19a3","idx":"d32cd4c6-d843-49bf-a5f1-0995e7afc077"}
{"func_before":"static BOOL ntlm_av_pair_get_next_offset(const NTLM_AV_PAIR* pAvPair, size_t size, size_t* pOffset)\n{\n\tsize_t avLen;\n\tif (!pOffset)\n\t\treturn FALSE;\n\n\tif (!ntlm_av_pair_get_len(pAvPair, size, &avLen))\n\t\treturn FALSE;\n\t*pOffset = avLen + sizeof(NTLM_AV_PAIR);\n\treturn TRUE;\n}","target":0,"flaw_line_index":0,"hash":"7a5d2ee3-0494-46a0-9f78-cac6202a189f","idx":"3b70d131-bb9d-41e3-91c1-86361bbe9f20"}
{"func_before":"static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long debugctlmsr;\n\n\t\/* Record the guest's net vcpu time for enforced NMI injections. *\/\n\tif (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked))\n\t\tvmx->entry_time = ktime_get();\n\n\t\/* Don't enter VMX if guest state is invalid, let the exit handler\n\t   start emulation until we arrive back to a valid state *\/\n\tif (vmx->emulation_required)\n\t\treturn;\n\n\t}\n\n\tif (vmx->nested.sync_shadow_vmcs) {\n\t\tcopy_vmcs12_to_shadow(vmx);\n\t\tvmx->nested.sync_shadow_vmcs = false;\n\t}\n\n\tif (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n\tif (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n\n\t\/* When single-stepping over STI and MOV SS, we must clear the\n\t * corresponding interruptibility bits in the guest state. Otherwise\n\t * vmentry fails as it then expects bit 14 (BS) in pending debug\n\t * exceptions being set, but that's not correct for the guest debugging\n\t * case. *\/\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvmx_set_interrupt_shadow(vcpu, 0);\n\n\tatomic_switch_perf_msrs(vmx);","target":1,"flaw_line_index":0,"hash":"719120e9-1128-4bd6-bfaf-7336cffc5924","idx":"d3444730-72da-4963-bfcf-45361a344b9f"}
{"func_before":"static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long debugctlmsr, cr4;\n\n\t\/* Record the guest's net vcpu time for enforced NMI injections. *\/\n\tif (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked))\n\t\tvmx->entry_time = ktime_get();\n\n\t\/* Don't enter VMX if guest state is invalid, let the exit handler\n\t   start emulation until we arrive back to a valid state *\/\n\tif (vmx->emulation_required)\n\t\treturn;\n\n\n\tif (vmx->nested.sync_shadow_vmcs) {\n\t\tcopy_vmcs12_to_shadow(vmx);\n\t\tvmx->nested.sync_shadow_vmcs = false;\n\t}\n\n\tif (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n\tif (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n\n\tcr4 = read_cr4();\n\tif (unlikely(cr4 != vmx->host_state.vmcs_host_cr4)) {\n\t\tvmcs_writel(HOST_CR4, cr4);\n\t\tvmx->host_state.vmcs_host_cr4 = cr4;\n\t}\n\n\t\/* When single-stepping over STI and MOV SS, we must clear the\n\t * corresponding interruptibility bits in the guest state. Otherwise\n\t * vmentry fails as it then expects bit 14 (BS) in pending debug\n\t * exceptions being set, but that's not correct for the guest debugging\n\t * case. *\/\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvmx_set_interrupt_shadow(vcpu, 0);\n\n\tatomic_switch_perf_msrs(vmx);","target":0,"flaw_line_index":0,"hash":"37445cba-1ae7-4c09-a045-087516840836","idx":"d9ac33ae-06c4-4613-b6e7-ced3c7c1d578"}
{"func_before":"    case CURL_SSLVERSION_SSLv3:\n    case CURL_SSLVERSION_SSLv2:\n      failf(data, \"SSL versions not supported\");\n      return CURLE_NOT_BUILT_IN;\n    default:\n      failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    if(SSL_CONN_CONFIG(cipher_list)) {\n      result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list));\n      if(CURLE_OK != result) {\n        failf(data, \"Unable to set ciphers to passed via SSL_CONN_CONFIG\");\n        return result;\n      }\n    }\n\n\n#ifdef HAS_CLIENT_CERT_PATH\n    \/* client certificate *\/\n    if(data->set.ssl.primary.clientcert || data->set.ssl.primary.cert_blob) {","target":1,"flaw_line_index":0,"hash":"8ee3ef71-1f81-4f34-82af-0754773638a3","idx":"f8972269-ca50-484e-8a22-8fa078a2393b"}
{"func_before":"    case CURL_SSLVERSION_SSLv3:\n    case CURL_SSLVERSION_SSLv2:\n      failf(data, \"SSL versions not supported\");\n      return CURLE_NOT_BUILT_IN;\n    default:\n      failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    if(SSL_CONN_CONFIG(cipher_list)) {\n      result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list),\n                               BACKEND->algIds);\n      if(CURLE_OK != result) {\n        failf(data, \"Unable to set ciphers to passed via SSL_CONN_CONFIG\");\n        return result;\n      }\n    }\n\n\n#ifdef HAS_CLIENT_CERT_PATH\n    \/* client certificate *\/\n    if(data->set.ssl.primary.clientcert || data->set.ssl.primary.cert_blob) {","target":0,"flaw_line_index":0,"hash":"03c4a768-2e3b-42c6-867a-0e98dcfff020","idx":"72b0adc3-b4d0-4c42-b313-3f378c4ed8e7"}
{"func_before":"raw_copy_to_user(void __user *dst, const void *src, unsigned long size)\n{\n\tint ret = 0;\n\n\tif (!__builtin_constant_p(size))\n\t\treturn copy_user_generic((__force void *)dst, src, size);\n\tswitch (size) {\n\tcase 1:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u8 *)src, (u8 __user *)dst,\n\t\t\t      ret, \"b\", \"b\", \"iq\", 1);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 2:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u16 *)src, (u16 __user *)dst,\n\t\t\t      ret, \"w\", \"w\", \"ir\", 2);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 4:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u32 *)src, (u32 __user *)dst,\n\t\t\t      ret, \"l\", \"k\", \"ir\", 4);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 8:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u64 *)src, (u64 __user *)dst,\n\t\t\t      ret, \"q\", \"\", \"er\", 8);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 10:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u64 *)src, (u64 __user *)dst,\n\t\t\t       ret, \"q\", \"\", \"er\", 10);\n\t\tif (likely(!ret)) {\n\t\t\tasm(\"\":::\"memory\");\n\t\t\t__put_user_asm(4[(u16 *)src], 4 + (u16 __user *)dst,\n\t\t\t\t       ret, \"w\", \"w\", \"ir\", 2);\n\t\t}\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 16:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u64 *)src, (u64 __user *)dst,\n\t\t\t       ret, \"q\", \"\", \"er\", 16);\n\t\tif (likely(!ret)) {\n\t\t\tasm(\"\":::\"memory\");\n\t\t\t__put_user_asm(1[(u64 *)src], 1 + (u64 __user *)dst,\n\t\t\t\t       ret, \"q\", \"\", \"er\", 8);\n\t\t}\n\t\t__uaccess_end();\n\t\treturn ret;\n\tdefault:\n\t\treturn copy_user_generic((__force void *)dst, src, size);\n\t}\n}","target":1,"flaw_line_index":0,"hash":"718d0176-74e8-42c7-ac2d-3a8f8c26dee2","idx":"405621c8-1719-4772-9f69-87217fd26c69"}
{"func_before":"raw_copy_to_user(void __user *dst, const void *src, unsigned long size)\n{\n\treturn copy_user_generic((__force void *)dst, src, size);\n}","target":0,"flaw_line_index":0,"hash":"d3773bd1-67a6-4c59-95b7-ba6ce8482f33","idx":"877fbbd5-6dc8-4ca2-aace-2c039f0e53a7"}
{"func_before":"{\n    char *s, *inbuffer;\n    int length, error = 0;\n    long num,i;\n\n    Inivars();\n    argc--;\n    axohelp = *argv++;\n    if ( argc <= 0 ) {\n        PrintHelp(axohelp);\n\treturn -1;\n    }\n    while ( (*argv)[0] == '-' ) {   \/* we have options *\/\n        s = *argv;\n        if ( s[1] == '-' ) {\n  \t    \/* Double \"--\", treat as \"-\" *\/\n\t    s++;\n        }\n        if ( ( strcmp(s,\"-h\") == 0) || ( strcmp(s,\"-help\") == 0 ) ) {\n  \t    PrintHelp(axohelp);\n\t    return 0;\n                    \"There is NO WARRANTY, to the extent permitted by law.\\n\",\n\t\t    axohelp, VERSION, SUBVERSION, VERSIONDATE);\n   \t    return 0;\n\t}\n        else if ( strcmp( s, \"-V\" ) == 0 ) {\n            VerboseFlag = 1;\n        }\n        else {\n \t    fprintf(stderr,\"%s: Illegal option %s\\n\", axohelp, *argv);\n            PrintHelpPrompt(axohelp);\n\t    return -1;\n        }\n        argc--; argv++;\n        if ( argc <= 0 ) {\n            fprintf(stderr,\"%s: Not enough arguments\\n\",axohelp);\n            PrintHelpPrompt(axohelp);\n\t    return -1;\n        }\n    }\n    if ( argc != 1 ) {\n        fprintf(stderr,\"%s: Too many arguments\\n\",axohelp);\n        PrintHelpPrompt(axohelp);\n        return -1;\n    }\n\/*\n    The filename is now in s. We copy it to a separate string and\n    paste on the extension .ax1 (if needed), and construct the\n    name of the output file.\n*\/\n    s = *argv;\n    length = strlen(s);\n    inname  = strcpy(malloc((length+5)*sizeof(char)),s);\n    outname = strcpy(malloc((length+5)*sizeof(char)),s);\n    if ( (length > 4) && (strcmp(s+length-4, \".ax1\") == 0) ) {\n        outname[length-1] = '2';\n    }\n    else {\n        strcpy( inname+length, \".ax1\" );\n        strcpy( outname+length, \".ax2\" );\n    }\n    if ( ( inbuffer = ReadInput(inname) ) == 0 ) return(-1);\n    if ( ( outfile = fopen(outname,\"w\") ) == 0 ) {\n        fprintf(stderr,\"%s: Cannot create file %s\\n\",axohelp,outname);\n        exit(-1);\n    }\n    num = ScanForObjects(inbuffer);\n    for ( i = 0; i < num; i++ ) {\n        numobject = i+1;\n        if ( DoOneObject(inputs[i]) < 0 ) { error++; }\n    }\n    fclose(outfile);\n    if ( error > 0 ) {\n        fprintf(stderr,\"%s: %d objects in %s were not translated correctly.\\n\",\n            axohelp,error,inname);\n        return(-1);\n    }\n    return(0);\n}","target":1,"flaw_line_index":0,"hash":"640385f7-19eb-4777-8fe7-e942ee50cf53","idx":"f2f0e768-03c9-45d5-aa80-f6a80392d9b0"}
{"func_before":"{\n    char *s, *inbuffer;\n    int length, error = 0;\n    long num,i;\n\n    Inivars();\n    argc--;\n    axohelp = *argv++;\n    if ( argc <= 0 ) {\n        PrintHelp(axohelp);\n\treturn 1;\n    }\n    while ( (*argv)[0] == '-' ) {   \/* we have options *\/\n        s = *argv;\n        if ( s[1] == '-' ) {\n  \t    \/* Double \"--\", treat as \"-\" *\/\n\t    s++;\n        }\n        if ( ( strcmp(s,\"-h\") == 0) || ( strcmp(s,\"-help\") == 0 ) ) {\n  \t    PrintHelp(axohelp);\n\t    return 0;\n                    \"There is NO WARRANTY, to the extent permitted by law.\\n\",\n\t\t    axohelp, VERSION, SUBVERSION, VERSIONDATE);\n   \t    return 0;\n\t}\n        else if ( strcmp( s, \"-V\" ) == 0 ) {\n            VerboseFlag = 1;\n        }\n        else {\n \t    fprintf(stderr,\"%s: Illegal option %s\\n\", axohelp, *argv);\n            PrintHelpPrompt(axohelp);\n\t    return 1;\n        }\n        argc--; argv++;\n        if ( argc <= 0 ) {\n            fprintf(stderr,\"%s: Not enough arguments\\n\",axohelp);\n            PrintHelpPrompt(axohelp);\n\t    return 1;\n        }\n    }\n    if ( argc != 1 ) {\n        fprintf(stderr,\"%s: Too many arguments\\n\",axohelp);\n        PrintHelpPrompt(axohelp);\n        return 1;\n    }\n\/*\n    The filename is now in s. We copy it to a separate string and\n    paste on the extension .ax1 (if needed), and construct the\n    name of the output file.\n*\/\n    s = *argv;\n    length = strlen(s);\n    inname  = strcpy(malloc((length+5)*sizeof(char)),s);\n    outname = strcpy(malloc((length+5)*sizeof(char)),s);\n    if ( (length > 4) && (strcmp(s+length-4, \".ax1\") == 0) ) {\n        outname[length-1] = '2';\n    }\n    else {\n        strcpy( inname+length, \".ax1\" );\n        strcpy( outname+length, \".ax2\" );\n    }\n    if ( ( inbuffer = ReadInput(inname) ) == 0 ) return(1);\n    if ( ( outfile = fopen(outname,\"w\") ) == 0 ) {\n        fprintf(stderr,\"%s: Cannot create file %s\\n\",axohelp,outname);\n        exit(1);\n    }\n    num = ScanForObjects(inbuffer);\n    for ( i = 0; i < num; i++ ) {\n        numobject = i+1;\n        if ( DoOneObject(inputs[i]) < 0 ) { error++; }\n    }\n    fclose(outfile);\n    if ( error > 0 ) {\n        fprintf(stderr,\"%s: %d objects in %s were not translated correctly.\\n\",\n            axohelp,error,inname);\n        return(1);\n    }\n    return(0);\n}","target":0,"flaw_line_index":0,"hash":"2a79c186-cc6e-40a7-8c8a-0e7d1f8014e0","idx":"8a96a62d-4288-49e4-a8a0-a91787fdd961"}
{"func_before":"static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint retval = 0;\n\tint bytes_read = 0;\n\tchar in_buffer[20];\n\tunsigned long flags;\n\n\tdev = file->private_data;\n\n\tmutex_lock(&dev->io_mutex);\n\tif (!dev->interface) {\t\t\/* already disconnected *\/\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tbytes_read = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (*ppos < bytes_read) {\n\t\tif (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))\n\t\t\tretval = -EFAULT;\n\t\telse {\n\t\t\tretval = bytes_read - *ppos;\n\t\t\t*ppos += bytes_read;\n\t\t}\n\t}\n\nexit:\n\tmutex_unlock(&dev->io_mutex);\n\treturn retval;\n}","target":1,"flaw_line_index":0,"hash":"0899dc83-d267-4b29-92b2-0cf48ad18d27","idx":"3f3546b6-852f-4c66-8560-86b37b4fb97d"}
{"func_before":"static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint len = 0;\n\tchar in_buffer[20];\n\tunsigned long flags;\n\n\tdev = file->private_data;\n\n\tmutex_lock(&dev->io_mutex);\n\tif (!dev->interface) {\t\t\/* already disconnected *\/\n\t\tmutex_unlock(&dev->io_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tlen = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tmutex_unlock(&dev->io_mutex);\n\n\treturn simple_read_from_buffer(buffer, count, ppos, in_buffer, len);\n}","target":0,"flaw_line_index":0,"hash":"6e4484cd-6b38-4936-8fd1-d9129fa8197b","idx":"cf2f0623-7e91-4e23-b10a-e9f9c671c149"}
{"func_before":"static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"ablkcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_ablkcipher.geniv ?: \"<default>\");\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;","target":1,"flaw_line_index":0,"hash":"722456e5-ab46-4efc-8cef-ae8319ccb4c4","idx":"c08644a7-5718-4b7f-980c-c5468c727769"}
{"func_before":"static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tstrncpy(rblkcipher.type, \"ablkcipher\", sizeof(rblkcipher.type));\n\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \"<default>\",\n\t\tsizeof(rblkcipher.geniv));\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_BLKCIPHER,\n\t\t    sizeof(struct crypto_report_blkcipher), &rblkcipher))\n\t\tgoto nla_put_failure;\n\treturn 0;","target":0,"flaw_line_index":0,"hash":"647b5315-14ea-462a-b97a-36cf0a8100e7","idx":"df7ec7e0-5187-48fb-9497-3cf66603eb79"}
{"func_before":"\n                    return NJS_ERROR;\n                }\n\n                p--;\n            }\n\n        } else {\n            \/* UTF-8 string. *\/\n\n            p = njs_string_offset(string_prop.start, end, from);\n            p = njs_utf8_next(p, end);\n\n            i = from + 1;\n\n            while (i-- > to) {\n                pos = njs_utf8_prev(p);\n\n                \/* This cannot fail. *\/\n                (void) njs_string_new(vm, &character, pos, p - pos , 1);\n\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {","target":1,"flaw_line_index":0,"hash":"e870b0d1-c7bf-4926-8e76-acb1c9f4217d","idx":"7f8f1115-38de-461e-bf4c-af45466cf338"}
{"func_before":"\n                    return NJS_ERROR;\n                }\n\n                p--;\n            }\n\n        } else {\n            \/* UTF-8 string. *\/\n\n            p = NULL;\n            i = from + 1;\n\n            if (i > to) {\n                p = njs_string_offset(string_prop.start, end, from);\n                p = njs_utf8_next(p, end);\n            }\n\n            while (i-- > to) {\n                pos = njs_utf8_prev(p);\n\n                \/* This cannot fail. *\/\n                (void) njs_string_new(vm, &character, pos, p - pos , 1);\n\n                ret = handler(vm, args, &character, i);\n                if (njs_slow_path(ret != NJS_OK)) {\n                    if (ret == NJS_DONE) {","target":0,"flaw_line_index":0,"hash":"ec29f289-7c93-4581-bd17-ef8b72d699f2","idx":"b44f8694-99bb-4552-a9c5-f9d6b361c2e2"}
{"func_before":"\nskipabs:\n\n\tr = snprintf(path, MAXPATHLEN, \"%s\/%s\", rootfs->mount,\n\t\t aux + offset);\n\tif (r < 0 || r >= MAXPATHLEN) {\n\t\tWARN(\"pathnme too long for '%s'\", mntent->mnt_dir);\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path);\n}","target":1,"flaw_line_index":0,"hash":"7435e3e3-0040-4cc7-9fc1-d1973b296e94","idx":"7b9724e5-4c28-42aa-952c-7c303fbea7bc"}
{"func_before":"\nskipabs:\n\n\tr = snprintf(path, MAXPATHLEN, \"%s\/%s\", rootfs->mount,\n\t\t aux + offset);\n\tif (r < 0 || r >= MAXPATHLEN) {\n\t\tWARN(\"pathnme too long for '%s'\", mntent->mnt_dir);\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, rootfs->mount);\n}","target":0,"flaw_line_index":0,"hash":"808bc274-bd08-4d0f-80d7-885e769f5bb7","idx":"bcf72e2a-bf4b-4145-8a34-1f915b97b683"}
{"func_before":"static int ref_pic_list_struct(GetBitContext *gb, RefPicListStruct *rpl)\n{\n    uint32_t delta_poc_st, strp_entry_sign_flag = 0;\n    rpl->ref_pic_num = get_ue_golomb_long(gb);\n    if (rpl->ref_pic_num > 0) {\n        delta_poc_st = get_ue_golomb_long(gb);\n\n        rpl->ref_pics[0] = delta_poc_st;\n        if (rpl->ref_pics[0] != 0) {\n            strp_entry_sign_flag = get_bits(gb, 1);\n\n            rpl->ref_pics[0] *= 1 - (strp_entry_sign_flag << 1);\n        }\n    }","target":1,"flaw_line_index":0,"hash":"613a24e8-3866-4324-9894-9cf9422e9bb2","idx":"8617c6c7-bced-4eaf-86ea-b19c2d1fa7ef"}
{"func_before":"static int ref_pic_list_struct(EVCParserSPS *sps, GetBitContext *gb, RefPicListStruct *rpl)\n{\n    uint32_t delta_poc_st, strp_entry_sign_flag = 0;\n    rpl->ref_pic_num = get_ue_golomb_long(gb);\n\n    if ((unsigned)rpl->ref_pic_num  > sps->sps_max_dec_pic_buffering_minus1)\n        return AVERROR_INVALIDDATA;\n\n    if (rpl->ref_pic_num > 0) {\n        delta_poc_st = get_ue_golomb_long(gb);\n\n        rpl->ref_pics[0] = delta_poc_st;\n        if (rpl->ref_pics[0] != 0) {\n            strp_entry_sign_flag = get_bits(gb, 1);\n\n            rpl->ref_pics[0] *= 1 - (strp_entry_sign_flag << 1);\n        }\n    }","target":0,"flaw_line_index":0,"hash":"d5e1ca45-9915-48f6-b8ac-e36b79984c35","idx":"87daf7c9-ea4d-43c3-b15d-1ee0db77556a"}
{"func_before":"ReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n\n    \/* we have an error following *\/\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    reason = malloc((uint64_t)reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}","target":1,"flaw_line_index":0,"hash":"55bf6e0f-94a6-4bcf-80c1-354ad0e37836","idx":"1fa6fba3-3625-4673-8936-d3695d7d8627"}
{"func_before":"ReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    if(reasonLen > 1<<20) {\n      rfbClientLog(\"VNC connection failed, but sent reason length of %u exceeds limit of 1MB\",(unsigned int)reasonLen);\n      return;\n    }\n    reason = malloc(reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}","target":0,"flaw_line_index":0,"hash":"a15a2130-13dd-4d51-86ac-bf6405b51a23","idx":"699ce8be-26eb-4fb8-a383-bbf910d521bb"}
{"func_before":"mptctl_readtest (unsigned long arg)\n{\n\tstruct mpt_ioctl_test __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_test\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to read in mpt_ioctl_test struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_readtest() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_readtest called.\\n\",\n\t    ioc->name));\n\t\/* Fill in the data and return the structure to the calling\n\t * program\n\t *\/\n\n#ifdef MFCNT\n\tkarg.chip_type = ioc->mfcnt;","target":1,"flaw_line_index":0,"hash":"00e54809-786e-4ca0-ab02-fb0de4dd6565","idx":"ec4f8b6f-7684-44a6-a2d2-3e005ad98484"}
{"func_before":"mptctl_readtest (MPT_ADAPTER *ioc, unsigned long arg)\n{\n\tstruct mpt_ioctl_test __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_test\t karg;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to read in mpt_ioctl_test struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_readtest called.\\n\",\n\t    ioc->name));\n\t\/* Fill in the data and return the structure to the calling\n\t * program\n\t *\/\n\n#ifdef MFCNT\n\tkarg.chip_type = ioc->mfcnt;","target":0,"flaw_line_index":0,"hash":"49823af9-db9e-457c-b6a9-4541fa0c9531","idx":"8a043e22-d15d-4ab9-bb3b-05c3d26e706a"}
{"func_before":"NOEXPORT void reload_config() {\n    static int delay=10; \/* 10ms *\/\n#ifdef HAVE_CHROOT\n    struct stat sb;\n#endif \/* HAVE_CHROOT *\/\n\n    if(options_parse(CONF_RELOAD)) {\n        s_log(LOG_ERR, \"Failed to reload the configuration file\");\n        return;\n    }\n    unbind_ports();\n    log_flush(LOG_MODE_BUFFER);\n    \/* we don't close SINK_SYSLOG if chroot is enabled and\n     * there is no \/dev\/log inside it, which could allow\n     * openlog(3) to reopen the syslog socket later *\/\n    if(global_options.chroot_dir && stat(\"\/dev\/log\", &sb))\n        log_close(SINK_OUTFILE);\n    else\n#endif \/* HAVE_CHROOT *\/\n        log_close(SINK_SYSLOG|SINK_OUTFILE);\n    \/* there is no race condition here:\n     * client threads are not allowed to use global options *\/\n    options_free();\n    options_apply();\n    \/* we hope that a sane openlog(3) implementation won't\n     * attempt to reopen \/dev\/log if it's already open *\/\n    log_open(SINK_SYSLOG|SINK_OUTFILE);\n    log_flush(LOG_MODE_CONFIGURED);\n    ui_config_reloaded();\n    \/* we use \"|\" instead of \"||\" to attempt initialization of both subsystems *\/\n    if(bind_ports() | exec_connect_start()) {\n        s_poll_sleep(delay\/1000, delay%1000); \/* sleep to avoid log trashing *\/\n        signal_post(SIGNAL_RELOAD_CONFIG); \/* retry *\/\n        delay*=2;\n        if(delay > 10000) \/* 10s *\/\n            delay=10000;\n    } else {\n        delay=10; \/* 10ms *\/\n    }\n}","target":1,"flaw_line_index":0,"hash":"361a2c5f-acae-4549-a7fa-c60185813cf7","idx":"d64bbd21-f185-4e75-a071-ffd15bded6de"}
{"func_before":"NOEXPORT void reload_config() {\n    static int delay=10; \/* default of 10ms *\/\n#ifdef HAVE_CHROOT\n    struct stat sb;\n#endif \/* HAVE_CHROOT *\/\n\n    if(options_parse(CONF_RELOAD)) {\n        s_log(LOG_ERR, \"Failed to reload the configuration file\");\n        return;\n    }\n    unbind_ports();\n    log_flush(LOG_MODE_BUFFER);\n    \/* we don't close SINK_SYSLOG if chroot is enabled and\n     * there is no \/dev\/log inside it, which could allow\n     * openlog(3) to reopen the syslog socket later *\/\n    if(global_options.chroot_dir && stat(\"\/dev\/log\", &sb))\n        log_close(SINK_OUTFILE);\n    else\n#endif \/* HAVE_CHROOT *\/\n        log_close(SINK_SYSLOG|SINK_OUTFILE);\n    \/* there is no race condition here:\n     * client threads are not allowed to use global options *\/\n    options_free(1); \/* free the current options *\/\n    options_apply(); \/* apply the new options *\/\n    \/* we hope that a sane openlog(3) implementation won't\n     * attempt to reopen \/dev\/log if it's already open *\/\n    log_open(SINK_SYSLOG|SINK_OUTFILE);\n    log_flush(LOG_MODE_CONFIGURED);\n    ui_config_reloaded();\n    \/* we use \"|\" instead of \"||\" to attempt initialization of both subsystems *\/\n    if(bind_ports() | exec_connect_start()) { \/* failed *\/\n        unbind_ports();\n        s_poll_sleep(delay\/1000, delay%1000); \/* sleep to avoid log trashing *\/\n        signal_post(SIGNAL_RELOAD_CONFIG); \/* retry *\/\n        delay*=2;\n        if(delay > 10000) \/* limit to 10s *\/\n            delay=10000;\n    } else { \/* success *\/\n        delay=10; \/* reset back to 10ms *\/\n    }\n}","target":0,"flaw_line_index":0,"hash":"cf46c77c-3608-476d-8470-343d33d0bcac","idx":"6682e5ba-0a70-4f98-b037-f1e025a36789"}
{"func_before":"    flb_sds_t out_buf;\n    msgpack_sbuffer mp_sbuf;\n    msgpack_packer mp_pck;\n    int ret;\n    char *buf = NULL;\n    size_t buf_size;\n    int root_type = MSGPACK_OBJECT_ARRAY;\n    msgpack_unpacked result;\n    flb_sds_t error_msg = NULL;\n    int response = 200;\n    flb_sds_t input_name;\n    msgpack_object_array *inputs = NULL;\n    size_t off = 0;\n    int i;\n    \n\n    \/* initialize buffers *\/\n    msgpack_sbuffer_init(&mp_sbuf);\n    msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);\n\n    msgpack_unpacked_init(&result);\n    ret = flb_pack_json(request->data.data, request->data.len, &buf, &buf_size,\n                        &root_type, NULL);\n    if (ret == -1) {\n        goto unpack_error;\n        goto unpack_error;\n    }\n\n    for (i = 0; i < result.data.via.map.size; i++) {\n        if (result.data.via.map.ptr[i].val.type != MSGPACK_OBJECT_ARRAY) {\n            continue;\n        }\n        if (result.data.via.map.ptr[i].key.type != MSGPACK_OBJECT_STR) {\n            continue;\n        }\n        if (result.data.via.map.ptr[i].key.via.str.size < strlen(\"inputs\")) {\n            continue;\n        }\n        if (strncmp(result.data.via.map.ptr[i].key.via.str.ptr, \"inputs\", strlen(\"inputs\"))) {\n            continue;\n        }\n        inputs = &result.data.via.map.ptr[i].val.via.array;\n    }\n\n    if (inputs == NULL) {\n        response = 503;\n        error_msg = flb_sds_create(\"inputs not found\");\n        goto unpack_error;\n    }\n    \n    msgpack_pack_map(&mp_pck, 2);\n\n    msgpack_pack_str_with_body(&mp_pck, \"inputs\", strlen(\"inputs\"));\n    msgpack_pack_map(&mp_pck, inputs->size);\n\n    for (i = 0; i < inputs->size; i++) {\n        input_name = flb_sds_create_len(inputs->ptr[i].via.str.ptr, inputs->ptr[i].via.str.size);\n        msgpack_pack_str_with_body(&mp_pck, input_name, flb_sds_len(input_name));\n\n        if (inputs->ptr[i].type != MSGPACK_OBJECT_STR) {\n            msgpack_pack_map(&mp_pck, 1);\n            msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n            msgpack_pack_str_with_body(&mp_pck, \"error\", strlen(\"error\"));\n        }\n        else {\n            if (request->method == MK_METHOD_POST || request->method == MK_METHOD_GET) {\n                ret = msgpack_params_enable_trace((struct flb_hs *)data, &result, input_name);\n                if (ret != 0) {\n                    msgpack_pack_map(&mp_pck, 2);\n                    msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n                    msgpack_pack_str_with_body(&mp_pck, \"error\", strlen(\"error\"));\n                    msgpack_pack_str_with_body(&mp_pck, \"returncode\", strlen(\"returncode\"));\n                    msgpack_pack_int64(&mp_pck, ret);\n                }\n                else {\n                    msgpack_pack_map(&mp_pck, 1);\n                    msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n                    msgpack_pack_str_with_body(&mp_pck, \"ok\", strlen(\"ok\"));\n                }\n            }\n            else if (request->method == MK_METHOD_DELETE) {\n                disable_trace_input((struct flb_hs *)data, input_name);\n            }\n            else {\n                msgpack_pack_map(&mp_pck, 2);\n                msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n                msgpack_pack_str_with_body(&mp_pck, \"error\", strlen(\"error\"));\n                msgpack_pack_str_with_body(&mp_pck, \"message\", strlen(\"message\"));\n                msgpack_pack_str_with_body(&mp_pck, \"method not allowed\", strlen(\"method not allowed\"));\n            }\n        }\n    }\n\n    msgpack_pack_str_with_body(&mp_pck, \"result\", strlen(\"result\"));\nunpack_error:\n    if (buf != NULL) {\n        flb_free(buf);\n    }\n    msgpack_unpacked_destroy(&result);\n    if (response == 404) {\n        msgpack_pack_map(&mp_pck, 1);\n        msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n        msgpack_pack_str_with_body(&mp_pck, \"not found\", strlen(\"not found\"));\n    }\n    else if (response == 503) {\n        msgpack_pack_map(&mp_pck, 2);\n        msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n        msgpack_pack_str_with_body(&mp_pck, \"error\", strlen(\"error\"));\n        msgpack_pack_str_with_body(&mp_pck, \"message\", strlen(\"message\"));\n        if (error_msg) {\n            msgpack_pack_str_with_body(&mp_pck, error_msg, flb_sds_len(error_msg));\n            flb_sds_destroy(error_msg);\n        }\n        else {\n            msgpack_pack_str_with_body(&mp_pck, \"unknown error\", strlen(\"unknown error\"));\n        }\n    }\n    else {\n        msgpack_pack_map(&mp_pck, 1);\n        msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n        msgpack_pack_str_with_body(&mp_pck, \"ok\", strlen(\"ok\"));\n    }\n\n    \/* Export to JSON *\/\n    out_buf = flb_msgpack_raw_to_json_sds(mp_sbuf.data, mp_sbuf.size);\n    if (out_buf == NULL) {\n        out_buf = flb_sds_create(\"serialization error\");\n    }\n    msgpack_sbuffer_destroy(&mp_sbuf);\n\n    mk_http_status(request, response);","target":1,"flaw_line_index":0,"hash":"fd7ab514-982a-42cd-ac24-f4c236bed50d","idx":"fba1aad9-2e6c-426d-8797-64df4adef425"}
{"func_before":"    flb_sds_t out_buf;\n    msgpack_sbuffer mp_sbuf;\n    msgpack_packer mp_pck;\n    int ret;\n    char *buf = NULL;\n    size_t buf_size;\n    int root_type = MSGPACK_OBJECT_ARRAY;\n    msgpack_unpacked result;\n    flb_sds_t error_msg = NULL;\n    int response = 200;\n    const char *input_name;\n    ssize_t input_nlen;\n    msgpack_object_array *inputs = NULL;\n    size_t off = 0;\n    int i;\n\n    \/* initialize buffers *\/\n    msgpack_sbuffer_init(&mp_sbuf);\n    msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);\n\n    msgpack_unpacked_init(&result);\n    ret = flb_pack_json(request->data.data, request->data.len, &buf, &buf_size,\n                        &root_type, NULL);\n    if (ret == -1) {\n        goto unpack_error;\n        goto unpack_error;\n    }\n\n    for (i = 0; i < result.data.via.map.size; i++) {\n        if (result.data.via.map.ptr[i].val.type != MSGPACK_OBJECT_ARRAY) {\n            continue;\n        }\n        if (result.data.via.map.ptr[i].key.type != MSGPACK_OBJECT_STR) {\n            continue;\n        }\n        if (result.data.via.map.ptr[i].key.via.str.size < STR_INPUTS_LEN) {\n            continue;\n        }\n        if (strncmp(result.data.via.map.ptr[i].key.via.str.ptr, STR_INPUTS, STR_INPUTS_LEN)) {\n            continue;\n        }\n        inputs = &result.data.via.map.ptr[i].val.via.array;\n    }\n\n    if (inputs == NULL) {\n        response = 503;\n        error_msg = flb_sds_create(\"inputs not found\");\n        goto unpack_error;\n    }\n\n    msgpack_pack_map(&mp_pck, 2);\n\n    msgpack_pack_str_with_body(&mp_pck, STR_INPUTS, STR_INPUTS_LEN);\n    msgpack_pack_map(&mp_pck, inputs->size);\n\n    for (i = 0; i < inputs->size; i++) {\n\n        if (inputs->ptr[i].type != MSGPACK_OBJECT_STR || inputs->ptr[i].via.str.ptr == NULL) {\n            response = 503;\n            error_msg = flb_sds_create(\"invalid input\");\n            msgpack_sbuffer_clear(&mp_sbuf);\n            goto unpack_error;\n        }\n    }\n\n    for (i = 0; i < inputs->size; i++) {\n\n        input_name = inputs->ptr[i].via.str.ptr;\n        input_nlen = inputs->ptr[i].via.str.size;\n\n        msgpack_pack_str_with_body(&mp_pck, input_name, input_nlen);\n\n        if (request->method == MK_METHOD_POST) {\n\n            ret = msgpack_params_enable_trace((struct flb_hs *)data, &result,\n                                              input_name, input_nlen);\n\n            if (ret != 0) {\n                msgpack_pack_map(&mp_pck, 2);\n                msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n                msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_ERROR, HTTP_RESULT_ERROR_LEN);\n                msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_RETURNCODE,\n                                           HTTP_FIELD_RETURNCODE_LEN);\n                msgpack_pack_int64(&mp_pck, ret);\n            }\n            else {\n                msgpack_pack_map(&mp_pck, 1);\n                msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n                msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n            }\n        }\n        else if (request->method == MK_METHOD_DELETE) {\n            disable_trace_input((struct flb_hs *)data, input_name, input_nlen);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n        }\n        else {\n            msgpack_pack_map(&mp_pck, 2);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_ERROR, HTTP_RESULT_ERROR_LEN);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_MESSAGE, HTTP_FIELD_MESSAGE_LEN);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_METHODNOTALLOWED,\n                                       HTTP_RESULT_METHODNOTALLOWED_LEN);\n        }\n    }\n\n    msgpack_pack_str_with_body(&mp_pck, \"result\", strlen(\"result\"));\nunpack_error:\n    if (buf != NULL) {\n        flb_free(buf);\n    }\n    msgpack_unpacked_destroy(&result);\n    if (response == 404) {\n        msgpack_pack_map(&mp_pck, 1);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_NOTFOUND, HTTP_RESULT_NOTFOUND_LEN);\n    }\n    else if (response == 503) {\n        msgpack_pack_map(&mp_pck, 2);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_MESSAGE, HTTP_FIELD_MESSAGE_LEN);\n        if (error_msg) {\n            msgpack_pack_str_with_body(&mp_pck, error_msg, flb_sds_len(error_msg));\n            flb_sds_destroy(error_msg);\n        }\n        else {\n            msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_UNKNOWNERROR,\n                                       HTTP_RESULT_UNKNOWNERROR_LEN);\n        }\n    }\n    else {\n        msgpack_pack_map(&mp_pck, 1);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n    }\n\n    \/* Export to JSON *\/\n    out_buf = flb_msgpack_raw_to_json_sds(mp_sbuf.data, mp_sbuf.size);\n    if (out_buf == NULL) {\n        out_buf = flb_sds_create(\"serialization error\");\n    }\n    msgpack_sbuffer_destroy(&mp_sbuf);\n\n    mk_http_status(request, response);","target":0,"flaw_line_index":0,"hash":"15e2f4bb-0db3-4657-be00-185e3c7be750","idx":"09d2e1ee-e497-4cfb-8308-26b827a6ea7e"}
{"func_before":"bool SecurityManager::discovered_participant(IdentityToken&& remote_identity_token,\n        const GUID_t& remote_participant_key)\n{\n    IdentityHandle* remote_identity_handle = nullptr;\n    SecurityException exception;\n    AuthenticationStatus auth_status = AUTHENTICATION_INIT;\n\n    \/\/ Find information\n    mutex_.lock();\n    auto dp_it = discovered_participants_.find(remote_participant_key);\n\n    if(dp_it == discovered_participants_.end())\n    {\n            return false;\n        }\n    }\n    else\n    {\n        auth_status = dp_it->second.get_auth_status();\n\n        if(auth_status == AUTHENTICATION_INIT)\n            return false;\n    }\n\n    if(auth_status == AUTHENTICATION_REQUEST_NOT_SEND)\n    {\n        remote_identity_handle = dp_it->second.get_identity_handle();\n        assert(remote_identity_handle);\n    }\n    mutex_.unlock();\n\n    bool returnedValue = true;\n\n    \/\/ Maybe send request.\n    if(remote_identity_handle != nullptr)\n    {\n        returnedValue = on_request_not_send(remote_participant_key, remote_identity_handle);\n    }\n\n    return returnedValue;\n}","target":1,"flaw_line_index":0,"hash":"26f36e86-5f4a-40b4-b90d-d2c1bbc344db","idx":"a5191fbb-91f4-4152-ad58-5a2e2ccd6031"}
{"func_before":"bool SecurityManager::discovered_participant(IdentityToken&& remote_identity_token,\n        const GUID_t& remote_participant_key)\n{\n    if(authentication_plugin_ == nullptr)\n        return true;\n\n    IdentityHandle* remote_identity_handle = nullptr;\n    SecurityException exception;\n    AuthenticationStatus auth_status = AUTHENTICATION_INIT;\n\n    \/\/ Find information\n    mutex_.lock();\n    auto dp_it = discovered_participants_.find(remote_participant_key);\n\n    if(dp_it == discovered_participants_.end())\n    {\n        }\n    }\n    else\n    {\n        auth_status = dp_it->second.get_auth_status();\n\n        if(auth_status == AUTHENTICATION_INIT)\n            return false;\n    }\n\n    int64_t last_sequence_number = 0;\n\n    if(auth_status == AUTHENTICATION_REQUEST_NOT_SEND)\n    {\n        remote_identity_handle = dp_it->second.get_identity_handle();\n        assert(remote_identity_handle);\n        last_sequence_number = dp_it->second.get_last_sequence_number();\n\n    }\n    mutex_.unlock();\n\n    bool returnedValue = true;\n\n    \/\/ Maybe send request.\n    if(remote_identity_handle != nullptr)\n    {\n        returnedValue = on_process_handshake(remote_participant_key, AUTHENTICATION_REQUEST_NOT_SEND,\n                MessageIdentity(), HandshakeMessageToken(),\n                remote_identity_handle, nullptr, last_sequence_number);\n    }\n\n    return returnedValue;\n}","target":0,"flaw_line_index":0,"hash":"1cd5c14d-8fb4-41a4-9e8f-dd6b1969d6e1","idx":"2e103e99-9a70-4093-b532-1442848845ae"}
{"func_before":"spnego_gss_inquire_sec_context_by_oid(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_OID desired_object,\n\t\tgss_buffer_set_t *data_set)\n{\n\tOM_uint32 ret;\n\tret = gss_inquire_sec_context_by_oid(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    data_set);\n\treturn (ret);\n}","target":1,"flaw_line_index":0,"hash":"64745133-0762-4696-8d90-1b20423a282c","idx":"2273e446-7c32-4cb1-af5e-8140098f70ea"}
{"func_before":"spnego_gss_inquire_sec_context_by_oid(\n\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_OID desired_object,\n\t\tgss_buffer_set_t *data_set)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\t\/* There are no SPNEGO-specific OIDs for this function. *\/\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_UNAVAILABLE);\n\n\tret = gss_inquire_sec_context_by_oid(minor_status,\n\t\t\t    sc->ctx_handle,\n\t\t\t    desired_object,\n\t\t\t    data_set);\n\treturn (ret);\n}","target":0,"flaw_line_index":0,"hash":"dca03412-228b-4da7-8945-11a158c2ed37","idx":"c7cf8124-3ae4-4622-876f-789925d6c5f9"}
{"func_before":"inline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0) {\n      return 4;\n    }\n  }\n  return 0;\n}","target":1,"flaw_line_index":0,"hash":"0e78527d-7be8-4c9b-83bf-347f29e6493e","idx":"b0640490-1a55-467e-b788-65032c7195a9"}
{"func_before":"inline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0 && l >= 2) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0 && l >= 3) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0 && l >= 4) {\n      return 4;\n    }\n  }\n  return 0;\n}","target":0,"flaw_line_index":0,"hash":"13ade820-508e-4307-9e87-5f19a0612b4b","idx":"c5fee7e4-d977-4d0a-bf5b-0d2fc2f95f96"}
{"func_before":"void TestJlCompress::extractDir_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::newRow(\"simple\") << \"jlextdir.zip\" << (\n            QStringList() << \"test0.txt\" << \"testdir1\/test1.txt\"\n            << \"testdir2\/test2.txt\" << \"testdir2\/subdir\/test2sub.txt\");\n    QTest::newRow(\"separate dir\") << \"sepdir.zip\" << (\n            QStringList() << \"laj\/\" << \"laj\/lajfile.txt\");\n}","target":1,"flaw_line_index":0,"hash":"3d87dc9f-358f-4a36-9f63-90f01cfe51eb","idx":"a04f5369-39c2-4fe7-b5bf-ad52237d62ad"}
{"func_before":"void TestJlCompress::extractDir_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::addColumn<QStringList>(\"expectedExtracted\");\n    QTest::newRow(\"simple\") << \"jlextdir.zip\"\n        << (QStringList() << \"test0.txt\" << \"testdir1\/test1.txt\"\n            << \"testdir2\/test2.txt\" << \"testdir2\/subdir\/test2sub.txt\")\n        << (QStringList() << \"test0.txt\" << \"testdir1\/test1.txt\"\n            << \"testdir2\/test2.txt\" << \"testdir2\/subdir\/test2sub.txt\");\n    QTest::newRow(\"separate dir\") << \"sepdir.zip\"\n        << (QStringList() << \"laj\/\" << \"laj\/lajfile.txt\")\n        << (QStringList() << \"laj\/\" << \"laj\/lajfile.txt\");\n    QTest::newRow(\"Zip Slip\") << \"zipslip.zip\"\n        << (QStringList() << \"test0.txt\" << \"..\/zipslip.txt\")\n        << (QStringList() << \"test0.txt\");\n}","target":0,"flaw_line_index":0,"hash":"c90c83cc-6fcc-4f01-8d3a-59c50253a214","idx":"c19fcbe3-f9d6-4d1a-bbe7-fd95d90bbaab"}
{"func_before":"static void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tif (ctx->might_cancel) {\n\t\tctx->might_cancel = false;\n\t\tspin_lock(&cancel_lock);\n\t\tlist_del_rcu(&ctx->clist);\n\t\tspin_unlock(&cancel_lock);\n\t}\n}","target":1,"flaw_line_index":0,"hash":"9b27322b-4bf9-4c8a-b0d6-25e16f282d25","idx":"868c6764-138e-427c-a65a-e38df8797006"}
{"func_before":"static void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tspin_lock(&ctx->cancel_lock);\n\t__timerfd_remove_cancel(ctx);\n\tspin_unlock(&ctx->cancel_lock);\n}","target":0,"flaw_line_index":0,"hash":"d3731b0c-8a0d-40f3-a805-dd947d290abf","idx":"798644de-5be5-4e87-8371-8d4de32f095e"}
{"func_before":"static inline __attribute__((unused)) ssize_t fiobj_send_free(intptr_t uuid,\n                                                              FIOBJ o) {\n  fio_str_info_s s = fiobj_obj2cstr(o);\n  return fio_write2(uuid, .data.buffer = (void *)(o),\n                    .offset = (((intptr_t)s.data) - ((intptr_t)(o))),\n                    .length = s.len, .after.dealloc = fiobj4sock_dealloc);\n}","target":1,"flaw_line_index":0,"hash":"9f9816b6-0260-4d32-8aa0-2c56e8bfe3eb","idx":"0db68e35-c6cd-4bba-bd77-cf60ab46ed22"}
{"func_before":"static inline __attribute__((unused)) ssize_t fiobj_send_free(intptr_t uuid,\n                                                              FIOBJ o) {\n  fio_str_info_s s = fiobj_obj2cstr(o);\n  return fio_write2(uuid, .data.buffer = (void *)(o),\n                    .offset = (uintptr_t)(((intptr_t)s.data) - ((intptr_t)(o))),\n                    .length = s.len, .after.dealloc = fiobj4sock_dealloc);\n}","target":0,"flaw_line_index":0,"hash":"02ee7de4-51a1-4404-a639-d3a3e1f9641b","idx":"afcac3e1-570d-4ac1-9af8-c9a5487611b0"}
{"func_before":"static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rpcomp;\n\n\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"pcomp\");\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rpcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}","target":1,"flaw_line_index":0,"hash":"896d6943-7cd5-421c-bbbc-974d33b73a85","idx":"b371d5fc-0939-4cb1-9986-4df5f11dab43"}
{"func_before":"static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rpcomp;\n\n\tstrncpy(rpcomp.type, \"pcomp\", sizeof(rpcomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rpcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}","target":0,"flaw_line_index":0,"hash":"c3a71fe3-e030-4132-b322-88161856828e","idx":"c00d297d-b8f2-4900-8126-98838c13f196"}
{"func_before":"   if(index < CPSW_ALE_MAX_ENTRIES)\n   {\n      \/\/Clear the contents of the entry\n      entry.word2 = 0;\n      entry.word1 = 0;\n      entry.word0 = 0;\n\n      \/\/Update the ALE table\n      am335xEthWriteEntry(index, &entry);\n\n      \/\/Sucessful processing\n      error = NO_ERROR;\n   }\n   else\n   {\n      \/\/Entry not found\n      error = ERROR_NOT_FOUND;\n   }\n\n   \/\/Return status code\n   return error;","target":1,"flaw_line_index":0,"hash":"498e3504-099d-4c3c-8c9b-3b2c6ff1d0c3","idx":"d5572e29-5201-4e61-9619-ccef9739a026"}
{"func_before":"   if(index < CPSW_ALE_MAX_ENTRIES)\n   {\n      \/\/Clear the contents of the entry\n      entry.word2 = 0;\n      entry.word1 = 0;\n      entry.word0 = 0;\n\n      \/\/Update the ALE table\n      am335xEthWriteEntry(index, &entry);\n\n      \/\/Successful processing\n      error = NO_ERROR;\n   }\n   else\n   {\n      \/\/Entry not found\n      error = ERROR_NOT_FOUND;\n   }\n\n   \/\/Return status code\n   return error;","target":0,"flaw_line_index":0,"hash":"6a999f1d-9af2-4232-8714-249356c17bc0","idx":"54524753-f09b-4845-9941-7e3e54588a84"}
{"func_before":"int cp_cmlhs_onv(const g1_t r, const g2_t s, const g1_t sig[], const g2_t z[],\n\t\tconst g1_t a[], const g1_t c[], const bn_t msg, const char *data,\n\t\tconst g1_t h, const gt_t vk, const g2_t y[], const g2_t pk[],\n\t\tsize_t slen, int bls) {\n\tg1_t g1;\n\tg2_t g2;\n\tgt_t e, u, v;\n\tbn_t k, n;\n\tint len, dlen = strlen(data), result = 1;\n\tuint8_t *buf = RLC_ALLOCA(uint8_t, 1 + 8 * RLC_FP_BYTES + dlen);\n\n\tg1_null(g1);\n\tg2_null(g2);\n\tgt_null(e);\n\tgt_null(u);\n\tgt_null(v);\n\tbn_null(k);\n\tbn_null(n);\n\n\tRLC_TRY {","target":1,"flaw_line_index":0,"hash":"8662d9fb-55e6-4dc8-9a49-3f6dd653c94c","idx":"a9848591-5964-4546-83d1-6dc5cc2c001a"}
{"func_before":"int cp_cmlhs_onv(const g1_t r, const g2_t s, const g1_t sig[], const g2_t z[],\n\t\tconst g1_t a[], const g1_t c[], const bn_t msg, const char *data,\n\t\tconst g1_t h, const gt_t vk, const g2_t y[], const g2_t pk[],\n\t\tsize_t slen, int bls) {\n\tg1_t g1;\n\tg2_t g2;\n\tgt_t e, u, v;\n\tbn_t k, n;\n\tsize_t len, dlen = strlen(data);\n\tuint8_t *buf = RLC_ALLOCA(uint8_t, 1 + 8 * RLC_FP_BYTES + dlen);\n\tint result = 1;\n\n\tg1_null(g1);\n\tg2_null(g2);\n\tgt_null(e);\n\tgt_null(u);\n\tgt_null(v);\n\tbn_null(k);\n\tbn_null(n);\n\n\tRLC_TRY {","target":0,"flaw_line_index":0,"hash":"9121129b-52b3-412a-96e4-87b5bac7d437","idx":"30945700-db06-4735-901f-624c3b6de9ff"}
{"func_before":"\n        r = dlopen_elf();\n        if (r < 0)\n                return r;\n\n        r = RET_NERRNO(pipe2(error_pipe, O_CLOEXEC|O_NONBLOCK));\n        if (r < 0)\n                return r;\n\n        if (ret) {\n                r = RET_NERRNO(pipe2(return_pipe, O_CLOEXEC));\n                if (r < 0)\n                        return r;\n        }\n\n        if (ret_package_metadata) {\n                r = RET_NERRNO(pipe2(json_pipe, O_CLOEXEC));\n                if (r < 0)\n                        return r;\n        }\n\n        \/* Parsing possibly malformed data is crash-happy, so fork. In case we crash,\n         * the core file will not be lost, and the messages will still be attached to\n         * the journal. Reading the elf object might be slow, but it still has an upper\n         * bound since the core files have an upper size limit. It's also not doing any\n         * system call or interacting with the system in any way, besides reading from\n         * the file descriptor and writing into these four pipes. *\/\n                        r = RET_NERRNO(prctl(PR_SET_DUMPABLE, 0));\n                        if (r < 0)\n                                goto child_fail;\n                }\n\n                r = parse_elf(fd, executable, ret ? &buf : NULL, ret_package_metadata ? &package_metadata : NULL);\n                if (r < 0)\n                        goto child_fail;\n\n                if (buf) {\n                        r = loop_write(return_pipe[1], buf, strlen(buf), false);\n                        if (r < 0)\n                                goto child_fail;\n\n                        return_pipe[1] = safe_close(return_pipe[1]);\n                }\n\n                if (package_metadata) {\n                        _cleanup_fclose_ FILE *json_out = NULL;\n\n                        json_out = take_fdopen(&json_pipe[1], \"w\");\n                        if (!json_out) {\n                                r = -errno;\n                                goto child_fail;\n                        }\n\n                        json_variant_dump(package_metadata, JSON_FORMAT_FLUSH, json_out, NULL);\n                }\n\n                _exit(EXIT_SUCCESS);\n\n        child_fail:\n                (void) write(error_pipe[1], &r, sizeof(r));\n                _exit(EXIT_FAILURE);\n        }\n\n        error_pipe[1] = safe_close(error_pipe[1]);\n\n        if (ret_package_metadata) {\n                _cleanup_fclose_ FILE *json_in = NULL;\n\n                json_in = take_fdopen(&json_pipe[0], \"r\");\n                if (!json_in)\n                        return -errno;\n\n                r = json_parse_file(json_in, NULL, 0, &package_metadata, NULL, NULL);\n                if (r < 0 && r != -ENODATA) \/* ENODATA: json was empty, so we got nothing, but that's ok *\/\n                        return r;\n        }\n\n        if (ret)\n                *ret = TAKE_PTR(buf);\n        if (ret_package_metadata)\n                *ret_package_metadata = TAKE_PTR(package_metadata);\n\n        return 0;\n}","target":1,"flaw_line_index":0,"hash":"6bf1904b-00d4-4f33-8088-50da7a142927","idx":"0d673f8f-270d-4a78-b418-e4d3a2f30b0d"}
{"func_before":"\n        r = dlopen_elf();\n        if (r < 0)\n                return r;\n\n        r = RET_NERRNO(pipe2(error_pipe, O_CLOEXEC|O_NONBLOCK));\n        if (r < 0)\n                return r;\n\n        if (ret) {\n                r = RET_NERRNO(pipe2(return_pipe, O_CLOEXEC|O_NONBLOCK));\n                if (r < 0)\n                        return r;\n        }\n\n        if (ret_package_metadata) {\n                r = RET_NERRNO(pipe2(json_pipe, O_CLOEXEC|O_NONBLOCK));\n                if (r < 0)\n                        return r;\n        }\n\n        \/* Parsing possibly malformed data is crash-happy, so fork. In case we crash,\n         * the core file will not be lost, and the messages will still be attached to\n         * the journal. Reading the elf object might be slow, but it still has an upper\n         * bound since the core files have an upper size limit. It's also not doing any\n         * system call or interacting with the system in any way, besides reading from\n         * the file descriptor and writing into these four pipes. *\/\n                        r = RET_NERRNO(prctl(PR_SET_DUMPABLE, 0));\n                        if (r < 0)\n                                goto child_fail;\n                }\n\n                r = parse_elf(fd, executable, ret ? &buf : NULL, ret_package_metadata ? &package_metadata : NULL);\n                if (r < 0)\n                        goto child_fail;\n\n                if (buf) {\n                        size_t len = strlen(buf);\n\n                        if (len > COREDUMP_PIPE_MAX) {\n                                \/* This is iffy. A backtrace can be a few hundred kilobytes, but too much is\n                                 * too much. Let's log a warning and ignore the rest. *\/\n                                log_warning(\"Generated backtrace is %zu bytes (more than the limit of %u bytes), backtrace will be truncated.\",\n                                            len, COREDUMP_PIPE_MAX);\n                                len = COREDUMP_PIPE_MAX;\n                        }\n\n                        \/* Bump the space for the returned string.\n                         * Failure is ignored, because partial output is still useful. *\/\n                        (void) fcntl(return_pipe[1], F_SETPIPE_SZ, len);\n\n                        r = loop_write(return_pipe[1], buf, len, false);\n                        if (r == -EAGAIN)\n                                log_warning(\"Write failed, backtrace will be truncated.\");\n                        else if (r < 0)\n                                goto child_fail;\n\n                        return_pipe[1] = safe_close(return_pipe[1]);\n                }\n\n                if (package_metadata) {\n                        _cleanup_fclose_ FILE *json_out = NULL;\n\n                        \/* Bump the space for the returned string. We don't know how much space we'll need in\n                         * advance, so we'll just try to write as much as possible and maybe fail later. *\/\n                        (void) fcntl(json_pipe[1], F_SETPIPE_SZ, COREDUMP_PIPE_MAX);\n\n                        json_out = take_fdopen(&json_pipe[1], \"w\");\n                        if (!json_out) {\n                                r = -errno;\n                                goto child_fail;\n                        }\n\n                        r = json_variant_dump(package_metadata, JSON_FORMAT_FLUSH, json_out, NULL);\n                        if (r < 0)\n                                log_warning_errno(r, \"Failed to write JSON package metadata, ignoring: %m\");\n                }\n\n                _exit(EXIT_SUCCESS);\n\n        child_fail:\n                (void) write(error_pipe[1], &r, sizeof(r));\n                _exit(EXIT_FAILURE);\n        }\n\n        error_pipe[1] = safe_close(error_pipe[1]);\n\n        if (ret_package_metadata) {\n                _cleanup_fclose_ FILE *json_in = NULL;\n\n                json_in = take_fdopen(&json_pipe[0], \"r\");\n                if (!json_in)\n                        return -errno;\n\n                r = json_parse_file(json_in, NULL, 0, &package_metadata, NULL, NULL);\n                if (r < 0 && r != -ENODATA) \/* ENODATA: json was empty, so we got nothing, but that's ok *\/\n                        log_warning_errno(r, \"Failed to read or parse json metadata, ignoring: %m\");\n        }\n\n        if (ret)\n                *ret = TAKE_PTR(buf);\n        if (ret_package_metadata)\n                *ret_package_metadata = TAKE_PTR(package_metadata);\n\n        return 0;\n}","target":0,"flaw_line_index":0,"hash":"1a9ae131-9392-4700-8494-761041c0b038","idx":"b4e81c04-757e-4c9f-afe5-33339a78b3fb"}
{"func_before":"void SmallVectorBase::grow_pod(void *FirstEl, size_t MinCapacity,\n                               size_t TSize) {\n  \/\/ Ensure we can fit the new capacity in 32 bits.\n  if (MinCapacity > UINT32_MAX)\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n\n  size_t NewCapacity = 2 * capacity() + 1; \/\/ Always grow.\n  NewCapacity =\n      std::min(std::max(NewCapacity, MinCapacity), size_t(UINT32_MAX));\n\n  void *NewElts;\n  if (BeginX == FirstEl) {\n    NewElts = safe_malloc(NewCapacity * TSize);\n\n    \/\/ Copy the elements over.  No need to run dtors on PODs.\n    memcpy(NewElts, this->BeginX, size() * TSize);\n  } else {\n    \/\/ If this wasn't grown from the inline copy, grow the allocated space.\n    NewElts = safe_realloc(this->BeginX, NewCapacity * TSize);","target":1,"flaw_line_index":0,"hash":"aace2085-cebc-49ab-bcc5-7e0d202381db","idx":"700abac2-f2aa-43b4-82b8-6bc04adab13d"}
{"func_before":"void SmallVectorBase::grow_pod(void *FirstEl, size_t MinCapacity,\n                               size_t TSize) {\n  constexpr size_t MinGrowth = 1;\n  size_t NewCapacity = 2 * capacity() + MinGrowth; \/\/ Always grow.\n  NewCapacity = static_cast<unsigned>(std::max(NewCapacity, MinCapacity));\n\n  \/\/ Ensure that NewCapacity did not overflow an unsigned int,\n  \/\/ and that the capacity in bytes will not overflow a size_t.\n  if (NewCapacity <= this->capacity() ||\n      NewCapacity < MinCapacity ||\n      NewCapacity > size_t(-1) \/ TSize)\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n\n  void *NewElts;\n  if (BeginX == FirstEl) {\n    NewElts = safe_malloc(NewCapacity * TSize);\n\n    \/\/ Copy the elements over.  No need to run dtors on PODs.\n    memcpy(NewElts, this->BeginX, size() * TSize);\n  } else {\n    \/\/ If this wasn't grown from the inline copy, grow the allocated space.\n    NewElts = safe_realloc(this->BeginX, NewCapacity * TSize);","target":0,"flaw_line_index":0,"hash":"5f4a2980-7f0f-41ca-88a3-ee46ae42aa6b","idx":"5c0d5390-5366-4707-ae66-40d8d2595f72"}
{"func_before":"\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\n\t\/* check the quota and attach the new data *\/\n\tzap = upayload;\n\n\tret = key_payload_reserve(key, datalen);\n\n\tif (ret == 0) {\n\t\t\/* attach the new data, displacing the old *\/\n\t\tzap = key->payload.data[0];\n\t\trcu_assign_keypointer(key, upayload);\n\t\tkey->expiry = 0;\n\t}\n\n\tif (zap)\n\t\tkfree_rcu(zap, rcu);\n\nerror:\n\treturn ret;\n}","target":1,"flaw_line_index":0,"hash":"87f50c24-7cf1-4f8a-990c-cfc07d717b88","idx":"e61d02dc-38f4-42f8-818a-cb2f150a0c42"}
{"func_before":"\tupayload->datalen = datalen;\n\tmemcpy(upayload->data, prep->data, datalen);\n\n\t\/* check the quota and attach the new data *\/\n\tzap = upayload;\n\n\tret = key_payload_reserve(key, datalen);\n\n\tif (ret == 0) {\n\t\t\/* attach the new data, displacing the old *\/\n\t\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\t\tzap = key->payload.data[0];\n\t\telse\n\t\t\tzap = NULL;\n\t\trcu_assign_keypointer(key, upayload);\n\t\tkey->expiry = 0;\n\t}\n\n\tif (zap)\n\t\tkfree_rcu(zap, rcu);\n\nerror:\n\treturn ret;\n}","target":0,"flaw_line_index":0,"hash":"09b5ffb3-4f3a-4fe9-ae6f-e42b219b49b7","idx":"bb19a86d-c360-4bae-8246-1ee49fd653ac"}
{"func_before":"size_t compile_tree(struct filter_op **fop)\n{\n   int i = 1;\n   struct filter_op *array = NULL;\n   struct unfold_elm *ue;\n\n   BUG_IF(tree_root == NULL);\n  \n   fprintf(stdout, \" Unfolding the meta-tree \");\n   fflush(stdout);\n     \n   \/* start the recursion on the tree *\/\n   unfold_blk(&tree_root);\n\n   fprintf(stdout, \" done.\\n\\n\");\n\n   \/* substitute the virtual labels with real offsets *\/","target":1,"flaw_line_index":0,"hash":"05de9fb0-e569-4903-8f2e-36b0e1e161ad","idx":"686ad1bd-0e40-4677-b478-0126c29fa705"}
{"func_before":"size_t compile_tree(struct filter_op **fop)\n{\n   int i = 1;\n   struct filter_op *array = NULL;\n   struct unfold_elm *ue;\n\n   \/\/ invalid file\n   if (tree_root == NULL)\n      return 0;\n  \n   fprintf(stdout, \" Unfolding the meta-tree \");\n   fflush(stdout);\n     \n   \/* start the recursion on the tree *\/\n   unfold_blk(&tree_root);\n\n   fprintf(stdout, \" done.\\n\\n\");\n\n   \/* substitute the virtual labels with real offsets *\/","target":0,"flaw_line_index":0,"hash":"80cc4cf9-e625-4c11-87fe-3667ae074c9a","idx":"319bee4e-c3d9-408c-9a76-7d3947a5005e"}
{"func_before":"modify_principal_2_svc(mprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    restriction_t                   *rp;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n                                          arg->mask);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_modify_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","target":1,"flaw_line_index":0,"hash":"dda1f74e-35fa-491d-b272-9b2954086b44","idx":"97976315-06a0-419d-903b-8c6885136953"}
{"func_before":"modify_principal_2_svc(mprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    restriction_t                   *rp;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_modify_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","target":0,"flaw_line_index":0,"hash":"feeb1b65-506c-4061-9efa-f3b71bd00403","idx":"7a885076-3d87-47de-8ff5-23bc80055f0d"}
{"func_before":"\torder = get_order(num);\nretry:\n\tret_sz = 1 << (PAGE_SHIFT + order);\n\n\tfor (k = 0, rem_sz = blk_size; rem_sz > 0 && k < mx_sc_elems;\n\t     k++, rem_sz -= ret_sz) {\n\n\t\tnum = (rem_sz > scatter_elem_sz_prev) ?\n\t\t\tscatter_elem_sz_prev : rem_sz;\n\n\t\tschp->pages[k] = alloc_pages(gfp_mask, order);\n\t\tif (!schp->pages[k])\n\t\t\tgoto out;\n\n\t\tif (num == scatter_elem_sz_prev) {\n\t\t\tif (unlikely(ret_sz > scatter_elem_sz_prev)) {\n\t\t\t\tscatter_elem_sz = ret_sz;\n\t\t\t\tscatter_elem_sz_prev = ret_sz;\n\t\t\t}\n\t\t}\n","target":1,"flaw_line_index":0,"hash":"224d0cbf-8537-4450-84d2-27c061b86038","idx":"a48e4664-f88a-4438-aefa-feff540e241a"}
{"func_before":"\torder = get_order(num);\nretry:\n\tret_sz = 1 << (PAGE_SHIFT + order);\n\n\tfor (k = 0, rem_sz = blk_size; rem_sz > 0 && k < mx_sc_elems;\n\t     k++, rem_sz -= ret_sz) {\n\n\t\tnum = (rem_sz > scatter_elem_sz_prev) ?\n\t\t\tscatter_elem_sz_prev : rem_sz;\n\n\t\tschp->pages[k] = alloc_pages(gfp_mask | __GFP_ZERO, order);\n\t\tif (!schp->pages[k])\n\t\t\tgoto out;\n\n\t\tif (num == scatter_elem_sz_prev) {\n\t\t\tif (unlikely(ret_sz > scatter_elem_sz_prev)) {\n\t\t\t\tscatter_elem_sz = ret_sz;\n\t\t\t\tscatter_elem_sz_prev = ret_sz;\n\t\t\t}\n\t\t}\n","target":0,"flaw_line_index":0,"hash":"6e7b9bf6-8579-4653-8d0f-1aa338b8279d","idx":"bb05543e-b454-4080-b29f-69d33df6c257"}
{"func_before":"\n  \/* The argument should consist of 2 comma separated values:\n     1) resolution\n     2) tile number\n     3) pixel index in x direction\n     4) pixel index in y direction\n  *\/\n\n  if( session->loglevel >= 3 ) (*session->logfile) << \"SPECTRA handler reached\" << endl;\n\n  int resolution, tile, x, y;\n\n\n  \/\/ Time this command\n  if( session->loglevel >= 2 ) command_timer.start();\n\n\n  \/\/ Parse the argument list\n  string arg = argument;\n  int delimitter = arg.find( \",\" );\n  resolution = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  tile = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  x = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  y = atoi( arg.substr(0,arg.length()).c_str() );\n\n  if( session->loglevel >= 5 ){ \n    (*session->logfile) << \"SPECTRA :: resolution: \" << resolution\n\t\t\t<< \", tile: \" << tile\n\t\t\t<< \", x: \" << x\n\t\t\t<< \", y: \" << y << endl;\n  }\n\n  \/\/ Make sure our x,y coordinates are within the tile dimensions\n  if( x < 0 || x >= (int)(*session->image)->getTileWidth() ||","target":1,"flaw_line_index":0,"hash":"172ad40b-691b-43a9-8263-3bc865ae5634","idx":"58b957b2-8f66-438f-8197-7170a0c4be08"}
{"func_before":"\n  \/* The argument should consist of 2 comma separated values:\n     1) resolution\n     2) tile number\n     3) pixel index in x direction\n     4) pixel index in y direction\n  *\/\n\n  if( session->loglevel >= 3 ) (*session->logfile) << \"SPECTRA handler reached\" << endl;\n\n\n  \/\/ Make sure we have set our image\n  this->session = session;\n  checkImage();\n\n\n  \/\/ Time this command\n  if( session->loglevel >= 2 ) command_timer.start();\n\n\n  \/\/ Parse the argument list\n  string arg = argument;\n  int delimitter = arg.find( \",\" );\n  int resolution = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  int tile = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  int x = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  int y = atoi( arg.substr(0,arg.length()).c_str() );\n\n  if( session->loglevel >= 5 ){ \n    (*session->logfile) << \"SPECTRA :: resolution: \" << resolution\n\t\t\t<< \", tile: \" << tile\n\t\t\t<< \", x: \" << x\n\t\t\t<< \", y: \" << y << endl;\n  }\n\n  \/\/ Make sure our x,y coordinates are within the tile dimensions\n  if( x < 0 || x >= (int)(*session->image)->getTileWidth() ||","target":0,"flaw_line_index":0,"hash":"99eb5773-9dfa-4daa-b9ef-43a839769546","idx":"880c214e-ceab-43a5-ba69-eb96d5efe239"}
{"func_before":"\t\tmnt->mnt_group_id = old->mnt_group_id;\n\n\tif ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {\n\t\terr = mnt_alloc_group_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);\n\t\/* Don't allow unprivileged users to change mount flags *\/\n\tif ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n\n\t\/* Don't allow unprivileged users to reveal what is under a mount *\/\n\tif ((flag & CL_UNPRIVILEGED) && list_empty(&old->mnt_expire))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCKED;\n\n\tatomic_inc(&sb->s_active);\n\tmnt->mnt.mnt_sb = sb;\n\tmnt->mnt.mnt_root = dget(root);\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;","target":1,"flaw_line_index":0,"hash":"a3f263d1-1c7d-4500-bbe7-8130b1396a67","idx":"36137a81-27c9-4a5f-8451-1336c90891d3"}
{"func_before":"\t\tmnt->mnt_group_id = old->mnt_group_id;\n\n\tif ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {\n\t\terr = mnt_alloc_group_id(mnt);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);\n\t\/* Don't allow unprivileged users to change mount flags *\/\n\tif (flag & CL_UNPRIVILEGED) {\n\t\tmnt->mnt.mnt_flags |= MNT_LOCK_ATIME;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_READONLY)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NODEV)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NODEV;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOSUID)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOSUID;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOEXEC)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOEXEC;\n\t}\n\n\t\/* Don't allow unprivileged users to reveal what is under a mount *\/\n\tif ((flag & CL_UNPRIVILEGED) && list_empty(&old->mnt_expire))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCKED;\n\n\tatomic_inc(&sb->s_active);\n\tmnt->mnt.mnt_sb = sb;\n\tmnt->mnt.mnt_root = dget(root);\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;","target":0,"flaw_line_index":0,"hash":"86422d50-0fd6-4a39-95a7-9d96975a5cf5","idx":"3e11cacb-375e-4078-a106-a018effd46a2"}
{"func_before":"int snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n\t\tconst void *data, size_t datalen)\n{\n\tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n\t__be32 *pdata = (__be32 *)data;\n\n\tif (*pdata == ctx->from) {\n\t\tpr_debug(\"%s: %pI4 to %pI4\\n\", __func__,\n\t\t\t (void *)&ctx->from, (void *)&ctx->to);\n\n\t\tif (*ctx->check)\n\t\t\tfast_csum(ctx, (unsigned char *)data - ctx->begin);\n\t\t*pdata = ctx->to;\n\t}\n\n\treturn 1;","target":1,"flaw_line_index":0,"hash":"1f758eb8-6f23-4b70-baad-71eb5a459a9e","idx":"8d27da19-ff59-457c-accd-0732219c8f30"}
{"func_before":"int snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n\t\tconst void *data, size_t datalen)\n{\n\tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n\t__be32 *pdata;\n\n\tif (datalen != 4)\n\t\treturn -EINVAL;\n\tpdata = (__be32 *)data;\n\tif (*pdata == ctx->from) {\n\t\tpr_debug(\"%s: %pI4 to %pI4\\n\", __func__,\n\t\t\t (void *)&ctx->from, (void *)&ctx->to);\n\n\t\tif (*ctx->check)\n\t\t\tfast_csum(ctx, (unsigned char *)data - ctx->begin);\n\t\t*pdata = ctx->to;\n\t}\n\n\treturn 1;","target":0,"flaw_line_index":0,"hash":"caa69243-b878-4d62-b9c5-ef5787b46e53","idx":"3eb243e7-eb27-484f-b35a-595c40f7ae34"}
{"func_before":"        case YYJSON_TYPE_OBJ: {\n            usize len = unsafe_yyjson_get_len(lhs);\n            if (len != unsafe_yyjson_get_len(rhs)) return false;\n            if (len > 0) {\n                yyjson_obj_iter iter;\n                yyjson_obj_iter_init(rhs, &iter);\n                lhs = unsafe_yyjson_get_first(lhs);\n                while (len-- > 0) {\n                    rhs = yyjson_obj_iter_getn(&iter, lhs->uni.str,\n                                               unsafe_yyjson_get_len(lhs));\n                    if (!rhs || !unsafe_yyjson_equals(lhs + 1, rhs))\n                        return false;\n                    lhs = unsafe_yyjson_get_next(lhs + 1);\n                }\n            }\n            \/* yyjson allows duplicate keys, so the check may be inaccurate *\/\n            return true;\n        }\n        \n        case YYJSON_TYPE_ARR: {\n            usize len = unsafe_yyjson_get_len(lhs);\n            if (len != unsafe_yyjson_get_len(rhs)) return false;","target":1,"flaw_line_index":0,"hash":"2059cb66-8219-4cca-83b4-f39d3486159e","idx":"708eb575-1ad9-4922-86e4-59566e1e01c1"}
{"func_before":"        case YYJSON_TYPE_OBJ: {\n            usize len = unsafe_yyjson_get_len(lhs);\n            if (len != unsafe_yyjson_get_len(rhs)) return false;\n            if (len > 0) {\n                yyjson_obj_iter iter;\n                yyjson_obj_iter_init(rhs, &iter);\n                lhs = unsafe_yyjson_get_first(lhs);\n                while (len-- > 0) {\n                    rhs = yyjson_obj_iter_getn(&iter, lhs->uni.str,\n                                               unsafe_yyjson_get_len(lhs));\n                    if (!rhs) return false;\n                    if (!unsafe_yyjson_equals(lhs + 1, rhs)) return false;\n                    lhs = unsafe_yyjson_get_next(lhs + 1);\n                }\n            }\n            \/* yyjson allows duplicate keys, so the check may be inaccurate *\/\n            return true;\n        }\n        \n        case YYJSON_TYPE_ARR: {\n            usize len = unsafe_yyjson_get_len(lhs);\n            if (len != unsafe_yyjson_get_len(rhs)) return false;","target":0,"flaw_line_index":0,"hash":"48d4006a-ed59-4789-a16a-39bb630e3ef7","idx":"6cdbe352-3330-4655-aecd-858b6f7dca7a"}
{"func_before":"                                      return_list, return_size,\n                                      persistent ? 1 : 0);\n  } else {\n    String enc = encoding.toString();\n    ret = php_mb_parse_encoding_list(enc.data(), enc.size(),\n                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list && *return_list) {\n      free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;\n}","target":1,"flaw_line_index":0,"hash":"2cb3a205-e053-455c-8b72-929f52326853","idx":"f042a4a8-4e25-443a-a270-b738936f269d"}
{"func_before":"                                      return_list, return_size,\n                                      persistent ? 1 : 0);\n  } else {\n    String enc = encoding.toString();\n    ret = php_mb_parse_encoding_list(enc.data(), enc.size(),\n                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list && *return_list) {\n      req::free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;\n}","target":0,"flaw_line_index":0,"hash":"096304f3-5913-447d-b9d0-432f15fa827e","idx":"2efc3041-611e-48c5-b3cb-388a90f561a9"}
{"func_before":"static s32 gf_media_vvc_read_sps_bs_internal(GF_BitStream *bs, VVCState *vvc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id;\n\tu32 i, CtbSizeY;\n\tVVC_SPS *sps;\n\tu8 sps_ptl_dpb_hrd_params_present_flag;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\tsps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif (sps_id >= 16) {\n\t\treturn -1;\n\t}\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif (vps_id >= 16) {\n\t\treturn -1;\n\t}\n\tif (!vps_id && !vvc->vps[0].state) {\n\t\tvvc->vps[0].state = 1;\n\t\tvvc->vps[0].num_ptl = 1;\n\t\tvvc->vps[0].max_layers = 1;\n\t\tvvc->vps[0].all_layers_independent = 1;\n\t}\n\n\tsps = &vvc->sps[sps_id];","target":1,"flaw_line_index":0,"hash":"83b0ba5d-4454-4c2e-b532-0c3f099a2d8f","idx":"28b36ba3-ad29-4c42-a948-7029b5f7aeba"}
{"func_before":"static s32 gf_media_vvc_read_sps_bs_internal(GF_BitStream *bs, VVCState *vvc, u8 layer_id, u32 *vui_flag_pos)\n{\n\ts32 vps_id, sps_id;\n\tu32 i, CtbSizeY;\n\tVVC_SPS *sps;\n\tu8 sps_ptl_dpb_hrd_params_present_flag;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\tsps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif ((sps_id<0) || (sps_id >= 16)) {\n\t\treturn -1;\n\t}\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif ((vps_id<0) || (vps_id >= 16)) {\n\t\treturn -1;\n\t}\n\tif (!vps_id && !vvc->vps[0].state) {\n\t\tvvc->vps[0].state = 1;\n\t\tvvc->vps[0].num_ptl = 1;\n\t\tvvc->vps[0].max_layers = 1;\n\t\tvvc->vps[0].all_layers_independent = 1;\n\t}\n\n\tsps = &vvc->sps[sps_id];","target":0,"flaw_line_index":0,"hash":"756f9eb7-22c4-49e6-ba91-b591b2c7e078","idx":"8ed21245-677a-4a0f-b2be-907acf582908"}
{"func_before":"\t\tif (!controller)\n\t\t\treturn -EIO;\n\n\t\tcgroup = find_cgroup_in_path(path);\n\t\tif (!cgroup) {\n\t\t\t\/* this is just \/cgroup\/controller, return its contents *\/\n\t\t\tcgroup = \"\/\";\n\t\t}\n\t}\n\n\tif (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {\n\t\treturn -EACCES;\n\t}\n\n\t\/* we'll free this at cg_releasedir *\/\n\tdir_info = malloc(sizeof(*dir_info));\n\tif (!dir_info)\n\t\treturn -ENOMEM;\n\tdir_info->controller = must_copy_string(controller);\n\tdir_info->cgroup = must_copy_string(cgroup);\n\tdir_info->type = LXC_TYPE_CGDIR;\n\tdir_info->buf = NULL;","target":1,"flaw_line_index":0,"hash":"1660649a-9730-4a44-a681-111bf4189281","idx":"a71b0e09-d444-4cae-a1fa-53584c971b1a"}
{"func_before":"\t\tif (!controller)\n\t\t\treturn -EIO;\n\n\t\tcgroup = find_cgroup_in_path(path);\n\t\tif (!cgroup) {\n\t\t\t\/* this is just \/cgroup\/controller, return its contents *\/\n\t\t\tcgroup = \"\/\";\n\t\t}\n\t}\n\n\tif (cgroup) {\n\t\tif (!caller_may_see_dir(fc->pid, controller, cgroup))\n\t\t\treturn -ENOENT;\n\t\tif (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))\n\t\t\treturn -EACCES;\n\t}\n\n\t\/* we'll free this at cg_releasedir *\/\n\tdir_info = malloc(sizeof(*dir_info));\n\tif (!dir_info)\n\t\treturn -ENOMEM;\n\tdir_info->controller = must_copy_string(controller);\n\tdir_info->cgroup = must_copy_string(cgroup);\n\tdir_info->type = LXC_TYPE_CGDIR;\n\tdir_info->buf = NULL;","target":0,"flaw_line_index":0,"hash":"00aa676d-3dd1-493f-bdc1-c02578c5d2ef","idx":"74857eb2-55a4-4888-b11c-0e4b3f964f36"}
{"func_before":"\tint ret;\n\tint i;\n\n\t*rcmd = NULL;\n\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tif (ret)\n\t\treturn -EFAULT;\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > 33)\n\t\t\t\/* the command may now also take up the space\n\t\t\t * initially intended for the reply & the\n\t\t\t * reply count. Needed for long 82078 commands\n\t\t\t * such as RESTORE, which takes ... 17 command\n\t\t\t * bytes. Murphy's law #137: When you reserve\n\t\t\t * 16 bytes for a structure, you'll one day\n\t\t\t * discover that you really need 17...\n\t\t\t *\/\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < 16; i++)\n\t\tptr->reply[i] = 0;\n\tptr->resultcode = 0;\n\tptr->kernel_data = NULL;\n\n\tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}","target":1,"flaw_line_index":0,"hash":"561a94e1-fe14-4024-87af-6737f0726606","idx":"0c62a1e3-cda6-4c1a-80a0-8287203f392f"}
{"func_before":"\tint i;\n\n\t*rcmd = NULL;\n\nloop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tptr->kernel_data = NULL;\n\tif (ret)\n\t\treturn -EFAULT;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > 33)\n\t\t\t\/* the command may now also take up the space\n\t\t\t * initially intended for the reply & the\n\t\t\t * reply count. Needed for long 82078 commands\n\t\t\t * such as RESTORE, which takes ... 17 command\n\t\t\t * bytes. Murphy's law #137: When you reserve\n\t\t\t * 16 bytes for a structure, you'll one day\n\t\t\t * discover that you really need 17...\n\t\t\t *\/\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < 16; i++)\n\t\tptr->reply[i] = 0;\n\tptr->resultcode = 0;\n\n\tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);\n\t\tfallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);\n\t\tif (!ptr->kernel_data)\n\t\t\treturn -ENOMEM;\n\t\tptr->buffer_length = ptr->length;\n\t}","target":0,"flaw_line_index":0,"hash":"338af0aa-3842-4088-8d4c-54e7fad0aefd","idx":"d960e646-378b-4e54-808c-870e10167c27"}
{"func_before":"video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,\n\t\tv4l2_kioctl func)\n{\n\tchar\tsbuf[128];\n\tvoid    *mbuf = NULL;\n\tvoid\t*parg = NULL;\n\tlong\terr  = -EINVAL;\n\tint     is_ext_ctrl;\n\tsize_t  ctrls_size = 0;\n\tvoid __user *user_ptr = NULL;\n\n\tis_ext_ctrl = (cmd == VIDIOC_S_EXT_CTRLS || cmd == VIDIOC_G_EXT_CTRLS ||\n\t\t       cmd == VIDIOC_TRY_EXT_CTRLS);\n\n\t\/*  Copy arguments into temp kernel buffer  *\/\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_NONE:\n\t\tparg = NULL;\n\t\tbreak;\n\tcase _IOC_READ:\n\tcase _IOC_WRITE:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n\t\t\tparg = sbuf;\n\t\t} else {\n\t\t\t\/* too big to allocate from stack *\/\n\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\n\t\t\tif (NULL == mbuf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tparg = mbuf;\n\t\t}\n\n\t\terr = -EFAULT;\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE)\n\t\t\tif (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tif (is_ext_ctrl) {\n\t\tstruct v4l2_ext_controls *p = parg;\n\n\t\t\/* In case of an error, tell the caller that it wasn't\n\t\t   a specific control that caused it. *\/\n\t\tp->error_idx = p->count;\n\t\tuser_ptr = (void __user *)p->controls;\n\t\tif (p->count) {\n\t\t\tctrls_size = sizeof(struct v4l2_ext_control) * p->count;\n\t\t\t\/* Note: v4l2_ext_controls fits in sbuf[] so mbuf is still NULL. *\/\n\t\t\tmbuf = kmalloc(ctrls_size, GFP_KERNEL);\n\t\t\terr = -ENOMEM;\n\t\t\tif (NULL == mbuf)\n\t\t\t\tgoto out_ext_ctrl;\n\t\t\terr = -EFAULT;\n\t\t\tif (copy_from_user(mbuf, user_ptr, ctrls_size))\n\t\t\t\tgoto out_ext_ctrl;\n\t\t\tp->controls = mbuf;\n\t\t}\n\t}\n\n\t\/* call driver *\/\n\terr = func(file, cmd, parg);\n\tif (err == -ENOIOCTLCMD)\n\t\terr = -EINVAL;\n\tif (is_ext_ctrl) {\n\t\tstruct v4l2_ext_controls *p = parg;\n\n\t\tp->controls = (void *)user_ptr;\n\t\tif (p->count && err == 0 && copy_to_user(user_ptr, mbuf, ctrls_size))\n\t\t\terr = -EFAULT;\n\t\tgoto out_ext_ctrl;\n\t}\n\tif (err < 0)\n\t\tgoto out;\n\nout_ext_ctrl:\n\t\/*  Copy results into user buffer  *\/\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_READ:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\t}\n\nout:","target":1,"flaw_line_index":0,"hash":"a6ae25fe-3ef1-4783-9f20-1297f6b385ca","idx":"c6b72e8b-5e01-4876-a15f-688d950313cb"}
{"func_before":"video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,\n\t       v4l2_kioctl func)\n{\n\tchar\tsbuf[128];\n\tvoid    *mbuf = NULL;\n\tvoid\t*parg = (void *)arg;\n\tlong\terr  = -EINVAL;\n\tbool\thas_array_args;\n\tsize_t  array_size = 0;\n\tvoid __user *user_ptr = NULL;\n\tvoid\t**kernel_ptr = NULL;\n\n\t\/*  Copy arguments into temp kernel buffer  *\/\n\tif (_IOC_DIR(cmd) != _IOC_NONE) {\n\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n\t\t\tparg = sbuf;\n\t\t} else {\n\t\t\t\/* too big to allocate from stack *\/\n\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\n\t\t\tif (NULL == mbuf)\n\t\t\t\treturn -ENOMEM;\n\t\t\tparg = mbuf;\n\t\t}\n\n\t\terr = -EFAULT;\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tunsigned long n = cmd_input_size(cmd);\n\n\t\t\tif (copy_from_user(parg, (void __user *)arg, n))\n\t\t\t\tgoto out;\n\n\t\t\t\/* zero out anything we don't copy from userspace *\/\n\t\t\tif (n < _IOC_SIZE(cmd))\n\t\t\t\tmemset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n);\n\t\t} else {\n\t\t\t\/* read-only ioctl *\/\n\t\t\tmemset(parg, 0, _IOC_SIZE(cmd));\n\t\t}\n\t}\n\n\terr = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr);\n\tif (err < 0)\n\t\tgoto out;\n\thas_array_args = err;\n\n\tif (has_array_args) {\n\t\t\/*\n\t\t * When adding new types of array args, make sure that the\n\t\t * parent argument to ioctl (which contains the pointer to the\n\t\t * array) fits into sbuf (so that mbuf will still remain\n\t\t * unused up to here).\n\t\t *\/\n\t\tmbuf = kmalloc(array_size, GFP_KERNEL);\n\t\terr = -ENOMEM;\n\t\tif (NULL == mbuf)\n\t\t\tgoto out_array_args;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(mbuf, user_ptr, array_size))\n\t\t\tgoto out_array_args;\n\t\t*kernel_ptr = mbuf;\n\t}\n\n\t\/* Handles IOCTL *\/\n\terr = func(file, cmd, parg);\n\tif (err == -ENOIOCTLCMD)\n\t\terr = -EINVAL;\n\n\tif (has_array_args) {\n\t\t*kernel_ptr = user_ptr;\n\t\tif (copy_to_user(user_ptr, mbuf, array_size))\n\t\t\terr = -EFAULT;\n\t\tgoto out_array_args;\n\t}\n\tif (err < 0)\n\t\tgoto out;\n\nout_array_args:\n\t\/*  Copy results into user buffer  *\/\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_READ:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\n\t\t\terr = -EFAULT;\n\t\tbreak;\n\t}\n\nout:","target":0,"flaw_line_index":0,"hash":"7e68f663-2605-428b-b0c2-5c1f5b1c98a3","idx":"b4ed3dca-2222-4fbe-8206-49ef7243ee6b"}
{"func_before":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (type == kGenericOptimized) {\n    optimized_ops::Floor(GetTensorShape(input), GetTensorData<float>(input),\n                         GetTensorShape(output), GetTensorData<float>(output));\n  } else {\n    reference_ops::Floor(GetTensorShape(input), GetTensorData<float>(input),\n                         GetTensorShape(output), GetTensorData<float>(output));\n  }\n\n  return kTfLiteOk;","target":1,"flaw_line_index":0,"hash":"ca902964-0e2e-4909-b96e-1141ab26e45e","idx":"2b10d76d-d1da-4f85-8abb-2bc93a7c536d"}
{"func_before":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  if (type == kGenericOptimized) {\n    optimized_ops::Floor(GetTensorShape(input), GetTensorData<float>(input),\n                         GetTensorShape(output), GetTensorData<float>(output));\n  } else {\n    reference_ops::Floor(GetTensorShape(input), GetTensorData<float>(input),\n                         GetTensorShape(output), GetTensorData<float>(output));\n  }\n\n  return kTfLiteOk;","target":0,"flaw_line_index":0,"hash":"c8164bf7-10a5-45e5-9caf-0e2be821ccb5","idx":"abb2510a-e437-4d0f-8ee1-fffe2bf05a47"}
{"func_before":"void fp54_exp_cyc_sps(fp54_t c, const fp54_t a, const int *b, int len, int sign) {\n\tint i, j, k, w = len;\n    fp54_t t, *u = RLC_ALLOCA(fp54_t, w);\n\n\tif (len == 0) {\n\t\tRLC_FREE(u);\n\t\tfp54_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp54_null(t);\n","target":1,"flaw_line_index":0,"hash":"42df232e-9a5b-4d8d-a9c7-ecd0dc18ebbc","idx":"546cb060-6cd5-467d-8fda-b7e5479829d5"}
{"func_before":"void fp54_exp_cyc_sps(fp54_t c, const fp54_t a, const int *b, size_t len,\n\t\tint sign) {\n\tsize_t i, j, k, w = len;\n    fp54_t t, *u = RLC_ALLOCA(fp54_t, w);\n\n\tif (len == 0) {\n\t\tRLC_FREE(u);\n\t\tfp54_set_dig(c, 1);\n\t\treturn;\n\t}\n\n\tfp54_null(t);\n","target":0,"flaw_line_index":0,"hash":"8ae1ff33-f8c6-46e7-9dc9-ab9fb6e38d54","idx":"d11efcd0-c185-489d-9cd4-88beaf6e4977"}
{"func_before":"NTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,\n                               size_t* pcbAvPairListRemaining)\n{\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\tpAvPair = NULL;\n\n\twhile (pAvPair)\n\t{\n\t\tUINT16 id = ntlm_av_pair_get_id(pAvPair);\n\n\t\tif (id == AvId)\n\t\t\tbreak;\n\t\tif (id == MsvAvEOL)\n\t\t{\n\t\t\tpAvPair = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\t}","target":1,"flaw_line_index":0,"hash":"b8f290dc-575d-453c-b9b1-8a6369aa75c3","idx":"6b92d74b-fd19-460f-9550-c8ca52061ec8"}
{"func_before":"NTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,\n                               size_t* pcbAvPairListRemaining)\n{\n\tUINT16 id;\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\tpAvPair = NULL;\n\n\twhile (pAvPair && ntlm_av_pair_get_id(pAvPair, cbAvPair, &id))\n\t{\n\t\tif (id == AvId)\n\t\t\tbreak;\n\t\tif (id == MsvAvEOL)\n\t\t{\n\t\t\tpAvPair = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpAvPair = ntlm_av_pair_next(pAvPair, &cbAvPair);\n\t}","target":0,"flaw_line_index":0,"hash":"6ee1eee1-4fb0-4c9e-9877-415427d5bf15","idx":"fc9083a1-ea36-43e7-a2c2-cb1f35991e23"}
{"func_before":"\n\t\t\/* create space for UDP\/IP header *\/\n\t\tskb_put(skb, fragheaderlen + transhdrlen);\n\n\t\t\/* initialize network header pointer *\/\n\t\tskb_reset_network_header(skb);\n\n\t\t\/* initialize protocol header pointer *\/\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\n\t\t\/* specify the length of each IP datagram fragment *\/\n\t\tskb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\t__skb_queue_tail(queue, skb);\n\t}\n\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}","target":1,"flaw_line_index":0,"hash":"04598407-1164-48ad-b3c1-e3f80606b327","idx":"6e992efd-5137-4f51-912a-2f3570f61111"}
{"func_before":"\t\tskb_reserve(skb, hh_len);\n\n\t\t\/* create space for UDP\/IP header *\/\n\t\tskb_put(skb, fragheaderlen + transhdrlen);\n\n\t\t\/* initialize network header pointer *\/\n\t\tskb_reset_network_header(skb);\n\n\t\t\/* initialize protocol header pointer *\/\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->csum = 0;\n\n\n\t\t__skb_queue_tail(queue, skb);\n\t} else if (skb_is_gso(skb)) {\n\t\tgoto append;\n\t}\n\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\/* specify the length of each IP datagram fragment *\/\n\tskb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;\n\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\nappend:\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}","target":0,"flaw_line_index":0,"hash":"a00d7400-5c3e-43c3-83cb-0d6e2fe5f855","idx":"86ee55ef-c99f-4e87-ac8e-280dd2bf5858"}
{"func_before":"define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)\n{\n    int\t\tj;\n    int\t\tc;\n    int\t\tsaved_did_emsg;\n    char_u\t*name = name_arg;\n    int\t\tis_global = FALSE;\n    char_u\t*p;\n    char_u\t*arg;\n    char_u\t*whitep;\n    char_u\t*line_arg = NULL;\n\t    goto ret_free;\n\t}\n    }\n\n    \/\/ This may get more lines and make the pointers into the first line\n    \/\/ invalid.\n    ++p;\n    if (get_function_args(&p, ')', &newargs,\n\t\t\teap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,\n\t\t\t NULL, &varargs, &default_args, eap->skip,\n\t\t\t eap, line_to_free) == FAIL)\n\tgoto errret_2;\n    whitep = p;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\t\/\/ find the return type: :def Func(): type\n\tif (*skipwhite(p) == ':')\n\t{\n\t    if (*p != ':')\n\t    {\n\n\tmsg_putchar('\\n');\t    \/\/ don't overwrite the function name\n\tcmdline_row = msg_row;\n    }\n\n    \/\/ Save the starting line number.\n    sourcing_lnum_top = SOURCING_LNUM;\n\n    \/\/ Do not define the function when getting the body fails and when\n    \/\/ skipping.\n    if (get_function_body(eap, &newlines, line_arg, line_to_free) == FAIL\n\t    || eap->skip)\n\tgoto erret;\n\n    \/*\n     * If there are no errors, add the function\n     *\/\n    if (fudi.fd_dict == NULL)\n    {\n\thashtab_T\t*ht;\n","target":1,"flaw_line_index":0,"hash":"3a3dc65e-be97-4f94-8b3b-e5923cdd0f13","idx":"097e38c6-2082-4a3f-bd4b-38777bc06ece"}
{"func_before":"define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free)\n{\n    int\t\tj;\n    int\t\tc;\n    int\t\tsaved_did_emsg;\n    char_u\t*name = name_arg;\n    int\t\tis_global = FALSE;\n    char_u\t*p;\n    char_u\t*arg;\n    char_u\t*whitep;\n    char_u\t*line_arg = NULL;\n\t    goto ret_free;\n\t}\n    }\n\n    \/\/ This may get more lines and make the pointers into the first line\n    \/\/ invalid.\n    ++p;\n    if (get_function_args(&p, ')', &newargs,\n\t\t\teap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,\n\t\t\t NULL, &varargs, &default_args, eap->skip,\n\t\t\t eap, lines_to_free) == FAIL)\n\tgoto errret_2;\n    whitep = p;\n\n    if (eap->cmdidx == CMD_def)\n    {\n\t\/\/ find the return type: :def Func(): type\n\tif (*skipwhite(p) == ':')\n\t{\n\t    if (*p != ':')\n\t    {\n\n\tmsg_putchar('\\n');\t    \/\/ don't overwrite the function name\n\tcmdline_row = msg_row;\n    }\n\n    \/\/ Save the starting line number.\n    sourcing_lnum_top = SOURCING_LNUM;\n\n    \/\/ Do not define the function when getting the body fails and when\n    \/\/ skipping.\n    if (get_function_body(eap, &newlines, line_arg, lines_to_free) == FAIL\n\t    || eap->skip)\n\tgoto erret;\n\n    \/*\n     * If there are no errors, add the function\n     *\/\n    if (fudi.fd_dict == NULL)\n    {\n\thashtab_T\t*ht;\n","target":0,"flaw_line_index":0,"hash":"299e2d75-3d90-4d48-989a-69bf71e9134b","idx":"54774d6f-e5cd-49bf-9e6b-6bbf0c8e4c6c"}
{"func_before":"\tif (!np)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpdev = of_find_device_by_node(np);\n\tof_node_put(np);\n\tif (!pdev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tqmp = platform_get_drvdata(pdev);\n\n\treturn qmp ? qmp : ERR_PTR(-EPROBE_DEFER);\n}","target":1,"flaw_line_index":0,"hash":"50dcdd19-dff8-4139-b7d6-e4edf18fa4c4","idx":"fa87b573-a705-4256-aaab-a7c4ed42ee92"}
{"func_before":"\tif (!np)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpdev = of_find_device_by_node(np);\n\tof_node_put(np);\n\tif (!pdev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tqmp = platform_get_drvdata(pdev);\n\n\tif (!qmp) {\n\t\tput_device(&pdev->dev);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\treturn qmp;\n}","target":0,"flaw_line_index":0,"hash":"e56ffac2-8135-4bcc-82a6-d938f186e186","idx":"2f9bfbfd-14c4-4cd0-bd8d-66cd36731e2f"}
{"func_before":"PJ_DEF(pj_status_t) pjmedia_wav_player_port_create( pj_pool_t *pool,\n\t\t\t\t\t\t     const char *filename,\n\t\t\t\t\t\t     unsigned ptime,\n\t\t\t\t\t\t     unsigned options,\n\t\t\t\t\t\t     pj_ssize_t buff_size,\n\t\t\t\t\t\t     pjmedia_port **p_port )\n{\n    pjmedia_wave_hdr wave_hdr;\n    pj_ssize_t size_to_read, size_read;\n    struct file_reader_port *fport;\n    pjmedia_audio_format_detail *ad;\n    pj_off_t pos;\n    pj_str_t name;\n    unsigned samples_per_frame;\n    pj_status_t status = PJ_SUCCESS;\n\n\n    \/* Check arguments. *\/\n    PJ_ASSERT_RETURN(pool && filename && p_port, PJ_EINVAL);\n    if (fport->fsize <= sizeof(pjmedia_wave_hdr)) {\n\treturn PJMEDIA_ENOTVALIDWAVE;\n    }\n\n    \/* Open file. *\/\n    status = pj_file_open( pool, filename, PJ_O_RDONLY, &fport->fd);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    \/* Read the file header plus fmt header only. *\/\n    size_read = size_to_read = sizeof(wave_hdr) - 8;\n    status = pj_file_read( fport->fd, &wave_hdr, &size_read);\n    if (status != PJ_SUCCESS) {\n\tpj_file_close(fport->fd);\n\treturn status;\n    }\n    if (size_read != size_to_read) {\n\tpj_file_close(fport->fd);\n\treturn PJMEDIA_ENOTVALIDWAVE;\n    }\n\n    }\n\n    fport->fmt_tag = (pjmedia_wave_fmt_tag)wave_hdr.fmt_hdr.fmt_tag;\n    fport->bytes_per_sample = (pj_uint16_t) \n\t\t\t      (wave_hdr.fmt_hdr.bits_per_sample \/ 8);\n\n    \/* If length of fmt_header is greater than 16, skip the remaining\n     * fmt header data.\n     *\/\n    if (wave_hdr.fmt_hdr.len > 16) {\n\tsize_to_read = wave_hdr.fmt_hdr.len - 16;\n\tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n\t    pj_file_close(fport->fd);\n\t    return status;\n\t}\n    }\n\n    \/* Repeat reading the WAVE file until we have 'data' chunk *\/\n    for (;;) {\n\tpjmedia_wave_subchunk subchunk;\n\t\/* Normalize endianness *\/\n\tPJMEDIA_WAVE_NORMALIZE_SUBCHUNK(&subchunk);\n\n\t\/* Break if this is \"data\" chunk *\/\n\tif (subchunk.id == PJMEDIA_DATA_TAG) {\n\t    wave_hdr.data_hdr.data = PJMEDIA_DATA_TAG;\n\t    wave_hdr.data_hdr.len = subchunk.len;\n\t    break;\n\t}\n\n\t\/* Otherwise skip the chunk contents *\/\n\tsize_to_read = subchunk.len;\n\tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n\t    pj_file_close(fport->fd);\n\t    return status;\n\t}\n    }\n\n    \/* Current file position now points to start of data *\/\n    status = pj_file_getpos(fport->fd, &pos);\n    fport->start_data = (unsigned)pos;","target":1,"flaw_line_index":0,"hash":"c0f4bab9-e305-45a7-b250-d14caad757d7","idx":"f27476ec-57d8-4b03-8ac9-faea48559583"}
{"func_before":"PJ_DEF(pj_status_t) pjmedia_wav_player_port_create( pj_pool_t *pool,\n\t\t\t\t\t\t     const char *filename,\n\t\t\t\t\t\t     unsigned ptime,\n\t\t\t\t\t\t     unsigned options,\n\t\t\t\t\t\t     pj_ssize_t buff_size,\n\t\t\t\t\t\t     pjmedia_port **p_port )\n{\n    pjmedia_wave_hdr wave_hdr;\n    pj_ssize_t size_read;\n    pj_off_t size_to_read;\n    struct file_reader_port *fport;\n    pjmedia_audio_format_detail *ad;\n    pj_off_t pos;\n    pj_str_t name;\n    unsigned samples_per_frame;\n    pj_status_t status = PJ_SUCCESS;\n\n\n    \/* Check arguments. *\/\n    PJ_ASSERT_RETURN(pool && filename && p_port, PJ_EINVAL);\n    if (fport->fsize <= sizeof(pjmedia_wave_hdr)) {\n\treturn PJMEDIA_ENOTVALIDWAVE;\n    }\n\n    \/* Open file. *\/\n    status = pj_file_open( pool, filename, PJ_O_RDONLY, &fport->fd);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    \/* Read the file header plus fmt header only. *\/\n    size_to_read = size_read = sizeof(wave_hdr) - 8;\n    status = pj_file_read( fport->fd, &wave_hdr, &size_read);\n    if (status != PJ_SUCCESS) {\n\tpj_file_close(fport->fd);\n\treturn status;\n    }\n    if (size_read != size_to_read) {\n\tpj_file_close(fport->fd);\n\treturn PJMEDIA_ENOTVALIDWAVE;\n    }\n\n    }\n\n    fport->fmt_tag = (pjmedia_wave_fmt_tag)wave_hdr.fmt_hdr.fmt_tag;\n    fport->bytes_per_sample = (pj_uint16_t) \n\t\t\t      (wave_hdr.fmt_hdr.bits_per_sample \/ 8);\n\n    \/* If length of fmt_header is greater than 16, skip the remaining\n     * fmt header data.\n     *\/\n    if (wave_hdr.fmt_hdr.len > 16) {\n\tPJ_CHECK_OVERFLOW_UINT32_TO_LONG(wave_hdr.fmt_hdr.len - 16,\n\t\t      pj_file_close(fport->fd); return PJMEDIA_ENOTVALIDWAVE;);\n\tsize_to_read = (pj_off_t)wave_hdr.fmt_hdr.len - 16;\n\tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n\t    pj_file_close(fport->fd);\n\t    return status;\n\t}\n    }\n\n    \/* Repeat reading the WAVE file until we have 'data' chunk *\/\n    for (;;) {\n\tpjmedia_wave_subchunk subchunk;\n\tPJMEDIA_WAVE_NORMALIZE_SUBCHUNK(&subchunk);\n\n\t\/* Break if this is \"data\" chunk *\/\n\tif (subchunk.id == PJMEDIA_DATA_TAG) {\n\t    wave_hdr.data_hdr.data = PJMEDIA_DATA_TAG;\n\t    wave_hdr.data_hdr.len = subchunk.len;\n\t    break;\n\t}\n\n\t\/* Otherwise skip the chunk contents *\/\n\tPJ_CHECK_OVERFLOW_UINT32_TO_LONG(subchunk.len, \n\t\t      pj_file_close(fport->fd); return PJMEDIA_ENOTVALIDWAVE;);\n\tsize_to_read = subchunk.len;\n\n\tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n\t    pj_file_close(fport->fd);\n\t    return status;\n\t}\n    }\n\n    \/* Current file position now points to start of data *\/\n    status = pj_file_getpos(fport->fd, &pos);\n    fport->start_data = (unsigned)pos;","target":0,"flaw_line_index":0,"hash":"2f03c2d9-3585-4e3f-8ca0-c41a852692dc","idx":"fb0f1bf1-c8c0-4ece-ab4c-648072df2854"}
{"func_before":"    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    \/*\n      Rewind list, removing any empty images while rewinding.\n    *\/\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    \/*\n      Fix scene numbers\n    *\/","target":1,"flaw_line_index":0,"hash":"eda4364d-a338-4ed5-b9b0-5683b4f9d1eb","idx":"d3b502cb-22f0-4198-a2f7-f66cb708168b"}
{"func_before":"\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    if (clone_info)\n      clone_info=DestroyImageInfo(clone_info);\n  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    ssize_t scene=0;\n\n    \/*\n      Rewind list, removing any empty images while rewinding.\n    *\/\n    p=image;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          if (tmp == image2)\n            image2=(Image *) NULL;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }\n      }\n\n    \/*\n      Fix scene numbers\n    *\/","target":0,"flaw_line_index":0,"hash":"5fb0b086-fb8f-4454-a574-3b445bc40dfc","idx":"b420ff00-fc16-413b-90a2-5cb864d18650"}
{"func_before":"\n  TestUtility::loadFromYaml(TestEnvironment::substitute(yaml_plain), tls_context);\n  auto* common_context = tls_context.mutable_common_tls_context();\n\n  if (options.alpn_) {\n    common_context->add_alpn_protocols(Http::Utility::AlpnNames::get().Http2);\n    common_context->add_alpn_protocols(Http::Utility::AlpnNames::get().Http11);\n    common_context->add_alpn_protocols(Http::Utility::AlpnNames::get().Http3);\n  }\n  if (!options.san_.empty()) {\n    common_context->mutable_validation_context()->add_match_subject_alt_names()->set_exact(\n        options.san_);\n  }\n  for (const std::string& cipher_suite : options.cipher_suites_) {\n    common_context->mutable_tls_params()->add_cipher_suites(cipher_suite);\n  }\n  if (!options.sni_.empty()) {\n    tls_context.set_sni(options.sni_);\n  }\n\n  common_context->mutable_tls_params()->set_tls_minimum_protocol_version(options.tls_version_);\n  common_context->mutable_tls_params()->set_tls_maximum_protocol_version(options.tls_version_);","target":1,"flaw_line_index":0,"hash":"d758dcb0-b0d7-4e33-8720-32bb285214f1","idx":"f1154131-0017-42e6-9220-c3f4942a83c7"}
{"func_before":"\n  TestUtility::loadFromYaml(TestEnvironment::substitute(yaml_plain), tls_context);\n  auto* common_context = tls_context.mutable_common_tls_context();\n\n  if (options.alpn_) {\n    common_context->add_alpn_protocols(Http::Utility::AlpnNames::get().Http2);\n    common_context->add_alpn_protocols(Http::Utility::AlpnNames::get().Http11);\n    common_context->add_alpn_protocols(Http::Utility::AlpnNames::get().Http3);\n  }\n  if (!options.san_.empty()) {\n    envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher* matcher =\n        common_context->mutable_validation_context()->add_match_typed_subject_alt_names();\n    matcher->mutable_matcher()->set_exact(options.san_);\n    matcher->set_san_type(\n        envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS);\n    matcher = common_context->mutable_validation_context()->add_match_typed_subject_alt_names();\n    matcher->mutable_matcher()->set_exact(options.san_);\n    matcher->set_san_type(\n        envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI);\n    matcher = common_context->mutable_validation_context()->add_match_typed_subject_alt_names();\n    matcher->mutable_matcher()->set_exact(options.san_);\n    matcher->set_san_type(\n        envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL);\n    matcher = common_context->mutable_validation_context()->add_match_typed_subject_alt_names();\n    matcher->mutable_matcher()->set_exact(options.san_);\n    matcher->set_san_type(\n        envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS);\n  }\n  for (const std::string& cipher_suite : options.cipher_suites_) {\n    common_context->mutable_tls_params()->add_cipher_suites(cipher_suite);\n  }\n  if (!options.sni_.empty()) {\n    tls_context.set_sni(options.sni_);\n  }\n\n  common_context->mutable_tls_params()->set_tls_minimum_protocol_version(options.tls_version_);\n  common_context->mutable_tls_params()->set_tls_maximum_protocol_version(options.tls_version_);","target":0,"flaw_line_index":0,"hash":"7b413ff2-1bf1-4e4b-8337-72264f99b837","idx":"a1762fc2-1f88-48cd-92dc-7900b705ea89"}
{"func_before":"void Context::onLog() {\n  if (wasm_->onLog_) {\n    wasm_->onLog_(this, id_);\n  }\n}","target":1,"flaw_line_index":0,"hash":"d6820c6e-319c-42a8-9877-f09e380d578d","idx":"2f34368b-be80-4711-a968-32ffd6c68912"}
{"func_before":"void Context::onLog() {\n  if (in_vm_context_created_ && wasm_->onLog_) {\n    wasm_->onLog_(this, id_);\n  }\n}","target":0,"flaw_line_index":0,"hash":"48657d06-2446-460f-a90b-e0728b4aa695","idx":"3cc7e57c-a4e4-42fe-aeb3-b65f99f9f455"}
{"func_before":"static int may_create_in_sticky(struct dentry * const dir,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir->d_inode->i_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir->d_inode->i_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\n\tif (likely(dir->d_inode->i_mode & 0002) ||\n\t    (dir->d_inode->i_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"8fca8cce-8cc5-45d7-8a0e-fa3b78481a49","idx":"a471a28c-736a-4ed6-bb49-698e182d601e"}
{"func_before":"static int may_create_in_sticky(umode_t dir_mode, kuid_t dir_uid,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\n\tif (likely(dir_mode & 0002) ||\n\t    (dir_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";\n\t\taudit_log_path_denied(AUDIT_ANOM_CREAT, operation);\n\t\treturn -EACCES;\n\t}\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"ce4c2bbe-d516-4050-b12d-94b4f9b0b98c","idx":"68da2297-1528-4d81-b04a-5c34eda2737e"}
{"func_before":"  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned int\n    depth;\n\n\n  (void) SeekBlob(image,0,SEEK_SET);\n  while (EOFBlob(image) != MagickFalse)\n  {\n    \/*\n     Object parser loop.\n    *\/\n    ldblk=ReadBlobLSBLong(image);\n    if ((ldblk > 9999) || (ldblk < 0))\n      break;\n    HDR.Type[3]=ldblk % 10; ldblk \/= 10;  \/* T digit *\/\n          Read complex pixels.\n        *\/\n        count=ReadBlob(image,depth\/8*image->columns,(char *) pixels);\n        if (count == -1)\n          break;\n        if (HDR.Type[1] == 0)\n          InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);\n        else\n          InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);\n      }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    rotate_image=RotateImage(image,90.0,exception);\n    if (rotate_image != (Image *) NULL)\n      {\n        image=DestroyImage(image);\n        image=rotate_image;\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);","target":1,"flaw_line_index":0,"hash":"d6c02b01-c52a-49b4-914d-a92596ae6a49","idx":"01debaa2-201d-4b4c-809c-4dcd25d7d033"}
{"func_before":"    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned int\n    depth;\n\n\n  quantum_info=(QuantumInfo *) NULL;\n  (void) SeekBlob(image,0,SEEK_SET);\n  while (EOFBlob(image) != MagickFalse)\n  {\n    \/*\n     Object parser loop.\n    *\/\n    ldblk=ReadBlobLSBLong(image);\n    if ((ldblk > 9999) || (ldblk < 0))\n      break;\n    HDR.Type[3]=ldblk % 10; ldblk \/= 10;  \/* T digit *\/\n          Read complex pixels.\n        *\/\n        count=ReadBlob(image,depth\/8*image->columns,(char *) pixels);\n        if (count == -1)\n          break;\n        if (HDR.Type[1] == 0)\n          InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);\n        else\n          InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);\n      }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    rotate_image=RotateImage(image,90.0,exception);\n    if (rotate_image != (Image *) NULL)\n      {\n        image=DestroyImage(image);\n        image=rotate_image;\n      }\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);","target":0,"flaw_line_index":0,"hash":"6c8bab75-1ab7-4b22-bd3b-0d0eedf9aa21","idx":"8b3c2222-78bf-447c-bd8e-7c83bc7e07f3"}
{"func_before":"pf_remove_state(struct pf_state *st)\n{\n\tPF_ASSERT_LOCKED();\n\n\tif (st->timeout == PFTM_UNLINKED)\n\t\treturn;\n\n\tst->timeout = PFTM_UNLINKED;\n\n\t\/* handle load balancing related tasks *\/\n\tpf_postprocess_addr(st);\n\n\tif (st->src.state == PF_TCPS_PROXY_DST) {\n\t\tpf_send_tcp(st->rule.ptr, st->key[PF_SK_WIRE]->af,\n\t\t    &st->key[PF_SK_WIRE]->addr[1],\n\t\t    &st->key[PF_SK_WIRE]->addr[0],\n\t\t    st->key[PF_SK_WIRE]->port[1],\n\t\t    st->key[PF_SK_WIRE]->port[0],","target":1,"flaw_line_index":0,"hash":"01bea2a9-0aab-4ddf-bf2c-4c12d93621a3","idx":"1c2d4144-f858-4095-a629-8895b63e04d2"}
{"func_before":"pf_remove_state(struct pf_state *st)\n{\n\tPF_ASSERT_LOCKED();\n\n\tmtx_enter(&st->mtx);\n\tif (st->timeout == PFTM_UNLINKED) {\n\t\tmtx_leave(&st->mtx);\n\t\treturn;\n\t}\n\tst->timeout = PFTM_UNLINKED;\n\tmtx_leave(&st->mtx);\n\n\t\/* handle load balancing related tasks *\/\n\tpf_postprocess_addr(st);\n\n\tif (st->src.state == PF_TCPS_PROXY_DST) {\n\t\tpf_send_tcp(st->rule.ptr, st->key[PF_SK_WIRE]->af,\n\t\t    &st->key[PF_SK_WIRE]->addr[1],\n\t\t    &st->key[PF_SK_WIRE]->addr[0],\n\t\t    st->key[PF_SK_WIRE]->port[1],\n\t\t    st->key[PF_SK_WIRE]->port[0],","target":0,"flaw_line_index":0,"hash":"066c132d-bb9a-4148-9e88-8a99d1d43274","idx":"fe6155fc-337d-45bd-9a79-d7e5f7b78c7c"}
{"func_before":"void TLSOutStream::flush()\n{\n  U8* sentUpTo = start;\n  while (sentUpTo < ptr) {\n    int n = writeTLS(sentUpTo, ptr - sentUpTo);\n    sentUpTo += n;\n    offset += n;\n  }\n\n  ptr = start;\n  out->flush();\n}","target":1,"flaw_line_index":0,"hash":"b259c63c-75f6-4d85-afe8-11238ba78a19","idx":"a93d2cf7-9ea5-40cd-af79-c328afd3a59d"}
{"func_before":"void TLSOutStream::flush()\n{\n  U8* sentUpTo = start;\n  while (sentUpTo < ptr) {\n    size_t n = writeTLS(sentUpTo, ptr - sentUpTo);\n    sentUpTo += n;\n    offset += n;\n  }\n\n  ptr = start;\n  out->flush();\n}","target":0,"flaw_line_index":0,"hash":"f5b164be-5b5c-46ba-a407-7530abe28260","idx":"49cd5332-51c7-4ec8-8bec-04e1607cf1bf"}
{"func_before":"\t\t\t\tT.pidfile = strdup(args[1]);\n\t\t\t}\n\t\t} else if (!strcasecmp (args[0], \"interfaces\")) {\n\t\t\tint i;\n\n\t\t\tif (argcnt < 2) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: interfaces <ifa> <ifb> ...\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t}\n\n\t\t\tfor (i = 0; T.iflist[i] && i < MAXINTERFACES; i++);\n\n\t\t \tif (i + argcnt-1 > MAXINTERFACES) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: to many interfaces, more than %d\", linenum, MAXINTERFACES);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n\t\t\t\tsyslog (LOG_DEBUG, \"line %d: %d interfaces listed, no wildcard socket\", linenum, argcnt-1);\n\n\t\t\t\tT.iflist[i + argcnt--] = NULL;\n\t\t\t\twhile (argcnt) {\n\t\t\t\t\tif (!strcmp(args[argcnt], \"*\")) {","target":1,"flaw_line_index":0,"hash":"6b72938e-fb04-4617-aa91-1dfaa52835d0","idx":"0f56394f-d7f0-4af1-ad40-d69c375eca8a"}
{"func_before":"\t\t\t\tT.pidfile = strdup(args[1]);\n\t\t\t}\n\t\t} else if (!strcasecmp (args[0], \"interfaces\")) {\n\t\t\tint i;\n\n\t\t\tif (argcnt < 2) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: interfaces <ifa> <ifb> ...\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t}\n\n\t\t\tfor (i = 0; T.iflist[i] && i < MAXINTERFACES; i++) { \n                        };\n\n\t\t \tif (i + argcnt-1 > MAXINTERFACES) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: to many interfaces, more than %d\", linenum, MAXINTERFACES);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n\t\t\t\tsyslog (LOG_DEBUG, \"line %d: %d interfaces listed, no wildcard socket\", linenum, argcnt-1);\n\n\t\t\t\tT.iflist[i + argcnt--] = NULL;\n\t\t\t\twhile (argcnt) {\n\t\t\t\t\tif (!strcmp(args[argcnt], \"*\")) {","target":0,"flaw_line_index":0,"hash":"baec853b-247b-4250-82bf-ace897d8f8da","idx":"b918dff1-4f5b-4c97-b4e8-460891cea6ed"}
{"func_before":"static CURLcode pop3_parse_url_path(struct connectdata *conn)\n{\n  \/* the pop3 struct is already inited in pop3_connect() *\/\n  struct pop3_conn *pop3c = &conn->proto.pop3c;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n\n  \/* url decode the path and use this mailbox *\/\n  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n  if(!pop3c->mailbox)\n    return CURLE_OUT_OF_MEMORY;\n\n  return CURLE_OK;\n}","target":1,"flaw_line_index":0,"hash":"e7de4fe1-dfcc-4e28-885d-3619e7c28253","idx":"ac3bd151-8180-45a3-816d-d3fb5a3cf01f"}
{"func_before":"static CURLcode pop3_parse_url_path(struct connectdata *conn)\n{\n  \/* the pop3 struct is already inited in pop3_connect() *\/\n  struct pop3_conn *pop3c = &conn->proto.pop3c;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n\n  \/* url decode the path and use this mailbox *\/\n  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n}","target":0,"flaw_line_index":0,"hash":"afb5656a-68b4-4139-ad71-f232df12ff7e","idx":"0fa2285a-0939-4761-bda3-b3487aeb11aa"}
{"func_before":"  if (u_map_get(request->map_url, \"state\") != NULL) {\n    state_encoded = ulfius_url_encode(u_map_get(request->map_url, \"state\"));\n    state_param = msprintf(\"&state=%s\", state_encoded);\n    o_free(state_encoded);\n  } else {\n    state_param = o_strdup(\"\");\n  }\n  \/\/ Check if client is allowed to perform this request\n  if (check_result_value(j_client, G_OK)) {\n    \/\/ Client is allowed to use auth_code grant with this redirection_uri\n    if (u_map_has_key(request->map_url, \"g_continue\")) {\n      if (!o_strnullempty(u_map_get(request->map_url, \"scope\"))) {\n        j_session = validate_session_client_scope(config, request, u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"));\n        if (check_result_value(j_session, G_OK)) {\n          if (json_object_get(json_object_get(j_session, \"session\"), \"authorization_required\") == json_false()) {\n            \/\/ User has granted access to the cleaned scope list for this client\n            \/\/ Generate code, generate the url and redirect to it\n            issued_for = get_client_hostname(request, config->glewlwyd_config->glewlwyd_config->originating_ip_header);\n            if (issued_for != NULL) {\n              if (config->glewlwyd_config->glewlwyd_callback_trigger_session_used(config->glewlwyd_config, request, json_string_value(json_object_get(json_object_get(j_session, \"session\"), \"scope_filtered\"))) == G_OK) {\n                if ((res = is_code_challenge_valid(config, u_map_get(request->map_url, \"code_challenge\"), u_map_get(request->map_url, \"code_challenge_method\"), code_challenge_stored)) == G_OK) {\n                  if ((authorization_code = generate_authorization_code(config, json_string_value(json_object_get(json_object_get(json_object_get(j_session, \"session\"), \"user\"), \"username\")), u_map_get(request->map_url, \"client_id\"), json_string_value(json_object_get(json_object_get(j_session, \"session\"), \"scope_filtered\")), u_map_get(request->map_url, \"redirect_uri\"), issued_for, u_map_get_case(request->map_header, \"user-agent\"), code_challenge_stored)) != NULL) {\n          o_free(redirect_url);\n        } else {\n          redirect_url = msprintf(\"%s%serror=server_error\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"));\n          ulfius_add_header_to_response(response, \"Location\", redirect_url);\n          o_free(redirect_url);\n          y_log_message(Y_LOG_LEVEL_ERROR, \"check_auth_type_auth_code_grant - oauth2 - Error validate_session_client_scope\");\n          response->status = 302;\n        }\n        json_decref(j_session);\n      } else {\n        \/\/ Scope is not allowed for this user\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_auth_type_auth_code_grant - oauth2 - scope list is missing or empty, origin: %s\", ip_source);\n        response->status = 302;\n        redirect_url = msprintf(\"%s%serror=invalid_scope%s\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"), state_param);\n        ulfius_add_header_to_response(response, \"Location\", redirect_url);\n        o_free(redirect_url);\n      }\n    } else {\n      \/\/ Redirect to login page\n      redirect_url = get_login_url(config, request, \"auth\", u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"), NULL);\n      ulfius_add_header_to_response(response, \"Location\", redirect_url);\n      o_free(redirect_url);\n      response->status = 302;\n    }\n  } else {\n    \/\/ client is not authorized\n    response->status = 302;\n    redirect_url = msprintf(\"%s%serror=unauthorized_client%s%s\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"), (u_map_get(request->map_url, \"state\")!=NULL?\"&state=\":\"\"), (u_map_get(request->map_url, \"state\")!=NULL?u_map_get(request->map_url, \"state\"):\"\"));\n    ulfius_add_header_to_response(response, \"Location\", redirect_url);\n    o_free(redirect_url);\n    config->glewlwyd_config->glewlwyd_plugin_callback_metrics_increment_counter(config->glewlwyd_config, GLWD_METRICS_OAUTH2_UNAUTHORIZED_CLIENT, 1, \"plugin\", config->name, NULL);\n  }\n  o_free(state_param);\n  json_decref(j_client);\n  return U_CALLBACK_CONTINUE;\n}","target":1,"flaw_line_index":0,"hash":"c59a11a4-3d07-42af-87b9-a17fa2dc41cf","idx":"24c50a28-36de-4b5d-ad42-77e53bd8e745"}
{"func_before":"  if (u_map_get(request->map_url, \"state\") != NULL) {\n    state_encoded = ulfius_url_encode(u_map_get(request->map_url, \"state\"));\n    state_param = msprintf(\"&state=%s\", state_encoded);\n    o_free(state_encoded);\n  } else {\n    state_param = o_strdup(\"\");\n  }\n  \/\/ Check if client is allowed to perform this request\n  if (check_result_value(j_client, G_OK)) {\n    \/\/ Client is allowed to use auth_code grant with this redirection_uri\n    if (!o_strnullempty(u_map_get(request->map_url, \"scope\"))) {\n      if (u_map_has_key(request->map_url, \"g_continue\")) {\n        j_session = validate_session_client_scope(config, request, u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"));\n        if (check_result_value(j_session, G_OK)) {\n          if (json_object_get(json_object_get(j_session, \"session\"), \"authorization_required\") == json_false()) {\n            \/\/ User has granted access to the cleaned scope list for this client\n            \/\/ Generate code, generate the url and redirect to it\n            issued_for = get_client_hostname(request, config->glewlwyd_config->glewlwyd_config->originating_ip_header);\n            if (issued_for != NULL) {\n              if (config->glewlwyd_config->glewlwyd_callback_trigger_session_used(config->glewlwyd_config, request, json_string_value(json_object_get(json_object_get(j_session, \"session\"), \"scope_filtered\"))) == G_OK) {\n                if ((res = is_code_challenge_valid(config, u_map_get(request->map_url, \"code_challenge\"), u_map_get(request->map_url, \"code_challenge_method\"), code_challenge_stored)) == G_OK) {\n                  if ((authorization_code = generate_authorization_code(config, json_string_value(json_object_get(json_object_get(json_object_get(j_session, \"session\"), \"user\"), \"username\")), u_map_get(request->map_url, \"client_id\"), json_string_value(json_object_get(json_object_get(j_session, \"session\"), \"scope_filtered\")), u_map_get(request->map_url, \"redirect_uri\"), issued_for, u_map_get_case(request->map_header, \"user-agent\"), code_challenge_stored)) != NULL) {\n          o_free(redirect_url);\n        } else {\n          redirect_url = msprintf(\"%s%serror=server_error\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"));\n          ulfius_add_header_to_response(response, \"Location\", redirect_url);\n          o_free(redirect_url);\n          y_log_message(Y_LOG_LEVEL_ERROR, \"check_auth_type_auth_code_grant - oauth2 - Error validate_session_client_scope\");\n          response->status = 302;\n        }\n        json_decref(j_session);\n      } else {\n        \/\/ Redirect to login page\n        redirect_url = get_login_url(config, request, \"auth\", u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"), NULL);\n        ulfius_add_header_to_response(response, \"Location\", redirect_url);\n        o_free(redirect_url);\n        response->status = 302;\n      }\n    } else {\n      \/\/ Scope is not allowed for this user\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"check_auth_type_auth_code_grant - oauth2 - scope list is missing or empty, origin: %s\", ip_source);\n      response->status = 403;\n    }\n  } else {\n    \/\/ client is not authorized\n    response->status = 403;\n    config->glewlwyd_config->glewlwyd_plugin_callback_metrics_increment_counter(config->glewlwyd_config, GLWD_METRICS_OAUTH2_UNAUTHORIZED_CLIENT, 1, \"plugin\", config->name, NULL);\n  }\n  o_free(state_param);\n  json_decref(j_client);\n  return U_CALLBACK_CONTINUE;\n}","target":0,"flaw_line_index":0,"hash":"abe03684-c97e-43a6-9601-dd52ddd6b670","idx":"d3af4b4c-f1fb-4205-bb8d-073e97474c45"}
{"func_before":"obj2ast_keyword(PyObject* obj, keyword_ty* out, PyArena* arena)\n{\n    PyObject* tmp = NULL;\n    identifier arg;\n    expr_ty value;\n\n    if (exists_not_none(obj, &PyId_arg)) {\n        int res;\n        tmp = _PyObject_GetAttrId(obj, &PyId_arg);\n        if (tmp == NULL) goto failed;\n        res = obj2ast_identifier(tmp, &arg, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    } else {\n        arg = NULL;\n    }\n    if (_PyObject_HasAttrId(obj, &PyId_value)) {\n        int res;\n        tmp = _PyObject_GetAttrId(obj, &PyId_value);\n        if (tmp == NULL) goto failed;\n        res = obj2ast_expr(tmp, &value, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    } else {\n        PyErr_SetString(PyExc_TypeError, \"required field \\\"value\\\" missing from keyword\");\n        return 1;\n    }\n    *out = keyword(arg, value, arena);\n    return 0;\nfailed:\n    Py_XDECREF(tmp);\n    return 1;\n}","target":1,"flaw_line_index":0,"hash":"81c5cb00-d1ef-49c7-b663-58b07a3f49b3","idx":"3d5eb06c-9795-4258-849e-566832d6db02"}
{"func_before":"obj2ast_keyword(PyObject* obj, keyword_ty* out, PyArena* arena)\n{\n    PyObject* tmp = NULL;\n    identifier arg;\n    expr_ty value;\n\n    if (lookup_attr_id(obj, &PyId_arg, &tmp) < 0) {\n        return 1;\n    }\n    if (tmp == NULL || tmp == Py_None) {\n        Py_CLEAR(tmp);\n        arg = NULL;\n    }\n    else {\n        int res;\n        res = obj2ast_identifier(tmp, &arg, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    }\n    if (lookup_attr_id(obj, &PyId_value, &tmp) < 0) {\n        return 1;\n    }\n    if (tmp == NULL) {\n        PyErr_SetString(PyExc_TypeError, \"required field \\\"value\\\" missing from keyword\");\n        return 1;\n    }\n    else {\n        int res;\n        res = obj2ast_expr(tmp, &value, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    }\n    *out = keyword(arg, value, arena);\n    return 0;\nfailed:\n    Py_XDECREF(tmp);\n    return 1;\n}","target":0,"flaw_line_index":0,"hash":"c8058c20-843c-4e7d-a413-c85e4385728b","idx":"24209e2a-aef4-4414-801d-a1dbe5231d7a"}
{"func_before":"static void dbEvalSetColumn(DbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[200];\n\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n\n    switch( sqlite3_column_type(pStmt, iCol) ) {\n    case SQLITE_BLOB: {\n        int bytes = sqlite3_column_bytes(pStmt, iCol);\n        const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol);\n        if( !zBlob ) {\n            return;\n        }","target":1,"flaw_line_index":0,"hash":"65c43e0e-bf36-4b4e-a391-e7f7be575b13","idx":"2afce5b6-37ef-43dc-9383-4721efe67c3b"}
{"func_before":"static void dbEvalSetColumn(DbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[JSI_MAX_NUMBER_STRING];\n\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n\n    switch( sqlite3_column_type(pStmt, iCol) ) {\n    case SQLITE_BLOB: {\n        int bytes = sqlite3_column_bytes(pStmt, iCol);\n        const char *zBlob = (char*)sqlite3_column_blob(pStmt, iCol);\n        if( !zBlob ) {\n            return;\n        }","target":0,"flaw_line_index":0,"hash":"8a0c6216-e5bf-484f-8ba0-be9c0ababfdf","idx":"baed516f-62ee-4ee4-bc63-6dd2c6c30d2d"}
{"func_before":"FontData::FontData(FontData* data, int32_t offset) {\n  Init(data->array_);\n  Bound(data->bound_offset_ + offset,\n        (data->bound_length_ == GROWABLE_SIZE)\n            ? GROWABLE_SIZE : data->bound_length_ - offset);\n}","target":1,"flaw_line_index":0,"hash":"16efeced-a24d-4466-a045-28dc4824efd0","idx":"8d5dfc0c-6e11-47c3-8f07-1ae37efdd19c"}
{"func_before":"FontData::FontData(FontData* data, int32_t offset) {\n  Init(data->array_);\n  Bound(data->bound_offset_ + offset,\n        (data->bound_length_ == GROWABLE_SIZE)\n        ? GROWABLE_SIZE : data->bound_length_ - offset);\n}","target":0,"flaw_line_index":0,"hash":"6f2699b4-3fa1-48b9-b178-c0a3c7997a81","idx":"10e65445-604f-47fc-8989-ebdc1e2f00e1"}
{"func_before":"static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_test(&ucounts->count)) {\n\t\tspin_lock_irqsave(&ucounts_lock, flags);\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\n\t\tkfree(ucounts);\n\t}\n}","target":1,"flaw_line_index":0,"hash":"a93f04ba-00b2-41dc-9f3d-940f415f0581","idx":"7debd94f-ba0c-4562-b366-0c10c2c2c646"}
{"func_before":"static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ucounts_lock, flags);\n\tucounts->count -= 1;\n\tif (!ucounts->count)\n\t\thlist_del_init(&ucounts->node);\n\telse\n\t\tucounts = NULL;\n\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\n\tkfree(ucounts);\n}","target":0,"flaw_line_index":0,"hash":"6c96273c-1a0f-4877-8926-580cb8a65173","idx":"55a64e6e-8e7d-4a00-ab83-86060cd8634d"}
{"func_before":"void CZNC::ForceEncoding() {\n    m_uiForceEncoding++;\n#ifdef HAVE_ICU\n    for (Csock* pSock : GetManager()) {\n        if (pSock->GetEncoding().empty()) {\n            pSock->SetEncoding(\"UTF-8\");\n        }\n    }\n#endif\n}","target":1,"flaw_line_index":0,"hash":"71800434-61a1-4111-ad28-17961e5e52fd","idx":"c058a244-0132-4b21-ab67-64345760e1bf"}
{"func_before":"void CZNC::ForceEncoding() {\n    m_uiForceEncoding++;\n#ifdef HAVE_ICU\n    for (Csock* pSock : GetManager()) {\n        pSock->SetEncoding(FixupEncoding(pSock->GetEncoding()));\n    }\n#endif\n}","target":0,"flaw_line_index":0,"hash":"f7407e3f-6b36-45e1-bce9-dfb1c3d38492","idx":"5743ee82-aeda-485d-85ab-85d637545ff1"}
{"func_before":"\t}\n      }\n      if (!error)\n      {\n\tif ((param->testflag & (T_REP_BY_SORT | T_REP_PARALLEL)) &&\n\t    (mi_is_any_key_active(share->state.key_map) ||\n\t     (rep_quick && !param->keys_in_use && !recreate)) &&\n\t    mi_test_if_sort_rep(info, info->state->records,\n\t\t\t\tinfo->s->state.key_map,\n\t\t\t\tparam->force_sort))\n\t{\n          if (param->testflag & T_REP_BY_SORT)\n            error=mi_repair_by_sort(param,info,filename,rep_quick);\n          else\n            error=mi_repair_parallel(param,info,filename,rep_quick);\n\t  state_updated=1;\n\t}\n\telse if (param->testflag & T_REP_ANY)\n\t  error=mi_repair(param, info,filename,rep_quick);\n      }\n      if (!error && param->testflag & T_SORT_RECORDS)\n      {\n\t\/*\n\t  The data file is nowadays reopened in the repair code so we should\n\t  soon remove the following reopen-code\n\t*\/\n#ifndef TO_BE_REMOVED\n\tif (param->out_flag & O_NEW_DATA)\n\t{\t\t\t\/* Change temp file to org file *\/\n\n\t  error=mi_sort_records(param,info,filename,param->opt_sort_key,\n                             \/* what is the following parameter for ? *\/\n\t\t\t\t(my_bool) !(param->testflag & T_REP),\n\t\t\t\tupdate_index);\n\t  datafile=info->dfile;\t\/* This is now locked *\/\n\t  if (!error && !update_index)\n\t  {\n\t    if (param->verbose)\n\t      puts(\"Table had a compressed index;  We must now recreate the index\");\n\t    error=mi_repair_by_sort(param,info,filename,1);\n\t  }\n\t}\n      }\n      if (!error && param->testflag & T_SORT_INDEX)\n\terror=mi_sort_index(param,info,filename);\n      if (!error)\n\tshare->state.changed&= ~(STATE_CHANGED | STATE_CRASHED |\n\t\t\t\t STATE_CRASHED_ON_REPAIR);\n      else\n\tmi_mark_crashed(info);\n    }\n    else if ((param->testflag & T_CHECK) || !(param->testflag & T_AUTO_INC))\n    {\n      if (!(param->testflag & T_SILENT) || param->testflag & T_INFO)\n\tprintf(\"Checking MyISAM file: %s\\n\",filename);","target":1,"flaw_line_index":0,"hash":"9f00ce74-4127-4873-ae21-11456c53b0d3","idx":"5f697756-1923-46ba-8eb4-2e1dfa49090c"}
{"func_before":"      }\n      if (!error)\n      {\n\tif ((param->testflag & (T_REP_BY_SORT | T_REP_PARALLEL)) &&\n\t    (mi_is_any_key_active(share->state.key_map) ||\n\t     (rep_quick && !param->keys_in_use && !recreate)) &&\n\t    mi_test_if_sort_rep(info, info->state->records,\n\t\t\t\tinfo->s->state.key_map,\n\t\t\t\tparam->force_sort))\n\t{\n          \/*\n            The new file might not be created with the right stats depending\n            on how myisamchk is run, so we must copy file stats from old to new.\n          *\/\n          if (param->testflag & T_REP_BY_SORT)\n            error= mi_repair_by_sort(param, info, filename, rep_quick, FALSE);\n          else\n            error= mi_repair_parallel(param, info, filename, rep_quick, FALSE);\n\t  state_updated=1;\n\t}\n\telse if (param->testflag & T_REP_ANY)\n\t  error= mi_repair(param, info, filename, rep_quick, FALSE);\n      }\n      if (!error && param->testflag & T_SORT_RECORDS)\n      {\n\t\/*\n\t  The data file is nowadays reopened in the repair code so we should\n\t  soon remove the following reopen-code\n\t*\/\n#ifndef TO_BE_REMOVED\n\tif (param->out_flag & O_NEW_DATA)\n\t{\t\t\t\/* Change temp file to org file *\/\n\n\t  error=mi_sort_records(param,info,filename,param->opt_sort_key,\n                             \/* what is the following parameter for ? *\/\n\t\t\t\t(my_bool) !(param->testflag & T_REP),\n\t\t\t\tupdate_index);\n\t  datafile=info->dfile;\t\/* This is now locked *\/\n\t  if (!error && !update_index)\n\t  {\n\t    if (param->verbose)\n\t      puts(\"Table had a compressed index;  We must now recreate the index\");\n\t    error= mi_repair_by_sort(param, info, filename, 1, FALSE);\n\t  }\n\t}\n      }\n      if (!error && param->testflag & T_SORT_INDEX)\n\terror= mi_sort_index(param, info, filename, FALSE);\n      if (!error)\n\tshare->state.changed&= ~(STATE_CHANGED | STATE_CRASHED |\n\t\t\t\t STATE_CRASHED_ON_REPAIR);\n      else\n\tmi_mark_crashed(info);\n    }\n    else if ((param->testflag & T_CHECK) || !(param->testflag & T_AUTO_INC))\n    {\n      if (!(param->testflag & T_SILENT) || param->testflag & T_INFO)\n\tprintf(\"Checking MyISAM file: %s\\n\",filename);","target":0,"flaw_line_index":0,"hash":"6bb05a81-0811-4643-9f36-651dbaec488e","idx":"a684db58-1dd3-4a97-a74d-92a2e0078039"}
{"func_before":"void luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + (inuse \/ 8) + 2*EXTRA_STACK;\n  if (goodsize > LUAI_MAXSTACK)\n    goodsize = LUAI_MAXSTACK;  \/* respect stack limit *\/\n  \/* if thread is currently not handling a stack overflow and its\n     good size is smaller than current size, shrink its stack *\/\n  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) &&\n      goodsize < L->stacksize)\n    luaD_reallocstack(L, goodsize, 0);  \/* ok if that fails *\/\n  else  \/* don't change stack *\/\n    condmovestack(L,{},{});  \/* (change only for debugging) *\/\n  luaE_shrinkCI(L);  \/* shrink CI list *\/\n}","target":1,"flaw_line_index":0,"hash":"0c82a928-6a23-4f9e-b11a-e303b4b06eb8","idx":"c98e3e90-e80e-41ba-8d53-9a4fbe49ebea"}
{"func_before":"void luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + BASIC_STACK_SIZE;\n  if (goodsize > LUAI_MAXSTACK)\n    goodsize = LUAI_MAXSTACK;  \/* respect stack limit *\/\n  \/* if thread is currently not handling a stack overflow and its\n     good size is smaller than current size, shrink its stack *\/\n  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) && goodsize < L->stacksize)\n    luaD_reallocstack(L, goodsize, 0);  \/* ok if that fails *\/\n  else  \/* don't change stack *\/\n    condmovestack(L,{},{});  \/* (change only for debugging) *\/\n  luaE_shrinkCI(L);  \/* shrink CI list *\/\n}","target":0,"flaw_line_index":0,"hash":"b1220e03-825c-4482-98c3-ca2bad557570","idx":"414d3c05-35d3-44a8-bc82-0b5bfdf3c3b7"}
{"func_before":"            }\n        } else if (!strcasecmp(argv[0],\"slowlog-max-len\") && argc == 2) {\n            server.slowlog_max_len = strtoll(argv[1],NULL,10);\n        } else if (!strcasecmp(argv[0],\"client-output-buffer-limit\") &&\n                   argc == 5)\n        {\n            int class = getClientTypeByName(argv[1]);\n            unsigned long long hard, soft;\n            int soft_seconds;\n\n            if (class == -1) {\n                err = \"Unrecognized client limit class\";\n                goto loaderr;\n            }\n            hard = memtoll(argv[2],NULL);\n            soft = memtoll(argv[3],NULL);\n            soft_seconds = atoi(argv[4]);\n            if (soft_seconds < 0) {\n                err = \"Negative number of seconds in soft limit is invalid\";\n                goto loaderr;\n            }\n            server.client_obuf_limits[class].hard_limit_bytes = hard;","target":1,"flaw_line_index":0,"hash":"f6cc783f-2d07-4648-88f7-78948d44f69f","idx":"f14090f6-1be6-4eb0-ac5b-3e3edc8d2549"}
{"func_before":"            }\n        } else if (!strcasecmp(argv[0],\"slowlog-max-len\") && argc == 2) {\n            server.slowlog_max_len = strtoll(argv[1],NULL,10);\n        } else if (!strcasecmp(argv[0],\"client-output-buffer-limit\") &&\n                   argc == 5)\n        {\n            int class = getClientTypeByName(argv[1]);\n            unsigned long long hard, soft;\n            int soft_seconds;\n\n            if (class == -1 || class == CLIENT_TYPE_MASTER) {\n                err = \"Unrecognized client limit class: the user specified \"\n                \"an invalid one, or 'master' which has no buffer limits.\";\n                goto loaderr;\n            }\n            hard = memtoll(argv[2],NULL);\n            soft = memtoll(argv[3],NULL);\n            soft_seconds = atoi(argv[4]);\n            if (soft_seconds < 0) {\n                err = \"Negative number of seconds in soft limit is invalid\";\n                goto loaderr;\n            }\n            server.client_obuf_limits[class].hard_limit_bytes = hard;","target":0,"flaw_line_index":0,"hash":"dd1641bd-e492-461f-88c7-ecd80087150f","idx":"5c660f39-6404-4116-846b-5f4977a121b7"}
{"func_before":"static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  const struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\n\tif (!dst)\n\t\tgoto out;\n\n\t\/* Yes, checking route validity in not connected\n\t * case is not very simple. Take into account,\n\t * that we do not support routing by source, TOS,\n\t * and MSG_DONTROUTE \t\t--ANK (980726)\n\t *\n\t * 1. ip6_rt_check(): If route was host route,\n\t *    check that cached destination is current.\n\t *    If it is network route, we still may\n\t *    check its validity using saved pointer\n\t *    to the last used address: daddr_cache.","target":1,"flaw_line_index":0,"hash":"495d615c-fb49-4191-ad52-3ab2c9f7b8bf","idx":"89f23df6-5ae3-4b0a-8477-ea3c3491ad0d"}
{"func_before":"static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  const struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt;\n\n\tif (!dst)\n\t\tgoto out;\n\n\tif (dst->ops->family != AF_INET6) {\n\t\tdst_release(dst);\n\t\treturn NULL;\n\t}\n\n\trt = (struct rt6_info *)dst;\n\t\/* Yes, checking route validity in not connected\n\t * case is not very simple. Take into account,\n\t * that we do not support routing by source, TOS,\n\t * and MSG_DONTROUTE \t\t--ANK (980726)\n\t *\n\t * 1. ip6_rt_check(): If route was host route,\n\t *    check that cached destination is current.\n\t *    If it is network route, we still may\n\t *    check its validity using saved pointer\n\t *    to the last used address: daddr_cache.","target":0,"flaw_line_index":0,"hash":"64bafb38-8f94-46b3-a910-4e86c5c82967","idx":"9c269211-6a6f-4490-a585-e9e6015caf67"}
{"func_before":"\t{\n\t  xd3_rinst *inst = xd3_rlist_pop_front (& stream->iopt_used);\n\n\t  switch (inst->type)\n\t    {\n\t    case XD3_RUN: *rptr++ = 'R'; break;\n\t    case XD3_CPY: *rptr++ = 'C'; break;\n\t    default: CHECK(0);\n\t    }\n\n\t  snprintf_func (rptr, rbuf+TESTBUFSIZE-rptr, \"%d\/%d\", \n\t\t\t inst->pos, inst->size);\n\t  rptr += strlen (rptr);\n\n\t  if (inst->type == XD3_CPY)\n\t    {\n\t      *rptr++ = '@';\n\t      snprintf_func (rptr, rbuf+TESTBUFSIZE-rptr, \"%\"Q\"d\", inst->addr);\n\t      rptr += strlen (rptr);\n\t    }\n","target":1,"flaw_line_index":0,"hash":"5b56d5bf-0f05-4c93-a7d6-24dca4bd5de2","idx":"738092e9-2409-4c67-bb79-732c49734ef2"}
{"func_before":"\t{\n\t  xd3_rinst *inst = xd3_rlist_pop_front (& stream->iopt_used);\n\n\t  switch (inst->type)\n\t    {\n\t    case XD3_RUN: *rptr++ = 'R'; break;\n\t    case XD3_CPY: *rptr++ = 'C'; break;\n\t    default: CHECK(0);\n\t    }\n\n\t  snprintf_func (rptr, rbuf+TESTBUFSIZE-rptr, \"%d\/%d\",\n\t\t\t inst->pos, inst->size);\n\t  rptr += strlen (rptr);\n\n\t  if (inst->type == XD3_CPY)\n\t    {\n\t      *rptr++ = '@';\n\t      snprintf_func (rptr, rbuf+TESTBUFSIZE-rptr, \"%\"Q\"d\", inst->addr);\n\t      rptr += strlen (rptr);\n\t    }\n","target":0,"flaw_line_index":0,"hash":"ace18619-5491-4091-af70-776305c4baf3","idx":"dd687e99-fa8d-4a5d-a1f5-b1e5f99a818b"}
{"func_before":"zfs_groupmember(zfsvfs_t *zfsvfs, uint64_t id, cred_t *cr)\n{\n#ifdef HAVE_KSID\n\tksid_t\t\t*ksid = crgetsid(cr, KSID_GROUP);\n\tksidlist_t\t*ksidlist = crgetsidlist(cr);\n\tuid_t\t\tgid;\n\n\tif (ksid && ksidlist) {\n\t\tint\t\ti;\n\t\tksid_t\t\t*ksid_groups;\n\t\tuint32_t\tidx = FUID_INDEX(id);\n\t\tuint32_t\trid = FUID_RID(id);\n\n\t\tksid_groups = ksidlist->ksl_sids;\n\n\t\tfor (i = 0; i != ksidlist->ksl_nsid; i++) {\n\t\t\t\tif (strcmp(domain,\n\t\t\t\t    IDMAP_WK_CREATOR_SID_AUTHORITY) == 0)\n\t\t\t\t\treturn (B_FALSE);\n\n\t\t\t\tif ((strcmp(domain,\n\t\t\t\t    ksid_groups[i].ks_domain->kd_name) == 0) &&\n\t\t\t\t    rid == ksid_groups[i].ks_rid)\n\t\t\t\t\treturn (B_TRUE);\n\t\t\t}\n\t\t}\n\t}\n\n\t\/*\n\t * Not found in ksidlist, check posix groups\n\t *\/\n\tgid = zfs_fuid_map_id(zfsvfs, id, cr, ZFS_GROUP);\n\treturn (groupmember(gid, cr));\n#else\n\treturn (B_TRUE);\n#endif\n}","target":1,"flaw_line_index":0,"hash":"76707f8c-c311-48fc-a1b0-5af5d05b26f0","idx":"73cdd8e2-1fd1-4e14-bb22-5c9382334ff7"}
{"func_before":"zfs_groupmember(zfsvfs_t *zfsvfs, uint64_t id, cred_t *cr)\n{\n#ifdef HAVE_KSID\n\tuid_t\t\tgid;\n\n#ifdef illumos\n\tksid_t\t\t*ksid = crgetsid(cr, KSID_GROUP);\n\tksidlist_t\t*ksidlist = crgetsidlist(cr);\n\n\tif (ksid && ksidlist) {\n\t\tint\t\ti;\n\t\tksid_t\t\t*ksid_groups;\n\t\tuint32_t\tidx = FUID_INDEX(id);\n\t\tuint32_t\trid = FUID_RID(id);\n\n\t\tksid_groups = ksidlist->ksl_sids;\n\n\t\tfor (i = 0; i != ksidlist->ksl_nsid; i++) {\n\t\t\t\t    IDMAP_WK_CREATOR_SID_AUTHORITY) == 0)\n\t\t\t\t\treturn (B_FALSE);\n\n\t\t\t\tif ((strcmp(domain,\n\t\t\t\t    ksid_groups[i].ks_domain->kd_name) == 0) &&\n\t\t\t\t    rid == ksid_groups[i].ks_rid)\n\t\t\t\t\treturn (B_TRUE);\n\t\t\t}\n\t\t}\n\t}\n#endif \/* illumos *\/\n\n\t\/*\n\t * Not found in ksidlist, check posix groups\n\t *\/\n\tgid = zfs_fuid_map_id(zfsvfs, id, cr, ZFS_GROUP);\n\treturn (groupmember(gid, cr));\n#else\n\treturn (B_TRUE);\n#endif\n}","target":0,"flaw_line_index":0,"hash":"470ef441-3cbc-4e59-9ffb-150db66b405f","idx":"6572bb01-457e-433d-97f9-83432619726a"}
{"func_before":"static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t\/* This is the main host *\/\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\t\/* That's us.  Be sure we keep track of the peer call number *\/\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t\/* We're transferring *\/\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}","target":1,"flaw_line_index":0,"hash":"257a9d71-7fba-4638-9c1d-63833a24ca24","idx":"78ce0a5b-83d3-4f2c-9860-ef45e48187d7"}
{"func_before":"static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t\/* This is the main host *\/\n\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n\t\t\t\/* That's us.  Be sure we keep track of the peer call number *\/\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t\/* We're transferring *\/\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}","target":0,"flaw_line_index":0,"hash":"894f38cb-bc34-42e1-b74f-3a948990982b","idx":"5cb3c87c-f3ab-4cad-9444-b6bbb53d4386"}
{"func_before":"\t\t     struct path *path,\n\t\t     unsigned int uid, unsigned int gid)\n{\n\tconst struct smb_sid *psid, *creator = NULL;\n\tstruct smb_ace *parent_aces, *aces;\n\tstruct smb_acl *parent_pdacl;\n\tstruct smb_ntsd *parent_pntsd = NULL;\n\tstruct smb_sid owner_sid, group_sid;\n\tstruct dentry *parent = path->dentry->d_parent;\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0;\n\tint rc = 0, num_aces, dacloffset, pntsd_type, acl_len;\n\tchar *aces_base;\n\tbool is_dir = S_ISDIR(d_inode(path->dentry)->i_mode);\n\n\tacl_len = ksmbd_vfs_get_sd_xattr(conn, user_ns,\n\t\t\t\t\t parent, &parent_pntsd);\n\tif (acl_len <= 0)\n\t\treturn -ENOENT;\n\tdacloffset = le32_to_cpu(parent_pntsd->dacloffset);\n\tif (!dacloffset) {\n\t\trc = -EINVAL;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\tparent_pdacl = (struct smb_acl *)((char *)parent_pntsd + dacloffset);\n\tnum_aces = le32_to_cpu(parent_pdacl->num_aces);\n\tpntsd_type = le16_to_cpu(parent_pntsd->type);\n\n\taces_base = kmalloc(sizeof(struct smb_ace) * num_aces * 2, GFP_KERNEL);\n\tif (!aces_base) {\n\t\trc = -ENOMEM;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\taces = (struct smb_ace *)aces_base;\n\tparent_aces = (struct smb_ace *)((char *)parent_pdacl +\n\t\t\tsizeof(struct smb_acl));\n\n\tif (pntsd_type & DACL_AUTO_INHERITED)\n\t\tinherited_flags = INHERITED_ACE;\n\n\tfor (i = 0; i < num_aces; i++) {\n\t\tflags = parent_aces->flags;\n\t\tif (!smb_inherit_flags(flags, is_dir))\n\t\t\tgoto pass;\n\t\tif (is_dir) {\n\t\t\tflags &= ~(INHERIT_ONLY_ACE | INHERITED_ACE);\n\t\t\tif (!(flags & CONTAINER_INHERIT_ACE))\n\t\t\t\tflags |= INHERIT_ONLY_ACE;\n\t\t\tif (flags & NO_PROPAGATE_INHERIT_ACE)\n\t\t\t\tflags = 0;\n\t\t} else {\n\t\t} else if (is_dir && !(parent_aces->flags & NO_PROPAGATE_INHERIT_ACE)) {\n\t\t\tpsid = &parent_aces->sid;\n\t\t}\n\n\t\tsmb_set_ace(aces, psid, parent_aces->type, flags | inherited_flags,\n\t\t\t    parent_aces->access_req);\n\t\tnt_size += le16_to_cpu(aces->size);\n\t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n\t\tace_cnt++;\npass:\n\t\tparent_aces =\n\t\t\t(struct smb_ace *)((char *)parent_aces + le16_to_cpu(parent_aces->size));\n\t}\n\n\tif (nt_size > 0) {\n\t\tstruct smb_ntsd *pntsd;\n\t\tstruct smb_acl *pdacl;\n\t\tstruct smb_sid *powner_sid = NULL, *pgroup_sid = NULL;\n\t\tint powner_sid_size = 0, pgroup_sid_size = 0, pntsd_size;\n\n\t\tif (parent_pntsd->osidoffset) {\n\t\t\tpowner_sid = (struct smb_sid *)((char *)parent_pntsd +","target":1,"flaw_line_index":0,"hash":"586ff493-0819-4e90-8cd5-6b09a1a996db","idx":"d16de7bf-b860-4082-822b-6c11667cfcdc"}
{"func_before":"\t\t     struct path *path,\n\t\t     unsigned int uid, unsigned int gid)\n{\n\tconst struct smb_sid *psid, *creator = NULL;\n\tstruct smb_ace *parent_aces, *aces;\n\tstruct smb_acl *parent_pdacl;\n\tstruct smb_ntsd *parent_pntsd = NULL;\n\tstruct smb_sid owner_sid, group_sid;\n\tstruct dentry *parent = path->dentry->d_parent;\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0, pdacl_size;\n\tint rc = 0, num_aces, dacloffset, pntsd_type, pntsd_size, acl_len, aces_size;\n\tchar *aces_base;\n\tbool is_dir = S_ISDIR(d_inode(path->dentry)->i_mode);\n\n\tpntsd_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,\n\t\t\t\t\t    parent, &parent_pntsd);\n\tif (pntsd_size <= 0)\n\t\treturn -ENOENT;\n\tdacloffset = le32_to_cpu(parent_pntsd->dacloffset);\n\tif (!dacloffset || (dacloffset + sizeof(struct smb_acl) > pntsd_size)) {\n\t\trc = -EINVAL;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\tparent_pdacl = (struct smb_acl *)((char *)parent_pntsd + dacloffset);\n\tacl_len = pntsd_size - dacloffset;\n\tnum_aces = le32_to_cpu(parent_pdacl->num_aces);\n\tpntsd_type = le16_to_cpu(parent_pntsd->type);\n\tpdacl_size = le16_to_cpu(parent_pdacl->size);\n\n\tif (pdacl_size > acl_len || pdacl_size < sizeof(struct smb_acl)) {\n\t\trc = -EINVAL;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\taces_base = kmalloc(sizeof(struct smb_ace) * num_aces * 2, GFP_KERNEL);\n\tif (!aces_base) {\n\t\trc = -ENOMEM;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\taces = (struct smb_ace *)aces_base;\n\tparent_aces = (struct smb_ace *)((char *)parent_pdacl +\n\t\t\tsizeof(struct smb_acl));\n\taces_size = acl_len - sizeof(struct smb_acl);\n\n\tif (pntsd_type & DACL_AUTO_INHERITED)\n\t\tinherited_flags = INHERITED_ACE;\n\n\tfor (i = 0; i < num_aces; i++) {\n\t\tint pace_size;\n\n\t\tif (offsetof(struct smb_ace, access_req) > aces_size)\n\t\t\tbreak;\n\n\t\tpace_size = le16_to_cpu(parent_aces->size);\n\t\tif (pace_size > aces_size)\n\t\t\tbreak;\n\n\t\taces_size -= pace_size;\n\n\t\tflags = parent_aces->flags;\n\t\tif (!smb_inherit_flags(flags, is_dir))\n\t\t\tgoto pass;\n\t\tif (is_dir) {\n\t\t\tflags &= ~(INHERIT_ONLY_ACE | INHERITED_ACE);\n\t\t\tif (!(flags & CONTAINER_INHERIT_ACE))\n\t\t\t\tflags |= INHERIT_ONLY_ACE;\n\t\t\tif (flags & NO_PROPAGATE_INHERIT_ACE)\n\t\t\t\tflags = 0;\n\t\t} else {\n\t\t} else if (is_dir && !(parent_aces->flags & NO_PROPAGATE_INHERIT_ACE)) {\n\t\t\tpsid = &parent_aces->sid;\n\t\t}\n\n\t\tsmb_set_ace(aces, psid, parent_aces->type, flags | inherited_flags,\n\t\t\t    parent_aces->access_req);\n\t\tnt_size += le16_to_cpu(aces->size);\n\t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n\t\tace_cnt++;\npass:\n\t\tparent_aces = (struct smb_ace *)((char *)parent_aces + pace_size);\n\t}\n\n\tif (nt_size > 0) {\n\t\tstruct smb_ntsd *pntsd;\n\t\tstruct smb_acl *pdacl;\n\t\tstruct smb_sid *powner_sid = NULL, *pgroup_sid = NULL;\n\t\tint powner_sid_size = 0, pgroup_sid_size = 0, pntsd_size;\n\n\t\tif (parent_pntsd->osidoffset) {\n\t\t\tpowner_sid = (struct smb_sid *)((char *)parent_pntsd +","target":0,"flaw_line_index":0,"hash":"4bc9a861-cf88-41ff-9e24-9650985547e1","idx":"518c46a3-e65b-4d5a-859d-01c9053fab76"}
{"func_before":"mrb_proc_copy(struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    \/* already initialized proc *\/\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(NULL, (mrb_irep*)a->body.irep);\n  }\n  a->upper = b->upper;\n  a->e.env = b->e.env;\n  \/* a->e.target_class = a->e.target_class; *\/\n}","target":1,"flaw_line_index":0,"hash":"6f26b155-332f-4a18-afc3-acf38052b5ec","idx":"87902bcb-252f-467d-8fc8-76171c281e1a"}
{"func_before":"mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    \/* already initialized proc *\/\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  a->upper = b->upper;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);\n  }\n  a->e.env = b->e.env;\n  \/* a->e.target_class = a->e.target_class; *\/\n}","target":0,"flaw_line_index":0,"hash":"c59604e1-b9d7-471c-8b82-2c97c51b937a","idx":"e257d361-e7a4-4c6f-bb57-fe3f186a10cd"}
{"func_before":"    if (free >= need) {\n        memmove(bot, tok, copy);\n        shift_ptrs_and_fpos(-static_cast<ptrdiff_t>(free));\n    }\n    else {\n        BSIZE += std::max(BSIZE, need);\n        char * buf = new char[BSIZE + YYMAXFILL];\n        if (!buf) fatal(\"out of memory\");\n\n        memmove(buf, tok, copy);\n        shift_ptrs_and_fpos(buf - bot);\n        delete [] bot;\n        bot = buf;\n\n        free = BSIZE - copy;\n    }\n\n    if (!read(free)) {\n        eof = lim;\n        memset(lim, 0, YYMAXFILL);\n        lim += YYMAXFILL;\n    }\n\n    return true;\n}","target":1,"flaw_line_index":0,"hash":"78e2d953-18f1-4a8b-8e00-e7b975009a5b","idx":"a44ac392-2364-43bf-a39e-4bf945af4a02"}
{"func_before":"    if (free >= need) {\n        memmove(bot, tok, copy);\n        shift_ptrs_and_fpos(-static_cast<ptrdiff_t>(free));\n    }\n    else {\n        BSIZE += std::max(BSIZE, need);\n        char * buf = new char[BSIZE + YYMAXFILL];\n        if (!buf) fatal(\"out of memory\");\n\n        memmove(buf, tok, copy);\n        shift_ptrs_and_fpos(buf - tok);\n        delete [] bot;\n        bot = buf;\n\n        free = BSIZE - copy;\n    }\n\n    DASSERT(lim + free <= bot + BSIZE);\n    if (!read(free)) {\n        eof = lim;\n        memset(lim, 0, YYMAXFILL);\n        lim += YYMAXFILL;\n    }\n\n    return true;\n}","target":0,"flaw_line_index":0,"hash":"ed8c6335-0fc1-4015-8743-7821e361d28c","idx":"5c8704b7-a25b-47f6-99a6-800bd7150c4a"}
{"func_before":"\t\t\t\tGFP_KERNEL);\n\t\tif (!slots)\n\t\t\tgoto out_free;\n\t\tslot = id_to_memslot(slots, mem->slot);\n\t\tslot->flags |= KVM_MEMSLOT_INVALID;\n\n\t\tupdate_memslots(slots, NULL);\n\n\t\told_memslots = kvm->memslots;\n\t\trcu_assign_pointer(kvm->memslots, slots);\n\t\tsynchronize_srcu_expedited(&kvm->srcu);\n\t\t\/* From this point no new shadow pages pointing to a deleted,\n\t\t * or moved, memslot will be created.\n\t\t *\n\t\t * validation of sp->gfn happens in:\n\t\t * \t- gfn_to_hva (kvm_read_guest, gfn_to_pfn)\n\t\t * \t- kvm_is_visible_gfn (mmu_check_roots)\n\t\t *\/\n\t\tkvm_arch_flush_shadow_memslot(kvm, slot);\n\t\tkfree(old_memslots);\n\t}\n\n\tr = kvm_arch_prepare_memory_region(kvm, &new, old, mem, user_alloc);\n\tif (r)\n\t\tgoto out_free;\n\n\t\/* map\/unmap the pages in iommu page table *\/\n\tif (npages) {\n\t\tr = kvm_iommu_map_pages(kvm, &new);\n\t\tif (r)\n\t\t\tgoto out_free;\n\t} else\n\t\tkvm_iommu_unmap_pages(kvm, &old);\n\n\tr = -ENOMEM;\n\tslots = kmemdup(kvm->memslots, sizeof(struct kvm_memslots),\n\t\t\tGFP_KERNEL);\n\tif (!slots)\n\t\tgoto out_free;\n\n\t\/* actual memory is freed via old in kvm_free_physmem_slot below *\/\n\tif (!npages) {\n\t\tnew.dirty_bitmap = NULL;\n\t\tmemset(&new.arch, 0, sizeof(new.arch));\n\t}\n\n\tupdate_memslots(slots, &new);\n\told_memslots = kvm->memslots;\n\trcu_assign_pointer(kvm->memslots, slots);\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\n\tkvm_arch_commit_memory_region(kvm, mem, old, user_alloc);\n\n\tkvm_free_physmem_slot(&old, &new);\n\tkfree(old_memslots);\n\n\treturn 0;\n\nout_free:\n\tkvm_free_physmem_slot(&new, &old);\nout:\n\treturn r;\n\n}","target":1,"flaw_line_index":0,"hash":"f66111e4-430e-4e33-9457-d5d70948e630","idx":"be75514f-2814-4bb7-9b2f-6e5b2f05a7a9"}
{"func_before":"\t\tif (!slots)\n\t\t\tgoto out_free;\n\t\tslot = id_to_memslot(slots, mem->slot);\n\t\tslot->flags |= KVM_MEMSLOT_INVALID;\n\n\t\tupdate_memslots(slots, NULL);\n\n\t\told_memslots = kvm->memslots;\n\t\trcu_assign_pointer(kvm->memslots, slots);\n\t\tsynchronize_srcu_expedited(&kvm->srcu);\n\t\t\/* slot was deleted or moved, clear iommu mapping *\/\n\t\tkvm_iommu_unmap_pages(kvm, &old);\n\t\t\/* From this point no new shadow pages pointing to a deleted,\n\t\t * or moved, memslot will be created.\n\t\t *\n\t\t * validation of sp->gfn happens in:\n\t\t * \t- gfn_to_hva (kvm_read_guest, gfn_to_pfn)\n\t\t * \t- kvm_is_visible_gfn (mmu_check_roots)\n\t\t *\/\n\t\tkvm_arch_flush_shadow_memslot(kvm, slot);\n\t\tkfree(old_memslots);\n\t}\n\n\tr = kvm_arch_prepare_memory_region(kvm, &new, old, mem, user_alloc);\n\tif (r)\n\t\tgoto out_free;\n\n\tr = -ENOMEM;\n\tslots = kmemdup(kvm->memslots, sizeof(struct kvm_memslots),\n\t\t\tGFP_KERNEL);\n\tif (!slots)\n\t\tgoto out_free;\n\n\t\/* map new memory slot into the iommu *\/\n\tif (npages) {\n\t\tr = kvm_iommu_map_pages(kvm, &new);\n\t\tif (r)\n\t\t\tgoto out_slots;\n\t}\n\n\t\/* actual memory is freed via old in kvm_free_physmem_slot below *\/\n\tif (!npages) {\n\t\tnew.dirty_bitmap = NULL;\n\t\tmemset(&new.arch, 0, sizeof(new.arch));\n\t}\n\n\tupdate_memslots(slots, &new);\n\told_memslots = kvm->memslots;\n\trcu_assign_pointer(kvm->memslots, slots);\n\tsynchronize_srcu_expedited(&kvm->srcu);\n\n\tkvm_arch_commit_memory_region(kvm, mem, old, user_alloc);\n\n\tkvm_free_physmem_slot(&old, &new);\n\tkfree(old_memslots);\n\n\treturn 0;\n\nout_slots:\n\tkfree(slots);\nout_free:\n\tkvm_free_physmem_slot(&new, &old);\nout:\n\treturn r;\n\n}","target":0,"flaw_line_index":0,"hash":"113271c2-7f77-494f-8673-75bbedc33a84","idx":"0994c01a-c995-4f8e-9a44-ba6fb025627c"}
{"func_before":"check_owner_password_V4(std::string& user_password,\n                        std::string const& owner_password,\n                        QPDF::EncryptionData const& data)\n{\n    \/\/ Algorithm 3.7 from the PDF 1.7 Reference Manual\n\n    unsigned char key[OU_key_bytes_V4];\n    compute_O_rc4_key(user_password, owner_password, data, key);\n    unsigned char O_data[key_bytes];\n    memcpy(O_data, QUtil::unsigned_char_pointer(data.getO()), key_bytes);\n    iterate_rc4(O_data, key_bytes, key, data.getLengthBytes(),\n                (data.getR() >= 3) ? 20 : 1, true);\n    std::string new_user_password =\n        std::string(reinterpret_cast<char*>(O_data), key_bytes);\n    bool result = false;\n    if (check_user_password(new_user_password, data))\n    {\n        result = true;\n        user_password = new_user_password;\n    }\n    return result;","target":1,"flaw_line_index":0,"hash":"71d14bd6-727a-4290-88d4-6af9395f6f45","idx":"06d24f30-d1f0-4167-9f66-327c58582660"}
{"func_before":"check_owner_password_V4(std::string& user_password,\n                        std::string const& owner_password,\n                        QPDF::EncryptionData const& data)\n{\n    \/\/ Algorithm 3.7 from the PDF 1.7 Reference Manual\n\n    unsigned char key[OU_key_bytes_V4];\n    compute_O_rc4_key(user_password, owner_password, data, key);\n    unsigned char O_data[key_bytes];\n    memcpy(O_data, QUtil::unsigned_char_pointer(data.getO()), key_bytes);\n    std::string k1(reinterpret_cast<char*>(key), OU_key_bytes_V4);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(O_data, key_bytes, QUtil::unsigned_char_pointer(k1),\n                data.getLengthBytes(),\n                (data.getR() >= 3) ? 20 : 1, true);\n    std::string new_user_password =\n        std::string(reinterpret_cast<char*>(O_data), key_bytes);\n    bool result = false;\n    if (check_user_password(new_user_password, data))\n    {\n        result = true;\n        user_password = new_user_password;\n    }\n    return result;","target":0,"flaw_line_index":0,"hash":"ee555c74-b9c3-43d8-858e-9897881f3964","idx":"d394af12-81e9-4cd3-9b8a-d781825e31bd"}
{"func_before":"\treq.lower_file = lower_file;\n\treq.path.dentry = lower_dentry;\n\treq.path.mnt = lower_mnt;\n\n\t\/* Corresponding dput() and mntput() are done when the\n\t * lower file is fput() when all eCryptfs files for the inode are\n\t * released. *\/\n\tflags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;\n\t(*lower_file) = dentry_open(&req.path, flags, cred);\n\tif (!IS_ERR(*lower_file))\n\t\tgoto out;\n\tif ((flags & O_ACCMODE) == O_RDONLY) {\n\t\trc = PTR_ERR((*lower_file));\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\trc = -EIO;\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\tprintk(KERN_ERR \"%s: We are in the middle of shutting down; \"\n\t\t       \"aborting privileged request to open lower file\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&req.kthread_ctl_list, &ecryptfs_kthread_ctl.req_list);\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n\twait_for_completion(&req.done);\n\tif (IS_ERR(*lower_file))\n\t\trc = PTR_ERR(*lower_file);\nout:\n\treturn rc;\n}","target":1,"flaw_line_index":0,"hash":"1be2c45c-3313-480a-b81c-105fc4d464fa","idx":"ae57cf58-c7cc-4066-9411-b7fee690c49a"}
{"func_before":"\treq.lower_file = lower_file;\n\treq.path.dentry = lower_dentry;\n\treq.path.mnt = lower_mnt;\n\n\t\/* Corresponding dput() and mntput() are done when the\n\t * lower file is fput() when all eCryptfs files for the inode are\n\t * released. *\/\n\tflags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;\n\t(*lower_file) = dentry_open(&req.path, flags, cred);\n\tif (!IS_ERR(*lower_file))\n\t\tgoto have_file;\n\tif ((flags & O_ACCMODE) == O_RDONLY) {\n\t\trc = PTR_ERR((*lower_file));\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\tif (ecryptfs_kthread_ctl.flags & ECRYPTFS_KTHREAD_ZOMBIE) {\n\t\trc = -EIO;\n\t\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\t\tprintk(KERN_ERR \"%s: We are in the middle of shutting down; \"\n\t\t       \"aborting privileged request to open lower file\\n\",\n\t\t\t__func__);\n\t\tgoto out;\n\t}\n\tlist_add_tail(&req.kthread_ctl_list, &ecryptfs_kthread_ctl.req_list);\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n\twait_for_completion(&req.done);\n\tif (IS_ERR(*lower_file)) {\n\t\trc = PTR_ERR(*lower_file);\n\t\tgoto out;\n\t}\nhave_file:\n\tif ((*lower_file)->f_op->mmap == NULL) {\n\t\tfput(*lower_file);\n\t\t*lower_file = NULL;\n\t\trc = -EMEDIUMTYPE;\n\t}\nout:\n\treturn rc;\n}","target":0,"flaw_line_index":0,"hash":"749cae4d-9605-4f6a-b214-012155dfa6d2","idx":"d3d9e5a7-263c-4470-83b9-4874f2816891"}
{"func_before":"ast2obj_arguments(void* _o)\n{\n    arguments_ty o = (arguments_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    result = PyType_GenericNew(arguments_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_list(o->args, ast2obj_arg);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_args, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_arg(o->vararg);","target":1,"flaw_line_index":0,"hash":"b5f7322a-84e3-4016-8180-507a720372df","idx":"c00f8f81-194d-4667-87cb-6604cc0f333f"}
{"func_before":"ast2obj_arguments(void* _o)\n{\n    arguments_ty o = (arguments_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_RETURN_NONE;\n    }\n\n    result = PyType_GenericNew(arguments_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_list(o->args, ast2obj_arg);\n    if (!value) goto failed;\n    if (_PyObject_SetAttrId(result, &PyId_args, value) == -1)\n        goto failed;\n    Py_DECREF(value);\n    value = ast2obj_arg(o->vararg);","target":0,"flaw_line_index":0,"hash":"e54ca723-9645-4be5-80a9-1976e011ccbf","idx":"b8fa900c-e2d0-40ae-90c6-d936397dfc3e"}
{"func_before":"static void infra_ip_create_ratedata(struct infra_cache* infra,\n\tstruct sockaddr_storage* addr, socklen_t addrlen, time_t timenow)\n{\n\thashvalue_type h = hash_addr(addr, addrlen, 0);\n\tstruct ip_rate_key* k = (struct ip_rate_key*)calloc(1, sizeof(*k));\n\tstruct ip_rate_data* d = (struct ip_rate_data*)calloc(1, sizeof(*d));\n\tif(!k || !d) {\n\t\tfree(k);\n\t\tfree(d);\n\t\treturn; \/* alloc failure *\/\n\t}\n\tk->addr = *addr;\n\tk->addrlen = addrlen;\n\tlock_rw_init(&k->entry.lock);\n\tk->entry.hash = h;\n\tk->entry.key = k;\n\tk->entry.data = d;\n\td->qps[0] = 1;\n\td->timestamp[0] = timenow;\n\tslabhash_insert(infra->client_ip_rates, h, &k->entry, d, NULL);\n}","target":1,"flaw_line_index":0,"hash":"ce4b9c1c-4de4-487d-9431-fb0067cb3cf9","idx":"af8cea20-9958-48d0-9571-cbb390fd3b94"}
{"func_before":"static void infra_ip_create_ratedata(struct infra_cache* infra,\n\tstruct sockaddr_storage* addr, socklen_t addrlen, time_t timenow,\n\tint mesh_wait)\n{\n\thashvalue_type h = hash_addr(addr, addrlen, 0);\n\tstruct ip_rate_key* k = (struct ip_rate_key*)calloc(1, sizeof(*k));\n\tstruct ip_rate_data* d = (struct ip_rate_data*)calloc(1, sizeof(*d));\n\tif(!k || !d) {\n\t\tfree(k);\n\t\tfree(d);\n\t\treturn; \/* alloc failure *\/\n\t}\n\tk->addr = *addr;\n\tk->addrlen = addrlen;\n\tlock_rw_init(&k->entry.lock);\n\tk->entry.hash = h;\n\tk->entry.key = k;\n\tk->entry.data = d;\n\td->qps[0] = 1;\n\td->timestamp[0] = timenow;\n\td->mesh_wait = mesh_wait;\n\tslabhash_insert(infra->client_ip_rates, h, &k->entry, d, NULL);\n}","target":0,"flaw_line_index":0,"hash":"bbfe8f59-3100-409c-b40e-8df780bb07b6","idx":"1dd51628-6c59-4f9e-a75d-1bf80d636b22"}
{"func_before":"\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, DesiredAccess);     \/* DesiredAccess (4 bytes) *\/\n\tStream_Seek_UINT64(irp->input);                    \/* AllocationSize (8 bytes) *\/\n\tStream_Seek_UINT32(irp->input);                    \/* FileAttributes (4 bytes) *\/\n\tStream_Read_UINT32(irp->input, SharedAccess);      \/* SharedAccess (4 bytes) *\/\n\tStream_Read_UINT32(irp->input, CreateDisposition); \/* CreateDisposition (4 bytes) *\/\n\tStream_Seek_UINT32(irp->input);                    \/* CreateOptions (4 bytes) *\/\n\tStream_Read_UINT32(irp->input, PathLength);        \/* PathLength (4 bytes) *\/\n\n\tif (Stream_GetRemainingLength(irp->input) < PathLength)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Seek(irp->input, PathLength); \/* Path (variable) *\/\n\tassert(PathLength == 0);             \/* MS-RDPESP 2.2.2.2 *\/\n#ifndef _WIN32\n\t\/* Windows 2012 server sends on a first call :\n\t *     DesiredAccess     = 0x00100080: SYNCHRONIZE | FILE_READ_ATTRIBUTES\n\t *     SharedAccess      = 0x00000007: FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ\n\t *     CreateDisposition = 0x00000001: CREATE_NEW\n\t *\n\t * then Windows 2012 sends :\n\t *     DesiredAccess     = 0x00120089: SYNCHRONIZE | READ_CONTROL | FILE_READ_ATTRIBUTES |\n\t * FILE_READ_EA | FILE_READ_DATA SharedAccess      = 0x00000007: FILE_SHARE_DELETE |","target":1,"flaw_line_index":0,"hash":"70154f68-85f5-4b3f-8ccc-4a8e5086bb2c","idx":"a7858264-19a9-4c4a-a4d6-4d8dfdd7ee51"}
{"func_before":"\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Read_UINT32(irp->input, DesiredAccess);     \/* DesiredAccess (4 bytes) *\/\n\tStream_Seek_UINT64(irp->input);                    \/* AllocationSize (8 bytes) *\/\n\tStream_Seek_UINT32(irp->input);                    \/* FileAttributes (4 bytes) *\/\n\tStream_Read_UINT32(irp->input, SharedAccess);      \/* SharedAccess (4 bytes) *\/\n\tStream_Read_UINT32(irp->input, CreateDisposition); \/* CreateDisposition (4 bytes) *\/\n\tStream_Seek_UINT32(irp->input);                    \/* CreateOptions (4 bytes) *\/\n\tStream_Read_UINT32(irp->input, PathLength);        \/* PathLength (4 bytes) *\/\n\n\tif (!Stream_SafeSeek(irp->input, PathLength)) \/* Path (variable) *\/\n\t\treturn ERROR_INVALID_DATA;\n\n\tassert(PathLength == 0);             \/* MS-RDPESP 2.2.2.2 *\/\n#ifndef _WIN32\n\t\/* Windows 2012 server sends on a first call :\n\t *     DesiredAccess     = 0x00100080: SYNCHRONIZE | FILE_READ_ATTRIBUTES\n\t *     SharedAccess      = 0x00000007: FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ\n\t *     CreateDisposition = 0x00000001: CREATE_NEW\n\t *\n\t * then Windows 2012 sends :\n\t *     DesiredAccess     = 0x00120089: SYNCHRONIZE | READ_CONTROL | FILE_READ_ATTRIBUTES |\n\t * FILE_READ_EA | FILE_READ_DATA SharedAccess      = 0x00000007: FILE_SHARE_DELETE |","target":0,"flaw_line_index":0,"hash":"333aff11-c2d5-484f-936b-daf2b526647a","idx":"f33d425e-3354-4f44-8934-86d1de3301b2"}
{"func_before":"int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \"\", name[200] = \"\", path[256];\n  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    size_t oft = strtoul(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    LOG(LL_DEBUG,\n        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");\n      return (int) hm->body.len;\n    }\n  }\n}","target":1,"flaw_line_index":0,"hash":"87f30828-54fd-4e4c-898e-7046a43b750c","idx":"d7a23868-8018-4a42-9f01-7ec1fbea74a8"}
{"func_before":"int mg_http_upload(struct mg_connection *c, struct mg_http_message *hm,\n                   const char *dir) {\n  char offset[40] = \"\", name[200] = \"\", path[256];\n  mg_http_get_var(&hm->query, \"offset\", offset, sizeof(offset));\n  mg_http_get_var(&hm->query, \"name\", name, sizeof(name));\n  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    long oft = strtol(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    remove_double_dots(path);\n    LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");\n      return (int) hm->body.len;\n    }\n  }\n}","target":0,"flaw_line_index":0,"hash":"239e531e-2191-400b-a14b-d90bb29e9f0d","idx":"9b1dfbad-05d0-4be7-bfb0-3b84cea838df"}
{"func_before":"\n\tif (*p == NL)\n\t    next = newline_skip_comments(p);\n\telse if (evalarg->eval_cookie != NULL)\n\t    next = getline_peek_skip_comments(evalarg);\n\telse\n\t    next = peek_next_line_from_context(evalarg->eval_cctx);\n\n\tif (next != NULL)\n\t{\n\t    *getnext = TRUE;\n\t    return skipwhite(next);\n\t}\n    }\n    return p;\n}","target":1,"flaw_line_index":0,"hash":"f2b725c5-32e4-42d4-965f-0252fe5990af","idx":"e0831d0c-2cd4-4ec8-be76-18be850b005b"}
{"func_before":"\n\tif (*p == NL)\n\t    next = newline_skip_comments(p);\n\telse if (evalarg->eval_cookie != NULL)\n\t    next = getline_peek_skip_comments(evalarg);\n\telse\n\t    next = peek_next_line_from_context(evalarg->eval_cctx);\n\n\tif (next != NULL)\n\t{\n\t    *getnext = *p != NL;\n\t    return skipwhite(next);\n\t}\n    }\n    return p;\n}","target":0,"flaw_line_index":0,"hash":"0854ba44-a385-471b-bba8-1fae33f4e581","idx":"677d69ce-17f8-4077-88a7-631aa63db9b3"}
{"func_before":"\n    \/* Initialize port *\/\n    fport->options = options;\n    fport->readpos = fport->buf;\n\n\n    \/* ok run this for all files to be sure all are good for playback. *\/\n    for (index=file_count-1; index>=0; index--) {\n\n\tpjmedia_wave_hdr wavehdr;\n\tpj_ssize_t size_to_read, size_read;\n\n\t\/* we end with the last one so we are good to go if still in function*\/\n\tpj_memcpy(filename, file_list[index].ptr, file_list[index].slen);\n\tfilename[file_list[index].slen] = '\\0';\n\n\t\/* Get the file size. *\/\n\tfport->current_file = index;\n\tfport->fsize_list[index] = pj_file_size(filename);\n\t\n\t\/* Size must be more than WAVE header size *\/\n\t    goto on_error;\n\t}\n\t\n\t\/* Open file. *\/\n\tstatus = pj_file_open( pool, filename, PJ_O_RDONLY, \n\t\t\t       &fport->fd_list[index]);\n\tif (status != PJ_SUCCESS)\n\t    goto on_error;\n\t\n\t\/* Read the file header plus fmt header only. *\/\n\tsize_read = size_to_read = sizeof(wavehdr) - 8;\n\tstatus = pj_file_read( fport->fd_list[index], &wavehdr, &size_read);\n\tif (status != PJ_SUCCESS) {\n\t    goto on_error;\n\t}\n\n\tif (size_read != size_to_read) {\n\t    status = PJMEDIA_ENOTVALIDWAVE;\n\t    goto on_error;\n\t}\n\t\n\t\twavehdr.fmt_hdr.nchan * BYTES_PER_SAMPLE)\n\t{\n\t    status = PJMEDIA_EWAVEUNSUPP;\n\t    goto on_error;\n\t}\n\t\n\t\/* If length of fmt_header is greater than 16, skip the remaining\n\t * fmt header data.\n\t *\/\n\tif (wavehdr.fmt_hdr.len > 16) {\n\t    size_to_read = wavehdr.fmt_hdr.len - 16;\n\t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n\t\t\t\t    PJ_SEEK_CUR);\n\t    if (status != PJ_SUCCESS) {\n\t\tgoto on_error;\n\t    }\n\t}\n\t\n\t\/* Repeat reading the WAVE file until we have 'data' chunk *\/\n\tfor (;;) {\n\t    pjmedia_wave_subchunk subchunk;\n\t    \/* Normalize endianness *\/\n\t    PJMEDIA_WAVE_NORMALIZE_SUBCHUNK(&subchunk);\n\t    \n\t    \/* Break if this is \"data\" chunk *\/\n\t    if (subchunk.id == PJMEDIA_DATA_TAG) {\n\t\twavehdr.data_hdr.data = PJMEDIA_DATA_TAG;\n\t\twavehdr.data_hdr.len = subchunk.len;\n\t\tbreak;\n\t    }\n\t    \n\t    \/* Otherwise skip the chunk contents *\/\n\t    size_to_read = subchunk.len;\n\t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n\t\t\t\t    PJ_SEEK_CUR);\n\t    if (status != PJ_SUCCESS) {\n\t\tgoto on_error;\n\t    }\n\t}\n\t\n\t\/* Current file position now points to start of data *\/\n\tstatus = pj_file_getpos(fport->fd_list[index], &pos);\n\tfport->start_data_list[index] = (unsigned)pos;","target":1,"flaw_line_index":0,"hash":"7c8afeda-836d-4753-bffd-afc53441d039","idx":"a7213ea3-9d6e-4d4a-8b56-6f3db2bb5f04"}
{"func_before":"\n    \/* Initialize port *\/\n    fport->options = options;\n    fport->readpos = fport->buf;\n\n\n    \/* ok run this for all files to be sure all are good for playback. *\/\n    for (index=file_count-1; index>=0; index--) {\n\n\tpjmedia_wave_hdr wavehdr;\n\tpj_ssize_t size_read;\n\tpj_off_t size_to_read;\n\n\t\/* we end with the last one so we are good to go if still in function*\/\n\tpj_memcpy(filename, file_list[index].ptr, file_list[index].slen);\n\tfilename[file_list[index].slen] = '\\0';\n\n\t\/* Get the file size. *\/\n\tfport->current_file = index;\n\tfport->fsize_list[index] = pj_file_size(filename);\n\t\n\t\/* Size must be more than WAVE header size *\/\n\t    goto on_error;\n\t}\n\t\n\t\/* Open file. *\/\n\tstatus = pj_file_open( pool, filename, PJ_O_RDONLY, \n\t\t\t       &fport->fd_list[index]);\n\tif (status != PJ_SUCCESS)\n\t    goto on_error;\n\t\n\t\/* Read the file header plus fmt header only. *\/\n\tsize_to_read = size_read = sizeof(wavehdr) - 8;\t\n\tstatus = pj_file_read( fport->fd_list[index], &wavehdr, &size_read);\n\tif (status != PJ_SUCCESS) {\n\t    goto on_error;\n\t}\n\n\tif (size_read != size_to_read) {\n\t    status = PJMEDIA_ENOTVALIDWAVE;\n\t    goto on_error;\n\t}\n\t\n\t\twavehdr.fmt_hdr.nchan * BYTES_PER_SAMPLE)\n\t{\n\t    status = PJMEDIA_EWAVEUNSUPP;\n\t    goto on_error;\n\t}\n\t\n\t\/* If length of fmt_header is greater than 16, skip the remaining\n\t * fmt header data.\n\t *\/\n\tif (wavehdr.fmt_hdr.len > 16) {\n\t    PJ_CHECK_OVERFLOW_UINT32_TO_LONG(wavehdr.fmt_hdr.len-16,\n\t\t\t       status = PJMEDIA_ENOTVALIDWAVE; goto on_error;);\n\t    size_to_read = (pj_off_t)wavehdr.fmt_hdr.len - 16;\n\t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n\t\t\t\t    PJ_SEEK_CUR);\n\t    if (status != PJ_SUCCESS) {\n\t\tgoto on_error;\n\t    }\n\t}\n\t\n\t\/* Repeat reading the WAVE file until we have 'data' chunk *\/\n\tfor (;;) {\n\t    pjmedia_wave_subchunk subchunk;\n\t    PJMEDIA_WAVE_NORMALIZE_SUBCHUNK(&subchunk);\n\t    \n\t    \/* Break if this is \"data\" chunk *\/\n\t    if (subchunk.id == PJMEDIA_DATA_TAG) {\n\t\twavehdr.data_hdr.data = PJMEDIA_DATA_TAG;\n\t\twavehdr.data_hdr.len = subchunk.len;\n\t\tbreak;\n\t    }\n\t    \n\t    \/* Otherwise skip the chunk contents *\/\n\t    PJ_CHECK_OVERFLOW_UINT32_TO_LONG(subchunk.len, \n\t\t\t       status = PJMEDIA_ENOTVALIDWAVE; goto on_error;);\n\t    size_to_read = subchunk.len;\n\n\t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n\t\t\t\t    PJ_SEEK_CUR);\n\t    if (status != PJ_SUCCESS) {\n\t\tgoto on_error;\n\t    }\n\t}\n\t\n\t\/* Current file position now points to start of data *\/\n\tstatus = pj_file_getpos(fport->fd_list[index], &pos);\n\tfport->start_data_list[index] = (unsigned)pos;","target":0,"flaw_line_index":0,"hash":"ee0b377d-4d0a-4010-832e-3212aa6c027d","idx":"cd4b4bb0-c636-4f96-8d32-95f27c0d9965"}
{"func_before":"inline void AveragePool(const PoolParams& params,\n                        const RuntimeShape& input_shape,\n                        const int8_t* input_data,\n                        const RuntimeShape& output_shape, int8_t* output_data) {\n  TFLITE_DCHECK_LE(params.quantized_activation_min,\n                   params.quantized_activation_max);\n  TFLITE_DCHECK_EQ(input_shape.DimensionsCount(), 4);\n  TFLITE_DCHECK_EQ(output_shape.DimensionsCount(), 4);\n  const int batches = MatchingDim(input_shape, 0, output_shape, 0);\n  const int depth = MatchingDim(input_shape, 3, output_shape, 3);\n  const int input_height = input_shape.Dims(1);\n  const int input_width = input_shape.Dims(2);\n  const int output_height = output_shape.Dims(1);\n  const int output_width = output_shape.Dims(2);\n  const int stride_height = params.stride_height;\n  const int stride_width = params.stride_width;\n  for (int batch = 0; batch < batches; ++batch) {\n    for (int out_y = 0; out_y < output_height; ++out_y) {\n      for (int out_x = 0; out_x < output_width; ++out_x) {\n        for (int channel = 0; channel < depth; ++channel) {\n          const int in_x_origin =\n              (out_x * stride_width) - params.padding_values.width;\n          const int in_y_origin =\n              (out_y * stride_height) - params.padding_values.height;\n          \/\/ Compute the boundaries of the filter region clamped so as to\n          \/\/ ensure that the filter window fits in the input array.\n          const int filter_x_start = std::max(0, -in_x_origin);\n          const int filter_x_end =\n              std::min(params.filter_width, input_width - in_x_origin);\n          const int filter_y_start = std::max(0, -in_y_origin);\n          const int filter_y_end =\n              std::min(params.filter_height, input_height - in_y_origin);\n          int32_t acc = 0;\n          int filter_count = 0;\n          for (int filter_y = filter_y_start; filter_y < filter_y_end;\n               ++filter_y) {\n            for (int filter_x = filter_x_start; filter_x < filter_x_end;\n                 ++filter_x) {\n              const int in_x = in_x_origin + filter_x;\n              const int in_y = in_y_origin + filter_y;\n              acc +=\n                  input_data[Offset(input_shape, batch, in_y, in_x, channel)];\n              filter_count++;\n            }\n          }\n          \/\/ Round to the closest integer value.\n          acc = acc > 0 ? (acc + filter_count \/ 2) \/ filter_count\n                        : (acc - filter_count \/ 2) \/ filter_count;\n          acc = std::max(acc, params.quantized_activation_min);\n          acc = std::min(acc, params.quantized_activation_max);\n          output_data[Offset(output_shape, batch, out_y, out_x, channel)] =\n              static_cast<int8_t>(acc);\n        }\n      }\n    }\n  }\n}","target":1,"flaw_line_index":0,"hash":"9d23fdb4-d660-4392-bb54-819e83b9c4cb","idx":"4a5841f3-af57-4e87-b149-37b081563604"}
{"func_before":"inline bool AveragePool(const PoolParams& params,\n                        const RuntimeShape& input_shape,\n                        const int8_t* input_data,\n                        const RuntimeShape& output_shape, int8_t* output_data) {\n  TFLITE_DCHECK_LE(params.quantized_activation_min,\n                   params.quantized_activation_max);\n  TFLITE_DCHECK_EQ(input_shape.DimensionsCount(), 4);\n  TFLITE_DCHECK_EQ(output_shape.DimensionsCount(), 4);\n  const int batches = MatchingDim(input_shape, 0, output_shape, 0);\n  const int depth = MatchingDim(input_shape, 3, output_shape, 3);\n  const int input_height = input_shape.Dims(1);\n  const int input_width = input_shape.Dims(2);\n  const int output_height = output_shape.Dims(1);\n  const int output_width = output_shape.Dims(2);\n  const int stride_height = params.stride_height;\n  const int stride_width = params.stride_width;\n  for (int batch = 0; batch < batches; ++batch) {\n    for (int out_y = 0; out_y < output_height; ++out_y) {\n      for (int out_x = 0; out_x < output_width; ++out_x) {\n        for (int channel = 0; channel < depth; ++channel) {\n          const int in_x_origin =\n              (out_x * stride_width) - params.padding_values.width;\n          const int in_y_origin =\n              (out_y * stride_height) - params.padding_values.height;\n          \/\/ Compute the boundaries of the filter region clamped so as to\n          \/\/ ensure that the filter window fits in the input array.\n          const int filter_x_start = std::max(0, -in_x_origin);\n          const int filter_x_end =\n              std::min(params.filter_width, input_width - in_x_origin);\n          const int filter_y_start = std::max(0, -in_y_origin);\n          const int filter_y_end =\n              std::min(params.filter_height, input_height - in_y_origin);\n          int32_t acc = 0;\n          int filter_count = 0;\n          for (int filter_y = filter_y_start; filter_y < filter_y_end;\n               ++filter_y) {\n            for (int filter_x = filter_x_start; filter_x < filter_x_end;\n                 ++filter_x) {\n              const int in_x = in_x_origin + filter_x;\n              const int in_y = in_y_origin + filter_y;\n              acc +=\n                  input_data[Offset(input_shape, batch, in_y, in_x, channel)];\n              filter_count++;\n            }\n          }\n          if (filter_count == 0) return false;\n          \/\/ Round to the closest integer value.\n          acc = acc > 0 ? (acc + filter_count \/ 2) \/ filter_count\n                        : (acc - filter_count \/ 2) \/ filter_count;\n          acc = std::max(acc, params.quantized_activation_min);\n          acc = std::min(acc, params.quantized_activation_max);\n          output_data[Offset(output_shape, batch, out_y, out_x, channel)] =\n              static_cast<int8_t>(acc);\n        }\n      }\n    }\n  }\n  return true;\n}","target":0,"flaw_line_index":0,"hash":"54065c6b-efc2-462d-9751-eb23b1aca2af","idx":"ee8f386f-bab5-465d-ab52-0173e8fa2c04"}
{"func_before":"\n  if (!FindMember(o, \"values\", values_iterator)) {\n    (*err) = \"the sparse object ob ths accessor doesn't have values\";\n    return false;\n  }\n\n  const json &indices_obj = GetValue(indices_iterator);\n  const json &values_obj = GetValue(values_iterator);\n\n  int indices_buffer_view = 0, indices_byte_offset = 0, component_type = 0;\n  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj, \"bufferView\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&indices_byte_offset, err, indices_obj, \"byteOffset\",\n                       false);\n  if (!ParseIntegerProperty(&component_type, err, indices_obj, \"componentType\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n\n  int values_buffer_view = 0, values_byte_offset = 0;\n  if (!ParseIntegerProperty(&values_buffer_view, err, values_obj, \"bufferView\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&values_byte_offset, err, values_obj, \"byteOffset\",\n                       false);\n\n  accessor->sparse.count = count;\n  accessor->sparse.indices.bufferView = indices_buffer_view;\n  accessor->sparse.indices.byteOffset = indices_byte_offset;\n  accessor->sparse.indices.componentType = component_type;\n  accessor->sparse.values.bufferView = values_buffer_view;","target":1,"flaw_line_index":0,"hash":"4aa0364a-adb6-428f-aed1-b4e20fef40e2","idx":"11c8e449-2948-47fe-84d7-f0f47a53a000"}
{"func_before":"\n  if (!FindMember(o, \"values\", values_iterator)) {\n    (*err) = \"the sparse object ob ths accessor doesn't have values\";\n    return false;\n  }\n\n  const json &indices_obj = GetValue(indices_iterator);\n  const json &values_obj = GetValue(values_iterator);\n\n  int indices_buffer_view = 0, indices_byte_offset = 0, component_type = 0;\n  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj,\n                            \"bufferView\", true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&indices_byte_offset, err, indices_obj, \"byteOffset\",\n                       false);\n  if (!ParseIntegerProperty(&component_type, err, indices_obj, \"componentType\",\n                            true, \"SparseAccessor\")) {\n    return false;\n  }\n\n  int values_buffer_view = 0, values_byte_offset = 0;\n  if (!ParseIntegerProperty(&values_buffer_view, err, values_obj, \"bufferView\",\n                            true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&values_byte_offset, err, values_obj, \"byteOffset\",\n                       false);\n\n  accessor->sparse.count = count;\n  accessor->sparse.indices.bufferView = indices_buffer_view;\n  accessor->sparse.indices.byteOffset = indices_byte_offset;\n  accessor->sparse.indices.componentType = component_type;\n  accessor->sparse.values.bufferView = values_buffer_view;","target":0,"flaw_line_index":0,"hash":"1a68e08e-2749-4016-9d68-8be10efc83a3","idx":"3d5db569-7e07-4abe-92a4-62900a9cd86e"}
{"func_before":"static void usage(int status)\n{\n\tFILE *dest = (status == 0) ? stdout : stderr;\n\n\tif(status == 0){\n\t\tfprintf(dest,\n\t\t\t\"%s(1)\\t\\t\\tcopyright <Pierre-François Monville>\\t\\t\\t%s(1)\\n\\nNAME\\n\\t%s -- crypt or decrypt any data\\n\\nSYNOPSIS\\n\\t%s [-h | --help] FILE [-s | --standard | KEYFILE]\\n\\nDESCRIPTION\\n\\t(FR) permet de chiffrer et de déchiffrer toutes les données entrées en paramètre le mot de passe demandé au début est hashé puis sert de graine pour le PRNG le PRNG permet de fournir une clé unique égale à la longueur du fichier à coder. La clé unique subit un xor avec le mot de passe (le mot de passe est répété autant de fois que nécéssaire). Le fichier subit un xor avec cette clé Puis un brouilleur est utilisé, il mélange la table des caractères (ascii) en utilisant le PRNG ou en utilisant le keyFile fourni.\\n\\t(EN) Can crypt and decrypt any data given in argument. The password asked is hashed to be used as a seed for the PRNG. The PRNG gives a unique key which has the same length as the source file. The key is xored with the password (the password is repeated as long as necessary). The file is then xored with this new key, then a scrambler is used. It scrambles the ascii table using the PRNG or the keyFile given\\n\\nOPTIONS\\n\\tthe options are as follows:\\n\\n\\t-h | --help\\tfurther help.\\n\\n\\t-s | --standard\\tput the scrambler on off.\\n\\n\\t-i | --inverted\\tinverts the coding\/decoding process, first it xors then it scrambles.\\n\\nEXIT STATUS\\n\\tthe %s program exits 0 on success, and anything else if an error occurs.\\n\\nEXAMPLES\\n\\tthe command:\\t%s file1\\n\\n\\tlets you choose between crypting or decrypting then it will prompt for a password that crypt\/decrypt file1 as xfile1 in the same folder, file1 is not modified.\\n\\n\\tthe command:\\t%s file2 keyfile1\\n\\n\\tlets you choose between crypting or decrypting, will prompt for the password that crypt\/decrypt file2, uses keyfile1 to generate the scrambler then crypt\/decrypt file2 as file2x in the same folder, file2 is not modified.\\n\\n\\tthe command:\\t%s file3 -s\\n\\n\\tlets you choose between crypting or decrypting, will prompt for a password that crypt\/decrypt the file without using the scrambler, resulting in using the unique key only.\\n\", progName, progName, progName, progName, progName, progName, progName, progName);\n\t} else{\n\t\tfprintf(dest,\n\t\t\t\"Usage : %s [-h | --help] FILE [-s | --standard | -i | --inverted] [KEYFILE]\\nOptions :\\n  -h --help :\\t\\tfurther help\\n  -s --standard :\\tput the scrambler off\\n  -i --inverted :\\tinverts the coding\/decoding process\\n  KEYFILE :\\t\\tpath to a keyfile that generates the scrambler instead of the password\\n\", progName);\n\t}\n\texit(status);\n}","target":1,"flaw_line_index":0,"hash":"83016efb-b48a-4352-b924-38048ee397a0","idx":"0691f71e-ce7e-4898-b4ab-078a5465f321"}
{"func_before":"static void usage(int status)\n{\n\tFILE *dest = (status == 0) ? stdout : stderr;\n\n\tif(status == 0){\n\t\tfprintf(dest,\n\t\t\t\"%s(1)\\t\\t\\tcopyright <Pierre-François Monville>\\t\\t\\t%s(1)\\n\\nNAME\\n\\t%s -- crypt or decrypt any data\\n\\nSYNOPSIS\\n\\t%s [-h | --help] FILE [-s | --standard | KEYFILE]\\n\\nDESCRIPTION\\n\\t(FR) permet de chiffrer et de déchiffrer toutes les données entrées en paramètre le mot de passe demandé au début est hashé puis sert de graine pour le PRNG le PRNG permet de fournir une clé unique égale à la longueur du fichier à coder. La clé unique subit un xor avec le mot de passe (le mot de passe est répété autant de fois que nécéssaire). Le fichier subit un xor avec cette clé Puis un brouilleur est utilisé, il mélange la table des caractères (ascii) en utilisant le PRNG ou en utilisant le keyFile fourni.\\n\\t(EN) Can crypt and decrypt any data given in argument. The password asked is hashed to be used as a seed for the PRNG. The PRNG gives a unique key which has the same length as the source file. The key is xored with the password (the password is repeated as long as necessary). The file is then xored with this new key, then a scrambler is used. It scrambles the ascii table using the PRNG or the keyFile given\\n\\nOPTIONS\\n\\tthe options are as follows:\\n\\n\\t-h | --help\\tfurther help.\\n\\n\\t-s | --standard\\tput the scrambler on off.\\n\\n\\t-i | --inverted\\tinverts the coding\/decoding process, first it xors then it scrambles.\\n\\n\\tKEYFILE    \\tthe path to a file which will be used to scramble the substitution's tables and choose in which order they will be used instead of the PRNG only (starting at 2.5 ko for the keyfile is great, however not interesting to be too heavy) \\n\\nEXIT STATUS\\n\\tthe %s program exits 0 on success, and anything else if an error occurs.\\n\\nEXAMPLES\\n\\tthe command:\\t%s file1\\n\\n\\tlets you choose between crypting or decrypting then it will prompt for a password that crypt\/decrypt file1 as xfile1 in the same folder, file1 is not modified.\\n\\n\\tthe command:\\t%s file2 keyfile1\\n\\n\\tlets you choose between crypting or decrypting, will prompt for the password that crypt\/decrypt file2, uses keyfile1 to generate the scrambler then crypt\/decrypt file2 as file2x in the same folder, file2 is not modified.\\n\\n\\tthe command:\\t%s file3 -s\\n\\n\\tlets you choose between crypting or decrypting, will prompt for a password that crypt\/decrypt the file without using the scrambler, resulting in using the unique key only.\\n\", progName, progName, progName, progName, progName, progName, progName, progName);\n\t} else{\n\t\tfprintf(dest,\n\t\t\t\"Version : 2.3\\nUsage : %s [-h | --help] FILE [-s | --standard | -i | --inverted] [KEYFILE]\\nOptions :\\n  -h --help :\\t\\tfurther help\\n  -s --standard :\\tput the scrambler off\\n  -i --inverted :\\tinverts the coding\/decoding process\\n  KEYFILE :\\t\\tpath to a keyfile that scrambles the substitution's tables and choose they order instead of the PRNG only\\n\", progName);\n\t}\n\texit(status);\n}","target":0,"flaw_line_index":0,"hash":"20741222-0632-4f6b-b6a7-13ee0575735f","idx":"94df837d-a5be-41a8-8017-c7e31939dad9"}
{"func_before":"         \/\/Compute CRC over the current MAC address\n         crc = enc28j60CalcCrc(&entry->addr, sizeof(MacAddr));\n         \/\/Calculate the corresponding index in the table\n         k = (crc >> 23) & 0x3F;\n         \/\/Update hash table contents\n         hashTable[k \/ 8] |= (1 << (k % 8));\n      }\n   }\n\n   \/\/Write the hash table to the ENC28J60 controller\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT0, hashTable[0]);\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT1, hashTable[1]);\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT2, hashTable[2]);\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT3, hashTable[3]);\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT4, hashTable[4]);\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT5, hashTable[5]);\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT6, hashTable[6]);\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT7, hashTable[7]);\n\n   \/\/Debug message\n   TRACE_DEBUG(\"  EHT0 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT0));\n   TRACE_DEBUG(\"  EHT1 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT1));\n   TRACE_DEBUG(\"  EHT2 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT2));\n   TRACE_DEBUG(\"  EHT3 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT3));\n   TRACE_DEBUG(\"  EHT0 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT4));\n   TRACE_DEBUG(\"  EHT1 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT5));\n   TRACE_DEBUG(\"  EHT2 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT6));\n   TRACE_DEBUG(\"  EHT3 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT7));\n\n   \/\/Successful processing\n   return NO_ERROR;\n}","target":1,"flaw_line_index":0,"hash":"e2f57368-2f5d-4517-9462-609a6f79362d","idx":"8921e2c2-d74f-4de3-9a6e-51b0852c3415"}
{"func_before":"         \/\/Compute CRC over the current MAC address\n         crc = enc28j60CalcCrc(&entry->addr, sizeof(MacAddr));\n         \/\/Calculate the corresponding index in the table\n         k = (crc >> 23) & 0x3F;\n         \/\/Update hash table contents\n         hashTable[k \/ 8] |= (1 << (k % 8));\n      }\n   }\n\n   \/\/Write the hash table to the ENC28J60 controller\n   enc28j60WriteReg(interface, ENC28J60_EHT0, hashTable[0]);\n   enc28j60WriteReg(interface, ENC28J60_EHT1, hashTable[1]);\n   enc28j60WriteReg(interface, ENC28J60_EHT2, hashTable[2]);\n   enc28j60WriteReg(interface, ENC28J60_EHT3, hashTable[3]);\n   enc28j60WriteReg(interface, ENC28J60_EHT4, hashTable[4]);\n   enc28j60WriteReg(interface, ENC28J60_EHT5, hashTable[5]);\n   enc28j60WriteReg(interface, ENC28J60_EHT6, hashTable[6]);\n   enc28j60WriteReg(interface, ENC28J60_EHT7, hashTable[7]);\n\n   \/\/Debug message\n   TRACE_DEBUG(\"  EHT0 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT0));\n   TRACE_DEBUG(\"  EHT1 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT1));\n   TRACE_DEBUG(\"  EHT2 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT2));\n   TRACE_DEBUG(\"  EHT3 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT3));\n   TRACE_DEBUG(\"  EHT0 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT4));\n   TRACE_DEBUG(\"  EHT1 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT5));\n   TRACE_DEBUG(\"  EHT2 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT6));\n   TRACE_DEBUG(\"  EHT3 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT7));\n\n   \/\/Successful processing\n   return NO_ERROR;\n}","target":0,"flaw_line_index":0,"hash":"f6ddaec5-3c6b-45c5-9914-25fd4c061485","idx":"10606003-d524-4c88-a24f-436a38e49a8a"}
{"func_before":"  FILE* fh;\n  if (fd==1) fh=stdout;\n  else if (fd==2) fh=stderr;\n  else { return; }\n\n#define LOG0(t) log2fh(fh, t)\n#define LOG1(t,d) log2fh(fh, t,d)\n#define LOG2(t,d1,d2) log2fh(fh, t,d1,d2)\n#define LOG3(t,d1,d2,d3) log2fh(fh, t,d1,d2,d3)\n#define LOG4(t,d1,d2,d3,d4) log2fh(fh, t,d1,d2,d3,d4)\n\n  const pic_parameter_set* pps = ctx->get_pps(slice_pic_parameter_set_id);\n  assert(pps->pps_read); \/\/ TODO: error handling\n\n  const seq_parameter_set* sps = ctx->get_sps((int)pps->seq_parameter_set_id);\n  assert(sps->sps_read); \/\/ TODO: error handling\n\n\n  LOG0(\"----------------- SLICE -----------------\\n\");\n  LOG1(\"first_slice_segment_in_pic_flag      : %d\\n\", first_slice_segment_in_pic_flag);\n  if (ctx->get_nal_unit_type() >= NAL_UNIT_BLA_W_LP &&\n      ctx->get_nal_unit_type() <= NAL_UNIT_RESERVED_IRAP_VCL23) {\n    LOG1(\"no_output_of_prior_pics_flag         : %d\\n\", no_output_of_prior_pics_flag);\n  }\n\n  LOG1(\"slice_pic_parameter_set_id           : %d\\n\", slice_pic_parameter_set_id);\n\n  if (!first_slice_segment_in_pic_flag) {\n    \/\/if (pps->dependent_slice_segments_enabled_flag) {","target":1,"flaw_line_index":0,"hash":"597b8919-d776-45d3-9d29-e5e33b197749","idx":"ebe819fb-0861-451d-accf-94b35c9e1db1"}
{"func_before":"  if (fd==1) fh=stdout;\n  else if (fd==2) fh=stderr;\n  else { return; }\n\n#define LOG0(t) log2fh(fh, t)\n#define LOG1(t,d) log2fh(fh, t,d)\n#define LOG2(t,d1,d2) log2fh(fh, t,d1,d2)\n#define LOG3(t,d1,d2,d3) log2fh(fh, t,d1,d2,d3)\n#define LOG4(t,d1,d2,d3,d4) log2fh(fh, t,d1,d2,d3,d4)\n\n  LOG0(\"----------------- SLICE -----------------\\n\");\n\n  const pic_parameter_set* pps = ctx->get_pps(slice_pic_parameter_set_id);\n  if (!pps) {\n    LOG0(\"invalid PPS referenced\\n\");\n    return;\n  }\n  assert(pps->pps_read); \/\/ TODO: error handling\n\n  const seq_parameter_set* sps = ctx->get_sps((int)pps->seq_parameter_set_id);\n  if (!sps) {\n    LOG0(\"invalid SPS referenced\\n\");\n    return;\n  }\n  assert(sps->sps_read); \/\/ TODO: error handling\n\n\n  LOG1(\"first_slice_segment_in_pic_flag      : %d\\n\", first_slice_segment_in_pic_flag);\n  if (ctx->get_nal_unit_type() >= NAL_UNIT_BLA_W_LP &&\n      ctx->get_nal_unit_type() <= NAL_UNIT_RESERVED_IRAP_VCL23) {\n    LOG1(\"no_output_of_prior_pics_flag         : %d\\n\", no_output_of_prior_pics_flag);\n  }\n\n  LOG1(\"slice_pic_parameter_set_id           : %d\\n\", slice_pic_parameter_set_id);\n\n  if (!first_slice_segment_in_pic_flag) {\n    \/\/if (pps->dependent_slice_segments_enabled_flag) {","target":0,"flaw_line_index":0,"hash":"ba6cb427-a25d-4c78-b2e4-e5ccfbf3d1c9","idx":"5654c36f-2ffc-4601-811d-f39e72e7624a"}
{"func_before":"static int rds_loop_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\t\t unsigned int hdr_off, unsigned int sg,\n\t\t\t unsigned int off)\n{\n\t\/* Do not send cong updates to loopback *\/\n\tif (rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\treturn sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;\n\t}\n\n\tBUG_ON(hdr_off || sg || off);\n\n\trds_inc_init(&rm->m_inc, conn, conn->c_laddr);\n\t\/* For the embedded inc. Matching put is in loop_inc_free() *\/\n\trds_message_addref(rm);\n\n\trds_recv_incoming(conn, conn->c_laddr, conn->c_faddr, &rm->m_inc,\n\t\t\t  GFP_KERNEL, KM_USER0);\n\n\trds_send_drop_acked(conn, be64_to_cpu(rm->m_inc.i_hdr.h_sequence),\n\t\t\t    NULL);\n\n\trds_inc_put(&rm->m_inc);\n\n\treturn sizeof(struct rds_header) + be32_to_cpu(rm->m_inc.i_hdr.h_len);\n}","target":1,"flaw_line_index":0,"hash":"380d1f99-b45b-4184-88da-7c8562514c1e","idx":"c3d789c5-480e-4ad6-a0c5-814d6164d7b7"}
{"func_before":"static int rds_loop_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\t\t unsigned int hdr_off, unsigned int sg,\n\t\t\t unsigned int off)\n{\n\tstruct scatterlist *sgp = &rm->data.op_sg[sg];\n\tint ret = sizeof(struct rds_header) +\n\t\t\tbe32_to_cpu(rm->m_inc.i_hdr.h_len);\n\n\t\/* Do not send cong updates to loopback *\/\n\tif (rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\tret = min_t(int, ret, sgp->length - conn->c_xmit_data_off);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(hdr_off || sg || off);\n\n\trds_inc_init(&rm->m_inc, conn, conn->c_laddr);\n\t\/* For the embedded inc. Matching put is in loop_inc_free() *\/\n\trds_message_addref(rm);\n\n\trds_recv_incoming(conn, conn->c_laddr, conn->c_faddr, &rm->m_inc,\n\t\t\t  GFP_KERNEL, KM_USER0);\n\n\trds_send_drop_acked(conn, be64_to_cpu(rm->m_inc.i_hdr.h_sequence),\n\t\t\t    NULL);\n\n\trds_inc_put(&rm->m_inc);\nout:\n\treturn ret;\n}","target":0,"flaw_line_index":0,"hash":"86850a51-fe08-440a-a524-03cae47d75da","idx":"67bdec46-076f-45f2-a46e-b1052600e087"}
{"func_before":"    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({nrows + 1}),\n                                            &rt_nested_splits_out));\n    auto rt_nested_splits = rt_nested_splits_out->flat<SPLITS_TYPE>();\n    rt_nested_splits(0) = 0;\n    for (int row = 0; row < nrows; ++row) {\n      T start = broadcast_starts ? starts(0) : starts(row);\n      T limit = broadcast_limits ? limits(0) : limits(row);\n      T delta = broadcast_deltas ? deltas(0) : deltas(row);\n      OP_REQUIRES(context, delta != 0, InvalidArgument(\"Requires delta != 0\"));\n      rt_nested_splits(row + 1) =\n          rt_nested_splits(row) + RangeSize(start, limit, delta);\n    }\n    SPLITS_TYPE nvals = rt_nested_splits(nrows);\n\n    \/\/ Construct the rt_dense_values tensor.\n    Tensor* rt_dense_values_out = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, TensorShape({nvals}),\n                                                     &rt_dense_values_out));\n    auto rt_dense_values = rt_dense_values_out->flat<T>();\n    int value_index = 0;\n    for (int row = 0; row < nrows; ++row) {","target":1,"flaw_line_index":0,"hash":"c5eb8e6c-9a74-4f44-9b4e-18fe45a1b9f7","idx":"8fcf8712-0192-415b-9447-a5c3b2271ec4"}
{"func_before":"    OP_REQUIRES_OK(context,\n                   context->allocate_output(0, TensorShape({nrows + 1}),\n                                            &rt_nested_splits_out));\n    auto rt_nested_splits = rt_nested_splits_out->flat<SPLITS_TYPE>();\n    rt_nested_splits(0) = 0;\n    for (int row = 0; row < nrows; ++row) {\n      T start = broadcast_starts ? starts(0) : starts(row);\n      T limit = broadcast_limits ? limits(0) : limits(row);\n      T delta = broadcast_deltas ? deltas(0) : deltas(row);\n      OP_REQUIRES(context, delta != 0, InvalidArgument(\"Requires delta != 0\"));\n      int64_t size;  \/\/ The number of elements in the specified range.\n      if (((delta > 0) && (limit < start)) ||\n          ((delta < 0) && (limit > start))) {\n        size = 0;\n      } else if (std::is_integral<T>::value) {\n        \/\/ The following is copied from tensorflow::RangeOp::Compute().\n        size = Eigen::divup(Eigen::numext::abs(limit - start),\n                            Eigen::numext::abs(delta));\n      } else {\n        \/\/ The following is copied from tensorflow::RangeOp::Compute().\n        auto size_auto =\n            Eigen::numext::ceil(Eigen::numext::abs((limit - start) \/ delta));\n        OP_REQUIRES(\n            context, size_auto <= std::numeric_limits<int64_t>::max(),\n            errors::InvalidArgument(\"Requires ((limit - start) \/ delta) <= \",\n                                    std::numeric_limits<int64_t>::max()));\n        size = static_cast<int64_t>(size_auto);\n      }\n      rt_nested_splits(row + 1) = rt_nested_splits(row) + size;\n    }\n    SPLITS_TYPE nvals = rt_nested_splits(nrows);\n\n    \/\/ Construct the rt_dense_values tensor.\n    Tensor* rt_dense_values_out = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(1, TensorShape({nvals}),\n                                                     &rt_dense_values_out));\n    auto rt_dense_values = rt_dense_values_out->flat<T>();\n    int value_index = 0;\n    for (int row = 0; row < nrows; ++row) {","target":0,"flaw_line_index":0,"hash":"ee166dca-b12d-4de6-b72f-b92652667766","idx":"87b1cc96-7661-4023-bd82-cc30c2c074a7"}
{"func_before":"\t\t\ticonInfo->cbColorTable = 0;\n\t\t\tbreak;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, iconInfo->cbBitsMask);  \/* cbBitsMask (2 bytes) *\/\n\tStream_Read_UINT16(s, iconInfo->cbBitsColor); \/* cbBitsColor (2 bytes) *\/\n\n\tif (Stream_GetRemainingLength(s) < iconInfo->cbBitsMask + iconInfo->cbBitsColor)\n\t\treturn FALSE;\n\n\t\/* bitsMask *\/\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\tif (!newBitMask)\n\t{\n\t\tfree(iconInfo->bitsMask);\n\t\ticonInfo->bitsMask = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsMask = newBitMask;\n\tStream_Read(s, iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\t\/* colorTable *\/\n\tif (iconInfo->colorTable == NULL)\n\t{\n\t\tif (iconInfo->cbColorTable)\n\t\t{\n\t\t\ticonInfo->colorTable = (BYTE*)malloc(iconInfo->cbColorTable);\n\n\t\t\tif (!iconInfo->colorTable)\n\t\t}\n\n\t\ticonInfo->colorTable = new_tab;\n\t}\n\telse\n\t{\n\t\tfree(iconInfo->colorTable);\n\t\ticonInfo->colorTable = NULL;\n\t}\n\n\tif (iconInfo->colorTable)\n\t\tStream_Read(s, iconInfo->colorTable, iconInfo->cbColorTable);\n\n\t\/* bitsColor *\/\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsColor, iconInfo->cbBitsColor);\n\n\tif (!newBitMask)\n\t{\n\t\tfree(iconInfo->bitsColor);\n\t\ticonInfo->bitsColor = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsColor = newBitMask;\n\tStream_Read(s, iconInfo->bitsColor, iconInfo->cbBitsColor);\n\treturn TRUE;\n}","target":1,"flaw_line_index":0,"hash":"c5d32492-d14a-4a6f-9782-b762103f1151","idx":"e887b289-7655-4a93-929e-6e8476700881"}
{"func_before":"\t\tdefault:\n\t\t\ticonInfo->cbColorTable = 0;\n\t\t\tbreak;\n\t}\n\n\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, iconInfo->cbBitsMask);  \/* cbBitsMask (2 bytes) *\/\n\tStream_Read_UINT16(s, iconInfo->cbBitsColor); \/* cbBitsColor (2 bytes) *\/\n\n\t\/* bitsMask *\/\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\tif (!newBitMask)\n\t{\n\t\tfree(iconInfo->bitsMask);\n\t\ticonInfo->bitsMask = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsMask = newBitMask;\n\tif (Stream_GetRemainingLength(s) < iconInfo->cbBitsMask)\n\t\treturn FALSE;\n\tStream_Read(s, iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\t\/* colorTable *\/\n\tif (iconInfo->colorTable == NULL)\n\t{\n\t\tif (iconInfo->cbColorTable)\n\t\t{\n\t\t\ticonInfo->colorTable = (BYTE*)malloc(iconInfo->cbColorTable);\n\n\t\t\tif (!iconInfo->colorTable)\n\n\t\ticonInfo->colorTable = new_tab;\n\t}\n\telse\n\t{\n\t\tfree(iconInfo->colorTable);\n\t\ticonInfo->colorTable = NULL;\n\t}\n\n\tif (iconInfo->colorTable)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < iconInfo->cbColorTable)\n\t\t\treturn FALSE;\n\t\tStream_Read(s, iconInfo->colorTable, iconInfo->cbColorTable);\n\t}\n\n\t\/* bitsColor *\/\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsColor, iconInfo->cbBitsColor);\n\n\tif (!newBitMask)\n\t{\n\t\tfree(iconInfo->bitsColor);\n\t\ticonInfo->bitsColor = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsColor = newBitMask;\n\tif (Stream_GetRemainingLength(s) < iconInfo->cbBitsColor)\n\t\treturn FALSE;\n\tStream_Read(s, iconInfo->bitsColor, iconInfo->cbBitsColor);\n\treturn TRUE;\n}","target":0,"flaw_line_index":0,"hash":"87428229-e533-4ee1-b3ac-edf0fc50746d","idx":"e201047b-e187-4f1d-8040-3c50ab8fec92"}
{"func_before":"static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n\tdec->tilexoff = siz->tilexoff;\n\tdec->tileyoff = siz->tileyoff;\n\tdec->numcomps = siz->numcomps;\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tdec->numtiles = dec->numhtiles * dec->numvtiles;\n\tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n\t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n\tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno \/ dec->numhtiles;","target":1,"flaw_line_index":0,"hash":"3df43e20-a2b4-49d9-80c7-10e840a6efc1","idx":"3e097f7f-2c64-4f94-a70c-d634bbfd4804"}
{"func_before":"static int jpc_dec_process_siz(jpc_dec_t *dec, jpc_ms_t *ms)\n{\n\tjpc_siz_t *siz = &ms->parms.siz;\n\tint compno;\n\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\tsize_t size;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\tdec->tilewidth = siz->tilewidth;\n\tdec->tileheight = siz->tileheight;\n\tdec->tilexoff = siz->tilexoff;\n\tdec->tileyoff = siz->tileyoff;\n\tdec->numcomps = siz->numcomps;\n\t\tcmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -\n\t\t  JPC_CEILDIV(dec->ystart, cmpt->vstep);\n\t\tcmpt->hsubstep = 0;\n\t\tcmpt->vsubstep = 0;\n\t}\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tif (!jas_safe_size_mul(dec->numhtiles, dec->numvtiles, &size)) {\n\t\treturn -1;\n\t}\n\tdec->numtiles = size;\n\tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n\t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n\tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}\n\n\tfor (tileno = 0, tile = dec->tiles; tileno < dec->numtiles; ++tileno,\n\t  ++tile) {\n\t\thtileno = tileno % dec->numhtiles;\n\t\tvtileno = tileno \/ dec->numhtiles;","target":0,"flaw_line_index":0,"hash":"9b66d46d-5a0c-4a8d-813a-ced220f922a1","idx":"c7b8865e-9fb2-4a37-9485-97e1b8336a4f"}
{"func_before":"static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_8read_strings(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self, Py_ssize_t __pyx_v_n_items, PyObject *__pyx_v_encoding) {\n  PyObject *__pyx_v_items = NULL;\n  Py_ssize_t __pyx_v_i;\n  char *__pyx_v_buffer_ptr;\n  Py_ssize_t __pyx_v_right;\n  Py_ssize_t __pyx_v_size;\n  Py_ssize_t __pyx_v_shift;\n  Py_ssize_t __pyx_v_bytes_read;\n  unsigned char __pyx_v_b;\n  char *__pyx_v_c_string;\n  Py_ssize_t __pyx_v_c_string_size;\n  char *__pyx_v_c_encoding;\n  PyObject *__pyx_v_rv = 0;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  int __pyx_t_2;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  char *__pyx_t_5;\n  Py_ssize_t __pyx_t_6;\n  Py_ssize_t __pyx_t_7;\n  Py_ssize_t __pyx_t_8;\n  Py_ssize_t __pyx_t_9;\n  Py_ssize_t __pyx_t_10;\n  Py_ssize_t __pyx_t_11;\n  PyObject *__pyx_t_12 = NULL;\n  PyObject *__pyx_t_13 = NULL;\n  PyObject *__pyx_t_14 = NULL;\n  int __pyx_t_15;\n  PyObject *__pyx_t_16 = NULL;\n  __Pyx_RefNannySetupContext(\"read_strings\", 0);\n  __Pyx_INCREF(__pyx_v_encoding);\n\n  \/* \"clickhouse_driver\/bufferedreader.pyx\":67\n *         We inline strings reading logic here to avoid this overhead.\n *         \"\"\"\n *         items = PyTuple_New(n_items)             # <<<<<<<<<<<<<<\n * \n *         cdef Py_ssize_t i\n *\/\n  __pyx_t_1 = PyTuple_New(__pyx_v_n_items); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 67, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_items = ((PyObject*)__pyx_t_1);\n  __pyx_t_1 = 0;\n\n  \/* \"clickhouse_driver\/bufferedreader.pyx\":71\n *         cdef Py_ssize_t i\n *         # Buffer vars\n *         cdef char* buffer_ptr = PyByteArray_AsString(self.buffer)             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t right\n *         # String length vars\n *\/\n  __pyx_t_1 = __pyx_v_self->buffer;\n  __Pyx_INCREF(__pyx_t_1);\n  __pyx_v_buffer_ptr = PyByteArray_AsString(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  \/* \"clickhouse_driver\/bufferedreader.pyx\":78\n * \n *         # String for decode vars.\n *         cdef char *c_string = NULL             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t c_string_size = 1024\n *         cdef char *c_encoding = NULL\n *\/\n  __pyx_v_c_string = NULL;\n\n  \/* \"clickhouse_driver\/bufferedreader.pyx\":79\n *         # String for decode vars.\n *         cdef char *c_string = NULL\n *         cdef Py_ssize_t c_string_size = 1024             # <<<<<<<<<<<<<<\n *         cdef char *c_encoding = NULL\n *         if encoding:\n *\/\n  __pyx_v_c_string_size = 0x400;\n\n  \/* \"clickhouse_driver\/bufferedreader.pyx\":80\n *         cdef char *c_string = NULL\n *         cdef Py_ssize_t c_string_size = 1024\n *         cdef char *c_encoding = NULL             # <<<<<<<<<<<<<<\n *         if encoding:\n *             encoding = encoding.encode('utf-8')\n *\/\n  __pyx_v_c_encoding = NULL;\n\n  \/* \"clickhouse_driver\/bufferedreader.pyx\":81\n *         cdef Py_ssize_t c_string_size = 1024\n *         cdef char *c_encoding = NULL\n *         if encoding:             # <<<<<<<<<<<<<<\n *             encoding = encoding.encode('utf-8')\n *             c_encoding = encoding\n *\/\n  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_encoding); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 81, __pyx_L1_error)\n  if (__pyx_t_2) {\n\n    \/* \"clickhouse_driver\/bufferedreader.pyx\":82\n *         cdef char *c_encoding = NULL\n    __pyx_t_4 = NULL;\n    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {\n      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);\n      if (likely(__pyx_t_4)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);\n        __Pyx_INCREF(__pyx_t_4);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_3, function);\n      }\n    }\n    __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_kp_u_utf_8) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_u_utf_8);\n    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 82, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __Pyx_DECREF_SET(__pyx_v_encoding, __pyx_t_1);\n    __pyx_t_1 = 0;\n\n    \/* \"clickhouse_driver\/bufferedreader.pyx\":83\n *         if encoding:\n *             encoding = encoding.encode('utf-8')\n *             c_encoding = encoding             # <<<<<<<<<<<<<<\n * \n *         cdef object rv = object()\n *\/\n    __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_encoding); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 83, __pyx_L1_error)\n    __pyx_v_c_encoding = __pyx_t_5;\n\n    \/* \"clickhouse_driver\/bufferedreader.pyx\":81\n *         cdef Py_ssize_t c_string_size = 1024\n *         cdef char *c_encoding = NULL\n *         if encoding:             # <<<<<<<<<<<<<<\n *             encoding = encoding.encode('utf-8')\n *             c_encoding = encoding\n *\/\n  }\n\n  \/* \"clickhouse_driver\/bufferedreader.pyx\":85\n *             c_encoding = encoding\n * \n * \n *\/\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(__pyx_v_items);\n  __pyx_r = __pyx_v_items;\n  goto __pyx_L0;\n\n  \/* \"clickhouse_driver\/bufferedreader.pyx\":62\n *         return rv\n * \n *     def read_strings(self, Py_ssize_t n_items, encoding=None):             # <<<<<<<<<<<<<<\n *         \"\"\"\n *         Python has great overhead between function calls.\n *\/\n\n  \/* function exit code *\/\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_16);","target":1,"flaw_line_index":0,"hash":"6e92ad2b-c0d9-4a32-ba8d-75f94ce20199","idx":"d26225f3-7ed7-4af1-968b-65b0668ee020"}
{"func_before":"static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_8read_strings(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self, unsigned PY_LONG_LONG __pyx_v_n_items, PyObject *__pyx_v_encoding) {\n  PyObject *__pyx_v_items = NULL;\n  unsigned PY_LONG_LONG __pyx_v_i;\n  char *__pyx_v_buffer_ptr;\n  unsigned PY_LONG_LONG __pyx_v_right;\n  unsigned PY_LONG_LONG __pyx_v_size;\n  unsigned PY_LONG_LONG __pyx_v_shift;\n  unsigned PY_LONG_LONG __pyx_v_bytes_read;\n  unsigned PY_LONG_LONG __pyx_v_b;\n  char *__pyx_v_c_string;\n  unsigned PY_LONG_LONG __pyx_v_c_string_size;\n  char *__pyx_v_c_encoding;\n  PyObject *__pyx_v_rv = 0;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  int __pyx_t_2;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  char *__pyx_t_5;\n  unsigned PY_LONG_LONG __pyx_t_6;\n  unsigned PY_LONG_LONG __pyx_t_7;\n  unsigned PY_LONG_LONG __pyx_t_8;\n  unsigned PY_LONG_LONG __pyx_t_9;\n  unsigned PY_LONG_LONG __pyx_t_10;\n  unsigned PY_LONG_LONG __pyx_t_11;\n  PyObject *__pyx_t_12 = NULL;\n  PyObject *__pyx_t_13 = NULL;\n  PyObject *__pyx_t_14 = NULL;\n  int __pyx_t_15;\n  PyObject *__pyx_t_16 = NULL;\n  int __pyx_lineno = 0;\n  const char *__pyx_filename = NULL;\n  int __pyx_clineno = 0;\n  __Pyx_RefNannySetupContext(\"read_strings\", 0);\n  __Pyx_INCREF(__pyx_v_encoding);\n\n  \/* \"clickhouse_driver\/bufferedreader.pyx\":67\n *         We inline strings reading logic here to avoid this overhead.\n *         \"\"\"\n *         items = PyTuple_New(n_items)             # <<<<<<<<<<<<<<\n * \n *         cdef unsigned long long i\n *\/\n  __pyx_t_1 = PyTuple_New(__pyx_v_n_items); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 67, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_items = ((PyObject*)__pyx_t_1);\n  __pyx_t_1 = 0;\n\n  \/* \"clickhouse_driver\/bufferedreader.pyx\":71\n *         cdef unsigned long long i\n *         # Buffer vars\n *         cdef char* buffer_ptr = PyByteArray_AsString(self.buffer)             # <<<<<<<<<<<<<<\n *         cdef unsigned long long right\n *         # String length vars\n *\/\n  __pyx_t_1 = __pyx_v_self->buffer;\n  __Pyx_INCREF(__pyx_t_1);\n  __pyx_v_buffer_ptr = PyByteArray_AsString(__pyx_t_1);\n  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n\n  \/* \"clickhouse_driver\/bufferedreader.pyx\":78\n * \n *         # String for decode vars.\n *         cdef char *c_string = NULL             # <<<<<<<<<<<<<<\n *         cdef unsigned long long c_string_size = 1024\n *         cdef char *c_encoding = NULL\n *\/\n  __pyx_v_c_string = NULL;\n\n  \/* \"clickhouse_driver\/bufferedreader.pyx\":79\n *         # String for decode vars.\n *         cdef char *c_string = NULL\n *         cdef unsigned long long c_string_size = 1024             # <<<<<<<<<<<<<<\n *         cdef char *c_encoding = NULL\n *         if encoding:\n *\/\n  __pyx_v_c_string_size = 0x400;\n\n  \/* \"clickhouse_driver\/bufferedreader.pyx\":80\n *         cdef char *c_string = NULL\n *         cdef unsigned long long c_string_size = 1024\n *         cdef char *c_encoding = NULL             # <<<<<<<<<<<<<<\n *         if encoding:\n *             encoding = encoding.encode('utf-8')\n *\/\n  __pyx_v_c_encoding = NULL;\n\n  \/* \"clickhouse_driver\/bufferedreader.pyx\":81\n *         cdef unsigned long long c_string_size = 1024\n *         cdef char *c_encoding = NULL\n *         if encoding:             # <<<<<<<<<<<<<<\n *             encoding = encoding.encode('utf-8')\n *             c_encoding = encoding\n *\/\n  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_encoding); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 81, __pyx_L1_error)\n  if (__pyx_t_2) {\n\n    \/* \"clickhouse_driver\/bufferedreader.pyx\":82\n *         cdef char *c_encoding = NULL\n    __pyx_t_4 = NULL;\n    if (CYTHON_UNPACK_METHODS && likely(PyMethod_Check(__pyx_t_3))) {\n      __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);\n      if (likely(__pyx_t_4)) {\n        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);\n        __Pyx_INCREF(__pyx_t_4);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_3, function);\n      }\n    }\n    __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_kp_s_utf_8) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_s_utf_8);\n    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 82, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __Pyx_DECREF_SET(__pyx_v_encoding, __pyx_t_1);\n    __pyx_t_1 = 0;\n\n    \/* \"clickhouse_driver\/bufferedreader.pyx\":83\n *         if encoding:\n *             encoding = encoding.encode('utf-8')\n *             c_encoding = encoding             # <<<<<<<<<<<<<<\n * \n *         cdef object rv = object()\n *\/\n    __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_encoding); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 83, __pyx_L1_error)\n    __pyx_v_c_encoding = __pyx_t_5;\n\n    \/* \"clickhouse_driver\/bufferedreader.pyx\":81\n *         cdef unsigned long long c_string_size = 1024\n *         cdef char *c_encoding = NULL\n *         if encoding:             # <<<<<<<<<<<<<<\n *             encoding = encoding.encode('utf-8')\n *             c_encoding = encoding\n *\/\n  }\n\n  \/* \"clickhouse_driver\/bufferedreader.pyx\":85\n *             c_encoding = encoding\n * \n * \n *\/\n  __Pyx_XDECREF(__pyx_r);\n  __Pyx_INCREF(__pyx_v_items);\n  __pyx_r = __pyx_v_items;\n  goto __pyx_L0;\n\n  \/* \"clickhouse_driver\/bufferedreader.pyx\":62\n *         return rv\n * \n *     def read_strings(self, unsigned long long n_items, encoding=None):             # <<<<<<<<<<<<<<\n *         \"\"\"\n *         Python has great overhead between function calls.\n *\/\n\n  \/* function exit code *\/\n  __pyx_L1_error:;\n  __Pyx_XDECREF(__pyx_t_1);\n  __Pyx_XDECREF(__pyx_t_3);\n  __Pyx_XDECREF(__pyx_t_4);\n  __Pyx_XDECREF(__pyx_t_16);","target":0,"flaw_line_index":0,"hash":"11c12c2d-9d74-4c9a-890b-af665d550c61","idx":"8bae41de-66d0-4f34-a827-af6067cfb575"}
{"func_before":"l2tp_accm_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tuint16_t val_h, val_l;\n\n\tptr++;\t\t\/* skip \"Reserved\" *\/\n\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"send=%08x \", (val_h<<16) + val_l));\n\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"recv=%08x \", (val_h<<16) + val_l));\n}","target":1,"flaw_line_index":0,"hash":"a6d5778d-eabd-443c-ad84-82e17be4d55e","idx":"583e8c2a-519e-426e-998c-3b62fb496d64"}
{"func_before":"l2tp_accm_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tuint16_t val_h, val_l;\n\n\tif (length < 2) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tptr++;\t\t\/* skip \"Reserved\" *\/\n\tlength -= 2;\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tND_PRINT((ndo, \"send=%08x \", (val_h<<16) + val_l));\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"recv=%08x \", (val_h<<16) + val_l));\n}","target":0,"flaw_line_index":0,"hash":"877ed463-258e-4112-9631-91736adaf7eb","idx":"92bc0b2e-0e3c-4e0d-a3b3-1f9af70d9413"}
{"func_before":"show_tree(tree_t *t,                    \/* I - Parent node *\/\n          int    indent)                \/* I - Indentation *\/\n{\n  while (t)\n  {\n    if (t->markup == MARKUP_NONE)\n      printf(\"%*s\\\"%s\\\"\\n\", indent, \"\", t->data);\n    else\n      printf(\"%*s%s\\n\", indent, \"\", _htmlMarkups[t->markup]);\n\n    if (t->child)\n      show_tree(t->child, indent + 2);\n\n    t = t->next;\n  }\n}","target":1,"flaw_line_index":0,"hash":"1bef82fb-5d18-46e9-8871-c2c984ffbe1d","idx":"832281ea-dd05-4fe9-8eed-6f46312b7848"}
{"func_before":"show_tree(tree_t *t,                    \/* I - Parent node *\/\n          int    indent)                \/* I - Indentation *\/\n{\n  static const char * const markups[] =\n  {\n    \"FILE\",\n    \"UNKNOWN\",\n    \"ERROR\"\n  };\n\n  while (t)\n  {\n    if (t->markup == MARKUP_NONE)\n      printf(\"%*s\\\"%s\\\"\\n\", indent, \"\", t->data);\n    else if (t->markup > MARKUP_NONE)\n      printf(\"%*s%s\\n\", indent, \"\", _htmlMarkups[t->markup]);\n    else\n      printf(\"%*s%s\\n\", indent, \"\", markups[t->markup - MARKUP_FILE]);\n\n    if (t->child)\n      show_tree(t->child, indent + 2);\n\n    t = t->next;\n  }\n}","target":0,"flaw_line_index":0,"hash":"be5e8004-b2cf-482f-af1a-3b1332dd7152","idx":"69ed401f-2932-446e-85e1-f3a397c6c092"}
{"func_before":"  \/* Deploy versions older than 4 might have some of the below fields, but it's\n   * not guaranteed if the deploy was first created with an old Flatpak version\n   *\/\n  if (old_version < 4)\n    {\n      const char *commit;\n      g_autoptr(GVariant) commit_data = NULL;\n      g_autoptr(GVariant) commit_metadata = NULL;\n      g_autoptr(GKeyFile) keyfile = NULL;\n      g_autoptr(GFile) metadata_file = NULL;\n      g_autofree char *metadata_contents = NULL;\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n\n      \/* Add fields from commit metadata to deploy *\/\n      commit = flatpak_deploy_data_get_commit (deploy_data);\n      if (!ostree_repo_load_commit (repo, commit, &commit_data, NULL, error))\n        return NULL;\n      commit_metadata = g_variant_get_child_value (commit_data, 0);\n      add_commit_metadata_to_deploy_data (&metadata_dict, commit_metadata);\n\n      \/* Add fields from metadata file to deploy *\/\n      keyfile = g_key_file_new ();\n      metadata_file = g_file_resolve_relative_path (deploy_dir, \"metadata\");\n      if (!g_file_load_contents (metadata_file, cancellable,\n                                 &metadata_contents, NULL, NULL, error))\n        return NULL;\n      if (!g_key_file_load_from_data (keyfile, metadata_contents, -1, 0, error))\n        return NULL;\n      add_metadata_to_deploy_data (&metadata_dict, keyfile);\n\n      \/* Add fields from appdata to deploy, since appdata-content-rating wasn't\n       * added when upgrading from version 2 as it should have been\n       *\/\n      if (old_version >= 1)\n        add_appdata_to_deploy_data (&metadata_dict, deploy_dir, id);\n    }\n","target":1,"flaw_line_index":0,"hash":"cec55976-ad51-413f-a7ae-f81a86e80d2b","idx":"18bccc11-7369-4ee4-ab5b-2b30356a4d87"}
{"func_before":"   * not guaranteed if the deploy was first created with an old Flatpak version\n   *\/\n  if (old_version < 4)\n    {\n      const char *commit;\n      g_autoptr(GVariant) commit_data = NULL;\n      g_autoptr(GVariant) commit_metadata = NULL;\n      g_autoptr(GKeyFile) keyfile = NULL;\n      g_autoptr(GFile) metadata_file = NULL;\n      g_autofree char *metadata_contents = NULL;\n      gsize metadata_size = 0;\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n\n      \/* Add fields from commit metadata to deploy *\/\n      commit = flatpak_deploy_data_get_commit (deploy_data);\n      if (!ostree_repo_load_commit (repo, commit, &commit_data, NULL, error))\n        return NULL;\n      commit_metadata = g_variant_get_child_value (commit_data, 0);\n      add_commit_metadata_to_deploy_data (&metadata_dict, commit_metadata);\n\n      \/* Add fields from metadata file to deploy *\/\n      keyfile = g_key_file_new ();\n      metadata_file = g_file_resolve_relative_path (deploy_dir, \"metadata\");\n      if (!g_file_load_contents (metadata_file, cancellable,\n                                 &metadata_contents, &metadata_size, NULL, error))\n        return NULL;\n      if (!g_key_file_load_from_data (keyfile, metadata_contents, metadata_size, 0, error))\n        return NULL;\n      add_metadata_to_deploy_data (&metadata_dict, keyfile);\n\n      \/* Add fields from appdata to deploy, since appdata-content-rating wasn't\n       * added when upgrading from version 2 as it should have been\n       *\/\n      if (old_version >= 1)\n        add_appdata_to_deploy_data (&metadata_dict, deploy_dir, id);\n    }\n","target":0,"flaw_line_index":0,"hash":"4ca8e555-44e6-43ce-9205-4b3de4305240","idx":"437da9a4-d4bc-461c-a2aa-312689e06ae3"}
{"func_before":"snmp_ber_encode_integer(unsigned char *out, uint32_t *out_len, uint32_t number)\n{\n  uint32_t original_out_len;\n\n  original_out_len = *out_len;\n  do {\n    (*out_len)++;\n    *out-- = (uint8_t)(number & 0xFF);\n    number >>= 8;\n  } while(number);\n\n  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n  out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_INTEGER);\n\n  return out;\n}","target":1,"flaw_line_index":0,"hash":"64160cbf-2ddc-42ff-8981-0624eccafddc","idx":"303d2103-0dc5-4daf-b2a7-839b9fd7b3ef"}
{"func_before":"snmp_ber_encode_integer(snmp_packet_t *snmp_packet, uint32_t number)\n{\n  return snmp_ber_encode_unsigned_integer(snmp_packet, BER_DATA_TYPE_INTEGER, number);\n}","target":0,"flaw_line_index":0,"hash":"142c46d2-e602-46b5-9b0d-981bacfbb11b","idx":"78b32edb-a9f4-4423-b90c-31f2a59c3e32"}
{"func_before":"set_option_value(\n    char_u\t*name,\n    long\tnumber,\n    char_u\t*string,\n    int\t\topt_flags)\t\/\/ OPT_LOCAL or 0 (both)\n{\n    int\t\topt_idx;\n    char_u\t*varp;\n    long_u\tflags;\n    static char\terrbuf[80];\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\n    {\n\tint key;\n\n\tif (STRLEN(name) == 4 && name[0] == 't' && name[1] == '_'\n\t\t&& (key = find_key_option(name, FALSE)) != 0)\n\t{\n\t    char_u key_name[2];\n\tflags = options[opt_idx].flags;\n#ifdef HAVE_SANDBOX\n\t\/\/ Disallow changing some options in the sandbox\n\tif (sandbox > 0 && (flags & P_SECURE))\n\t{\n\t    emsg(_(e_not_allowed_in_sandbox));\n\t    return NULL;\n\t}\n#endif\n\tif (flags & P_STRING)\n\t    return set_string_option(opt_idx, string, opt_flags, errbuf);\n\n\tvarp = get_varp_scope(&(options[opt_idx]), opt_flags);\n\tif (varp != NULL)\t\/\/ hidden option is not changed\n\t{\n\t    if (number == 0 && string != NULL)\n\t    {\n\t\tint idx;\n\n\t\t\/\/ Either we are given a string or we are setting option\n\t\t\/\/ to zero.","target":1,"flaw_line_index":0,"hash":"74e40a9c-6635-4301-94f9-11e275f14d12","idx":"de57e4d4-f037-439b-8669-5e5ae8f0b602"}
{"func_before":"set_option_value(\n    char_u\t*name,\n    long\tnumber,\n    char_u\t*string,\n    int\t\topt_flags)\t\/\/ OPT_LOCAL or 0 (both)\n{\n    int\t\topt_idx;\n    char_u\t*varp;\n    long_u\tflags;\n    static char\terrbuf[ERR_BUFLEN];\n    int\t\terrbuflen = ERR_BUFLEN;\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\n    {\n\tint key;\n\n\tif (STRLEN(name) == 4 && name[0] == 't' && name[1] == '_'\n\t\t&& (key = find_key_option(name, FALSE)) != 0)\n\t{\n\t    char_u key_name[2];\n\tflags = options[opt_idx].flags;\n#ifdef HAVE_SANDBOX\n\t\/\/ Disallow changing some options in the sandbox\n\tif (sandbox > 0 && (flags & P_SECURE))\n\t{\n\t    emsg(_(e_not_allowed_in_sandbox));\n\t    return NULL;\n\t}\n#endif\n\tif (flags & P_STRING)\n\t    return set_string_option(opt_idx, string, opt_flags, errbuf, errbuflen);\n\n\tvarp = get_varp_scope(&(options[opt_idx]), opt_flags);\n\tif (varp != NULL)\t\/\/ hidden option is not changed\n\t{\n\t    if (number == 0 && string != NULL)\n\t    {\n\t\tint idx;\n\n\t\t\/\/ Either we are given a string or we are setting option\n\t\t\/\/ to zero.","target":0,"flaw_line_index":0,"hash":"5c4ddacb-ec08-4ece-a295-62f607e29f12","idx":"3052dd52-1455-4fcf-974d-91ddc83c76fd"}
{"func_before":"static inline Quantum GetPixelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[image->channel_map[channel].offset].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[channel].offset]);\n}","target":1,"flaw_line_index":0,"hash":"ef75d743-b298-4666-8f87-0fb043f5338e","idx":"b505c4fa-9310-4d82-b2dc-fc6466f6b782"}
{"func_before":"static inline Quantum GetPixelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[channel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[channel].offset]);\n}","target":0,"flaw_line_index":0,"hash":"20ccb92f-283e-444f-be22-1b6b1d711500","idx":"b7053d9c-86f3-4b33-8223-a5094f026a28"}
{"func_before":"int utf8s_to_utf16s(const u8 *s, int len, wchar_t *pwcs)\n{\n\tu16 *op;\n\tint size;\n\tunicode_t u;\n\n\top = pwcs;\n\twhile (*s && len > 0) {\n\t\tif (*s & 0x80) {\n\t\t\tsize = utf8_to_utf32(s, len, &u);\n\t\t\tif (size < 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (u >= PLANE_SIZE) {\n\t\t\t\tu -= PLANE_SIZE;\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n\t\t\t\t\t\t((u >> 10) & SURROGATE_BITS));\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n\t\t\t\t\t\tSURROGATE_LOW |\n\t\t\t\t\t\t(u & SURROGATE_BITS));\n\t\t\t} else {\n\t\t\t\t*op++ = (wchar_t) u;\n\t\t\t}\n\t\t\ts += size;\n\t\t\tlen -= size;\n\t\t} else {\n\t\t\t*op++ = *s++;\n\t\t\tlen--;\n\t\t}\n\t}\n\treturn op - pwcs;\n}","target":1,"flaw_line_index":0,"hash":"57c8ebfb-c845-441a-8209-b835c6222a22","idx":"b16bcbaf-5ece-45b8-9f0a-3e19691ecd26"}
{"func_before":"int utf8s_to_utf16s(const u8 *s, int len, enum utf16_endian endian,\n\t\twchar_t *pwcs, int maxlen)\n{\n\tu16 *op;\n\tint size;\n\tunicode_t u;\n\n\top = pwcs;\n\twhile (len > 0 && maxlen > 0 && *s) {\n\t\tif (*s & 0x80) {\n\t\t\tsize = utf8_to_utf32(s, len, &u);\n\t\t\tif (size < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\ts += size;\n\t\t\tlen -= size;\n\n\t\t\tif (u >= PLANE_SIZE) {\n\t\t\t\tif (maxlen < 2)\n\t\t\t\t\tbreak;\n\t\t\t\tu -= PLANE_SIZE;\n\t\t\t\tput_utf16(op++, SURROGATE_PAIR |\n\t\t\t\t\t\t((u >> 10) & SURROGATE_BITS),\n\t\t\t\t\t\tendian);\n\t\t\t\tput_utf16(op++, SURROGATE_PAIR |\n\t\t\t\t\t\tSURROGATE_LOW |\n\t\t\t\t\t\t(u & SURROGATE_BITS),\n\t\t\t\t\t\tendian);\n\t\t\t\tmaxlen -= 2;\n\t\t\t} else {\n\t\t\t\tput_utf16(op++, u, endian);\n\t\t\t\tmaxlen--;\n\t\t\t}\n\t\t} else {\n\t\t\tput_utf16(op++, *s++, endian);\n\t\t\tlen--;\n\t\t\tmaxlen--;\n\t\t}\n\t}\n\treturn op - pwcs;\n}","target":0,"flaw_line_index":0,"hash":"ecec8d02-f8f5-4521-be74-661ffa5a4455","idx":"e3db6761-0244-4cb7-849b-24e1678e8d4d"}
{"func_before":"\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\/*this is to cope with single MFString which shall appear as SF in XMT*\/\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {","target":1,"flaw_line_index":0,"hash":"bcca457f-bf80-4c04-8666-8568dfa2808f","idx":"df3a15c7-70c2-4aff-8d9e-5957953c8468"}
{"func_before":"\t\tGenMFField *mffield;\n\t\tmffield = (GenMFField *) field.far_ptr;\n\t\tsf_type = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"[\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; mffield && (i<mffield->count); i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\/*this is to cope with single MFString which shall appear as SF in XMT*\/\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}\n\t\tif (!sdump->XMLDump) {\n\t\t\tgf_fprintf(sdump->trace, \"]\");\n\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \"\\'\");\n\t\t} else {","target":0,"flaw_line_index":0,"hash":"307c7e54-59d6-4beb-806c-2c2968146c29","idx":"52c529d3-54fd-4d32-8292-2d51fd79f00d"}
{"func_before":"\t\/* initializations*\/\n\ttcp = &p_cp->tcps [tileno];\n\tl_tccp = tcp->tccps;\n\tl_img_comp = p_image->comps;\n\n\t\/* position in x and y of tile*\/\n\tp = tileno % p_cp->tw;\n\tq = tileno \/ p_cp->tw;\n\n\t\/* here calculation of tx0, tx1, ty0, ty1, maxprec, l_dx and l_dy *\/\n\t*p_tx0 = opj_int_max((OPJ_INT32)(p_cp->tx0 + p * p_cp->tdx), (OPJ_INT32)p_image->x0);\n\t*p_tx1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + (p + 1) * p_cp->tdx), (OPJ_INT32)p_image->x1);\n\t*p_ty0 = opj_int_max((OPJ_INT32)(p_cp->ty0 + q * p_cp->tdy), (OPJ_INT32)p_image->y0);\n\t*p_ty1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + (q + 1) * p_cp->tdy), (OPJ_INT32)p_image->y1);\n\n\t\/* max precision and resolution is 0 (can only grow)*\/\n\t*p_max_prec = 0;\n\t*p_max_res = 0;\n\n\t\/* take the largest value for dx_min and dy_min*\/\n\t*p_dx_min = 0x7fffffff;\n\t*p_dy_min = 0x7fffffff;\n\n\tfor (compno = 0; compno < p_image->numcomps; ++compno) {","target":1,"flaw_line_index":0,"hash":"b4c00300-245f-4610-ba8f-f5914d0980c0","idx":"2169e091-e677-4e96-bc3e-e356b4468ef1"}
{"func_before":"\t\/* initializations*\/\n\ttcp = &p_cp->tcps [tileno];\n\tl_tccp = tcp->tccps;\n\tl_img_comp = p_image->comps;\n\n\t\/* position in x and y of tile*\/\n\tp = tileno % p_cp->tw;\n\tq = tileno \/ p_cp->tw;\n\n\t\/* here calculation of tx0, tx1, ty0, ty1, maxprec, l_dx and l_dy *\/\n\t*p_tx0 = (OPJ_INT32)opj_uint_max(p_cp->tx0 + p * p_cp->tdx, p_image->x0);\n\t*p_tx1 = (OPJ_INT32)opj_uint_min(p_cp->tx0 + (p + 1) * p_cp->tdx, p_image->x1);\n\t*p_ty0 = (OPJ_INT32)opj_uint_max(p_cp->ty0 + q * p_cp->tdy, p_image->y0);\n\t*p_ty1 = (OPJ_INT32)opj_uint_min(p_cp->ty0 + (q + 1) * p_cp->tdy, p_image->y1);\n\n\t\/* max precision and resolution is 0 (can only grow)*\/\n\t*p_max_prec = 0;\n\t*p_max_res = 0;\n\n\t\/* take the largest value for dx_min and dy_min*\/\n\t*p_dx_min = 0x7fffffff;\n\t*p_dy_min = 0x7fffffff;\n\n\tfor (compno = 0; compno < p_image->numcomps; ++compno) {","target":0,"flaw_line_index":0,"hash":"3573017e-deb9-4da8-9537-4f01043062b8","idx":"0a098720-37f6-455a-92b2-dbea9f566652"}
{"func_before":"TEST_P(Http2CodecImplTest, TestLargeRequestHeadersAtLimitAccepted) {\n  uint32_t codec_limit_kb = 64;\n  max_request_headers_kb_ = codec_limit_kb;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  std::string key = \"big\";\n  uint32_t head_room = 77;\n  uint32_t long_string_length =\n      codec_limit_kb * 1024 - request_headers.byteSize() - key.length() - head_room;\n  std::string long_string = std::string(long_string_length, 'q');\n  request_headers.addCopy(key, long_string);\n\n  \/\/ The amount of data sent to the codec is not equivalent to the size of the\n  \/\/ request headers that Envoy computes, as the codec limits based on the\n  \/\/ entire http2 frame. The exact head room needed (76) was found through iteration.\n  ASSERT_EQ(request_headers.byteSize() + head_room, codec_limit_kb * 1024);\n\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _));\n  request_encoder_->encodeHeaders(request_headers, true);\n}","target":1,"flaw_line_index":0,"hash":"d62855c0-df13-47f5-8be0-63934483ded7","idx":"2860f96e-52c1-470e-a0a5-2635bb058f67"}
{"func_before":"TEST_P(Http2CodecImplTest, TestLargeRequestHeadersAtLimitAccepted) {\n  uint32_t codec_limit_kb = 64;\n  max_request_headers_kb_ = codec_limit_kb;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  \/\/ Refresh byte size after adding default inline headers by reference.\n  request_headers.refreshByteSize();\n  std::string key = \"big\";\n  uint32_t head_room = 77;\n  uint32_t long_string_length =\n      codec_limit_kb * 1024 - request_headers.byteSize().value() - key.length() - head_room;\n  std::string long_string = std::string(long_string_length, 'q');\n  request_headers.addCopy(key, long_string);\n\n  \/\/ The amount of data sent to the codec is not equivalent to the size of the\n  \/\/ request headers that Envoy computes, as the codec limits based on the\n  \/\/ entire http2 frame. The exact head room needed (76) was found through iteration.\n  ASSERT_EQ(request_headers.byteSize().value() + head_room, codec_limit_kb * 1024);\n\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _));\n  request_encoder_->encodeHeaders(request_headers, true);\n}","target":0,"flaw_line_index":0,"hash":"30336984-ad55-4d04-b3a0-bef51e70d3e7","idx":"2076400e-3ba9-4b47-b68d-72d3bfae118b"}
{"func_before":"\n\t\/* Don't use (incr*2 < delta), incr*2 might overflow. *\/\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1 << i;\n\t\tdelta -= incr;\n\t}\n}","target":1,"flaw_line_index":0,"hash":"324eaa60-e1f9-43c5-a254-ff6fa2fc4542","idx":"e9d64498-97f7-43d9-96c3-dc1bb8089d57"}
{"func_before":"\n\t\/* Don't use (incr*2 < delta), incr*2 might overflow. *\/\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1LL << i;\n\t\tdelta -= incr;\n\t}\n}","target":0,"flaw_line_index":0,"hash":"63555da5-f75c-42f0-aa53-91d41b182c23","idx":"a6219823-3478-42f2-8721-9b66bf46b4d8"}
{"func_before":"\t} else {\n\t\tint err, size = decode_access_size(insn);\n\t\tunsigned long addr;\n\n\t\tif(floating_point_load_or_store_p(insn)) {\n\t\t\tprintk(\"User FPU load\/store unaligned unsupported.\\n\");\n\t\t\tgoto kill_user;\n\t\t}\n\n\t\taddr = compute_effective_address(regs, insn);\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, addr);\n\t\tswitch(dir) {\n\t\tcase load:\n\t\t\terr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),\n\t\t\t\t\t\t\t regs),\n\t\t\t\t\t  size, (unsigned long *) addr,\n\t\t\t\t\t  decode_signedness(insn));\n\t\t\tbreak;\n\n\t\tcase store:\n\t\t\terr = do_int_store(((insn>>25)&0x1f), size,","target":1,"flaw_line_index":0,"hash":"afc51e49-000d-4102-b118-5a099d68d222","idx":"889ce5a6-c178-411c-a67e-f892d4866aec"}
{"func_before":"\t} else {\n\t\tint err, size = decode_access_size(insn);\n\t\tunsigned long addr;\n\n\t\tif(floating_point_load_or_store_p(insn)) {\n\t\t\tprintk(\"User FPU load\/store unaligned unsupported.\\n\");\n\t\t\tgoto kill_user;\n\t\t}\n\n\t\taddr = compute_effective_address(regs, insn);\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, addr);\n\t\tswitch(dir) {\n\t\tcase load:\n\t\t\terr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),\n\t\t\t\t\t\t\t regs),\n\t\t\t\t\t  size, (unsigned long *) addr,\n\t\t\t\t\t  decode_signedness(insn));\n\t\t\tbreak;\n\n\t\tcase store:\n\t\t\terr = do_int_store(((insn>>25)&0x1f), size,","target":0,"flaw_line_index":0,"hash":"2206961c-a46e-443f-8726-552667f2c9f7","idx":"e34976bc-aeea-4abf-991b-4f2432a73b3e"}
{"func_before":"static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t\/* 32-bit ALU ops are (32,32)->64 *\/\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t\tcoerce_reg_to_size(&src_reg, 4);\n\t}\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t\t\/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t *\/\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t\/* We may learn something more from the var_off *\/\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val > 63) {\n\t\t\t\/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t *\/\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t\/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t *\/\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t\/* If we might shift our top bit out, then we know nothing *\/\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n\t\t\/* We may learn something more from the var_off *\/\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val > 63) {\n\t\t\t\/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t *\/\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t\/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\t\tdst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t\/* We may learn something more from the var_off *\/\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"411b7203-c2f6-4132-badc-098e527004a7","idx":"11ef2c1e-2d81-41b7-8d80-274b738f445a"}
{"func_before":"static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,\n\t\t\t\t      struct bpf_insn *insn,\n\t\t\t\t      struct bpf_reg_state *dst_reg,\n\t\t\t\t      struct bpf_reg_state src_reg)\n{\n\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\tu64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;\n\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\tdst_known = tnum_is_const(dst_reg->var_off);\n\n\tswitch (opcode) {\n\tcase BPF_ADD:\n\t\tif (signed_add_overflows(dst_reg->smin_value, smin_val) ||\n\t\t\t\/* ORing two positives gives a positive, so safe to\n\t\t\t * cast result into s64.\n\t\t\t *\/\n\t\t\tdst_reg->smin_value = dst_reg->umin_value;\n\t\t\tdst_reg->smax_value = dst_reg->umax_value;\n\t\t}\n\t\t\/* We may learn something more from the var_off *\/\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t\/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t *\/\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t\/* We lose all sign bit information (except what we can pick\n\t\t * up from var_off)\n\t\t *\/\n\t\tdst_reg->smin_value = S64_MIN;\n\t\tdst_reg->smax_value = S64_MAX;\n\t\t\/* If we might shift our top bit out, then we know nothing *\/\n\t\t\tdst_reg->umax_value <<= umax_val;\n\t\t}\n\t\tif (src_known)\n\t\t\tdst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);\n\t\telse\n\t\t\tdst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n\t\t\/* We may learn something more from the var_off *\/\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t\/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t *\/\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t\/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\t * be negative, then either:\n\t\t * 1) src_reg might be zero, so the sign bit of the result is\n\t\t *    unknown, so we lose our signed bounds\n\t\t * 2) it's known negative, thus the unsigned bounds capture the\n\t\t *    signed bounds\n\t\tdst_reg->umin_value >>= umax_val;\n\t\tdst_reg->umax_value >>= umin_val;\n\t\t\/* We may learn something more from the var_off *\/\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t\/* 32-bit ALU ops are (32,32)->32 *\/\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t\tcoerce_reg_to_size(&src_reg, 4);\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"9eda909d-8055-47f7-ae49-60d688cc0033","idx":"ff434c11-aa0b-4b2c-90fc-8d8a210902dd"}
{"func_before":"\tdev->priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE;\n\tdev->netdev_ops = &virtnet_netdev;\n\tdev->features = NETIF_F_HIGHDMA;\n\n\tdev->ethtool_ops = &virtnet_ethtool_ops;\n\tSET_NETDEV_DEV(dev, &vdev->dev);\n\n\t\/* Do we support \"hardware\" checksums? *\/\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CSUM)) {\n\t\t\/* This opens up the world of extra features. *\/\n\t\tdev->hw_features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;\n\t\tif (csum)\n\t\t\tdev->features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;\n\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_GSO)) {\n\t\t\tdev->hw_features |= NETIF_F_TSO | NETIF_F_UFO\n\t\t\t\t| NETIF_F_TSO_ECN | NETIF_F_TSO6;\n\t\t}\n\t\t\/* Individual feature bits: what can host handle? *\/\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_TSO4))\n\t\t\tdev->hw_features |= NETIF_F_TSO;\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_TSO6))\n\t\t\tdev->hw_features |= NETIF_F_TSO6;","target":1,"flaw_line_index":0,"hash":"bed2e939-9f38-4907-8249-a248dfba7c24","idx":"a53eac3c-41a9-4c0e-a9d9-4017abeaeb4b"}
{"func_before":"\tdev->priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE;\n\tdev->netdev_ops = &virtnet_netdev;\n\tdev->features = NETIF_F_HIGHDMA;\n\n\tdev->ethtool_ops = &virtnet_ethtool_ops;\n\tSET_NETDEV_DEV(dev, &vdev->dev);\n\n\t\/* Do we support \"hardware\" checksums? *\/\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CSUM)) {\n\t\t\/* This opens up the world of extra features. *\/\n\t\tdev->hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG;\n\t\tif (csum)\n\t\t\tdev->features |= NETIF_F_HW_CSUM | NETIF_F_SG;\n\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_GSO)) {\n\t\t\tdev->hw_features |= NETIF_F_TSO | NETIF_F_UFO\n\t\t\t\t| NETIF_F_TSO_ECN | NETIF_F_TSO6;\n\t\t}\n\t\t\/* Individual feature bits: what can host handle? *\/\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_TSO4))\n\t\t\tdev->hw_features |= NETIF_F_TSO;\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_HOST_TSO6))\n\t\t\tdev->hw_features |= NETIF_F_TSO6;","target":0,"flaw_line_index":0,"hash":"226ba3f6-ee7f-4396-a856-bdfe05c64cc9","idx":"579f80e0-d6ec-4fa3-9307-227731de5b81"}
{"func_before":"            ptr += picture->linesize[i];\n        }\n    }\n\n    s->picture = picture;\n\n    avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);\n\n    ymax = FFMAX(0, s->ymax + 1);\n    \/\/ Zero out the end if ymax+1 is not h\n    for (i = 0; i < planes; i++) {\n        ptr = picture->data[i] + (ymax * picture->linesize[i]);\n        for (y = ymax; y < avctx->height; y++) {\n            memset(ptr, 0, out_line_size);\n            ptr += picture->linesize[i];\n        }\n    }\n\n    picture->pict_type = AV_PICTURE_TYPE_I;\n    *got_frame = 1;\n\n    return avpkt->size;\n}","target":1,"flaw_line_index":0,"hash":"a0f41955-0a66-4d25-9ef0-f3157f7b7be2","idx":"b081c789-77a9-4b5f-9502-ff4b5c5911f9"}
{"func_before":"            ptr += picture->linesize[i];\n        }\n    }\n\n    s->picture = picture;\n\n    avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);\n\n    ymax = FFMAX(0, s->ymax + 1);\n    \/\/ Zero out the end if ymax+1 is not h\n    if (ymax < avctx->height)\n        for (i = 0; i < planes; i++) {\n            ptr = picture->data[i] + (ymax * picture->linesize[i]);\n            for (y = ymax; y < avctx->height; y++) {\n                memset(ptr, 0, out_line_size);\n                ptr += picture->linesize[i];\n            }\n        }\n\n    picture->pict_type = AV_PICTURE_TYPE_I;\n    *got_frame = 1;\n\n    return avpkt->size;\n}","target":0,"flaw_line_index":0,"hash":"0d6b0904-856d-47a7-a6d6-86d9921a9ab2","idx":"6ea7396f-0b77-4088-bbb1-5a64f2bf361a"}
{"func_before":"static void lo_release(struct gendisk *disk, fmode_t mode)\n{\n\tstruct loop_device *lo = disk->private_data;\n\tint err;\n\n\tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\t\/*\n\t\t * In autoclear mode, stop the loop thread\n\t\t * and remove configuration after last close.\n\t\t *\/\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\t\/*\n\t\t * Otherwise keep thread (if running) and config,\n\t\t * but flush possible ongoing bios in thread.\n\t\t *\/\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\n\tmutex_unlock(&lo->lo_ctl_mutex);\n}","target":1,"flaw_line_index":0,"hash":"9c80fd55-862b-40ac-9b37-5667f96fb050","idx":"8ed06e07-216a-40ba-a151-7a9baf4d9dca"}
{"func_before":"static void lo_release(struct gendisk *disk, fmode_t mode)\n{\n\tmutex_lock(&loop_index_mutex);\n\t__lo_release(disk->private_data);\n\tmutex_unlock(&loop_index_mutex);\n}","target":0,"flaw_line_index":0,"hash":"66d2e999-a25b-4867-a934-75f2ffd46e61","idx":"64829f06-92e6-4476-be15-6d3c3cac061f"}
{"func_before":"      info, trace_span.get(),\n      [context, continuation, trace_span](\n          Status status, const service_control::CheckResponseInfo &info) {\n        TRACE(trace_span) << \"Check service control request returned with \"\n                          << \"status \" << status.ToString();\n        \/\/ info is valid regardless status.\n        context->set_check_response_info(info);\n\n        \/\/ update consumer_project_id to service context\n        if (!info.consumer_project_id.empty()) {\n          context->request()->AddHeaderToBackend(kConsumerProjecId,\n                                                 info.consumer_project_id);\n        }\n\n        continuation(status);\n      });\n}","target":1,"flaw_line_index":0,"hash":"841af02b-039f-47e2-a32e-29eccc6149d8","idx":"a32e89b6-68fb-425c-8301-a847a2528b3d"}
{"func_before":"      info, trace_span.get(),\n      [context, continuation, trace_span](\n          Status status, const service_control::CheckResponseInfo &info) {\n        TRACE(trace_span) << \"Check service control request returned with \"\n                          << \"status \" << status.ToString();\n        \/\/ info is valid regardless status.\n        context->set_check_response_info(info);\n\n        \/\/ update consumer_project_id to service context\n        if (!info.consumer_project_id.empty()) {\n          context->request()->AddHeaderToBackend(\n              kConsumerProjecId, info.consumer_project_id, false);\n        }\n\n        continuation(status);\n      });\n}","target":0,"flaw_line_index":0,"hash":"3710fc54-cc2e-4e44-8f77-4b39b4fb599b","idx":"37d30f6f-cc53-4e38-9c9b-9b9b82c0fb32"}
{"func_before":"\n\t\/* Start all dormant timers *\/\n\t_UEV_FOREACH(w, ctx->watchers) {\n\t\tif (UEV_CRON_TYPE == w->type)\n\t\t\tuev_cron_set(w, w->u.c.when, w->u.c.interval);\n\t\tif (UEV_TIMER_TYPE == w->type)\n\t\t\tuev_timer_set(w, w->u.t.timeout, w->u.t.period);\n\t}\n\n\twhile (ctx->running && ctx->watchers) {\n\t\tstruct epoll_event ee[UEV_MAX_EVENTS];\n\t\tint i, nfds, rerun = 0;\n\n\t\t\/* Handle special case: `application < file.txt` *\/\n\t\tif (ctx->workaround) {\n\t\t\t_UEV_FOREACH(w, ctx->watchers) {\n\t\t\t\tif (w->active != -1 || !w->cb)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!has_data(w->fd)) {\n\t\t\t\t\tw->active = 0;\n\t\t\t\t\t_UEV_REMOVE(w, ctx->watchers);\n\n\t\t\t\trerun++;\n\t\t\t\tw->cb(w, w->arg, UEV_READ);\n\t\t\t}\n\t\t}\n\n\t\tif (rerun)\n\t\t\tcontinue;\n\t\tctx->workaround = 0;\n\n\t\twhile ((nfds = epoll_wait(ctx->fd, ee, ctx->maxevents, timeout)) < 0) {\n\t\t\tif (!ctx->running)\n\t\t\t\tbreak;\n\n\t\t\tif (EINTR == errno)\n\t\t\t\tcontinue; \/* Signalled, try again *\/\n\n\t\t\t\/* Unrecoverable error, cleanup and exit with error. *\/\n\t\t\tuev_exit(ctx);\n\n\t\t\treturn -2;","target":1,"flaw_line_index":0,"hash":"aafb7cde-c424-4c80-bfd0-a99435fe48b0","idx":"ed686999-a50b-433b-b1d3-f311c671def9"}
{"func_before":"\t\/* Start all dormant timers *\/\n\t_UEV_FOREACH(w, ctx->watchers) {\n\t\tif (UEV_CRON_TYPE == w->type)\n\t\t\tuev_cron_set(w, w->u.c.when, w->u.c.interval);\n\t\tif (UEV_TIMER_TYPE == w->type)\n\t\t\tuev_timer_set(w, w->u.t.timeout, w->u.t.period);\n\t}\n\n\twhile (ctx->running && ctx->watchers) {\n\t\tstruct epoll_event ee[UEV_MAX_EVENTS];\n\t\tint maxevents = ctx->maxevents;\n\t\tint i, nfds, rerun = 0;\n\n\t\tif (maxevents > UEV_MAX_EVENTS)\n\t\t\tmaxevents = UEV_MAX_EVENTS;\n\n\t\t\/* Handle special case: `application < file.txt` *\/\n\t\tif (ctx->workaround) {\n\t\t\t_UEV_FOREACH(w, ctx->watchers) {\n\t\t\t\tif (w->active != -1 || !w->cb)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (!has_data(w->fd)) {\n\t\t\t\t\tw->active = 0;\n\t\t\t\t\t_UEV_REMOVE(w, ctx->watchers);\n\n\t\t\t\trerun++;\n\t\t\t\tw->cb(w, w->arg, UEV_READ);\n\t\t\t}\n\t\t}\n\n\t\tif (rerun)\n\t\t\tcontinue;\n\t\tctx->workaround = 0;\n\n\t\twhile ((nfds = epoll_wait(ctx->fd, ee, maxevents, timeout)) < 0) {\n\t\t\tif (!ctx->running)\n\t\t\t\tbreak;\n\n\t\t\tif (EINTR == errno)\n\t\t\t\tcontinue; \/* Signalled, try again *\/\n\n\t\t\t\/* Unrecoverable error, cleanup and exit with error. *\/\n\t\t\tuev_exit(ctx);\n\n\t\t\treturn -2;","target":0,"flaw_line_index":0,"hash":"1edb1e7c-7e2c-4707-a509-029ac6c380b4","idx":"804e38f0-8c5b-4c93-bf69-daf9f7606ebd"}
{"func_before":"static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t value;\n    int position, zeroes, i, j;\n    char bits[65];\n\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    zeroes = i = 0;\n    while (1) {\n        if (get_bits_left(gbc) < zeroes + 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (get_bits1(gbc)) {\n            bits[i++] = '1';\n            break;\n        } else {\n            bits[i++] = '0';\n            ++zeroes;\n        }\n    }\n\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        value = get_bits_long(gbc, zeroes);\n\n        for (j = 0; j < zeroes; j++)\n            bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';\n\n        value += (1 << zeroes) - 1;\n    }\n\n    if (ctx->trace_enable) {\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL,\n                                    bits, value);\n    }\n\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n\n    *write_to = value;","target":1,"flaw_line_index":0,"hash":"238e7ac8-52c0-467e-8b83-5a007bd0f567","idx":"dcba44cc-a78e-46eb-9cbd-dfae89294387"}
{"func_before":"static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t zeroes, bits_value, value;\n    int position;\n\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    zeroes = 0;\n    while (1) {\n        if (get_bits_left(gbc) < 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (get_bits1(gbc))\n            break;\n        ++zeroes;\n    }\n\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        if (get_bits_left(gbc) < zeroes) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n\n        bits_value = get_bits_long(gbc, zeroes);\n        value = bits_value + (UINT32_C(1) << zeroes) - 1;\n    }\n\n    if (ctx->trace_enable) {\n        char bits[65];\n        int i, j, k;\n\n        if (zeroes >= 32) {\n            while (zeroes > 32) {\n                k = FFMIN(zeroes - 32, 32);\n                for (i = 0; i < k; i++)\n                    bits[i] = '0';\n                bits[i] = 0;\n                ff_cbs_trace_syntax_element(ctx, position, name,\n                                            NULL, bits, 0);\n                zeroes -= k;\n                position += k;\n            }\n        }\n\n        for (i = 0; i < zeroes; i++)\n            bits[i] = '0';\n        bits[i++] = '1';\n\n        if (zeroes < 32) {\n            for (j = 0; j < zeroes; j++)\n                bits[i++] = (bits_value >> (zeroes - j - 1) & 1) ? '1' : '0';\n        }\n\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name,\n                                    NULL, bits, value);\n    }\n\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n\n    *write_to = value;","target":0,"flaw_line_index":0,"hash":"87fba3f0-1519-4f24-b510-10728f89b32f","idx":"4637bcba-e462-4ee4-bb8f-5220661648ba"}
{"func_before":"int my_redel(const char *org_name, const char *tmp_name, myf MyFlags)\n{\n  int error=1;\n  DBUG_ENTER(\"my_redel\");\n  DBUG_PRINT(\"my\",(\"org_name: '%s' tmp_name: '%s'  MyFlags: %d\",\n\t\t   org_name,tmp_name,MyFlags));\n\n  if (my_copystat(org_name,tmp_name,MyFlags) < 0)\n    goto end;\n  if (MyFlags & MY_REDEL_MAKE_BACKUP)\n  {\n    char name_buff[FN_REFLEN+20];    \n    char ext[20];\n    ext[0]='-';\n    get_date(ext+1,2+4,(time_t) 0);\n    strmov(strend(ext),REDEL_EXT);\n    if (my_rename(org_name, fn_format(name_buff, org_name, \"\", ext, 2),\n\t\t  MyFlags))\n      goto end;","target":1,"flaw_line_index":0,"hash":"4468ce64-c514-439b-9f54-6b25269f25fe","idx":"afa3771a-0b87-41c8-b09d-20c50637b80e"}
{"func_before":"int my_redel(const char *org_name, const char *tmp_name, myf MyFlags)\n{\n  int error=1;\n  DBUG_ENTER(\"my_redel\");\n  DBUG_PRINT(\"my\",(\"org_name: '%s' tmp_name: '%s'  MyFlags: %d\",\n\t\t   org_name,tmp_name,MyFlags));\n\n  if (!(MyFlags & MY_REDEL_NO_COPY_STAT))\n  {\n    if (my_copystat(org_name,tmp_name,MyFlags) < 0)\n      goto end;\n  }\n  if (MyFlags & MY_REDEL_MAKE_BACKUP)\n  {\n    char name_buff[FN_REFLEN+20];    \n    char ext[20];\n    ext[0]='-';\n    get_date(ext+1,2+4,(time_t) 0);\n    strmov(strend(ext),REDEL_EXT);\n    if (my_rename(org_name, fn_format(name_buff, org_name, \"\", ext, 2),\n\t\t  MyFlags))\n      goto end;","target":0,"flaw_line_index":0,"hash":"3621196b-aa67-42a1-9510-0d5fc21e0a7f","idx":"9925dab6-0918-4668-93d2-64e26662081b"}
{"func_before":"write_stacktrace(const char *file_name, const char *str)\n{\n\tint fd;\n\tvoid *buffer[100];\n\tint nptrs;\n\tint i;\n\tchar **strs;\n\n\tnptrs = backtrace(buffer, 100);\n\tif (file_name) {\n\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n\t\tif (str)\n\t\t\tdprintf(fd, \"%s\\n\", str);\n\t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n\t\tif (write(fd, \"\\n\", 1) != 1) {\n\t\t\t\/* We don't care, but this stops a warning on Ubuntu *\/\n\t\t}\n\t\tclose(fd);\n\t} else {\n\t\tif (str)\n\t\t\tlog_message(LOG_INFO, \"%s\", str);","target":1,"flaw_line_index":0,"hash":"a8c8ac78-ed80-4cae-98fc-715f72d4a15e","idx":"20f4256a-a2e9-498a-bb4a-625bc3b45dbe"}
{"func_before":"write_stacktrace(const char *file_name, const char *str)\n{\n\tint fd;\n\tvoid *buffer[100];\n\tint nptrs;\n\tint i;\n\tchar **strs;\n\n\tnptrs = backtrace(buffer, 100);\n\tif (file_name) {\n\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n\t\tif (str)\n\t\t\tdprintf(fd, \"%s\\n\", str);\n\t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n\t\tif (write(fd, \"\\n\", 1) != 1) {\n\t\t\t\/* We don't care, but this stops a warning on Ubuntu *\/\n\t\t}\n\t\tclose(fd);\n\t} else {\n\t\tif (str)\n\t\t\tlog_message(LOG_INFO, \"%s\", str);","target":0,"flaw_line_index":0,"hash":"32359daa-60e4-472a-8902-507daf591f3d","idx":"2cdeaa0c-8f35-49b5-a7df-bf44d700e52e"}
{"func_before":"  if (op->getType().isNumberType()) {\n    UOI->setType(numberResultType);\n    return true;\n  }\n\n  if (op->getType().isBigIntType()) {\n    UOI->setType(Type::createBigInt());\n    return true;\n  }\n\n  Type mayBeBigInt =\n      op->getType().canBeBigInt() ? Type::createBigInt() : Type::createNoType();\n\n  \/\/ - ?? => Number|?BigInt. BigInt is only possible if op.Type canBeBigInt.\n  UOI->setType(Type::unionTy(numberResultType, mayBeBigInt));\n  return true;\n}","target":1,"flaw_line_index":0,"hash":"ad471307-94c1-490a-bd26-d05e10e8c902","idx":"9b35b7bb-4192-4033-b980-d6f1a763813f"}
{"func_before":"  if (op->getType().isNumberType()) {\n    UOI->setType(numberResultType);\n    return true;\n  }\n\n  if (op->getType().isBigIntType()) {\n    UOI->setType(Type::createBigInt());\n    return true;\n  }\n\n  Type mayBeBigInt = isBigIntOrObject(op->getType()) ? Type::createBigInt()\n                                                     : Type::createNoType();\n\n  \/\/ - ?? => Number|?BigInt. BigInt is only possible if op.Type is\n  \/\/ BigInt|Object.\n  UOI->setType(Type::unionTy(numberResultType, mayBeBigInt));\n  return true;\n}","target":0,"flaw_line_index":0,"hash":"2a26048a-6547-4479-a978-9c4b120615c4","idx":"5eb8c4ff-a59c-4969-bffe-9be2c7077e89"}
{"func_before":"\n\t\t\/*\n\t\t * event overflow\n\t\t *\/\n\t\thandled++;\n\t\tdata.period\t= event->hw.last_period;\n\n\t\tif (!x86_perf_event_set_period(event))\n\t\t\tcontinue;\n\n\t\tif (perf_event_overflow(event, 1, &data, regs))\n\t\t\tx86_pmu_stop(event, 0);\n\t}\n\n\tif (handled)\n\t\tinc_irq_stat(apic_perf_irqs);\n\n\treturn handled;\n}","target":1,"flaw_line_index":0,"hash":"227890e7-ccc2-404e-ae68-4eded65538fc","idx":"6ad587cc-6b53-4f8f-b6ff-def4c1b1683b"}
{"func_before":"\n\t\t\/*\n\t\t * event overflow\n\t\t *\/\n\t\thandled++;\n\t\tdata.period\t= event->hw.last_period;\n\n\t\tif (!x86_perf_event_set_period(event))\n\t\t\tcontinue;\n\n\t\tif (perf_event_overflow(event, &data, regs))\n\t\t\tx86_pmu_stop(event, 0);\n\t}\n\n\tif (handled)\n\t\tinc_irq_stat(apic_perf_irqs);\n\n\treturn handled;\n}","target":0,"flaw_line_index":0,"hash":"b6fdd13f-20cf-4a45-9127-869d3e61a0f2","idx":"9cd5d0f8-02a2-49d0-b754-1f02326a28b2"}
{"func_before":"\n\tswitch (kiocb->ki_opcode) {\n\tcase IOCB_CMD_PREAD:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_READ)))\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (unlikely(!access_ok(VERIFY_WRITE, kiocb->ki_buf,\n\t\t\tkiocb->ki_left)))\n\t\t\tbreak;\n\t\tret = security_file_permission(file, MAY_READ);\n\t\tif (unlikely(ret))\n\t\t\tbreak;\n\t\tret = aio_setup_single_vector(kiocb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_read)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PWRITE:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_WRITE)))\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (unlikely(!access_ok(VERIFY_READ, kiocb->ki_buf,\n\t\t\tkiocb->ki_left)))\n\t\t\tbreak;\n\t\tret = security_file_permission(file, MAY_WRITE);\n\t\tif (unlikely(ret))\n\t\t\tbreak;\n\t\tret = aio_setup_single_vector(kiocb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_write)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PREADV:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_READ)))\n\t\t\tbreak;\n\t\tret = security_file_permission(file, MAY_READ);\n\t\tif (unlikely(ret))\n\t\t\tbreak;\n\t\tret = aio_setup_vectored_rw(READ, kiocb, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_read)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PWRITEV:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_WRITE)))\n\t\t\tbreak;\n\t\tret = security_file_permission(file, MAY_WRITE);\n\t\tif (unlikely(ret))\n\t\t\tbreak;\n\t\tret = aio_setup_vectored_rw(WRITE, kiocb, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_write)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_FDSYNC:\n\t\tret = -EINVAL;","target":1,"flaw_line_index":0,"hash":"2df27f31-e902-4976-a878-757435481760","idx":"caeabed6-f81c-41a4-940b-3968a07717dd"}
{"func_before":"\n\tswitch (kiocb->ki_opcode) {\n\tcase IOCB_CMD_PREAD:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_READ)))\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (unlikely(!access_ok(VERIFY_WRITE, kiocb->ki_buf,\n\t\t\tkiocb->ki_left)))\n\t\t\tbreak;\n\t\tret = aio_setup_single_vector(READ, file, kiocb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_read)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PWRITE:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_WRITE)))\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (unlikely(!access_ok(VERIFY_READ, kiocb->ki_buf,\n\t\t\tkiocb->ki_left)))\n\t\t\tbreak;\n\t\tret = aio_setup_single_vector(WRITE, file, kiocb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_write)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PREADV:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_READ)))\n\t\t\tbreak;\n\t\tret = aio_setup_vectored_rw(READ, kiocb, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_read)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PWRITEV:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_WRITE)))\n\t\t\tbreak;\n\t\tret = aio_setup_vectored_rw(WRITE, kiocb, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_write)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_FDSYNC:\n\t\tret = -EINVAL;","target":0,"flaw_line_index":0,"hash":"7622f913-7bff-45a3-abae-80ace82eb182","idx":"ab341434-0ba9-400f-92cd-996f77aa80e3"}
{"func_before":"\tif (ret = -EINVAL, vma->addr != addr || vma->size != size) {\n\t\tif (addr + size > vma->addr + vma->size || vma->memory ||\n\t\t    (vma->refd == NVKM_VMA_PAGE_NONE && !vma->mapref)) {\n\t\t\tVMM_DEBUG(vmm, \"split %d %d %d \"\n\t\t\t\t       \"%016llx %016llx %016llx %016llx\",\n\t\t\t\t  !!vma->memory, vma->refd, vma->mapref,\n\t\t\t\t  addr, size, vma->addr, (u64)vma->size);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (vma->addr != addr) {\n\t\t\tconst u64 tail = vma->size + vma->addr - addr;\n\t\t\tif (ret = -ENOMEM, !(vma = nvkm_vma_tail(vma, tail)))\n\t\t\t\tgoto fail;\n\t\t\tvma->part = true;\n\t\t\tnvkm_vmm_node_insert(vmm, vma);\n\t\t}\n\n\t\tif (vma->size != size) {\n\t\t\tconst u64 tail = vma->size - size;\n\t\t\tstruct nvkm_vma *tmp;\n\t\t\tif (ret = -ENOMEM, !(tmp = nvkm_vma_tail(vma, tail))) {\n\t\t\t\tnvkm_vmm_unmap_region(vmm, vma);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\ttmp->part = true;\n\t\t\tnvkm_vmm_node_insert(vmm, tmp);\n\t\t}\n\t}\n\tvma->busy = true;\n\tmutex_unlock(&vmm->mutex);\n\n\tret = nvkm_memory_map(memory, offset, vmm, vma, argv, argc);\n\tif (ret == 0) {\n\t\t\/* Successful map will clear vma->busy. *\/\n\t\tnvkm_memory_unref(&memory);\n\t\treturn 0;","target":1,"flaw_line_index":0,"hash":"916e49a1-a70e-4692-81b1-ca5629daac94","idx":"087e35ae-526c-4e8c-b265-9820cf881235"}
{"func_before":"\tif (ret = -EINVAL, vma->addr != addr || vma->size != size) {\n\t\tif (addr + size > vma->addr + vma->size || vma->memory ||\n\t\t    (vma->refd == NVKM_VMA_PAGE_NONE && !vma->mapref)) {\n\t\t\tVMM_DEBUG(vmm, \"split %d %d %d \"\n\t\t\t\t       \"%016llx %016llx %016llx %016llx\",\n\t\t\t\t  !!vma->memory, vma->refd, vma->mapref,\n\t\t\t\t  addr, size, vma->addr, (u64)vma->size);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tvma = nvkm_vmm_node_split(vmm, vma, addr, size);\n\t\tif (!vma) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tvma->busy = true;\n\tmutex_unlock(&vmm->mutex);\n\n\tret = nvkm_memory_map(memory, offset, vmm, vma, argv, argc);\n\tif (ret == 0) {\n\t\t\/* Successful map will clear vma->busy. *\/\n\t\tnvkm_memory_unref(&memory);\n\t\treturn 0;","target":0,"flaw_line_index":0,"hash":"2a711938-3987-4a2c-b3ac-ee4f5770b420","idx":"856bb408-91f9-41b7-a8a6-91f45f82c77b"}
{"func_before":"void _luac_build_info(LuaProto *proto, LuacBinInfo *info) {\n\t\/* process proto header info *\/\n\tchar *section_name;\n\tchar *symbol_name;\n\tchar *proto_name;\n\tRzListIter *iter;\n\n\tut64 current_offset;\n\tut64 current_size;\n\n\tint i = 0; \/\/ iter\n\n\t\/\/ 0. check if stripped (proto name is lost)\n\tif (proto->name_size == 0 || proto->proto_name == NULL) {\n\t\t\/\/ replace name with current offset\n\t\tproto_name = rz_str_newf(\"fcn.%08llx\", proto->offset);\n\t} else {\n\t\tproto_name = rz_str_new((char *)proto->proto_name);\n\t}\n\n\t\/\/ 1.1 set section name as function_name.header\n\tLuaLocalVarEntry *local_var_entry;\n\trz_list_foreach (proto->local_var_info_entries, iter, local_var_entry) {\n\t\tluac_add_string(\n\t\t\tinfo->string_list,\n\t\t\t(char *)local_var_entry->varname,\n\t\t\tlocal_var_entry->offset,\n\t\t\tlocal_var_entry->varname_len);\n\t}\n\n\t\/\/ 2.2 parse debug_upvalues\n\tchar **upvalue_names;\n\tint real_upvalue_cnt;\n\tLuaDbgUpvalueEntry *debug_upv_entry;\n\treal_upvalue_cnt = rz_list_length(proto->upvalue_entries);\n\tupvalue_names = RZ_NEWS0(char *, real_upvalue_cnt);\n\tif (!upvalue_names) {\n\t\treturn;\n\t}\n\trz_list_foreach (proto->dbg_upvalue_entries, iter, debug_upv_entry) {\n\t\tupvalue_names[i] = (char *)debug_upv_entry->upvalue_name;\n\t\tluac_add_string(\n\t\t\tinfo->string_list,\n\t\t\tupvalue_names[i],\n\t\t\tdebug_upv_entry->offset,\n\t\t\tdebug_upv_entry->name_len);\n\t}\n\n\t\/\/ 3.1 construct constant symbols\n\tLuaConstEntry *const_entry;\n\trz_list_foreach (proto->const_entries, iter, const_entry) {\n\t\tsymbol_name = get_constant_symbol_name(proto_name, const_entry);\n\t\tluac_add_symbol(\n\t\t\tinfo->symbol_list,\n\t\t\tsymbol_name,\n\t\t\tconst_entry->offset,\n\t\t\t\"UPVALUE\");\n\t\tRZ_FREE(symbol_name);\n\t}\n\n\t\/\/ 4. parse sub proto\n\tLuaProto *sub_proto;\n\trz_list_foreach (proto->proto_entries, iter, sub_proto) {\n\t\t_luac_build_info(sub_proto, info);\n\t}\n\n\tRZ_FREE(proto_name);\n}","target":1,"flaw_line_index":0,"hash":"339ecdb9-b69b-448f-a0f7-b24cbf5b059a","idx":"3a201e1c-0c25-47be-87e7-b38bbce965d2"}
{"func_before":"void _luac_build_info(LuaProto *proto, LuacBinInfo *info) {\n\t\/* process proto header info *\/\n\tchar *section_name;\n\tchar *symbol_name;\n\tchar *proto_name;\n\tchar **upvalue_names = NULL;\n\tRzListIter *iter;\n\tint i = 0; \/\/ iter\n\n\tut64 current_offset;\n\tut64 current_size;\n\n\t\/\/ 0. check if stripped (proto name is lost)\n\tif (proto->name_size == 0 || proto->proto_name == NULL) {\n\t\t\/\/ replace name with current offset\n\t\tproto_name = rz_str_newf(\"fcn.%08llx\", proto->offset);\n\t} else {\n\t\tproto_name = rz_str_new((char *)proto->proto_name);\n\t}\n\n\t\/\/ 1.1 set section name as function_name.header\n\tLuaLocalVarEntry *local_var_entry;\n\trz_list_foreach (proto->local_var_info_entries, iter, local_var_entry) {\n\t\tluac_add_string(\n\t\t\tinfo->string_list,\n\t\t\t(char *)local_var_entry->varname,\n\t\t\tlocal_var_entry->offset,\n\t\t\tlocal_var_entry->varname_len);\n\t}\n\n\t\/\/ 2.2 parse debug_upvalues\n\tsize_t real_upvalue_cnt = rz_list_length(proto->upvalue_entries);\n\tif (real_upvalue_cnt > 0) {\n\t\tLuaDbgUpvalueEntry *debug_upv_entry;\n\t\tupvalue_names = RZ_NEWS0(char *, real_upvalue_cnt);\n\t\tif (!upvalue_names) {\n\t\t\tfree(proto_name);\n\t\t\treturn;\n\t\t}\n\n\t\ti = 0;\n\t\trz_list_foreach (proto->dbg_upvalue_entries, iter, debug_upv_entry) {\n\t\t\tupvalue_names[i] = (char *)debug_upv_entry->upvalue_name;\n\t\t\tluac_add_string(\n\t\t\t\tinfo->string_list,\n\t\t\t\tupvalue_names[i],\n\t\t\t\tdebug_upv_entry->offset,\n\t\t\t\tdebug_upv_entry->name_len);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t\/\/ 3.1 construct constant symbols\n\tLuaConstEntry *const_entry;\n\trz_list_foreach (proto->const_entries, iter, const_entry) {\n\t\tsymbol_name = get_constant_symbol_name(proto_name, const_entry);\n\t\tluac_add_symbol(\n\t\t\tinfo->symbol_list,\n\t\t\tsymbol_name,\n\t\t\tconst_entry->offset,\n\t\t\t\"UPVALUE\");\n\t\tRZ_FREE(symbol_name);\n\t}\n\n\t\/\/ 4. parse sub proto\n\tLuaProto *sub_proto;\n\trz_list_foreach (proto->proto_entries, iter, sub_proto) {\n\t\t_luac_build_info(sub_proto, info);\n\t}\n\n\tfree(upvalue_names);\n\tfree(proto_name);\n}","target":0,"flaw_line_index":0,"hash":"3ed190ac-d201-4bbd-bc00-5a198d0bbf9e","idx":"a75a1779-c481-45eb-8393-d23a31730305"}
{"func_before":"static int verify_cb(int preverify_ok, X509_STORE_CTX *x509_ctx)\n{\n    pj_ssl_sock_t *ssock;\n    SSL *ossl_ssl;\n    int err;\n\n    \/* Get SSL instance *\/\n    ossl_ssl = X509_STORE_CTX_get_ex_data(x509_ctx, \n\t\t\t\t    SSL_get_ex_data_X509_STORE_CTX_idx());\n    pj_assert(ossl_ssl);\n\n    \/* Get SSL socket instance *\/\n    ssock = SSL_get_ex_data(ossl_ssl, sslsock_idx);\n    pj_assert(ssock);\n\n    \/* Store verification status *\/\n    err = X509_STORE_CTX_get_error(x509_ctx);\n    switch (err) {\n    case X509_V_OK:\n\tbreak;\n\n    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\n\tssock->verify_status |= PJ_SSL_CERT_EISSUER_NOT_FOUND;\n\tbreak;\n    default:\n\tssock->verify_status |= PJ_SSL_CERT_EUNKNOWN;\n\tbreak;\n    }\n\n    \/* When verification is not requested just return ok here, however\n     * application can still get the verification status.\n     *\/\n    if (PJ_FALSE == ssock->param.verify_peer)\n\tpreverify_ok = 1;\n\n    return preverify_ok;\n}","target":1,"flaw_line_index":0,"hash":"b3f384c2-63da-454d-8b6f-90cfa65da628","idx":"e0ef8bef-2ac7-442d-b71f-e32c3e2edb0e"}
{"func_before":"static int verify_cb(int preverify_ok, X509_STORE_CTX *x509_ctx)\n{\n    pj_ssl_sock_t *ssock = NULL;\n    SSL *ossl_ssl = NULL;\n    int err;\n\n    \/* Get SSL instance *\/\n    ossl_ssl = X509_STORE_CTX_get_ex_data(x509_ctx, \n\t\t\t\t    SSL_get_ex_data_X509_STORE_CTX_idx());\n    if (!ossl_ssl) {\n\tPJ_LOG(1,(THIS_FILE,\n\t\t  \"SSL verification callback failed to get SSL instance\"));\n\tgoto on_return;\n    }\n\n    \/* Get SSL socket instance *\/\n    ssock = SSL_get_ex_data(ossl_ssl, sslsock_idx);\n    if (!ssock) {\n\t\/* SSL socket may have been destroyed *\/\n\tPJ_LOG(1,(THIS_FILE,\n\t\t  \"SSL verification callback failed to get SSL socket \"\n\t\t  \"instance (sslsock_idx=%d).\", sslsock_idx));\n\tgoto on_return;\n    }\n\n    \/* Store verification status *\/\n    err = X509_STORE_CTX_get_error(x509_ctx);\n    switch (err) {\n    case X509_V_OK:\n\tbreak;\n\n    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\n\tssock->verify_status |= PJ_SSL_CERT_EISSUER_NOT_FOUND;\n\tbreak;\n\tssock->verify_status |= PJ_SSL_CERT_EUNKNOWN;\n\tbreak;\n    }\n\n    \/* When verification is not requested just return ok here, however\n     * application can still get the verification status.\n     *\/\n    if (PJ_FALSE == ssock->param.verify_peer)\n\tpreverify_ok = 1;\n\non_return:\n    return preverify_ok;\n}","target":0,"flaw_line_index":0,"hash":"1c0c4788-9ca3-4b3b-a10d-cddba153b8b4","idx":"4163f92f-a294-4828-9879-e98e20c446c0"}
{"func_before":"  do\n    rc = imap_cmd_step (idata);\n  while (rc == IMAP_CMD_CONTINUE);\n  \n  if (rc != IMAP_CMD_RESPOND)\n  {\n    dprint (1, (debugfile, \"Invalid response from server: %s\\n\", ibuf));\n    goto bail;\n  }\n\n  if ((len = mutt_from_base64 (obuf, idata->buf + 2)) == -1)\n  {\n    dprint (1, (debugfile, \"Error decoding base64 response.\\n\"));\n    goto bail;\n  }\n\n  obuf[len] = '\\0';\n  dprint (2, (debugfile, \"CRAM challenge: %s\\n\", obuf));\n\n  \/* The client makes note of the data and then responds with a string\n   * consisting of the user name, a space, and a 'digest'. The latter is","target":1,"flaw_line_index":0,"hash":"79ed4929-707a-42e1-a64d-a13158df638e","idx":"524027e9-f866-4069-b546-60351e75ada1"}
{"func_before":"  do\n    rc = imap_cmd_step (idata);\n  while (rc == IMAP_CMD_CONTINUE);\n  \n  if (rc != IMAP_CMD_RESPOND)\n  {\n    dprint (1, (debugfile, \"Invalid response from server: %s\\n\", ibuf));\n    goto bail;\n  }\n\n  if ((len = mutt_from_base64 (obuf, idata->buf + 2, sizeof(obuf) - 1)) == -1)\n  {\n    dprint (1, (debugfile, \"Error decoding base64 response.\\n\"));\n    goto bail;\n  }\n\n  obuf[len] = '\\0';\n  dprint (2, (debugfile, \"CRAM challenge: %s\\n\", obuf));\n\n  \/* The client makes note of the data and then responds with a string\n   * consisting of the user name, a space, and a 'digest'. The latter is","target":0,"flaw_line_index":0,"hash":"60e51ef9-91a8-46e6-afbe-20c689be3d4c","idx":"23a433fb-8c2f-43ee-b21e-3dbdb0e4b251"}
{"func_before":"        const NetplanState* np_state,\n        const NetplanNetDefinition* def,\n        const char *rootdir,\n        const char* path,\n        gboolean* has_been_written,\n        GError** error)\n{\n    g_autoptr(GString) network = NULL;\n    g_autoptr(GString) link = NULL;\n    GString* s = NULL;\n    mode_t orig_umask;\n\n    SET_OPT_OUT_PTR(has_been_written, FALSE);\n\n    if (def->type == NETPLAN_DEF_TYPE_VLAN && def->sriov_vlan_filter) {\n        g_debug(\"%s is defined as a hardware SR-IOV filtered VLAN, postponing creation\", def->id);\n        return TRUE;\n    }\n\n    \/* Prepare the [Link] section of the .network file. *\/\n    link = g_string_sized_new(200);\n\n    if (network->len > 0 || link->len > 0) {\n        s = g_string_sized_new(200);\n        append_match_section(def, s, TRUE);\n\n        if (link->len > 0)\n            g_string_append_printf(s, \"\\n[Link]\\n%s\", link->str);\n        if (network->len > 0)\n            g_string_append_printf(s, \"\\n[Network]\\n%s\", network->str);\n\n        \/* these do not contain secrets and need to be readable by\n         * systemd-networkd - LP: #1736965 *\/\n        orig_umask = umask(022);\n        _netplan_g_string_free_to_file(s, rootdir, path, \".network\");\n        umask(orig_umask);\n    }\n\n    SET_OPT_OUT_PTR(has_been_written, TRUE);\n    return TRUE;\n}","target":1,"flaw_line_index":0,"hash":"4774e963-1afc-43b8-a5b4-8f632f04924e","idx":"cc1ac14f-f612-42a4-9c90-3637bb213364"}
{"func_before":"_netplan_netdef_write_network_file(\n        const NetplanState* np_state,\n        const NetplanNetDefinition* def,\n        const char *rootdir,\n        const char* path,\n        gboolean* has_been_written,\n        GError** error)\n{\n    g_autoptr(GString) network = NULL;\n    g_autoptr(GString) link = NULL;\n    GString* s = NULL;\n\n    SET_OPT_OUT_PTR(has_been_written, FALSE);\n\n    if (def->type == NETPLAN_DEF_TYPE_VLAN && def->sriov_vlan_filter) {\n        g_debug(\"%s is defined as a hardware SR-IOV filtered VLAN, postponing creation\", def->id);\n        return TRUE;\n    }\n\n    \/* Prepare the [Link] section of the .network file. *\/\n    link = g_string_sized_new(200);\n\n    if (network->len > 0 || link->len > 0) {\n        s = g_string_sized_new(200);\n        append_match_section(def, s, TRUE);\n\n        if (link->len > 0)\n            g_string_append_printf(s, \"\\n[Link]\\n%s\", link->str);\n        if (network->len > 0)\n            g_string_append_printf(s, \"\\n[Network]\\n%s\", network->str);\n\n        _netplan_g_string_free_to_file_with_permissions(s, rootdir, path, \".network\", \"root\", NETWORKD_GROUP, 0640);\n    }\n\n    SET_OPT_OUT_PTR(has_been_written, TRUE);\n    return TRUE;\n}","target":0,"flaw_line_index":0,"hash":"6b3f68fc-6788-4344-ab5e-ad8cc4254676","idx":"aad7c164-cd32-4c55-800a-b3cc978c3117"}
{"func_before":"void ep2_mul_slide(ep2_t r, const ep2_t p, const bn_t k) {\n\tep2_t t[1 << (EP_WIDTH - 1)], q;\n\tint i, j, l;\n\tuint8_t win[RLC_FP_BITS + 1];\n\n\tep2_null(q);\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n\t\t\tep2_null(t[i]);\n\t\t\tep2_new(t[i]);\n\t\t}\n\n\t\tep2_new(q);\n\n\t\tep2_copy(t[0], p);\n\t\tep2_dbl(q, p);\n\n#if defined(EP_MIXED)\n\t\tep2_norm(q, q);\n#endif\n\n\t\t\/* Create table. *\/\n\t\tfor (i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep2_add(t[i], t[i - 1], q);\n\t\t}\n\n#if defined(EP_MIXED)\n\t\tep2_norm_sim(t + 1, t + 1, (1 << (EP_WIDTH - 1)) - 1);\n#endif\n\n\t\tep2_set_infty(q);\n\t\tl = RLC_FP_BITS + 1;\n\t\tbn_rec_slw(win, &l, k, EP_WIDTH);\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\tep2_dbl(q, q);\n\t\t\t} else {\n\t\t\t\tfor (j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\tep2_dbl(q, q);\n\t\t\t\t}\n\t\t\t\tep2_add(q, q, t[win[i] >> 1]);\n\t\t\t}\n\t\t}\n\n\t\tep2_norm(r, q);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep2_free(t[i]);\n\t\t}\n\t\tep2_free(q);\n\t}\n}","target":1,"flaw_line_index":0,"hash":"4f9c8bc2-c143-4634-9d5d-83f538951b7f","idx":"5ff81def-f1ee-4354-9cb7-f152cf9bdf6e"}
{"func_before":"void ep2_mul_slide(ep2_t r, const ep2_t p, const bn_t k) {\n\tep2_t t[1 << (EP_WIDTH - 1)], q;\n\tuint8_t win[RLC_FP_BITS + 1];\n\tsize_t l;\n\n\tep2_null(q);\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfor (int i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n\t\t\tep2_null(t[i]);\n\t\t\tep2_new(t[i]);\n\t\t}\n\n\t\tep2_new(q);\n\n\t\tep2_copy(t[0], p);\n\t\tep2_dbl(q, p);\n\n#if defined(EP_MIXED)\n\t\tep2_norm(q, q);\n#endif\n\n\t\t\/* Create table. *\/\n\t\tfor (size_t i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep2_add(t[i], t[i - 1], q);\n\t\t}\n\n#if defined(EP_MIXED)\n\t\tep2_norm_sim(t + 1, t + 1, (1 << (EP_WIDTH - 1)) - 1);\n#endif\n\n\t\tep2_set_infty(q);\n\t\tl = RLC_FP_BITS + 1;\n\t\tbn_rec_slw(win, &l, k, EP_WIDTH);\n\t\tfor (size_t i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\tep2_dbl(q, q);\n\t\t\t} else {\n\t\t\t\tfor (size_t j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\tep2_dbl(q, q);\n\t\t\t\t}\n\t\t\t\tep2_add(q, q, t[win[i] >> 1]);\n\t\t\t}\n\t\t}\n\n\t\tep2_norm(r, q);\n\t\tif (bn_sign(k) == RLC_NEG) {\n\t\t\tep2_neg(r, r);\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep2_free(t[i]);\n\t\t}\n\t\tep2_free(q);\n\t}\n}","target":0,"flaw_line_index":0,"hash":"f6ce841a-efe4-4cc0-9653-f80ba10ffa46","idx":"ca67c898-e6f2-4e02-8ac3-67f9a9e292bd"}
{"func_before":"\tstruct btd_adapter *adapter = client->adapter;\n\tstruct mgmt_cp_stop_discovery cp;\n\n\t\/* Check if there are more client discovering *\/\n\tif (g_slist_next(adapter->discovery_list)) {\n\t\tdiscovery_remove(client);\n\t\tupdate_discovery_filter(adapter);\n\t\treturn 0;\n\t}\n\n\tif (adapter->discovery_discoverable)\n\t\tset_discovery_discoverable(adapter, false);\n\n\t\/*\n\t * In the idle phase of a discovery, there is no need to stop it\n\t * and so it is enough to send out the signal and just return.\n\t *\/\n\tif (adapter->discovery_enable == 0x00) {\n\t\tdiscovery_remove(client);\n\t\tadapter->discovering = false;\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");","target":1,"flaw_line_index":0,"hash":"1f19884b-f68c-47d2-b190-9218aa809a2a","idx":"4bd13a9d-6b59-4234-8ef9-828e573c938f"}
{"func_before":"\tstruct btd_adapter *adapter = client->adapter;\n\tstruct mgmt_cp_stop_discovery cp;\n\n\t\/* Check if there are more client discovering *\/\n\tif (g_slist_next(adapter->discovery_list)) {\n\t\tdiscovery_remove(client);\n\t\tupdate_discovery_filter(adapter);\n\t\treturn 0;\n\t}\n\n\tset_discovery_discoverable(adapter, false);\n\n\t\/*\n\t * In the idle phase of a discovery, there is no need to stop it\n\t * and so it is enough to send out the signal and just return.\n\t *\/\n\tif (adapter->discovery_enable == 0x00) {\n\t\tdiscovery_remove(client);\n\t\tadapter->discovering = false;\n\t\tg_dbus_emit_property_changed(dbus_conn, adapter->path,\n\t\t\t\t\tADAPTER_INTERFACE, \"Discovering\");","target":0,"flaw_line_index":0,"hash":"606b1618-996b-4b71-a933-e157ac59188b","idx":"305e7c2c-05ed-45a7-8392-c68908f76282"}
{"func_before":"epilogProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  parser->m_processor = epilogProcessor;\n  parser->m_eventPtr = s;\n  for (;;) {\n    const char *next = NULL;\n    int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    parser->m_eventEndPtr = next;\n    switch (tok) {\n    \/* report partial linebreak - it might be the last token *\/\n    case -XML_TOK_PROLOG_S:","target":1,"flaw_line_index":0,"hash":"34d03bb2-75ee-4e78-9b47-f38cbf0ba787","idx":"701219c6-f1bb-45ea-be07-fc5751199a45"}
{"func_before":"epilogProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  parser->m_processor = epilogProcessor;\n  parser->m_eventPtr = s;\n  for (;;) {\n    const char *next = NULL;\n    int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n#if defined(XML_DTD) || XML_GE == 1\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    parser->m_eventEndPtr = next;\n    switch (tok) {\n    \/* report partial linebreak - it might be the last token *\/\n    case -XML_TOK_PROLOG_S:","target":0,"flaw_line_index":0,"hash":"6d6021fc-541f-45b2-9a46-1f63fe5e2dda","idx":"a3e70485-d13e-47c9-b58f-cbd257ceb45e"}
{"func_before":"void rose_start_heartbeat(struct sock *sk)\n{\n\tdel_timer(&sk->sk_timer);\n\n\tsk->sk_timer.function = rose_heartbeat_expiry;\n\tsk->sk_timer.expires  = jiffies + 5 * HZ;\n\n\tadd_timer(&sk->sk_timer);\n}","target":1,"flaw_line_index":0,"hash":"8ed0668e-6a10-4651-b458-ade77c64afd9","idx":"bee879a2-5b7d-4095-a28f-35ba8dcf39a6"}
{"func_before":"void rose_start_heartbeat(struct sock *sk)\n{\n\tsk_stop_timer(sk, &sk->sk_timer);\n\n\tsk->sk_timer.function = rose_heartbeat_expiry;\n\tsk->sk_timer.expires  = jiffies + 5 * HZ;\n\n\tsk_reset_timer(sk, &sk->sk_timer, sk->sk_timer.expires);\n}","target":0,"flaw_line_index":0,"hash":"faa43e4a-d978-4424-8d62-719d11355148","idx":"fda71958-f982-4ece-a905-7c0c0565fc89"}
{"func_before":"bool ExtractSymlink(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName)\n{\n#if defined(SAVE_LINKS) && defined(_UNIX)\n  \/\/ For RAR 3.x archives we process links even in test mode to skip link data.\n  if (Arc.Format==RARFMT15)\n    return ExtractUnixLink30(Cmd,DataIO,Arc,LinkName);\n  if (Arc.Format==RARFMT50)\n    return ExtractUnixLink50(Cmd,LinkName,&Arc.FileHead);\n#elif defined _WIN_ALL\n  \/\/ RAR 5.0 archives store link information in file header, so there is\n  \/\/ no need to additionally test it if we do not create a file.\n  if (Arc.Format==RARFMT50)\n    return CreateReparsePoint(Cmd,LinkName,&Arc.FileHead);\n#endif\n  return false;\n}","target":1,"flaw_line_index":0,"hash":"d0305529-0dac-47ee-82b0-a2e4fa6d5c81","idx":"25072818-be36-419b-a4cf-be64cb81d6c6"}
{"func_before":"bool ExtractSymlink(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName,bool &UpLink)\n{\n  \/\/ Returning true in Uplink indicates that link target might include \"..\"\n  \/\/ and enables additional checks. It is ok to falsely return true here,\n  \/\/ as it implies only the minor performance penalty. But we shall always\n  \/\/ return true for links with \"..\" in target for security reason.\n\n  UpLink=true; \/\/ Assume the target might include potentially unsafe \"..\".\n#if defined(SAVE_LINKS) && defined(_UNIX) || defined(_WIN_ALL)\n  if (Arc.Format==RARFMT50) \/\/ For RAR5 archives we can check RedirName for both Unix and Windows.\n    UpLink=wcsstr(Arc.FileHead.RedirName,L\"..\")!=NULL;\n#endif\n\n#if defined(SAVE_LINKS) && defined(_UNIX)\n  \/\/ For RAR 3.x archives we process links even in test mode to skip link data.\n  if (Arc.Format==RARFMT15)\n    return ExtractUnixLink30(Cmd,DataIO,Arc,LinkName,UpLink);\n  if (Arc.Format==RARFMT50)\n    return ExtractUnixLink50(Cmd,LinkName,&Arc.FileHead);\n#elif defined(_WIN_ALL)\n  \/\/ RAR 5.0 archives store link information in file header, so there is\n  \/\/ no need to additionally test it if we do not create a file.\n  if (Arc.Format==RARFMT50)\n    return CreateReparsePoint(Cmd,LinkName,&Arc.FileHead);\n#endif\n  return false;\n}","target":0,"flaw_line_index":0,"hash":"78d94305-a8c8-491f-9405-3b620c171e48","idx":"ca2ba2e6-e3b9-4311-a79d-031af00b5d0e"}
{"func_before":"int bson_check_field_name( bson *b, const char *string,\n                           const int length ) {\n\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 1, 1 );\n}","target":1,"flaw_line_index":0,"hash":"bd1f9147-4c3f-4b5f-88e7-2c576e438b6c","idx":"176cba95-f8c0-4f58-ba22-9958f6cdd182"}
{"func_before":"int bson_check_field_name( bson *b, const char *string,\n                           const size_t length ) {\n\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 1, 1 );\n}","target":0,"flaw_line_index":0,"hash":"27f88efd-f173-4f5b-85f3-61fdcf19c126","idx":"4b4c61db-c765-4ee7-95ea-fe01406f69d2"}
{"func_before":"\tif (newsk == NULL)\n\t\tgoto exit_nonewsk;\n\n\tsk_setup_caps(newsk, dst);\n\n\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n\tnewinet->inet_daddr\t= ireq->rmt_addr;\n\tnewinet->inet_rcv_saddr = ireq->loc_addr;\n\tnewinet->inet_saddr\t= ireq->loc_addr;\n\tnewinet->opt\t   = ireq->opt;\n\tireq->opt\t   = NULL;\n\tnewinet->mc_index  = inet_iif(skb);\n\tnewinet->mc_ttl\t   = ip_hdr(skb)->ttl;\n\tnewinet->inet_id   = jiffies;\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;","target":1,"flaw_line_index":0,"hash":"7c3845f3-21f2-4791-827f-cbc2c04a085f","idx":"26925980-903c-44cf-8f8b-2938afe38c6d"}
{"func_before":"\tif (newsk == NULL)\n\t\tgoto exit_nonewsk;\n\n\tsk_setup_caps(newsk, dst);\n\n\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n\tnewinet->inet_daddr\t= ireq->rmt_addr;\n\tnewinet->inet_rcv_saddr = ireq->loc_addr;\n\tnewinet->inet_saddr\t= ireq->loc_addr;\n\tnewinet->inet_opt\t= ireq->opt;\n\tireq->opt\t   = NULL;\n\tnewinet->mc_index  = inet_iif(skb);\n\tnewinet->mc_ttl\t   = ip_hdr(skb)->ttl;\n\tnewinet->inet_id   = jiffies;\n\n\tdccp_sync_mss(newsk, dst_mtu(dst));\n\n\tif (__inet_inherit_port(sk, newsk) < 0) {\n\t\tsock_put(newsk);\n\t\tgoto exit;","target":0,"flaw_line_index":0,"hash":"4a789893-46c3-49d6-9f35-02f93e69d414","idx":"52f7f320-b680-41fd-aef7-309a54d76428"}
{"func_before":"\t}\n#endif\n\n\tif (dump_cart) dump_isom_cover_art(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n\tif (dump_chap) dump_isom_chapters(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_chap);\n\tif (dump_udta_type) dump_isom_udta(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_udta_type, dump_udta_track);\n\n\tif (dump_iod) {\n\t\tGF_InitialObjectDescriptor *iod = (GF_InitialObjectDescriptor *)gf_isom_get_root_od(file);\n\t\tif (!iod) {\n\t\t\tfprintf(stderr, \"File %s has no IOD\", inName);\n\t\t} else {\n\t\t\tchar szName[GF_MAX_PATH+10];\n\t\t\tFILE *iodf;\n\t\t\tsprintf(szName, \"%s.iod\", outfile);\n\t\t\tiodf = gf_fopen(szName, \"wb\");\n\t\t\tif (!iodf) {\n\t\t\t\tfprintf(stderr, \"Cannot open destination %s\\n\", szName);\n\t\t\t} else {\n\t\t\t\tu8 *desc;\n\t\t\t\tu32 size;","target":1,"flaw_line_index":0,"hash":"50c84dc1-1f29-4574-a5f5-53d7bce9adbf","idx":"6f1e14b6-8c83-4c3c-8cdb-b71604416bd3"}
{"func_before":"\t}\n#endif\n\n\tif (dump_cart) dump_isom_cover_art(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE);\n\tif (dump_chap) dump_isom_chapters(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_chap);\n\tif (dump_udta_type) dump_isom_udta(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_udta_type, dump_udta_track);\n\n\tif (dump_iod) {\n\t\tGF_InitialObjectDescriptor *iod = (GF_InitialObjectDescriptor *)gf_isom_get_root_od(file);\n\t\tif (!iod) {\n\t\t\tfprintf(stderr, \"File %s has no IOD\\n\", inName);\n\t\t} else {\n\t\t\tchar szName[GF_MAX_PATH+10];\n\t\t\tFILE *iodf;\n\t\t\tsprintf(szName, \"%s.iod\", outfile);\n\t\t\tiodf = gf_fopen(szName, \"wb\");\n\t\t\tif (!iodf) {\n\t\t\t\tfprintf(stderr, \"Cannot open destination %s\\n\", szName);\n\t\t\t} else {\n\t\t\t\tu8 *desc;\n\t\t\t\tu32 size;","target":0,"flaw_line_index":0,"hash":"88e12ac1-b248-4570-b058-c67d70e588fe","idx":"902a29cf-6fe5-48fa-87d2-e4afed7f5b4f"}
{"func_before":"void bn_srt(bn_t c, bn_t a) {\n\tbn_t h, l, m, t;\n\tint bits, cmp;\n\n\tif (bn_sign(a) == RLC_NEG) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t}\n\n\tbits = bn_bits(a);\n\tbits += (bits % 2);\n\n\tbn_null(h);\n\tbn_null(l);\n\tbn_null(m);\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(h);\n\t\tbn_new(l);\n\t\tbn_new(m);\n\t\tbn_new(t);\n\n\t\tbn_set_2b(h, bits >> 1);\n\t\tbn_set_2b(l, (bits >> 1) - 1);\n\n\t\t\/* Trivial binary search approach. *\/\n\t\tdo {\n\t\t\tbn_add(m, h, l);\n\t\t\tbn_hlv(m, m);\n\t\t\tbn_sqr(t, m);\n\t\t\tcmp = bn_cmp(t, a);\n\t\t\tbn_sub(t, h, l);\n\n\t\t\tif (cmp == RLC_GT) {","target":1,"flaw_line_index":0,"hash":"a43ed1c0-5500-49a1-a8cd-dc18cb4e83a8","idx":"78a181c9-fa7a-436c-bcc9-eec6ac4bceb5"}
{"func_before":"void bn_srt(bn_t c, bn_t a) {\n\tbn_t h, l, m, t;\n\tsize_t bits;\n\tint cmp;\n\n\tif (bn_sign(a) == RLC_NEG) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t}\n\n\tbits = bn_bits(a);\n\tbits += (bits % 2);\n\n\tbn_null(h);\n\tbn_null(l);\n\tbn_null(m);\n\tbn_null(t);\n\n\tRLC_TRY {\n\t\tbn_new(h);\n\t\tbn_new(l);\n\t\tbn_new(m);\n\t\tbn_new(t);\n\n\t\tbn_zero(l);\n\t\tbn_set_2b(h, bits >> 1);\n\t\tif (bits >= 2) {\n\t\t\tbn_set_2b(l, (bits >> 1) - 1);\n\t\t}\n\n\t\t\/* Trivial binary search approach. *\/\n\t\tdo {\n\t\t\tbn_add(m, h, l);\n\t\t\tbn_hlv(m, m);\n\t\t\tbn_sqr(t, m);\n\t\t\tcmp = bn_cmp(t, a);\n\t\t\tbn_sub(t, h, l);\n\n\t\t\tif (cmp == RLC_GT) {","target":0,"flaw_line_index":0,"hash":"b0c2dc76-3be7-40ac-991d-dc382caff168","idx":"f44b5315-0dc5-442c-a10e-ecde9828fdb1"}
{"func_before":"\tset_intr_gate(X86_TRAP_UD, invalid_op);\n\tset_intr_gate(X86_TRAP_NM, device_not_available);\n#ifdef CONFIG_X86_32\n\tset_task_gate(X86_TRAP_DF, GDT_ENTRY_DOUBLEFAULT_TSS);\n#else\n\tset_intr_gate_ist(X86_TRAP_DF, &double_fault, DOUBLEFAULT_STACK);\n#endif\n\tset_intr_gate(X86_TRAP_OLD_MF, coprocessor_segment_overrun);\n\tset_intr_gate(X86_TRAP_TS, invalid_TSS);\n\tset_intr_gate(X86_TRAP_NP, segment_not_present);\n\tset_intr_gate_ist(X86_TRAP_SS, &stack_segment, STACKFAULT_STACK);\n\tset_intr_gate(X86_TRAP_GP, general_protection);\n\tset_intr_gate(X86_TRAP_SPURIOUS, spurious_interrupt_bug);\n\tset_intr_gate(X86_TRAP_MF, coprocessor_error);\n\tset_intr_gate(X86_TRAP_AC, alignment_check);\n#ifdef CONFIG_X86_MCE\n\tset_intr_gate_ist(X86_TRAP_MC, &machine_check, MCE_STACK);\n#endif\n\tset_intr_gate(X86_TRAP_XF, simd_coprocessor_error);\n\n\t\/* Reserve all the builtin and the syscall vector: *\/","target":1,"flaw_line_index":0,"hash":"a19b040c-d5f9-4ace-b5e7-aab325ac1d53","idx":"42132514-f840-482e-b89e-29b1ed02e331"}
{"func_before":"\tset_intr_gate(X86_TRAP_UD, invalid_op);\n\tset_intr_gate(X86_TRAP_NM, device_not_available);\n#ifdef CONFIG_X86_32\n\tset_task_gate(X86_TRAP_DF, GDT_ENTRY_DOUBLEFAULT_TSS);\n#else\n\tset_intr_gate_ist(X86_TRAP_DF, &double_fault, DOUBLEFAULT_STACK);\n#endif\n\tset_intr_gate(X86_TRAP_OLD_MF, coprocessor_segment_overrun);\n\tset_intr_gate(X86_TRAP_TS, invalid_TSS);\n\tset_intr_gate(X86_TRAP_NP, segment_not_present);\n\tset_intr_gate(X86_TRAP_SS, stack_segment);\n\tset_intr_gate(X86_TRAP_GP, general_protection);\n\tset_intr_gate(X86_TRAP_SPURIOUS, spurious_interrupt_bug);\n\tset_intr_gate(X86_TRAP_MF, coprocessor_error);\n\tset_intr_gate(X86_TRAP_AC, alignment_check);\n#ifdef CONFIG_X86_MCE\n\tset_intr_gate_ist(X86_TRAP_MC, &machine_check, MCE_STACK);\n#endif\n\tset_intr_gate(X86_TRAP_XF, simd_coprocessor_error);\n\n\t\/* Reserve all the builtin and the syscall vector: *\/","target":0,"flaw_line_index":0,"hash":"4b1c2559-cea3-459a-9481-747278c15fab","idx":"5b09bd3f-6086-4d58-aece-b8c49730f123"}
{"func_before":"\t\tgoto fail;\n\t}\n\n\tStream_Seek_UINT8(s);                      \/* reserved1 (1 byte) *\/\n\tStream_Seek_UINT8(s);                      \/* reserved2 (1 byte) *\/\n\tStream_Read_UINT8(s, bitmapData->codecID); \/* codecID (1 byte) *\/\n\tStream_Read_UINT16(s, bitmapData->width);  \/* width (2 bytes) *\/\n\tStream_Read_UINT16(s, bitmapData->height); \/* height (2 bytes) *\/\n\tStream_Read_UINT32(s, new_len);            \/* length (4 bytes) *\/\n\n\tif (Stream_GetRemainingLength(s) < new_len)\n\t\tgoto fail;\n\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\n\tif (!new_data)\n\t\tgoto fail;\n\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);","target":1,"flaw_line_index":0,"hash":"2d1a50f8-525b-485f-94e1-c0614a5722a0","idx":"3e00bcad-6325-41c5-8c4e-25bb91be2791"}
{"func_before":"\t\tgoto fail;\n\t}\n\n\tStream_Seek_UINT8(s);                      \/* reserved1 (1 byte) *\/\n\tStream_Seek_UINT8(s);                      \/* reserved2 (1 byte) *\/\n\tStream_Read_UINT8(s, bitmapData->codecID); \/* codecID (1 byte) *\/\n\tStream_Read_UINT16(s, bitmapData->width);  \/* width (2 bytes) *\/\n\tStream_Read_UINT16(s, bitmapData->height); \/* height (2 bytes) *\/\n\tStream_Read_UINT32(s, new_len);            \/* length (4 bytes) *\/\n\n\tif ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len))\n\t\tgoto fail;\n\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\n\tif (!new_data)\n\t\tgoto fail;\n\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);","target":0,"flaw_line_index":0,"hash":"ea6e074d-9114-4cce-aebd-2e13c5afc8e8","idx":"cb975d22-65cf-4696-8ce1-635bc0e50aa8"}
{"func_before":"  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  \/\/ x: op_info.inputs(0)\n  \/\/ y: op_info.inputs(1)\n  \/\/ y_grad: op_info.inputs(2)\n  if (op_info.inputs_size() < 3) {\n    return errors::InvalidArgument(\"MaxPoolGrad op has invalid inputs: \",\n                                   op_info.ShortDebugString());\n  }\n\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n\n  int64_t ops = 0;\n  if (dims.kx == 1 && dims.ky == 1) {\n    \/\/ 1x1 window. No need to know which input was max.\n    ops = dims.batch * dims.ix * dims.iy * dims.iz;\n  } else if (dims.kx <= dims.sx && dims.ky <= dims.sy) {\n    \/\/ Non-overlapping window: re-run maxpool, then assign zero or y_grad.\n    ops = dims.batch * dims.iz *\n          (dims.ox * dims.oy * (dims.kx * dims.ky - 1) + dims.ix * dims.iy);\n  } else {","target":1,"flaw_line_index":0,"hash":"5f419921-0498-4622-95ac-4e5436300ce4","idx":"fe7aa495-a827-4e5c-8d24-6622823705f7"}
{"func_before":"  bool found_unknown_shapes = false;\n  const auto& op_info = op_context.op_info;\n  \/\/ x: op_info.inputs(0)\n  \/\/ y: op_info.inputs(1)\n  \/\/ y_grad: op_info.inputs(2)\n  if (op_info.inputs_size() < 3) {\n    return errors::InvalidArgument(\"MaxPoolGrad op has invalid inputs: \",\n                                   op_info.ShortDebugString());\n  }\n\n  TF_ASSIGN_OR_RETURN(ConvolutionDimensions dims,\n                      OpDimensionsFromInputs(op_info.inputs(0).shape(), op_info,\n                                             &found_unknown_shapes));\n\n  int64_t ops = 0;\n  if (dims.kx == 1 && dims.ky == 1) {\n    \/\/ 1x1 window. No need to know which input was max.\n    ops = dims.batch * dims.ix * dims.iy * dims.iz;\n  } else if (dims.kx <= dims.sx && dims.ky <= dims.sy) {\n    \/\/ Non-overlapping window: re-run maxpool, then assign zero or y_grad.\n    ops = dims.batch * dims.iz *\n          (dims.ox * dims.oy * (dims.kx * dims.ky - 1) + dims.ix * dims.iy);\n  } else {","target":0,"flaw_line_index":0,"hash":"3febd209-225b-458d-bcaf-77049e2c9898","idx":"49adeed0-5328-4d47-9076-d154dc427309"}
{"func_before":"static int udf_load_logicalvol(struct super_block *sb, sector_t block,\n\t\t\t       struct kernel_lb_addr *fileset)\n{\n\tstruct logicalVolDesc *lvd;\n\tint i, j, offset;\n\tuint8_t type;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct genericPartitionMap *gpm;\n\tuint16_t ident;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn 1;\n\tBUG_ON(ident != TAG_IDENT_LVD);\n\tlvd = (struct logicalVolDesc *)bh->b_data;\n\n\tret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));\n\tif (ret)\n\t\tgoto out_bh;\n\n\tfor (i = 0, offset = 0;\n\t     i < sbi->s_partitions && offset < le32_to_cpu(lvd->mapTableLength);\n\t     i++, offset += gpm->partitionMapLength) {\n\t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n\t\tgpm = (struct genericPartitionMap *)\n\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\ttype = gpm->partitionMapType;\n\t\tif (type == 1) {\n\t\t\tstruct genericPartitionMap1 *gpm1 =\n\t\t\t\t(struct genericPartitionMap1 *)gpm;\n\t\t\tmap->s_partition_type = UDF_TYPE1_MAP15;\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(gpm1->volSeqNum);","target":1,"flaw_line_index":0,"hash":"2858cf56-707c-4774-8cc9-f1becd443274","idx":"acafe1bf-6b40-4079-957b-b240ebc41d68"}
{"func_before":"static int udf_load_logicalvol(struct super_block *sb, sector_t block,\n\t\t\t       struct kernel_lb_addr *fileset)\n{\n\tstruct logicalVolDesc *lvd;\n\tint i, j, offset;\n\tuint8_t type;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct genericPartitionMap *gpm;\n\tuint16_t ident;\n\tstruct buffer_head *bh;\n\tunsigned int table_len;\n\tint ret = 0;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn 1;\n\tBUG_ON(ident != TAG_IDENT_LVD);\n\tlvd = (struct logicalVolDesc *)bh->b_data;\n\ttable_len = le32_to_cpu(lvd->mapTableLength);\n\tif (sizeof(*lvd) + table_len > sb->s_blocksize) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Partition table too long (%u > %lu)\\n\", table_len,\n\t\t\tsb->s_blocksize - sizeof(*lvd));\n\t\tgoto out_bh;\n\t}\n\n\tret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));\n\tif (ret)\n\t\tgoto out_bh;\n\n\tfor (i = 0, offset = 0;\n\t     i < sbi->s_partitions && offset < table_len;\n\t     i++, offset += gpm->partitionMapLength) {\n\t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n\t\tgpm = (struct genericPartitionMap *)\n\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\ttype = gpm->partitionMapType;\n\t\tif (type == 1) {\n\t\t\tstruct genericPartitionMap1 *gpm1 =\n\t\t\t\t(struct genericPartitionMap1 *)gpm;\n\t\t\tmap->s_partition_type = UDF_TYPE1_MAP15;\n\t\t\tmap->s_volumeseqnum = le16_to_cpu(gpm1->volSeqNum);","target":0,"flaw_line_index":0,"hash":"6759974e-53b5-49d4-8297-6dfc2036bbed","idx":"35d84c3d-e180-4ed0-80af-9c6dbab8ddc7"}
{"func_before":"START_TEST (test_send_sonmp)\n{\n\tint n;\n\t\/* Packet we should build:\nIEEE 802.3 Ethernet \n    Destination: Bay-Networks-(Synoptics)-autodiscovery (01:00:81:00:01:00)\n    Source: 5e:10:8e:e7:84:ad (5e:10:8e:e7:84:ad)\n    Length: 22\nLogical-Link Control\n    DSAP: SNAP (0xaa)\n    IG Bit: Individual\n    SSAP: SNAP (0xaa)\n    CR Bit: Command\n    Control field: U, func=UI (0x03)\n        000. 00.. = Command: Unnumbered Information (0x00)\n        .... ..11 = Frame type: Unnumbered frame (0x03)\n    Organization Code: Nortel Networks SONMP (0x000081)\n    PID: SONMP segment hello (0x01a2)\n    NMM IP address: 172.17.142.37 (172.17.142.37)\n    Segment Identifier: 0x000004\n    Chassis type: Unknown (1)\n    Backplane type: ethernet, fast ethernet and gigabit ethernet (12)\n    NMM state: New (3)\n    Number of links: 1\n\nIEEE 802.3 Ethernet \n    Destination: Bay-Networks-(Synoptics)-autodiscovery (01:00:81:00:01:01)\n    Source: 5e:10:8e:e7:84:ad (5e:10:8e:e7:84:ad)\n    Length: 22\nLogical-Link Control\n    DSAP: SNAP (0xaa)\n    IG Bit: Individual\n    SSAP: SNAP (0xaa)\n    CR Bit: Command\n    Control field: U, func=UI (0x03)\n        000. 00.. = Command: Unnumbered Information (0x00)\n        .... ..11 = Frame type: Unnumbered frame (0x03)\n    Organization Code: Nortel Networks SONMP (0x000081)\n    PID: SONMP flatnet hello (0x01a1)\nNortel Networks \/ SynOptics Network Management Protocol\n    NMM IP address: 172.17.142.37 (172.17.142.37)\n    Segment Identifier: 0x000004\n    Chassis type: Unknown (1)\n    Backplane type: ethernet, fast ethernet and gigabit ethernet (12)\n    NMM state: New (3)\n    Number of links: 1\n\t*\/\n\tchar pkt1[] = {\n\t\t0x01, 0x00, 0x81, 0x00, 0x01, 0x00, 0x5e, 0x10,\n\t\t0x8e, 0xe7, 0x84, 0xad, 0x00, 0x16, 0xaa, 0xaa,\n\t\t0x03, 0x00, 0x00, 0x81, 0x01, 0xa2, 0xac, 0x11,\n\t\t0x8e, 0x25, 0x00, 0x00, 0x04, 0x01, 0x0c, 0x03,\n\t\t0x01 };\n\tchar pkt2[] = {\n\t\t0x01, 0x00, 0x81, 0x00, 0x01, 0x01, 0x5e, 0x10,\n\t\t0x8e, 0xe7, 0x84, 0xad, 0x00, 0x16, 0xaa, 0xaa,\n\t\t0x03, 0x00, 0x00, 0x81, 0x01, 0xa1, 0xac, 0x11,\n\t\t0x8e, 0x25, 0x00, 0x00, 0x04, 0x01, 0x0c, 0x03,\n\t\t0x01 };\n\tstruct packet *pkt;\n\tin_addr_t addr;\t\n\tstruct lldpd_mgmt *mgmt;\n\n\t\/* Populate port and chassis *\/\n\thardware.h_lport.p_id_subtype = LLDP_PORTID_SUBTYPE_IFNAME;\n\thardware.h_lport.p_id = \"Not used\";\n\thardware.h_lport.p_id_len = strlen(hardware.h_lport.p_id);\n\tchassis.c_id_subtype = LLDP_CHASSISID_SUBTYPE_LLADDR;\n\tchassis.c_id = macaddress;\n\tchassis.c_id_len = ETHER_ADDR_LEN;\n\tTAILQ_INIT(&chassis.c_mgmt);\n\taddr = inet_addr(\"172.17.142.37\");\n\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, \n\t\t\t\t&addr, sizeof(in_addr_t), 0);\n\tif (mgmt == NULL)\n\t\tck_abort();\n\tTAILQ_INSERT_TAIL(&chassis.c_mgmt, mgmt, m_entries);\n\n\t\/* Build packet *\/\n\tn = sonmp_send(NULL, &hardware);\n\tif (n != 0) {\n\t\tfail(\"unable to build packet\");\n\t\treturn;","target":1,"flaw_line_index":0,"hash":"c29e88d7-c546-4ab7-ade4-9f67bfe93632","idx":"7612b373-66fb-4bc1-961a-ecab770c3a36"}
{"func_before":"START_TEST (test_send_sonmp)\n{\n\tint n;\n\t\/* Packet we should build:\nIEEE 802.3 Ethernet \n    Destination: Bay-Networks-(Synoptics)-autodiscovery (01:00:81:00:01:00)\n    Source: 5e:10:8e:e7:84:ad (5e:10:8e:e7:84:ad)\n    Length: 19\nLogical-Link Control\n    DSAP: SNAP (0xaa)\n    IG Bit: Individual\n    SSAP: SNAP (0xaa)\n    CR Bit: Command\n    Control field: U, func=UI (0x03)\n        000. 00.. = Command: Unnumbered Information (0x00)\n        .... ..11 = Frame type: Unnumbered frame (0x03)\n    Organization Code: Nortel Networks SONMP (0x000081)\n    PID: SONMP segment hello (0x01a2)\n    NMM IP address: 172.17.142.37 (172.17.142.37)\n    Segment Identifier: 0x000004\n    Chassis type: Unknown (1)\n    Backplane type: ethernet, fast ethernet and gigabit ethernet (12)\n    NMM state: New (3)\n    Number of links: 1\n\nIEEE 802.3 Ethernet \n    Destination: Bay-Networks-(Synoptics)-autodiscovery (01:00:81:00:01:01)\n    Source: 5e:10:8e:e7:84:ad (5e:10:8e:e7:84:ad)\n    Length: 19\nLogical-Link Control\n    DSAP: SNAP (0xaa)\n    IG Bit: Individual\n    SSAP: SNAP (0xaa)\n    CR Bit: Command\n    Control field: U, func=UI (0x03)\n        000. 00.. = Command: Unnumbered Information (0x00)\n        .... ..11 = Frame type: Unnumbered frame (0x03)\n    Organization Code: Nortel Networks SONMP (0x000081)\n    PID: SONMP flatnet hello (0x01a1)\nNortel Networks \/ SynOptics Network Management Protocol\n    NMM IP address: 172.17.142.37 (172.17.142.37)\n    Segment Identifier: 0x000004\n    Chassis type: Unknown (1)\n    Backplane type: ethernet, fast ethernet and gigabit ethernet (12)\n    NMM state: New (3)\n    Number of links: 1\n\t*\/\n\tchar pkt1[] = {\n\t\t0x01, 0x00, 0x81, 0x00, 0x01, 0x00, 0x5e, 0x10,\n\t\t0x8e, 0xe7, 0x84, 0xad, 0x00, 0x13, 0xaa, 0xaa,\n\t\t0x03, 0x00, 0x00, 0x81, 0x01, 0xa2, 0xac, 0x11,\n\t\t0x8e, 0x25, 0x00, 0x00, 0x04, 0x01, 0x0c, 0x03,\n\t\t0x01 };\n\tchar pkt2[] = {\n\t\t0x01, 0x00, 0x81, 0x00, 0x01, 0x01, 0x5e, 0x10,\n\t\t0x8e, 0xe7, 0x84, 0xad, 0x00, 0x13, 0xaa, 0xaa,\n\t\t0x03, 0x00, 0x00, 0x81, 0x01, 0xa1, 0xac, 0x11,\n\t\t0x8e, 0x25, 0x00, 0x00, 0x04, 0x01, 0x0c, 0x03,\n\t\t0x01 };\n\tstruct packet *pkt;\n\tin_addr_t addr;\t\n\tstruct lldpd_mgmt *mgmt;\n\n\t\/* Populate port and chassis *\/\n\thardware.h_lport.p_id_subtype = LLDP_PORTID_SUBTYPE_IFNAME;\n\thardware.h_lport.p_id = \"Not used\";\n\thardware.h_lport.p_id_len = strlen(hardware.h_lport.p_id);\n\tchassis.c_id_subtype = LLDP_CHASSISID_SUBTYPE_LLADDR;\n\tchassis.c_id = macaddress;\n\tchassis.c_id_len = ETHER_ADDR_LEN;\n\tTAILQ_INIT(&chassis.c_mgmt);\n\taddr = inet_addr(\"172.17.142.37\");\n\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4,\n\t\t\t\t&addr, sizeof(in_addr_t), 0);\n\tif (mgmt == NULL)\n\t\tck_abort();\n\tTAILQ_INSERT_TAIL(&chassis.c_mgmt, mgmt, m_entries);\n\n\t\/* Build packet *\/\n\tn = sonmp_send(NULL, &hardware);\n\tif (n != 0) {\n\t\tfail(\"unable to build packet\");\n\t\treturn;","target":0,"flaw_line_index":0,"hash":"db0f6811-48a8-40fd-845b-3b3826feedae","idx":"1c9ece44-167f-4a32-8c77-556308a181fa"}
{"func_before":"static int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct skcipher_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(private));\n\n\tINIT_LIST_HEAD(&ctx->tsgl);\n\tctx->len = len;\n\tctx->used = 0;\n\tctx->more = 0;\n\tctx->merge = 0;\n\tctx->enc = 0;\n\tatomic_set(&ctx->inflight, 0);\n\taf_alg_init_completion(&ctx->completion);\n\n\task->private = ctx;\n\n\tskcipher_request_set_tfm(&ctx->req, private);\n\tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      af_alg_complete, &ctx->completion);\n\n\tsk->sk_destruct = skcipher_sock_destruct;\n\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"eee9cb2c-143c-48ef-93e6-7c5fb0dc9b7a","idx":"7df9239b-6bd2-4bb8-ac94-1db90f9653ca"}
{"func_before":"static int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct skcipher_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_tfm *tfm = private;\n\tstruct crypto_skcipher *skcipher = tfm->skcipher;\n\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);\n\n\tif (!tfm->has_key)\n\t\treturn -ENOKEY;\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));\n\n\tINIT_LIST_HEAD(&ctx->tsgl);\n\tctx->len = len;\n\tctx->used = 0;\n\tctx->more = 0;\n\tctx->merge = 0;\n\tctx->enc = 0;\n\tatomic_set(&ctx->inflight, 0);\n\taf_alg_init_completion(&ctx->completion);\n\n\task->private = ctx;\n\n\tskcipher_request_set_tfm(&ctx->req, skcipher);\n\tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      af_alg_complete, &ctx->completion);\n\n\tsk->sk_destruct = skcipher_sock_destruct;\n\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"56f8eafe-d1b9-4743-ade4-b88401b24973","idx":"f8be4927-87ca-4e68-89d8-33048627b53d"}
{"func_before":"PyInit__ast3(void)\n{\n    PyObject *m, *d;\n    if (!init_types()) return NULL;\n    m = PyModule_Create(&_astmodule3);\n    if (!m) return NULL;\n    d = PyModule_GetDict(m);\n    if (PyDict_SetItemString(d, \"AST\", (PyObject*)&AST_type) < 0) return NULL;\n    if (PyModule_AddIntMacro(m, PyCF_ONLY_AST) < 0)\n        return NULL;\n    if (PyDict_SetItemString(d, \"mod\", (PyObject*)mod_type) < 0) return NULL;\n    if (PyDict_SetItemString(d, \"Module\", (PyObject*)Module_type) < 0) return\n        NULL;\n    if (PyDict_SetItemString(d, \"Interactive\", (PyObject*)Interactive_type) <\n        0) return NULL;","target":1,"flaw_line_index":0,"hash":"1fa304df-7f8f-4cb1-aa94-8ca1b9312c8c","idx":"ea5ea6ad-cbe4-4949-94b9-24b212f9c1e5"}
{"func_before":"PyInit__ast3(void)\n{\n    PyObject *m, *d;\n    if (!init_types()) return NULL;\n    m = PyModule_Create(&_astmodule);\n    if (!m) return NULL;\n    d = PyModule_GetDict(m);\n    if (PyDict_SetItemString(d, \"AST\", (PyObject*)&AST_type) < 0) return NULL;\n    if (PyModule_AddIntMacro(m, PyCF_ONLY_AST) < 0)\n        return NULL;\n    if (PyDict_SetItemString(d, \"mod\", (PyObject*)mod_type) < 0) return NULL;\n    if (PyDict_SetItemString(d, \"Module\", (PyObject*)Module_type) < 0) return\n        NULL;\n    if (PyDict_SetItemString(d, \"Interactive\", (PyObject*)Interactive_type) <\n        0) return NULL;","target":0,"flaw_line_index":0,"hash":"0c4c0788-e987-43a6-944b-793af3fbfaf4","idx":"1b053fc4-a8d3-48d3-b9a5-722a941da408"}
{"func_before":" *\/\nprivate int\nmconvert(struct magic_set *ms, struct magic *m, int flip)\n{\n\tunion VALUETYPE *p = &ms->ms_value;\n\n\tswitch (cvt_flip(m->type, flip)) {\n\tcase FILE_BYTE:\n\t\tcvt_8(p, m);\n\t\treturn 1;\n\tcase FILE_SHORT:\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LONG:\n\tcase FILE_DATE:\n\tcase FILE_LDATE:\n\t\tcvt_32(p, m);\n\t}\n\tcase FILE_BESHORT:\n\t\tp->h = (short)((p->hs[0]<<8)|(p->hs[1]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_BELONG:\n\tcase FILE_BEDATE:\n\tcase FILE_BELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_BEQUAD:\n\tcase FILE_BEQDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_BEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));\n\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_LESHORT:\n\t\tp->h = (short)((p->hs[1]<<8)|(p->hs[0]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LELONG:\n\tcase FILE_LEDATE:\n\tcase FILE_LELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_LEQUAD:\n\tcase FILE_LEQDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_LEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));\n\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_MELONG:\n\tcase FILE_MEDATE:\n\tcase FILE_MELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_FLOAT:\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_BEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)|\n\t\t\t((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_LEFLOAT:","target":1,"flaw_line_index":0,"hash":"ad55de80-eed7-4756-a75d-aba988ebf744","idx":"22bea996-003f-41a3-9d2d-20914db48216"}
{"func_before":" *\/\nprivate int\nmconvert(struct magic_set *ms, struct magic *m, int flip)\n{\n\tunion VALUETYPE *p = &ms->ms_value;\n\tuint8_t type;\n\n\tswitch (type = cvt_flip(m->type, flip)) {\n\tcase FILE_BYTE:\n\t\tcvt_8(p, m);\n\t\treturn 1;\n\tcase FILE_SHORT:\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LONG:\n\tcase FILE_DATE:\n\tcase FILE_LDATE:\n\t\tcvt_32(p, m);\n\t}\n\tcase FILE_BESHORT:\n\t\tp->h = (short)((p->hs[0]<<8)|(p->hs[1]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_BELONG:\n\tcase FILE_BEDATE:\n\tcase FILE_BELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));\n\t\tif (type == FILE_BELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_BEQUAD:\n\tcase FILE_BEQDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_BEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));\n\t\tif (type == FILE_BEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_LESHORT:\n\t\tp->h = (short)((p->hs[1]<<8)|(p->hs[0]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LELONG:\n\tcase FILE_LEDATE:\n\tcase FILE_LELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));\n\t\tif (type == FILE_LELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_LEQUAD:\n\tcase FILE_LEQDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_LEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));\n\t\tif (type == FILE_LEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_MELONG:\n\tcase FILE_MEDATE:\n\tcase FILE_MELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));\n\t\tif (type == FILE_MELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_FLOAT:\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_BEFLOAT:\n\t\tp->l =  ((uint32_t)p->hl[0]<<24)|((uint32_t)p->hl[1]<<16)|\n\t\t\t((uint32_t)p->hl[2]<<8) |((uint32_t)p->hl[3]);\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_LEFLOAT:","target":0,"flaw_line_index":0,"hash":"90bb2fcc-698b-4195-83c3-9c9af86aa6f1","idx":"4b8c0de3-a7bb-4d1f-b788-8f268cabd798"}
{"func_before":"static void perf_event_mmap_output(struct perf_event *event,\n\t\t\t\t     struct perf_mmap_event *mmap_event)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint size = mmap_event->event_id.header.size;\n\tint ret;\n\n\tperf_event_header__init_id(&mmap_event->event_id.header, &sample, event);\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tmmap_event->event_id.header.size, 0, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tmmap_event->event_id.pid = perf_event_pid(event, current);\n\tmmap_event->event_id.tid = perf_event_tid(event, current);\n\n\tperf_output_put(&handle, mmap_event->event_id);\n\t__output_copy(&handle, mmap_event->file_name,\n\t\t\t\t   mmap_event->file_size);\n","target":1,"flaw_line_index":0,"hash":"0829ff65-7aab-4d30-a01f-469a9c8f644d","idx":"15768d24-83ca-40f9-a024-789d1455f524"}
{"func_before":"static void perf_event_mmap_output(struct perf_event *event,\n\t\t\t\t     struct perf_mmap_event *mmap_event)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint size = mmap_event->event_id.header.size;\n\tint ret;\n\n\tperf_event_header__init_id(&mmap_event->event_id.header, &sample, event);\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tmmap_event->event_id.header.size, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tmmap_event->event_id.pid = perf_event_pid(event, current);\n\tmmap_event->event_id.tid = perf_event_tid(event, current);\n\n\tperf_output_put(&handle, mmap_event->event_id);\n\t__output_copy(&handle, mmap_event->file_name,\n\t\t\t\t   mmap_event->file_size);\n","target":0,"flaw_line_index":0,"hash":"fee5d4fb-b9dd-4082-8cc4-801cb798d167","idx":"5e76aa43-ef24-424f-8707-b03756773ec3"}
{"func_before":"\t}\n      if (pid != (pid_t)-1)\n        {\n          if (WIFSIGNALED (status))\n            {\n              fprintf (stderr, \"%s%s\\n\", strsignal (WTERMSIG (status)),\n                       WCOREDUMP (status) ? _(\" (core dumped)\") : \"\");\n              status = WTERMSIG (status) + 128;\n            }\n          else\n            status = WEXITSTATUS (status);\n        }\n      else if (caught_signal)\n        status = caught_signal + 128;\n      else\n        status = 1;\n    }\n  else\n    status = 1;\n\n  if (caught_signal)\n    {\n      fprintf (stderr, _(\"\\nSession terminated, killing shell...\"));\n      kill (child, SIGTERM);\n    }\n\n  cleanup_pam (PAM_SUCCESS);\n\n  if (caught_signal)\n    {\n      sleep (2);\n      kill (child, SIGKILL);\n      fprintf (stderr, _(\" ...killed.\\n\"));\n\n      \/* Let's terminate itself with the received signal.\n       *\n       * It seems that shells use WIFSIGNALED() rather than our exit status\n       * value to detect situations when is necessary to cleanup (reset)\n       * terminal settings (kzak -- Jun 2013).\n       *\/\n      switch (caught_signal) {\n        case SIGTERM:\n          sigaction(SIGTERM, &oldact[0], NULL);","target":1,"flaw_line_index":0,"hash":"0f470e24-d844-46b5-bc99-deb8ec4b3345","idx":"9fa36077-1d57-438f-88e8-ccf42da6354a"}
{"func_before":"      if (pid != (pid_t)-1)\n        {\n          if (WIFSIGNALED (status))\n            {\n              fprintf (stderr, \"%s%s\\n\", strsignal (WTERMSIG (status)),\n                       WCOREDUMP (status) ? _(\" (core dumped)\") : \"\");\n              status = WTERMSIG (status) + 128;\n            }\n          else\n            status = WEXITSTATUS (status);\n\n\t  \/* child is gone, don't use the PID anymore *\/\n\t  child = (pid_t) -1;\n        }\n      else if (caught_signal)\n        status = caught_signal + 128;\n      else\n        status = 1;\n    }\n  else\n    status = 1;\n\n  if (caught_signal && child != (pid_t)-1)\n    {\n      fprintf (stderr, _(\"\\nSession terminated, killing shell...\"));\n      kill (child, SIGTERM);\n    }\n\n  cleanup_pam (PAM_SUCCESS);\n\n  if (caught_signal)\n    {\n      if (child != (pid_t)-1)\n\t{\n\t  sleep (2);\n\t  kill (child, SIGKILL);\n\t  fprintf (stderr, _(\" ...killed.\\n\"));\n\t}\n\n      \/* Let's terminate itself with the received signal.\n       *\n       * It seems that shells use WIFSIGNALED() rather than our exit status\n       * value to detect situations when is necessary to cleanup (reset)\n       * terminal settings (kzak -- Jun 2013).\n       *\/\n      switch (caught_signal) {\n        case SIGTERM:\n          sigaction(SIGTERM, &oldact[0], NULL);","target":0,"flaw_line_index":0,"hash":"60484771-98d0-45f0-ad94-0645f8e8e5e4","idx":"393844c7-03f4-406d-ae04-a7cbbda16959"}
{"func_before":"         acceptable = TRUE;\n      }\n   }\n\n   \/\/Non acceptable sequence number?\n   if(!acceptable)\n   {\n      \/\/Debug message\n      TRACE_WARNING(\"Sequence number is not acceptable!\\r\\n\");\n\n      \/\/If an incoming segment is not acceptable, an acknowledgment\n      \/\/should be sent in reply (unless the RST bit is set)\n      if(!(segment->flags & TCP_FLAG_RST))\n         tcpSendSegment(socket, TCP_FLAG_ACK, socket->sndNxt, socket->rcvNxt, 0, FALSE);\n\n      \/\/Return status code\n      return ERROR_FAILURE;\n   }\n\n   \/\/Sequence number is acceptable\n   return NO_ERROR;\n}","target":1,"flaw_line_index":0,"hash":"72fd0b12-5e65-4721-89e0-1a109d4a295f","idx":"0f4c4a47-cd64-4b5c-b474-1f74e9b6ba38"}
{"func_before":"         acceptable = TRUE;\n      }\n   }\n\n   \/\/Non acceptable sequence number?\n   if(!acceptable)\n   {\n      \/\/Debug message\n      TRACE_WARNING(\"Sequence number is not acceptable!\\r\\n\");\n\n      \/\/If an incoming segment is not acceptable, an acknowledgment should\n      \/\/be sent in reply (unless the RST bit is set)\n      if(!(segment->flags & TCP_FLAG_RST))\n      {\n         tcpSendSegment(socket, TCP_FLAG_ACK, socket->sndNxt, socket->rcvNxt,\n            0, FALSE);\n      }\n\n      \/\/Return status code\n      return ERROR_FAILURE;\n   }\n\n   \/\/Sequence number is acceptable\n   return NO_ERROR;\n}","target":0,"flaw_line_index":0,"hash":"f40f314e-ab80-4468-8cb9-4538a421e102","idx":"56c20c12-2788-43bb-8d47-6ddc5600ffb8"}
{"func_before":"static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,\n                                   OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n    OPJ_UINT32 x, y;\n    OPJ_UINT8 *pix;\n    const OPJ_UINT8 *beyond;\n\n    beyond = pData + stride * height;\n    pix = pData;\n\n    x = y = 0U;\n    while (y < height) {\n        int c = getc(IN);\n        if (c == EOF) {\n            return OPJ_FALSE;\n        }\n\n        if (c) {\n            int j, c1_int;\n            OPJ_UINT8 c1;\n\n            c1_int = getc(IN);\n            if (c1_int == EOF) {\n                return OPJ_FALSE;\n            }\n            c1 = (OPJ_UINT8)c1_int;\n\n            for (j = 0; (j < c) && (x < width) &&\n                    ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                *pix = c1;\n            }\n        } else {\n            c = getc(IN);\n            if (c == EOF) {\n                return OPJ_FALSE;\n            }\n\n            if (c == 0x00) { \/* EOL *\/\n                x = 0;\n                ++y;\n                int j;\n                for (j = 0; (j < c) && (x < width) &&\n                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                    int c1_int;\n                    OPJ_UINT8 c1;\n                    c1_int = getc(IN);\n                    if (c1_int == EOF) {\n                        return OPJ_FALSE;\n                    }\n                    c1 = (OPJ_UINT8)c1_int;\n                    *pix = c1;\n                }\n                if ((OPJ_UINT32)c & 1U) { \/* skip padding byte *\/\n                    c = getc(IN);\n                    if (c == EOF) {\n                        return OPJ_FALSE;\n                    }\n                }\n            }\n        }\n    }\/* while() *\/\n    return OPJ_TRUE;\n}","target":1,"flaw_line_index":0,"hash":"0df1b4cb-015a-41c3-aaf8-3265f53fea9a","idx":"98a1920e-22b7-4781-91e4-1a7b286643c3"}
{"func_before":"static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,\n                                   OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n    OPJ_UINT32 x, y, written;\n    OPJ_UINT8 *pix;\n    const OPJ_UINT8 *beyond;\n\n    beyond = pData + stride * height;\n    pix = pData;\n\n    x = y = written = 0U;\n    while (y < height) {\n        int c = getc(IN);\n        if (c == EOF) {\n            return OPJ_FALSE;\n        }\n\n        if (c) {\n            int j, c1_int;\n            OPJ_UINT8 c1;\n\n            c1_int = getc(IN);\n            if (c1_int == EOF) {\n                return OPJ_FALSE;\n            }\n            c1 = (OPJ_UINT8)c1_int;\n\n            for (j = 0; (j < c) && (x < width) &&\n                    ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                *pix = c1;\n                written++;\n            }\n        } else {\n            c = getc(IN);\n            if (c == EOF) {\n                return OPJ_FALSE;\n            }\n\n            if (c == 0x00) { \/* EOL *\/\n                x = 0;\n                ++y;\n                for (j = 0; (j < c) && (x < width) &&\n                        ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                    int c1_int;\n                    OPJ_UINT8 c1;\n                    c1_int = getc(IN);\n                    if (c1_int == EOF) {\n                        return OPJ_FALSE;\n                    }\n                    c1 = (OPJ_UINT8)c1_int;\n                    *pix = c1;\n                    written++;\n                }\n                if ((OPJ_UINT32)c & 1U) { \/* skip padding byte *\/\n                    c = getc(IN);\n                    if (c == EOF) {\n                        return OPJ_FALSE;\n                    }\n                }\n            }\n        }\n    }\/* while() *\/\n\n    if (written != width * height) {\n        fprintf(stderr, \"warning, image's actual size does not match advertized one\\n\");\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}","target":0,"flaw_line_index":0,"hash":"23e9cd39-d842-450a-8d6e-3febef4d291f","idx":"6c096581-2786-4bb4-a4ec-0b4823066318"}
{"func_before":"\tbi->vdpi = pict_read_fixed(f, pos+12);\n\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);\n\n\tbi->pixeltype = dbuf_getu16be(f, pos+16);\n\tbi->pixelsize = dbuf_getu16be(f, pos+18);\n\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits\/pixel=%d, components\/pixel=%d, bits\/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\n\tbi->pdwidth = (bi->rowbytes*8)\/bi->pixelsize;\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\n\tplane_bytes = dbuf_getu32be(f, pos+24);\n\tde_dbg(c, \"plane bytes: %d\", (int)plane_bytes);\n\n\tbi->pmTable = (u32)dbuf_getu32be(f, pos+28);\n\tde_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);\n","target":1,"flaw_line_index":0,"hash":"87a84e21-fb3e-4944-875c-684fe492b4ab","idx":"cdace4fc-ea49-4675-8a68-e699244bd39f"}
{"func_before":"\tbi->vdpi = pict_read_fixed(f, pos+12);\n\tde_dbg(c, \"dpi: %.2f\"DE_CHAR_TIMES\"%.2f\", bi->hdpi, bi->vdpi);\n\n\tbi->pixeltype = dbuf_getu16be(f, pos+16);\n\tbi->pixelsize = dbuf_getu16be(f, pos+18);\n\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits\/pixel=%d, components\/pixel=%d, bits\/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\n\tif(bi->pixelsize>0) {\n\t\tbi->pdwidth = (bi->rowbytes*8)\/bi->pixelsize;\n\t}\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\n\tplane_bytes = dbuf_getu32be(f, pos+24);\n\tde_dbg(c, \"plane bytes: %d\", (int)plane_bytes);\n\n\tbi->pmTable = (u32)dbuf_getu32be(f, pos+28);\n\tde_dbg(c, \"pmTable: 0x%08x\", (unsigned int)bi->pmTable);\n","target":0,"flaw_line_index":0,"hash":"c7449f6d-784e-47e5-8020-1d65ed94d408","idx":"6b614198-8584-4162-8ea6-ed18625f52de"}
{"func_before":"        tok->u.code = (OnigCodePoint )num;\n      }\n      break;\n\n    case '0':\n    case '1': case '2': case '3': case '4': case '5': case '6': case '7':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n        PUNFETCH;\n        prev = p;\n        num = scan_unsigned_octal_number(&p, end, 3, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  \/* can't read nothing. *\/\n          num = 0; \/* but, it's not error *\/\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 8;\n        tok->u.c  = num;\n      }\n      break;\n\n    default:","target":1,"flaw_line_index":0,"hash":"4b8abc78-29b6-45b6-aead-50a5159f8e88","idx":"d99048a1-de93-40ca-aa68-ca544450ace6"}
{"func_before":"        tok->u.code = (OnigCodePoint )num;\n      }\n      break;\n\n    case '0':\n    case '1': case '2': case '3': case '4': case '5': case '6': case '7':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n        PUNFETCH;\n        prev = p;\n        num = scan_unsigned_octal_number(&p, end, 3, enc);\n        if (num < 0 || num >= 256) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  \/* can't read nothing. *\/\n          num = 0; \/* but, it's not error *\/\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 8;\n        tok->u.c  = num;\n      }\n      break;\n\n    default:","target":0,"flaw_line_index":0,"hash":"b5cb512e-5e93-4e2d-bf12-68c7d1e244bc","idx":"4c0ab837-a812-428d-9735-5b2f7d09b984"}
{"func_before":"ast_for_async_funcdef(struct compiling *c, const node *n, asdl_seq *decorator_seq)\n{\n    \/* async_funcdef: ASYNC funcdef *\/\n    REQ(n, async_funcdef);\n    REQ(CHILD(n, 0), ASYNC);\n    REQ(CHILD(n, 1), funcdef);\n\n    return ast_for_funcdef_impl(c, CHILD(n, 1), decorator_seq,\n                                1 \/* is_async *\/);\n}","target":1,"flaw_line_index":0,"hash":"fbe346df-6173-42da-a8b1-059919f58b14","idx":"04eb9df9-24cf-4de2-9227-0932402a8f7f"}
{"func_before":"ast_for_async_funcdef(struct compiling *c, const node *n, asdl_seq *decorator_seq)\n{\n    \/* async_funcdef: 'async' funcdef *\/\n    REQ(n, async_funcdef);\n    REQ(CHILD(n, 0), NAME);\n    assert(strcmp(STR(CHILD(n, 0)), \"async\") == 0);\n    REQ(CHILD(n, 1), funcdef);\n\n    return ast_for_funcdef_impl(c, n, decorator_seq,\n                                true \/* is_async *\/);\n}","target":0,"flaw_line_index":0,"hash":"c2c29588-3f5f-4836-846a-b5796d308af1","idx":"ad3766a0-ed6c-4b87-88c4-f8cb86452e2a"}
{"func_before":"    if (position == output_name_to_position.end()) {\n      return InvalidArgument(\n          \"Can't import function, returned value references unknown output \"\n          \"argument \",\n          ret_val.first);\n    }\n    if (ret_val.second.empty()) {\n      return InvalidArgument(\"Function '\", func.signature().name(),\n                             \"' has empty result name\");\n    }\n    ret_vals[position->second] =\n        value_manager.GetValueOrCreatePlaceholder(ret_val.second);\n  }\n  for (const auto& ret_val : func.control_ret()) {\n    auto position = control_output_to_position.find(ret_val.first);\n    if (position == control_output_to_position.end()) {\n      return InvalidArgument(\n          \"Can't import function, returned value references unknown output \"\n          \"argument \",\n          ret_val.first);\n    }\n    if (ret_val.second.empty()) {\n      return InvalidArgument(\"Function '\", func.signature().name(),\n                             \"' has empty control result name\");\n    }\n    Value result = value_manager.GetValueOrCreatePlaceholder(\n        (Twine(\"^\") + ret_val.second).str());\n    if (!result.getType().isa<ControlType>())\n      return InvalidArgument(\"failed to map returned value \", ret_val.second,\n                             \", isn't a control output\");\n    ret_vals[func.ret_size() + position->second] = result;\n  }\n  \/\/ Check that all the of the return operands have been populated.\n  for (auto& indexed_val : llvm::enumerate(ret_vals)) {\n    if (indexed_val.value()) continue;\n    return InvalidArgument(\n        \"Failed to import function, missing output for position \",","target":1,"flaw_line_index":0,"hash":"89493f82-39b6-4244-8537-7bffe937c0ac","idx":"634b0b3d-cd7a-4281-8093-76319d4d8b44"}
{"func_before":"    if (position == output_name_to_position.end()) {\n      return InvalidArgument(\n          \"Can't import function, returned value references unknown output \"\n          \"argument \",\n          ret_val.first);\n    }\n    if (ret_val.second.empty()) {\n      return InvalidArgument(\"Function '\", func.signature().name(),\n                             \"' has empty result name\");\n    }\n    TF_ASSIGN_OR_RETURN(\n        ret_vals[position->second],\n        value_manager.GetValueOrCreatePlaceholder(ret_val.second));\n  }\n  for (const auto& ret_val : func.control_ret()) {\n    auto position = control_output_to_position.find(ret_val.first);\n    if (position == control_output_to_position.end()) {\n      return InvalidArgument(\n          \"Can't import function, returned value references unknown output \"\n          \"argument \",\n          ret_val.first);\n    }\n    if (ret_val.second.empty()) {\n      return InvalidArgument(\"Function '\", func.signature().name(),\n                             \"' has empty control result name\");\n    }\n    TF_ASSIGN_OR_RETURN(Value result, value_manager.GetValueOrCreatePlaceholder(\n                                          (Twine(\"^\") + ret_val.second).str()));\n    if (!result.getType().isa<ControlType>())\n      return InvalidArgument(\"failed to map returned value \", ret_val.second,\n                             \", isn't a control output\");\n    ret_vals[func.ret_size() + position->second] = result;\n  }\n  \/\/ Check that all the of the return operands have been populated.\n  for (auto& indexed_val : llvm::enumerate(ret_vals)) {\n    if (indexed_val.value()) continue;\n    return InvalidArgument(\n        \"Failed to import function, missing output for position \",","target":0,"flaw_line_index":0,"hash":"936976dc-2fe7-4724-89fb-9045d5209a09","idx":"fffb65f3-d64a-49c0-94a3-852dc83dcd50"}
{"func_before":"TfLiteStatus GenericPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (!is_supported_type(input->type)) {\n    TF_LITE_UNSUPPORTED_TYPE(context, input->type, op_name);\n  }\n  return context->ResizeTensor(context, output,\n                               TfLiteIntArrayCopy(input->dims));\n}","target":1,"flaw_line_index":0,"hash":"ca341851-626a-4d7f-8ef0-338df5a8ae2a","idx":"031c53b0-88ed-4476-af26-53f9c992f8c5"}
{"func_before":"TfLiteStatus GenericPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (!is_supported_type(input->type)) {\n    TF_LITE_UNSUPPORTED_TYPE(context, input->type, op_name);\n  }\n  return context->ResizeTensor(context, output,\n                               TfLiteIntArrayCopy(input->dims));\n}","target":0,"flaw_line_index":0,"hash":"9f1eb2d7-9d65-4543-b7fa-dd066ec0c5ff","idx":"f8adc398-ec71-4631-ac0d-24a02980becc"}
{"func_before":"\n\ttrace_xfs_attr_sf_addname(args);\n\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tASSERT(retval == 0);\n\t}\n\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);","target":1,"flaw_line_index":0,"hash":"8d799f99-a144-4612-8f26-c353c19555b8","idx":"8eedc9f3-606e-4b48-9767-9aafe0dccab7"}
{"func_before":"\n\ttrace_xfs_attr_sf_addname(args);\n\n\tretval = xfs_attr_shortform_lookup(args);\n\tif ((args->flags & ATTR_REPLACE) && (retval == -ENOATTR)) {\n\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\t\/*\n\t\t * Since we have removed the old attr, clear ATTR_REPLACE so\n\t\t * that the leaf format add routine won't trip over the attr\n\t\t * not being around.\n\t\t *\/\n\t\targs->flags &= ~ATTR_REPLACE;\n\t}\n\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;\n\n\tnewsize = XFS_ATTR_SF_TOTSIZE(args->dp);\n\tnewsize += XFS_ATTR_SF_ENTSIZE_BYNAME(args->namelen, args->valuelen);\n\n\tforkoff = xfs_attr_shortform_bytesfit(args->dp, newsize);","target":0,"flaw_line_index":0,"hash":"07c5b8a4-cb31-407b-b0cd-51d1f4284c83","idx":"ac1cddaf-451a-4d09-8ef4-e68533971dcd"}
{"func_before":"                        print_unknown_data(ndo, tptr, \"\\n\\t      \", tlen);\n                    }\n                }\n                break;\n        }\n\tcase BGPTYPE_AIGP:\n\t{\n\t\tuint8_t type;\n\t\tuint16_t length;\n\n\t\tND_TCHECK2(tptr[0], 3);\n\n\t\ttlen = len;\n\n\t\twhile (tlen >= 3) {\n\n\t\t    type = *tptr;\n\t\t    length = EXTRACT_16BITS(tptr+1);\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s TLV (%u), length %u\",\n\t\t\t      tok2str(bgp_aigp_values, \"Unknown\", type),\n\t\t\t      type, length));\n\n\t\t    \/*\n\t\t     * Check if we can read the TLV data.\n\t\t     *\/\n\t\t    ND_TCHECK2(tptr[3], length - 3);\n\n\t\t    switch (type) {\n\n\t\t    case BGP_AIGP_TLV:\n\t\t        ND_TCHECK2(tptr[3], 8);\n\t\t\tND_PRINT((ndo, \", metric %\" PRIu64,\n\t\t\t\t  EXTRACT_64BITS(tptr+3)));\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\t    print_unknown_data(ndo, tptr+3,\"\\n\\t      \", length-3);\n\t\t\t}\n\t\t    }\n\n\t\t    tptr += length;\n\t\t    tlen -= length;\n\t\t}\n\t\tbreak;\n\t}\n        case BGPTYPE_ATTR_SET:\n                ND_TCHECK2(tptr[0], 4);","target":1,"flaw_line_index":0,"hash":"1d93c5ba-a06c-4d63-8050-fe2e2079c0d6","idx":"a2d816a1-8944-44e2-8e66-5c1156c416f1"}
{"func_before":"                    if (ndo->ndo_vflag <= 1) {\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", tlen);\n                    }\n                }\n                break;\n        }\n\tcase BGPTYPE_AIGP:\n\t{\n\t\tuint8_t type;\n\t\tuint16_t length;\n\n\t\ttlen = len;\n\n\t\twhile (tlen >= 3) {\n\n\t\t    ND_TCHECK2(tptr[0], 3);\n\n\t\t    type = *tptr;\n\t\t    length = EXTRACT_16BITS(tptr+1);\n\t\t    tptr += 3;\n\t\t    tlen -= 3;\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s TLV (%u), length %u\",\n\t\t\t      tok2str(bgp_aigp_values, \"Unknown\", type),\n\t\t\t      type, length));\n\n\t\t    if (length < 3)\n\t\t\tgoto trunc;\n\t\t    length -= 3;\n\n\t\t    \/*\n\t\t     * Check if we can read the TLV data.\n\t\t     *\/\n\t\t    ND_TCHECK2(tptr[3], length);\n\n\t\t    switch (type) {\n\n\t\t    case BGP_AIGP_TLV:\n\t\t        if (length < 8)\n\t\t            goto trunc;\n\t\t\tND_PRINT((ndo, \", metric %\" PRIu64,\n\t\t\t\t  EXTRACT_64BITS(tptr)));\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\t    print_unknown_data(ndo, tptr,\"\\n\\t      \", length);\n\t\t\t}\n\t\t    }\n\n\t\t    tptr += length;\n\t\t    tlen -= length;\n\t\t}\n\t\tbreak;\n\t}\n        case BGPTYPE_ATTR_SET:\n                ND_TCHECK2(tptr[0], 4);","target":0,"flaw_line_index":0,"hash":"edd5afc8-0909-4635-ab04-0193fb3079a1","idx":"015a9f02-e14e-432a-8bcd-71523161a423"}
{"func_before":"create_principal3_2_svc(cprinc3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n                                            arg->passwd);\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_create_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","target":1,"flaw_line_index":0,"hash":"07ab78e7-4363-40d8-972d-8e9e9266c445","idx":"e2273526-a00d-4884-8c32-c7791c95d737"}
{"func_before":"create_principal3_2_svc(cprinc3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n    if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))\n        goto exit_func;\n\n        if( ret.code != 0 )\n            errmsg = krb5_get_error_message(handle->context, ret.code);\n\n        log_done(\"kadm5_create_principal\", prime_arg, errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","target":0,"flaw_line_index":0,"hash":"433b570b-8581-422b-89cf-086acac12a7b","idx":"a44b08f7-3d1e-45b7-9a75-3660346e689a"}
{"func_before":"xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t     xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret, *dst;\n    const xmlChar *src;\n    xmlAttributePtr attrDecl = NULL;\n    int extsubset = 0;\n\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n    }\n\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    src = value;\n    dst = ret;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n    if ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) {\n\txmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,\n\"standalone: %s on %s value had to be normalized based on external subset declaration\\n\",\n\t       name, elem->name, NULL);\n\tctxt->valid = 0;\n    }\n    return(ret);\n}","target":1,"flaw_line_index":0,"hash":"75db7623-1676-4780-a38d-f9dbcf00481a","idx":"d32dd05e-e0ee-499c-99f3-786a6b76b64d"}
{"func_before":"xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t     xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret;\n    xmlAttributePtr attrDecl = NULL;\n    int extsubset = 0;\n\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n    if (name == NULL) return(NULL);\n    if (value == NULL) return(NULL);\n\n    if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) {\n\txmlChar fn[50];\n    }\n\n    if (attrDecl == NULL)\n\treturn(NULL);\n    if (attrDecl->atype == XML_ATTRIBUTE_CDATA)\n\treturn(NULL);\n\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    xmlValidNormalizeString(ret);\n    if ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) {\n\txmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,\n\"standalone: %s on %s value had to be normalized based on external subset declaration\\n\",\n\t       name, elem->name, NULL);\n\tctxt->valid = 0;\n    }\n    return(ret);\n}","target":0,"flaw_line_index":0,"hash":"8b9ebec9-9517-4d42-88a0-b149556a8248","idx":"b69bbe0a-4cb9-4624-af67-4817776bf9e2"}
{"func_before":"char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[1024];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = gf_fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\tif (unicode_type<=1) {\n\t\tj=0;\n\t\tlen = (u32) strlen(szLine);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tif (!szLine[i] && !szLine[i+1]) break;\n\t\t\tc = szLine[i+1];\n\t\t\tszLine[i+1] = szLine[i];\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t\/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \\0 after a \\n*\/\n\tif (unicode_type==3) gf_fgetc(txt_in);\n\treturn sOK;\n}","target":1,"flaw_line_index":0,"hash":"059d7897-866d-4e69-b7a4-46a10f894557","idx":"07e4e7af-b9fa-45c2-9c60-a6dd44adfa20"}
{"func_before":"char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[2048];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = gf_fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\tif (unicode_type<=1) {\n\t\tj=0;\n\t\tlen = (u32) strlen(szLine);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tif (!szLine[i] && !szLine[i+1]) break;\n\t\t\tc = szLine[i+1];\n\t\t\tszLine[i+1] = szLine[i];\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = (u32) gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t\/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \\0 after a \\n*\/\n\tif (unicode_type==3) gf_fgetc(txt_in);\n\treturn sOK;\n}","target":0,"flaw_line_index":0,"hash":"4e7975a6-c706-4edb-8504-aca66901d8c8","idx":"87a145ed-ec5f-4896-a0e3-acc46b429ac5"}
{"func_before":"comics_document_render (EvDocument      *document,\n\t\t\tEvRenderContext *rc)\n{\n\tGdkPixbuf       *pixbuf;\n\tcairo_surface_t *surface;\n\n\tpixbuf = comics_document_render_pixbuf (document, rc);\n\tsurface = ev_document_misc_surface_from_pixbuf (pixbuf);\n\tg_object_unref (pixbuf);\n\t\n\treturn surface;\n}","target":1,"flaw_line_index":0,"hash":"4152698c-6d31-4d7f-bdac-636a86e37663","idx":"c3503326-2adb-4cda-a580-f1bec6dc6451"}
{"func_before":"comics_document_render (EvDocument      *document,\n\t\t\tEvRenderContext *rc)\n{\n\tGdkPixbuf       *pixbuf;\n\tcairo_surface_t *surface;\n\n\tpixbuf = comics_document_render_pixbuf (document, rc);\n\tif (!pixbuf)\n\t\treturn NULL;\n\tsurface = ev_document_misc_surface_from_pixbuf (pixbuf);\n\tg_clear_object (&pixbuf);\n\n\treturn surface;\n}","target":0,"flaw_line_index":0,"hash":"e2cd2d3f-bde9-40f3-8c7f-8e22967fd3b1","idx":"4380e62d-1b1a-4bdc-8804-680b82c0c30c"}
{"func_before":"FunctionDef(identifier name, arguments_ty args, asdl_seq * body, asdl_seq *\n            decorator_list, expr_ty returns, int lineno, int col_offset, int\n            end_lineno, int end_col_offset, PyArena *arena)\n{\n    stmt_ty p;\n    if (!name) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field name is required for FunctionDef\");\n        return NULL;\n    }\n    if (!args) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field args is required for FunctionDef\");\n        return NULL;\n    }\n    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = FunctionDef_kind;\n    p->v.FunctionDef.name = name;\n    p->v.FunctionDef.args = args;\n    p->v.FunctionDef.body = body;\n    p->v.FunctionDef.decorator_list = decorator_list;\n    p->v.FunctionDef.returns = returns;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;\n}","target":1,"flaw_line_index":0,"hash":"bc4e616b-f259-43a7-a3cf-3ab9b1922113","idx":"9daf7559-748d-4078-93b1-c928353684c9"}
{"func_before":"FunctionDef(identifier name, arguments_ty args, asdl_seq * body, asdl_seq *\n            decorator_list, expr_ty returns, string type_comment, int lineno,\n            int col_offset, int end_lineno, int end_col_offset, PyArena *arena)\n{\n    stmt_ty p;\n    if (!name) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field name is required for FunctionDef\");\n        return NULL;\n    }\n    if (!args) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field args is required for FunctionDef\");\n    }\n    p = (stmt_ty)PyArena_Malloc(arena, sizeof(*p));\n    if (!p)\n        return NULL;\n    p->kind = FunctionDef_kind;\n    p->v.FunctionDef.name = name;\n    p->v.FunctionDef.args = args;\n    p->v.FunctionDef.body = body;\n    p->v.FunctionDef.decorator_list = decorator_list;\n    p->v.FunctionDef.returns = returns;\n    p->v.FunctionDef.type_comment = type_comment;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;\n}","target":0,"flaw_line_index":0,"hash":"1ba3dadd-a8c7-467d-96e1-1bc4f5dd507b","idx":"4878fc8d-f9ff-4792-acea-2e986f84a929"}
{"func_before":"int mi_repair(MI_CHECK *param, register MI_INFO *info,\n\t      char * name, int rep_quick)\n{\n  int error,got_error;\n  ha_rows start_records,new_header_length;\n  my_off_t del;\n  File new_file;\n  MYISAM_SHARE *share=info->s;\n  char llbuff[22],llbuff2[22];\n  SORT_INFO sort_info;\n  MI_SORT_PARAM sort_param;\n  DBUG_ENTER(\"mi_repair\");\n  got_error=0;\n  \/* If invoked by external program that uses thr_lock *\/\n  if (&share->state.state != info->state)\n    memcpy( &share->state.state, info->state, sizeof(*info->state));\n\nerr:\n  if (!got_error)\n  {\n    \/* Replace the actual file with the temporary file *\/\n    if (new_file >= 0)\n    {\n      mysql_file_close(new_file, MYF(0));\n      info->dfile=new_file= -1;\n      \/*\n        On Windows, the old data file cannot be deleted if it is either\n        open, or memory mapped. Closing the file won't remove the memory\n        map implicilty on Windows. We closed the data file, but we keep\n        the MyISAM table open. A memory map will be closed on the final\n        mi_close() only. So we need to unmap explicitly here. After\n        renaming the new file under the hook, we couldn't use the map of\n        the old file any more anyway.\n      *\/\n      if (info->s->file_map)\n      {\n        (void) my_munmap((char*) info->s->file_map,\n                         (size_t) info->s->mmaped_length);\n        info->s->file_map= NULL;\n      }\n      if (change_to_newfile(share->data_file_name, MI_NAME_DEXT, DATA_TMP_EXT,\n\t\t\t    (param->testflag & T_BACKUP_DATA ?\n\t\t\t     MYF(MY_REDEL_MAKE_BACKUP): MYF(0))) ||\n\t  mi_open_datafile(info,share,name,-1))\n\tgot_error=1;\n\n      param->retry_repair= 0;\n    }\n  }\n  if (got_error)\n  {\n    if (! param->error_printed)\n      mi_check_print_error(param,\"%d for record at pos %s\",my_errno,","target":1,"flaw_line_index":0,"hash":"bc594580-5c6f-4746-9527-44a1805b583b","idx":"81e38528-6c12-4cd3-b0d1-d7f1806334ca"}
{"func_before":"int mi_repair(MI_CHECK *param, register MI_INFO *info,\n\t      char * name, int rep_quick, my_bool no_copy_stat)\n{\n  int error,got_error;\n  ha_rows start_records,new_header_length;\n  my_off_t del;\n  File new_file;\n  MYISAM_SHARE *share=info->s;\n  char llbuff[22],llbuff2[22];\n  SORT_INFO sort_info;\n  MI_SORT_PARAM sort_param;\n  DBUG_ENTER(\"mi_repair\");\n  \/* If invoked by external program that uses thr_lock *\/\n  if (&share->state.state != info->state)\n    memcpy( &share->state.state, info->state, sizeof(*info->state));\n\nerr:\n  if (!got_error)\n  {\n    \/* Replace the actual file with the temporary file *\/\n    if (new_file >= 0)\n    {\n      myf flags= 0;\n      if (param->testflag & T_BACKUP_DATA)\n        flags |= MY_REDEL_MAKE_BACKUP;\n      if (no_copy_stat)\n        flags |= MY_REDEL_NO_COPY_STAT;\n      mysql_file_close(new_file, MYF(0));\n      info->dfile=new_file= -1;\n      \/*\n        On Windows, the old data file cannot be deleted if it is either\n        open, or memory mapped. Closing the file won't remove the memory\n        map implicilty on Windows. We closed the data file, but we keep\n        the MyISAM table open. A memory map will be closed on the final\n        mi_close() only. So we need to unmap explicitly here. After\n        renaming the new file under the hook, we couldn't use the map of\n        the old file any more anyway.\n      *\/\n      if (info->s->file_map)\n      {\n        (void) my_munmap((char*) info->s->file_map,\n                         (size_t) info->s->mmaped_length);\n        info->s->file_map= NULL;\n      }\n      if (change_to_newfile(share->data_file_name, MI_NAME_DEXT, DATA_TMP_EXT,\n                            flags) ||\n\t  mi_open_datafile(info,share,name,-1))\n\tgot_error=1;\n\n      param->retry_repair= 0;\n    }\n  }\n  if (got_error)\n  {\n    if (! param->error_printed)\n      mi_check_print_error(param,\"%d for record at pos %s\",my_errno,","target":0,"flaw_line_index":0,"hash":"566ad8bb-14e3-4e8b-b4d9-84ada8b09945","idx":"68a12af8-61e8-4dfa-a4cd-6804abc97882"}
{"func_before":"static CONSTBUFFER_HANDLE CONSTBUFFER_Create_Internal(const unsigned char* source, size_t size)\n{\n    CONSTBUFFER_HANDLE result;\n    \/*Codes_SRS_CONSTBUFFER_02_005: [The non-NULL handle returned by CONSTBUFFER_Create shall have its ref count set to \"1\".]*\/\n    \/*Codes_SRS_CONSTBUFFER_02_010: [The non-NULL handle returned by CONSTBUFFER_CreateFromBuffer shall have its ref count set to \"1\".]*\/\n    result = (CONSTBUFFER_HANDLE)calloc(1, (sizeof(CONSTBUFFER_HANDLE_DATA) + size));\n    if (result == NULL)\n    {\n        \/*Codes_SRS_CONSTBUFFER_02_003: [If creating the copy fails then CONSTBUFFER_Create shall return NULL.]*\/\n        \/*Codes_SRS_CONSTBUFFER_02_008: [If copying the content fails, then CONSTBUFFER_CreateFromBuffer shall fail and return NULL.] *\/\n        LogError(\"unable to malloc\");\n        \/*return as is*\/\n    }\n    else\n    {\n        INIT_REF_VAR(result->count);","target":1,"flaw_line_index":0,"hash":"90ec0769-ad4a-4217-b4c5-33754e83fc43","idx":"b75d72c5-5005-476e-8ff4-f70fc8393137"}
{"func_before":"static CONSTBUFFER_HANDLE CONSTBUFFER_Create_Internal(const unsigned char* source, size_t size)\n{\n    CONSTBUFFER_HANDLE result;\n    \/*Codes_SRS_CONSTBUFFER_02_005: [The non-NULL handle returned by CONSTBUFFER_Create shall have its ref count set to \"1\".]*\/\n    \/*Codes_SRS_CONSTBUFFER_02_010: [The non-NULL handle returned by CONSTBUFFER_CreateFromBuffer shall have its ref count set to \"1\".]*\/\n    size_t malloc_size = sizeof(CONSTBUFFER_HANDLE_DATA) + size;\n    if (malloc_size < size)\n    {\n        result = NULL;\n        LogError(\"invalid size parameter\");\n        \/*return as is*\/\n    }\n    else\n    {\n        result = (CONSTBUFFER_HANDLE)calloc(1, malloc_size);\n    }\n\n    if (result == NULL)\n    {\n        \/*Codes_SRS_CONSTBUFFER_02_003: [If creating the copy fails then CONSTBUFFER_Create shall return NULL.]*\/\n        \/*Codes_SRS_CONSTBUFFER_02_008: [If copying the content fails, then CONSTBUFFER_CreateFromBuffer shall fail and return NULL.] *\/\n        LogError(\"unable to malloc\");\n        \/*return as is*\/\n    }\n    else\n    {\n        INIT_REF_VAR(result->count);","target":0,"flaw_line_index":0,"hash":"ca460d03-fa9a-4cb9-b1f7-7ddce3b47b7d","idx":"ae6d66d2-1fb9-47a9-816f-cf501f6ca9e4"}
{"func_before":"find_entry_internal(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int\t\t\tlock,\n\tback_txn *txn,\n\tint flags\n)\n{\n\t\/* check if we should search based on uniqueid or dn *\/\n\tif (addr->uniqueid!=NULL)\n\t{\n\t\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> find_entry_internal (uniqueid=%s) lock %d\\n\",\n\t\t    addr->uniqueid, lock, 0 );\n\t\treturn (find_entry_internal_uniqueid (pb, be, addr->uniqueid, lock, txn));\n\t}\n\telse\n\t{\n\t\tstruct backentry *entry = NULL;\n\n\t\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> find_entry_internal (dn=%s) lock %d\\n\",\n\t\t           slapi_sdn_get_dn(addr->sdn), lock, 0 );\n\t\tif (addr->sdn) {\n\t\t\tentry = find_entry_internal_dn (pb, be, addr->sdn, \n\t\t\t                                lock, txn, flags);\n\t\t} else {\n\t\t\tLDAPDebug0Args( LDAP_DEBUG_ANY,\n\t\t\t                \"find_entry_internal: Null target dn\\n\" );\n\t\t}\n\n\t\tLDAPDebug0Args( LDAP_DEBUG_TRACE, \"<= find_entry_internal\\n\" );\n\t\treturn entry;\n\t}\n}","target":1,"flaw_line_index":0,"hash":"46371f46-15d3-41db-862b-f0716159d555","idx":"4fbcb0ed-f479-4b9c-9561-951af0ef6aca"}
{"func_before":"find_entry_internal(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int\t\t\tlock,\n    back_txn *txn,\n    int flags,\n    int *rc\n)\n{\n\t\/* check if we should search based on uniqueid or dn *\/\n\tif (addr->uniqueid!=NULL)\n\t{\n\t\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> find_entry_internal (uniqueid=%s) lock %d\\n\",\n\t\t    addr->uniqueid, lock, 0 );\n\t\treturn (find_entry_internal_uniqueid (pb, be, addr->uniqueid, lock, txn));\n\t}\n\telse\n\t{\n\t\tstruct backentry *entry = NULL;\n\n\t\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> find_entry_internal (dn=%s) lock %d\\n\",\n\t\t           slapi_sdn_get_dn(addr->sdn), lock, 0 );\n\t\tif (addr->sdn) {\n\t\t\tentry = find_entry_internal_dn (pb, be, addr->sdn, lock, txn, flags, rc);\n\t\t} else {\n\t\t\tLDAPDebug0Args( LDAP_DEBUG_ANY, \"find_entry_internal: Null target dn\\n\" );\n\t\t}\n\n\t\tLDAPDebug0Args( LDAP_DEBUG_TRACE, \"<= find_entry_internal\\n\" );\n\t\treturn entry;\n\t}\n}","target":0,"flaw_line_index":0,"hash":"c03fcd86-7685-4498-89c0-9bb9936c0609","idx":"5afc79a5-0842-4a87-9c65-b863494d1cb9"}
{"func_before":"static void buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\n\tref->ref++;\n}","target":1,"flaw_line_index":0,"hash":"7a315ba6-413c-4b91-b861-54c21a838c5e","idx":"cb559832-bf6e-426d-ab32-5239de913d2b"}
{"func_before":"static bool buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\n\tif (ref->ref > INT_MAX\/2)\n\t\treturn false;\n\n\tref->ref++;\n\treturn true;\n}","target":0,"flaw_line_index":0,"hash":"e731eac0-2c39-49ba-b5b9-a3fa48bb53a5","idx":"08721279-2a4d-4c8f-a0a4-d384fb592c5a"}
{"func_before":"static char *get_header(FILE *fp)\n{\n    long start;\n\n    \/* First 1024 bytes of doc must be header (1.7 spec pg 1102) *\/\n    char *header;\n\n    header = calloc(1, 1024);\n    \n    start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    \n    return header;\n}","target":1,"flaw_line_index":0,"hash":"0c65bcb2-c45b-4411-b211-0634bb77dcb6","idx":"087dcbcd-c09b-4cdc-9098-c75deba1fbed"}
{"func_before":"static char *get_header(FILE *fp)\n{\n    \/* First 1024 bytes of doc must be header (1.7 spec pg 1102) *\/\n    char *header = safe_calloc(1024);\n    long start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    return header;\n}","target":0,"flaw_line_index":0,"hash":"3e739ffb-f28e-49e4-856e-a68bfa2f81bb","idx":"335c5475-bc85-4800-9401-b267a56ea609"}
{"func_before":"  YYUSE (yyscanner);\n  YYUSE (lex_env);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n          case 16: \/* tokens  *\/\n#line 94 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1023 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n        break;\n\n    case 17: \/* token_sequence  *\/\n#line 95 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1029 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n        break;\n\n    case 18: \/* token_or_range  *\/\n#line 96 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1035 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n        break;\n\n    case 19: \/* token  *\/\n#line 97 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1041 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n        break;\n\n    case 21: \/* range  *\/\n#line 100 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1047 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n        break;\n\n    case 22: \/* alternatives  *\/\n#line 99 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1053 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n        break;\n\n    case 23: \/* byte  *\/\n#line 98 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1059 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n        break;\n\n\n      default:\n        break;\n    }","target":1,"flaw_line_index":0,"hash":"f1fafd6b-38d6-42de-a920-3f139e0623f2","idx":"099b374b-ba67-4c7c-a401-0d217a82f0cf"}
{"func_before":"  YYUSE (yyscanner);\n  YYUSE (lex_env);\n  if (!yymsg)\n    yymsg = \"Deleting\";\n  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);\n\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n          case 16: \/* tokens  *\/\n#line 101 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1030 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n        break;\n\n    case 17: \/* token_sequence  *\/\n#line 102 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1036 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n        break;\n\n    case 18: \/* token_or_range  *\/\n#line 103 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1042 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n        break;\n\n    case 19: \/* token  *\/\n#line 104 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1048 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n        break;\n\n    case 21: \/* range  *\/\n#line 107 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1054 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n        break;\n\n    case 22: \/* alternatives  *\/\n#line 106 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1060 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n        break;\n\n    case 23: \/* byte  *\/\n#line 105 \"hex_grammar.y\" \/* yacc.c:1257  *\/\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1066 \"hex_grammar.c\" \/* yacc.c:1257  *\/\n        break;\n\n\n      default:\n        break;\n    }","target":0,"flaw_line_index":0,"hash":"ef44d2d6-4912-4b3a-8f6b-846b402c3bf9","idx":"d5e9e723-6b3f-44e7-a532-4e615cf489c3"}
{"func_before":"void imap_quote_string (char *dest, size_t dlen, const char *src)\n{\n  static const char quote[] = \"\\\"\\\\\";\n  char *pt;\n  const char *s;\n\n  pt = dest;\n  s  = src;\n\n  *pt++ = '\"';\n  \/* save room for trailing quote-char *\/\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr (quote, *s))\n    {\n      dlen -= 2;\n      if (!dlen)\n\tbreak;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = 0;\n}","target":1,"flaw_line_index":0,"hash":"5d3efeb5-ccba-4fe2-aa41-3877ee7dba54","idx":"8c6ef02c-027a-4374-b189-2692ceebd3c1"}
{"func_before":"void imap_quote_string (char *dest, size_t dlen, const char *src)\n{\n  _imap_quote_string (dest, dlen, src, \"\\\"\\\\\");\n}","target":0,"flaw_line_index":0,"hash":"eb626795-a0cf-4562-964e-ab08f9f2bc9e","idx":"bd9fbc4b-08c6-4a40-bbf5-fc8159546748"}
{"func_before":"        printf(\"Please check that unicorn.dll\/unicorn.so is available as well as\\n\");\n        printf(\"any other dependent dll\/so files.\\n\");\n        printf(\"The easiest way is to place them in the same directory as this app.\\n\");\n        return 1;\n    }\n#endif\n    \n    test_arm();\n    printf(\"==========================\\n\");\n    test_thumb();\n\n    \/\/ dynamically free shared library\n#ifdef DYNLOAD\n    uc_dyn_free();\n#endif\n    \n    return 0;\n}","target":1,"flaw_line_index":0,"hash":"3c552bd5-39e7-4a76-845f-89ea17ef9868","idx":"ce9600ba-ad67-43f7-9247-85b89c1507ab"}
{"func_before":"        printf(\"Please check that unicorn.dll\/unicorn.so is available as well as\\n\");\n        printf(\"any other dependent dll\/so files.\\n\");\n        printf(\"The easiest way is to place them in the same directory as this app.\\n\");\n        return 1;\n    }\n#endif\n    \n    test_arm();\n    printf(\"==========================\\n\");\n    test_thumb();\n    printf(\"==========================\\n\");\n    test_thumb_ite();\n    \/\/ dynamically free shared library\n#ifdef DYNLOAD\n    uc_dyn_free();\n#endif\n    \n    return 0;\n}","target":0,"flaw_line_index":0,"hash":"e540478b-2551-473b-8629-84c9a4c4b943","idx":"4964979c-8204-4ff4-b62a-b5b11e2b6cbe"}
{"func_before":"#endif\n\n#ifdef HAVE_SETPGID\n    static_assert(_Py_IS_TYPE_SIGNED(pid_t), \"pid_t is unsigned\");\n    if (pgid_to_set >= 0) {\n        POSIX_CALL(setpgid(0, pgid_to_set));\n    }\n#endif\n\n#ifdef HAVE_SETGROUPS\n    if (extra_group_size > 0)\n        POSIX_CALL(setgroups(extra_group_size, extra_groups));\n#endif \/* HAVE_SETGROUPS *\/\n\n#ifdef HAVE_SETREGID\n    if (gid != (gid_t)-1)\n        POSIX_CALL(setregid(gid, gid));\n#endif \/* HAVE_SETREGID *\/\n\n#ifdef HAVE_SETREUID\n    if (uid != (uid_t)-1)\n        POSIX_CALL(setreuid(uid, uid));","target":1,"flaw_line_index":0,"hash":"c1696fe8-441f-4679-b404-c57374952fdf","idx":"07118388-2a5d-4846-a8fc-987ce9b3d67a"}
{"func_before":"#endif\n\n#ifdef HAVE_SETPGID\n    static_assert(_Py_IS_TYPE_SIGNED(pid_t), \"pid_t is unsigned\");\n    if (pgid_to_set >= 0) {\n        POSIX_CALL(setpgid(0, pgid_to_set));\n    }\n#endif\n\n#ifdef HAVE_SETGROUPS\n    if (extra_group_size >= 0) {\n        assert((extra_group_size == 0) == (extra_groups == NULL));\n        POSIX_CALL(setgroups(extra_group_size, extra_groups));\n    }\n#endif \/* HAVE_SETGROUPS *\/\n\n#ifdef HAVE_SETREGID\n    if (gid != (gid_t)-1)\n        POSIX_CALL(setregid(gid, gid));\n#endif \/* HAVE_SETREGID *\/\n\n#ifdef HAVE_SETREUID\n    if (uid != (uid_t)-1)\n        POSIX_CALL(setreuid(uid, uid));","target":0,"flaw_line_index":0,"hash":"23fc4624-e749-412b-a409-edb336c58cf0","idx":"98cea889-82cc-416f-ae59-b6f1a6a08dc2"}
{"func_before":"                goto fail;\n\n        r = sd_event_source_set_enabled(q->defer_event_source, SD_EVENT_ONESHOT);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_message_rewind(q->request, true);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_enqeue_for_read(sd_bus_message_get_bus(q->request), q->request);\n        if (r < 0)\n                goto fail;\n\n        return 1;\n\nfail:\n        log_debug_errno(r, \"Processing asynchronous PolicyKit reply failed, ignoring: %m\");\n        (void) sd_bus_reply_method_errno(q->request, r, NULL);\n        async_polkit_query_free(q);\n        return r;","target":1,"flaw_line_index":0,"hash":"6feb2e65-236b-42e8-8910-a53e4725f6a6","idx":"56dcdc03-f02f-43f9-9e72-25918e9aa1a3"}
{"func_before":"                goto fail;\n\n        r = sd_event_source_set_enabled(q->defer_event_source, SD_EVENT_ONESHOT);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_message_rewind(q->request, true);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_enqueue_for_read(sd_bus_message_get_bus(q->request), q->request);\n        if (r < 0)\n                goto fail;\n\n        return 1;\n\nfail:\n        log_debug_errno(r, \"Processing asynchronous PolicyKit reply failed, ignoring: %m\");\n        (void) sd_bus_reply_method_errno(q->request, r, NULL);\n        async_polkit_query_free(q);\n        return r;","target":0,"flaw_line_index":0,"hash":"bebef946-763c-4456-9539-c18645aae946","idx":"15afe260-19bb-4184-b826-729f9635acf6"}
{"func_before":"\t * For example, writing debug data to a port which you\n\t * have just faulted on is not going to work.\n\t *\/\n\n\ttsk = current;\n\tmm = tsk->mm;\n\n\t\/* Not an IO address, so reenable interrupts *\/\n\tlocal_irq_enable();\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n\n\t\/*\n\t * If we're in an interrupt or have no user\n\t * context, we must not take the fault..\n\t *\/\n\tif (in_atomic() || !mm)\n\t\tgoto no_context;\n\n\t\/* TLB misses upon some cache flushes get done under cli() *\/\n\tdown_read(&mm->mmap_sem);\n\tif (unlikely(fault & VM_FAULT_ERROR)) {\n\t\tif (fault & VM_FAULT_OOM)\n\t\t\tgoto out_of_memory;\n\t\telse if (fault & VM_FAULT_SIGBUS)\n\t\t\tgoto do_sigbus;\n\t\tBUG();\n\t}\n\n\tif (fault & VM_FAULT_MAJOR) {\n\t\ttsk->maj_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n\t\t\t\t     regs, address);\n\t} else {\n\t\ttsk->min_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n\t\t\t\t     regs, address);\n\t}\n\n\t\/* If we get here, the page fault has been handled.  Do the TLB refill\n\t   now from the newly-setup PTE, to avoid having to fault again right\n\t   away on the same instruction. *\/\n\tpte = lookup_pte (mm, address);\n\tif (!pte) {\n\t\t\/* From empirical evidence, we can get here, due to\n\t\t   !pte_present(pte).  (e.g. if a swap-in occurs, and the page","target":1,"flaw_line_index":0,"hash":"6602b1cb-e892-4890-9f27-3bba21bc29c7","idx":"18efb3a2-78cd-4e52-8e9d-394abce7fc0c"}
{"func_before":"\t * For example, writing debug data to a port which you\n\t * have just faulted on is not going to work.\n\t *\/\n\n\ttsk = current;\n\tmm = tsk->mm;\n\n\t\/* Not an IO address, so reenable interrupts *\/\n\tlocal_irq_enable();\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n\n\t\/*\n\t * If we're in an interrupt or have no user\n\t * context, we must not take the fault..\n\t *\/\n\tif (in_atomic() || !mm)\n\t\tgoto no_context;\n\n\t\/* TLB misses upon some cache flushes get done under cli() *\/\n\tdown_read(&mm->mmap_sem);\n\tif (unlikely(fault & VM_FAULT_ERROR)) {\n\t\tif (fault & VM_FAULT_OOM)\n\t\t\tgoto out_of_memory;\n\t\telse if (fault & VM_FAULT_SIGBUS)\n\t\t\tgoto do_sigbus;\n\t\tBUG();\n\t}\n\n\tif (fault & VM_FAULT_MAJOR) {\n\t\ttsk->maj_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,\n\t\t\t\t     regs, address);\n\t} else {\n\t\ttsk->min_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,\n\t\t\t\t     regs, address);\n\t}\n\n\t\/* If we get here, the page fault has been handled.  Do the TLB refill\n\t   now from the newly-setup PTE, to avoid having to fault again right\n\t   away on the same instruction. *\/\n\tpte = lookup_pte (mm, address);\n\tif (!pte) {\n\t\t\/* From empirical evidence, we can get here, due to\n\t\t   !pte_present(pte).  (e.g. if a swap-in occurs, and the page","target":0,"flaw_line_index":0,"hash":"d7798685-bd6e-4b85-a030-4ee09f58e3cf","idx":"5e116590-bab5-4b23-b1ff-3688d8ecbb3d"}
{"func_before":"\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPOFFSETS))\n\t\t\t{\n\t\t\t\tif (!isTiled(tif))\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_COLORMAP))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagColormap(tif,&ndir,dir))","target":1,"flaw_line_index":0,"hash":"41083cab-bedb-4ad6-87e4-47afa4f51246","idx":"d69f9747-2aa2-4890-a792-85c673d385a7"}
{"func_before":"\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEBYTECOUNTS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripbytecount))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPOFFSETS))\n\t\t\t{\n\t\t\t\tif (!isTiled(tif))\n\t\t\t\t{\n                    \/* td_stripoffset might be NULL in an odd OJPEG case. See\n                     *  tif_dirread.c around line 3634.\n                     * XXX: OJPEG hack.\n                     * If a) compression is OJPEG, b) it's not a tiled TIFF,\n                     * and c) the number of strips is 1,\n                     * then we tolerate the absence of stripoffsets tag,\n                     * because, presumably, all required data is in the\n                     * JpegInterchangeFormat stream.\n                     * We can get here when using tiffset on such a file.\n                     * See http:\/\/bugzilla.maptools.org\/show_bug.cgi?id=2500\n                    *\/\n                    if (tif->tif_dir.td_stripoffset != NULL &&\n                        !TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\n                        goto bad;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_COLORMAP))\n\t\t\t{\n\t\t\t\tif (!TIFFWriteDirectoryTagColormap(tif,&ndir,dir))","target":0,"flaw_line_index":0,"hash":"b73a8b22-f7ca-479f-a58e-c4d3288d7845","idx":"f3989cf4-b247-4c92-96ba-3e446d5511b8"}
{"func_before":"\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\n\t\/\/ Mark the box data as never having been constructed\n\t\/\/ so that we will not errantly attempt to destroy it later.\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {","target":1,"flaw_line_index":0,"hash":"d8c548a2-5f13-4e78-a24e-e113ecd4ff81","idx":"55f201a9-c340-43ff-a6c2-e0eb6e2710f3"}
{"func_before":"\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tjas_stream_t *tmpstream;\n\tuint_fast32_t len;\n\tuint_fast64_t extlen;\n\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jp2_box_create0())) {\n\t\tgoto error;\n\t}\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: \"\n\t  \"type=%c%s%c (0x%08x); length=%\"PRIuFAST32\"\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tJAS_DBGLOG(10, (\"big length\\n\"));\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");\n\t\t\textlen = 0xffffffffUL;\n\t\t}\n\t\tbox->len = extlen;\n\t\tbox->datalen = extlen - JP2_BOX_HDRLEN(true);\n\t} else {","target":0,"flaw_line_index":0,"hash":"73d4c5bd-bbc8-4c68-b260-e80e6d3fea84","idx":"afce4f42-0606-435d-8571-d82b1e8be874"}
{"func_before":"      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;","target":1,"flaw_line_index":0,"hash":"24c83b3b-871d-413a-a50c-87078fe0b832","idx":"95eccfe3-1f5a-46c8-8e32-e955efcd46fb"}
{"func_before":"      if (mid == 0 || !target_class) {\n        mrb_value exc = mrb_exc_new_lit(mrb, E_NOMETHOD_ERROR, \"super called outside of method\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;\n      }\n      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (!target_class || target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {\n      super_typeerror: ;\n        mrb_value exc = mrb_exc_new_lit(mrb, E_TYPE_ERROR,\n                                            \"self has wrong type to call super in this context\");\n        mrb_exc_set(mrb, exc);\n        goto L_RAISE;","target":0,"flaw_line_index":0,"hash":"3ac9a98b-8502-43dd-8ad8-6d8d1bc5493b","idx":"66801538-cd8b-4f85-8f33-b939b9993b03"}
{"func_before":"{\n    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st[2] = {NULL, NULL};\n    NSVStream *nst;\n    AVPacket *pkt;\n    int i, err = 0;\n    uint8_t auxcount; \/* number of aux metadata, also 4 bits of vsize *\/\n    uint32_t vsize;\n    uint16_t asize;\n    uint16_t auxsize;\n\n    if (nsv->ahead[0].data || nsv->ahead[1].data)\n        return 0; \/\/-1; \/* hey! eat what you've in your plate first! *\/\n\nnull_chunk_retry:\n    if (pb->eof_reached)\n        return -1;\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)\n        err = nsv_resync(s);\n\n    \/* map back streams to v,a *\/\n    if (s->nb_streams > 0)\n        st[s->streams[0]->id] = s->streams[0];\n    if (s->nb_streams > 1)\n        st[s->streams[1]->id] = s->streams[1];\n\n    if (vsize && st[NSV_ST_VIDEO]) {\n        nst = st[NSV_ST_VIDEO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_VIDEO];\n        av_get_packet(pb, pkt, vsize);\n        pkt->stream_index = st[NSV_ST_VIDEO]->index;\/\/NSV_ST_VIDEO;\n        pkt->dts = nst->frame_offset;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; \/* keyframe only likely on a sync frame *\/\n        for (i = 0; i < FFMIN(8, vsize); i++)\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02\"PRIx8\"\\n\",\n                   i, pkt->data[i]);\n    }\n    if(st[NSV_ST_VIDEO])\n        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;\n\n                if (bps == 8)\n                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n                samplerate \/= 4;\/* UGH ??? XXX *\/\n                channels = 1;\n                st[NSV_ST_AUDIO]->codecpar->channels = channels;\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                       bps, channels, samplerate);\n            }\n        }\n        av_get_packet(pb, pkt, asize);\n        pkt->stream_index = st[NSV_ST_AUDIO]->index;\/\/NSV_ST_AUDIO;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; \/* keyframe only likely on a sync frame *\/\n        if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n            \/* on a nsvs frame we have new information on a\/v sync *\/\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);\n            pkt->dts *= (int64_t)1000        * nsv->framerate.den;\n            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;\n            av_log(s, AV_LOG_TRACE, \"NSV AUDIO: sync:%\"PRId16\", dts:%\"PRId64,\n                   nsv->avsync, pkt->dts);\n        }","target":1,"flaw_line_index":0,"hash":"bf5d0468-8948-4f68-8410-8cf490c461d3","idx":"224517ff-70c2-4e7a-804f-e82ec8ac365e"}
{"func_before":"    NSVContext *nsv = s->priv_data;\n    AVIOContext *pb = s->pb;\n    AVStream *st[2] = {NULL, NULL};\n    NSVStream *nst;\n    AVPacket *pkt;\n    int i, err = 0;\n    uint8_t auxcount; \/* number of aux metadata, also 4 bits of vsize *\/\n    uint32_t vsize;\n    uint16_t asize;\n    uint16_t auxsize;\n    int ret;\n\n    if (nsv->ahead[0].data || nsv->ahead[1].data)\n        return 0; \/\/-1; \/* hey! eat what you've in your plate first! *\/\n\nnull_chunk_retry:\n    if (pb->eof_reached)\n        return -1;\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)\n        err = nsv_resync(s);\n\n    \/* map back streams to v,a *\/\n    if (s->nb_streams > 0)\n        st[s->streams[0]->id] = s->streams[0];\n    if (s->nb_streams > 1)\n        st[s->streams[1]->id] = s->streams[1];\n\n    if (vsize && st[NSV_ST_VIDEO]) {\n        nst = st[NSV_ST_VIDEO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_VIDEO];\n        if ((ret = av_get_packet(pb, pkt, vsize)) < 0)\n            return ret;\n        pkt->stream_index = st[NSV_ST_VIDEO]->index;\/\/NSV_ST_VIDEO;\n        pkt->dts = nst->frame_offset;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; \/* keyframe only likely on a sync frame *\/\n        for (i = 0; i < FFMIN(8, vsize); i++)\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02\"PRIx8\"\\n\",\n                   i, pkt->data[i]);\n    }\n    if(st[NSV_ST_VIDEO])\n        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;\n\n                if (bps == 8)\n                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n                samplerate \/= 4;\/* UGH ??? XXX *\/\n                channels = 1;\n                st[NSV_ST_AUDIO]->codecpar->channels = channels;\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                       bps, channels, samplerate);\n            }\n        }\n        if ((ret = av_get_packet(pb, pkt, asize)) < 0)\n            return ret;\n        pkt->stream_index = st[NSV_ST_AUDIO]->index;\/\/NSV_ST_AUDIO;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; \/* keyframe only likely on a sync frame *\/\n        if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n            \/* on a nsvs frame we have new information on a\/v sync *\/\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);\n            pkt->dts *= (int64_t)1000        * nsv->framerate.den;\n            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;\n            av_log(s, AV_LOG_TRACE, \"NSV AUDIO: sync:%\"PRId16\", dts:%\"PRId64,\n                   nsv->avsync, pkt->dts);\n        }","target":0,"flaw_line_index":0,"hash":"f77955c1-c9fa-4476-b761-09cb446d7440","idx":"45684dd9-0bfb-4083-8264-5beabc904960"}
{"func_before":"    State(IfOp* kernel, OpKernelContext* ctx, bool cond, FHandle then_handle,\n          FHandle else_handle, DoneCallback done)\n        : kernel_(kernel),\n          ctx_(ctx),\n          cond_(cond),\n          then_handle_(then_handle),\n          else_handle_(else_handle),\n          done_(std::move(done)),\n          lib_(CHECK_NOTNULL(ctx_->function_library())) {\n      SetRunOptions(ctx_, &opts_, true \/* always_collect_stats *\/);\n      for (int i = 1; i < ctx_->num_inputs(); ++i) {\n        args_.push_back(ctx_->input(i));\n      }\n    }","target":1,"flaw_line_index":0,"hash":"4595c6f0-3948-4728-b617-c7607f3010d7","idx":"7b8d3edc-9656-4cfd-8046-d02109e405b5"}
{"func_before":"    State(IfOp* kernel, OpKernelContext* ctx, bool cond, FHandle then_handle,\n          FHandle else_handle, DoneCallback done)\n        : kernel_(kernel),\n          ctx_(ctx),\n          cond_(cond),\n          then_handle_(then_handle),\n          else_handle_(else_handle),\n          done_(std::move(done)),\n          lib_(CHECK_NOTNULL(ctx_->function_library())),\n          opts_(ctx->step_id()) {\n      SetRunOptions(ctx_, &opts_, true \/* always_collect_stats *\/);\n      for (int i = 1; i < ctx_->num_inputs(); ++i) {\n        args_.push_back(ctx_->input(i));\n      }\n    }","target":0,"flaw_line_index":0,"hash":"94c50595-2eb5-4fd6-b09c-3d557df63d2c","idx":"0249edc5-851f-4f80-9b00-c7afe7441806"}
{"func_before":"\telse\n\t{\n\t  _pdfioFileError(tb->pdf, \"Syntax error: '>%c'.\", ch);\n\t  return (false);\n\t}\n\tbreak;\n  }\n\n  *bufptr = '\\0';\n\n  PDFIO_DEBUG(\"_pdfioTokenRead: Read '%s'.\\n\", buffer);\n\n  return (bufptr > buffer);\n}","target":1,"flaw_line_index":0,"hash":"1128e784-d4f3-4611-b3b0-38a5d28eba7a","idx":"512a4825-d823-4d70-a7b9-103d294aaf23"}
{"func_before":"\telse\n\t{\n\t  _pdfioFileError(tb->pdf, \"Syntax error: '>%c'.\", ch);\n\t  return (false);\n\t}\n\tbreak;\n  }\n\n  *bufptr = '\\0';\n\n\/\/  PDFIO_DEBUG(\"_pdfioTokenRead: Read '%s'.\\n\", buffer);\n\n  return (bufptr > buffer);\n}","target":0,"flaw_line_index":0,"hash":"37500a0a-6e8e-498d-97cb-effce9c7bd16","idx":"f8ff9db4-72bf-4b52-9c00-f17b2617699f"}
{"func_before":"static int simulate_llsc(struct pt_regs *regs, unsigned int opcode)\n{\n\tif ((opcode & OPCODE) == LL) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, 0, regs, 0);\n\t\treturn simulate_ll(regs, opcode);\n\t}\n\tif ((opcode & OPCODE) == SC) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, 0, regs, 0);\n\t\treturn simulate_sc(regs, opcode);\n\t}\n\n\treturn -1;\t\t\t\/* Must be something else ... *\/\n}","target":1,"flaw_line_index":0,"hash":"2843511a-c2d0-461e-8a04-3b53f564ca3f","idx":"3a5e527a-138e-4df2-bb23-4c1f32153282"}
{"func_before":"static int simulate_llsc(struct pt_regs *regs, unsigned int opcode)\n{\n\tif ((opcode & OPCODE) == LL) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, regs, 0);\n\t\treturn simulate_ll(regs, opcode);\n\t}\n\tif ((opcode & OPCODE) == SC) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, regs, 0);\n\t\treturn simulate_sc(regs, opcode);\n\t}\n\n\treturn -1;\t\t\t\/* Must be something else ... *\/\n}","target":0,"flaw_line_index":0,"hash":"484deb11-e811-4694-b3c2-e8db831e84dd","idx":"aed3e0c9-edbf-48e6-b24e-6e738e62f080"}
{"func_before":"      JpegInput( String filename ) : filename_( std::move( filename )) {\n         infile_ = std::fopen( filename_.c_str(), \"rb\" );\n         if( infile_ == nullptr ) {\n            if( !FileHasExtension( filename_ )) {\n               filename_ = FileAddExtension( filename_, \"jpg\" ); \/\/ Try with \"jpg\" extension\n               infile_ = std::fopen( filename_.c_str(), \"rb\" );\n               if( infile_ == nullptr ) {\n                  filename_ = FileAddExtension( filename_, \"jpeg\" ); \/\/ Try with \"jpeg\" extension\n                  infile_ = std::fopen( filename_.c_str(), \"rb\" );\n               }\n            }\n         }\n         if( infile_ == nullptr ) {\n            DIP_THROW_RUNTIME( \"Could not open the specified JPEG file\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         if( setjmp( jerr_.setjmp_buffer )) {\n            \/\/ If we get here, the JPEG code has signaled an error.\n            DIP_THROW_RUNTIME( \"Error reading JPEG file.\" );\n         }\n         jpeg_create_decompress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_src( &cinfo_, infile_ );\n         jpeg_read_header( &cinfo_, TRUE );\n      }","target":1,"flaw_line_index":0,"hash":"2dd63396-8c2b-4aa1-9895-07995b28e508","idx":"54397b1f-733a-4c0e-9fa3-bf763e5b22a4"}
{"func_before":"      JpegInput( String filename, std::jmp_buf const& setjmp_buffer ) : filename_( std::move( filename )) {\n         infile_ = std::fopen( filename_.c_str(), \"rb\" );\n         if( infile_ == nullptr ) {\n            if( !FileHasExtension( filename_ )) {\n               filename_ = FileAddExtension( filename_, \"jpg\" ); \/\/ Try with \"jpg\" extension\n               infile_ = std::fopen( filename_.c_str(), \"rb\" );\n               if( infile_ == nullptr ) {\n                  filename_ = FileAddExtension( filename_, \"jpeg\" ); \/\/ Try with \"jpeg\" extension\n                  infile_ = std::fopen( filename_.c_str(), \"rb\" );\n               }\n            }\n         }\n         if( infile_ == nullptr ) {\n            DIP_THROW_RUNTIME( \"Could not open the specified JPEG file\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         std::memcpy( jerr_.setjmp_buffer, setjmp_buffer, sizeof( setjmp_buffer ));\n         jpeg_create_decompress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_src( &cinfo_, infile_ );\n         jpeg_read_header( &cinfo_, TRUE );\n      }","target":0,"flaw_line_index":0,"hash":"f7f6df54-0366-4c79-8882-f1c27e21a77c","idx":"b6bd5714-349e-4799-8775-538bb6c26add"}
{"func_before":"\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps; ++pi->compno,\n\t  ++pi->picomp) {\n\t\tpirlvl = pi->picomp->pirlvls;\n\t\tpi->xstep = pi->picomp->hsamp * (1 << (pirlvl->prcwidthexpn +\n\t\t  pi->picomp->numrlvls - 1));\n\t\tpi->ystep = pi->picomp->vsamp * (1 << (pirlvl->prcheightexpn +\n\t\t  pi->picomp->numrlvls - 1));\n\t\tfor (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];\n\t\t  rlvlno < pi->picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp * (1 <<\n\t\t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls -\n\t\t\t  rlvlno - 1)));\n\t\t\tpi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp * (1 <<\n\t\t\t  (pirlvl->prcheightexpn + pi->picomp->numrlvls -\n\t\t\t  rlvlno - 1)));\n\t\t}\n\t\tfor (pi->y = pi->ystart; pi->y < pi->yend;\n\t\t  pi->y += pi->ystep - (pi->y % pi->ystep)) {\n\t\t\tfor (pi->x = pi->xstart; pi->x < pi->xend;\n\t\t\t  pi->x += pi->xstep - (pi->x % pi->xstep)) {\n\t\t\t\tfor (pi->rlvlno = pchg->rlvlnostart,\n\t\t\t\t  pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\t  pi->rlvlno < pi->picomp->numrlvls && pi->rlvlno <\n\t\t\t\t  pchg->rlvlnoend; ++pi->rlvlno, ++pi->pirlvl) {\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {","target":1,"flaw_line_index":0,"hash":"c2b793ee-8f0f-47cd-858a-1f1693ab10ea","idx":"66eb499b-2441-4338-ad13-39a04554d265"}
{"func_before":"\tif (!pi->prgvolfirst) {\n\t\tgoto skip;\n\t} else {\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps; ++pi->compno,\n\t  ++pi->picomp) {\n\t\tpirlvl = pi->picomp->pirlvls;\n\t\tpi->xstep = pi->picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls - 1));\n\t\tpi->ystep = pi->picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcheightexpn + pi->picomp->numrlvls - 1));\n\t\tfor (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];\n\t\t  rlvlno < pi->picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp *\n\t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcwidthexpn +\n\t\t\t  pi->picomp->numrlvls - rlvlno - 1)));\n\t\t\tpi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp *\n\t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcheightexpn +\n\t\t\t  pi->picomp->numrlvls - rlvlno - 1)));\n\t\t}\n\t\tfor (pi->y = pi->ystart; pi->y < pi->yend;\n\t\t  pi->y += pi->ystep - (pi->y % pi->ystep)) {\n\t\t\tfor (pi->x = pi->xstart; pi->x < pi->xend;\n\t\t\t  pi->x += pi->xstep - (pi->x % pi->xstep)) {\n\t\t\t\tfor (pi->rlvlno = pchg->rlvlnostart,\n\t\t\t\t  pi->pirlvl = &pi->picomp->pirlvls[pi->rlvlno];\n\t\t\t\t  pi->rlvlno < pi->picomp->numrlvls && pi->rlvlno <\n\t\t\t\t  pchg->rlvlnoend; ++pi->rlvlno, ++pi->pirlvl) {\n\t\t\t\t\tif (pi->pirlvl->numprcs == 0) {","target":0,"flaw_line_index":0,"hash":"c9d05570-4d59-49ea-a69e-9236b5efa160","idx":"89053e35-b21e-4818-8d0c-fd451af3bf25"}
{"func_before":"horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\n\tunsigned char* cp = (unsigned char*) cp0;\n\tassert((cc%stride)==0);\n\tif (cc > stride) {\n\t\t\/*\n\t\t * Pipeline the most common cases.\n\t\t *\/\n\t\tif (stride == 3)  {\n\t\t\tunsigned int cr = cp[0];\n\t\t\tunsigned int cg = cp[1];\n\t\t\tunsigned int cb = cp[2];\n\t\t\tcc -= 3;\n\t\t\tcp += 3;\n\t\t\t\tcp += 4;\n\t\t\t}\n\t\t} else  {\n\t\t\tcc -= stride;\n\t\t\tdo {\n\t\t\t\tREPEAT4(stride, cp[stride] =\n\t\t\t\t\t(unsigned char) ((cp[stride] + *cp) & 0xff); cp++)\n\t\t\t\tcc -= stride;\n\t\t\t} while (cc>0);\n\t\t}\n\t}\n}","target":1,"flaw_line_index":0,"hash":"c7095cde-6433-4a70-bbf9-0ce392070d5b","idx":"a3ba90cd-1b2a-423d-b842-6c71bda588fc"}
{"func_before":"horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\n\tunsigned char* cp = (unsigned char*) cp0;\n    if((cc%stride)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"horAcc8\",\n                     \"%s\", \"(cc%stride)!=0\");\n        return 0;\n    }\n\n\tif (cc > stride) {\n\t\t\/*\n\t\t * Pipeline the most common cases.\n\t\t *\/\n\t\tif (stride == 3)  {\n\t\t\tunsigned int cr = cp[0];\n\t\t\tunsigned int cg = cp[1];\n\t\t\tunsigned int cb = cp[2];\n\t\t\tcc -= 3;\n\t\t\tcp += 3;\n\t\t\t}\n\t\t} else  {\n\t\t\tcc -= stride;\n\t\t\tdo {\n\t\t\t\tREPEAT4(stride, cp[stride] =\n\t\t\t\t\t(unsigned char) ((cp[stride] + *cp) & 0xff); cp++)\n\t\t\t\tcc -= stride;\n\t\t\t} while (cc>0);\n\t\t}\n\t}\n\treturn 1;\n}","target":0,"flaw_line_index":0,"hash":"9d3187d9-8982-4854-a494-bcb0025acd14","idx":"6b073d11-3dd3-4975-bcae-2a58c4eb3da9"}
{"func_before":"\t\t\t\t\t      needed | smc->opt_payloads |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_VID) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_N) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_D) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_CR) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_CERT))) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"%smessage ignored because it contains a payload type (%s) unexpected by state %s\",\n\t\t\t\t\t\texcuse,\n\t\t\t\t\t\tenum_show(&ikev1_payload_names, np),\n\t\t\t\t\t\tst->st_state->name);\n\t\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\t\tSEND_NOTIFICATION(INVALID_PAYLOAD_TYPE);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tDBG(DBG_PARSING,\n\t\t\t\t    DBG_log(\"got payload 0x%\" PRIxLSET\"  (%s) needed: 0x%\" PRIxLSET \" opt: 0x%\" PRIxLSET,\n\t\t\t\t\t    s, enum_show(&ikev1_payload_names, np),\n\t\t\t\t\t    needed, smc->opt_payloads));","target":1,"flaw_line_index":0,"hash":"de04aec7-4c5a-42f1-8451-0829875d6ca6","idx":"56592b91-58fa-4abb-a7d4-e4e68b5abf5b"}
{"func_before":"\t\t\t\t\t      needed | smc->opt_payloads |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_VID) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_N) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_D) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_CR) |\n\t\t\t\t\t      LELEM(ISAKMP_NEXT_CERT))) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"%smessage ignored because it contains a payload type (%s) unexpected by state %s\",\n\t\t\t\t\t\texcuse,\n\t\t\t\t\t\tenum_show(&ikev1_payload_names, np),\n\t\t\t\t\t\tfinite_states[smc->state]->name);\n\t\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\t\tSEND_NOTIFICATION(INVALID_PAYLOAD_TYPE);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tDBG(DBG_PARSING,\n\t\t\t\t    DBG_log(\"got payload 0x%\" PRIxLSET\"  (%s) needed: 0x%\" PRIxLSET \" opt: 0x%\" PRIxLSET,\n\t\t\t\t\t    s, enum_show(&ikev1_payload_names, np),\n\t\t\t\t\t    needed, smc->opt_payloads));","target":0,"flaw_line_index":0,"hash":"cfdc09a9-5c0d-498f-be74-15aefebbb3ed","idx":"7f7f01d6-91b6-446b-903e-82e62fff8b3b"}
{"func_before":"                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, NULL, LINENO(ch), ch->n_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; \/* the name *\/\n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \/* the comma, if present *\/\n                break;\n            case TYPE_COMMENT:\n                \/* arg will be equal to the last argument processed *\/\n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                i += 1;\n                break;\n            case DOUBLESTAR:\n                return i;\n            default:","target":1,"flaw_line_index":0,"hash":"6497612b-d6fe-48cd-b349-7569181c3b0d","idx":"33ec3b2c-82c6-4f12-8e06-ce9ebfe2875b"}
{"func_before":"                if (!argname)\n                    goto error;\n                if (forbidden_name(c, argname, ch, 0))\n                    goto error;\n                arg = arg(argname, annotation, NULL, LINENO(ch), ch->n_col_offset,\n                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; \/* the name *\/\n                if (TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \/* the comma, if present *\/\n                break;\n            case TYPE_COMMENT:\n                \/* arg will be equal to the last argument processed *\/\n                arg->type_comment = NEW_TYPE_COMMENT(ch);\n                i += 1;\n                break;\n            case DOUBLESTAR:\n                return i;\n            default:","target":0,"flaw_line_index":0,"hash":"3a54238b-e255-4521-9554-0966536c5bcc","idx":"fdb69fc6-c2a5-4f13-9401-99f0d2ca8ec1"}
{"func_before":"  g_auto(GStrv) sandbox_expose = NULL;\n  g_auto(GStrv) sandbox_expose_ro = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd_ro = NULL;\n  g_autoptr(GOutputStream) instance_id_out_stream = NULL;\n  guint sandbox_flags = 0;\n  gboolean sandboxed;\n  gboolean expose_pids;\n  gboolean share_pids;\n  gboolean notify_start;\n  gboolean devel;\n\n  child_setup_data.instance_id_fd = -1;\n\n  if (fd_list != NULL)\n    fds = g_unix_fd_list_peek_fds (fd_list, &fds_len);\n\n  app_info = g_object_get_data (G_OBJECT (invocation), \"app-info\");\n  g_assert (app_info != NULL);\n\n  app_id = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_APPLICATION,\n                                  FLATPAK_METADATA_KEY_NAME, NULL);\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--device=dri\"));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--session-bus\"));\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--a11y-bus\"));\n    }\n  else\n    {\n      for (i = 0; extra_args != NULL && extra_args[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));\n    }\n\n  expose_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0;\n  share_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS) != 0;\n\n  if (expose_pids || share_pids)\n    {\n      g_autofree char *instance_id = NULL;\n      int sender_pid1 = 0;\n","target":1,"flaw_line_index":0,"hash":"10d7747d-5bad-4efb-b910-f33e53afc546","idx":"8c8ea497-8c6c-4501-a953-aada24444704"}
{"func_before":"  g_auto(GStrv) sandbox_expose_ro = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd_ro = NULL;\n  g_autoptr(GOutputStream) instance_id_out_stream = NULL;\n  guint sandbox_flags = 0;\n  gboolean sandboxed;\n  gboolean expose_pids;\n  gboolean share_pids;\n  gboolean notify_start;\n  gboolean devel;\n  g_autoptr(GString) env_string = g_string_new (\"\");\n\n  child_setup_data.instance_id_fd = -1;\n  child_setup_data.env_fd = -1;\n\n  if (fd_list != NULL)\n    fds = g_unix_fd_list_peek_fds (fd_list, &fds_len);\n\n  app_info = g_object_get_data (G_OBJECT (invocation), \"app-info\");\n  g_assert (app_info != NULL);\n\n  app_id = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_APPLICATION,\n                                  FLATPAK_METADATA_KEY_NAME, NULL);\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--device=dri\"));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--session-bus\"));\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--a11y-bus\"));\n    }\n  else\n    {\n      for (i = 0; extra_args != NULL && extra_args[i] != NULL; i++)\n        {\n          if (g_str_has_prefix (extra_args[i], \"--env=\"))\n            {\n              const char *var_val = extra_args[i] + strlen (\"--env=\");\n\n              if (var_val[0] == '\\0' || var_val[0] == '=')\n                {\n                  g_warning (\"Environment variable in extra-args has empty name\");\n                  continue;\n                }\n\n              if (strchr (var_val, '=') == NULL)\n                {\n                  g_warning (\"Environment variable in extra-args has no value\");\n                  continue;\n                }\n\n              g_string_append (env_string, var_val);\n              g_string_append_c (env_string, '\\0');\n            }\n          else\n            {\n              g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));\n            }\n        }\n    }\n\n  if (env_string->len > 0)\n    {\n      g_auto(GLnxTmpfile) env_tmpf  = { 0, };\n\n      if (!flatpak_buffer_to_sealed_memfd_or_tmpfile (&env_tmpf, \"environ\",\n                                                      env_string->str,\n                                                      env_string->len, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      child_setup_data.env_fd = glnx_steal_fd (&env_tmpf.fd);\n      g_ptr_array_add (flatpak_argv,\n                       g_strdup_printf (\"--env-fd=%d\",\n                                        child_setup_data.env_fd));\n    }\n\n  expose_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0;\n  share_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS) != 0;\n\n  if (expose_pids || share_pids)\n    {\n      g_autofree char *instance_id = NULL;\n      int sender_pid1 = 0;\n","target":0,"flaw_line_index":0,"hash":"e74f13c7-c47b-4ccd-9519-846610e8913d","idx":"25602671-14f2-4d52-89dd-e0ae98692fec"}
{"func_before":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* dims = GetInput(context, node, kDimsTensor);\n  const TfLiteTensor* value = GetInput(context, node, kValueTensor);\n\n  \/\/ Make sure the 1st input tensor is 1-D.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(dims), 1);\n\n  \/\/ Make sure the 1st input tensor is int32 or int64.\n  const auto dtype = dims->type;\n  TF_LITE_ENSURE(context, dtype == kTfLiteInt32 || dtype == kTfLiteInt64);\n\n  \/\/ Make sure the 2nd input tensor is a scalar.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(value), 0);\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  output->type = value->type;\n\n  if (IsConstantTensor(dims)) {\n    TF_LITE_ENSURE_OK(context, ResizeOutput(context, dims, output));\n  } else {\n    SetTensorToDynamic(output);\n  }\n  return kTfLiteOk;\n}","target":1,"flaw_line_index":0,"hash":"b3613c24-6b72-4b3f-8f81-3cc806554b47","idx":"08781cc4-ac2f-4074-aa8e-641ae16cc3b3"}
{"func_before":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* dims;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kDimsTensor, &dims));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kValueTensor, &value));\n\n  \/\/ Make sure the 1st input tensor is 1-D.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(dims), 1);\n\n  \/\/ Make sure the 1st input tensor is int32 or int64.\n  const auto dtype = dims->type;\n  TF_LITE_ENSURE(context, dtype == kTfLiteInt32 || dtype == kTfLiteInt64);\n\n  \/\/ Make sure the 2nd input tensor is a scalar.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(value), 0);\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  output->type = value->type;\n\n  if (IsConstantTensor(dims)) {\n    TF_LITE_ENSURE_OK(context, ResizeOutput(context, dims, output));\n  } else {\n    SetTensorToDynamic(output);\n  }\n  return kTfLiteOk;\n}","target":0,"flaw_line_index":0,"hash":"e5a8d5af-7b08-434f-a630-e04fba228854","idx":"1b365267-0b4c-411a-9f0e-303916b8c629"}
{"func_before":"{\n    int flush;\n    int status;\n    int footer_start;\n    uint8_t *pb;\n    size_t out_size;\n    void *out_buf;\n    z_stream strm;\n    mz_ulong crc;\n\n    out_size = in_len + 32;\n    out_buf = flb_malloc(out_size);\n    if (!out_buf) {\n        flb_errno();\n        flb_error(\"[gzip] could not allocate outgoing buffer\");\n        return -1;\n    }\n\n    \/* Initialize streaming buffer context *\/\n    memset(&strm, '\\0', sizeof(strm));\n    strm.zalloc    = Z_NULL;\n    strm.zfree     = Z_NULL;","target":1,"flaw_line_index":0,"hash":"b986de2c-ab2a-474b-8acf-e1317b44cc78","idx":"90f09bbf-2848-4ab8-9521-fcfe6cbed7db"}
{"func_before":"{\n    int flush;\n    int status;\n    int footer_start;\n    uint8_t *pb;\n    size_t out_size;\n    void *out_buf;\n    z_stream strm;\n    mz_ulong crc;\n\n\n    \/*\n     * GZIP relies on an algorithm with worst-case expansion\n     * of 5 bytes per 32KB data. This means we need to create a variable\n     * length output, that depends on the input length.\n     * See RFC 1951 for details.\n     *\/\n    int max_input_expansion = ((int)(in_len \/ 32000) + 1) * 5;\n\n    \/*\n     * Max compressed size is equal to sum of:\n     *   10 byte header\n     *   8 byte foot\n     *   max input expansion\n     *   size of input\n     *\/\n    out_size = 10 + 8 + max_input_expansion + in_len;\n    out_buf = flb_malloc(out_size);\n\n    if (!out_buf) {\n        flb_errno();\n        flb_error(\"[gzip] could not allocate outgoing buffer\");\n        return -1;\n    }\n\n    \/* Initialize streaming buffer context *\/\n    memset(&strm, '\\0', sizeof(strm));\n    strm.zalloc    = Z_NULL;\n    strm.zfree     = Z_NULL;","target":0,"flaw_line_index":0,"hash":"a1a1a827-c7d5-4a5b-b2ce-18bbc18448be","idx":"cdf62bb3-cfb8-4be8-b0fb-8fd301731e02"}
{"func_before":"header_seek (SF_PRIVATE *psf, sf_count_t position, int whence)\n{\n\tswitch (whence)\n\t{\tcase SEEK_SET :\n\t\t\tif (position > SIGNED_SIZEOF (psf->header))\n\t\t\t{\t\/* Too much header to cache so just seek instead. *\/\n\t\t\t\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\t\t\tif (position > psf->headend)\n\t\t\t\tpsf->headend += psf_fread (psf->header + psf->headend, 1, position - psf->headend, psf) ;\n\t\t\tpsf->headindex = position ;\n\t\t\tbreak ;\n\n\t\tcase SEEK_CUR :\n\t\t\tif (psf->headindex + position < 0)\n\t\t\t\tbreak ;\n\n\t\t\tif (psf->headindex >= SIGNED_SIZEOF (psf->header))\n\t\t\t{\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->headindex + position <= psf->headend)\n\t\t\t{\tpsf->headindex += position ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->headindex + position > SIGNED_SIZEOF (psf->header))\n\t\t\t{\t\/* Need to jump this without caching it. *\/\n\t\t\t\tpsf->headindex = psf->headend ;\n\t\t\t\tpsf_fseek (psf, position, SEEK_CUR) ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\n\t\t\tpsf->headend += psf_fread (psf->header + psf->headend, 1, position - (psf->headend - psf->headindex), psf) ;\n\t\t\tpsf->headindex = psf->headend ;\n\t\t\tbreak ;\n\n\t\tcase SEEK_END :\n\t\tdefault :\n\t\t\tpsf_log_printf (psf, \"Bad whence param in header_seek().\\n\") ;\n\t\t\tbreak ;\n\t\t} ;\n\n\treturn ;\n} \/* header_seek *\/","target":1,"flaw_line_index":0,"hash":"f764cd2e-1e76-453c-88f9-61fcec96fc54","idx":"93e005ad-65a9-4082-a27a-b5ae7502350f"}
{"func_before":"header_seek (SF_PRIVATE *psf, sf_count_t position, int whence)\n{\n\tswitch (whence)\n\t{\tcase SEEK_SET :\n\t\t\tif (psf->header.indx + position >= psf->header.len)\n\t\t\t\tpsf_bump_header_allocation (psf, position) ;\n\t\t\tif (position > psf->header.len)\n\t\t\t{\t\/* Too much header to cache so just seek instead. *\/\n\t\t\t\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\t\t\tif (position > psf->header.end)\n\t\t\t\tpsf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, position - psf->header.end, psf) ;\n\t\t\tpsf->header.indx = position ;\n\t\t\tbreak ;\n\n\t\tcase SEEK_CUR :\n\t\t\tif (psf->header.indx + position >= psf->header.len)\n\t\t\t\tpsf_bump_header_allocation (psf, position) ;\n\n\t\t\tif (psf->header.indx + position < 0)\n\t\t\t\tbreak ;\n\n\t\t\tif (psf->header.indx >= psf->header.len)\n\t\t\t{\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->header.indx + position <= psf->header.end)\n\t\t\t{\tpsf->header.indx += position ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->header.indx + position > psf->header.len)\n\t\t\t{\t\/* Need to jump this without caching it. *\/\n\t\t\t\tpsf->header.indx = psf->header.end ;\n\t\t\t\tpsf_fseek (psf, position, SEEK_CUR) ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\n\t\t\tpsf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, position - (psf->header.end - psf->header.indx), psf) ;\n\t\t\tpsf->header.indx = psf->header.end ;\n\t\t\tbreak ;\n\n\t\tcase SEEK_END :\n\t\tdefault :\n\t\t\tpsf_log_printf (psf, \"Bad whence param in header_seek().\\n\") ;\n\t\t\tbreak ;\n\t\t} ;\n\n\treturn ;\n} \/* header_seek *\/","target":0,"flaw_line_index":0,"hash":"f9412e70-5624-4ce6-b85a-5b837c2ca572","idx":"5a177240-5b5d-4b79-b82c-ea8c9fba46c2"}
{"func_before":"\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->tread_sem);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;","target":1,"flaw_line_index":0,"hash":"7e329405-24ce-44e0-96eb-233589594030","idx":"efdccfc1-808b-4d66-bdce-8bc050334738"}
{"func_before":"\n\terr = nonseekable_open(inode, file);\n\tif (err < 0)\n\t\treturn err;\n\n\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->ioctl_lock);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {\n\t\tkfree(tu);\n\t\treturn -ENOMEM;\n\t}\n\tfile->private_data = tu;\n\treturn 0;","target":0,"flaw_line_index":0,"hash":"12d15b06-f12e-4d98-ab55-efb3157d6064","idx":"bb26bd76-36e0-4c2c-9bb0-dd820d5d2052"}
{"func_before":"#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"Code clear (free=%hu) npix=%ld\\n\", free, npix);\n#endif \/* !defined(NGIFLIB_NO_FILE) *\/\n\t\t\t\/* clear *\/\n\t\t\tfree = clr + 2;\n\t\t\tcontext.nbbit = i->imgbits + 1;\n\t\t\tcontext.max = clr + clr - 1; \/* (1 << context.nbbit) - 1 *\/\n\t\t\tact_code = GetGifWord(i, &context);\n\t\t\tcasspecial = (u8)act_code;\n\t\t\told_code = act_code;\n\t\t\tWritePixel(i, &context, casspecial); npix--;\n\t\t} else {\n\t\t\tread_byt = act_code;\n\t\t\tif(act_code >= free) {\t\/* code pas encore dans alphabet *\/\n\/*\t\t\t\tprintf(\"Code pas dans alphabet : %d>=%d push %d\\n\", act_code, free, casspecial); *\/\n\t\t\t\t*(--stackp) = casspecial; \/* dernier debut de chaine ! *\/\n\t\t\t\tact_code = old_code;\n\t\t\t}\n\/*\t\t\tprintf(\"actcode=%d\\n\", act_code); *\/\n\t\t\twhile(act_code > clr) { \/* code non concret *\/\n\t\t\t\t\/* fillstackloop empile les suffixes ! *\/\n\t\t\t\t*(--stackp) = ab_suffx[act_code];\n\t\t\t\tact_code = ab_prfx[act_code];\t\/* prefixe *\/\n\t\t\t}\n\t\t\t\/* act_code est concret *\/\n\t\t\tcasspecial = (u8)act_code;\t\/* dernier debut de chaine ! *\/\n\t\t\t*(--stackp) = casspecial;\t\/* push on stack *\/\n\t\t\tWritePixels(i, &context, stackp, stack_top - stackp);\t\/* unstack all pixels at once *\/\n\t\t\tnpix -= (stack_top - stackp);\n\t\t\tstackp = stack_top;\n\/*\t\t\tputchar('\\n'); *\/\n\t\t\tif(free < 4096) { \/* la taille du dico est 4096 max ! *\/\n\t\t\t\tab_prfx[free] = old_code;\n\t\t\t\tab_suffx[free] = (u8)act_code;\n\t\t\t\tfree++;\n\t\t\t\tif((free > context.max) && (context.nbbit < 12)) {\n\t\t\t\t\tcontext.nbbit++;\t\/* 1 bit de plus pour les codes LZW *\/\n\t\t\t\t\tcontext.max += context.max + 1;","target":1,"flaw_line_index":0,"hash":"c0a516fa-7e0f-4b31-b765-5f06a0d55f75","idx":"05923f10-1f3b-44a5-b435-6127c2dce1e8"}
{"func_before":"#if !defined(NGIFLIB_NO_FILE)\n\t\t\tif(i->parent && i->parent->log) fprintf(i->parent->log, \"Code clear (free=%hu) npix=%ld\\n\", free, npix);\n#endif \/* !defined(NGIFLIB_NO_FILE) *\/\n\t\t\t\/* clear *\/\n\t\t\tfree = clr + 2;\n\t\t\tcontext.nbbit = i->imgbits + 1;\n\t\t\tcontext.max = clr + clr - 1; \/* (1 << context.nbbit) - 1 *\/\n\t\t\tact_code = GetGifWord(i, &context);\n\t\t\tcasspecial = (u8)act_code;\n\t\t\told_code = act_code;\n\t\t\tif(npix > 0) WritePixel(i, &context, casspecial);\n\t\t\tnpix--;\n\t\t} else {\n\t\t\tread_byt = act_code;\n\t\t\tif(act_code >= free) {\t\/* code pas encore dans alphabet *\/\n\/*\t\t\t\tprintf(\"Code pas dans alphabet : %d>=%d push %d\\n\", act_code, free, casspecial); *\/\n\t\t\t\t*(--stackp) = casspecial; \/* dernier debut de chaine ! *\/\n\t\t\t\tact_code = old_code;\n\t\t\t}\n\/*\t\t\tprintf(\"actcode=%d\\n\", act_code); *\/\n\t\t\twhile(act_code > clr) { \/* code non concret *\/\n\t\t\t\t\/* fillstackloop empile les suffixes ! *\/\n\t\t\t\t*(--stackp) = ab_suffx[act_code];\n\t\t\t\tact_code = ab_prfx[act_code];\t\/* prefixe *\/\n\t\t\t}\n\t\t\t\/* act_code est concret *\/\n\t\t\tcasspecial = (u8)act_code;\t\/* dernier debut de chaine ! *\/\n\t\t\t*(--stackp) = casspecial;\t\/* push on stack *\/\n\t\t\tif(npix >= (stack_top - stackp)) {\n\t\t\t\tWritePixels(i, &context, stackp, stack_top - stackp);\t\/* unstack all pixels at once *\/\n\t\t\t} else if(npix > 0) {\t\/* \"pixel overflow\" *\/\n\t\t\t\tWritePixels(i, &context, stackp, npix);\n\t\t\t}\n\t\t\tnpix -= (stack_top - stackp);\n\t\t\tstackp = stack_top;\n\/*\t\t\tputchar('\\n'); *\/\n\t\t\tif(free < 4096) { \/* la taille du dico est 4096 max ! *\/\n\t\t\t\tab_prfx[free] = old_code;\n\t\t\t\tab_suffx[free] = (u8)act_code;\n\t\t\t\tfree++;\n\t\t\t\tif((free > context.max) && (context.nbbit < 12)) {\n\t\t\t\t\tcontext.nbbit++;\t\/* 1 bit de plus pour les codes LZW *\/\n\t\t\t\t\tcontext.max += context.max + 1;","target":0,"flaw_line_index":0,"hash":"f7e08a6c-091a-43aa-b322-98846b546a40","idx":"54ea9d65-4c83-485c-a5b4-7f193b4df3f3"}
{"func_before":"bool CxImage::Transfer(CxImage &from, bool bTransferFrames \/*=true*\/)\n{\n\tif (!Destroy())\n\t\treturn false;\n\n\tmemcpy(&head,&from.head,sizeof(BITMAPINFOHEADER));\n\tmemcpy(&info,&from.info,sizeof(CXIMAGEINFO));\n\n\tpDib = from.pDib;\n\tpSelection = from.pSelection;\n\tpAlpha = from.pAlpha;\n\tppLayers = from.ppLayers;\n\n\tmemset(&from.head,0,sizeof(BITMAPINFOHEADER));\n\tmemset(&from.info,0,sizeof(CXIMAGEINFO));\n\tfrom.pDib = from.pSelection = from.pAlpha = NULL;\n\tfrom.ppLayers = NULL;\n\n\tif (bTransferFrames){\n\t\tDestroyFrames();\n\t\tppFrames = from.ppFrames;\n\t\tfrom.ppFrames = NULL;\n\t}\n\n\treturn true;\n}","target":1,"flaw_line_index":0,"hash":"b88d60c0-9468-4e82-8f6d-20a153f17aea","idx":"2314f1d6-8892-4a45-82c2-c2848e8aad63"}
{"func_before":"bool CxImage::Transfer(CxImage &from, bool bTransferFrames \/*=true*\/)\n{\n\tif (!Destroy())\n\t\treturn false;\n\n\tmemcpy(&head,&from.head,sizeof(BITMAPINFOHEADER));\n\tmemcpy(&info,&from.info,sizeof(CXIMAGEINFO));\n\n\tpDib = from.pDib;\n    pDib = from.pDibLimit;\n\tpSelection = from.pSelection;\n\tpAlpha = from.pAlpha;\n\tppLayers = from.ppLayers;\n\n\tmemset(&from.head,0,sizeof(BITMAPINFOHEADER));\n\tmemset(&from.info,0,sizeof(CXIMAGEINFO));\n    from.pDib = from.pDibLimit = from.pSelection = from.pAlpha = NULL;\n\tfrom.ppLayers = NULL;\n\n\tif (bTransferFrames){\n\t\tDestroyFrames();\n\t\tppFrames = from.ppFrames;\n\t\tfrom.ppFrames = NULL;\n\t}\n\n\treturn true;\n}","target":0,"flaw_line_index":0,"hash":"03e75dbd-ee53-4826-984c-1a8fa8d5a90e","idx":"516473ff-51b0-4990-85d3-802c20e1c383"}
{"func_before":"static void cil_reset_classperms_set(struct cil_classperms_set *cp_set)\n{\n\tcil_reset_classpermission(cp_set->set);\n}","target":1,"flaw_line_index":0,"hash":"e6d94383-09e5-4b69-9b4a-c28f2b651847","idx":"4d6fa5cc-9278-486f-9cf8-7e7730212de1"}
{"func_before":"static void cil_reset_classperms_set(struct cil_classperms_set *cp_set)\n{\n\tif (cp_set == NULL) {\n\t\treturn;\n\t}\n\n\tcp_set->set = NULL;\n}","target":0,"flaw_line_index":0,"hash":"6c664a54-9309-4c74-bcbe-6ba0a6c8a27b","idx":"a3ab2b45-986f-4ba8-9865-a2433937881f"}
{"func_before":"\t\t}\n\t\tif( strcmp(key_name , LOC_EXTLANG_TAG) ==0 ){\n\t\t\tmax_value  = MAX_NO_EXTLANG;\n\t\t}\n\t\tif( strcmp(key_name , LOC_PRIVATE_TAG) ==0 ){\n\t\t\tmax_value  = MAX_NO_PRIVATE;\n\t\t}\n\n\t\t\/* Multiple variant values as variant0, variant1 ,variant2 *\/\n\t\tisFirstSubtag = 0;\n\t\tfor( i=0 ; i< max_value; i++ ){  \n\t\t\tsnprintf( cur_key_name , 30, \"%s%d\", key_name , i);\t\n\t\t\tif( zend_hash_find( hash_arr , cur_key_name , strlen(cur_key_name) + 1,(void **)&ele_value ) == SUCCESS ){\n\t\t\t\tif( Z_TYPE_PP(ele_value)!= IS_STRING ){\n\t\t\t\t\t\/* variant is not a string *\/\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\t\/* Add the contents *\/\n\t\t\t\tif (isFirstSubtag++ == 0){\n\t\t\t\t\tadd_prefix(loc_name , cur_key_name);\n\t\t\t\t}\n\t\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);","target":1,"flaw_line_index":0,"hash":"7652e9a6-3521-4338-acfa-1fd184e2fd28","idx":"4b554df1-cbdc-48a0-9d02-ccbc2cac2e0c"}
{"func_before":"\t\t}\n\t\tif( strcmp(key_name , LOC_EXTLANG_TAG) ==0 ){\n\t\t\tmax_value  = MAX_NO_EXTLANG;\n\t\t}\n\t\tif( strcmp(key_name , LOC_PRIVATE_TAG) ==0 ){\n\t\t\tmax_value  = MAX_NO_PRIVATE;\n\t\t}\n\n\t\t\/* Multiple variant values as variant0, variant1 ,variant2 *\/\n\t\tisFirstSubtag = 0;\n\t\tfor( i=0 ; i< max_value; i++ ){\n\t\t\tsnprintf( cur_key_name , 30, \"%s%d\", key_name , i);\n\t\t\tif( zend_hash_find( hash_arr , cur_key_name , strlen(cur_key_name) + 1,(void **)&ele_value ) == SUCCESS ){\n\t\t\t\tif( Z_TYPE_PP(ele_value)!= IS_STRING ){\n\t\t\t\t\t\/* variant is not a string *\/\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}\n\t\t\t\t\/* Add the contents *\/\n\t\t\t\tif (isFirstSubtag++ == 0){\n\t\t\t\t\tadd_prefix(loc_name , cur_key_name);\n\t\t\t\t}\n\t\t\t\tsmart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1);","target":0,"flaw_line_index":0,"hash":"071cf961-a8be-4e99-8e09-9120593dcf24","idx":"e0ab3833-603b-4703-b409-5876a9de0bd4"}
{"func_before":"                rrd_infoval_t prline;\n\n                if (im->gdes[i].strftm) {\n                    prline.u_str = (char*)malloc((FMT_LEG_LEN + 2) * sizeof(char));\n                    if (im->gdes[vidx].vf.never == 1) {\n                       time_clean(prline.u_str, im->gdes[i].format);\n                    } else {\n                        strftime(prline.u_str,\n                                 FMT_LEG_LEN, im->gdes[i].format, &tmvdef);\n                    }\n                } else if (bad_format(im->gdes[i].format)) {\n                    rrd_set_error\n                        (\"bad format for PRINT in '%s'\", im->gdes[i].format);\n                    return -1;\n                } else {\n                    prline.u_str =\n                        sprintf_alloc(im->gdes[i].format, printval, si_symb);\n                }\n                grinfo_push(im,\n                            sprintf_alloc\n                            (\"print[%ld]\", prline_cnt++), RD_I_STR, prline);\n                free(prline.u_str);\n            } else {\n                \/* GF_GPRINT *\/\n\n                if (im->gdes[i].strftm) {\n                    if (im->gdes[vidx].vf.never == 1) {\n                       time_clean(im->gdes[i].legend, im->gdes[i].format);\n                    } else {\n                        strftime(im->gdes[i].legend,\n                                 FMT_LEG_LEN, im->gdes[i].format, &tmvdef);\n                    }\n                } else {\n                    if (bad_format(im->gdes[i].format)) {\n                        rrd_set_error\n                            (\"bad format for GPRINT in '%s'\",\n                             im->gdes[i].format);\n                        return -1;\n                    }\n                    snprintf(im->gdes[i].legend,\n                             FMT_LEG_LEN - 2,\n                             im->gdes[i].format, printval, si_symb);\n                }\n                graphelement = 1;\n            }\n            break;\n        case GF_LINE:\n        case GF_AREA:","target":1,"flaw_line_index":0,"hash":"6dc54a79-9457-47c1-a02e-7e2c94b1a652","idx":"000fbd86-7671-49ee-bd5c-895e8123a500"}
{"func_before":"                rrd_infoval_t prline;\n\n                if (im->gdes[i].strftm) {\n                    prline.u_str = (char*)malloc((FMT_LEG_LEN + 2) * sizeof(char));\n                    if (im->gdes[vidx].vf.never == 1) {\n                       time_clean(prline.u_str, im->gdes[i].format);\n                    } else {\n                        strftime(prline.u_str,\n                                 FMT_LEG_LEN, im->gdes[i].format, &tmvdef);\n                    }\n                } else if (bad_format_print(im->gdes[i].format)) {\n                    return -1;\n                } else {\n                    prline.u_str =\n                        sprintf_alloc(im->gdes[i].format, printval, si_symb);\n                }\n                grinfo_push(im,\n                            sprintf_alloc\n                            (\"print[%ld]\", prline_cnt++), RD_I_STR, prline);\n                free(prline.u_str);\n            } else {\n                \/* GF_GPRINT *\/\n\n                if (im->gdes[i].strftm) {\n                    if (im->gdes[vidx].vf.never == 1) {\n                       time_clean(im->gdes[i].legend, im->gdes[i].format);\n                    } else {\n                        strftime(im->gdes[i].legend,\n                                 FMT_LEG_LEN, im->gdes[i].format, &tmvdef);\n                    }\n                } else {\n                    if (bad_format_print(im->gdes[i].format)) {\n                       return -1;\n                    }\n                    snprintf(im->gdes[i].legend,\n                             FMT_LEG_LEN - 2,\n                             im->gdes[i].format, printval, si_symb);\n                }\n                graphelement = 1;\n            }\n            break;\n        case GF_LINE:\n        case GF_AREA:","target":0,"flaw_line_index":0,"hash":"2b051e89-fa99-4994-a777-d53146128b9d","idx":"3e81caee-4a92-4d9f-8a46-60441b69a439"}
