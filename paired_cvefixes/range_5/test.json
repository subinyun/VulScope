[
  {
    "input": "\t\t\telse if (*p == FAC_NATIONAL_DIGIS) {\n\t\t\t\tfac_national_digis_received = 1;\n\t\t\t\tfacilities->source_ndigis = 0;\n\t\t\t\tfacilities->dest_ndigis   = 0;\n\t\t\t\tfor (pt = p + 2, lg = 0 ; lg < l ; pt += AX25_ADDR_LEN, lg += AX25_ADDR_LEN) {\n\t\t\t\t\tif (pt[6] & AX25_HBIT)\n\t\t\t\t\t\tmemcpy(&facilities->dest_digis[facilities->dest_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\telse\n\t\t\t\t\t\tmemcpy(&facilities->source_digis[facilities->source_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\telse if (*p == FAC_NATIONAL_DIGIS) {\n\t\t\t\tfac_national_digis_received = 1;\n\t\t\t\tfacilities->source_ndigis = 0;\n\t\t\t\tfacilities->dest_ndigis   = 0;\n\t\t\t\tfor (pt = p + 2, lg = 0 ; lg < l ; pt += AX25_ADDR_LEN, lg += AX25_ADDR_LEN) {\n\t\t\t\t\tif (pt[6] & AX25_HBIT) {\n\t\t\t\t\t\tif (facilities->dest_ndigis >= ROSE_MAX_DIGIS)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tmemcpy(&facilities->dest_digis[facilities->dest_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (facilities->source_ndigis >= ROSE_MAX_DIGIS)\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\tmemcpy(&facilities->source_digis[facilities->source_ndigis++], pt, AX25_ADDR_LEN);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tp   += l + 2;\n\t\t\tn   += l + 2;\n\t\t\tlen -= l + 2;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "   (row_bytes+MaxCount),sizeof(*packed_scanline));\n  scanline=(unsigned char *) AcquireQuantumMemory(row_bytes,sizeof(*scanline));\n  if ((buffer == (unsigned char *) NULL) ||\n      (packed_scanline == (unsigned char *) NULL) ||\n      (scanline == (unsigned char *) NULL))\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(scanline,0,row_bytes);\n  (void) ResetMagickMemory(packed_scanline,0,(size_t) (row_bytes+MaxCount));\n  /*\n    Write header, header size, size bounding box, version, and reserved.\n  */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "   (row_bytes+MaxCount),sizeof(*packed_scanline));\n  scanline=(unsigned char *) AcquireQuantumMemory(row_bytes,sizeof(*scanline));\n  if ((buffer == (unsigned char *) NULL) ||\n      (packed_scanline == (unsigned char *) NULL) ||\n      (scanline == (unsigned char *) NULL))\n    {\n      if (scanline != (unsigned char *) NULL)\n        scanline=(unsigned char *) RelinquishMagickMemory(scanline);\n      if (packed_scanline != (unsigned char *) NULL)\n        packed_scanline=(unsigned char *) RelinquishMagickMemory(\n          packed_scanline);\n      if (buffer != (unsigned char *) NULL)\n        buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  (void) ResetMagickMemory(scanline,0,row_bytes);\n  (void) ResetMagickMemory(packed_scanline,0,(size_t) (row_bytes+MaxCount));\n  /*\n    Write header, header size, size bounding box, version, and reserved.\n  */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tamount = 0;\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase TIOCINQ: {\n\t\t/*\n\t\t * These two are safe on a single CPU system as only\n\t\t * user tasks fiddle here\n\t\t */\n\t\tstruct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\n\t\tlong amount = 0;\n\n\t\tif (skb)\n\t\t\tamount = skb->len - sizeof(struct ddpehdr);\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\t/* Routing */\n\tcase SIOCADDRT:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tamount = 0;\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\tcase TIOCINQ: {\n\t\tstruct sk_buff *skb;\n\t\tlong amount = 0;\n\n\t\tspin_lock_irq(&sk->sk_receive_queue.lock);\n\t\tskb = skb_peek(&sk->sk_receive_queue);\n\t\tif (skb)\n\t\t\tamount = skb->len - sizeof(struct ddpehdr);\n\t\tspin_unlock_irq(&sk->sk_receive_queue.lock);\n\t\trc = put_user(amount, (int __user *)argp);\n\t\tbreak;\n\t}\n\t/* Routing */\n\tcase SIOCADDRT:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "bool RequestParser::OnHeadersEnd() {\n  bool matched = view_matcher_(request_->method(), request_->url().path(),\n                               &stream_);\n\n  if (!matched) {\n    LOG_WARN(\"No view matches the request: %s %s\", request_->method().c_str(),\n             request_->url().path().c_str());\n  }\n\n  return matched;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "bool RequestParser::OnHeadersEnd() {\n  // Decode the URL path before match.\n  std::string url_path = Url::DecodeUnsafe(request_->url().path());\n  bool matched = view_matcher_(request_->method(), url_path, &stream_);\n  if (!matched) {\n    LOG_WARN(\"No view matches the request: %s %s\", request_->method().c_str(),\n             url_path.c_str());\n  }\n  return matched;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "snmp_engine_get_bulk(snmp_header_t *header, snmp_varbind_t *varbinds, uint32_t *varbinds_length)\n{\n  snmp_mib_resource_t *resource;\n  uint32_t i, j, original_varbinds_length;\n  uint32_t oid[SNMP_MAX_NR_VALUES][SNMP_MSG_OID_MAX_LEN];\n  uint8_t repeater;\n\n  /*\n   * A local copy of the requested oids must be kept since\n   *  the varbinds are modified on the fly\n   */\n  original_varbinds_length = *varbinds_length;\n  for(i = 0; i < original_varbinds_length; i++) {\n    snmp_oid_copy(oid[i], varbinds[i].oid);\n  }\n\n  *varbinds_length = 0;\n  for(i = 0; i < original_varbinds_length; i++) {\n    if(i >= header->error_status_non_repeaters.non_repeaters) {\n      break;\n    }\n\n    resource = snmp_mib_find_next(oid[i]);\n    if(!resource) {\n      switch(header->version) {\n      case SNMP_VERSION_1:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        /*\n         * Varbinds are 1 indexed\n         */\n        header->error_index_max_repetitions.error_index = i + 1;\n        break;\n      case SNMP_VERSION_2C:\n        (&varbinds[i])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;\n        break;\n      default:\n        header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index_max_repetitions.error_index = 0;\n      }\n    } else {\n      if(*varbinds_length < SNMP_MAX_NR_VALUES) {\n        resource->handler(&varbinds[*varbinds_length], resource->oid);\n        (*varbinds_length)++;\n      }\n    }\n  }\n\n  for(i = 0; i < header->error_index_max_repetitions.max_repetitions; i++) {\n    repeater = 0;\n    for(j = header->error_status_non_repeaters.non_repeaters; j < original_varbinds_length; j++) {\n      resource = snmp_mib_find_next(oid[j]);\n      if(!resource) {\n        switch(header->version) {\n        case SNMP_VERSION_1:\n          header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n          /*\n           * Varbinds are 1 indexed\n           */\n          header->error_index_max_repetitions.error_index = *varbinds_length + 1;\n          break;\n        case SNMP_VERSION_2C:\n          if(*varbinds_length < SNMP_MAX_NR_VALUES) {\n            (&varbinds[*varbinds_length])->value_type = SNMP_DATA_TYPE_END_OF_MIB_VIEW;\n            snmp_oid_copy((&varbinds[*varbinds_length])->oid, oid[j]);\n            (*varbinds_length)++;\n          }\n          break;\n        default:\n          header->error_status_non_repeaters.error_status = SNMP_STATUS_NO_SUCH_NAME;\n          header->error_index_max_repetitions.error_index = 0;\n        }\n      } else {\n        if(*varbinds_length < SNMP_MAX_NR_VALUES) {\n          resource->handler(&varbinds[*varbinds_length], resource->oid);\n          (*varbinds_length)++;\n          snmp_oid_copy(oid[j], resource->oid);\n          repeater++;\n        }\n      }\n    }\n    if(repeater == 0) {\n      break;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "snmp_engine_get_bulk(snmp_header_t *header, snmp_varbind_t *varbinds)\n{\n  snmp_mib_resource_t *resource;\n  snmp_oid_t oids[SNMP_MAX_NR_VALUES];\n  uint32_t j, original_varbinds_length;\n  uint8_t repeater;\n  uint8_t i, varbinds_length;\n\n  /*\n   * A local copy of the requested oids must be kept since\n   *  the varbinds are modified on the fly\n   */\n  original_varbinds_length = 0;\n  while(varbinds[original_varbinds_length].value_type != BER_DATA_TYPE_EOC && original_varbinds_length < SNMP_MAX_NR_VALUES) {\n    memcpy(&oids[original_varbinds_length], &varbinds[original_varbinds_length].oid, sizeof(snmp_oid_t));\n    original_varbinds_length++;\n  }\n\n  varbinds_length = 0;\n  for(i = 0; i < original_varbinds_length; i++) {\n    if(i >= header->non_repeaters) {\n      break;\n    }\n\n    resource = snmp_mib_find_next(&oids[i]);\n    if(!resource) {\n      switch(header->version) {\n      case SNMP_VERSION_1:\n        header->error_status = SNMP_STATUS_NO_SUCH_NAME;\n        /*\n         * Varbinds are 1 indexed\n         */\n        header->error_index = i + 1;\n        break;\n      case SNMP_VERSION_2C:\n        (&varbinds[i])->value_type = BER_DATA_TYPE_END_OF_MIB_VIEW;\n        break;\n      default:\n        header->error_status = SNMP_STATUS_NO_SUCH_NAME;\n        header->error_index = 0;\n      }\n    } else {\n      if(varbinds_length < SNMP_MAX_NR_VALUES) {\n        resource->handler(&varbinds[varbinds_length], &resource->oid);\n        (varbinds_length)++;\n      } else {\n        return -1;\n      }\n    }\n  }\n\n  for(i = 0; i < header->max_repetitions; i++) {\n    repeater = 0;\n    for(j = header->non_repeaters; j < original_varbinds_length; j++) {\n      resource = snmp_mib_find_next(&oids[j]);\n      if(!resource) {\n        switch(header->version) {\n        case SNMP_VERSION_1:\n          header->error_status = SNMP_STATUS_NO_SUCH_NAME;\n          /*\n           * Varbinds are 1 indexed\n           */\n          header->error_index = varbinds_length + 1;\n          break;\n        case SNMP_VERSION_2C:\n          if(varbinds_length < SNMP_MAX_NR_VALUES) {\n            (&varbinds[varbinds_length])->value_type = BER_DATA_TYPE_END_OF_MIB_VIEW;\n            memcpy(&varbinds[varbinds_length].oid, &oids[j], sizeof(snmp_oid_t));\n            (varbinds_length)++;\n          } else {\n            return -1;\n          }\n          break;\n        default:\n          header->error_status = SNMP_STATUS_NO_SUCH_NAME;\n          header->error_index = 0;\n        }\n      } else {\n        if(varbinds_length < SNMP_MAX_NR_VALUES) {\n          resource->handler(&varbinds[varbinds_length], &resource->oid);\n          (varbinds_length)++;\n          memcpy(&oids[j], &resource->oid, sizeof(snmp_oid_t));\n          repeater++;\n        } else {\n          return -1;\n        }\n      }\n    }\n    if(repeater == 0) {\n      break;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\n\treturn rv;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tif (_gdImageWebpCtx(im, out, -1)) {\n\t\trv = NULL;\n\t} else {\n\t\trv = gdDPExtractData(out, size);\n\t}\n\tout->gd_free(out);\n\n\treturn rv;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                int i = 0;\n                while (data <= data_end && !isspace(*data) && *data != tag_close && i < MOBI_ATTRVALUE_MAXSIZE) {\n                    result->value[i++] = (char) *data++;\n                }\n                /* self closing tag '/>' */\n                if (*(data - 1) == '/' && *data == '>') {\n                    --data; --i;\n                }\n                result->end = data;\n                result->value[i] = '\\0';\n                return MOBI_SUCCESS;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                int i = 0;\n                while (data <= data_end && !isspace(*data) && *data != tag_close && i < MOBI_ATTRVALUE_MAXSIZE) {\n                    result->value[i++] = (char) *data++;\n                }\n                /* self closing tag '/>' */\n                if (data <= data_end && *(data - 1) == '/' && *data == '>') {\n                    --data; --i;\n                }\n                result->end = data;\n                result->value[i] = '\\0';\n                return MOBI_SUCCESS;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\n\traw = bpf_any_get(inode->i_private, *type);\n\ttouch_atime(&path);\n\n\tpath_put(&path);\n\treturn raw;\nout:\n\tpath_put(&path);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tret = bpf_inode_type(inode, type);\n\tif (ret)\n\t\tgoto out;\n\n\traw = bpf_any_get(inode->i_private, *type);\n\tif (!IS_ERR(raw))\n\t\ttouch_atime(&path);\n\n\tpath_put(&path);\n\treturn raw;\nout:\n\tpath_put(&path);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int sgi_clock_set(clockid_t clockid, struct timespec *tp)\n{\n\n\tu64 nsec;\n\tu64 rem;\n\n\tnsec = rtc_time() * sgi_clock_period;\n\n\tsgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);\n\n\tif (rem <= tp->tv_nsec)\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec - rem;\n\telse {\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int sgi_clock_set(clockid_t clockid, struct timespec *tp)\n{\n\n\tu64 nsec;\n\tu32 rem;\n\n\tnsec = rtc_time() * sgi_clock_period;\n\n\tsgi_clock_offset.tv_sec = tp->tv_sec - div_u64_rem(nsec, NSEC_PER_SEC, &rem);\n\n\tif (rem <= tp->tv_nsec)\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec - rem;\n\telse {\n\t\tsgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int bn_ham(const bn_t a) {\n\tint c = 0;\n\n\tfor (int i = 0; i < bn_bits(a); i++) {\n\t\tc += bn_get_bit(a, i);\n\t}\n\n\treturn c;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "size_t bn_ham(const bn_t a) {\n\tint c = 0;\n\n\tfor (int i = 0; i < bn_bits(a); i++) {\n\t\tc += bn_get_bit(a, i);\n\t}\n\n\treturn c;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n#ifdef WITH_SSL_SUPPORT\n    else if((opt.ssl_mode & SSL_MODE_TLS_OUTGOING) &&\n          (status & PROTOCOL_S_STARTTLS)) {\n      server_io=perdition_ssl_client_connection(server_io, opt.ssl_ca_file, \n\t\t      opt.ssl_ca_path, opt.ssl_listen_ciphers, servername);\n      if(!server_io) {\n        VANESSA_LOGGER_DEBUG(\"perdition_ssl_connection outgoing\");\n        VANESSA_LOGGER_ERR(\"Fatal error establishing SSL connection\");\n        perdition_exit_cleanly(-1);\n      }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n#ifdef WITH_SSL_SUPPORT\n    else if((opt.ssl_mode & SSL_MODE_TLS_OUTGOING) &&\n          (status & PROTOCOL_S_STARTTLS)) {\n      server_io=perdition_ssl_client_connection(server_io, opt.ssl_ca_file, \n\t\t      opt.ssl_ca_path, opt.ssl_outgoing_ciphers, servername);\n      if(!server_io) {\n        VANESSA_LOGGER_DEBUG(\"perdition_ssl_connection outgoing\");\n        VANESSA_LOGGER_ERR(\"Fatal error establishing SSL connection\");\n        perdition_exit_cleanly(-1);\n      }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        connp->in_state = htp_connp_REQ_HEADERS;\n        connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n    } else {\n        // Let's check if the protocol was simply missing\n        int64_t pos = connp->in_current_read_offset;\n        int afterspaces = 0;\n        // Probe if data looks like a header line\n        while (pos < connp->in_current_len) {\n            if (connp->in_current_data[pos] == ':') {\n                htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Request line: missing protocol\");\n                connp->in_tx->is_protocol_0_9 = 0;\n                // Switch to request header parsing.\n                connp->in_state = htp_connp_REQ_HEADERS;\n                connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n                return HTP_OK;\n            } else if (htp_is_lws(connp->in_current_data[pos])) {\n                // Allows spaces after header name\n                afterspaces = 1;\n            } else if (htp_is_space(connp->in_current_data[pos]) || afterspaces == 1) {\n                break;\n            }\n            pos++;\n        }\n        // We're done with this request.\n        connp->in_state = htp_connp_REQ_FINALIZE;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        // Switch to request header parsing.\n        connp->in_state = htp_connp_REQ_HEADERS;\n        connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n    } else {\n        // Let's check if the protocol was simply missing\n        int64_t pos = connp->in_current_read_offset;\n        // Probe if data looks like a header line\n        while (pos < connp->in_current_len) {\n            if (!htp_is_space(connp->in_current_data[pos])) {\n                htp_log(connp, HTP_LOG_MARK, HTP_LOG_WARNING, 0, \"Request line: missing protocol\");\n                connp->in_tx->is_protocol_0_9 = 0;\n                // Switch to request header parsing.\n                connp->in_state = htp_connp_REQ_HEADERS;\n                connp->in_tx->request_progress = HTP_REQUEST_HEADERS;\n                return HTP_OK;\n            }\n            pos++;\n        }\n        // We're done with this request.\n        connp->in_state = htp_connp_REQ_FINALIZE;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tgoto cleanup;\n\n\t/* Here we know that we can set the new attribute. */\n\n\tif (header) {\n\t\tstruct mb_cache_entry *ce;\n\n\t\t/* assert(header == HDR(bh)); */\n\t\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev,\n\t\t\t\t\tbh->b_blocknr);\n\t\tlock_buffer(bh);\n\t\tif (header->h_refcount == cpu_to_le32(1)) {\n\t\t\tea_bdebug(bh, \"modifying in-place\");\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_free(ce);\n\t\t\t/* keep the buffer locked while modifying it. */\n\t\t} else {\n\t\t\tint offset;\n\n\t\t\tif (ce)\n\t\t\t\tmb_cache_entry_release(ce);\n\t\t\tunlock_buffer(bh);\n\t\t\tea_bdebug(bh, \"cloning\");\n\t\t\theader = kmalloc(bh->b_size, GFP_KERNEL);\n\t\t\terror = -ENOMEM;\n\t\t\tif (header == NULL)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (free < EXT2_XATTR_LEN(name_len) + EXT2_XATTR_SIZE(value_len))\n\t\tgoto cleanup;\n\n\t/* Here we know that we can set the new attribute. */\n\n\tif (header) {\n\t\t/* assert(header == HDR(bh)); */\n\t\tlock_buffer(bh);\n\t\tif (header->h_refcount == cpu_to_le32(1)) {\n\t\t\t__u32 hash = le32_to_cpu(header->h_hash);\n\n\t\t\tea_bdebug(bh, \"modifying in-place\");\n\t\t\t/*\n\t\t\t * This must happen under buffer lock for\n\t\t\t * ext2_xattr_set2() to reliably detect modified block\n\t\t\t */\n\t\t\tmb2_cache_entry_delete_block(EXT2_SB(sb)->s_mb_cache,\n\t\t\t\t\t\t     hash, bh->b_blocknr);\n\n\t\t\t/* keep the buffer locked while modifying it. */\n\t\t} else {\n\t\t\tint offset;\n\n\t\t\tunlock_buffer(bh);\n\t\t\tea_bdebug(bh, \"cloning\");\n\t\t\theader = kmalloc(bh->b_size, GFP_KERNEL);\n\t\t\terror = -ENOMEM;\n\t\t\tif (header == NULL)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "char *oidc_util_get_chunked_cookie(request_rec *r, const char *cookieName, int chunkSize) {\n\tchar *cookieValue = NULL;\n\tchar *chunkValue = NULL;\n\tint i = 0;\n\tif (chunkSize == 0) {\n\t\tcookieValue = oidc_util_get_cookie(r, cookieName);\n\t} else {\n\t\tint chunkCount = oidc_util_get_chunked_count(r, cookieName);\n\t\tif (chunkCount > 0) {\n\t\t\tcookieValue = \"\";\n\t\t\tfor (i = 0; i < chunkCount; i++) {\n\t\t\t\tchunkValue = oidc_util_get_cookie(r, oidc_util_get_chunk_cookie_name(r, cookieName, i));\n\t\t\t\tif (chunkValue != NULL)\n\t\t\t\t\tcookieValue = apr_psprintf(r->pool, \"%s%s\", cookieValue, chunkValue);\n\t\t\t}\n\t\t} else {\n\t\t\tcookieValue = oidc_util_get_cookie(r, cookieName);\n\t\t}\n\t}\n\treturn cookieValue;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "char *oidc_util_get_chunked_cookie(request_rec *r, const char *cookieName, int chunkSize) {\n\tchar *cookieValue = NULL, *chunkValue = NULL;\n\tint chunkCount = 0, i = 0;\n\tif (chunkSize == 0)\n\t\treturn oidc_util_get_cookie(r, cookieName);\n\tchunkCount = oidc_util_get_chunked_count(r, cookieName);\n\tif (chunkCount == 0)\n\t\treturn oidc_util_get_cookie(r, cookieName);\n\tif ((chunkCount < 0) || (chunkCount > 99)) {\n\t\toidc_warn(r, \"chunk count out of bounds: %d\", chunkCount);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < chunkCount; i++) {\n\t\tchunkValue = oidc_util_get_cookie(r, oidc_util_get_chunk_cookie_name(r, cookieName, i));\n\t\tif (chunkValue == NULL) {\n\t\t\toidc_warn(r, \"could not find chunk %d; aborting\", i);\n\t\t\tbreak;\n\t\t}\n\t\tcookieValue = apr_psprintf(r->pool, \"%s%s\", cookieValue ? cookieValue : \"\", chunkValue);\n\t}\n\treturn cookieValue;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        {\n          mutt_error(_(\"Header search without header name: %s\"), pat->p.str);\n          return -1;\n        }\n        *delim = '\\0';\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        mutt_buffer_addch(buf, ' ');\n\n        /* and field */\n        *delim = ':';\n        delim++;\n        SKIPWS(delim);\n        imap_quote_string(term, sizeof(term), delim);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_BODY:\n        mutt_buffer_addstr(buf, \"BODY \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_WHOLE_MSG:\n        mutt_buffer_addstr(buf, \"TEXT \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_SERVERSEARCH:\n      {\n        struct ImapData *idata = ctx->data;\n          mutt_error(_(\"Server-side custom search not supported: %s\"), pat->p.str);\n          return -1;\n        }\n      }\n        mutt_buffer_addstr(buf, \"X-GM-RAW \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n    }\n  }\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        {\n          mutt_error(_(\"Header search without header name: %s\"), pat->p.str);\n          return -1;\n        }\n        *delim = '\\0';\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        mutt_buffer_addch(buf, ' ');\n\n        /* and field */\n        *delim = ':';\n        delim++;\n        SKIPWS(delim);\n        imap_quote_string(term, sizeof(term), delim, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_BODY:\n        mutt_buffer_addstr(buf, \"BODY \");\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_WHOLE_MSG:\n        mutt_buffer_addstr(buf, \"TEXT \");\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_SERVERSEARCH:\n      {\n        struct ImapData *idata = ctx->data;\n          mutt_error(_(\"Server-side custom search not supported: %s\"), pat->p.str);\n          return -1;\n        }\n      }\n        mutt_buffer_addstr(buf, \"X-GM-RAW \");\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n    }\n  }\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct perf_event *event = file->private_data;\n\tvoid (*func)(struct perf_event *);\n\tu32 flags = arg;\n\n\tswitch (cmd) {\n\tcase PERF_EVENT_IOC_ENABLE:\n\t\tfunc = perf_event_enable;\n\t\tbreak;\n\tcase PERF_EVENT_IOC_DISABLE:\n\t\tfunc = perf_event_disable;\n\t\tbreak;\n\tcase PERF_EVENT_IOC_RESET:\n\t\tfunc = perf_event_reset;\n\t\tbreak;\n\n\tcase PERF_EVENT_IOC_REFRESH:\n\t\treturn perf_event_refresh(event, arg);\n\n\tcase PERF_EVENT_IOC_PERIOD:\n\t\treturn perf_event_period(event, (u64 __user *)arg);\n\n\tcase PERF_EVENT_IOC_ID:\n\t{\n\t\tu64 id = primary_event_id(event);\n\n\t\tif (copy_to_user((void __user *)arg, &id, sizeof(id)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tcase PERF_EVENT_IOC_SET_OUTPUT:\n\t{\n\t\tint ret;\n\t\tif (arg != -1) {\n\t\t\tstruct perf_event *output_event;\n\t\t\tstruct fd output;\n\t\t\tret = perf_fget_light(arg, &output);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\toutput_event = output.file->private_data;\n\t\t\tret = perf_event_set_output(event, output_event);\n\t\t\tfdput(output);\n\t\t} else {\n\t\t\tret = perf_event_set_output(event, NULL);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tcase PERF_EVENT_IOC_SET_FILTER:\n\t\treturn perf_event_set_filter(event, (void __user *)arg);\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\tif (flags & PERF_IOC_FLAG_GROUP)\n\t\tperf_event_for_each(event, func);\n\telse\n\t\tperf_event_for_each_child(event, func);\n\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct perf_event *event = file->private_data;\n\tstruct perf_event_context *ctx;\n\tlong ret;\n\n\tctx = perf_event_ctx_lock(event);\n\tret = _perf_ioctl(event, cmd, arg);\n\tperf_event_ctx_unlock(event, ctx);\n\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_cork *cork;\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\tunsigned int maxfraglen, fragheaderlen;\n\tint exthdrlen;\n\tint dst_exthdrlen;\n\tint hh_len;\n\tint mtu;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\t__u8 tx_flags = 0;\n\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t/* update mtu and maxfraglen if necessary */\n\t\t\tif (skb == NULL || skb_prev == NULL)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt);\n\n\t\t\tskb_prev = skb;\n\n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct inet_cork *cork;\n\tstruct sk_buff *skb, *skb_prev = NULL;\n\tunsigned int maxfraglen, fragheaderlen, mtu;\n\tint exthdrlen;\n\tint dst_exthdrlen;\n\tint hh_len;\n\tint copy;\n\tint err;\n\tint offset = 0;\n\t__u8 tx_flags = 0;\n\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t/* update mtu and maxfraglen if necessary */\n\t\t\tif (skb == NULL || skb_prev == NULL)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt,\n\t\t\t\t\t\t    np->pmtudisc ==\n\t\t\t\t\t\t    IPV6_PMTUDISC_PROBE);\n\n\t\t\tskb_prev = skb;\n\n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)\n{\n\tint i;\n\tint j;\n\n\tif (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=\n\t  mat1->numcols_) {\n\t\treturn 1;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)\n{\n\tjas_matind_t i;\n\tjas_matind_t j;\n\n\tif (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=\n\t  mat1->numcols_) {\n\t\treturn 1;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteStatus L2Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  switch (input->type) {  // Already know in/out types are same.\n    case kTfLiteFloat32:\n      L2EvalFloat<kernel_type>(context, node, params, data, input, output);\n      break;\n    case kTfLiteUInt8:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteStatus L2Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params = reinterpret_cast<TfLitePoolParams*>(node->builtin_data);\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  switch (input->type) {  // Already know in/out types are same.\n    case kTfLiteFloat32:\n      L2EvalFloat<kernel_type>(context, node, params, data, input, output);\n      break;\n    case kTfLiteUInt8:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_TOOLARGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  for (col = cinfo->image_width; col > 0; col--) {\n    register unsigned int temp;\n    temp  = UCH(*bufferptr++) << 8;\n    temp |= UCH(*bufferptr++);\n    if (temp > maxval)\n      ERREXIT(cinfo, JERR_PPM_OUTOFRANGE);\n    *ptr++ = rescale[temp];\n  }\n  return 1;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t{\n\t\tprintf(\"usage: %s <file_with_GPMF>\\n\", argv[0]);\n\t\treturn -1;\n\t}\n\n\tsize_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);\n//\tsize_t mp4 = OpenMP4SourceUDTA(argv[1]);  //Search for GPMF payload with MP4's udta \n\n\tmetadatalength = GetDuration(mp4);\n\n\tif (metadatalength > 0.0)\n\n\n\t\tfor (index = 0; index < payloads; index++)\n\t\t{\n\t\t\tuint32_t payloadsize = GetPayloadSize(mp4, index);\n\t\t\tfloat in = 0.0, out = 0.0; //times\n\t\t\tpayload = GetPayload(mp4, payload, index);\n\t\t\tif (payload == NULL)\n\t\t\t\tgoto cleanup;\n\n\t\t\tret = GetPayloadTime(mp4, index, &in, &out);\n#if 1\n\t\t// Find all the available Streams and compute they sample rates\n\t\twhile (GPMF_OK == GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS))\n\t\t{\n\t\t\tif (GPMF_OK == GPMF_SeekToSamples(ms)) //find the last FOURCC within the stream\n\t\t\t{\n\t\t\t\tuint32_t fourcc = GPMF_Key(ms);\n\t\t\t\tdouble rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE);// GPMF_SAMPLE_RATE_FAST);\n\t\t\t\tprintf(\"%c%c%c%c sampling rate = %f Hz\\n\", PRINTF_4CC(fourcc), rate);\n\t\t\t}\n\t\t}\n#endif\n\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tprintf(\"usage: %s <file_with_GPMF>\\n\", argv[0]);\n\t\treturn -1;\n\t}\n\n\tsize_t mp4 = OpenMP4Source(argv[1], MOV_GPMF_TRAK_TYPE, MOV_GPMF_TRAK_SUBTYPE);\n\tif (mp4 == 0)\n\t{\n\t\tprintf(\"error: %s is an invalid MP4/MOV\\n\", argv[1]);\n\t\treturn -1;\n\t}\n\n//\tsize_t mp4 = OpenMP4SourceUDTA(argv[1]);  //Search for GPMF payload with MP4's udta \n\n\tmetadatalength = GetDuration(mp4);\n\n\tif (metadatalength > 0.0)\n\n\n\t\tfor (index = 0; index < payloads; index++)\n\t\t{\n\t\t\tuint32_t payloadsize = GetPayloadSize(mp4, index);\n\t\t\tdouble in = 0.0, out = 0.0; //times\n\t\t\tpayload = GetPayload(mp4, payload, index);\n\t\t\tif (payload == NULL)\n\t\t\t\tgoto cleanup;\n\n\t\t\tret = GetPayloadTime(mp4, index, &in, &out);\n\t\t// Find all the available Streams and compute they sample rates\n\t\twhile (GPMF_OK == GPMF_FindNext(ms, GPMF_KEY_STREAM, GPMF_RECURSE_LEVELS))\n\t\t{\n\t\t\tif (GPMF_OK == GPMF_SeekToSamples(ms)) //find the last FOURCC within the stream\n\t\t\t{\n\t\t\t\tdouble in = 0.0, out = 0.0;\n\t\t\t\tuint32_t fourcc = GPMF_Key(ms);\n\t\t\t\tdouble rate = GetGPMFSampleRate(mp4, fourcc, GPMF_SAMPLE_RATE_PRECISE, &in, &out);// GPMF_SAMPLE_RATE_FAST);\n\t\t\t\tprintf(\"%c%c%c%c sampling rate = %f Hz (from %f to %f)\\n\", PRINTF_4CC(fourcc), rate, in, out);\n\t\t\t}\n\t\t}\n#endif\n\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int64_t OutputFile::readImpl(char* /*buffer*/, int64_t /*length*/) {\n  raise_warning(\"cannot read from a php://output stream\");\n  return -1;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int64_t OutputFile::readImpl(char* /*buffer*/, int64_t /*length*/) {\n  raise_warning(\"cannot read from a php://output stream\");\n  return 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_BE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_4_LE:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_LE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_LENGTH_INCLUDES_ITSELF:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_BE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_4_LE:\n\t\t\t\t\tswitch (m->type) {\n\t\t\t\t\tcase FILE_PSTRING:\n\t\t\t\t\tcase FILE_REGEX:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t\t}\n\t\t\t\t\tm->str_flags = (m->str_flags & ~PSTRING_LEN) | PSTRING_4_LE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CHAR_PSTRING_LENGTH_INCLUDES_ITSELF:\n\t\t\t\t\tif (m->type != FILE_PSTRING)\n\t\t\t\t\t\tgoto bad;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "mget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n    int flip, int recursion_level, int *printed_something,\n    int *need_separator, int *returnval)\n{\n\tuint32_t soffset, offset = ms->offset;\n\tuint32_t lhs;\n\tint rv, oneed_separator, in_type;\n\tchar *sbuf, *rbuf;\n\tunion VALUETYPE *p = &ms->ms_value;\n\tstruct mlist ml;\n\n\tif (recursion_level >= 20) {\n\t\tfile_error(ms, 0, \"recursion nesting exceeded\");\n\t\treturn -1;\n\t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t\t\treturn 0;\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\t\tif (offset == 0)\n\t\t\treturn 0;\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = ms->o.buf;\n\t\tsoffset = ms->offset;\n\t\tms->o.buf = NULL;\n\t\tms->offset = 0;\n\t\trv = file_softmagic(ms, s + offset, nbytes - offset,\n\t\t    recursion_level, BINTEST, text);\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\tfprintf(stderr, \"indirect @offs=%u[%d]\\n\", offset, rv);\n\t\trbuf = ms->o.buf;\n\t\tms->o.buf = sbuf;\n\t\tms->offset = soffset;\n\t\tif (rv == 1) {\n\t\t\tif ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&\n\t\t\t    file_printf(ms, F(ms, m, \"%u\"), offset) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\treturn rv;\n\n\tcase FILE_USE:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\tsbuf = m->value.s;\n\t\tif (*sbuf == '^') {\n\t\t\tsbuf++;\n\t\t\tflip = !flip;\n\t\t}\n\t\tif (file_magicfind(ms, sbuf, &ml) == -1) {\n\t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", sbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\toneed_separator = *need_separator;\n\t\tif (m->flag & NOSPACE)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "mget(struct magic_set *ms, const unsigned char *s, struct magic *m,\n    size_t nbytes, size_t o, unsigned int cont_level, int mode, int text,\n    int flip, int recursion_level, int *printed_something,\n    int *need_separator, int *returnval)\n{\n\tuint32_t offset = ms->offset;\n\tuint32_t lhs;\n\tfile_pushbuf_t *pb;\n\tint rv, oneed_separator, in_type;\n\tchar *rbuf;\n\tunion VALUETYPE *p = &ms->ms_value;\n\tstruct mlist ml;\n\n\tif (recursion_level >= MAX_RECURSION_LEVEL) {\n\t\tfile_error(ms, 0, \"recursion nesting exceeded\");\n\t\treturn -1;\n\t}\n\n\tif (mcopy(ms, p, m->type, m->flag & INDIR, s, (uint32_t)(offset + o),\n\t\tbreak;\n\n\tcase FILE_INDIRECT:\n\t\tif (offset == 0)\n\t\t\treturn 0;\n\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\n\t\tif ((pb = file_push_buffer(ms)) == NULL)\n\t\t\treturn -1;\n\n\t\trv = file_softmagic(ms, s + offset, nbytes - offset,\n\t\t    recursion_level, BINTEST, text);\n\n\t\tif ((ms->flags & MAGIC_DEBUG) != 0)\n\t\t\tfprintf(stderr, \"indirect @offs=%u[%d]\\n\", offset, rv);\n\n\t\trbuf = file_pop_buffer(ms, pb);\n\t\tif (rbuf == NULL)\n\t\t\treturn -1;\n\n\t\tif (rv == 1) {\n\t\t\tif ((ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0 &&\n\t\t\t    file_printf(ms, F(ms, m, \"%u\"), offset) == -1) {\n\t\t\t\tfree(rbuf);\n\t\t\t\treturn -1;\n\t\treturn rv;\n\n\tcase FILE_USE:\n\t\tif (nbytes < offset)\n\t\t\treturn 0;\n\t\trbuf = m->value.s;\n\t\tif (*rbuf == '^') {\n\t\t\trbuf++;\n\t\t\tflip = !flip;\n\t\t}\n\t\tif (file_magicfind(ms, rbuf, &ml) == -1) {\n\t\t\tfile_error(ms, 0, \"cannot find entry `%s'\", rbuf);\n\t\t\treturn -1;\n\t\t}\n\n\t\toneed_separator = *need_separator;\n\t\tif (m->flag & NOSPACE)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  void lazyCompile(Runtime &runtime) {\n    if (LLVM_UNLIKELY(isLazy())) {\n      lazyCompileImpl(runtime);\n    }\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  ExecutionStatus lazyCompile(Runtime &runtime) {\n    if (LLVM_UNLIKELY(isLazy())) {\n      return lazyCompileImpl(runtime);\n    }\n    return ExecutionStatus::RETURNED;\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                                           &tmp_indices));\n        functor::DenseUpdate<Device, Index, ASSIGN> copy_functor;\n        copy_functor(c->eigen_device<Device>(), tmp_indices.flat<Index>(),\n                     indices.flat<Index>());\n\n        AddBatchOffsets(&tmp_indices, params);\n        op_indices = &tmp_indices;\n      }\n\n      int64_t gather_dim_size = 1;\n      for (int idx = 0; idx <= batch_dims_; ++idx) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                                           &tmp_indices));\n        functor::DenseUpdate<Device, Index, ASSIGN> copy_functor;\n        copy_functor(c->eigen_device<Device>(), tmp_indices.flat<Index>(),\n                     indices.flat<Index>());\n\n        AddBatchOffsets(c, &tmp_indices, params);\n        if (!c->status().ok()) return;\n        op_indices = &tmp_indices;\n      }\n\n      int64_t gather_dim_size = 1;\n      for (int idx = 0; idx <= batch_dims_; ++idx) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n\n    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen);\n    if (ret)\n        return ret;\n    if (rlen != 0)\n        return ASN1_BAD_LENGTH;\n    insert_bytes(buf, contents, clen);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n    krb5_error_code ret;\n    const uint8_t *contents, *remainder;\n    size_t clen, rlen;\n\n    ret = get_tag(*der, len, tag_out, &contents, &clen, &remainder, &rlen, 0);\n    if (ret)\n        return ret;\n    if (rlen != 0)\n        return ASN1_BAD_LENGTH;\n    insert_bytes(buf, contents, clen);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t   return CI_MOD_ALLOW204;\n     }\n\n     \n     /* Check URL header against squidGuard */\n     if (usepipe == 1) {\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Sending request to chained program: %s\\n\", squidguard);\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Request: %s %s %s %s\\n\", httpinf.url,clientip,username,httpinf.method);\n\tfprintf(sgfpw,\"%s %s %s %s\\n\",httpinf.url,clientip,username,httpinf.method);\n\tfflush(sgfpw);\n\t/* the chained redirector must return empty line if ok or the redirection url */\n\tchain_ret = (char *)malloc(sizeof(char)*MAX_URL_SIZE);\n\tif (chain_ret != NULL) {\n\t   ret = fgets(chain_ret,MAX_URL_SIZE,sgfpr);\n\t   if ((ret != NULL) && (strlen(chain_ret) > 1)) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "     }\n\n     \n     /* Check URL header against squidGuard */\n     if (usepipe == 1) {\n\tchar *rbuff = NULL;\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Sending request to chained program: %s\\n\", squidguard);\n\tci_debug_printf(2, \"DEBUG squidclamav_check_preview_handler: Request: %s %s %s %s\\n\", httpinf.url,clientip,username,httpinf.method);\n\t/* escaping escaped character to prevent unescaping by squidguard */\n\trbuff = replace(httpinf.url, \"%\", \"%25\");\n\tfprintf(sgfpw,\"%s %s %s %s\\n\",rbuff,clientip,username,httpinf.method);\n\tfflush(sgfpw);\n\txfree(rbuff);\n\t/* the chained redirector must return empty line if ok or the redirection url */\n\tchain_ret = (char *)malloc(sizeof(char)*MAX_URL_SIZE);\n\tif (chain_ret != NULL) {\n\t   ret = fgets(chain_ret,MAX_URL_SIZE,sgfpr);\n\t   if ((ret != NULL) && (strlen(chain_ret) > 1)) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int is_manager_apk(char *path)\n{\n\treturn check_v2_signature(path, ksu_expected_size, ksu_expected_hash);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "bool is_manager_apk(char *path)\n{\n\treturn check_v2_signature(path, ksu_expected_size, ksu_expected_hash);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "do_prefetch_tables (const void *gcmM, size_t gcmM_size)\n{\n  prefetch_table(gcmM, gcmM_size);\n  prefetch_table(gcmR, sizeof(gcmR));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "do_prefetch_tables (const void *gcmM, size_t gcmM_size)\n{\n  /* Modify counters to trigger copy-on-write and unsharing if physical pages\n   * of look-up table are shared between processes.  Modifying counters also\n   * causes checksums for pages to change and hint same-page merging algorithm\n   * that these pages are frequently changing.  */\n  gcm_table.counter_head++;\n  gcm_table.counter_tail++;\n\n  /* Prefetch look-up tables to cache.  */\n  prefetch_table(gcmM, gcmM_size);\n  prefetch_table(&gcm_table, sizeof(gcm_table));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "create_spnego_ctx(void)\n{\n\tspnego_gss_ctx_id_t spnego_ctx = NULL;\n\tspnego_ctx = (spnego_gss_ctx_id_t)\n\t\tmalloc(sizeof (spnego_gss_ctx_id_rec));\n\n\tspnego_ctx->default_cred = GSS_C_NO_CREDENTIAL;\n\tspnego_ctx->mic_reqd = 0;\n\tspnego_ctx->mic_sent = 0;\n\tspnego_ctx->mic_rcvd = 0;\n\tspnego_ctx->mech_complete = 0;\n\tspnego_ctx->nego_done = 0;\n\tspnego_ctx->internal_name = GSS_C_NO_NAME;\n\tspnego_ctx->actual_mech = GSS_C_NO_OID;\n\n\tcheck_spnego_options(spnego_ctx);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "create_spnego_ctx(int initiate)\n{\n\tspnego_gss_ctx_id_t spnego_ctx = NULL;\n\tspnego_ctx = (spnego_gss_ctx_id_t)\n\t\tmalloc(sizeof (spnego_gss_ctx_id_rec));\n\n\tspnego_ctx->mic_reqd = 0;\n\tspnego_ctx->mic_sent = 0;\n\tspnego_ctx->mic_rcvd = 0;\n\tspnego_ctx->mech_complete = 0;\n\tspnego_ctx->nego_done = 0;\n\tspnego_ctx->opened = 0;\n\tspnego_ctx->initiate = initiate;\n\tspnego_ctx->internal_name = GSS_C_NO_NAME;\n\tspnego_ctx->actual_mech = GSS_C_NO_OID;\n\n\tcheck_spnego_options(spnego_ctx);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                        GsmXsmpServer *server,\n                        unsigned long *mask_ret,\n                        SmsCallbacks  *callbacks_ret,\n                        char         **failure_reason_ret)\n{\n        IceConn        ice_conn;\n        GsmXSMPClient *client;\n\n        /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */\n        if (server->priv->xsmp_sockets == NULL) {\n                g_debug (\"GsmXsmpServer: In shutdown, rejecting new client\");\n\n                *failure_reason_ret = strdup (_(\"Refusing new client connection because the session is currently being shut down\\n\"));\n                return FALSE;\n        }\n\n        ice_conn = SmsGetIceConnection (sms_conn);\n        client = ice_conn->context;\n\n        g_return_val_if_fail (client != NULL, TRUE);\n\n        gsm_xsmp_client_connect (client, sms_conn, mask_ret, callbacks_ret);\n\n        return TRUE;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                        GsmXsmpServer *server,\n                        unsigned long *mask_ret,\n                        SmsCallbacks  *callbacks_ret,\n                        char         **failure_reason_ret)\n{\n        IceConn                ice_conn;\n        GsmClient             *client;\n        GsmIceConnectionWatch *data;\n\n        /* FIXME: what about during shutdown but before gsm_xsmp_shutdown? */\n        if (server->priv->xsmp_sockets == NULL) {\n                g_debug (\"GsmXsmpServer: In shutdown, rejecting new client\");\n\n                *failure_reason_ret = strdup (_(\"Refusing new client connection because the session is currently being shut down\\n\"));\n                return FALSE;\n        }\n\n        ice_conn = SmsGetIceConnection (sms_conn);\n        data = ice_conn->context;\n\n        /* Each GsmXSMPClient has its own IceConn watcher */\n        free_ice_connection_watch (data);\n\n        client = gsm_xsmp_client_new (ice_conn);\n\n        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));\n        /* the store will own the ref */\n        g_object_unref (client);\n\n        gsm_xsmp_client_connect (GSM_XSMP_CLIENT (client), sms_conn, mask_ret, callbacks_ret);\n\n        return TRUE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "file_extension(const char *s)\t/* I - Filename or URL */\n{\n  const char\t*extension;\t/* Pointer to directory separator */\n  static char\tbuf[1024];\t/* Buffer for files with targets */\n\n\n  if (s == NULL)\n    return (NULL);\n  if (strchr(extension, '#') == NULL)\n    return (extension);\n\n  strlcpy(buf, extension, sizeof(buf));\n\n  *(char *)strchr(buf, '#') = '\\0';\n\n  return (buf);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "file_extension(const char *s)\t/* I - Filename or URL */\n{\n  const char\t*extension;\t/* Pointer to directory separator */\n  char\t\t*bufptr;\t/* Pointer into buffer */\n  static char\tbuf[1024];\t/* Buffer for files with targets */\n\n\n  if (s == NULL)\n    return (NULL);\n  if (strchr(extension, '#') == NULL)\n    return (extension);\n\n  strlcpy(buf, extension, sizeof(buf));\n\n  if ((bufptr = strchr(buf, '#')) != NULL)\n    *bufptr = '\\0';\n\n  return (buf);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tevtchn_to_irq[row][col] = -1;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void clear_evtchn_to_irq_row(unsigned row)\n{\n\tunsigned col;\n\n\tfor (col = 0; col < EVTCHN_PER_ROW; col++)\n\t\tWRITE_ONCE(evtchn_to_irq[row][col], -1);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tphysical_offset, devid);\n\t\tret = -EUCLEAN;\n\t}\n\n\t/* Make sure no dev extent is beyond device bondary */\n\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL);\n\tif (!dev) {\n\t\tbtrfs_err(fs_info, \"failed to find devid %llu\", devid);\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\n\t/* It's possible this device is a dummy for seed device */\n\tif (dev->disk_total_bytes == 0) {\n\t\tdev = find_device(fs_info->fs_devices->seed, devid, NULL);\n\t\tif (!dev) {\n\t\t\tbtrfs_err(fs_info, \"failed to find seed devid %llu\",\n\t\t\t\t  devid);\n\t\t\tret = -EUCLEAN;\n\t\t\tgoto out;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tphysical_offset, devid);\n\t\tret = -EUCLEAN;\n\t}\n\n\t/* Make sure no dev extent is beyond device bondary */\n\tdev = btrfs_find_device(fs_info->fs_devices, devid, NULL, NULL, true);\n\tif (!dev) {\n\t\tbtrfs_err(fs_info, \"failed to find devid %llu\", devid);\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\n\t/* It's possible this device is a dummy for seed device */\n\tif (dev->disk_total_bytes == 0) {\n\t\tdev = btrfs_find_device(fs_info->fs_devices->seed, devid, NULL,\n\t\t\t\t\tNULL, false);\n\t\tif (!dev) {\n\t\t\tbtrfs_err(fs_info, \"failed to find seed devid %llu\",\n\t\t\t\t  devid);\n\t\t\tret = -EUCLEAN;\n\t\t\tgoto out;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "DH *get_dh2048(void)\n{\n    static unsigned char dhp_2048[] = {\n        0xD5, 0x75, 0xF1, 0x23, 0xC1, 0x81, 0x4B, 0x44, 0x23, 0xBE,\n        0x97, 0x81, 0x7A, 0xDA, 0x97, 0x1F, 0x1F, 0x0D, 0xD5, 0xEC,\n        0xC5, 0x5F, 0x86, 0x42, 0x7F, 0x38, 0xA3, 0x95, 0xEE, 0xA0,\n        0x52, 0x2C, 0xB7, 0x20, 0x29, 0xC1, 0xC7, 0xE6, 0x8E, 0x6F,\n        0xE5, 0xC1, 0x0D, 0xDD, 0x8A, 0xEF, 0x8D, 0xE7, 0xA8, 0x63,\n        0xB4, 0xF7, 0x58, 0x32, 0x0E, 0x24, 0xAC, 0x30, 0x94, 0xF5,\n        0xC7, 0x02, 0x81, 0x1B, 0xC7, 0x68, 0xE5, 0x71, 0xD7, 0x1E,\n        0x3D, 0xE4, 0x2E, 0x2F, 0xC0, 0x0A, 0xED, 0x34, 0xAC, 0xC0,\n        0x1F, 0x0A, 0x56, 0xA4, 0x12, 0x02, 0xFD, 0x68, 0xD2, 0x4D,\n        0x5E, 0x0A, 0x5D, 0x78, 0xE3, 0xA0, 0x85, 0x75, 0xD2, 0xA9,\n        0xC1, 0xF2, 0xAD, 0x65, 0x11, 0xDE, 0xE8, 0x05, 0x68, 0x36,\n        0x4C, 0x92, 0x99, 0x21, 0xB9, 0x69, 0xD0, 0x6F, 0xD8, 0xA3,\n        0xEA, 0x35, 0x13, 0x93, 0xDC, 0x1B, 0x13, 0x16, 0xB2, 0x15,\n        0x8E, 0x10, 0x22, 0xCE, 0x01, 0x1F, 0x1C, 0x09, 0x86, 0xD5,\n        0xE7, 0xCB, 0xCF, 0xFA, 0xED, 0x2F, 0xE2, 0x3A, 0x65, 0x14,\n        0xC9, 0xFA, 0x70, 0x99, 0xF7, 0xE0, 0x30, 0xBF, 0x7F, 0xEA,\n        0x84, 0x14, 0x8A, 0x51, 0xC9, 0xE9, 0x85, 0x73, 0x7F, 0xA1,\n        0xB0, 0xC3, 0x33, 0x9A, 0xAB, 0x69, 0x4E, 0x75, 0xFB, 0x12,\n        0xB0, 0x9E, 0xB1, 0xD9, 0xD1, 0xB9, 0x32, 0x1D, 0xC6, 0xD9,\n        0x2C, 0xAA, 0xB0, 0xC5, 0x3E, 0x69, 0x56, 0xA2, 0xB3, 0xA2,\n        0x81, 0xCA, 0x9D, 0x77, 0xBB, 0x52, 0x44, 0xA2, 0xED, 0xE0,\n        0xF0, 0x2A, 0x81, 0x85, 0x90, 0xB6, 0x04, 0x60, 0xEB, 0x09,\n        0x72, 0x08, 0x44, 0xAF, 0x28, 0xF5, 0x15, 0x34, 0x87, 0x5C,\n        0x8A, 0xB4, 0x5B, 0x15, 0x6A, 0xAD, 0x27, 0x4E, 0xA0, 0xDE,\n        0x99, 0x22, 0xCF, 0xAB, 0x4C, 0xFD, 0x75, 0x10, 0x5D, 0xFF,\n        0xE8, 0x81, 0x50, 0xC4, 0xC0, 0x4B\n    };\n    static unsigned char dhg_2048[] = {\n        0x02\n    };\n    DH *dh = DH_new();",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "DH *get_dh2048(void)\n{\n    static unsigned char dhp_2048[] = {\n        0xCF, 0x9F, 0x3A, 0x9C, 0xC5, 0xA5, 0x89, 0x27, 0x6D, 0x2C,\n        0x2C, 0xF3, 0xA6, 0x00, 0xD2, 0x7C, 0xEA, 0xFA, 0xF2, 0x43,\n        0x4F, 0x49, 0x0A, 0xFC, 0xA6, 0xE7, 0x75, 0xCA, 0x07, 0xDC,\n        0xA5, 0xF2, 0x83, 0x4E, 0x5A, 0xA0, 0xA0, 0xF5, 0x9C, 0xFD,\n        0x02, 0xE6, 0x9E, 0xFC, 0x01, 0x59, 0xD7, 0xB6, 0xC1, 0x4E,\n        0xC0, 0xB6, 0x71, 0x49, 0xF0, 0xC7, 0xD5, 0x2F, 0x8D, 0xDF,\n        0xD3, 0xF1, 0x82, 0x82, 0x23, 0x33, 0x13, 0x93, 0xEB, 0x50,\n        0x29, 0xFD, 0x1B, 0x5A, 0x2F, 0xD5, 0x08, 0x99, 0x64, 0xE9,\n        0x7B, 0x1A, 0xDD, 0x68, 0x16, 0x08, 0xD0, 0x13, 0x82, 0xB6,\n        0x86, 0x62, 0x76, 0xAA, 0x16, 0x14, 0xCC, 0x86, 0x72, 0x26,\n        0x45, 0x8E, 0x2A, 0x82, 0x5B, 0x6F, 0xC1, 0xDF, 0xAA, 0x18,\n        0x43, 0xB8, 0xAD, 0x84, 0x52, 0xF2, 0xD9, 0x9C, 0xC0, 0x47,\n        0x52, 0x1B, 0x8E, 0x42, 0xC4, 0xD3, 0x61, 0x7B, 0x65, 0xA7,\n        0x69, 0x03, 0xB5, 0xD4, 0x6C, 0x83, 0x6A, 0x46, 0x73, 0xAF,\n        0x76, 0x77, 0x70, 0xC2, 0xD0, 0x74, 0xFE, 0x78, 0xF5, 0x75,\n        0x3B, 0xCE, 0xE2, 0xB6, 0xA0, 0x25, 0xE9, 0xE8, 0x4B, 0xA2,\n        0xF1, 0x20, 0x88, 0x13, 0x07, 0xED, 0x66, 0xBC, 0x46, 0xA1,\n        0xB3, 0x44, 0xAF, 0x2C, 0xED, 0x73, 0x75, 0x3D, 0x14, 0x6E,\n        0x43, 0x92, 0x40, 0x99, 0xB0, 0xD1, 0xBF, 0x2C, 0x4D, 0x0F,\n        0x2A, 0x63, 0xF4, 0x85, 0x7B, 0x1B, 0x0E, 0x48, 0x5A, 0x06,\n        0x02, 0xA6, 0x3D, 0x9E, 0x78, 0x05, 0xA8, 0x7C, 0xAD, 0x54,\n        0x49, 0xDE, 0x7A, 0xE6, 0x36, 0x5C, 0x50, 0xFC, 0x09, 0x81,\n        0x9E, 0x83, 0x53, 0x8C, 0x42, 0xEF, 0x12, 0x36, 0x4F, 0x22,\n        0x16, 0x2A, 0x15, 0x88, 0x83, 0xA9, 0x00, 0x66, 0x9E, 0xD1,\n        0xDC, 0x0F, 0x54, 0xC0, 0x32, 0x5C, 0x4C, 0x5E, 0xE2, 0x3D,\n        0xBC, 0x56, 0x89, 0x75, 0x28, 0xA3\n    };\n    static unsigned char dhg_2048[] = {\n        0x02\n    };\n    DH *dh = DH_new();",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        member_count = me.second.m_member_memos.size();\n        for (auto& mme : me.second.m_member_memos) {\n          if (mme.second.m_return_value != fr) all_same = false;\n          count += mme.second.m_count;\n          auto ser_len = mme.second.m_return_value.length();\n          min_ser_len = std::min(min_ser_len, ser_len);\n          max_ser_len = std::max(max_ser_len, ser_len);\n          if (mme.second.m_count > 1) any_multiple = true;\n        }\n        if (!any_multiple && !all_same) continue;\n      } else {\n        min_ser_len = max_ser_len = me.second.m_return_value.length();",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        member_count = me.second.m_member_memos.size();\n        for (auto& mme : me.second.m_member_memos) {\n          if (mme.second.m_return_value != fr) all_same = false;\n          count += mme.second.m_count;\n          auto ser_len = mme.second.m_return_value.length();\n          min_ser_len = std::min<int64_t>(min_ser_len, ser_len);\n          max_ser_len = std::max<int64_t>(max_ser_len, ser_len);\n          if (mme.second.m_count > 1) any_multiple = true;\n        }\n        if (!any_multiple && !all_same) continue;\n      } else {\n        min_ser_len = max_ser_len = me.second.m_return_value.length();",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t}\n\tut64 starts_at = offset + header.starts_offset;\n\tif (header.starts_offset > size) {\n\t\treturn false;\n\t}\n\tut32 segs_count;\n\tif ((segs_count = r_buf_read_le32_at (bin->b, starts_at)) == UT32_MAX) {\n\t\treturn false;\n\t}\n\tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, segs_count);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tbin->fixups_header = header;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t}\n\tut64 starts_at = offset + header.starts_offset;\n\tif (header.starts_offset > size) {\n\t\treturn false;\n\t}\n\tut32 segs_count = r_buf_read_le32_at (bin->b, starts_at);\n\tif (segs_count == UT32_MAX || segs_count == 0) {\n\t\treturn false;\n\t}\n\tbin->segs_count = segs_count;\n\tbin->chained_starts = R_NEWS0 (struct r_dyld_chained_starts_in_segment *, segs_count);\n\tif (!bin->chained_starts) {\n\t\treturn false;\n\t}\n\tbin->fixups_header = header;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\n\tseq_puts(m, key->description);\n\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \": %zu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\n\tseq_puts(m, key->description);\n\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \": %zu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t     send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\tsc = create_spnego_ctx();\n\tif (sc == NULL)\n\t\treturn GSS_S_FAILURE;\n\n\t/* determine negotiation mech set */\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,\n\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\t/*\n\t * The actual context is not yet determined, set the output\n\t * context handle to refer to the spnego context itself.\n\t */\n\tsc->ctx_handle = GSS_C_NO_CONTEXT;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\t*tokflag = INIT_TOKEN_SEND;\n\tret = GSS_S_CONTINUE_NEEDED;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t     send_token_flag *tokflag)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = NULL;\n\n\tsc = create_spnego_ctx(1);\n\tif (sc == NULL)\n\t\treturn GSS_S_FAILURE;\n\n\t/* determine negotiation mech set */\n\tret = get_negotiable_mechs(minor_status, spcred, GSS_C_INITIATE,\n\n\tif (put_mech_set(sc->mech_set, &sc->DER_mechTypes) < 0) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\n\tsc->ctx_handle = GSS_C_NO_CONTEXT;\n\t*ctx = (gss_ctx_id_t)sc;\n\tsc = NULL;\n\t*tokflag = INIT_TOKEN_SEND;\n\tret = GSS_S_CONTINUE_NEEDED;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t\t/*\n\t\t * Get a reference to this pipe buffer,\n\t\t * so we can copy the contents over.\n\t\t */\n\t\tpipe_buf_get(ipipe, ibuf);\n\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\n\t\t/*",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\t\t/*\n\t\t * Get a reference to this pipe buffer,\n\t\t * so we can copy the contents over.\n\t\t */\n\t\tif (!pipe_buf_get(ipipe, ibuf)) {\n\t\t\tif (ret == 0)\n\t\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\n\t\t/*",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int jpg_dec_parseopts(char *optstr, jpg_dec_importopts_t *opts)\n{\n\tjas_tvparser_t *tvp;\n\n\topts->max_size = 0;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\treturn -1;\n\t}\n\n\twhile (!jas_tvparser_next(tvp)) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_MAXSIZE:\n\t\t\topts->max_size = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t  jas_tvparser_gettag(tvp));\n\t\t\tbreak;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int jpg_dec_parseopts(char *optstr, jpg_dec_importopts_t *opts)\n{\n\tjas_tvparser_t *tvp;\n\n\topts->max_samples = 64 * JAS_MEBI;\n\n\tif (!(tvp = jas_tvparser_create(optstr ? optstr : \"\"))) {\n\t\treturn -1;\n\t}\n\n\twhile (!jas_tvparser_next(tvp)) {\n\t\tswitch (jas_taginfo_nonull(jas_taginfos_lookup(decopts,\n\t\t  jas_tvparser_gettag(tvp)))->id) {\n\t\tcase OPT_MAXSIZE:\n\t\t\topts->max_samples = atoi(jas_tvparser_getval(tvp));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tjas_eprintf(\"warning: ignoring invalid option %s\\n\",\n\t\t\t  jas_tvparser_gettag(tvp));\n\t\t\tbreak;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void dbOutputHexBlob(Jsi_DString *dStr, const void *pBlob, int nBlob){\n  int i;\n  char out[100], *zBlob = (char *)pBlob;\n  Jsi_DSAppend(dStr, \"X'\", NULL);\n  for(i=0; i<nBlob; i++){ snprintf(out, sizeof(out),\"%02x\",zBlob[i]&0xff);Jsi_DSAppend(dStr, out, NULL); }\n  Jsi_DSAppend(dStr, \"'\", NULL);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void dbOutputHexBlob(Jsi_DString *dStr, const void *pBlob, int nBlob){\n  int i;\n  char out[JSI_MAX_NUMBER_STRING], *zBlob = (char *)pBlob;\n  Jsi_DSAppend(dStr, \"X'\", NULL);\n  for(i=0; i<nBlob; i++){ snprintf(out, sizeof(out),\"%02x\",zBlob[i]&0xff);Jsi_DSAppend(dStr, out, NULL); }\n  Jsi_DSAppend(dStr, \"'\", NULL);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "#ifdef MAXSEG_64K\n    return Z_STREAM_ERROR;\n#else\n    deflate_state *ds;\n    deflate_state *ss;\n    ushf *overlay;\n\n\n    if (deflateStateCheck(source) || dest == Z_NULL) {\n        return Z_STREAM_ERROR;\n    }\n    ds->strm = dest;\n\n    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));\n    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));\n    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);\n    ds->pending_buf = (uchf *) overlay;\n\n    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||\n        ds->pending_buf == Z_NULL) {\n        deflateEnd (dest);\n        return Z_MEM_ERROR;\n    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));\n    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));\n    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n\n    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);\n    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);\n    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;\n\n    ds->l_desc.dyn_tree = ds->dyn_ltree;\n    ds->d_desc.dyn_tree = ds->dyn_dtree;\n    ds->bl_desc.dyn_tree = ds->bl_tree;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n#ifdef MAXSEG_64K\n    return Z_STREAM_ERROR;\n#else\n    deflate_state *ds;\n    deflate_state *ss;\n\n\n    if (deflateStateCheck(source) || dest == Z_NULL) {\n        return Z_STREAM_ERROR;\n    }\n    ds->strm = dest;\n\n    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));\n    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));\n    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));\n    ds->pending_buf = (uchf *) ZALLOC(dest, ds->lit_bufsize, 4);\n\n    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||\n        ds->pending_buf == Z_NULL) {\n        deflateEnd (dest);\n        return Z_MEM_ERROR;\n    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));\n    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));\n    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);\n\n    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);\n    ds->sym_buf = ds->pending_buf + ds->lit_bufsize;\n\n    ds->l_desc.dyn_tree = ds->dyn_ltree;\n    ds->d_desc.dyn_tree = ds->dyn_dtree;\n    ds->bl_desc.dyn_tree = ds->bl_tree;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  const float float_activation_max = params.float_activation_max;\n  float* data_ptr = output_data;\n  if (bias_data) {\n    const int outer_size =\n        batches * output_depth * output_height * output_width;\n    const int num_channels = input_shape.Dims(4);\n    for (int n = 0; n < outer_size; ++n) {\n      for (int c = 0; c < output_num_channels; ++c) {\n        data_ptr[c] = ActivationFunctionWithMinMax(data_ptr[c] + bias_data[c],\n                                                   float_activation_min,\n                                                   float_activation_max);\n      }\n      data_ptr += num_channels;\n    }\n  } else {\n    const int flat_size = output_shape.FlatSize();\n    for (int i = 0; i < flat_size; ++i) {\n      data_ptr[i] = ActivationFunctionWithMinMax(",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  const float float_activation_min = params.float_activation_min;\n  const float float_activation_max = params.float_activation_max;\n  float* data_ptr = output_data;\n  if (bias_data) {\n    const int outer_size =\n        batches * output_depth * output_height * output_width;\n    for (int n = 0; n < outer_size; ++n) {\n      for (int c = 0; c < output_num_channels; ++c) {\n        data_ptr[c] = ActivationFunctionWithMinMax(data_ptr[c] + bias_data[c],\n                                                   float_activation_min,\n                                                   float_activation_max);\n      }\n      data_ptr += output_num_channels;\n    }\n  } else {\n    const int flat_size = output_shape.FlatSize();\n    for (int i = 0; i < flat_size; ++i) {\n      data_ptr[i] = ActivationFunctionWithMinMax(",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static mif_hdr_t *mif_hdr_get(jas_stream_t *in)\n{\n\tuchar magicbuf[MIF_MAGICLEN];\n\tchar buf[4096];\n\tmif_hdr_t *hdr;\n\tbool done;\n\tjas_tvparser_t *tvp;\n\tint id;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static mif_hdr_t *mif_hdr_get(jas_stream_t *in)\n{\n\tjas_uchar magicbuf[MIF_MAGICLEN];\n\tchar buf[4096];\n\tmif_hdr_t *hdr;\n\tbool done;\n\tjas_tvparser_t *tvp;\n\tint id;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    int length() { return ptr - start; }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    size_t length() { return ptr - start; }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tint element_counter;\n\tchar **elements;\n\tchar *query_str;\n\tstruct collect_query collect_query;\n\tint i;\n\tint j;\n\tint length = 0;\n\n\tdebug(LOG_DEBUG, \" Getting query, separator is [%s].\", separator);\n\n\telement_counter = MHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, counter_iterator, NULL);\n\t\tif (!elements[i])\n\t\t\tcontinue;\n\t\tlength += strlen(elements[i]);\n\n\t\tif (i > 0) // q=foo&o=bar the '&' need also some space\n\t\t\tlength++;\n\t}\n\n\t// don't miss the zero terminator\n\tif (*query == NULL) {\n\t\tfor (i = 0; i < element_counter; i++) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdebug(LOG_DEBUG, \" element [%d] is [%s]\", i, elements[i]);\n\n\t\tstrncpy(*query + j, elements[i], length - j);\n\t\tif (i == 0) {\n\t\t\t// query_str is empty when i = 0 so safe to copy a single char into it\n\t\t\tstrcpy(query_str, \"?\");\n\t\t} else {\n\t\t\tif (QUERYMAXLEN - strlen(query_str) > length - j + 1) {\n\t\t\t\tstrncat(query_str, separator, QUERYMAXLEN - strlen(query_str));\n\t\t\t}\n\t\t}\n\n\t\t// note: query string will be truncated if too long\n\t\tif (QUERYMAXLEN - strlen(query_str) > length - j) {\n\t\t\tstrncat(query_str, *query, QUERYMAXLEN - strlen(query_str));\n\t\t} else {\n\t\t\tdebug(LOG_WARNING, \" Query string exceeds the maximum of %d bytes so has been truncated.\", QUERYMAXLEN/2);\n\t\t}\n\n\t\tfree(elements[i]);\n\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tint element_counter;\n\tchar **elements;\n\tchar *query_str;\n\tstruct collect_query collect_query;\n\tint i;\n\tint j = 4;\n\tint length = 0;\n\n\tdebug(LOG_DEBUG, \" Getting query, separator is [%s].\", separator);\n\n\telement_counter = MHD_get_connection_values(connection, MHD_GET_ARGUMENT_KIND, counter_iterator, NULL);\n\t\t\tcontinue;\n\t\tlength += strlen(elements[i]);\n\n\t\tif (i > 0) // q=foo&o=bar the '&' need also some space\n\t\t\tlength++;\n\n\t\tdebug(LOG_DEBUG, \" cumulative element length is [%d]\", length);\n\t}\n\n\t// don't miss the zero terminator\n\tif (*query == NULL) {\n\t\tfor (i = 0; i < element_counter; i++) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdebug(LOG_DEBUG, \" element [%d] is [%s]\", i, elements[i]);\n\n\t\tif (length + j < QUERYMAXLEN) {\n\n\t\t\tstrncpy(*query + j, elements[i], length - j);\n\n\t\t\tif (i == 0) {\n\t\t\t\t// query_str is empty when i = 0 so safe to copy a single char into it\n\t\t\t\tstrcpy(query_str, \"?\");\n\t\t\t} else {\n\t\t\t\tif (QUERYMAXLEN - strlen(query_str) > length - j + 1) {\n\t\t\t\t\tstrncat(query_str, separator, QUERYMAXLEN - strlen(query_str));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstrncat(query_str, *query, QUERYMAXLEN - strlen(query_str));\n\t\t} else {\n\t\t\tdebug(LOG_WARNING, \" Query string is too long, invalid or corrupt so is ignored.\");\n\t\t}\n\n\t\tfree(elements[i]);\n\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  state.writeRecordLayer()->setProtocolVersion(*version);\n\n  validateClientHello(chlo);\n\n  auto cipher = negotiateCipher(chlo, state.context()->getSupportedCiphers());\n\n  verifyCookieState(cookieState, *version, cipher);\n\n  auto resStateResult = getResumptionState(\n      chlo,\n      state.context()->getTicketCipher(),\n            resState,\n            cookieState,\n            pskType,\n            std::move(state.handshakeContext()),\n            version);\n\n        if (state.cipher().has_value() && cipher != *state.cipher()) {\n          throw FizzException(\n              \"cipher mismatch with previous negotiation\",\n              AlertDescription::illegal_parameter);\n        }\n\n        auto alpn = negotiateAlpn(chlo, folly::none, *state.context());\n\n        auto clockSkew = getClockSkew(\n            resState,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n  validateClientHello(chlo);\n\n  auto cipher = negotiateCipher(chlo, state.context()->getSupportedCiphers());\n\n  if (state.cipher().has_value() && cipher != *state.cipher()) {\n    throw FizzException(\n        \"cipher mismatch with previous negotiation\",\n        AlertDescription::illegal_parameter);\n  }\n\n  verifyCookieState(cookieState, *version, cipher);\n\n  auto resStateResult = getResumptionState(\n      chlo,\n      state.context()->getTicketCipher(),\n            chlo,\n            resState,\n            cookieState,\n            pskType,\n            std::move(state.handshakeContext()),\n            version);\n\n        auto alpn = negotiateAlpn(chlo, folly::none, *state.context());\n\n        auto clockSkew = getClockSkew(\n            resState,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\n\tif (!valid_localpart(maddr->user) ||\n\t    !valid_domainpart(maddr->domain)) {\n\t\t/* accept empty return-path in MAIL FROM, required for bounces */\n\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\t\treturn (1);\n\n\t\t/* no user-part, reject */\n\t\tif (maddr->user[0] == '\\0')\n\t\t\treturn (0);\n\n\t\t/* no domain, local user */\n\t\tif (maddr->domain[0] == '\\0') {\n\t\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\t    sizeof(maddr->domain));\n\t\t\treturn (1);\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (1);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\n\t/* accept empty return-path in MAIL FROM, required for bounces */\n\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\treturn (1);\n\n\t/* no or invalid user-part, reject */\n\tif (maddr->user[0] == '\\0' || !valid_localpart(maddr->user))\n\t\treturn (0);\n\n\t/* no domain part, local user */\n\tif (maddr->domain[0] == '\\0') {\n\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\tsizeof(maddr->domain));\n\t}\n\n\tif (!valid_domainpart(maddr->domain))\n\t\treturn (0);\n\n\treturn (1);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "cib_remote_msg(gpointer data)\n{\n    const char *value = NULL;\n    xmlNode *command = NULL;\n    cib_client_t *client = data;\n\n    crm_trace(\"%s callback\", client->encrypted ? \"secure\" : \"clear-text\");\n\n    command = crm_recv_remote_msg(client->session, client->encrypted);\n    if (command == NULL) {\n        return -1;\n    }\n\n    value = crm_element_name(command);\n    if (safe_str_neq(value, \"cib_command\")) {\n        crm_log_xml_trace(command, \"Bad command: \");\n        goto bail;\n    }\n\n    if (client->name == NULL) {\n        value = crm_element_value(command, F_CLIENTNAME);\n        if (value == NULL) {\n            client->name = strdup(client->id);\n        } else {\n            client->name = strdup(value);\n        }\n    }\n\n    if (client->callback_id == NULL) {\n        value = crm_element_value(command, F_CIB_CALLBACK_TOKEN);\n        if (value != NULL) {\n            client->callback_id = strdup(value);\n            crm_trace(\"Callback channel for %s is %s\", client->id, client->callback_id);\n\n        } else {\n            client->callback_id = strdup(client->id);\n        }\n    }\n\n    /* unset dangerous options */\n    xml_remove_prop(command, F_ORIG);\n    xml_remove_prop(command, F_CIB_HOST);\n    xml_remove_prop(command, F_CIB_GLOBAL_UPDATE);\n\n    crm_xml_add(command, F_TYPE, T_CIB);\n    crm_xml_add(command, F_CIB_CLIENTID, client->id);\n    crm_xml_add(command, F_CIB_CLIENTNAME, client->name);\n#if ENABLE_ACL\n    crm_xml_add(command, F_CIB_USER, client->user);\n#endif\n\n    if (crm_element_value(command, F_CIB_CALLID) == NULL) {\n        char *call_uuid = crm_generate_uuid();\n\n        /* fix the command */\n        crm_xml_add(command, F_CIB_CALLID, call_uuid);\n        free(call_uuid);\n    }\n\n    if (crm_element_value(command, F_CIB_CALLOPTS) == NULL) {\n        crm_xml_add_int(command, F_CIB_CALLOPTS, 0);\n    }\n\n    crm_log_xml_trace(command, \"Remote command: \");\n    cib_common_callback_worker(0, 0, command, client, TRUE);\n  bail:\n    free_xml(command);\n    command = NULL;\n    return 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "cib_remote_msg(gpointer data)\n{\n    xmlNode *command = NULL;\n    cib_client_t *client = data;\n    int disconnected = 0;\n    int timeout = client->remote_auth ? -1 : 1000;\n\n    crm_trace(\"%s callback\", client->encrypted ? \"secure\" : \"clear-text\");\n\n#ifdef HAVE_GNUTLS_GNUTLS_H\n    if (client->encrypted && (client->handshake_complete == FALSE)) {\n        int rc = 0;\n\n        /* Muliple calls to handshake will be required, this callback\n         * will be invoked once the client sends more handshake data. */\n        do {\n            rc = gnutls_handshake(*client->session);\n\n            if (rc < 0 && rc != GNUTLS_E_AGAIN) {\n                crm_err(\"Remote cib tls handshake failed\");\n                return -1;\n            }\n        } while (rc == GNUTLS_E_INTERRUPTED);\n\n        if (rc == 0) {\n            crm_debug(\"Remote cib tls handshake completed\");\n            client->handshake_complete = TRUE;\n            if (client->remote_auth_timeout) {\n                g_source_remove(client->remote_auth_timeout);\n            }\n            /* after handshake, clients must send auth in a few seconds */\n            client->remote_auth_timeout = g_timeout_add(REMOTE_AUTH_TIMEOUT, remote_auth_timeout_cb, client);\n        }\n        return 0;\n    }\n#endif\n\n    crm_recv_remote_msg(client->session, &client->recv_buf, client->encrypted, timeout, &disconnected);\n\n    /* must pass auth before we will process anything else */\n    if (client->remote_auth == FALSE) {\n        xmlNode *reg;\n#if ENABLE_ACL\n        const char *user = NULL;\n#endif\n        command = crm_parse_remote_buffer(&client->recv_buf);\n        if (cib_remote_auth(command) == FALSE) {\n            free_xml(command);\n            return -1;\n        }\n\n        crm_debug(\"remote connection authenticated successfully\");\n        client->remote_auth = TRUE;\n        g_source_remove(client->remote_auth_timeout);\n        client->remote_auth_timeout = 0;\n        client->name = crm_element_value_copy(command, \"name\");\n\n#if ENABLE_ACL\n        user = crm_element_value(command, \"user\");\n        if (user) {\n           new_client->user = strdup(user);\n        }\n#endif\n\n        /* send ACK */\n        reg = create_xml_node(NULL, \"cib_result\");\n        crm_xml_add(reg, F_CIB_OPERATION, CRM_OP_REGISTER);\n        crm_xml_add(reg, F_CIB_CLIENTID, client->id);\n        crm_send_remote_msg(client->session, reg, client->encrypted);\n        free_xml(reg);\n        free_xml(command);\n    }\n\n    command = crm_parse_remote_buffer(&client->recv_buf);\n    while (command) {\n        crm_trace(\"command received\");\n        cib_handle_remote_msg(client, command);\n        free_xml(command);\n        command = crm_parse_remote_buffer(&client->recv_buf);\n    }\n\n    if (disconnected) {\n        crm_trace(\"disconnected while receiving remote cib msg.\");\n        return -1;\n    }\n\n    return 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    return NULL;\n  }\n\n  // Check for OOM before doing a potentially large allocation.\n  auto allocsz = sizeof(gdImage)\n    + sy * (sizeof(int *) + sizeof(unsigned char *))\n    + sx * sy * (sizeof(int) + sizeof(unsigned char));\n  if (UNLIKELY(precheckOOM(allocsz))) {\n    // Don't throw here because GD might need to do its own cleanup.\n    return NULL;\n  }\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    return NULL;\n  }\n\n  // Check for OOM before doing a potentially large allocation.\n  auto allocsz = sizeof(gdImage)\n    + (sizeof(int *) + sizeof(unsigned char *)) * sy\n    + (sizeof(int) + sizeof(unsigned char)) * sx * sy;\n  if (UNLIKELY(precheckOOM(allocsz))) {\n    // Don't throw here because GD might need to do its own cleanup.\n    return NULL;\n  }\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                        int index) {\n  if (index >= 0 && index < node->outputs->size) {\n    const int tensor_index = node->outputs->data[index];\n    if (tensor_index != kTfLiteOptionalTensor) {\n      if (context->tensors != nullptr) {\n        return &context->tensors[tensor_index];\n      } else {\n        return context->GetTensor(context, tensor_index);\n      }\n    }\n  }\n  return nullptr;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,\n                        int index) {\n  const int tensor_index = ValidateTensorIndexing(\n      context, index, node->outputs->size, node->outputs->data);\n  if (tensor_index < 0) {\n    return nullptr;\n  }\n  return GetTensorAtIndex(context, tensor_index);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n    bool has_location = false;\n    for (const StringStringEntryProto& entry : tensor.external_data()) {\n      if (entry.has_key() && entry.has_value() && entry.key() == \"location\") {\n        has_location = true;\n        std::string data_path = path_join(ctx.get_model_dir(), entry.value());\n        // use stat to check whether the file exists\n        struct stat buffer;\n        if (stat((data_path).c_str(), &buffer) != 0) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be stored in \",\n              data_path,\n              \", but it doesn't exist or is not accessible.\");\n        }\n      }\n    }\n    if (!has_location) {\n      fail_check(\"TensorProto ( tensor name: \", tensor.name(), \") is stored externally but doesn't have a location.\");\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n    bool has_location = false;\n    for (const StringStringEntryProto& entry : tensor.external_data()) {\n      if (entry.has_key() && entry.has_value() && entry.key() == \"location\") {\n        has_location = true;\n        std::string relative_path = clean_relative_path(entry.value());\n        // Check that normalized relative path starts with \"../\" or \"..\\\" on windows.\n        if (relative_path.rfind(\"..\" + k_preferred_path_separator, 0) == 0) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be file inside the \",\n              ctx.get_model_dir(),\n              \", but the '\",\n              entry.value(),\n              \"' points outside the directory\");\n        }\n\n        std::string data_path = path_join(ctx.get_model_dir(), relative_path);\n        // use stat to check whether the file exists\n        struct stat buffer;\n        if (stat((data_path).c_str(), &buffer) != 0) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be stored in \",\n              data_path,\n              \", but it doesn't exist or is not accessible.\");\n        }\n#ifdef _WIN32\n#else // POSIX\n      //  Do not allow symlinks or directories.\n        if (!S_ISREG(buffer.st_mode)) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be stored in \",\n              data_path,\n              \", but it is not regular file.\");\n        }\n#endif\n      }\n    }\n    if (!has_location) {\n      fail_check(\"TensorProto ( tensor name: \", tensor.name(), \") is stored externally but doesn't have a location.\");\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  int __pyx_t_5;\n  int __pyx_t_6;\n  __Pyx_RefNannySetupContext(\"__reduce_cython__\", 0);\n\n  /* \"(tree fragment)\":5\n *     cdef object _dict\n *     cdef bint use_setstate\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:\n */\n  __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->buffer); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = PyInt_FromSsize_t(__pyx_v_self->buffer_size); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_3 = PyInt_FromSsize_t(__pyx_v_self->position); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __Pyx_GIVEREF(__pyx_t_1);\n  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  int __pyx_t_5;\n  int __pyx_t_6;\n  int __pyx_lineno = 0;\n  const char *__pyx_filename = NULL;\n  int __pyx_clineno = 0;\n  __Pyx_RefNannySetupContext(\"__reduce_cython__\", 0);\n\n  /* \"(tree fragment)\":5\n *     cdef object _dict\n *     cdef bint use_setstate\n *     _dict = getattr(self, '__dict__', None)\n *     if _dict is not None:\n */\n  __pyx_t_1 = __Pyx_PyBytes_FromString(__pyx_v_self->buffer); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_t_2 = __Pyx_PyInt_From_unsigned_PY_LONG_LONG(__pyx_v_self->buffer_size); if (unlikely(!__pyx_t_2)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_2);\n  __pyx_t_3 = __Pyx_PyInt_From_unsigned_PY_LONG_LONG(__pyx_v_self->position); if (unlikely(!__pyx_t_3)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_3);\n  __pyx_t_4 = PyTuple_New(3); if (unlikely(!__pyx_t_4)) __PYX_ERR(1, 5, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_4);\n  __Pyx_GIVEREF(__pyx_t_1);\n  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_1);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void* ipc_alloc(int size)\n{\n\tvoid* out;\n\tif(size > PAGE_SIZE)\n\t\tout = vmalloc(size);\n\telse\n\t\tout = kmalloc(size, GFP_KERNEL);\n\treturn out;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void *ipc_alloc(int size)\n{\n\tvoid *out;\n\tif(size > PAGE_SIZE)\n\t\tout = vmalloc(size);\n\telse\n\t\tout = kmalloc(size, GFP_KERNEL);\n\treturn out;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "          ec = CreateNormalDirectory(state_temp_dir);\n        }\n\n        if (ec)\n        {\n          // Delete previous uninstaller\n          if (DeleteFile(unexe))\n          {\n            myDelete(state_temp_dir, DEL_DIR|DEL_RECURSE);\n            if (!retry++) goto retry_un_dir;\n          }\n        }\n        else\n        {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "          ec = CreateNormalDirectory(state_temp_dir);\n        }\n\n        if (ec)\n        {\n          // Delete previous uninstaller (if it is safe to do so)\n          if (!(GetFileAttributes(unexe) & FILE_ATTRIBUTE_REPARSE_POINT) && DeleteFile(unexe))\n          {\n            myDelete(state_temp_dir, DEL_DIR);\n            if (!retry++) goto retry_un_dir;\n          }\n        }\n        else\n        {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\n\t\t// insert block's trailing spaces only if there's text behind\n\t\tif ((j < count - 1 || !shortline) && spaces)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t\telse\n\t}\n    }\n\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\n\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\n\t\t// insert block's trailing spaces only if there's text behind\n\t\tif ((j < count - 1 || !shortline) && spaces > 0)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t\telse\n    }\n\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\n\n    // Make sure the cursor is not after the NUL.\n    int len = (int)STRLEN(ml_get_curline());\n    if (curwin->w_cursor.col > len)\n    {\n\tif (cur_ve_flags == VE_ALL)\n\t    curwin->w_cursor.coladd = curwin->w_cursor.col - len;\n\tcurwin->w_cursor.col = len;\n    }\n\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "bool RepeatedAttrDefEqual(\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a1,\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {\n  std::unordered_map<string, const OpDef::AttrDef*> a1_set;\n  for (const OpDef::AttrDef& def : a1) {\n    DCHECK(a1_set.find(def.name()) == a1_set.end())\n        << \"AttrDef names must be unique, but '\" << def.name()\n        << \"' appears more than once\";\n    a1_set[def.name()] = &def;\n  }\n  for (const OpDef::AttrDef& def : a2) {\n    auto iter = a1_set.find(def.name());\n    if (iter == a1_set.end()) return false;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "bool RepeatedAttrDefEqual(\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a1,\n    const protobuf::RepeatedPtrField<OpDef::AttrDef>& a2) {\n  std::unordered_map<string, const OpDef::AttrDef*> a1_set;\n  for (const OpDef::AttrDef& def : a1) {\n    if (a1_set.find(def.name()) != a1_set.end()) {\n      LOG(ERROR) << \"AttrDef names must be unique, but '\" << def.name()\n                 << \"' appears more than once\";\n    }\n    a1_set[def.name()] = &def;\n  }\n  for (const OpDef::AttrDef& def : a2) {\n    auto iter = a1_set.find(def.name());\n    if (iter == a1_set.end()) return false;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tstruct device *dev = &intf->dev;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct net_device *netdev;\n\tstruct catc *catc;\n\tu8 broadcast[ETH_ALEN];\n\tint i, pktsz, ret;\n\n\tif (usb_set_interface(usbdev,\n\t\t\tintf->altsetting->desc.bInterfaceNumber, 1)) {\n\t\tdev_err(dev, \"Can't set altsetting 1.\\n\");\n\t\treturn -EIO;\n\t\tcatc->rx_buf, pktsz, catc_rx_done, catc);\n\n\tusb_fill_int_urb(catc->irq_urb, usbdev, usb_rcvintpipe(usbdev, 2),\n                catc->irq_buf, 2, catc_irq_done, catc, 1);\n\n\tif (!catc->is_f5u011) {\n\t\tdev_dbg(dev, \"Checking memory size\\n\");\n\n\t\ti = 0x12345678;\n\t\tcatc_write_mem(catc, 0x7a80, &i, 4);\n\t\ti = 0x87654321;\t\n\t\tcatc_write_mem(catc, 0xfa80, &i, 4);\n\t\tcatc_read_mem(catc, 0x7a80, &i, 4);\n\t  \n\t\tswitch (i) {\n\t\tcase 0x12345678:\n\t\t\tcatc_set_reg(catc, TxBufCount, 8);\n\t\t\tcatc_set_reg(catc, RxBufCount, 32);\n\t\t\tdev_dbg(dev, \"64k Memory\\n\");\n\t\t\tbreak;\n\t\tcase 0x87654321:\n\t\t\tcatc_set_reg(catc, TxBufCount, 4);\n\t\t\tcatc_set_reg(catc, RxBufCount, 16);\n\t\t\tdev_dbg(dev, \"32k Memory\\n\");\n\t\t\tbreak;\n\t\t}\n\t  \n\t\tdev_dbg(dev, \"Getting MAC from SEEROM.\\n\");\n\t  \n\t\tcatc_get_mac(catc, netdev->dev_addr);\n\t\t",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tstruct device *dev = &intf->dev;\n\tstruct usb_device *usbdev = interface_to_usbdev(intf);\n\tstruct net_device *netdev;\n\tstruct catc *catc;\n\tu8 broadcast[ETH_ALEN];\n\tint pktsz, ret;\n\n\tif (usb_set_interface(usbdev,\n\t\t\tintf->altsetting->desc.bInterfaceNumber, 1)) {\n\t\tdev_err(dev, \"Can't set altsetting 1.\\n\");\n\t\treturn -EIO;\n\n\tusb_fill_int_urb(catc->irq_urb, usbdev, usb_rcvintpipe(usbdev, 2),\n                catc->irq_buf, 2, catc_irq_done, catc, 1);\n\n\tif (!catc->is_f5u011) {\n\t\tu32 *buf;\n\t\tint i;\n\n\t\tdev_dbg(dev, \"Checking memory size\\n\");\n\n\t\tbuf = kmalloc(4, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_free;\n\t\t}\n\n\t\t*buf = 0x12345678;\n\t\tcatc_write_mem(catc, 0x7a80, buf, 4);\n\t\t*buf = 0x87654321;\n\t\tcatc_write_mem(catc, 0xfa80, buf, 4);\n\t\tcatc_read_mem(catc, 0x7a80, buf, 4);\n\t  \n\t\tswitch (*buf) {\n\t\tcase 0x12345678:\n\t\t\tcatc_set_reg(catc, TxBufCount, 8);\n\t\t\tcatc_set_reg(catc, RxBufCount, 32);\n\t\t\tdev_dbg(dev, \"64k Memory\\n\");\n\t\t\tbreak;\n\t\t\tcatc_set_reg(catc, TxBufCount, 4);\n\t\t\tcatc_set_reg(catc, RxBufCount, 16);\n\t\t\tdev_dbg(dev, \"32k Memory\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree(buf);\n\t  \n\t\tdev_dbg(dev, \"Getting MAC from SEEROM.\\n\");\n\t  \n\t\tcatc_get_mac(catc, netdev->dev_addr);\n\t\t",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "            state->indent = NULL;\n            state->indent_len = 0;\n        }\n    } else {\n        if (state->indent) ruby_xfree(state->indent);\n        state->indent = strdup(RSTRING_PTR(indent));\n        state->indent_len = len;\n    }\n    return Qnil;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "            state->indent = NULL;\n            state->indent_len = 0;\n        }\n    } else {\n        if (state->indent) ruby_xfree(state->indent);\n        state->indent = fstrndup(RSTRING_PTR(indent), len);\n        state->indent_len = len;\n    }\n    return Qnil;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  void event_cb(drachtio::RequestHandler::GlobalInfo *g, curl_socket_t s,\n                       int action, const boost::system::error_code & error,\n                       int *fdp) {\n    std::shared_ptr<RequestHandler> p = RequestHandler::getInstance() ;\n    std::map<curl_socket_t, boost::asio::ip::tcp::socket *>& socket_map = p->getSocketMap() ;\n    boost::asio::deadline_timer& timer = p->getTimer() ;\n\n    if(socket_map.find(s) == socket_map.end()) {\n      DR_LOG(log_error) << \"event_cb: socket already closed\";\n      return;\n    }\n\n    /* make sure the event matches what are wanted */\n    if(*fdp == action || *fdp == CURL_POLL_INOUT) {\n      CURLMcode rc;\n      if(error)\n        action = CURL_CSELECT_ERR;\n      rc = curl_multi_socket_action(g->multi, s, action, &g->still_running);\n\n\n      /* keep on watching.\n       * the socket may have been closed and/or fdp may have been changed\n       * in curl_multi_socket_action(), so check them both */\n      if(!error && socket_map.find(s) != socket_map.end() &&\n         (*fdp == action || *fdp == CURL_POLL_INOUT)) {\n        boost::asio::ip::tcp::socket *tcp_socket = socket_map.find(s)->second;\n\n        if(action == CURL_POLL_IN) {\n          tcp_socket->async_read_some(boost::asio::null_buffers(),\n                                      boost::bind(&event_cb, g, s,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  void event_cb(drachtio::RequestHandler::GlobalInfo *g, curl_socket_t s,\n                       int action, const boost::system::error_code & error,\n                       int *fdp) {\n    int f = *fdp;\n    std::shared_ptr<RequestHandler> p = RequestHandler::getInstance() ;\n    std::map<curl_socket_t, boost::asio::ip::tcp::socket *>& socket_map = p->getSocketMap() ;\n    boost::asio::deadline_timer& timer = p->getTimer() ;\n\n    if(socket_map.find(s) == socket_map.end()) {\n      DR_LOG(log_error) << \"event_cb: socket already closed\";\n      return;\n    }\n\n    /* make sure the event matches what are wanted */\n    if(f == action || f == CURL_POLL_INOUT) {\n      CURLMcode rc;\n      if(error)\n        action = CURL_CSELECT_ERR;\n      rc = curl_multi_socket_action(g->multi, s, action, &g->still_running);\n\n\n      /* keep on watching.\n       * the socket may have been closed and/or fdp may have been changed\n       * in curl_multi_socket_action(), so check them both */\n      if(!error && socket_map.find(s) != socket_map.end() &&\n         (f == action || f == CURL_POLL_INOUT)) {\n        boost::asio::ip::tcp::socket *tcp_socket = socket_map.find(s)->second;\n\n        if(action == CURL_POLL_IN) {\n          tcp_socket->async_read_some(boost::asio::null_buffers(),\n                                      boost::bind(&event_cb, g, s,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                result = 0;\n            }\n            else\n            {\n                // b2->size != 0, whatever b1->size is\n                unsigned char* temp = (unsigned char*)realloc(b1->buffer, b1->size + b2->size);\n                if (temp == NULL)\n                {\n                    /* Codes_SRS_BUFFER_07_023: [BUFFER_append shall return a nonzero upon any error that is encountered.] */\n                    LogError(\"Failure: allocating temp buffer.\");\n                    result = MU_FAILURE;\n                }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                result = 0;\n            }\n            else\n            {\n                // b2->size != 0, whatever b1->size is\n                unsigned char* temp;\n                size_t malloc_size = safe_add_size_t(b1->size, b2->size);\n                if (malloc_size == SIZE_MAX || \n                    (temp = (unsigned char*)realloc(b1->buffer, malloc_size)) == NULL)\n                {\n                    /* Codes_SRS_BUFFER_07_023: [BUFFER_append shall return a nonzero upon any error that is encountered.] */\n                    LogError(\"Failure: allocating temp buffer.\");\n                    result = MU_FAILURE;\n                }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    ret = njs_module_load(vm);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_vmcode_interpreter(vm, vm->start);\n\n    return (ret == NJS_ERROR) ? NJS_ERROR : NJS_OK;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    ret = njs_module_load(vm);\n    if (njs_slow_path(ret != NJS_OK)) {\n        return ret;\n    }\n\n    ret = njs_vmcode_interpreter(vm, vm->start, NULL, NULL);\n\n    return (ret == NJS_ERROR) ? NJS_ERROR : NJS_OK;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n\tunsigned int h;\n\tint err;\n\n\tif ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\n\tif (e->next_offset",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                                      const void *data, pj_size_t len)\n{\n    char tmp[128];\n    pj_size_t nwritten;\n\n    pj_lock_acquire(ds->ossl_lock);\n\n    if (!ds->ossl_rbio[idx]) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_EGONE;\n    }\n\n    nwritten = BIO_write(ds->ossl_rbio[idx], data, (int)len);\n    if (nwritten < len) {\n        pj_status_t status;\n        status = GET_SSL_STATUS(ds);\n#if DTLS_DEBUG\n        pj_perror(2, ds->base.name, status, \"BIO_write() error\");\n#endif\n        pj_lock_release(ds->ossl_lock);\n        return status;\n    }\n\n    if (!ds->ossl_ssl[idx]) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_EGONE;\n    }\n\n    /* Consume (and ignore) the packet */\n    while (1) {\n#endif\n            break;\n        }\n    }\n\n    pj_lock_release(ds->ossl_lock);\n\n    /* Flush anything pending in the write BIO */\n    return ssl_flush_wbio(ds, idx);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                                      const void *data, pj_size_t len)\n{\n    char tmp[128];\n    pj_size_t nwritten;\n\n    DTLS_LOCK(ds);\n\n    if (!ds->ossl_rbio[idx]) {\n        DTLS_UNLOCK(ds);\n        return PJ_EGONE;\n    }\n\n    nwritten = BIO_write(ds->ossl_rbio[idx], data, (int)len);\n    if (nwritten < len) {\n        pj_status_t status;\n        status = GET_SSL_STATUS(ds);\n#if DTLS_DEBUG\n        pj_perror(2, ds->base.name, status, \"BIO_write() error\");\n#endif\n        DTLS_UNLOCK(ds);\n        return status;\n    }\n\n    if (!ds->ossl_ssl[idx]) {\n        DTLS_UNLOCK(ds);\n        return PJ_EGONE;\n    }\n\n    /* Consume (and ignore) the packet */\n    while (1) {\n#endif\n            break;\n        }\n    }\n\n    DTLS_UNLOCK(ds);\n\n    /* Flush anything pending in the write BIO */\n    return ssl_flush_wbio(ds, idx);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "FdOutStream::FdOutStream(int fd_, bool blocking_, int timeoutms_, int bufSize_)\n  : fd(fd_), blocking(blocking_), timeoutms(timeoutms_),\n    bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)\n{\n  ptr = start = sentUpTo = new U8[bufSize];\n  end = start + bufSize;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "FdOutStream::FdOutStream(int fd_, bool blocking_, int timeoutms_, size_t bufSize_)\n  : fd(fd_), blocking(blocking_), timeoutms(timeoutms_),\n    bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)\n{\n  ptr = start = sentUpTo = new U8[bufSize];\n  end = start + bufSize;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    oe_off_t offset)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_pwrite_ocall(&ret, file->host_fd, buf, count, offset) !=\n        OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    oe_off_t offset)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    /*\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/pwrite.html\n     * for more detail.\n     */\n    if (!file || count > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_pwrite_ocall(&ret, file->host_fd, buf, count, offset) !=\n        OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed count.\n     */\n    if (ret > (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void HeaderTable::setCapacity(uint32_t capacity) {\n  auto oldCapacity = capacity_;\n  capacity_ = capacity;\n  if (capacity_ <= oldCapacity) {\n    evict(0);\n  } else {\n    auto oldTail = tail();\n    auto oldLength = table_.size();\n    uint32_t newLength = (capacity_ >> 5) + 1;\n    table_.resize(newLength);\n    if (size_ > 0 && oldTail > head_) {\n      // the list wrapped around, need to move oldTail..oldLength to the end of\n      // the now-larger table_\n      std::copy(table_.begin() + oldTail, table_.begin() + oldLength,\n                table_.begin() + newLength - (oldLength - oldTail));\n      // Update the names indecies that pointed to the old range\n      for (auto& names_it: names_) {\n        for (auto& idx: names_it.second) {\n          if (idx >= oldTail) {\n            DCHECK_LT(idx + (table_.size() - oldLength), table_.size());\n            idx += (table_.size() - oldLength);\n          } else {\n            // remaining indecies in the list were smaller than oldTail, so\n            // should be indexed from 0\n            break;\n          }\n        }\n      }\n    }\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void HeaderTable::setCapacity(uint32_t capacity) {\n  // TODO: ddmello - the below is a little dangerous as we update the\n  // capacity right away.  Some properties of the class utilize that variable\n  // and so might be better to refactor and update capacity at the end of the\n  // method (and update other methods)\n  auto oldCapacity = capacity_;\n  capacity_ = capacity;\n  if (capacity_ == oldCapacity) {\n    return;\n  } else if (capacity_ < oldCapacity) {\n    // NOTE: currently no actual resizing is performed...\n    evict(0);\n  } else {\n    // NOTE: due to the above lack of resizing, we must determine whether a\n    // resize is actually appropriate (to handle cases where the underlying\n    // vector is still >= to the size related to the new capacity requested)\n    uint32_t newLength = (capacity_ >> 5) + 1;\n    if (newLength > table_.size()) {\n      auto oldTail = tail();\n      auto oldLength = table_.size();\n      table_.resize(newLength);\n      if (size_ > 0 && oldTail > head_) {\n        // the list wrapped around, need to move oldTail..oldLength to the end\n        // of the now-larger table_\n        std::copy(table_.begin() + oldTail, table_.begin() + oldLength,\n                  table_.begin() + newLength - (oldLength - oldTail));\n        // Update the names indecies that pointed to the old range\n        for (auto& names_it: names_) {\n          for (auto& idx: names_it.second) {\n            if (idx >= oldTail) {\n              DCHECK_LT(idx + (table_.size() - oldLength), table_.size());\n              idx += (table_.size() - oldLength);\n            } else {\n              // remaining indecies in the list were smaller than oldTail, so\n              // should be indexed from 0\n              break;\n            }\n          }\n        }\n      }\n    }\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE;\n\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)\n\t\treturn 0;\n\n\ttimr->it_interval = timespec64_to_ktime(new_setting->it_interval);\n\texpires = timespec64_to_ktime(new_setting->it_value);\n\tsigev_none = timr->it_sigev_notify == SIGEV_NONE;\n\n\tkc->timer_arm(timr, expires, flags & TIMER_ABSTIME, sigev_none);\n\ttimr->it_active = !sigev_none;\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "Status TensorSliceWriter::SaveData(const T* data, int64_t num_elements,\n                                   SavedSlice* ss) {\n  size_t size_bound =\n      ss->ByteSize() + kTensorProtoHeaderBytes +\n      (MaxBytesPerElement(DataTypeToEnum<T>::value) * num_elements);\n  if (size_bound > kMaxMessageBytes) {\n    return errors::InvalidArgument(\n        \"Tensor slice is too large to serialize (conservative estimate: \",\n        size_bound, \" bytes)\");\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "Status TensorSliceWriter::SaveData(const T* data, int64_t num_elements,\n                                   SavedSlice* ss) {\n  size_t max_bytes_per_element =\n      MaxBytesPerElementOrZero(DataTypeToEnum<T>::value);\n  if (max_bytes_per_element == 0) {\n    return errors::InvalidArgument(\n        \"Tensor slice serialization not implemented for dtype \",\n        DataTypeToEnum<T>::value);\n  }\n  size_t size_bound = ss->ByteSize() + kTensorProtoHeaderBytes +\n                      (max_bytes_per_element * num_elements);\n  if (size_bound > kMaxMessageBytes) {\n    return errors::InvalidArgument(\n        \"Tensor slice is too large to serialize (conservative estimate: \",\n        size_bound, \" bytes)\");\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\tnow = ast_tvnow();\n\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x >= TRUNK_CALL_START) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\tint start, found = 0;\n\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\n\t\tnow = ast_tvnow();\n\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n\t\tfor (x = start; 1; x++) {\n\t\t\tif (x == TRUNK_CALL_START) {\n\t\t\t\tx = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\t\n\t\t\tif (x == start - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x == start - 1 && !found) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static RList *symbols(RBinFile *bf) {\n\tRList *res = r_list_newf ((RListFree)r_bin_symbol_free);\n\tr_return_val_if_fail (res && bf->o && bf->o->bin_obj, res);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tHtUU *hash = ht_uu_new0 ();\n\tif (!hash) {\n\t\treturn res;\n\t}\n\tbool found = false;\n\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\tRCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n\t\tif (!sym) {\n\t\t\tbreak;\n\t\t}\n\t\tht_uu_find (hash, sym->paddr, &found);\n\t\tif (found) {\n\t\t\tcontinue;\n\t\t}\n\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\tif (s) {\n\t\t\tr_list_append (res, s);\n\t\t\tht_uu_insert (hash, sym->paddr, 1);\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &element->symbols[i];",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static RList *symbols(RBinFile *bf) {\n\tr_return_val_if_fail (bf && bf->o && bf->o->bin_obj, NULL);\n\tRCoreSymCacheElement *element = bf->o->bin_obj;\n\tsize_t i;\n\tHtUU *hash = ht_uu_new0 ();\n\tif (!hash) {\n\t\treturn NULL;\n\t}\n\tRList *res = r_list_newf ((RListFree)r_bin_symbol_free);\n\tbool found = false;\n\tif (element->lined_symbols) {\n\t\tfor (i = 0; i < element->hdr->n_lined_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = (RCoreSymCacheElementSymbol *)&element->lined_symbols[i];\n\t\t\tif (!sym) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tht_uu_find (hash, sym->paddr, &found);\n\t\t\tif (found) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRBinSymbol *s = bin_symbol_from_symbol (element, sym);\n\t\t\tif (s) {\n\t\t\t\tr_list_append (res, s);\n\t\t\t\tht_uu_insert (hash, sym->paddr, 1);\n\t\t\t}\n\t\t}\n\t}\n\tif (element->symbols) {\n\t\tfor (i = 0; i < element->hdr->n_symbols; i++) {\n\t\t\tRCoreSymCacheElementSymbol *sym = &element->symbols[i];",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void FileBody::Dump(std::ostream& os, const std::string& prefix) const {\n  os << prefix << \"<file: \" << path_.string() << \">\" << std::endl;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void FileBody::Dump(std::ostream& os, const std::string& prefix) const {\n  os << prefix << \"<file: \" << path_.u8string() << \">\" << std::endl;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  void SetUp() override {\n    env_ = std::make_unique<FakeClockEnv>(Env::Default());\n    tfdataz_metrics_ = std::make_unique<TfDatazMetricsCollector>(*env_);\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  void SetUp() override {\n    env_ = std::make_unique<FakeClockEnv>(Env::Default());\n    tfdataz_metrics_ =\n        std::make_unique<TfDatazMetricsCollector>(*env_, iterator_.get());\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "Http::FilterTrailersStatus Context::onResponseTrailers() {\n  if (!wasm_->onResponseTrailers_) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  if (wasm_->onResponseTrailers_(this, id_).u64_ == 0) {\n    return Http::FilterTrailersStatus::Continue;\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "Http::FilterTrailersStatus Context::onResponseTrailers() {\n  if (!in_vm_context_created_ || !wasm_->onResponseTrailers_) {\n    return Http::FilterTrailersStatus::Continue;\n  }\n  if (wasm_->onResponseTrailers_(this, id_).u64_ == 0) {\n    return Http::FilterTrailersStatus::Continue;\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "generic_ret *init_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static generic_ret         ret;\n    gss_buffer_desc            client_name,\n        service_name;\n    kadm5_server_handle_t      handle;\n    OM_uint32                  minor_stat;\n    const char                 *errmsg = NULL;\n    size_t clen, slen;\n    char *cdots, *sdots;\n                     (int)slen, (char *)service_name.value, sdots,\n                     client_addr(rqstp->rq_xprt),\n                     ret.api_version & ~(KADM5_API_VERSION_MASK),\n                     rqstp->rq_cred.oa_flavor);\n    if (errmsg != NULL)\n        krb5_free_error_message(NULL, errmsg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n\nexit_func:\n    return(&ret);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "generic_ret *init_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)\n{\n    static generic_ret         ret;\n    gss_buffer_desc            client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc            service_name = GSS_C_EMPTY_BUFFER;\n    kadm5_server_handle_t      handle;\n    OM_uint32                  minor_stat;\n    const char                 *errmsg = NULL;\n    size_t clen, slen;\n    char *cdots, *sdots;\n                     client_addr(rqstp->rq_xprt),\n                     ret.api_version & ~(KADM5_API_VERSION_MASK),\n                     rqstp->rq_cred.oa_flavor);\n    if (errmsg != NULL)\n        krb5_free_error_message(NULL, errmsg);\n\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    return(&ret);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void enc624j600UpdateMacConfig(NetInterface *interface)\n{\n   uint16_t duplexMode;\n\n   //Determine the new duplex mode by reading the PHYDPX bit\n   duplexMode = enc624j600ReadReg(interface, ENC624J600_REG_ESTAT) & ESTAT_PHYDPX;\n\n   //Full-duplex mode?\n   if(duplexMode)\n   {\n      //Configure the FULDPX bit to match the current duplex mode\n      enc624j600WriteReg(interface, ENC624J600_REG_MACON2, MACON2_DEFER |\n         MACON2_PADCFG2 | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1 | MACON2_FULDPX);\n      //Configure the Back-to-Back Inter-Packet Gap register\n      enc624j600WriteReg(interface, ENC624J600_REG_MABBIPG, 0x15);\n   }\n   //Half-duplex mode?\n   else\n   {\n      //Configure the FULDPX bit to match the current duplex mode\n      enc624j600WriteReg(interface, ENC624J600_REG_MACON2, MACON2_DEFER |\n         MACON2_PADCFG2 | MACON2_PADCFG0 | MACON2_TXCRCEN | MACON2_R1);\n      //Configure the Back-to-Back Inter-Packet Gap register\n      enc624j600WriteReg(interface, ENC624J600_REG_MABBIPG, 0x12);\n   }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void enc624j600UpdateMacConfig(NetInterface *interface)\n{\n   uint16_t duplexMode;\n\n   //Determine the new duplex mode by reading the PHYDPX bit\n   duplexMode = enc624j600ReadReg(interface, ENC624J600_ESTAT) & ENC624J600_ESTAT_PHYDPX;\n\n   //Full-duplex mode?\n   if(duplexMode)\n   {\n      //Configure the FULDPX bit to match the current duplex mode\n      enc624j600WriteReg(interface, ENC624J600_MACON2, ENC624J600_MACON2_DEFER |\n         ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN |\n         ENC624J600_MACON2_R1_DEFAULT | ENC624J600_MACON2_FULDPX);\n\n      //Configure the Back-to-Back Inter-Packet Gap register\n      enc624j600WriteReg(interface, ENC624J600_MABBIPG,\n         ENC624J600_MABBIPG_BBIPG_DEFAULT_FD);\n   }\n   //Half-duplex mode?\n   else\n   {\n      //Configure the FULDPX bit to match the current duplex mode\n      enc624j600WriteReg(interface, ENC624J600_MACON2, ENC624J600_MACON2_DEFER |\n         ENC624J600_MACON2_PADCFG_AUTO | ENC624J600_MACON2_TXCRCEN |\n         ENC624J600_MACON2_R1_DEFAULT);\n\n      //Configure the Back-to-Back Inter-Packet Gap register\n      enc624j600WriteReg(interface, ENC624J600_MABBIPG,\n         ENC624J600_MABBIPG_BBIPG_DEFAULT_HD);\n   }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  char text[4] = {0, 0, 0, 0};\n\n  text[0] = '\\\\';\n  text[1] = RE_YY_INPUT(yyscanner);\n\n  if (text[1] == EOF)\n    return 0;\n\n  if (text[1] == 'x')\n  {\n    text[2] = RE_YY_INPUT(yyscanner);\n\n    if (text[2] == EOF)\n      return 0;\n\n    text[3] = RE_YY_INPUT(yyscanner);\n\n    if (text[3] == EOF)\n      return 0;\n  }\n\n  *escaped_char = escaped_char_value(text);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  char text[4] = {0, 0, 0, 0};\n\n  text[0] = '\\\\';\n  text[1] = RE_YY_INPUT(yyscanner);\n\n  if (text[1] == EOF || text[1] == 0)\n    return 0;\n\n  if (text[1] == 'x')\n  {\n    text[2] = RE_YY_INPUT(yyscanner);\n\n    if (!isxdigit(text[2]))\n      return 0;\n\n    text[3] = RE_YY_INPUT(yyscanner);\n\n    if (!isxdigit(text[3]))\n      return 0;\n  }\n\n  *escaped_char = escaped_char_value(text);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tstruct ifreq ifr;\n\tint sndbuf;\n\tint vnet_hdr_sz;\n\tint ret;\n\n\tif (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89)\n\t\tif (copy_from_user(&ifr, argp, ifreq_len))\n\t\t\treturn -EFAULT;\n\n\tif (cmd == TUNGETFEATURES) {\n\t\t/* Currently this just means: \"what IFF flags are valid?\".\n\t\t * This is needed because we never checked for invalid flags on\n\t\t * TUNSETIFF. */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tstruct ifreq ifr;\n\tint sndbuf;\n\tint vnet_hdr_sz;\n\tint ret;\n\n\tif (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89) {\n\t\tif (copy_from_user(&ifr, argp, ifreq_len))\n\t\t\treturn -EFAULT;\n\t} else\n\t\tmemset(&ifr, 0, sizeof(ifr));\n\n\tif (cmd == TUNGETFEATURES) {\n\t\t/* Currently this just means: \"what IFF flags are valid?\".\n\t\t * This is needed because we never checked for invalid flags on\n\t\t * TUNSETIFF. */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      //\n      // Because NDIMS, Functor::use_broadcast_optimization and\n      // use_broadcast_optimization<T> are compile-time constant, gcc\n      // does a decent job avoiding generating code when conditions\n      // are not met.\n      const int a = in0.dimension(0);  // in0 is shape [a, b]\n      const int b = in0.dimension(1);\n      const int c = in1.dimension(0);  // in1 is shape [c, d]\n      const int d = in1.dimension(1);\n      if ((a == 1) && (d == 1)) {\n        auto lhs = in0.reshape(OneByM(b)).broadcast(NByOne(c));\n        auto rhs = in1.reshape(NByOne(c)).broadcast(OneByM(b));\n        Assign(dev, out, lhs.binaryExpr(rhs, func));\n        return;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      //\n      // Because NDIMS, Functor::use_broadcast_optimization and\n      // use_broadcast_optimization<T> are compile-time constant, gcc\n      // does a decent job avoiding generating code when conditions\n      // are not met.\n      const Eigen::DenseIndex a = in0.dimension(0);  // in0 is shape [a, b]\n      const Eigen::DenseIndex b = in0.dimension(1);\n      const Eigen::DenseIndex c = in1.dimension(0);  // in1 is shape [c, d]\n      const Eigen::DenseIndex d = in1.dimension(1);\n      if ((a == 1) && (d == 1)) {\n        auto lhs = in0.reshape(OneByM(b)).broadcast(NByOne(c));\n        auto rhs = in1.reshape(NByOne(c)).broadcast(OneByM(b));\n        Assign(dev, out, lhs.binaryExpr(rhs, func));\n        return;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    line = ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);\n    if (pos->col == MAXCOL)\n\tposptr = NULL;  // continue until the NUL\n    else\n    {\n\t// Special check for an empty line, which can happen on exit, when\n\t// ml_get_buf() always returns an empty string.\n\tif (*ptr == NUL)\n\t    pos->col = 0;\n\tposptr = ptr + pos->col;\n\tif (has_mbyte)\n\t    // always start on the first byte\n\t    posptr -= (*mb_head_off)(line, posptr);\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    line = ptr = ml_get_buf(wp->w_buffer, pos->lnum, FALSE);\n    if (pos->col == MAXCOL)\n\tposptr = NULL;  // continue until the NUL\n    else\n    {\n\tcolnr_T i;\n\n\t// In a few cases the position can be beyond the end of the line.\n\tfor (i = 0; i < pos->col; ++i)\n\t    if (ptr[i] == NUL)\n\t    {\n\t\tpos->col = i;\n\t\tbreak;\n\t    }\n\tposptr = ptr + pos->col;\n\tif (has_mbyte)\n\t    // always start on the first byte\n\t    posptr -= (*mb_head_off)(line, posptr);\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tint i;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, stats->devid, NULL, NULL);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tif (!dev) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, device not found\");\n\t\treturn -ENODEV;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tstruct btrfs_device *dev;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tint i;\n\n\tmutex_lock(&fs_devices->device_list_mutex);\n\tdev = btrfs_find_device(fs_info->fs_devices, stats->devid, NULL, NULL,\n\t\t\t\ttrue);\n\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tif (!dev) {\n\t\tbtrfs_warn(fs_info, \"get dev_stats failed, device not found\");\n\t\treturn -ENODEV;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n\t\t\t\t       size_t len)\n{\n\tuaddr_t a;\n\tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n\t\t\t       CORE_MMU_USER_PARAM_SIZE);\n\n\tif (ADD_OVERFLOW(uaddr, len, &a))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t */\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n\t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\tfor (a = uaddr; a < (uaddr + len); a += addr_incr) {\n\t\tuint32_t attr;\n\t\tTEE_Result res;\n\n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,\n\t\t\t\t       uint32_t flags, uaddr_t uaddr,\n\t\t\t\t       size_t len)\n{\n\tuaddr_t a;\n\tuaddr_t end_addr = 0;\n\tsize_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,\n\t\t\t       CORE_MMU_USER_PARAM_SIZE);\n\n\tif (ADD_OVERFLOW(uaddr, len, &end_addr))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\tif ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&\n\t    (flags & TEE_MEMORY_ACCESS_SECURE))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\t */\n\tif (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&\n\t   !tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))\n\t\treturn TEE_ERROR_ACCESS_DENIED;\n\n\tfor (a = ROUNDDOWN(uaddr, addr_incr); a < end_addr; a += addr_incr) {\n\t\tuint32_t attr;\n\t\tTEE_Result res;\n\n\t\tres = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);\n\t\tif (res != TEE_SUCCESS)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    SET_ERRNO (EFAULT,\n               \"subkey_lf is not a valid block (0x%zx)\", subkey_lf);\n    goto error;\n  }\n\n  if (_get_children (h, subkey_lf, &children, &blocks, flags) == -1)\n    goto error;\n\n  /* Check the number of children we ended up reading matches\n   * nr_subkeys_in_nk.\n   */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    SET_ERRNO (EFAULT,\n               \"subkey_lf is not a valid block (0x%zx)\", subkey_lf);\n    goto error;\n  }\n\n  if (_get_children (h, subkey_lf, &children, &blocks, flags, 0) == -1)\n    goto error;\n\n  /* Check the number of children we ended up reading matches\n   * nr_subkeys_in_nk.\n   */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                    \"i and x shape doesn't match at index 0: \",\n                    i.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n\n    Tensor y = x;  // This creates an alias intentionally.\n    // Skip processing if tensors are empty.\n    if (x.NumElements() > 0 || v.NumElements() > 0) {\n      OP_REQUIRES_OK(ctx, DoCompute(ctx, i, v, &y));\n    }\n    ctx->set_output(0, y);\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                    \"i and x shape doesn't match at index 0: \",\n                    i.shape().DebugString(), \" vs. \", v.shape().DebugString()));\n\n    Tensor y = x;  // This creates an alias intentionally.\n    // Skip processing if tensors are empty.\n    if (x.NumElements() > 0 && v.NumElements() > 0) {\n      OP_REQUIRES_OK(ctx, DoCompute(ctx, i, v, &y));\n    }\n    ctx->set_output(0, y);\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    char *uri;\n    GFile *file;\n\n    switch (response_id)\n    {\n        case RESPONSE_RUN:\n        {\n            screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n            uri = nautilus_file_get_uri (parameters->file);\n            DEBUG (\"Launching untrusted launcher %s\", uri);\n            nautilus_launch_desktop_file (screen, uri, NULL,\n                                          parameters->parent_window);\n            g_free (uri);\n        }\n        break;\n\n        case RESPONSE_MARK_TRUSTED:\n        {\n            file = nautilus_file_get_location (parameters->file);\n            nautilus_file_mark_desktop_file_trusted (file,\n                                                     parameters->parent_window,\n                                                     TRUE,\n                                                     NULL, NULL);\n            g_object_unref (file);\n        }\n        break;\n\n        default:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    char *uri;\n    GFile *file;\n\n    switch (response_id)\n    {\n        case GTK_RESPONSE_OK:\n        {\n            file = nautilus_file_get_location (parameters->file);\n\n            /* We need to do this in order to prevent malicious desktop files\n             * with the executable bit already set.\n             * See https://bugzilla.gnome.org/show_bug.cgi?id=777991\n             */\n            nautilus_file_set_metadata (parameters->file, NAUTILUS_METADATA_KEY_DESKTOP_FILE_TRUSTED,\n                                        NULL,\n                                        \"yes\");\n\n            nautilus_file_mark_desktop_file_executable (file,\n                                                        parameters->parent_window,\n                                                        TRUE,\n                                                        NULL, NULL);\n\n            /* Need to force a reload of the attributes so is_trusted is marked\n             * correctly. Not sure why the general monitor doesn't fire in this\n             * case when setting the metadata\n             */\n            nautilus_file_invalidate_all_attributes (parameters->file);\n\n            screen = gtk_widget_get_screen (GTK_WIDGET (parameters->parent_window));\n            uri = nautilus_file_get_uri (parameters->file);\n            DEBUG (\"Launching untrusted launcher %s\", uri);\n            nautilus_launch_desktop_file (screen, uri, NULL,\n                                          parameters->parent_window);\n            g_free (uri);\n            g_object_unref (file);\n        }\n        break;\n\n        default:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tnt_len = le16_to_cpu(authblob->NtChallengeResponse.Length);\n\n\tdn_off = le32_to_cpu(authblob->DomainName.BufferOffset);\n\tdn_len = le16_to_cpu(authblob->DomainName.Length);\n\n\tif (blob_len < (u64)dn_off + dn_len || blob_len < (u64)nt_off + nt_len)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_SMB_INSECURE_SERVER\n\tlm_off = le32_to_cpu(authblob->LmChallengeResponse.BufferOffset);\n\tlm_len = le16_to_cpu(authblob->LmChallengeResponse.Length);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tnt_len = le16_to_cpu(authblob->NtChallengeResponse.Length);\n\n\tdn_off = le32_to_cpu(authblob->DomainName.BufferOffset);\n\tdn_len = le16_to_cpu(authblob->DomainName.Length);\n\n\tif (blob_len < (u64)dn_off + dn_len || blob_len < (u64)nt_off + nt_len ||\n\t    nt_len < CIFS_ENCPWD_SIZE)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_SMB_INSECURE_SERVER\n\tlm_off = le32_to_cpu(authblob->LmChallengeResponse.BufferOffset);\n\tlm_len = le16_to_cpu(authblob->LmChallengeResponse.Length);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int enable_trace_input(struct flb_hs *hs, const char *name, const char *prefix, const char *output_name, struct mk_list *props)\n{\n    struct flb_input_instance *in;\n\n\n    in = find_input(hs, name);\n    if (in == NULL) {\n        return 404;\n    }\n\n    flb_chunk_trace_context_new(in, output_name, prefix, NULL, props);\n    return (in->chunk_trace_ctxt == NULL ? 503 : 0);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int enable_trace_input(struct flb_hs *hs, const char *name, ssize_t nlen, const char *prefix,\n                              const char *output_name, struct mk_list *props)\n{\n    struct flb_input_instance *in;\n\n    in = find_input(hs, name, nlen);\n    if (in == NULL) {\n        flb_error(\"unable to find input: [%d]%.*s\", (int)nlen, (int)nlen, name);\n        return 404;\n    }\n\n    flb_chunk_trace_context_new(in, output_name, prefix, NULL, props);\n\n    if (in->chunk_trace_ctxt == NULL) {\n        flb_error(\"unable to start tracing\");\n        return 503;\n    }\n\n    return 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void Archive::Seek(int64 Offset,int Method)\n{\n  if (!QOpen.Seek(Offset,Method))\n    File::Seek(Offset,Method);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void Archive::Seek(int64 Offset,int Method)\n{\n#ifdef USE_QOPEN\n  if (QOpen.Seek(Offset,Method))\n    return;\n#endif\n#ifdef USE_ARCMEM\n  if (ArcMem.Seek(Offset,Method))\n    return;\n#endif\n  File::Seek(Offset,Method);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "test_make_inputs (xd3_stream *stream, xoff_t *ss_out, xoff_t *ts_out)\n{\n  usize_t ts = (mt_random (&static_mtrand) % TEST_FILE_MEAN) + TEST_FILE_MEAN / 2;\n  usize_t ss = (mt_random (&static_mtrand) % TEST_FILE_MEAN) + TEST_FILE_MEAN / 2;\n  uint8_t *buf = (uint8_t*) malloc (ts + ss), *sbuf = buf, *tbuf = buf + ss;\n  usize_t sadd = 0, sadd_max = (usize_t)(ss * TEST_ADD_RATIO);\n  FILE  *tf = NULL, *sf = NULL;\n  usize_t i, j;\n  int ret;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "test_make_inputs (xd3_stream *stream, xoff_t *ss_out, xoff_t *ts_out)\n{\n  usize_t ts = (mt_random (&static_mtrand) % TEST_FILE_MEAN) +\n    TEST_FILE_MEAN / 2;\n  usize_t ss = (mt_random (&static_mtrand) % TEST_FILE_MEAN) +\n    TEST_FILE_MEAN / 2;\n  uint8_t *buf = (uint8_t*) malloc (ts + ss), *sbuf = buf, *tbuf = buf + ss;\n  usize_t sadd = 0, sadd_max = (usize_t)(ss * TEST_ADD_RATIO);\n  FILE  *tf = NULL, *sf = NULL;\n  usize_t i, j;\n  int ret;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int fsmVerify(const char *path, rpmfi fi)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n            rc = fsmStat(path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n            if (S_ISDIR(dsb.st_mode)) return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int fsmVerify(const char *path, rpmfi fi, const struct stat *fsb)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n\t    uid_t luid = dsb.st_uid;\n            rc = fsmStat(path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n\t    /* Only permit directory symlinks by target owner and root */\n            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == fsb->st_uid))\n\t\t    return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\tp_idx = ef_idx;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Encryption key present ? */\n\t\t\tiPinCount = iACLen - 1;\t\t\n\n\t\t\tif (buf[iOffset] & 0x20) {\n\t\t\t\tint iSC;\n\t\t\t\tif (len < 1 + (size_t)iACLen)\n\t\t\t\t\tbreak;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\tp_idx = ef_idx;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Encryption key present ? */\n\t\t\tiPinCount = iACLen > 0 ? iACLen - 1 : 0;\n\n\t\t\tif (buf[iOffset] & 0x20) {\n\t\t\t\tint iSC;\n\t\t\t\tif (len < 1 + (size_t)iACLen)\n\t\t\t\t\tbreak;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void unix_notinflight(struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tspin_lock(&unix_gc_lock);\n\n\n\t\tif (atomic_long_dec_and_test(&u->inflight))\n\t\t\tlist_del_init(&u->link);\n\t\tunix_tot_inflight--;\n\t}\n\tfp->f_cred->user->unix_inflight--;\n\tspin_unlock(&unix_gc_lock);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void unix_notinflight(struct user_struct *user, struct file *fp)\n{\n\tstruct sock *s = unix_get_socket(fp);\n\n\tspin_lock(&unix_gc_lock);\n\n\n\t\tif (atomic_long_dec_and_test(&u->inflight))\n\t\t\tlist_del_init(&u->link);\n\t\tunix_tot_inflight--;\n\t}\n\tuser->unix_inflight--;\n\tspin_unlock(&unix_gc_lock);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t/* NOTE 11/06/07 EG moved to after we read config files, as user may have overridden timezone offset */\n\t\t\t/* get program (re)start time and save as macro */\n\t\t\tprogram_start = time(NULL);\n\t\t\tmy_free(mac->x[MACRO_PROCESSSTARTTIME]);\n\t\t\tasprintf(&mac->x[MACRO_PROCESSSTARTTIME], \"%llu\", (unsigned long long)program_start);\n\n\t\t\t/* drop privileges */\n\t\t\tif(drop_privileges(nagios_user, nagios_group) == ERROR) {\n\n\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, \"Failed to drop privileges.  Aborting.\");\n\n\t\t\t\tcleanup();\n\t\t\t\texit(ERROR);\n\t\t\t\t}\n\n\t\t\tif (test_path_access(nagios_binary_path, X_OK)) {\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: failed to access() %s: %s\\n\", nagios_binary_path, strerror(errno));\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Spawning workers will be impossible. Aborting.\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\n\t\t\tif (test_configured_paths() == ERROR) {\n\t\t\t\t/* error has already been logged */\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t/* enter daemon mode (unless we're restarting...) */\n\t\t\tif(daemon_mode == TRUE && sigrestart == FALSE) {\n\n\t\t\t\tresult = daemon_init();\n\n\t\t\t\t\tcleanup();\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t\t}\n\n\t\t\t\t/* get new PID */\n\t\t\t\tnagios_pid = (int)getpid();\n\t\t\t\t}\n\n\t\t\t/* this must be logged after we read config data, as user may have changed location of main log file */\n\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Nagios %s starting... (PID=%d)\\n\", PROGRAM_VERSION, (int)getpid());\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t/* NOTE 11/06/07 EG moved to after we read config files, as user may have overridden timezone offset */\n\t\t\t/* get program (re)start time and save as macro */\n\t\t\tprogram_start = time(NULL);\n\t\t\tmy_free(mac->x[MACRO_PROCESSSTARTTIME]);\n\t\t\tasprintf(&mac->x[MACRO_PROCESSSTARTTIME], \"%llu\", (unsigned long long)program_start);\n\t\t\t\n\t\t\t/* enter daemon mode (unless we're restarting...) */\n\t\t\tif(daemon_mode == TRUE && sigrestart == FALSE) {\n\n\t\t\t\tresult = daemon_init();\n\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t\t}\n\n\t\t\t\t/* get new PID */\n\t\t\t\tnagios_pid = (int)getpid();\n\t\t\t\t}\n\n\t\t\t/* drop privileges */\n\t\t\tif(drop_privileges(nagios_user, nagios_group) == ERROR) {\n\n\t\t\t\tlogit(NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR, TRUE, \"Failed to drop privileges.  Aborting.\");\n\n\t\t\t\tcleanup();\n\t\t\t\texit(ERROR);\n\t\t\t\t}\n\n\t\t\tif (test_path_access(nagios_binary_path, X_OK)) {\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: failed to access() %s: %s\\n\", nagios_binary_path, strerror(errno));\n\t\t\t\tlogit(NSLOG_RUNTIME_ERROR, TRUE, \"Error: Spawning workers will be impossible. Aborting.\\n\");\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\n\t\t\tif (test_configured_paths() == ERROR) {\n\t\t\t\t/* error has already been logged */\n\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\n\t\t\t/* this must be logged after we read config data, as user may have changed location of main log file */\n\t\t\tlogit(NSLOG_PROCESS_INFO, TRUE, \"Nagios %s starting... (PID=%d)\\n\", PROGRAM_VERSION, (int)getpid());\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\trem = 0;\n\tfor (idx = 0; idx < pipe->nrbufs && rem < len; idx++)\n\t\trem += pipe->bufs[(pipe->curbuf + idx) & (pipe->buffers - 1)].len;\n\n\tret = -EINVAL;\n\tif (rem < len) {\n\t\tpipe_unlock(pipe);\n\t\tgoto out;\n\t}\n\n\trem = len;\n\twhile (rem) {\n\t\tstruct pipe_buffer *ibuf;\n\t\tstruct pipe_buffer *obuf;\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t} else {\n\t\t\tpipe_buf_get(pipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\t\tobuf->len = rem;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\tif (flags & SPLICE_F_MOVE)\n\t\tcs.move_pages = 1;\n\n\tret = fuse_dev_do_write(fud, &cs, len);\n\n\tpipe_lock(pipe);\n\tfor (idx = 0; idx < nbuf; idx++)\n\t\tpipe_buf_release(pipe, &bufs[idx]);\n\tpipe_unlock(pipe);\n\nout:\n\tkvfree(bufs);\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\trem = 0;\n\tfor (idx = 0; idx < pipe->nrbufs && rem < len; idx++)\n\t\trem += pipe->bufs[(pipe->curbuf + idx) & (pipe->buffers - 1)].len;\n\n\tret = -EINVAL;\n\tif (rem < len)\n\t\tgoto out_free;\n\n\trem = len;\n\twhile (rem) {\n\t\tstruct pipe_buffer *ibuf;\n\t\tstruct pipe_buffer *obuf;\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t} else {\n\t\t\tif (!pipe_buf_get(pipe, ibuf))\n\t\t\t\tgoto out_free;\n\n\t\t\t*obuf = *ibuf;\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\t\t\tobuf->len = rem;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\tcs.move_pages = 1;\n\n\tret = fuse_dev_do_write(fud, &cs, len);\n\n\tpipe_lock(pipe);\nout_free:\n\tfor (idx = 0; idx < nbuf; idx++)\n\t\tpipe_buf_release(pipe, &bufs[idx]);\n\tpipe_unlock(pipe);\n\n\tkvfree(bufs);\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void deletesuccessor(file_t **existing, file_t *duplicate, int matchconfirmed,\n      int (*comparef)(file_t *f1, file_t *f2), struct log_info *loginfo)\n{\n  file_t *to_keep;\n  file_t *to_delete;\n\n  if (comparef(duplicate, *existing) >= 0)\n  {\n    to_keep = *existing;\n    to_delete = duplicate;\n  if (loginfo)\n    log_file_remaining(loginfo, to_keep->d_name);\n\n  if (matchconfirmed)\n  {\n    if (remove(to_delete->d_name) == 0) {\n      printf(\"   [-] %s\\n\", to_delete->d_name);\n\n      if (loginfo)\n        log_file_deleted(loginfo, to_delete->d_name);\n    } else {\n      printf(\"   [!] %s \", to_delete->d_name);\n      printf(\"-- unable to delete file!\\n\");\n\n      if (loginfo)\n        log_file_remaining(loginfo, to_delete->d_name);\n    }\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void deletesuccessor(file_t **existing, file_t *duplicate, int matchconfirmed,\n      int (*comparef)(file_t *f1, file_t *f2), struct log_info *loginfo)\n{\n  file_t *to_keep;\n  file_t *to_delete;\n  char *errorstring;\n\n  if (comparef(duplicate, *existing) >= 0)\n  {\n    to_keep = *existing;\n    to_delete = duplicate;\n  if (loginfo)\n    log_file_remaining(loginfo, to_keep->d_name);\n\n  if (matchconfirmed)\n  {\n    if (removeifnotchanged(to_delete, &errorstring) == 0) {\n      printf(\"   [-] %s\\n\", to_delete->d_name);\n\n      if (loginfo)\n        log_file_deleted(loginfo, to_delete->d_name);\n    } else {\n      printf(\"   [!] %s \", to_delete->d_name);\n      printf(\"-- unable to delete file: %s!\\n\", errorstring);\n\n      if (loginfo)\n        log_file_remaining(loginfo, to_delete->d_name);\n    }\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void CoreUserInputHandler::handleSay(const BufferInfo &bufferInfo, const QString &msg)\n{\n    if (bufferInfo.bufferName().isEmpty() || !bufferInfo.acceptsRegularMessages())\n        return;  // server buffer\n\n    QByteArray encMsg = channelEncode(bufferInfo.bufferName(), msg);\n#ifdef HAVE_QCA2\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg, network()->cipher(bufferInfo.bufferName()));\n#else\n    putPrivmsg(serverEncode(bufferInfo.bufferName()), encMsg);\n#endif\n    emit displayMsg(Message::Plain, bufferInfo.type(), bufferInfo.bufferName(), msg, network()->myNick(), Message::Self);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void CoreUserInputHandler::handleSay(const BufferInfo &bufferInfo, const QString &msg)\n{\n    if (bufferInfo.bufferName().isEmpty() || !bufferInfo.acceptsRegularMessages())\n        return;  // server buffer\n\n    std::function<QByteArray(const QString &, const QString &)> encodeFunc = [this] (const QString &target, const QString &message) -> QByteArray {\n        return channelEncode(target, message);\n    };\n\n#ifdef HAVE_QCA2\n    putPrivmsg(bufferInfo.bufferName(), msg, encodeFunc, network()->cipher(bufferInfo.bufferName()));\n#else\n    putPrivmsg(bufferInfo.bufferName(), msg, encodeFunc);\n#endif\n    emit displayMsg(Message::Plain, bufferInfo.type(), bufferInfo.bufferName(), msg, network()->myNick(), Message::Self);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static RzList *classes_from_symbols(RzBinFile *bf) {\n\tRzBinSymbol *sym;\n\tRzListIter *iter;\n\trz_list_foreach (bf->o->symbols, iter, sym) {\n\t\tif (sym->name[0] != '_') {\n\t\t\tcontinue;\n\t\t}\n\t\tconst char *cn = sym->classname;\n\t\tif (cn) {\n\t\t\tRzBinClass *c = rz_bin_file_add_class(bf, sym->classname, NULL, 0);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static RzList *classes_from_symbols(RzBinFile *bf) {\n\tRzBinSymbol *sym;\n\tRzListIter *iter;\n\trz_list_foreach (bf->o->symbols, iter, sym) {\n\t\tif (!sym->name || sym->name[0] != '_') {\n\t\t\tcontinue;\n\t\t}\n\t\tconst char *cn = sym->classname;\n\t\tif (cn) {\n\t\t\tRzBinClass *c = rz_bin_file_add_class(bf, sym->classname, NULL, 0);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ext2_xattr_delete_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\tstruct mb_cache_entry *ce;\n\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tce = mb_cache_entry_get(ext2_xattr_cache, bh->b_bdev, bh->b_blocknr);\n\tlock_buffer(bh);\n\tif (HDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\tif (ce)\n\t\t\tmb_cache_entry_free(ce);\n\t\text2_free_blocks(inode, EXT2_I(inode)->i_file_acl, 1);\n\t\tget_bh(bh);\n\t\tbforget(bh);\n\t\tunlock_buffer(bh);\n\t} else {\n\t\tle32_add_cpu(&HDR(bh)->h_refcount, -1);\n\t\tif (ce)\n\t\t\tmb_cache_entry_release(ce);\n\t\tea_bdebug(bh, \"refcount now=%d\",\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tif (IS_SYNC(inode))",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ext2_xattr_delete_inode(struct inode *inode)\n{\n\tstruct buffer_head *bh = NULL;\n\n\tdown_write(&EXT2_I(inode)->xattr_sem);\n\tif (!EXT2_I(inode)->i_file_acl)\n\t\tgoto cleanup;\n\tbh = sb_bread(inode->i_sb, EXT2_I(inode)->i_file_acl);\n\t    HDR(bh)->h_blocks != cpu_to_le32(1)) {\n\t\text2_error(inode->i_sb, \"ext2_xattr_delete_inode\",\n\t\t\t\"inode %ld: bad block %d\", inode->i_ino,\n\t\t\tEXT2_I(inode)->i_file_acl);\n\t\tgoto cleanup;\n\t}\n\tlock_buffer(bh);\n\tif (HDR(bh)->h_refcount == cpu_to_le32(1)) {\n\t\t__u32 hash = le32_to_cpu(HDR(bh)->h_hash);\n\n\t\t/*\n\t\t * This must happen under buffer lock for ext2_xattr_set2() to\n\t\t * reliably detect freed block\n\t\t */\n\t\tmb2_cache_entry_delete_block(EXT2_SB(inode->i_sb)->s_mb_cache,\n\t\t\t\t\t     hash, bh->b_blocknr);\n\t\text2_free_blocks(inode, EXT2_I(inode)->i_file_acl, 1);\n\t\tget_bh(bh);\n\t\tbforget(bh);\n\t\tunlock_buffer(bh);\n\t} else {\n\t\tle32_add_cpu(&HDR(bh)->h_refcount, -1);\n\t\tea_bdebug(bh, \"refcount now=%d\",\n\t\t\tle32_to_cpu(HDR(bh)->h_refcount));\n\t\tunlock_buffer(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tif (IS_SYNC(inode))",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    input_indices->shape().DebugString()));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    input_values->shape().DebugString()));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    input_shape->shape().DebugString()));\n\n    int rank = input_shape->NumElements();\n\n    OP_REQUIRES(\n        context, rank > 1,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    OP_REQUIRES_OK(context, GetMap(context, true /* is_writing */, &map));\n\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrix(input_indices->shape()),\n                errors::InvalidArgument(\n                    \"Input indices should be a matrix but received shape \",\n                    input_indices->shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_values->shape()),\n                errors::InvalidArgument(\n                    \"Input values should be a vector but received shape \",\n                    input_values->shape().DebugString()));\n    OP_REQUIRES(context, TensorShapeUtils::IsVector(input_shape->shape()),\n                errors::InvalidArgument(\n                    \"Input shape should be a vector but received shape \",\n                    input_shape->shape().DebugString()));\n    OP_REQUIRES(\n        context,\n        input_values->shape().dim_size(0) == input_indices->shape().dim_size(0),\n        errors::InvalidArgument(\n            \"Number of values must match first dimension of indices. \", \"Got \",\n            input_values->shape().dim_size(0),\n            \" values, indices shape: \", input_indices->shape().DebugString()));\n    OP_REQUIRES(\n        context,\n        input_shape->shape().dim_size(0) == input_indices->shape().dim_size(1),\n        errors::InvalidArgument(\n            \"Number of dimensions must match second dimension of indices. \",\n            \"Got \", input_shape->shape().dim_size(0),\n            \" dimensions, indices shape: \",\n            input_indices->shape().DebugString()));\n\n    int rank = input_shape->NumElements();\n\n    OP_REQUIRES(\n        context, rank > 1,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tsize_t c;\n\t\t\tassert(len != NULL);\n\n\t\t\t/* Strip off padding zero */\n\t\t\tif ((entry->flags & SC_ASN1_UNSIGNED)\n\t\t\t && obj[0] == 0x00 && objlen > 1) {\n\t\t\t\tobjlen--;\n\t\t\t\tobj++;\n\t\t\t}\n\n\t\t\t/* Allocate buffer if needed */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tsize_t c;\n\t\t\tassert(len != NULL);\n\n\t\t\t/* Strip off padding zero */\n\t\t\tif ((entry->flags & SC_ASN1_UNSIGNED)\n\t\t\t\t\t&& objlen > 1 && obj[0] == 0x00) {\n\t\t\t\tobjlen--;\n\t\t\t\tobj++;\n\t\t\t}\n\n\t\t\t/* Allocate buffer if needed */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  int i, ret;\n  char * message = NULL;\n  gnutls_pubkey_t pubkey = NULL;\n  gnutls_x509_crt_t cert = NULL;\n  gnutls_datum_t cert_dat, data, signature, cert_issued_by;\n  unsigned char data_signed[200], client_data_hash[32], cert_export[32], cert_export_b64[64];\n  size_t data_signed_offset = 0, client_data_hash_len = 32, cert_export_len = 32, cert_export_b64_len = 0;\n  \n  if (j_error != NULL) {\n    do {\n      if (gnutls_x509_crt_init(&cert)) {\n\n      if (sig == NULL || !cbor_isa_bytestring(sig)) {\n        json_array_append_new(j_error, json_string(\"Error sig is not a bytestring\"));\n        break;\n      }\n      \n      // Build bytestring to verify signature\n      data_signed[0] = 0x0;\n      data_signed_offset = 1;\n      \n      memcpy(data_signed+data_signed_offset, rpid_hash, rpid_hash_len);\n      \n      if (gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) {\n        json_array_append_new(j_error, json_string(\"Invalid signature\"));\n      }\n      \n    } while (0);\n    \n    if (json_array_size(j_error)) {\n      j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"error\", j_error);\n    } else {\n      j_return = json_pack(\"{sis{ss%}}\", \"result\", G_OK, \"data\", \"certificate\", cert_export_b64, cert_export_b64_len);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  int i, ret;\n  char * message = NULL;\n  gnutls_pubkey_t pubkey = NULL;\n  gnutls_x509_crt_t cert = NULL;\n  gnutls_datum_t cert_dat, data, signature, cert_issued_by;\n  unsigned char * data_signed = NULL, client_data_hash[32], cert_export[32], cert_export_b64[64];\n  size_t data_signed_offset = 0, client_data_hash_len = 32, cert_export_len = 32, cert_export_b64_len = 0;\n  \n  if (j_error != NULL) {\n    do {\n      if (gnutls_x509_crt_init(&cert)) {\n      if (sig == NULL || !cbor_isa_bytestring(sig)) {\n        json_array_append_new(j_error, json_string(\"Error sig is not a bytestring\"));\n        break;\n      }\n      \n      if ((data_signed = o_malloc(rpid_hash_len+client_data_hash_len+credential_id_len+cert_x_len+cert_y_len+2)) == NULL) {\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_attestation_fido_u2f - Error allocating data_signed\");\n        json_array_append_new(j_error, json_string(\"Internal error\"));\n        break;\n      }\n      \n      // Build bytestring to verify signature\n      data_signed[0] = 0x0;\n      data_signed_offset = 1;\n      \n      memcpy(data_signed+data_signed_offset, rpid_hash, rpid_hash_len);\n      if (gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) {\n        json_array_append_new(j_error, json_string(\"Invalid signature\"));\n      }\n      \n    } while (0);\n    o_free(data_signed);\n    \n    if (json_array_size(j_error)) {\n      j_return = json_pack(\"{sisO}\", \"result\", G_ERROR_PARAM, \"error\", j_error);\n    } else {\n      j_return = json_pack(\"{sis{ss%}}\", \"result\", G_OK, \"data\", \"certificate\", cert_export_b64, cert_export_b64_len);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    char *message_txt = xmpp_message_get_body(message);\n    if (!message_txt) {\n        log_warning(\"Carbon received with no message.\");\n        return TRUE;\n    }\n\n    const gchar *to = xmpp_stanza_get_to(message);\n    const gchar *from = xmpp_stanza_get_from(message);\n\n    // happens when receive a carbon of a self sent message\n    if (!to) to = from;\n\n    Jid *jid_from = jid_create(from);\n    Jid *jid_to = jid_create(to);\n    Jid *my_jid = jid_create(connection_get_fulljid());\n\n    // check for pgp encrypted message\n    char *enc_message = NULL;\n    xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);\n    if (x) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    if (!message_txt) {\n        log_warning(\"Carbon received with no message.\");\n        return TRUE;\n    }\n\n    Jid *my_jid = jid_create(connection_get_fulljid());\n    const char *const stanza_from = xmpp_stanza_get_from(stanza);\n    Jid *msg_jid = jid_create(stanza_from);\n    if (g_strcmp0(my_jid->barejid, msg_jid->barejid) != 0) {\n        log_warning(\"Invalid carbon received, from: %s\", stanza_from);\n        return TRUE;\n    }\n\n    const gchar *to = xmpp_stanza_get_to(message);\n    const gchar *from = xmpp_stanza_get_from(message);\n\n    // happens when receive a carbon of a self sent message\n    if (!to) to = from;\n\n    Jid *jid_from = jid_create(from);\n    Jid *jid_to = jid_create(to);\n\n    // check for pgp encrypted message\n    char *enc_message = NULL;\n    xmpp_stanza_t *x = xmpp_stanza_get_child_by_ns(message, STANZA_NS_ENCRYPTED);\n    if (x) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (strcmp(f->file, \"tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/cgroup.procs\") == 0 ||\n\t\t\tstrcmp(f->file, \"cgroup.procs\") == 0)\n\t\t// special case - we have to translate the pids\n\t\tr = do_write_pids(fc->pid, f->controller, f->cgroup, f->file, localbuf);\n\telse\n\t\tr = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf);\n\n\tif (!r)\n\t\tsize = -EINVAL;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (strcmp(f->file, \"tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/tasks\") == 0 ||\n\t\t\tstrcmp(f->file, \"/cgroup.procs\") == 0 ||\n\t\t\tstrcmp(f->file, \"cgroup.procs\") == 0)\n\t\t// special case - we have to translate the pids\n\t\tr = do_write_pids(fc->pid, fc->uid, f->controller, f->cgroup, f->file, localbuf);\n\telse\n\t\tr = cgfs_set_value(f->controller, f->cgroup, f->file, localbuf);\n\n\tif (!r)\n\t\tsize = -EINVAL;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    AreaData::Evidence evi = {argv[1], argv[2], argv[3]};\n    if (is_int && idx <= area->evidence().size() && idx >= 0) {\n        area->replaceEvidence(idx, evi);\n    }\n    sendEvidenceList(area);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    if (!checkEvidenceAccess(area))\n        return;\n    bool is_int = false;\n    int idx = argv[0].toInt(&is_int);\n    AreaData::Evidence evi = {argv[1], argv[2], argv[3]};\n    if (is_int && idx < area->evidence().size() && idx >= 0) {\n        area->replaceEvidence(idx, evi);\n    }\n    sendEvidenceList(area);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  void operator()(const CPUDevice& d, typename TTypes<T>::ConstFlat gradient,\n                  typename TTypes<T>::ConstFlat input,\n                  typename TTypes<T>::ConstScalar input_min_tensor,\n                  typename TTypes<T>::ConstScalar input_max_tensor,\n                  typename TTypes<T>::Flat input_backprop,\n                  typename TTypes<T>::Scalar input_min_backprop,\n                  typename TTypes<T>::Scalar input_max_backprop) {\n    QuantizeAndDequantizeOneScaleGradientImpl<CPUDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  void operator()(const CpuDevice& d, typename TTypes<T>::ConstFlat gradient,\n                  typename TTypes<T>::ConstFlat input,\n                  typename TTypes<T>::ConstScalar input_min_tensor,\n                  typename TTypes<T>::ConstScalar input_max_tensor,\n                  typename TTypes<T>::Flat input_backprop,\n                  typename TTypes<T>::Scalar input_min_backprop,\n                  typename TTypes<T>::Scalar input_max_backprop) {\n    QuantizeAndDequantizeOneScaleGradientImpl<CpuDevice, T>::Compute(\n        d, gradient, input, input_min_tensor, input_max_tensor, input_backprop,\n        input_min_backprop, input_max_backprop);\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int hns_rcb_get_ring_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n\t\treturn HNS_RING_STATIC_REG_NUM;\n\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    std::vector<int32> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int32_t dim = outputs[0]->flat<int32>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  } else {\n    std::vector<int64_t> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int64_t dim = outputs[0]->flat<int64_t>()(i);\n      shp.push_back(dim);\n    }\n    TF_CHECK_OK(TensorShapeUtils::MakeShape(shp, &new_dims));\n  }\n\n  if (!shape.IsCompatibleWith(new_dims)) {\n    return errors::Internal(\"Expected shape \", shape.DebugString(),\n                            \"to be compatible with \", new_dims.DebugString());",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    std::vector<int32> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int32_t dim = outputs[0]->flat<int32>()(i);\n      shp.push_back(dim);\n    }\n    s = TensorShapeUtils::MakeShape(shp, &new_dims);\n    if (!s.ok()) return s;\n  } else {\n    std::vector<int64_t> shp;\n    for (int i = 0; i < outputs[0]->NumElements(); ++i) {\n      int64_t dim = outputs[0]->flat<int64_t>()(i);\n      shp.push_back(dim);\n    }\n    s = TensorShapeUtils::MakeShape(shp, &new_dims);\n    if (!s.ok()) return s;\n  }\n\n  if (!shape.IsCompatibleWith(new_dims)) {\n    return errors::Internal(\"Expected shape \", shape.DebugString(),\n                            \"to be compatible with \", new_dims.DebugString());",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\n\t\tstruct dentry *new_dir, const char *new_name)\n{\n\tint error;\n\tstruct dentry *dentry = NULL, *trap;\n\tconst char *old_name;\n\n\ttrap = lock_rename(new_dir, old_dir);\n\t/* Source or destination directories don't exist? */\n\tif (d_really_is_negative(old_dir) || d_really_is_negative(new_dir))\n\t\tgoto exit;\n\tdentry = lookup_one_len(new_name, new_dir, strlen(new_name));\n\t/* Lookup failed, cyclic rename or target exists? */\n\tif (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))\n\t\tgoto exit;\n\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\n\terror = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),\n\t\t\t      dentry, 0);\n\tif (error) {\n\t\tfsnotify_oldname_free(old_name);\n\t\tgoto exit;\n\t}\n\td_move(old_dentry, dentry);\n\tfsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name,\n\t\td_is_dir(old_dentry),\n\t\tNULL, old_dentry);\n\tfsnotify_oldname_free(old_name);\n\tunlock_rename(new_dir, old_dir);\n\tdput(dentry);\n\treturn old_dentry;\nexit:\n\tif (dentry && !IS_ERR(dentry))",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,\n\t\tstruct dentry *new_dir, const char *new_name)\n{\n\tint error;\n\tstruct dentry *dentry = NULL, *trap;\n\tstruct name_snapshot old_name;\n\n\ttrap = lock_rename(new_dir, old_dir);\n\t/* Source or destination directories don't exist? */\n\tif (d_really_is_negative(old_dir) || d_really_is_negative(new_dir))\n\t\tgoto exit;\n\tdentry = lookup_one_len(new_name, new_dir, strlen(new_name));\n\t/* Lookup failed, cyclic rename or target exists? */\n\tif (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))\n\t\tgoto exit;\n\n\ttake_dentry_name_snapshot(&old_name, old_dentry);\n\n\terror = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),\n\t\t\t      dentry, 0);\n\tif (error) {\n\t\trelease_dentry_name_snapshot(&old_name);\n\t\tgoto exit;\n\t}\n\td_move(old_dentry, dentry);\n\tfsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name.name,\n\t\td_is_dir(old_dentry),\n\t\tNULL, old_dentry);\n\trelease_dentry_name_snapshot(&old_name);\n\tunlock_rename(new_dir, old_dir);\n\tdput(dentry);\n\treturn old_dentry;\nexit:\n\tif (dentry && !IS_ERR(dentry))",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteStatus PrepareAny(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteBool);\n  return PrepareSimple(context, node);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteStatus PrepareAny(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteBool);\n  return PrepareSimple(context, node);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t/* Initialize the device options */\n\tbond_dev->tx_queue_len = 0;\n\tbond_dev->flags |= IFF_MASTER|IFF_MULTICAST;\n\tbond_dev->priv_flags |= IFF_BONDING;\n\tbond_dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\n\t/* At first, we block adding VLANs. That's the only way to\n\t * prevent problems that occur when adding VLANs over an\n\t * empty bond. The block will be removed once non-challenged\n\t * slaves are enslaved.",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\t/* Initialize the device options */\n\tbond_dev->tx_queue_len = 0;\n\tbond_dev->flags |= IFF_MASTER|IFF_MULTICAST;\n\tbond_dev->priv_flags |= IFF_BONDING;\n\tbond_dev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n\n\t/* At first, we block adding VLANs. That's the only way to\n\t * prevent problems that occur when adding VLANs over an\n\t * empty bond. The block will be removed once non-challenged\n\t * slaves are enslaved.",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "inline bool ShapeIsVector(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* shape = GetInput(context, node, kShapeTensor);\n  return (shape->dims->size == 1 && shape->type == kTfLiteInt32);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "inline bool ShapeIsVector(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* shape = GetInput(context, node, kShapeTensor);\n  return (shape != nullptr && shape->dims->size == 1 &&\n          shape->type == kTfLiteInt32);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t}\n\tsprintf(buf, \"Creator: JasPer Version %s\", jas_getversion());\n\tcom = &enc->mrk->parms.com;\n\tcom->len = JAS_CAST(uint_fast16_t, strlen(buf));\n\tcom->regid = JPC_COM_LATIN;\n\tif (!(com->data = JAS_CAST(uchar *, jas_strdup(buf)))) {\n\t\tabort();\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write COM marker\\n\");\n\t\treturn -1;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t}\n\tsprintf(buf, \"Creator: JasPer Version %s\", jas_getversion());\n\tcom = &enc->mrk->parms.com;\n\tcom->len = JAS_CAST(uint_fast16_t, strlen(buf));\n\tcom->regid = JPC_COM_LATIN;\n\tif (!(com->data = JAS_CAST(jas_uchar *, jas_strdup(buf)))) {\n\t\tabort();\n\t}\n\tif (jpc_putms(enc->out, enc->cstate, enc->mrk)) {\n\t\tjas_eprintf(\"cannot write COM marker\\n\");\n\t\treturn -1;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TEST_F(ZNCTest, AwayNotify) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    auto client = ConnectClient();\n    client.Write(\"CAP LS\");\n    client.Write(\"PASS :hunter2\");\n    client.Write(\"NICK nick\");\n    client.Write(\"USER user/test x x :x\");\n    QByteArray cap_ls;\n    client.ReadUntilAndGet(\" LS :\", cap_ls);\n    ASSERT_THAT(cap_ls.toStdString(), AllOf(HasSubstr(\"cap-notify\"), Not(HasSubstr(\"away-notify\"))));\n    client.Write(\"CAP REQ :cap-notify\");\n    client.ReadUntil(\"ACK :cap-notify\");\n    client.Write(\"CAP END\");\n    client.ReadUntil(\" 001 \");\n    ircd.ReadUntil(\"USER\");\n    ircd.Write(\"CAP user LS :away-notify\");\n    ircd.ReadUntil(\"CAP REQ :away-notify\");\n    ircd.Write(\"CAP user ACK :away-notify\");\n    ircd.ReadUntil(\"CAP END\");\n    ircd.Write(\":server 001 user :welcome\");\n    client.ReadUntil(\"CAP user NEW :away-notify\");\n    client.Write(\"CAP REQ :away-notify\");\n    client.ReadUntil(\"ACK :away-notify\");\n    ircd.Write(\":x!y@z AWAY :reason\");\n    client.ReadUntil(\":x!y@z AWAY :reason\");\n    ircd.Close();\n    client.ReadUntil(\"DEL :away-notify\");\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TEST_F(ZNCTest, StatusEchoMessage) {\n    auto znc = Run();\n    auto ircd = ConnectIRCd();\n    auto client = LoginClient();\n    client.Write(\"CAP REQ :echo-message\");\n    client.Write(\"PRIVMSG *status :blah\");\n    client.ReadUntil(\":nick!user@irc.znc.in PRIVMSG *status :blah\");\n    client.ReadUntil(\":*status!znc@znc.in PRIVMSG nick :Unknown command\");\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  auto* params =\n      reinterpret_cast<TfLiteLSHProjectionParams*>(node->builtin_data);\n  TF_LITE_ENSURE(context, NumInputs(node) == 2 || NumInputs(node) == 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* hash = GetInput(context, node, 0);\n  TF_LITE_ENSURE_EQ(context, NumDimensions(hash), 2);\n  // Support up to 32 bits.\n  TF_LITE_ENSURE(context, SizeOfDimension(hash, 1) <= 32);\n\n  const TfLiteTensor* input = GetInput(context, node, 1);\n  TF_LITE_ENSURE(context, NumDimensions(input) >= 1);\n\n  if (NumInputs(node) == 3) {\n    const TfLiteTensor* weight = GetInput(context, node, 2);\n    TF_LITE_ENSURE_EQ(context, NumDimensions(weight), 1);\n    TF_LITE_ENSURE_EQ(context, SizeOfDimension(weight, 0),\n                      SizeOfDimension(input, 0));\n  }\n\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  switch (params->type) {\n    case kTfLiteLshProjectionSparse:\n      outputSize->data[0] = SizeOfDimension(hash, 0);\n      break;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  auto* params =\n      reinterpret_cast<TfLiteLSHProjectionParams*>(node->builtin_data);\n  TF_LITE_ENSURE(context, NumInputs(node) == 2 || NumInputs(node) == 3);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* hash;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &hash));\n  TF_LITE_ENSURE_EQ(context, NumDimensions(hash), 2);\n  // Support up to 32 bits.\n  TF_LITE_ENSURE(context, SizeOfDimension(hash, 1) <= 32);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &input));\n  TF_LITE_ENSURE(context, NumDimensions(input) >= 1);\n\n  if (NumInputs(node) == 3) {\n    const TfLiteTensor* weight;\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &weight));\n    TF_LITE_ENSURE_EQ(context, NumDimensions(weight), 1);\n    TF_LITE_ENSURE_EQ(context, SizeOfDimension(weight, 0),\n                      SizeOfDimension(input, 0));\n  }\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TfLiteIntArray* outputSize = TfLiteIntArrayCreate(1);\n  switch (params->type) {\n    case kTfLiteLshProjectionSparse:\n      outputSize->data[0] = SizeOfDimension(hash, 0);\n      break;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "     but rather for code size.  */\n  size_t cnt;\n  size_t total;\n  char *result;\n\n  /* Determine the nubmer of DST elements.  */\n  cnt = DL_DST_COUNT (s, 1);\n\n  /* If we do not have to replace anything simply copy the string.  */\n  if (cnt == 0)\n    return local_strdup (s);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "     but rather for code size.  */\n  size_t cnt;\n  size_t total;\n  char *result;\n\n  /* Determine the number of DST elements.  */\n  cnt = DL_DST_COUNT (s, 1);\n\n  /* If we do not have to replace anything simply copy the string.  */\n  if (cnt == 0)\n    return local_strdup (s);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    else\n      ProcessSwitch(Arg+1);\n  else\n    if (*Command==0)\n    {\n      wcsncpy(Command,Arg,ASIZE(Command));\n\n\n      *Command=toupperw(*Command);\n      // 'I' and 'S' commands can contain case sensitive strings after\n      // the first character, so we must not modify their case.",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    else\n      ProcessSwitch(Arg+1);\n  else\n    if (*Command==0)\n    {\n      wcsncpyz(Command,Arg,ASIZE(Command));\n\n\n      *Command=toupperw(*Command);\n      // 'I' and 'S' commands can contain case sensitive strings after\n      // the first character, so we must not modify their case.",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void __perf_sw_event(u32 event_id, u64 nr, int nmi,\n\t\t\t    struct pt_regs *regs, u64 addr)\n{\n\tstruct perf_sample_data data;\n\tint rctx;\n\n\tpreempt_disable_notrace();\n\tif (rctx < 0)\n\t\treturn;\n\n\tperf_sample_data_init(&data, addr);\n\n\tdo_perf_sw_event(PERF_TYPE_SOFTWARE, event_id, nr, nmi, &data, regs);\n\n\tperf_swevent_put_recursion_context(rctx);\n\tpreempt_enable_notrace();\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void __perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)\n{\n\tstruct perf_sample_data data;\n\tint rctx;\n\n\tpreempt_disable_notrace();\n\tif (rctx < 0)\n\t\treturn;\n\n\tperf_sample_data_init(&data, addr);\n\n\tdo_perf_sw_event(PERF_TYPE_SOFTWARE, event_id, nr, &data, regs);\n\n\tperf_swevent_put_recursion_context(rctx);\n\tpreempt_enable_notrace();\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  if (rc == IDN2_OK)\n    {\n      /* wow, this is ugly, but libidn manpage states:\n       * char * out  output zero terminated string that must have room for at\n       * least 63 characters plus the terminating zero.\n       */\n      if (output)\n\tstrcpy (output, (const char *) output_u8);\n\n      free(output_u8);\n    }\n\n  return rc;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    {\n      /* wow, this is ugly, but libidn manpage states:\n       * char * out  output zero terminated string that must have room for at\n       * least 63 characters plus the terminating zero.\n       */\n      size_t len = strlen ((char *) output_u8);\n\n      if (len > 63)\n        {\n\t  free (output_u8);\n\t  return IDN2_TOO_BIG_DOMAIN;\n        }\n\n      if (output)\n\tstrcpy (output, (char *) output_u8);\n\n      free (output_u8);\n    }\n\n  return rc;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) {\n\tr_return_val_if_fail (cmd && cmd->aliases && k, NULL);\n\treturn ht_pp_find(cmd->aliases, k, NULL);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "R_API RCmdAliasVal *r_cmd_alias_get(RCmd *cmd, const char *k) {\n\tr_return_val_if_fail (cmd && cmd->aliases && k, NULL);\n\treturn ht_pp_find (cmd->aliases, k, NULL);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    }\n  (void) FormatLocaleString(huffman_image->filename,MagickPathExtent,\"tiff:%s\",\n    filename);\n  (void) SetImageType(huffman_image,BilevelType,exception);\n  write_info=CloneImageInfo((ImageInfo *) NULL);\n  SetImageInfoFile(write_info,file);\n  (void) SetImageType(image,BilevelType,exception);\n  (void) SetImageDepth(image,1,exception);\n  write_info->compression=Group4Compression;\n  write_info->type=BilevelType;\n  (void) SetImageOption(write_info,\"quantum:polarity\",\"min-is-white\");\n  status=WriteTIFFImage(write_info,huffman_image,exception);\n  (void) fflush(file);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  (void) FormatLocaleString(huffman_image->filename,MagickPathExtent,\"tiff:%s\",\n    filename);\n  (void) SetImageType(huffman_image,BilevelType,exception);\n  write_info=CloneImageInfo((ImageInfo *) NULL);\n  SetImageInfoFile(write_info,file);\n  (void) SetImageDepth(image,1,exception);\n  (void) SetImageType(image,BilevelType,exception);\n  write_info->compression=Group4Compression;\n  write_info->type=BilevelType;\n  (void) SetImageOption(write_info,\"quantum:polarity\",\"min-is-white\");\n  status=WriteTIFFImage(write_info,huffman_image,exception);\n  (void) fflush(file);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (!fuzzy)\n\t{\n\t    if (attempt > 0 && patc == pat)\n\t\tbreak;\t// there was no anchor, no need to try again\n\t    regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);\n\t    if (regmatch.regprog == NULL)\n\t    {\n\t\tif (patc != pat)\n\t\t    vim_free(patc);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// round == 1: Count the matches.\n\t// round == 2: Build the array to keep the matches.\n\tfor (round = 1; round <= 2; ++round)\n\t\t    // :diffget or :diffput completion.\n\t\t    if (buf == curbuf || !diff_mode_buf(buf))\n\t\t\tcontinue;\n#endif\n\n\t\tif (!fuzzy)\n\t\t    p = buflist_match(&regmatch, buf, p_wic);\n\t\telse\n\t\t{\n\t\t    p = NULL;\n\t\t    // first try matching with the short file name\n\t\t    if ((score = fuzzy_match_str(buf->b_sfname, pat)) != 0)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tif (!fuzzy)\n\t{\n\t    if (attempt > 0 && patc == pat)\n\t\tbreak;\t// there was no anchor, no need to try again\n\t    regmatch.regprog = vim_regcomp(patc + attempt * 11, RE_MAGIC);\n\t}\n\n\t// round == 1: Count the matches.\n\t// round == 2: Build the array to keep the matches.\n\tfor (round = 1; round <= 2; ++round)\n\t\t    if (buf == curbuf || !diff_mode_buf(buf))\n\t\t\tcontinue;\n#endif\n\n\t\tif (!fuzzy)\n\t\t{\n\t\t    if (regmatch.regprog == NULL)\n\t\t    {\n\t\t\t// invalid pattern, possibly after recompiling\n\t\t\tif (patc != pat)\n\t\t\t    vim_free(patc);\n\t\t\treturn FAIL;\n\t\t    }\n\t\t    p = buflist_match(&regmatch, buf, p_wic);\n\t\t}\n\t\telse\n\t\t{\n\t\t    p = NULL;\n\t\t    // first try matching with the short file name\n\t\t    if ((score = fuzzy_match_str(buf->b_sfname, pat)) != 0)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t block_nr;\n\tint ret = 0;\n\n\tblock_in_file = (sector_t)page->index;\n\tlast_block = block_in_file + nr_pages;\n\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >>\n\t\t\t\t\t\t\tblkbits;\n\tif (last_block > last_block_in_file)\n\t\tlast_block = last_block_in_file;\ngot_it:\n\tif ((map->m_flags & F2FS_MAP_MAPPED)) {\n\t\tblock_nr = map->m_pblk + block_in_file - map->m_lblk;\n\t\tSetPageMappedToDisk(page);\n\n\t\tif (!PageUptodate(page) && !cleancache_get_page(page)) {\n\t\t\tSetPageUptodate(page);\n\t\t\tgoto confused;\n\t\t}\n\n\t\tif (!f2fs_is_valid_blkaddr(F2FS_I_SB(inode), block_nr,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tsector_t last_block;\n\tsector_t last_block_in_file;\n\tsector_t block_nr;\n\tint ret = 0;\n\n\tblock_in_file = (sector_t)page_index(page);\n\tlast_block = block_in_file + nr_pages;\n\tlast_block_in_file = (i_size_read(inode) + blocksize - 1) >>\n\t\t\t\t\t\t\tblkbits;\n\tif (last_block > last_block_in_file)\n\t\tlast_block = last_block_in_file;\ngot_it:\n\tif ((map->m_flags & F2FS_MAP_MAPPED)) {\n\t\tblock_nr = map->m_pblk + block_in_file - map->m_lblk;\n\t\tSetPageMappedToDisk(page);\n\n\t\tif (!PageUptodate(page) && (!PageSwapCache(page) &&\n\t\t\t\t\t!cleancache_get_page(page))) {\n\t\t\tSetPageUptodate(page);\n\t\t\tgoto confused;\n\t\t}\n\n\t\tif (!f2fs_is_valid_blkaddr(F2FS_I_SB(inode), block_nr,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  const int num_elements = NumElements(input);\n  TF_LITE_ENSURE_EQ(context, num_elements, NumElements(output));\n  switch (input->type) {\n    case kTfLiteInt64:\n      return copyToTensor(context, input->data.i64, output, num_elements);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  const int num_elements = NumElements(input);\n  TF_LITE_ENSURE_EQ(context, num_elements, NumElements(output));\n  switch (input->type) {\n    case kTfLiteInt64:\n      return copyToTensor(context, input->data.i64, output, num_elements);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\t//box has been disabled, do not write\n\tif (!a->size) return GF_OK;\n\t\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tGF_Err e;\n\tu64 pos = gf_bs_get_position(bs);\n\tif (!a) return GF_BAD_PARAM;\n\t//box has been disabled, do not write\n\tif (!a->size) return GF_OK;\n\n\tif (a->registry->disabled) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[iso file] Box %s disabled registry, skip write\\n\", gf_4cc_to_str(a->type)));\n\t\treturn GF_OK;\n\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\n\t\t\t//TXMInstrument* ins = &instr[y];\n\t\t\n\t\t\tf.readDwords(&instr[y].size,1);\n\t\t\t\n\t\t\tif (instr[y].size < 29)\n\t\t\t{\n\t\t\t\tmp_ubyte buffer[29];\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tf.read(buffer, 1, instr[y].size - 4);\n\t\t\t\tmemcpy(instr[y].name, buffer, 22);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\n\t\t\t//TXMInstrument* ins = &instr[y];\n\t\t\n\t\t\tf.readDwords(&instr[y].size,1);\n\t\t\t\n\t\t\tif (instr[y].size >= 4 && instr[y].size < 29)\n\t\t\t{\n\t\t\t\tmp_ubyte buffer[29];\n\t\t\t\tmemset(buffer, 0, sizeof(buffer));\n\t\t\t\tf.read(buffer, 1, instr[y].size - 4);\n\t\t\t\tmemcpy(instr[y].name, buffer, 22);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t// we must place a sensible limit on the amount of data that will\n\t// be read, to avoid possibly allocating gigabytes of memory.\n\n\theader_len = lha_decode_uint32(&RAW_DATA(header, 24));\n\n\tif (header_len > LEVEL_3_MAX_HEADER_LEN) {\n\t\treturn 0;\n\t}\n\n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t// we must place a sensible limit on the amount of data that will\n\t// be read, to avoid possibly allocating gigabytes of memory.\n\n\theader_len = lha_decode_uint32(&RAW_DATA(header, 24));\n\n\tif (header_len > LEVEL_3_MAX_HEADER_LEN\n\t || header_len < RAW_DATA_LEN(header)) {\n\t\treturn 0;\n\t}\n\n\tif (!extend_raw_data(header, stream,\n\t                     header_len - RAW_DATA_LEN(header))) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "QualifyIpPacket(IPHeader *pIpHeader, ULONG len)\n{\n    tTcpIpPacketParsingResult res;\n    UCHAR  ver_len = pIpHeader->v4.ip_verlen;\n    UCHAR  ip_version = (ver_len & 0xF0) >> 4;\n    USHORT ipHeaderSize = 0;\n    USHORT fullLength = 0;\n    res.value = 0;\n    \n    if (ip_version == 4)\n    {\n        ipHeaderSize = (ver_len & 0xF) << 2;\n        fullLength = swap_short(pIpHeader->v4.ip_length);\n        DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d\\n\",\n            ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength));\n        res.ipStatus = (ipHeaderSize >= sizeof(IPv4Header)) ? ppresIPV4 : ppresNotIP;\n        if (len < ipHeaderSize) res.ipCheckSum = ppresIPTooShort;\n        if (fullLength) {}\n        else\n        {\n            DPrintf(2, (\"ip v.%d, iplen %d\\n\", ip_version, fullLength));\n        }\n    }\n    else if (ip_version == 6)\n    {\n        UCHAR nextHeader = pIpHeader->v6.ip6_next_header;\n    }\n    \n    if (res.ipStatus == ppresIPV4)\n    {\n        res.ipHeaderSize = ipHeaderSize;\n        res.xxpFull = len >= fullLength ? 1 : 0;\n        // bit \"more fragments\" or fragment offset mean the packet is fragmented\n        res.IsFragment = (pIpHeader->v4.ip_offset & ~0xC0) != 0;\n        switch (pIpHeader->v4.ip_protocol)\n        {\n            case PROTOCOL_TCP:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "QualifyIpPacket(IPHeader *pIpHeader, ULONG len)\n{\n    tTcpIpPacketParsingResult res;\n    res.value = 0;\n\n    if (len < 4)\n    {\n        res.ipStatus = ppresNotIP;\n        return res;\n    }\n\n    UCHAR  ver_len = pIpHeader->v4.ip_verlen;\n    UCHAR  ip_version = (ver_len & 0xF0) >> 4;\n    USHORT ipHeaderSize = 0;\n    USHORT fullLength = 0;\n    res.value = 0;\n\n    if (ip_version == 4)\n    {\n        if (len < sizeof(IPv4Header))\n        {\n            res.ipStatus = ppresNotIP;\n            return res;\n        }\n        ipHeaderSize = (ver_len & 0xF) << 2;\n        fullLength = swap_short(pIpHeader->v4.ip_length);\n        DPrintf(3, (\"ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\",\n            ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));\n\n        res.ipStatus = (ipHeaderSize >= sizeof(IPv4Header)) ? ppresIPV4 : ppresNotIP;\n        if (res.ipStatus == ppresNotIP)\n        {\n            return res;\n        }\n\n        if (ipHeaderSize >= fullLength || len < fullLength)\n        {\n            DPrintf(2, (\"[%s] - truncated packet - ip_version %d, ipHeaderSize %d, protocol %d, iplen %d, L2 payload length %d\\n\",\n                ip_version, ipHeaderSize, pIpHeader->v4.ip_protocol, fullLength, len));\n            res.ipCheckSum = ppresIPTooShort;\n            return res;\n        }\n    }\n    else if (ip_version == 6)\n    {\n        UCHAR nextHeader = pIpHeader->v6.ip6_next_header;\n    }\n    \n    if (res.ipStatus == ppresIPV4)\n    {\n        res.ipHeaderSize = ipHeaderSize;\n\n        // bit \"more fragments\" or fragment offset mean the packet is fragmented\n        res.IsFragment = (pIpHeader->v4.ip_offset & ~0xC0) != 0;\n        switch (pIpHeader->v4.ip_protocol)\n        {\n            case PROTOCOL_TCP:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t     0, /* value */\n\t\t\t     0, /* index */\n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc < 0)\n\t\tdev_err(&port->dev, \"Reading line status failed (error = %d)\\n\",\n\t\t\trc);\n\telse {\n\t\tstatus = get_unaligned_le16(status_buf);\n\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t     0, /* value */\n\t\t\t     0, /* index */\n\t\t\t     status_buf, KLSI_STATUSBUF_LEN,\n\t\t\t     10000\n\t\t\t     );\n\tif (rc != KLSI_STATUSBUF_LEN) {\n\t\tdev_err(&port->dev, \"reading line status failed: %d\\n\", rc);\n\t\tif (rc >= 0)\n\t\t\trc = -EIO;\n\t} else {\n\t\tstatus = get_unaligned_le16(status_buf);\n\n\t\tdev_info(&port->serial->dev->dev, \"read status %x %x\\n\",\n\t\t\t status_buf[0], status_buf[1]);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index) {\n  const bool use_tensor = index < node->inputs->size &&\n                          node->inputs->data[index] != kTfLiteOptionalTensor;\n  if (use_tensor) {\n    return GetMutableInput(context, node, index);\n  }\n  return nullptr;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "const TfLiteTensor* GetOptionalInputTensor(const TfLiteContext* context,\n                                           const TfLiteNode* node, int index) {\n  return GetInput(context, node, index);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  int64_t max_batches_per_split =\n      std::numeric_limits<int>::max() / elements_per_batch_input;\n\n  if (max_batches_per_split == 0) {\n    return tsl::Status(\n        port::error::INTERNAL,\n        absl::StrCat(\n            \"Tensor has too many elements for int32 indexing: batches=\",\n            num_batches, \" elements_per_batch=\", elements_per_batch_input,\n            \".\"));\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  int64_t max_batches_per_split =\n      std::numeric_limits<int>::max() / elements_per_batch_input;\n\n  if (max_batches_per_split == 0) {\n    return tsl::Status(\n        tsl::error::INTERNAL,\n        absl::StrCat(\n            \"Tensor has too many elements for int32 indexing: batches=\",\n            num_batches, \" elements_per_batch=\", elements_per_batch_input,\n            \".\"));\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int setpwnam(struct passwd *pwd)\n{\n\tFILE *fp = NULL, *pwf = NULL;\n\tint save_errno;\n\tint found;\n\tint namelen;\n\tint buflen = 256;\n\tint contlen, rc;\n\tchar *linebuf = NULL;\n\tchar *tmpname = NULL;\n\tchar *atomic_dir = \"/etc\";\n\n\tpw_init();\n\n\tif ((fp = xfmkstemp(&tmpname, atomic_dir)) == NULL)\n\t\treturn -1;\n\n\t/* ptmp should be owned by root.root or root.wheel */\n\tif (fchown(fileno(fp), (uid_t) 0, (gid_t) 0) < 0)\n\t\tgoto fail;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int setpwnam(struct passwd *pwd, const char *prefix)\n{\n\tFILE *fp = NULL, *pwf = NULL;\n\tint save_errno;\n\tint found;\n\tint namelen;\n\tint buflen = 256;\n\tint contlen, rc;\n\tchar *linebuf = NULL;\n\tchar *tmpname = NULL;\n\n\tpw_init();\n\n\tif ((fp = xfmkstemp(&tmpname, \"/etc\", prefix)) == NULL)\n\t\treturn -1;\n\n\t/* ptmp should be owned by root.root or root.wheel */\n\tif (fchown(fileno(fp), (uid_t) 0, (gid_t) 0) < 0)\n\t\tgoto fail;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tzend_call_method_with_1_params(&return_value, ce, &ce->constructor, \"__construct\", NULL, arg1);\n\t\tzval_ptr_dtor(&arg1);\n\t} else {\n\t\tspl_filesystem_info_set_filename(intern, file_path, file_path_len, use_copy TSRMLS_CC);\n\t}\n\t\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\treturn intern;\n} /* }}} */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tzend_call_method_with_1_params(&return_value, ce, &ce->constructor, \"__construct\", NULL, arg1);\n\t\tzval_ptr_dtor(&arg1);\n\t} else {\n\t\tspl_filesystem_info_set_filename(intern, file_path, file_path_len, use_copy TSRMLS_CC);\n\t}\n\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\treturn intern;\n} /* }}} */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        }\n        if (stop < 0)\n            stop += length;\n    }\n    if (unlikely(stop <= start))\n        return PyUnicode_FromUnicode(NULL, 0);\n    length = stop - start;\n    cstring += start;\n    if (decode_func) {\n        return decode_func(cstring, length, errors);\n    } else {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        }\n        if (stop < 0)\n            stop += length;\n    }\n    if (unlikely(stop <= start))\n        return __Pyx_NewRef(__pyx_empty_unicode);\n    length = stop - start;\n    cstring += start;\n    if (decode_func) {\n        return decode_func(cstring, length, errors);\n    } else {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "            but lets leave it there for the moment to avoid\n            changing output.  */\n        if (line_context->lc_file_entry_count > 9) {\n            dwarfstring_append_printf_u(&m3,\n                \"  file[%2u] \",fiu);\n            dwarfstring_append_printf_s(&m3,\n                \"%-20s \",\n                (char *) fe->fi_file_name);\n            dwarfstring_append_printf_u(&m3,\n                \"(file-number: %u)\\n\",\n                filenum);\n        } else {\n            dwarfstring_append_printf_u(&m3,\n                \"  file[%u]  \", fiu);\n            dwarfstring_append_printf_s(&m3,\n                \"%-20s \",(char *)fe->fi_file_name);\n            dwarfstring_append_printf_u(&m3,\n                \"(file-number: %u)\\n\",filenum);\n        }\n        _dwarf_printf(dbg,dwarfstring_string(&m3));\n        dwarfstring_reset(&m3);\n        if (fe->fi_dir_index_present) {\n            Dwarf_Unsigned di = 0;\n            di = fe->fi_dir_index;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        /*  The space character at the end of line is silly,\n            but lets leave it there for the moment to avoid\n            changing output.  */\n        if (line_context->lc_file_entry_count > 9) {\n            dwarfstring_append_printf_u(&m3,\n                \"  file[%2u] \",fiu);\n        } else {\n            dwarfstring_append_printf_u(&m3,\n                \"  file[%u]  \", fiu);\n        }\n        /*  DWARF5 can have a null fi_file_name\n            if  the format code in the\n            line table header is unknown, such\n            as in a corrupt object file. */\n        dwarfstring_append_printf_s(&m3,\n            \"%-20s \",\n            fe->fi_file_name?\n            (char *) fe->fi_file_name:\n            \"<no file name>\");\n        dwarfstring_append_printf_u(&m3,\n            \"(file-number: %u)\\n\",\n            filenum);\n        _dwarf_printf(dbg,dwarfstring_string(&m3));\n        dwarfstring_reset(&m3);\n        if (fe->fi_dir_index_present) {\n            Dwarf_Unsigned di = 0;\n            di = fe->fi_dir_index;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    Jsi_Obj *obj = _this->d.obj;\n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = Jsi_ObjGetLength(interp, obj);\n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    if (argc <= 0) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n        obj->arr[i] = ov;\n        Jsi_IncrRefCount(interp, ov);\n    }\n    Jsi_ObjSetLength(interp, obj, curlen+argc);\n    \n    Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj));\n    return JSI_OK;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj))\n        return Jsi_LogError(\"expected array object\");\n\n    Jsi_Obj *obj = _this->d.obj;\n    int argc = Jsi_ValueGetLength(interp, args);\n    int curlen = jsi_SizeOfArray(interp, obj);\n    if (argc <= 0) {\n        Jsi_ValueMakeNumber(interp, ret, 0);\n        return JSI_OK;\n    }\n    Jsi_ObjListifyArray(interp, obj);\n        obj->arr[i] = ov;\n        Jsi_IncrRefCount(interp, ov);\n    }\n    Jsi_ObjSetLength(interp, obj, curlen+argc);\n    \n    Jsi_ValueMakeNumber(interp, ret, jsi_SizeOfArray(interp, obj));\n    return JSI_OK;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "asmlinkage __visible void __init xen_start_kernel(void)\n{\n\tstruct physdev_set_iopl set_iopl;\n\tunsigned long initrd_start = 0;\n\tint rc;\n\n\tif (!xen_start_info)\n\t\treturn;\n\n\t__text_gen_insn(&early_xen_iret_patch,\n\t\t\tJMP32_INSN_OPCODE, &early_xen_iret_patch, &xen_iret,\n\t\t\tJMP32_INSN_SIZE);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "asmlinkage __visible void __init xen_start_kernel(struct start_info *si)\n{\n\tstruct physdev_set_iopl set_iopl;\n\tunsigned long initrd_start = 0;\n\tint rc;\n\n\tif (!si)\n\t\treturn;\n\n\tclear_bss();\n\n\txen_start_info = si;\n\n\t__text_gen_insn(&early_xen_iret_patch,\n\t\t\tJMP32_INSN_OPCODE, &early_xen_iret_patch, &xen_iret,\n\t\t\tJMP32_INSN_SIZE);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tcase PCIBAR_MEMHI64:\n\t\tdev->bar[idx].addr &= 0xffffffff;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tdefault:\n\t\tassert(0);\n\t}\n\n\tif (decode)\n\t\tregister_bar(dev, idx);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tcase PCIBAR_MEMHI64:\n\t\tdev->bar[idx].addr &= 0xffffffff;\n\t\tdev->bar[idx].addr |= addr;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: invalid bar type %d\\n\", __func__, type);\n\t\treturn;\n\t}\n\n\tif (decode)\n\t\tregister_bar(dev, idx);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n    while(tok != NULL) {\n      char *_equal;\n\n      if(strncmp(tok, \"csrf\", strlen(\"csrf\")) /* Do not put csrf into the params table */\n\t && (_equal = strchr(tok, '='))) {\n\tchar *decoded_buf;\n        int len;\n\n        _equal[0] = '\\0';\n        _equal = &_equal[1];",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n    while(tok != NULL) {\n      char *_equal;\n\n      if(strncmp(tok, \"csrf\", strlen(\"csrf\")) /* Do not put csrf into the params table */\n\t && (_equal = strchr(tok, '='))\n\t && (strlen(_equal) > 1)) {\n\tchar *decoded_buf;\n        int len;\n\n        _equal[0] = '\\0';\n        _equal = &_equal[1];",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  // Reinterprete the opaque data provided by user.\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n\n  const TfLiteType type = input1->type;\n  switch (type) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  // Reinterprete the opaque data provided by user.\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n\n  const TfLiteType type = input1->type;\n  switch (type) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      {\n        D.Incomplete=true;\n        break;\n      }\n    }\n    if (((WriteBorder-UnpPtr) & MaxWinMask)<MAX_LZ_MATCH+3 && WriteBorder!=UnpPtr)\n    {\n      UnpWriteBuf();\n      if (WrittenFileSize>DestUnpSize)\n        return false;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      {\n        D.Incomplete=true;\n        break;\n      }\n    }\n    if (((WriteBorder-UnpPtr) & MaxWinMask)<MAX_INC_LZ_MATCH && WriteBorder!=UnpPtr)\n    {\n      UnpWriteBuf();\n      if (WrittenFileSize>DestUnpSize)\n        return false;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "#else\n      struct sockaddr_un *sa = (struct sockaddr_un *)sock_type;\n      sa->sun_family = AF_UNIX;\n      if (addr.length() > sizeof(sa->sun_path)) {\n        raise_warning(\n          \"Unix socket path length (%d) is larger than system limit (%lu)\",\n          addr.length(),\n          sizeof(sa->sun_path)\n        );\n        return false;\n      }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "#else\n      struct sockaddr_un *sa = (struct sockaddr_un *)sock_type;\n      sa->sun_family = AF_UNIX;\n      if (addr.length() > sizeof(sa->sun_path)) {\n        raise_warning(\n          \"Unix socket path length (%ld) is larger than system limit (%lu)\",\n          addr.length(),\n          sizeof(sa->sun_path)\n        );\n        return false;\n      }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        char *domain_mask;\n\n        bool enable_debug;\n        bool enable_trace;\n    } optarg;\n    const char *argv_out[argc];\n\n    memset(&optarg, 0, sizeof(optarg));\n\n    ogs_getopt_init(&options, (char**)argv);\n    while ((opt = ogs_getopt(&options, \"vhDc:l:e:m:dt\")) != -1) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        char *domain_mask;\n\n        bool enable_debug;\n        bool enable_trace;\n    } optarg;\n    const char *argv_out[argc+1];\n\n    memset(&optarg, 0, sizeof(optarg));\n\n    ogs_getopt_init(&options, (char**)argv);\n    while ((opt = ogs_getopt(&options, \"vhDc:l:e:m:dt\")) != -1) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  /* Mac line endings */\n  if (len > 0 && s[len-1] == '\\n')\n    s[len-1] = '\\r';\n  t1mac_output_data((byte *)s, len);\n  if (strncmp(s, \"/FontName\", 9) == 0) {\n    for (s += 9; isspace(*s); s++) ;\n    if (*s == '/') {\n      const char *t = ++s;\n      while (*t && !isspace(*t)) t++;\n      free(font_name);\n      font_name = (char *)malloc(t - s + 1);\n      memcpy(font_name, s, t - s);\n      font_name[t - s] = 0;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  /* Mac line endings */\n  if (len > 0 && s[len-1] == '\\n')\n    s[len-1] = '\\r';\n  t1mac_output_data((byte *)s, len);\n  if (strncmp(s, \"/FontName\", 9) == 0) {\n    for (s += 9; isspace((unsigned char) *s); s++)\n        /* skip */;\n    if (*s == '/') {\n      const char *t = ++s;\n      while (*t && !isspace((unsigned char) *t)) t++;\n      free(font_name);\n      font_name = (char *)malloc(t - s + 1);\n      memcpy(font_name, s, t - s);\n      font_name[t - s] = 0;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                                 const std::string& emsa) :\n         PK_Ops::Verification_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_y(dsa.get_y()),\n         m_mod_q(dsa.group_q())\n         {}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                                 const std::string& emsa) :\n         PK_Ops::Verification_with_EMSA(emsa),\n         m_group(dsa.get_group()),\n         m_y(dsa.get_y()),\n         m_mod_q(dsa.group_q())\n         {\n         }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t{\n\t\t    // Do one more byte at this node.\n\t\t    n = arridx[depth] + curi[depth];\n\t\t    ++curi[depth];\n\t\t    c = byts[n];\n\t\t    if (c == 0)\n\t\t    {\n\t\t\t// End of word, deal with the word.\n\t\t\t// Don't use keep-case words in the fold-case tree,\n\t\t\t// they will appear in the keep-case tree.\n\t\t\t// Only use the word when the region matches.\n\t\t\tflags = (int)idxs[n];\n\t\t\tif ((round == 2 || (flags & WF_KEEPCAP) == 0)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t{\n\t\t    // Do one more byte at this node.\n\t\t    n = arridx[depth] + curi[depth];\n\t\t    ++curi[depth];\n\t\t    c = byts[n];\n\t\t    if (c == 0 || depth >= MAXWLEN - 1)\n\t\t    {\n\t\t\t// End of word or reached maximum length, deal with the\n\t\t\t// word.\n\t\t\t// Don't use keep-case words in the fold-case tree,\n\t\t\t// they will appear in the keep-case tree.\n\t\t\t// Only use the word when the region matches.\n\t\t\tflags = (int)idxs[n];\n\t\t\tif ((round == 2 || (flags & WF_KEEPCAP) == 0)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    if (GSSINT_CHK_LOOP(ctx))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    status = gssint_delete_internal_sec_context(minor_status,\n\t\t\t\t\t\tctx->mech_type,\n\t\t\t\t\t\t&ctx->internal_ctx_id,\n\t\t\t\t\t\toutput_token);\n    if (status)\n\treturn status;\n\n    /* now free up the space for the union context structure */\n    free(ctx->mech_type->elements);\n    free(ctx->mech_type);\n    free(*context_handle);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    if (GSSINT_CHK_LOOP(ctx))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n\tstatus = gssint_delete_internal_sec_context(minor_status,\n\t\t\t\t\t\t    ctx->mech_type,\n\t\t\t\t\t\t    &ctx->internal_ctx_id,\n\t\t\t\t\t\t    output_token);\n\tif (status)\n\t    return status;\n    }\n\n    /* now free up the space for the union context structure */\n    free(ctx->mech_type->elements);\n    free(ctx->mech_type);\n    free(*context_handle);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int mongo_env_read_socket( mongo *conn, void *buf, int len ) {\n    char *cbuf = buf;\n\n    while ( len ) {\n        int sent = recv( conn->sock, cbuf, len, 0 );\n        if ( sent == 0 || sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() );\n            return MONGO_ERROR;\n        }\n        cbuf += sent;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int mongo_env_read_socket( mongo *conn, void *buf, size_t len ) {\n    char *cbuf = buf;\n\n    while ( len ) {\n        size_t sent = recv( conn->sock, cbuf, len, 0 );\n        if ( sent == 0 || sent == -1 ) {\n            __mongo_set_error( conn, MONGO_IO_ERROR, NULL, WSAGetLastError() );\n            return MONGO_ERROR;\n        }\n        cbuf += sent;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tconst char *macro_mode;\n\tchar data[8];\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_GET_MODE,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 2,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial mode (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\n\tswitch (data[0]) {\n\tcase K90_MACRO_MODE_HW:\n\t\tmacro_mode = \"HW\";\n\t\tmacro_mode = \"SW\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"K90 in unknown mode: %02hhx.\\n\",\n\t\t\t data[0]);\n\t\treturn -EIO;\n\t}\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", macro_mode);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tconst char *macro_mode;\n\tchar *data;\n\n\tdata = kmalloc(2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_GET_MODE,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 2,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial mode (error %d).\\n\",\n\t\t\t ret);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tswitch (data[0]) {\n\tcase K90_MACRO_MODE_HW:\n\t\tmacro_mode = \"HW\";\n\t\tmacro_mode = \"SW\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"K90 in unknown mode: %02hhx.\\n\",\n\t\t\t data[0]);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = snprintf(buf, PAGE_SIZE, \"%s\\n\", macro_mode);\nout:\n\tkfree(data);\n\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tgoto skip;\n\t} else {\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps; ++pi->compno,\n\t  ++pi->picomp) {\n\t\tpirlvl = pi->picomp->pirlvls;\n\t\tpi->xstep = pi->picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls - 1));\n\t\tpi->ystep = pi->picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcheightexpn + pi->picomp->numrlvls - 1));\n\t\tfor (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];\n\t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;\n\t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);\n\t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n\t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n\t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n\t\t\t\t\tif (((pi->x == pi->xstart && ((trx0 << r) % (1 << rpx))) ||\n\t\t\t\t\t  !(pi->x % (pi->picomp->hsamp << rpx))) &&\n\t\t\t\t\t  ((pi->y == pi->ystart && ((try0 << r) % (1 << rpy))) ||\n\t\t\t\t\t  !(pi->y % (pi->picomp->vsamp << rpy)))) {\n\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x, pi->picomp->hsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcwidthexpn) - JPC_FLOORDIVPOW2(trx0,\n\t\t\t\t\t\t  pi->pirlvl->prcwidthexpn);\n\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y, pi->picomp->vsamp\n\t\t\t\t\t\t  << r), pi->pirlvl->prcheightexpn) - JPC_FLOORDIVPOW2(try0,\n\t\t\t\t\t\t  pi->pirlvl->prcheightexpn);\n\t\t\t\t\t\tpi->prcno = prcvind *\n\t\t\t\t\t\t  pi->pirlvl->numhprcs +\n\t\t\t\t\t\t  prchind;\n\t\t\t\t\t\tassert(pi->prcno <\n\t\t\t\t\t\t  pi->pirlvl->numprcs);\n\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno <\n\t\t\t\t\t\t  pi->numlyrs && pi->lyrno < JAS_CAST(int, pchg->lyrnoend); ++pi->lyrno) {\n\t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tgoto skip;\n\t} else {\n\t\tpi->prgvolfirst = 0;\n\t}\n\n\tfor (pi->compno = pchg->compnostart, pi->picomp = &pi->picomps[pi->compno];\n\t  pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps;\n\t  ++pi->compno, ++pi->picomp) {\n\t\tpirlvl = pi->picomp->pirlvls;\n\t\t// Check for the potential for overflow problems.\n\t\tif (pirlvl->prcwidthexpn + pi->picomp->numrlvls >\n\t\t  JAS_UINTFAST32_NUMBITS - 2 ||\n\t\t  pirlvl->prcheightexpn + pi->picomp->numrlvls >\n\t\t  JAS_UINTFAST32_NUMBITS - 2) {\n\t\t\treturn -1;\n\t\t}\n\t\tpi->xstep = pi->picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls - 1));\n\t\tpi->ystep = pi->picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcheightexpn + pi->picomp->numrlvls - 1));\n\t\tfor (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];\n\t\t\t\t\tr = pi->picomp->numrlvls - 1 - pi->rlvlno;\n\t\t\t\t\ttrx0 = JPC_CEILDIV(pi->xstart, pi->picomp->hsamp << r);\n\t\t\t\t\ttry0 = JPC_CEILDIV(pi->ystart, pi->picomp->vsamp << r);\n\t\t\t\t\trpx = r + pi->pirlvl->prcwidthexpn;\n\t\t\t\t\trpy = r + pi->pirlvl->prcheightexpn;\n\t\t\t\t\tif (((pi->x == pi->xstart &&\n\t\t\t\t\t  ((trx0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpx))) ||\n\t\t\t\t\t  !(pi->x % (pi->picomp->hsamp << rpx))) &&\n\t\t\t\t\t  ((pi->y == pi->ystart &&\n\t\t\t\t\t  ((try0 << r) % (JAS_CAST(uint_fast32_t, 1) << rpy))) ||\n\t\t\t\t\t  !(pi->y % (pi->picomp->vsamp << rpy)))) {\n\t\t\t\t\t\tprchind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->x,\n\t\t\t\t\t\t  pi->picomp->hsamp << r), pi->pirlvl->prcwidthexpn) -\n\t\t\t\t\t\t  JPC_FLOORDIVPOW2(trx0, pi->pirlvl->prcwidthexpn);\n\t\t\t\t\t\tprcvind = JPC_FLOORDIVPOW2(JPC_CEILDIV(pi->y,\n\t\t\t\t\t\t  pi->picomp->vsamp << r), pi->pirlvl->prcheightexpn) -\n\t\t\t\t\t\t  JPC_FLOORDIVPOW2(try0, pi->pirlvl->prcheightexpn);\n\t\t\t\t\t\tpi->prcno = prcvind * pi->pirlvl->numhprcs + prchind;\n\t\t\t\t\t\tassert(pi->prcno < pi->pirlvl->numprcs);\n\t\t\t\t\t\tfor (pi->lyrno = 0; pi->lyrno < pi->numlyrs &&\n\t\t\t\t\t\t  pi->lyrno < JAS_CAST(int, pchg->lyrnoend);\n\t\t\t\t\t\t  ++pi->lyrno) {\n\t\t\t\t\t\t\tprclyrno = &pi->pirlvl->prclyrnos[pi->prcno];\n\t\t\t\t\t\t\tif (pi->lyrno >= *prclyrno) {\n\t\t\t\t\t\t\t\t++(*prclyrno);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tintern->file_name_len = 10;\n\t}\n\tintern->u.file.open_mode = \"wb\";\n\tintern->u.file.open_mode_len = 1;\n\tintern->u.file.zcontext = NULL;\n\t\n\tif (spl_filesystem_file_open(intern, 0, 0 TSRMLS_CC) == SUCCESS) {\n\t\tintern->_path_len = 0;\n\t\tintern->_path = estrndup(\"\", 0);\n\t}\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tintern->file_name_len = 10;\n\t}\n\tintern->u.file.open_mode = \"wb\";\n\tintern->u.file.open_mode_len = 1;\n\tintern->u.file.zcontext = NULL;\n\n\tif (spl_filesystem_file_open(intern, 0, 0 TSRMLS_CC) == SUCCESS) {\n\t\tintern->_path_len = 0;\n\t\tintern->_path = estrndup(\"\", 0);\n\t}\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n    PyObject* tmp = NULL;\n    expr_ty context_expr;\n    expr_ty optional_vars;\n\n    if (_PyObject_HasAttrId(obj, &PyId_context_expr)) {\n        int res;\n        tmp = _PyObject_GetAttrId(obj, &PyId_context_expr);\n        if (tmp == NULL) goto failed;\n        res = obj2ast_expr(tmp, &context_expr, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    } else {\n        PyErr_SetString(PyExc_TypeError, \"required field \\\"context_expr\\\" missing from withitem\");\n        return 1;\n    }\n    if (exists_not_none(obj, &PyId_optional_vars)) {\n        int res;\n        tmp = _PyObject_GetAttrId(obj, &PyId_optional_vars);\n        if (tmp == NULL) goto failed;\n        res = obj2ast_expr(tmp, &optional_vars, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    } else {\n        optional_vars = NULL;\n    }\n    *out = withitem(context_expr, optional_vars, arena);\n    return 0;\nfailed:\n    Py_XDECREF(tmp);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n    PyObject* tmp = NULL;\n    expr_ty context_expr;\n    expr_ty optional_vars;\n\n    if (lookup_attr_id(obj, &PyId_context_expr, &tmp) < 0) {\n        return 1;\n    }\n    if (tmp == NULL) {\n        PyErr_SetString(PyExc_TypeError, \"required field \\\"context_expr\\\" missing from withitem\");\n        return 1;\n    }\n    else {\n        int res;\n        res = obj2ast_expr(tmp, &context_expr, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    }\n    if (lookup_attr_id(obj, &PyId_optional_vars, &tmp) < 0) {\n        return 1;\n    }\n    if (tmp == NULL || tmp == Py_None) {\n        Py_CLEAR(tmp);\n        optional_vars = NULL;\n    }\n    else {\n        int res;\n        res = obj2ast_expr(tmp, &optional_vars, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    }\n    *out = withitem(context_expr, optional_vars, arena);\n    return 0;\nfailed:\n    Py_XDECREF(tmp);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n\tu_int caplen = ND_BYTES_AVAILABLE_AFTER(p);\n\tu_char *b, *t, c;\n\tconst u_char *s;\n\tu_int i, proto;\n\tconst void *sb, *se;\n\n\tif (caplen == 0)\n\t\treturn;\n\n        if (length == 0)\n                return;\n\n\tb = (u_char *)nd_malloc(ndo, caplen);\n\tif (b == NULL)\n\t\treturn;\n\n\t/*\n\t * Unescape all the data into a temporary, private, buffer.\n\t * Do this so that we don't overwrite the original packet\n\t * contents.\n\t\t}\n\t\t*t++ = c;\n\t}\n\n\t/*\n\t * Change the end pointer, so bounds checks work.\n\t * Change the pointer to packet data to help debugging.\n\t */\n\tsb = ndo->ndo_packetp;\n\tse = ndo->ndo_snapend;\n\tndo->ndo_packetp = b;\n\tndo->ndo_snapend = t;\n\tlength = ND_BYTES_AVAILABLE_AFTER(b);\n\n        /* now lets guess about the payload codepoint format */\n        if (length < 1)\n                goto trunc;\n                handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\n\ncleanup:\n\tndo->ndo_packetp = sb;\n\tndo->ndo_snapend = se;\n        return;\n\ntrunc:\n\tndo->ndo_packetp = sb;\n\tndo->ndo_snapend = se;\n\tnd_print_trunc(ndo);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "         const u_char *p, u_int length)\n{\n\tu_int caplen = ND_BYTES_AVAILABLE_AFTER(p);\n\tu_char *b, *t, c;\n\tconst u_char *s;\n\tu_int i, proto;\n\n\tif (caplen == 0)\n\t\treturn;\n\n        if (length == 0)\n                return;\n\n\tb = (u_char *)malloc(caplen);\n\tif (b == NULL) {\n\t\t(*ndo->ndo_error)(ndo, S_ERR_ND_MEM_ALLOC,\n\t\t\t\"%s: malloc\", __func__);\n\t}\n\n\t/*\n\t * Unescape all the data into a temporary, private, buffer.\n\t * Do this so that we don't overwrite the original packet\n\t * contents.\n\t\t}\n\t\t*t++ = c;\n\t}\n\n\t/*\n\t * Switch to the output buffer for dissection, and save it\n\t * on the buffer stack so it can be freed; our caller must\n\t * pop it when done.\n\t */\n\tif (!nd_push_buffer(ndo, b, b, (u_int)(t - b))) {\n\t\tfree(b);\n\t\t(*ndo->ndo_error)(ndo, S_ERR_ND_MEM_ALLOC,\n\t\t\t\"%s: can't push buffer on buffer stack\", __func__);\n\t}\n\tlength = ND_BYTES_AVAILABLE_AFTER(b);\n\n        /* now lets guess about the payload codepoint format */\n        if (length < 1)\n                goto trunc;\n                handle_ppp(ndo, proto, b + 2, length - 2);\n            break;\n        }\n\ncleanup:\n\tnd_pop_packet_info(ndo);\n        return;\n\ntrunc:\n\tnd_pop_packet_info(ndo);\n\tnd_print_trunc(ndo);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void CNativeControlEmbed::CreateObjectBuilderInContext(const std::string& name, JSSmart<CJSContext> context)\n{\n    v8::Isolate* current = CV8Worker::GetCurrent();\n    context->m_internal->m_global->Set(current, name.c_str(), v8::FunctionTemplate::New(current, NSNativeControl::CreateNativeObjectBuilder));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void CNativeControlEmbed::CreateObjectBuilderInContext(const std::string& name, JSSmart<CJSContext> context)\n{\n\tv8::Isolate* current = CV8Worker::GetCurrent();\n\tcontext->m_internal->m_global->Set(current, name.c_str(), v8::FunctionTemplate::New(current, NSNativeControl::CreateNativeObjectBuilder));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t    {\n\t\treturn;\n\t    } \n\t    IniBase::operator = (s);\n\t    ip = s.ip;\n\t    end_comment = s.end_comment; rewrite_by = s.rewrite_by;\n\t    container = s.container;\n\n\t    reindex ();\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t    {\n\t\treturn;\n\t    } \n\t    IniBase::operator = (s);\n\t    ip = s.ip;\n\t    end_comment = s.end_comment;\n            is_private = s.is_private;\n            rewrite_by = s.rewrite_by;\n\t    container = s.container;\n\n\t    reindex ();\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tmemcpy(args->value, &name_loc->nameval[args->namelen], valuelen);\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tASSERT(name_rmt->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n\t\tvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n\t\t\t\t\t\t       valuelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < valuelen) {\n\t\t\targs->valuelen = valuelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = valuelen;\n\t}\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tmemcpy(args->value, &name_loc->nameval[args->namelen], valuelen);\n\t} else {\n\t\tname_rmt = xfs_attr3_leaf_name_remote(leaf, args->index);\n\t\tASSERT(name_rmt->namelen == args->namelen);\n\t\tASSERT(memcmp(args->name, name_rmt->name, args->namelen) == 0);\n\t\targs->rmtvaluelen = be32_to_cpu(name_rmt->valuelen);\n\t\targs->rmtblkno = be32_to_cpu(name_rmt->valueblk);\n\t\targs->rmtblkcnt = xfs_attr3_rmt_blocks(args->dp->i_mount,\n\t\t\t\t\t\t       args->rmtvaluelen);\n\t\tif (args->flags & ATTR_KERNOVAL) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn 0;\n\t\t}\n\t\tif (args->valuelen < args->rmtvaluelen) {\n\t\t\targs->valuelen = args->rmtvaluelen;\n\t\t\treturn XFS_ERROR(ERANGE);\n\t\t}\n\t\targs->valuelen = args->rmtvaluelen;\n\t}\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t// Not a known command: beep.\n\tclearopbeep(oap);\n\tgoto normal_end;\n    }\n\n    if ((nv_cmds[idx].cmd_flags & NV_NCW)\n\t\t\t\t&& (check_text_locked(oap) || curbuf_locked()))\n\t// this command is not allowed now\n\tgoto normal_end;\n\n    // In Visual/Select mode, a few keys are handled in a special way.\n    if (VIsual_active)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t// Not a known command: beep.\n\tclearopbeep(oap);\n\tgoto normal_end;\n    }\n\n    if ((nv_cmds[idx].cmd_flags & NV_NCW) && check_text_or_curbuf_locked(oap))\n\t// this command is not allowed now\n\tgoto normal_end;\n\n    // In Visual/Select mode, a few keys are handled in a special way.\n    if (VIsual_active)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif (pps->sps_id >= 16) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\tvvc->sps_active_idx = pps->sps_id; /*set active sps*/",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (!pps->state) {\n\t\tpps->id = pps_id;\n\t\tpps->state = 1;\n\t}\n\tpps->sps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif ((pps->sps_id<0) || (pps->sps_id >= 16)) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[VVC] wrong SPS ID %d in PPS\\n\", pps->sps_id));\n\t\tpps->sps_id=0;\n\t\treturn -1;\n\t}\n\tvvc->sps_active_idx = pps->sps_id; /*set active sps*/",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tif (!addr) {\n\t\tut8 b[128];\n\t\tut64 entry = addr_to_offset(bin, bin->entry);\n\t\t// XXX: X86 only and hacky!\n\t\tif (entry > bin->size || entry + sizeof (b) > bin->size)\n\t\t\treturn 0;\n\t\ti = r_buf_read_at (bin->b, entry, b, sizeof (b));\n\t\tif (i < 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tif (!addr) {\n\t\tut8 b[128];\n\t\tut64 entry = addr_to_offset(bin, bin->entry);\n\t\t// XXX: X86 only and hacky!\n\t\tif (entry > bin->size || entry + sizeof (b) > bin->size) {\n\t\t\treturn 0;\n\t\t}\n\t\ti = r_buf_read_at (bin->b, entry, b, sizeof (b));\n\t\tif (i < 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (i = 0; i < 64; i++) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    return false;\n  }\n\n  // An extra center frequency is computed at the top to get the upper\n  // limit on the high side of the final triangular filter.\n  center_frequencies_.resize(num_channels_ + 1);\n  const double mel_low = FreqToMel(lower_frequency_limit);\n  const double mel_hi = FreqToMel(upper_frequency_limit);\n  const double mel_span = mel_hi - mel_low;\n  const double mel_spacing = mel_span / static_cast<double>(num_channels_ + 1);\n  for (int i = 0; i < num_channels_ + 1; ++i) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    return false;\n  }\n\n  // An extra center frequency is computed at the top to get the upper\n  // limit on the high side of the final triangular filter.\n  std::size_t center_frequencies_size = std::size_t(num_channels_) + 1;\n  if (center_frequencies_size >= std::numeric_limits<int>::max() ||\n      center_frequencies_size > center_frequencies_.max_size()) {\n    LOG(ERROR) << \"Number of filterbank channels must be less than \"\n               << std::numeric_limits<int>::max()\n               << \" and less than or equal to \"\n               << center_frequencies_.max_size();\n    return false;\n  }\n  center_frequencies_.resize(center_frequencies_size);\n\n  const double mel_low = FreqToMel(lower_frequency_limit);\n  const double mel_hi = FreqToMel(upper_frequency_limit);\n  const double mel_span = mel_hi - mel_low;\n  const double mel_spacing = mel_span / static_cast<double>(num_channels_ + 1);\n  for (int i = 0; i < num_channels_ + 1; ++i) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n\tstruct btrfs_device *device;\n\n\tif (devid) {\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, NULL,\n\t\t\t\t\t   NULL);\n\t\tif (!device)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn device;\n\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n\tstruct btrfs_device *device;\n\n\tif (devid) {\n\t\tdevice = btrfs_find_device(fs_info->fs_devices, devid, NULL,\n\t\t\t\t\t   NULL, true);\n\t\tif (!device)\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\treturn device;\n\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    if (!pt) {\n        return boost::none;\n    }\n\n    // Deserialize from the plaintext\n    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n    ss << pt.get();\n\n    SaplingNotePlaintext ret;\n    ss >> ret;\n\n    assert(ss.size() == 0);\n\n    uint256 pk_d;\n    if (!librustzcash_ivk_to_pkd(ivk.begin(), ret.d.data(), pk_d.begin())) {\n        return boost::none;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    auto pt = AttemptSaplingEncDecryption(ciphertext, ivk, epk);\n    if (!pt) {\n        return boost::none;\n    }\n\n    // Deserialize from the plaintext\n    SaplingNotePlaintext ret;\n    try {\n        CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n        ss << pt.get();\n        ss >> ret;\n        assert(ss.size() == 0);\n    } catch (const boost::thread_interrupted&) {\n        throw;\n    } catch (...) {\n        return boost::none;\n    }\n\n    uint256 pk_d;\n    if (!librustzcash_ivk_to_pkd(ivk.begin(), ret.d.data(), pk_d.begin())) {\n        return boost::none;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n\t/* step two : do  proxy tunneling init */\n\tchar cmd[512];\n\tchar *inputline = NULL;\n\tchar *proxy_auth = NULL;\n\tchar debug_buff[512];\n\tint remaining = sizeof(cmd) - 1;\n\n\tremaining -= snprintf(cmd, sizeof(cmd), \"CONNECT %s:%d HTTP/1.1\\r\\n\", host, port);\n\tif (proxy->username && proxy->username[0]) {\n\t\tproxy_auth = encode_proxy_auth_str(proxy);\n\t\tremaining -= strlen(proxy_auth);\n\t\tstrncat(cmd, \"\\r\\n\", remaining);\n\t\tremaining -= 2;\n\t}\n\tstrncat(cmd, \"\\r\\n\", remaining);\n#ifndef DEBUG\n\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", cmd);\n\tdebug_print(debug_buff);\n#endif\n\tif (send(sockfd, cmd, strlen(cmd), 0) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n\tif (ay_recv_line(sockfd, &inputline) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n#ifndef DEBUG\n\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);\n\tdebug_print(debug_buff);\n#endif\n\tif (!strstr(inputline, \"200\")) {\n\t\t/* Check if proxy authorization needed */\n\t\tif (strstr(inputline, \"407\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\twhile (strlen(inputline) > 1) {\n\t\tfree(inputline);\n\t\tif (ay_recv_line(sockfd, &inputline) < 0) {\n\t\t\treturn AY_CONNECTION_REFUSED;\n\t\t}\n#ifndef DEBUG\n\t\tsnprintf(debug_buff, sizeof(debug_buff), \"<%s>\\n\", inputline);\n\t\tdebug_print(debug_buff);\n#endif\n\t}\n\tfree(inputline);\n\n\tg_free(proxy_auth);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int http_connect(int sockfd, const char *host, int port, AyProxyData *proxy)\n{\n\t/* step two : do  proxy tunneling init */\n\tchar cmd[512];\n\tchar *inputline = NULL;\n\tchar *proxy_auth = NULL;\n\tint remaining = sizeof(cmd) - 1;\n\n\tremaining -= snprintf(cmd, sizeof(cmd), \"CONNECT %s:%d HTTP/1.1\\r\\n\", host, port);\n\tif (proxy->username && proxy->username[0]) {\n\t\tproxy_auth = encode_proxy_auth_str(proxy);\n\t\tremaining -= strlen(proxy_auth);\n\t\tstrncat(cmd, \"\\r\\n\", remaining);\n\t\tremaining -= 2;\n\t}\n\tstrncat(cmd, \"\\r\\n\", remaining);\n#ifdef DEBUG\n\tdebug_print(\"<%s>\\n\", cmd);\n#endif\n\tif (send(sockfd, cmd, strlen(cmd), 0) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n\tif (ay_recv_line(sockfd, &inputline) < 0)\n\t\treturn AY_CONNECTION_REFUSED;\n#ifdef DEBUG\n\tdebug_print(\"<%s>\\n\", inputline);\n#endif\n\tif (!strstr(inputline, \"200\")) {\n\t\t/* Check if proxy authorization needed */\n\t\tif (strstr(inputline, \"407\")) {\n\t\t\twhile (ay_recv_line(sockfd, &inputline) > 0) {\n\twhile (strlen(inputline) > 1) {\n\t\tfree(inputline);\n\t\tif (ay_recv_line(sockfd, &inputline) < 0) {\n\t\t\treturn AY_CONNECTION_REFUSED;\n\t\t}\n#ifdef DEBUG\n\t\tdebug_print(\"<%s>\\n\", inputline);\n#endif\n\t}\n\tfree(inputline);\n\n\tg_free(proxy_auth);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "            public_shares[i] = publicShares[i].asString();\n        }\n\n        vector<string> public_keys = calculateAllBlsPublicKeys(public_shares);\n\n        if (public_keys.size() != n) {\n            throw SGXException(UNKNOWN_ERROR, \"\");\n        }\n\n        for (int i = 0; i < n; ++i) {\n            result[\"publicKeys\"][i] = public_keys[i];",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "            public_shares[i] = publicShares[i].asString();\n        }\n\n        vector<string> public_keys = calculateAllBlsPublicKeys(public_shares);\n\n        if (public_keys.size() != (uint64_t)n) {\n            throw SGXException(UNKNOWN_ERROR, \"\");\n        }\n\n        for (int i = 0; i < n; ++i) {\n            result[\"publicKeys\"][i] = public_keys[i];",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "            c = tok_nextc(tok);\n            if (c == ' ') {\n                col++, altcol++;\n            }\n            else if (c == '\\t') {\n                col = (col/tok->tabsize + 1) * tok->tabsize;\n                altcol = (altcol/tok->alttabsize + 1)\n                    * tok->alttabsize;\n            }\n            else if (c == '\\014')  {/* Control-L (formfeed) */\n                col = altcol = 0; /* For Emacs users */\n            }\n            else {\n        }\n        if (!blankline && tok->level == 0) {\n            if (col == tok->indstack[tok->indent]) {\n                /* No change */\n                if (altcol != tok->altindstack[tok->indent]) {\n                    if (indenterror(tok)) {\n                        return ERRORTOKEN;\n                    }\n                }\n            }\n            else if (col > tok->indstack[tok->indent]) {\n                /* Indent -- always one */\n                if (tok->indent+1 >= MAXINDENT) {\n                    tok->done = E_TOODEEP;\n                    tok->cur = tok->inp;\n                    return ERRORTOKEN;\n                }\n                if (altcol <= tok->altindstack[tok->indent]) {\n                    if (indenterror(tok)) {\n                        return ERRORTOKEN;\n                    }\n                }\n                tok->pendin++;\n                tok->indstack[++tok->indent] = col;\n                tok->altindstack[tok->indent] = altcol;\n            }\n                    tok->done = E_DEDENT;\n                    tok->cur = tok->inp;\n                    return ERRORTOKEN;\n                }\n                if (altcol != tok->altindstack[tok->indent]) {\n                    if (indenterror(tok)) {\n                        return ERRORTOKEN;\n                    }\n                }\n            }\n        }\n    }\n\n    }\n\n    /* Identifier (most frequent token!) */\n    nonascii = 0;\n    if (is_potential_identifier_start(c)) {\n        /* Process b\"\", r\"\", u\"\", br\"\" and rb\"\" */\n        int saw_b = 0, saw_r = 0, saw_u = 0, saw_f = 0;\n        while (1) {\n            if (!(saw_b || saw_u || saw_f) && (c == 'b' || c == 'B'))\n                saw_b = 1;\n            /* Since this is a backwards compatibility support literal we don't\n        *p_end = tok->cur;\n\n        /* async/await parsing block. */\n        if (tok->cur - tok->start == 5) {\n            /* Current token length is 5. */\n            if (tok->async_def) {\n                /* We're inside an 'async def' function. */\n                if (memcmp(tok->start, \"async\", 5) == 0) {\n                    return ASYNC;\n                }\n                if (memcmp(tok->start, \"await\", 5) == 0) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "            c = tok_nextc(tok);\n            if (c == ' ') {\n                col++, altcol++;\n            }\n            else if (c == '\\t') {\n                col = (col / tok->tabsize + 1) * tok->tabsize;\n                altcol = (altcol / ALTTABSIZE + 1) * ALTTABSIZE;\n            }\n            else if (c == '\\014')  {/* Control-L (formfeed) */\n                col = altcol = 0; /* For Emacs users */\n            }\n            else {\n        }\n        if (!blankline && tok->level == 0) {\n            if (col == tok->indstack[tok->indent]) {\n                /* No change */\n                if (altcol != tok->altindstack[tok->indent]) {\n                    return indenterror(tok);\n                }\n            }\n            else if (col > tok->indstack[tok->indent]) {\n                /* Indent -- always one */\n                if (tok->indent+1 >= MAXINDENT) {\n                    tok->done = E_TOODEEP;\n                    tok->cur = tok->inp;\n                    return ERRORTOKEN;\n                }\n                if (altcol <= tok->altindstack[tok->indent]) {\n                    return indenterror(tok);\n                }\n                tok->pendin++;\n                tok->indstack[++tok->indent] = col;\n                tok->altindstack[tok->indent] = altcol;\n            }\n                    tok->done = E_DEDENT;\n                    tok->cur = tok->inp;\n                    return ERRORTOKEN;\n                }\n                if (altcol != tok->altindstack[tok->indent]) {\n                    return indenterror(tok);\n                }\n            }\n        }\n    }\n\n    }\n\n    /* Identifier (most frequent token!) */\n    nonascii = 0;\n    if (is_potential_identifier_start(c)) {\n        /* Process the various legal combinations of b\"\", r\"\", u\"\", and f\"\". */\n        int saw_b = 0, saw_r = 0, saw_u = 0, saw_f = 0;\n        while (1) {\n            if (!(saw_b || saw_u || saw_f) && (c == 'b' || c == 'B'))\n                saw_b = 1;\n            /* Since this is a backwards compatibility support literal we don't\n        *p_end = tok->cur;\n\n        /* async/await parsing block. */\n        if (tok->cur - tok->start == 5) {\n            /* Current token length is 5. */\n            if (tok->async_always || tok->async_def) {\n                /* We're inside an 'async def' function. */\n                if (memcmp(tok->start, \"async\", 5) == 0) {\n                    return ASYNC;\n                }\n                if (memcmp(tok->start, \"await\", 5) == 0) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      // if no parent, check in root?\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n\n      if (jsvHasChildren(parent)) {\n        // else remove properly.\n        if (jsvIsArray(parent)) {\n          // For arrays, we must make sure we don't change the length\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    if (jsvIsName(a) && !jsvIsNewChild(a)) {\n      // if no parent, check in root?\n      if (!parent && jsvIsChild(execInfo.root, a))\n        parent = jsvLockAgain(execInfo.root);\n\n#ifdef DEBUG\n      if (jsvHasChildren(parent)) assert(jsvIsChild(parent, a));\n#endif\n      if (jsvHasChildren(parent) && jsvIsChild(parent, a)) {\n        // else remove properly.\n        /* we use jsvIsChild here just in case. delete probably isn't called\n        that often so it pays to be safe */\n        if (jsvIsArray(parent)) {\n          // For arrays, we must make sure we don't change the length\n          JsVarInt l = jsvGetArrayLength(parent);\n          jsvRemoveChild(parent, a);\n          jsvSetArrayLength(parent, l, false);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tint r = EMULATION_OK;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\n\tinit_emulate_ctxt(vcpu);\n\n\t/*\n\t * We will reenter on the same instruction since we do not set\n\t * complete_userspace_io. This does not handle watchpoints yet,\n\t * those would be handled in the emulate_ops.\n\t */\n\tif (!(emulation_type & EMULTYPE_SKIP) &&\n\t    kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\treturn r;\n\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu->stat.insn_emulation;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int x86_decode_emulated_instruction(struct kvm_vcpu *vcpu, int emulation_type,\n\t\t\t\t    void *insn, int insn_len)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint r;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tr = x86_decode_insn(ctxt, insn, insn_len, emulation_type);\n\n\ttrace_kvm_emulate_insn_start(vcpu);\n\t++vcpu->stat.insn_emulation;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static_inline bool unsafe_yyjson_num_equals(void *lhs, void *rhs) {\n    yyjson_val_uni *luni = &((yyjson_val *)lhs)->uni;\n    yyjson_val_uni *runi = &((yyjson_val *)rhs)->uni;\n    yyjson_subtype lt = unsafe_yyjson_get_subtype(lhs);\n    yyjson_subtype rt = unsafe_yyjson_get_subtype(rhs);\n    if (lt == rt)\n        return luni->u64 == runi->u64;\n    if (lt == YYJSON_SUBTYPE_SINT && rt == YYJSON_SUBTYPE_UINT)\n        return luni->i64 >= 0 && luni->u64 == runi->u64;\n    if (lt == YYJSON_SUBTYPE_UINT && rt == YYJSON_SUBTYPE_SINT)\n        return runi->i64 >= 0 && luni->u64 == runi->u64;\n    return false;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static_inline bool unsafe_yyjson_num_equals(void *lhs, void *rhs) {\n    yyjson_val_uni *luni = &((yyjson_val *)lhs)->uni;\n    yyjson_val_uni *runi = &((yyjson_val *)rhs)->uni;\n    yyjson_subtype lt = unsafe_yyjson_get_subtype(lhs);\n    yyjson_subtype rt = unsafe_yyjson_get_subtype(rhs);\n    if (lt == rt) return luni->u64 == runi->u64;\n    if (lt == YYJSON_SUBTYPE_SINT && rt == YYJSON_SUBTYPE_UINT) {\n        return luni->i64 >= 0 && luni->u64 == runi->u64;\n    }\n    if (lt == YYJSON_SUBTYPE_UINT && rt == YYJSON_SUBTYPE_SINT) {\n        return runi->i64 >= 0 && luni->u64 == runi->u64;\n    }\n    return false;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "u32 cdk_pk_get_keyid(cdk_pubkey_t pk, u32 * keyid)\n{\n\tu32 lowbits = 0;\n\tbyte buf[24];\n\n\tif (pk && (!pk->keyid[0] || !pk->keyid[1])) {\n\t\tif (pk->version < 4 && is_RSA(pk->pubkey_algo)) {\n\t\t\tbyte p[MAX_MPI_BYTES];\n\t\t\tsize_t n;\n\n\t\t\tn = MAX_MPI_BYTES;\n\t\t\t_gnutls_mpi_print(pk->mpi[0], p, &n);\n\t\t\tpk->keyid[0] =\n\t\t\t    p[n - 8] << 24 | p[n - 7] << 16 | p[n -\n\t\t\t\t\t\t\t\t6] << 8 |\n\t\t\t    p[n - 5];\n\t\t\tpk->keyid[1] =",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "u32 cdk_pk_get_keyid(cdk_pubkey_t pk, u32 * keyid)\n{\n\tu32 lowbits = 0;\n\tbyte buf[24];\n\tint rc;\n\n\tif (pk && (!pk->keyid[0] || !pk->keyid[1])) {\n\t\tif (pk->version < 4 && is_RSA(pk->pubkey_algo)) {\n\t\t\tbyte p[MAX_MPI_BYTES];\n\t\t\tsize_t n;\n\n\t\t\tn = MAX_MPI_BYTES;\n\t\t\trc = _gnutls_mpi_print(pk->mpi[0], p, &n);\n\t\t\tif (rc < 0 || n < 8) {\n\t\t\t\tkeyid[0] = keyid[1] = (u32)-1;\n\t\t\t\treturn (u32)-1;\n\t\t\t}\n\n\t\t\tpk->keyid[0] =\n\t\t\t    p[n - 8] << 24 | p[n - 7] << 16 | p[n -\n\t\t\t\t\t\t\t\t6] << 8 |\n\t\t\t    p[n - 5];\n\t\t\tpk->keyid[1] =",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tvoid *from, int length, int hh_len, int fragheaderlen,\n\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\t/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t */\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tstruct frag_hdr fhdr;\n\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\n\t\t/* initialize protocol header pointer */\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\n\t\t/* Specify the length of each IPv6 datagram fragment.\n\t\t * It has to be a multiple of 8.\n\t\t */\n\t\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\tipv6_select_ident(&fhdr, rt);\n\t\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t}\n\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tint transhdrlen, int mtu,unsigned int flags,\n\t\t\tstruct rt6_info *rt)\n\n{\n\tstruct sk_buff *skb;\n\tstruct frag_hdr fhdr;\n\tint err;\n\n\t/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t */\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\t\tskb_reset_network_header(skb);\n\n\t\t/* initialize protocol header pointer */\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->csum = 0;\n\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t} else if (skb_is_gso(skb)) {\n\t\tgoto append;\n\t}\n\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t/* Specify the length of each IPv6 datagram fragment.\n\t * It has to be a multiple of 8.\n\t */\n\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\tipv6_select_ident(&fhdr, rt);\n\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n\nappend:\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  int_fast32_t width, int_fast32_t height, uint_fast16_t depth, bool sgnd,\n  uint_fast32_t inmem)\n{\n\tjas_image_cmpt_t *cmpt;\n\tsize_t size;\n\n\tcmpt = 0;\n\tif (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {\n\t\tgoto error;\n\t}\n\tif (!jas_safe_intfast32_add(tlx, width, 0) ||\n\t  !jas_safe_intfast32_add(tly, height, 0)) {\n\t\tgoto error;\n\t}\n\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\tgoto error;\n\tcmpt->cps_ = (depth + 7) / 8;\n\n\t// Compute the number of samples in the image component, while protecting\n\t// against overflow.\n\t// size = cmpt->width_ * cmpt->height_ * cmpt->cps_;\n\tif (!jas_safe_size_mul(cmpt->width_, cmpt->height_, &size) ||\n\t  !jas_safe_size_mul(size, cmpt->cps_, &size)) {\n\t\tgoto error;\n\t}\n\tcmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :\n\t  jas_stream_tmpfile();\n\tif (!cmpt->stream_) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  uint_fast32_t inmem)\n{\n\tjas_image_cmpt_t *cmpt;\n\tsize_t size;\n\n\tJAS_DBGLOG(100, (\n\t  \"jas_image_cmpt_create(%ld, %ld, %ld, %ld, %ld, %ld, %d, %d, %d)\\n\",\n\t  JAS_CAST(long, tlx),\n\t  JAS_CAST(long, tly),\n\t  JAS_CAST(long, hstep),\n\t  JAS_CAST(long, vstep),\n\t  JAS_CAST(long, width),\n\t  JAS_CAST(long, height),\n\t  JAS_CAST(int, depth),\n\t  sgnd,\n\t  inmem\n\t  ));\n\n\tcmpt = 0;\n\tif (width < 0 || height < 0 || hstep <= 0 || vstep <= 0) {\n\t\tgoto error;\n\t}\n\tif (!jas_safe_intfast32_add(tlx, width, 0) ||\n\t  !jas_safe_intfast32_add(tly, height, 0)) {\n\t\tgoto error;\n\t}\n\tif (!jas_safe_intfast32_mul3(width, height, depth, 0)) {\n\t\tgoto error;\n\t}\n\n\tif (!(cmpt = jas_malloc(sizeof(jas_image_cmpt_t)))) {\n\t\tgoto error;\n\tcmpt->cps_ = (depth + 7) / 8;\n\n\t// Compute the number of samples in the image component, while protecting\n\t// against overflow.\n\t// size = cmpt->width_ * cmpt->height_ * cmpt->cps_;\n\tif (!jas_safe_size_mul3(cmpt->width_, cmpt->height_, cmpt->cps_, &size)) {\n\t\tgoto error;\n\t}\n\tcmpt->stream_ = (inmem) ? jas_stream_memopen2(0, size) :\n\t  jas_stream_tmpfile();\n\tif (!cmpt->stream_) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb->len - dataoff;\n\tunsigned int cscov;\n\tconst char *msg;\n\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tif (dh == NULL) {\n\t\tmsg = \"nf_ct_dccp: short packet \";\n\t\tgoto out_invalid;\n\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb->len - dataoff;\n\tunsigned int cscov;\n\tconst char *msg;\n\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);\n\tif (dh == NULL) {\n\t\tmsg = \"nf_ct_dccp: short packet \";\n\t\tgoto out_invalid;\n\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\n\ttmsize_t wc = cc / bps;\n\ttmsize_t count = cc;\n\tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp = (uint8 *)_TIFFmalloc(cc);\n\n    if(cc%(bps*stride)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"fpAcc\",\n                     \"%s\", \"cc%(bps*stride))!=0\");\n        return 0;\n    }\n\n\tif (!tmp)\n\t\treturn 0;\n\n\twhile (count > stride) {\n\t\tREPEAT4(stride, cp[stride] =",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\n\ttmsize_t wc = cc / bps;\n\ttmsize_t count = cc;\n\tuint8 *cp = (uint8 *) cp0;\n\tuint8 *tmp;\n\n    if(cc%(bps*stride)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"fpAcc\",\n                     \"%s\", \"cc%(bps*stride))!=0\");\n        return 0;\n    }\n\n    tmp = (uint8 *)_TIFFmalloc(cc);\n\tif (!tmp)\n\t\treturn 0;\n\n\twhile (count > stride) {\n\t\tREPEAT4(stride, cp[stride] =",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        logerror(\"Error creating backend %s : Couldn't open %s for reading\\n\",\n                    backend_name, path);\n        free(path);\n        return NULL;\n    }\n    if (fscanf(file, \"%s\", obj_path) == 0)\n    {\n        logerror(\"Error creating backend %s : Couldn't parse %s\\n\",\n                    backend_name, path);\n        free(path);\n        fclose(file);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        logerror(\"Error creating backend %s : Couldn't open %s for reading\\n\",\n                    backend_name, path);\n        free(path);\n        return NULL;\n    }\n    if (fscanf(file, \"%1023s\", obj_path) == 0)\n    {\n        logerror(\"Error creating backend %s : Couldn't parse %s\\n\",\n                    backend_name, path);\n        free(path);\n        fclose(file);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n{\n\tstruct sem_array *sma;\n\tstruct sem_undo_list *ulp;\n\tstruct sem_undo *un, *new;\n\tint nsems;\n\tint error;\n\n\terror = get_undo_list(&ulp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\t\trcu_read_unlock();\n\t\treturn ERR_CAST(sma);\n\t}\n\n\tnsems = sma->sem_nsems;\n\tipc_rcu_getref(sma);\n\trcu_read_unlock();\n\n\t/* step 2: allocate new undo structure */\n\tnew = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);\n\tif (!new) {\n\t}\n\n\t/* step 3: Acquire the lock on semaphore array */\n\tsem_lock_and_putref(sma);\n\tif (sma->sem_perm.deleted) {\n\t\tsem_unlock(sma);\n\t\tkfree(new);\n\t\tun = ERR_PTR(-EIDRM);\n\t\tgoto out;\n\t}\n\tspin_lock(&ulp->lock);\n\tun = new;\n\nsuccess:\n\tspin_unlock(&ulp->lock);\n\trcu_read_lock();\n\tsem_unlock(sma);\nout:\n\treturn un;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static struct sem_undo *find_alloc_undo(struct ipc_namespace *ns, int semid)\n{\n\tstruct sem_array *sma;\n\tstruct sem_undo_list *ulp;\n\tstruct sem_undo *un, *new;\n\tint nsems, error;\n\n\terror = get_undo_list(&ulp);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\t\trcu_read_unlock();\n\t\treturn ERR_CAST(sma);\n\t}\n\n\tnsems = sma->sem_nsems;\n\tif (!ipc_rcu_getref(sma)) {\n\t\trcu_read_unlock();\n\t\tun = ERR_PTR(-EIDRM);\n\t\tgoto out;\n\t}\n\trcu_read_unlock();\n\n\t/* step 2: allocate new undo structure */\n\tnew = kzalloc(sizeof(struct sem_undo) + sizeof(short)*nsems, GFP_KERNEL);\n\tif (!new) {\n\t}\n\n\t/* step 3: Acquire the lock on semaphore array */\n\tsem_lock_and_putref(sma);\n\tif (sma->sem_perm.deleted) {\n\t\tsem_unlock(sma, -1);\n\t\tkfree(new);\n\t\tun = ERR_PTR(-EIDRM);\n\t\tgoto out;\n\t}\n\tspin_lock(&ulp->lock);\n\tun = new;\n\nsuccess:\n\tspin_unlock(&ulp->lock);\n\trcu_read_lock();\n\tsem_unlock(sma, -1);\nout:\n\treturn un;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\trandom_ether_addr(dev->dev_addr);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n\trandom_ether_addr(dev->dev_addr);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "          mutt_progress_update(&progress, j, -1);\n        snprintf(buf, sizeof(buf), \"DELE %d\\r\\n\", ctx->hdrs[i]->refno);\n        ret = pop_query(pop_data, buf, sizeof(buf));\n        if (ret == 0)\n        {\n          mutt_bcache_del(pop_data->bcache, ctx->hdrs[i]->data);\n#ifdef USE_HCACHE\n          mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n#endif\n        }\n      }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "          mutt_progress_update(&progress, j, -1);\n        snprintf(buf, sizeof(buf), \"DELE %d\\r\\n\", ctx->hdrs[i]->refno);\n        ret = pop_query(pop_data, buf, sizeof(buf));\n        if (ret == 0)\n        {\n          mutt_bcache_del(pop_data->bcache, cache_id(ctx->hdrs[i]->data));\n#ifdef USE_HCACHE\n          mutt_hcache_delete(hc, ctx->hdrs[i]->data, strlen(ctx->hdrs[i]->data));\n#endif\n        }\n      }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (!library || library[0] != 'L') {\n\t\treturn NULL;\n\t}\n\tchar *demangled = strdup(library + 1);\n\trz_str_replace_ch(demangled, '/', '.', 1);\n\tdemangled[strlen(demangled) - 1] = 0;\n\treturn demangled;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (!library || library[0] != 'L') {\n\t\treturn NULL;\n\t}\n\tchar *demangled = strdup(library + 1);\n\trz_str_replace_ch(demangled, '/', '.', 1);\n\tif (RZ_STR_ISNOTEMPTY(demangled)) {\n\t\tdemangled[strlen(demangled) - 1] = 0;\n\t}\n\treturn demangled;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n  blocked_shape_.resize(original_rank);\n  block_size_.resize(block_map_.size());\n  for (int i = 0; i < original_rank; i++) {\n    if (block_dim < block_map_.size() && block_map_[block_dim] == i) {\n      int orig_dim = traversal_order_[original_rank + block_dim];\n      block_size_[block_dim] = dense_size[orig_dim];\n      blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];\n      block_dim++;\n    } else {\n      blocked_shape_[i] = dense_shape_[i];\n    }\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n  blocked_shape_.resize(original_rank);\n  block_size_.resize(block_map_.size());\n  for (int i = 0; i < original_rank; i++) {\n    if (block_dim < block_map_.size() && block_map_[block_dim] == i) {\n      if (original_rank + block_dim < traversal_order_.size()) {\n        int orig_dim = traversal_order_[original_rank + block_dim];\n        block_size_[block_dim] = dense_size[orig_dim];\n        blocked_shape_[i] = dense_shape_[i] / dense_size[orig_dim];\n        block_dim++;\n      }\n    } else {\n      blocked_shape_[i] = dense_shape_[i];\n    }\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t/*\n\t * Ensure irq/preemption can't change debugctl in between.\n\t * Note also that both TIF_BLOCKSTEP and debugctl should\n\t * be changed atomically wrt preemption.\n\t * FIXME: this means that set/clear TIF_BLOCKSTEP is simply\n\t * wrong if task != current, SIGKILL can wakeup the stopped\n\t * tracee and set/clear can play with the running task, this\n\t * can confuse the next __switch_to_xtra().\n\t */\n\tlocal_irq_disable();\n\tdebugctl = get_debugctlmsr();\n\tif (on) {\n\t\tdebugctl |= DEBUGCTLMSR_BTF;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\t/*\n\t * Ensure irq/preemption can't change debugctl in between.\n\t * Note also that both TIF_BLOCKSTEP and debugctl should\n\t * be changed atomically wrt preemption.\n\t *\n\t * NOTE: this means that set/clear TIF_BLOCKSTEP is only safe if\n\t * task is current or it can't be running, otherwise we can race\n\t * with __switch_to_xtra(). We rely on ptrace_freeze_traced() but\n\t * PTRACE_KILL is not safe.\n\t */\n\tlocal_irq_disable();\n\tdebugctl = get_debugctlmsr();\n\tif (on) {\n\t\tdebugctl |= DEBUGCTLMSR_BTF;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int WriteRiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)\n{\n    int do_rf64 = 0, write_junk = 1;\n    ChunkHeader ds64hdr, datahdr, fmthdr;\n    RiffChunkHeader riffhdr;\n    DS64Chunk ds64_chunk;\n    JunkChunk junkchunk;\n    WaveHeader wavhdr;\n    uint32_t bcount;\n\n    int64_t total_data_bytes, total_riff_bytes;\n    }\n\n    strncpy (riffhdr.ckID, do_rf64 ? \"RF64\" : \"RIFF\", sizeof (riffhdr.ckID));\n    strncpy (riffhdr.formType, \"WAVE\", sizeof (riffhdr.formType));\n    total_riff_bytes = sizeof (riffhdr) + wavhdrsize + sizeof (datahdr) + ((total_data_bytes + 1) & ~(int64_t)1);\n    if (do_rf64) total_riff_bytes += sizeof (ds64hdr) + sizeof (ds64_chunk);\n    if (write_junk) total_riff_bytes += sizeof (junkchunk);\n    strncpy (fmthdr.ckID, \"fmt \", sizeof (fmthdr.ckID));\n    strncpy (datahdr.ckID, \"data\", sizeof (datahdr.ckID));\n    fmthdr.ckSize = wavhdrsize;\n\n        WavpackNativeToLittleEndian (&junkchunk, ChunkHeaderFormat);\n    }\n\n    if (do_rf64) {\n        strncpy (ds64hdr.ckID, \"ds64\", sizeof (ds64hdr.ckID));\n        ds64hdr.ckSize = sizeof (ds64_chunk);\n        CLEAR (ds64_chunk);\n        ds64_chunk.riffSize64 = total_riff_bytes;\n        ds64_chunk.dataSize64 = total_data_bytes;\n        ds64_chunk.sampleCount64 = total_samples;\n        riffhdr.ckSize = (uint32_t) -1;\n        datahdr.ckSize = (uint32_t) -1;\n        WavpackNativeToLittleEndian (&ds64hdr, ChunkHeaderFormat);\n        WavpackNativeToLittleEndian (&ds64_chunk, DS64ChunkFormat);\n    }\n    else {\n        riffhdr.ckSize = (uint32_t) total_riff_bytes;\n        datahdr.ckSize = (uint32_t) total_data_bytes;\n    }\n\n    // write the RIFF chunks up to just before the data starts\n\n    WavpackNativeToLittleEndian (&riffhdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&wavhdr, WaveHeaderFormat);\n    WavpackNativeToLittleEndian (&datahdr, ChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &riffhdr, sizeof (riffhdr), &bcount) || bcount != sizeof (riffhdr) ||\n        (do_rf64 && (!DoWriteFile (outfile, &ds64hdr, sizeof (ds64hdr), &bcount) || bcount != sizeof (ds64hdr))) ||\n        (do_rf64 && (!DoWriteFile (outfile, &ds64_chunk, sizeof (ds64_chunk), &bcount) || bcount != sizeof (ds64_chunk))) ||\n        (write_junk && (!DoWriteFile (outfile, &junkchunk, sizeof (junkchunk), &bcount) || bcount != sizeof (junkchunk))) ||\n        !DoWriteFile (outfile, &fmthdr, sizeof (fmthdr), &bcount) || bcount != sizeof (fmthdr) ||\n        !DoWriteFile (outfile, &wavhdr, wavhdrsize, &bcount) || bcount != wavhdrsize ||\n        !DoWriteFile (outfile, &datahdr, sizeof (datahdr), &bcount) || bcount != sizeof (datahdr)) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int WriteRiffHeader (FILE *outfile, WavpackContext *wpc, int64_t total_samples, int qmode)\n{\n    int do_rf64 = 0, write_junk = 1, table_length = 0;\n    ChunkHeader ds64hdr, datahdr, fmthdr;\n    RiffChunkHeader riffhdr;\n    DS64Chunk ds64_chunk;\n    CS64Chunk cs64_chunk;\n    JunkChunk junkchunk;\n    WaveHeader wavhdr;\n    uint32_t bcount;\n\n    int64_t total_data_bytes, total_riff_bytes;\n\n    strncpy (riffhdr.ckID, do_rf64 ? \"RF64\" : \"RIFF\", sizeof (riffhdr.ckID));\n    strncpy (riffhdr.formType, \"WAVE\", sizeof (riffhdr.formType));\n    total_riff_bytes = sizeof (riffhdr) + wavhdrsize + sizeof (datahdr) + ((total_data_bytes + 1) & ~(int64_t)1);\n    if (do_rf64) total_riff_bytes += sizeof (ds64hdr) + sizeof (ds64_chunk);\n    total_riff_bytes += table_length * sizeof (CS64Chunk);\n    if (write_junk) total_riff_bytes += sizeof (junkchunk);\n    strncpy (fmthdr.ckID, \"fmt \", sizeof (fmthdr.ckID));\n    strncpy (datahdr.ckID, \"data\", sizeof (datahdr.ckID));\n    fmthdr.ckSize = wavhdrsize;\n\n        WavpackNativeToLittleEndian (&junkchunk, ChunkHeaderFormat);\n    }\n\n    if (do_rf64) {\n        strncpy (ds64hdr.ckID, \"ds64\", sizeof (ds64hdr.ckID));\n        ds64hdr.ckSize = sizeof (ds64_chunk) + (table_length * sizeof (CS64Chunk));\n        CLEAR (ds64_chunk);\n        ds64_chunk.riffSize64 = total_riff_bytes;\n        ds64_chunk.dataSize64 = total_data_bytes;\n        ds64_chunk.sampleCount64 = total_samples;\n        ds64_chunk.tableLength = table_length;\n        riffhdr.ckSize = (uint32_t) -1;\n        datahdr.ckSize = (uint32_t) -1;\n        WavpackNativeToLittleEndian (&ds64hdr, ChunkHeaderFormat);\n        WavpackNativeToLittleEndian (&ds64_chunk, DS64ChunkFormat);\n    }\n    else {\n        riffhdr.ckSize = (uint32_t) total_riff_bytes;\n        datahdr.ckSize = (uint32_t) total_data_bytes;\n    }\n\n    // this \"table\" is just a dummy placeholder for testing (normally not written)\n\n    if (table_length) {\n        strncpy (cs64_chunk.ckID, \"dmmy\", sizeof (cs64_chunk.ckID));\n        cs64_chunk.chunkSize64 = 12345678;\n        WavpackNativeToLittleEndian (&cs64_chunk, CS64ChunkFormat);\n    }\n\n    // write the RIFF chunks up to just before the data starts\n\n    WavpackNativeToLittleEndian (&riffhdr, ChunkHeaderFormat);\n    WavpackNativeToLittleEndian (&wavhdr, WaveHeaderFormat);\n    WavpackNativeToLittleEndian (&datahdr, ChunkHeaderFormat);\n\n    if (!DoWriteFile (outfile, &riffhdr, sizeof (riffhdr), &bcount) || bcount != sizeof (riffhdr) ||\n        (do_rf64 && (!DoWriteFile (outfile, &ds64hdr, sizeof (ds64hdr), &bcount) || bcount != sizeof (ds64hdr))) ||\n        (do_rf64 && (!DoWriteFile (outfile, &ds64_chunk, sizeof (ds64_chunk), &bcount) || bcount != sizeof (ds64_chunk)))) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n    }\n\n    // again, this is normally not written except for testing\n\n    while (table_length--)\n        if (!DoWriteFile (outfile, &cs64_chunk, sizeof (cs64_chunk), &bcount) || bcount != sizeof (cs64_chunk)) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;\n        }\n\n\n    if ((write_junk && (!DoWriteFile (outfile, &junkchunk, sizeof (junkchunk), &bcount) || bcount != sizeof (junkchunk))) ||\n        !DoWriteFile (outfile, &fmthdr, sizeof (fmthdr), &bcount) || bcount != sizeof (fmthdr) ||\n        !DoWriteFile (outfile, &wavhdr, wavhdrsize, &bcount) || bcount != wavhdrsize ||\n        !DoWriteFile (outfile, &datahdr, sizeof (datahdr), &bcount) || bcount != sizeof (datahdr)) {\n            error_line (\"can't write .WAV data, disk probably full!\");\n            return FALSE;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t{ \n\t\t    int i;\n\t\t    for (i = 0; mapi_attrs[i]; i++)\n\t\t    {\n\t\t\tMAPI_Attr *a = mapi_attrs[i];\n\t\t\t    \n\t\t\tif (a->name == MAPI_BODY_HTML)\n\t\t\t{\n\t\t\t    body.html_bodies = get_html_data (a);\n                                html_size = a->num_values;\n\t\t\t}\n\t\t\telse if (a->name == MAPI_RTF_COMPRESSED)\n\t\t\t{\n\t\t\t    body.rtf_bodies = get_rtf_data (a);\n                                rtf_size = a->num_values;\n\t\t\t}\n\t\t    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t{ \n\t\t    int i;\n\t\t    for (i = 0; mapi_attrs[i]; i++)\n\t\t    {\n\t\t\tMAPI_Attr *a = mapi_attrs[i];\n\t\t\n\t\t\tif (a->type == szMAPI_BINARY && a->name == MAPI_BODY_HTML)\n\t\t\t{\n\t\t\t    body.html_bodies = get_html_data (a);\n                                html_size = a->num_values;\n\t\t\t}\n\t\t\telse if (a->type == szMAPI_BINARY && a->name == MAPI_RTF_COMPRESSED)\n\t\t\t{\n\t\t\t    body.rtf_bodies = get_rtf_data (a);\n                                rtf_size = a->num_values;\n\t\t\t}\n\t\t    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    yyjson_val *val; /* current JSON value */\n    yyjson_val *ctn; /* current container */\n    yyjson_val *ctn_parent; /* parent of current container */\n    yyjson_doc *doc; /* the JSON document, equals to val_hdr */\n    const char *msg; /* error message */\n    \n    bool raw; /* read number as raw */\n    bool inv; /* allow invalid unicode */\n    u8 *raw_end; /* raw end for null-terminator */\n    u8 **pre; /* previous raw end pointer */\n    \n        ctn->tag = YYJSON_TYPE_ARR;\n        ctn->uni.ofs = 0;\n        goto arr_val_begin;\n    }\n    \narr_begin:\n    /* save current container */\n    ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n               (ctn->tag & YYJSON_TAG_MASK);\n    \n    /* create a new array value, save parent container offset */\n        if (skip_spaces_and_comments(&cur)) goto arr_val_end;\n        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \narr_end:\n    /* get parent container */\n    ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n    \n    /* save the next sibling value offset */\n    ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n        goto obj_val_end;\n    } else {\n        goto arr_val_end;\n    }\n    \nobj_begin:\n    /* push container */\n    ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n               (ctn->tag & YYJSON_TAG_MASK);\n    val_incr();\n    val->tag = YYJSON_TYPE_OBJ;\n        if (skip_spaces_and_comments(&cur)) goto obj_val_end;\n        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \nobj_end:\n    /* pop container */\n    ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n    /* point to the next value */\n    ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n    ctn->tag = (ctn_len << (YYJSON_TAG_BIT - 1)) | YYJSON_TYPE_OBJ;\nfail_comment:\n    return_err(cur, INVALID_COMMENT, \"unclosed multiline comment\");\nfail_character:\n    return_err(cur, UNEXPECTED_CHARACTER, \"unexpected character\");\nfail_garbage:\n    return_err(cur, UNEXPECTED_CONTENT, \"unexpected content after document\");\n    \n#undef val_incr\n#undef return_err\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    yyjson_val *val; /* current JSON value */\n    yyjson_val *ctn; /* current container */\n    yyjson_val *ctn_parent; /* parent of current container */\n    yyjson_doc *doc; /* the JSON document, equals to val_hdr */\n    const char *msg; /* error message */\n\n    u32 container_depth = 0; /* limit on number of open array and map */\n    bool raw; /* read number as raw */\n    bool inv; /* allow invalid unicode */\n    u8 *raw_end; /* raw end for null-terminator */\n    u8 **pre; /* previous raw end pointer */\n    \n        ctn->uni.ofs = 0;\n        goto arr_val_begin;\n    }\n    \narr_begin:\n    container_depth++;\n    if (unlikely(container_depth >= YYJSON_READER_CONTAINER_RECURSION_LIMIT)) {\n        goto fail_recursion;\n    }\n\n    /* save current container */\n    ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n               (ctn->tag & YYJSON_TAG_MASK);\n    \n    /* create a new array value, save parent container offset */\n        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \narr_end:\n    container_depth--;\n\n    /* get parent container */\n    ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n    \n    /* save the next sibling value offset */\n    ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n    } else {\n        goto arr_val_end;\n    }\n    \nobj_begin:\n    container_depth++;\n    if (unlikely(container_depth >= YYJSON_READER_CONTAINER_RECURSION_LIMIT)) {\n        goto fail_recursion;\n    }\n\n    /* push container */\n    ctn->tag = (((u64)ctn_len + 1) << YYJSON_TAG_BIT) |\n               (ctn->tag & YYJSON_TAG_MASK);\n    val_incr();\n    val->tag = YYJSON_TYPE_OBJ;\n        if (byte_match_2(cur, \"/*\")) goto fail_comment;\n    }\n    goto fail_character;\n    \nobj_end:\n    container_depth--;\n\n    /* pop container */\n    ctn_parent = (yyjson_val *)(void *)((u8 *)ctn - ctn->uni.ofs);\n    /* point to the next value */\n    ctn->uni.ofs = (usize)((u8 *)val - (u8 *)ctn) + sizeof(yyjson_val);\n    ctn->tag = (ctn_len << (YYJSON_TAG_BIT - 1)) | YYJSON_TYPE_OBJ;\n    return_err(cur, INVALID_COMMENT, \"unclosed multiline comment\");\nfail_character:\n    return_err(cur, UNEXPECTED_CHARACTER, \"unexpected character\");\nfail_garbage:\n    return_err(cur, UNEXPECTED_CONTENT, \"unexpected content after document\");\nfail_recursion:\n    return_err(cur, RECURSION_DEPTH, \"array and object recursion depth exceeded\");\n    \n#undef val_incr\n#undef return_err\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void rand_gen(uint8_t *out, int out_len) {\n\tint m = RLC_CEIL(out_len, RLC_MD_LEN);\n\tuint8_t hash[RLC_MD_LEN], data[(RLC_RAND_SIZE - 1)/2];\n\tctx_t *ctx = core_get();\n\n\t/* data = V */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void rand_gen(uint8_t *out, size_t out_len) {\n\tint m = RLC_CEIL(out_len, RLC_MD_LEN);\n\tuint8_t hash[RLC_MD_LEN], data[(RLC_RAND_SIZE - 1)/2];\n\tctx_t *ctx = core_get();\n\n\t/* data = V */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int cg_mkdir(const char *path, mode_t mode)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *path1, *cgdir = NULL, *controller;\n\tconst char *cgroup;\n\tint ret;\n\n\tif (!fc)\n\t\treturn -EIO;\n\tget_cgdir_and_path(cgroup, &cgdir, &fpath);\n\tif (!fpath)\n\t\tpath1 = \"/\";\n\telse\n\t\tpath1 = cgdir;\n\n\tif (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {\n\n\tret = cgfs_create(controller, cgroup, fc->uid, fc->gid);\n\tprintf(\"cgfs_create returned %d for %s %s\\n\", ret, controller, cgroup);\n\nout:\n\tfree(cgdir);\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int cg_mkdir(const char *path, mode_t mode)\n{\n\tstruct fuse_context *fc = fuse_get_context();\n\tchar *fpath = NULL, *path1, *cgdir = NULL, *controller, *next = NULL;\n\tconst char *cgroup;\n\tint ret;\n\n\tif (!fc)\n\t\treturn -EIO;\n\tif (!fpath)\n\t\tpath1 = \"/\";\n\telse\n\t\tpath1 = cgdir;\n\n\tif (!caller_is_in_ancestor(fc->pid, controller, path1, &next)) {\n\t\tif (fpath && strcmp(next, fpath) == 0)\n\t\t\tret = -EEXIST;\n\t\telse\n\t\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (!fc_may_access(fc, controller, path1, NULL, O_RDWR)) {\n\t\tret = -EACCES;\n\t\tgoto out;\n\t}\n\tif (!caller_is_in_ancestor(fc->pid, controller, path1, NULL)) {\n\tret = cgfs_create(controller, cgroup, fc->uid, fc->gid);\n\tprintf(\"cgfs_create returned %d for %s %s\\n\", ret, controller, cgroup);\n\nout:\n\tfree(cgdir);\n\tfree(next);\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static bool init_ehdr(ELFOBJ *bin) {\n\tut8 e_ident[EI_NIDENT];\n\tut8 ehdr[sizeof (Elf_(Ehdr))] = {0};\n\tint i, len;\n\tif (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) == -1) {\n\t\tR_LOG_ERROR (\"read (magic)\");\n\t\treturn false;\n\t}\n\tsdb_set (bin->kv, \"elf_type.cparse\", \"enum elf_type { ET_NONE=0, ET_REL=1,\"\n\t\t\t\" ET_EXEC=2, ET_DYN=3, ET_CORE=4, ET_LOOS=0xfe00, ET_HIOS=0xfeff,\"\n\t\t\t\" ET_LOPROC=0xff00, ET_HIPROC=0xffff };\", 0);\n#endif\n\tbin->endian = (e_ident[EI_DATA] == ELFDATA2MSB)? 1: 0;\n\tmemset (&bin->ehdr, 0, sizeof (Elf_(Ehdr)));\n\tlen = r_buf_read_at (bin->b, 0, ehdr, sizeof (ehdr));\n\tif (len < 32) { // tinyelf != sizeof (Elf_(Ehdr))) {\n\t\tR_LOG_ERROR (\"read (ehdr)\");\n\t\treturn false;\n\t}\n\t// XXX no need to check twice\n\tmemcpy (&bin->ehdr.e_ident, ehdr, 16);\n\tif (!__is_valid_ident (bin)) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static bool init_ehdr(ELFOBJ *bin) {\n\tut8 e_ident[EI_NIDENT];\n\tut8 ehdr[sizeof (Elf_(Ehdr))] = {0};\n\tint i, len;\n\tif (r_buf_read_at (bin->b, 0, e_ident, EI_NIDENT) == -1) {\n\t\tR_LOG_DEBUG (\"read (magic)\");\n\t\treturn false;\n\t}\n\tsdb_set (bin->kv, \"elf_type.cparse\", \"enum elf_type { ET_NONE=0, ET_REL=1,\"\n\t\t\t\" ET_EXEC=2, ET_DYN=3, ET_CORE=4, ET_LOOS=0xfe00, ET_HIOS=0xfeff,\"\n\t\t\t\" ET_LOPROC=0xff00, ET_HIPROC=0xffff };\", 0);\n#endif\n\tbin->endian = (e_ident[EI_DATA] == ELFDATA2MSB)? 1: 0;\n\tmemset (&bin->ehdr, 0, sizeof (Elf_(Ehdr)));\n\tlen = r_buf_read_at (bin->b, 0, ehdr, sizeof (ehdr));\n\tif (len < 32) { // tinyelf != sizeof (Elf_(Ehdr))) {\n\t\tR_LOG_DEBUG (\"read (ehdr)\");\n\t\treturn false;\n\t}\n\t// XXX no need to check twice\n\tmemcpy (&bin->ehdr.e_ident, ehdr, 16);\n\tif (!__is_valid_ident (bin)) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tgoto data_overrun_error;\n\t}\n\n\t/* Extract a tag from the data */\n\ttag = data[dp++];\n\tif (tag == 0) {\n\t\t/* It appears to be an EOC. */\n\t\tif (data[dp++] != 0)\n\t\t\tgoto invalid_eoc;\n\t\tif (--indef_level <= 0) {\n\t\t\t*_len = dp - *_dp;\n\t\t} while (tmp & 0x80);\n\t}\n\n\t/* Extract the length */\n\tlen = data[dp++];\n\tif (len <= 0x7f) {\n\t\tdp += len;\n\t\tgoto next_tag;\n\t}\n\n\tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\t/* Indefinite length */\n\t\tif (unlikely((tag & ASN1_CONS_BIT) == ASN1_PRIM << 5))\n\t\t\tgoto indefinite_len_primitive;\n\t\tindef_level++;\n\t\tgoto next_tag;\n\t}\n\n\tn = len - 0x80;\n\tif (unlikely(n > sizeof(size_t) - 1))\n\t\tgoto length_too_long;\n\tif (unlikely(n > datalen - dp))\n\t\tgoto data_overrun_error;\n\tfor (len = 0; n > 0; n--) {\n\t\tlen <<= 8;\n\t\tlen |= data[dp++];\n\t}\n\tdp += len;\n\tgoto next_tag;\n\nlength_too_long:\n\t*_errmsg = \"Unsupported length\";",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tgoto data_overrun_error;\n\t}\n\n\t/* Extract a tag from the data */\n\ttag = data[dp++];\n\tif (tag == ASN1_EOC) {\n\t\t/* It appears to be an EOC. */\n\t\tif (data[dp++] != 0)\n\t\t\tgoto invalid_eoc;\n\t\tif (--indef_level <= 0) {\n\t\t\t*_len = dp - *_dp;\n\t\t} while (tmp & 0x80);\n\t}\n\n\t/* Extract the length */\n\tlen = data[dp++];\n\tif (len <= 0x7f)\n\t\tgoto check_length;\n\n\tif (unlikely(len == ASN1_INDEFINITE_LENGTH)) {\n\t\t/* Indefinite length */\n\t\tif (unlikely((tag & ASN1_CONS_BIT) == ASN1_PRIM << 5))\n\t\t\tgoto indefinite_len_primitive;\n\t\tindef_level++;\n\t\tgoto next_tag;\n\t}\n\n\tn = len - 0x80;\n\tif (unlikely(n > sizeof(len) - 1))\n\t\tgoto length_too_long;\n\tif (unlikely(n > datalen - dp))\n\t\tgoto data_overrun_error;\n\tlen = 0;\n\tfor (; n > 0; n--) {\n\t\tlen <<= 8;\n\t\tlen |= data[dp++];\n\t}\ncheck_length:\n\tif (len > datalen - dp)\n\t\tgoto data_overrun_error;\n\tdp += len;\n\tgoto next_tag;\n\nlength_too_long:\n\t*_errmsg = \"Unsupported length\";",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void fp12_exp_dig(fp12_t c, const fp12_t a, dig_t b) {\n\tbn_t _b;\n\tfp12_t t, v;\n\tint8_t u, naf[RLC_DIG + 1];\n\tint l;\n\n\tif (b == 0) {\n\t\tfp12_set_dig(c, 1);\n\t\treturn;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void fp12_exp_dig(fp12_t c, const fp12_t a, dig_t b) {\n\tbn_t _b;\n\tfp12_t t, v;\n\tint8_t u, naf[RLC_DIG + 1];\n\tsize_t l;\n\n\tif (b == 0) {\n\t\tfp12_set_dig(c, 1);\n\t\treturn;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tbreak;\n\n\tcase NLPID_CLNP:\n\tcase NLPID_ESIS:\n\tcase NLPID_ISIS:\n\t\tisoclns_print(ndo, p - 1, length + 1, ndo->ndo_snapend - p + 1); /* OSI printers need the NLPID field */\n\t\tbreak;\n\n\tcase NLPID_SNAP:\n\t\tif (snap_print(ndo, p, length, ndo->ndo_snapend - p, NULL, NULL, 0) == 0) {\n\t\t\t/* ether_type not known, print raw packet */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tbreak;\n\n\tcase NLPID_CLNP:\n\tcase NLPID_ESIS:\n\tcase NLPID_ISIS:\n\t\tisoclns_print(ndo, p - 1, length + 1); /* OSI printers need the NLPID field */\n\t\tbreak;\n\n\tcase NLPID_SNAP:\n\t\tif (snap_print(ndo, p, length, ndo->ndo_snapend - p, NULL, NULL, 0) == 0) {\n\t\t\t/* ether_type not known, print raw packet */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "context_parse_args (FlatpakContext *context,\n                    ...)\n{\n  g_autoptr(GError) local_error = NULL;\n  g_autoptr(GOptionContext) oc = NULL;\n  g_autoptr(GOptionGroup) group = NULL;\n  g_autoptr(GPtrArray) args = g_ptr_array_new_with_free_func (g_free);\n  g_auto(GStrv) argv = NULL;\n  const char *arg;\n  va_list ap;\n\n  g_ptr_array_add (args, g_strdup (\"argv[0]\"));\n\n  va_start (ap, context);\n\n  while ((arg = va_arg (ap, const char *)) != NULL)\n    g_ptr_array_add (args, g_strdup (arg));\n\n  va_end (ap);\n  argv = (GStrv) g_ptr_array_free (g_steal_pointer (&args), FALSE);\n\n  oc = g_option_context_new (\"\");\n  group = flatpak_context_get_options (context);\n  g_option_context_add_group (oc, group);\n  g_option_context_parse_strv (oc, &argv, &local_error);\n  g_assert_no_error (local_error);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "context_parse_args (FlatpakContext *context,\n                    GError        **error,\n                    ...)\n{\n  g_autoptr(GOptionContext) oc = NULL;\n  g_autoptr(GOptionGroup) group = NULL;\n  g_autoptr(GPtrArray) args = g_ptr_array_new_with_free_func (g_free);\n  g_auto(GStrv) argv = NULL;\n  const char *arg;\n  va_list ap;\n\n  g_ptr_array_add (args, g_strdup (\"argv[0]\"));\n\n  va_start (ap, error);\n\n  while ((arg = va_arg (ap, const char *)) != NULL)\n    g_ptr_array_add (args, g_strdup (arg));\n\n  va_end (ap);\n  argv = (GStrv) g_ptr_array_free (g_steal_pointer (&args), FALSE);\n\n  oc = g_option_context_new (\"\");\n  group = flatpak_context_get_options (context);\n  g_option_context_add_group (oc, group);\n  g_option_context_parse_strv (oc, &argv, error);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  for (;;) {\n    const char *next\n        = entityTextPtr; /* XmlEntityValueTok doesn't always set the last arg */\n    int tok = XmlEntityValueTok(enc, entityTextPtr, entityTextEnd, &next);\n\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, entityTextPtr, next, __LINE__,\n                                  account)) {\n      accountingOnAbort(parser);\n      result = XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      goto endEntityValue;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  for (;;) {\n    const char *next\n        = entityTextPtr; /* XmlEntityValueTok doesn't always set the last arg */\n    int tok = XmlEntityValueTok(enc, entityTextPtr, entityTextEnd, &next);\n\n#if defined(XML_DTD) || XML_GE == 1\n    if (! accountingDiffTolerated(parser, tok, entityTextPtr, next, __LINE__,\n                                  account)) {\n      accountingOnAbort(parser);\n      result = XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      goto endEntityValue;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\tworking_segment_size = working_descriptor->packet_size;\n\n\t\t\t} else {\n\t\t\t\t// We don't know what this packet is, so we'll let the parser continue\n\t\t\t\t// just so that we can dequeue it in one shot\n\t\t\t\tworking_segment_size = packet_size + PACKET_SIZE_TYPE_SIZE;\n\n\t\t\t\tif (working_segment_size > CRSF_MAX_PACKET_LEN) {\n\t\t\t\t\tparser_statistics->invalid_unknown_packet_sizes++;\n\t\t\t\t\tparser_state = PARSER_STATE_HEADER;\n\t\t\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\tworking_segment_size = working_descriptor->packet_size;\n\n\t\t\t} else {\n\t\t\t\t// We don't know what this packet is, so we'll let the parser continue\n\t\t\t\t// just so that we can dequeue it in one shot\n\t\t\t\tworking_segment_size = packet_size - PACKET_SIZE_TYPE_SIZE;\n\n\t\t\t\tif (working_index + working_segment_size + CRC_SIZE > CRSF_MAX_PACKET_LEN) {\n\t\t\t\t\tparser_statistics->invalid_unknown_packet_sizes++;\n\t\t\t\t\tparser_state = PARSER_STATE_HEADER;\n\t\t\t\t\tworking_segment_size = HEADER_SIZE;\n\t\t\t\t\tworking_index = 0;\n\t\t\t\t\tbuffer_count = QueueBuffer_Count(&rx_queue);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tdoff = exif_get_long (d + offset + 8, data->priv->order);\n\telse\n\t\tdoff = offset + 8;\n\n\t/* Sanity checks */\n\tif ((doff + s < doff) || (doff + s < s) || (doff + s > size)) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag data past end of buffer (%u > %u)\", doff+s, size);\t\n\t\treturn 0;\n\t}\n\n\tentry->data = exif_data_alloc (data, s);\n\tif (entry->data) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tdoff = exif_get_long (d + offset + 8, data->priv->order);\n\telse\n\t\tdoff = offset + 8;\n\n\t/* Sanity checks */\n\tif (doff >= size) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag starts past end of buffer (%u > %u)\", doff, size);\n\t\treturn 0;\n\t}\n\n\tif (s > size - doff) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_DEBUG, \"ExifData\",\n\t\t\t\t  \"Tag data goes past end of buffer (%u > %u)\", doff+s, size);\n\t\treturn 0;\n\t}\n\n\tentry->data = exif_data_alloc (data, s);\n\tif (entry->data) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tstruct common_audit_data sa;\n\tstruct apparmor_audit_data aad = {0,};\n\tchar *command, *args = value;\n\tsize_t arg_size;\n\tint error;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\t/* args points to a PAGE_SIZE buffer, AppArmor requires that\n\t * the buffer must be null terminated or have size <= PAGE_SIZE -1\n\t * so that AppArmor can null terminate them\n\t */\n\tif (args[size - 1] != '\\0') {\n\t\tif (size == PAGE_SIZE)\n\t\t\treturn -EINVAL;\n\t\targs[size] = '\\0';\n\t}\n\n\t/* task can only write its own attributes */\n\tif (current != task)\n\t\treturn -EACCES;\n\n\targs = value;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\treturn -EINVAL;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\treturn -EINVAL;\n\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\telse\n\t\t\tgoto fail;\n\t} else\n\t\t/* only support the \"current\" and \"exec\" process attributes */\n\t\treturn -EINVAL;\n\n\tif (!error)\n\t\terror = size;\n\treturn error;\n\nfail:\n\tsa.type = LSM_AUDIT_DATA_NONE;\n\tsa.aad = &aad;\n\taad.profile = aa_current_profile();\n\taad.op = OP_SETPROCATTR;\n\taad.info = name;\n\taad.error = -EINVAL;\n\taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n\treturn -EINVAL;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int apparmor_setprocattr(struct task_struct *task, char *name,\n\t\t\t\tvoid *value, size_t size)\n{\n\tstruct common_audit_data sa;\n\tstruct apparmor_audit_data aad = {0,};\n\tchar *command, *largs = NULL, *args = value;\n\tsize_t arg_size;\n\tint error;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\t/* task can only write its own attributes */\n\tif (current != task)\n\t\treturn -EACCES;\n\n\t/* AppArmor requires that the buffer must be null terminated atm */\n\tif (args[size - 1] != '\\0') {\n\t\t/* null terminate */\n\t\tlargs = args = kmalloc(size + 1, GFP_KERNEL);\n\t\tif (!args)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(args, value, size);\n\t\targs[size] = '\\0';\n\t}\n\n\terror = -EINVAL;\n\targs = strim(args);\n\tcommand = strsep(&args, \" \");\n\tif (!args)\n\t\tgoto out;\n\targs = skip_spaces(args);\n\tif (!*args)\n\t\tgoto out;\n\n\targ_size = size - (args - (char *) value);\n\tif (strcmp(name, \"current\") == 0) {\n\t\tif (strcmp(command, \"changehat\") == 0) {\n\t\t\terror = aa_setprocattr_changehat(args, arg_size,\n\t\t\t\t\t\t\t     !AA_DO_TEST);\n\t\telse\n\t\t\tgoto fail;\n\t} else\n\t\t/* only support the \"current\" and \"exec\" process attributes */\n\t\tgoto fail;\n\n\tif (!error)\n\t\terror = size;\nout:\n\tkfree(largs);\n\treturn error;\n\nfail:\n\tsa.type = LSM_AUDIT_DATA_NONE;\n\tsa.aad = &aad;\n\taad.profile = aa_current_profile();\n\taad.op = OP_SETPROCATTR;\n\taad.info = name;\n\taad.error = error = -EINVAL;\n\taa_audit_msg(AUDIT_APPARMOR_DENIED, &sa, NULL);\n\tgoto out;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tfor (j=0; j<nb_items; j++) {\n\t\t\tu8 *udta=NULL;\n\t\t\tu32 udta_size;\n\t\t\tgf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);\n\t\t\tif (!udta) continue;\n\t\t\tif (gf_utf8_is_legal(udta, udta_size)) {\n\t\t\t\tif (first) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tfirst = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\t%s\\n\", (char *) udta);\n\t\t\t}\n\t\t\tgf_free(udta);\n\t\t}\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tfor (j=0; j<nb_items; j++) {\n\t\t\tu8 *udta=NULL;\n\t\t\tu32 udta_size;\n\t\t\tgf_isom_get_user_data(file, track_number, type, uuid, j+1, &udta, &udta_size);\n\t\t\tif (!udta) continue;\n\t\t\tif (udta_size && gf_utf8_is_legal(udta, udta_size)) {\n\t\t\t\tu32 idx;\n\t\t\t\tif (first) {\n\t\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t\t\tfirst = GF_FALSE;\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\t\");\n\t\t\t\tfor (idx=0; idx<udta_size; idx++) {\n\t\t\t\t\tif (!udta[idx]) break;\n\t\t\t\t\tfprintf(stderr, \"%c\", udta[idx]);\n\t\t\t\t}\n\t\t\t\tfprintf(stderr, \"\\n\");\n\t\t\t}\n\t\t\tgf_free(udta);\n\t\t}\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    int\t\tignore_drag_release = TRUE;\n#ifdef FEAT_EVAL\n    int\t\tbreak_ctrl_c = FALSE;\n#endif\n    expand_T\txpc;\n    long\t*b_im_ptr = NULL;\n    cmdline_info_T save_ccline;\n    int\t\tdid_save_ccline = FALSE;\n    int\t\tcmdline_type;\n    int\t\twild_type;\n\n    {\n\t// Use \":lmap\" mappings for search pattern and input().\n\tif (curbuf->b_p_imsearch == B_IMODE_USE_INSERT)\n\t    b_im_ptr = &curbuf->b_p_iminsert;\n\telse\n\t    b_im_ptr = &curbuf->b_p_imsearch;\n\tif (*b_im_ptr == B_IMODE_LMAP)\n\t    State |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(*b_im_ptr == B_IMODE_IM);\n#endif\n\t\tui_cursor_shape();\t// may show different cursor shape\n#endif\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_HAT:\n\t\tcmdline_toggle_langmap(b_im_ptr);\n\t\tgoto cmdline_not_changed;\n\n//\tcase '@':   only in very old vi\n\tcase Ctrl_U:\n\t\t// delete all characters left of the cursor\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n#ifdef HAVE_INPUT_METHOD\n    if (b_im_ptr != NULL && *b_im_ptr != B_IMODE_LMAP)\n\tim_save_status(b_im_ptr);\n    im_set_active(FALSE);\n#endif\n    setmouse();\n#ifdef CURSOR_SHAPE",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "#ifdef FEAT_EVAL\n    int\t\tbreak_ctrl_c = FALSE;\n#endif\n    expand_T\txpc;\n    long\t*b_im_ptr = NULL;\n    buf_T\t*b_im_ptr_buf = NULL;\t// buffer where b_im_ptr is valid\n    cmdline_info_T save_ccline;\n    int\t\tdid_save_ccline = FALSE;\n    int\t\tcmdline_type;\n    int\t\twild_type;\n\n\t// Use \":lmap\" mappings for search pattern and input().\n\tif (curbuf->b_p_imsearch == B_IMODE_USE_INSERT)\n\t    b_im_ptr = &curbuf->b_p_iminsert;\n\telse\n\t    b_im_ptr = &curbuf->b_p_imsearch;\n\tb_im_ptr_buf = curbuf;\n\tif (*b_im_ptr == B_IMODE_LMAP)\n\t    State |= MODE_LANGMAP;\n#ifdef HAVE_INPUT_METHOD\n\tim_set_active(*b_im_ptr == B_IMODE_IM);\n#endif\n\t\tui_cursor_shape();\t// may show different cursor shape\n#endif\n\t\tgoto cmdline_not_changed;\n\n\tcase Ctrl_HAT:\n\t\tcmdline_toggle_langmap(\n\t\t\t\t    buf_valid(b_im_ptr_buf) ? b_im_ptr : NULL);\n\t\tgoto cmdline_not_changed;\n\n//\tcase '@':   only in very old vi\n\tcase Ctrl_U:\n\t\t// delete all characters left of the cursor\n    if (!debug_mode)\n\tmay_trigger_modechanged();\n#endif\n\n#ifdef HAVE_INPUT_METHOD\n    if (b_im_ptr != NULL && buf_valid(b_im_ptr_buf)\n\t\t\t\t\t\t  && *b_im_ptr != B_IMODE_LMAP)\n\tim_save_status(b_im_ptr);\n    im_set_active(FALSE);\n#endif\n    setmouse();\n#ifdef CURSOR_SHAPE",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                                ecma_value_t value_arg, /**< value argument */\n                                lit_magic_string_id_t lit_id) /**< class id */\n{\n  JERRY_ASSERT (container_p != NULL);\n\n  ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (value_arg));\n  }\n\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);\n} /* ecma_op_internal_buffer_append */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                                ecma_value_t key_arg, /**< key argument */\n                                ecma_value_t value_arg, /**< value argument */\n                                lit_magic_string_id_t lit_id) /**< class id */\n{\n  JERRY_ASSERT (container_p != NULL);\n\n  if (lit_id == LIT_MAGIC_STRING_WEAKMAP_UL || lit_id == LIT_MAGIC_STRING_MAP_UL)\n  {\n    ecma_value_t values[] = { ecma_copy_value_if_not_object (key_arg), ecma_copy_value_if_not_object (value_arg) };\n    ecma_collection_append (container_p, values, 2);\n  }\n  else\n  {\n    ecma_collection_push_back (container_p, ecma_copy_value_if_not_object (key_arg));\n  }\n\n  ECMA_CONTAINER_SET_SIZE (container_p, ECMA_CONTAINER_GET_SIZE (container_p) + 1);\n} /* ecma_op_internal_buffer_append */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t}\n\t\tintern->ar_flags &= ~SPL_ARRAY_CLONE_MASK;\n\t\tintern->ar_flags |= flags & SPL_ARRAY_CLONE_MASK;\n\t\tzval_ptr_dtor(&intern->array);\n\t\tALLOC_INIT_ZVAL(intern->array);\n\t\tif (!php_var_unserialize(&intern->array, &p, s + buf_len, &var_hash TSRMLS_CC)) {\n\t\t\tgoto outexcept;\n\t\t}\n\t\tvar_push_dtor(&var_hash, &intern->array);\n\t}\n\tif (*p != ';') {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t}\n\t\tintern->ar_flags &= ~SPL_ARRAY_CLONE_MASK;\n\t\tintern->ar_flags |= flags & SPL_ARRAY_CLONE_MASK;\n\t\tzval_ptr_dtor(&intern->array);\n\t\tALLOC_INIT_ZVAL(intern->array);\n\t\tif (!php_var_unserialize(&intern->array, &p, s + buf_len, &var_hash TSRMLS_CC)\n\t\t\t\t|| (Z_TYPE_P(intern->array) != IS_ARRAY && Z_TYPE_P(intern->array) != IS_OBJECT)) {\n\t\t\tzval_ptr_dtor(&intern->array);\n\t\t\tgoto outexcept;\n\t\t}\n\t\tvar_push_dtor(&var_hash, &intern->array);\n\t}\n\tif (*p != ';') {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    const int crop_width = grads.dimension(2);\n    const int depth = grads.dimension(3);\n\n    grads_image.setZero();\n\n    auto CropAndResizeBackImgPerBox = [&](int start_box, int limit_box) {\n      for (int b = start_box; b < limit_box; ++b) {\n        const float y1 = boxes(b, 0);\n        const float x1 = boxes(b, 1);\n        const float y2 = boxes(b, 2);\n        const float x2 = boxes(b, 3);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    const int crop_width = grads.dimension(2);\n    const int depth = grads.dimension(3);\n\n    grads_image.setZero();\n\n    auto CropAndResizeBackImgPerBox = [&](int64 start_box, int64 limit_box) {\n      for (int b = start_box; b < limit_box; ++b) {\n        const float y1 = boxes(b, 0);\n        const float x1 = boxes(b, 1);\n        const float y2 = boxes(b, 2);\n        const float x2 = boxes(b, 3);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tgf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);\n\n\t/*VVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n\t\n\t/*AV1*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n\n\t/*VPx*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tgf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos);\n\tgf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos);\n\n\t/*VVC*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos);\n\n\t/*AV1*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos);\n\n\t/*VPx*/\n\tgf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tpr_debug(\"dev_name=%s target_idx=%u skb->len=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, skb->len);\n\n\tdevice_lock(&dev->dev);\n\n\tif (!device_is_registered(&dev->dev)) {\n\t\trc = -ENODEV;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tpr_debug(\"dev_name=%s target_idx=%u skb->len=%u\\n\",\n\t\t dev_name(&dev->dev), target_idx, skb->len);\n\n\tdevice_lock(&dev->dev);\n\n\tif (dev->shutting_down) {\n\t\trc = -ENODEV;\n\t\tkfree_skb(skb);\n\t\tgoto error;\n\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "rad_get_vendor_attr(u_int32_t *vendor, const void **data, size_t *len)\n{\n\tstruct vendor_attribute *attr;\n\n\tattr = (struct vendor_attribute *)*data;\n\t*vendor = ntohl(attr->vendor_value);\n\t*data = attr->attrib_data;\n\t*len = attr->attrib_len - 2;\n\n\treturn (attr->attrib_type);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "rad_get_vendor_attr(u_int32_t *vendor, unsigned char *type, const void **data, size_t *len, const void *raw, size_t raw_len)\n{\n\tstruct vendor_attribute *attr;\n\n\tif (raw_len < sizeof(struct vendor_attribute)) {\n\t\treturn -1;\n\t}\n\n\tattr = (struct vendor_attribute *) raw;\n\t*vendor = ntohl(attr->vendor_value);\n\t*type = attr->attrib_type;\n\t*data = attr->attrib_data;\n\t*len = attr->attrib_len - 2;\n\n\tif ((attr->attrib_len + 4) > raw_len) {\n\t\treturn -1;\n\t}\n\n\treturn (attr->attrib_type);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tfiltered = i8042_filter(data, str, serio);\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\tif (likely(port->exists && !filtered))\n\t\tserio_interrupt(serio, data, dfl);\n\n out:\n\treturn IRQ_RETVAL(ret);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tfiltered = i8042_filter(data, str, serio);\n\n\tspin_unlock_irqrestore(&i8042_lock, flags);\n\n\tif (likely(serio && !filtered))\n\t\tserio_interrupt(serio, data, dfl);\n\n out:\n\treturn IRQ_RETVAL(ret);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t */\n\tTAILQ_FOREACH(us, &nss->parse_tree->userspecs, entries) {\n\t    int user_match = userlist_matches(nss->parse_tree, ctx->user.pw,\n\t\t&us->users);\n\t    if (user_match != ALLOW) {\n\t\tif (callback != NULL && user_match != UNSPEC) {\n\t\t    callback(nss->parse_tree, us, user_match, NULL, UNSPEC,\n\t\t\tNULL, UNSPEC, UNSPEC, UNSPEC, cb_data);\n\t\t}\n\t\tcontinue;\n\t    }\n\t\t    if (callback != NULL) {\n\t\t\tcallback(nss->parse_tree, us, user_match, priv,\n\t\t\t    host_match, cs, date_match, runas_match,\n\t\t\t    cmnd_match, cb_data);\n\t\t    }\n\t\t    if (cmnd_match != UNSPEC) {\n\t\t\t/*\n\t\t\t * We take the last match but must process\n\t\t\t * the entire policy for pwcheck == all.\n\t\t\t */\n\t\t\tmatch = cmnd_match;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t */\n\tTAILQ_FOREACH(us, &nss->parse_tree->userspecs, entries) {\n\t    int user_match = userlist_matches(nss->parse_tree, ctx->user.pw,\n\t\t&us->users);\n\t    if (user_match != ALLOW) {\n\t\tif (callback != NULL && user_match == DENY) {\n\t\t    callback(nss->parse_tree, us, user_match, NULL, UNSPEC,\n\t\t\tNULL, UNSPEC, UNSPEC, UNSPEC, cb_data);\n\t\t}\n\t\tcontinue;\n\t    }\n\t\t    if (callback != NULL) {\n\t\t\tcallback(nss->parse_tree, us, user_match, priv,\n\t\t\t    host_match, cs, date_match, runas_match,\n\t\t\t    cmnd_match, cb_data);\n\t\t    }\n\t\t    if (SPECIFIED(cmnd_match)) {\n\t\t\t/*\n\t\t\t * We take the last match but must process\n\t\t\t * the entire policy for pwcheck == all.\n\t\t\t */\n\t\t\tmatch = cmnd_match;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,\n\t\t\t      indx, data, size, 100);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int set_registers(pegasus_t *pegasus, __u16 indx, __u16 size,\n\t\t\t const void *data)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(data, size, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_SET_REGS, PEGASUS_REQT_WRITE, 0,\n\t\t\t      indx, buf, size, 100);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\tkfree(buf);\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "Http::FilterMetadataStatus Context::onResponseMetadata() {\n  if (!wasm_->onResponseMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onResponseMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "Http::FilterMetadataStatus Context::onResponseMetadata() {\n  if (!in_vm_context_created_ || !wasm_->onResponseMetadata_) {\n    return Http::FilterMetadataStatus::Continue;\n  }\n  if (wasm_->onResponseMetadata_(this, id_).u64_ == 0) {\n    return Http::FilterMetadataStatus::Continue;\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteStatus LeakyReluEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  const auto* params =\n      reinterpret_cast<TfLiteLeakyReluParams*>(node->builtin_data);\n  const LeakyReluOpData* data =\n      reinterpret_cast<LeakyReluOpData*>(node->user_data);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteStatus LeakyReluEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const auto* params =\n      reinterpret_cast<TfLiteLeakyReluParams*>(node->builtin_data);\n  const LeakyReluOpData* data =\n      reinterpret_cast<LeakyReluOpData*>(node->user_data);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tbreak;\n\t\tcase LC_LOAD_DYLIB:\n\t\tcase LC_LOAD_WEAK_DYLIB:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"load_dylib\", 0);\n\t\t\tbin->nlibs++;\n\t\t\tif (!parse_dylib(bin, off)){\n\t\t\t\tbprintf (\"Cannot parse dylib\\n\");\n\t\t\t\tbin->nlibs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_INFO:\n\t\tcase LC_DYLD_INFO_ONLY:\n\t\t\t{\n\t\t\tut8 dyldi[sizeof (struct dyld_info_command)] = {0};\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dyld_info\", 0);\n\t\t\tbin->dyld_info = malloc (sizeof(struct dyld_info_command));\n\n\t\t\tif (off + sizeof (struct dyld_info_command) > bin->size){\n\t\t\t\tbprintf (\"Cannot parse dyldinfo\\n\");\n\t\t\t\tfree (bin->dyld_info);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {\n\t\t\t\tfree (bin->dyld_info);\n\t\t\t\tbin->dyld_info = NULL;\n\t\t\t\tbprintf (\"Error: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\t} else {\n\t\t\t\tbin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);\n\t\t\t\tbin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);\n\t\t\t\tbin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);\n\t\t\t\tbin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);\n\t\t\t\tbin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);\n\t\t\t\tbin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);\n\t\t\t\tbin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);\n\t\t\t\tbin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);\n\t\t\t\tbin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);\n\t\t\t\tbin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);\n\t\t\t\tbin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);\n\t\t\t\tbin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_CODE_SIGNATURE:\n\t\t\tparse_signature (bin, off);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tbreak;\n\t\tcase LC_LOAD_DYLIB:\n\t\tcase LC_LOAD_WEAK_DYLIB:\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"load_dylib\", 0);\n\t\t\tbin->nlibs++;\n\t\t\tif (!parse_dylib (bin, off)){\n\t\t\t\tbprintf (\"Cannot parse dylib\\n\");\n\t\t\t\tbin->nlibs--;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_DYLD_INFO:\n\t\tcase LC_DYLD_INFO_ONLY:\n\t\t\t{\n\t\t\tut8 dyldi[sizeof (struct dyld_info_command)] = {0};\n\t\t\tsdb_set (bin->kv, sdb_fmt (0, \"mach0_cmd_%d.cmd\", i), \"dyld_info\", 0);\n\t\t\tbin->dyld_info = calloc (1, sizeof (struct dyld_info_command));\n\t\t\tif (bin->dyld_info) {\n\t\t\t\tif (off + sizeof (struct dyld_info_command) > bin->size){\n\t\t\t\t\tbprintf (\"Cannot parse dyldinfo\\n\");\n\t\t\t\t\tR_FREE (bin->dyld_info);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (r_buf_read_at (bin->b, off, dyldi, sizeof (struct dyld_info_command)) == -1) {\n\t\t\t\t\tfree (bin->dyld_info);\n\t\t\t\t\tbin->dyld_info = NULL;\n\t\t\t\t\tbprintf (\"Error: read (LC_DYLD_INFO) at 0x%08\"PFMT64x\"\\n\", off);\n\t\t\t\t} else {\n\t\t\t\t\tbin->dyld_info->cmd = r_read_ble32 (&dyldi[0], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->cmdsize = r_read_ble32 (&dyldi[4], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->rebase_off = r_read_ble32 (&dyldi[8], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->rebase_size = r_read_ble32 (&dyldi[12], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->bind_off = r_read_ble32 (&dyldi[16], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->bind_size = r_read_ble32 (&dyldi[20], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->weak_bind_off = r_read_ble32 (&dyldi[24], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->weak_bind_size = r_read_ble32 (&dyldi[28], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->lazy_bind_off = r_read_ble32 (&dyldi[32], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->lazy_bind_size = r_read_ble32 (&dyldi[36], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->export_off = r_read_ble32 (&dyldi[40], bin->big_endian);\n\t\t\t\t\tbin->dyld_info->export_size = r_read_ble32 (&dyldi[44], bin->big_endian);\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase LC_CODE_SIGNATURE:\n\t\t\tparse_signature (bin, off);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\trc = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (rc < 0)\n\t\t\t\treturn rc;\n\t\t\tinode->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(inode);\n\t\t\tif (rc == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tea_name = XATTR_NAME_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\trc = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t\tinode->i_ctime = CURRENT_TIME;\n\t\t\tmark_inode_dirty(inode);\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tea_name = XATTR_NAME_POSIX_ACL_DEFAULT;\n\t\tbreak;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void dm9000WritePhyReg(uint8_t address, uint16_t data)\n{\n   //Write PHY register address\n   dm9000WriteReg(DM9000_REG_EPAR, 0x40 | address);\n   //Write register value\n   dm9000WriteReg(DM9000_REG_EPDRL, LSB(data));\n   dm9000WriteReg(DM9000_REG_EPDRH, MSB(data));\n\n   //Start the write operation\n   dm9000WriteReg(DM9000_REG_EPCR, EPCR_EPOS | EPCR_ERPRW);\n   //PHY access is still in progress?\n   while((dm9000ReadReg(DM9000_REG_EPCR) & EPCR_ERRE) != 0)\n   {\n   }\n\n   //Wait 5us minimum\n   usleep(5);\n   //Clear command register\n   dm9000WriteReg(DM9000_REG_EPCR, EPCR_EPOS);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void dm9000WritePhyReg(uint8_t address, uint16_t data)\n{\n   //Write PHY register address\n   dm9000WriteReg(DM9000_EPAR, 0x40 | address);\n   //Write register value\n   dm9000WriteReg(DM9000_EPDRL, LSB(data));\n   dm9000WriteReg(DM9000_EPDRH, MSB(data));\n\n   //Start the write operation\n   dm9000WriteReg(DM9000_EPCR, DM9000_EPCR_EPOS | DM9000_EPCR_ERPRW);\n\n   //PHY access is still in progress?\n   while((dm9000ReadReg(DM9000_EPCR) & DM9000_EPCR_ERRE) != 0)\n   {\n   }\n\n   //Wait 5us minimum\n   usleep(5);\n   //Clear command register\n   dm9000WriteReg(DM9000_EPCR, DM9000_EPCR_EPOS);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    if (new_ts < 0 && *eap->arg == '-')\n    {\n\temsg(_(e_argument_must_be_positive));\n\treturn;\n    }\n    if (new_ts < 0 || new_ts > 9999)\n    {\n\tsemsg(_(e_invalid_argument_str), eap->arg);\n\treturn;\n    }\n    if (new_ts == 0)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    if (new_ts < 0 && *eap->arg == '-')\n    {\n\temsg(_(e_argument_must_be_positive));\n\treturn;\n    }\n    if (new_ts < 0 || new_ts > TABSTOP_MAX)\n    {\n\tsemsg(_(e_invalid_argument_str), eap->arg);\n\treturn;\n    }\n    if (new_ts == 0)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tret = make_NegHints(minor_status, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tsc = create_spnego_ctx();\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tret = make_NegHints(minor_status, mechListMIC);\n\tif (ret != GSS_S_COMPLETE)\n\t\tgoto cleanup;\n\n\tsc = create_spnego_ctx(0);\n\tif (sc == NULL) {\n\t\tret = GSS_S_FAILURE;\n\t\tgoto cleanup;\n\t}\n\tif (put_mech_set(supported_mechSet, &sc->DER_mechTypes) < 0) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\tif (!prev || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\t/* don't alter vm_end if the coredump is running */\n\tif (!prev || !mmget_still_valid(mm) || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tvoid verifyDirectoryPermissions(const string &path) {\n\t\tTRACE_POINT();\n\t\tstruct stat buf;\n\n\t\tif (stat(path.c_str(), &buf) == -1) {\n\t\t\tint e = errno;\n\t\t\tthrow FileSystemException(\"Cannot stat() \" + path, e, path);\n\t\t} else if (buf.st_mode != (S_IFDIR | parseModeString(\"u=rwx,g=rx,o=rx\"))) {\n\t\t\tthrow RuntimeException(\"Tried to reuse existing server instance directory \" +\n\t\t\t\tpath + \", but it has wrong permissions\");\n\t\t} else if (buf.st_uid != geteuid() || buf.st_gid != getegid()) {\n\t\t\t/* The server instance directory is always created by the Watchdog. Its UID/GID never\n\t\t\t * changes because:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tvoid verifyDirectoryPermissions(const string &path, struct stat &buf) {\n\t\tTRACE_POINT();\n\n\t\tif (buf.st_mode != (S_IFDIR | parseModeString(\"u=rwx,g=rx,o=rx\"))) {\n\t\t\tthrow RuntimeException(\"Tried to reuse existing server instance directory \" +\n\t\t\t\tpath + \", but it has wrong permissions\");\n\t\t} else if (buf.st_uid != geteuid() || buf.st_gid != getegid()) {\n\t\t\t/* The server instance directory is always created by the Watchdog. Its UID/GID never\n\t\t\t * changes because:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tprog = __bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\n\tatomic_inc(&prog->aux->refcnt);\n\tfdput(f);\n\n\treturn prog;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tprog = __bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\n\tprog = bpf_prog_inc(prog);\n\tfdput(f);\n\n\treturn prog;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\tif (vapic_addr)\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\telse\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tif (vapic_addr) {\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t\t\t\t&vcpu->arch.apic->vapic_cache,\n\t\t\t\t\tvapic_addr, sizeof(u32)))\n\t\t\treturn -EINVAL;\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t} else {\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t}\n\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tst = sss_se05x_key_object_get_handle(&k_object, key_id);\n\t\tif (st == kStatus_SSS_Success)\n\t\t\tsss_se05x_key_store_erase_key(se050_kstore, &k_object);\n\t}\n\n\tcrypto_bignum_free(s->e);\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->n);\n\tcrypto_bignum_free(s->p);\n\tcrypto_bignum_free(s->q);\n\tcrypto_bignum_free(s->qp);\n\tcrypto_bignum_free(s->dp);\n\tcrypto_bignum_free(s->dq);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tst = sss_se05x_key_object_get_handle(&k_object, key_id);\n\t\tif (st == kStatus_SSS_Success)\n\t\t\tsss_se05x_key_store_erase_key(se050_kstore, &k_object);\n\t}\n\n\tcrypto_bignum_free(&s->e);\n\tcrypto_bignum_free(&s->d);\n\tcrypto_bignum_free(&s->n);\n\tcrypto_bignum_free(&s->p);\n\tcrypto_bignum_free(&s->q);\n\tcrypto_bignum_free(&s->qp);\n\tcrypto_bignum_free(&s->dp);\n\tcrypto_bignum_free(&s->dq);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n  GHashTable *modules = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  g_autofree char *modules_data = NULL;\n  g_autoptr(GError) error = NULL;\n  char *start, *end;\n  \n  if (!g_file_get_contents (\"/proc/modules\", &modules_data, NULL, &error))\n    {\n      g_info (\"Failed to read /proc/modules: %s\", error->message);\n      return modules;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n  GHashTable *modules = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n  g_autofree char *modules_data = NULL;\n  g_autoptr(GError) error = NULL;\n  char *start, *end;\n\n  if (!g_file_get_contents (\"/proc/modules\", &modules_data, NULL, &error))\n    {\n      g_info (\"Failed to read /proc/modules: %s\", error->message);\n      return modules;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4)\n            withvalues = 1;\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n\n    /* Handle variant without <count> argument. Reply with simple bulk string */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    if (c->argc >= 3) {\n        if (getLongFromObjectOrReply(c,c->argv[2],&l,NULL) != C_OK) return;\n        if (c->argc > 4 || (c->argc == 4 && strcasecmp(c->argv[3]->ptr,\"withvalues\"))) {\n            addReplyErrorObject(c,shared.syntaxerr);\n            return;\n        } else if (c->argc == 4) {\n            withvalues = 1;\n            if (l < LONG_MIN/2 || l > LONG_MAX/2) {\n                addReplyError(c,\"value is out of range\");\n                return;\n            }\n        }\n        hrandfieldWithCountCommand(c, l, withvalues);\n        return;\n    }\n\n    /* Handle variant without <count> argument. Reply with simple bulk string */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tswitch (advice) {\n\tcase MADV_HUGEPAGE:\n\t\t/*\n\t\t * Be somewhat over-protective like KSM for now!\n\t\t */\n\t\tif (*vm_flags & (VM_HUGEPAGE |\n\t\t\t\t VM_SHARED   | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |\n\t\t\t\t VM_MIXEDMAP | VM_SAO))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_NOHUGEPAGE;\n\t\t*vm_flags |= VM_HUGEPAGE;\n\t\t/*\n\t\t * If the vma become good for khugepaged to scan,\n\t\tbreak;\n\tcase MADV_NOHUGEPAGE:\n\t\t/*\n\t\t * Be somewhat over-protective like KSM for now!\n\t\t */\n\t\tif (*vm_flags & (VM_NOHUGEPAGE |\n\t\t\t\t VM_SHARED   | VM_MAYSHARE   |\n\t\t\t\t VM_PFNMAP   | VM_IO      | VM_DONTEXPAND |\n\t\t\t\t VM_RESERVED | VM_HUGETLB | VM_INSERTPAGE |\n\t\t\t\t VM_MIXEDMAP | VM_SAO))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_HUGEPAGE;\n\t\t*vm_flags |= VM_NOHUGEPAGE;\n\t\t/*\n\t\t * Setting VM_NOHUGEPAGE will prevent khugepaged from scanning",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tswitch (advice) {\n\tcase MADV_HUGEPAGE:\n\t\t/*\n\t\t * Be somewhat over-protective like KSM for now!\n\t\t */\n\t\tif (*vm_flags & (VM_HUGEPAGE | VM_NO_THP))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_NOHUGEPAGE;\n\t\t*vm_flags |= VM_HUGEPAGE;\n\t\t/*\n\t\t * If the vma become good for khugepaged to scan,\n\t\tbreak;\n\tcase MADV_NOHUGEPAGE:\n\t\t/*\n\t\t * Be somewhat over-protective like KSM for now!\n\t\t */\n\t\tif (*vm_flags & (VM_NOHUGEPAGE | VM_NO_THP))\n\t\t\treturn -EINVAL;\n\t\t*vm_flags &= ~VM_HUGEPAGE;\n\t\t*vm_flags |= VM_NOHUGEPAGE;\n\t\t/*\n\t\t * Setting VM_NOHUGEPAGE will prevent khugepaged from scanning",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\t\telse if (avail < 4 || utf8_lead(str[pos + 3]))\n\t\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t\telse\n\t\t\t\t\t\tMB_FAILURE(pos, 4);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthis_char = ((c & 0x07) << 18) | ((str[pos + 1] & 0x3f) << 12) | ((str[pos + 2] & 0x3f) << 6) | (str[pos + 3] & 0x3f);\n\t\t\t\tif (this_char < 0x10000 || this_char > 0x10FFFF) { /* non-shortest form or outside range */\n\t\t\t\t\tMB_FAILURE(pos, 4);\n\t\t\t\t}\n\t\t\t\tpos += 4;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\t\telse if (avail < 4 || utf8_lead(str[pos + 3]))\n\t\t\t\t\t\tMB_FAILURE(pos, 3);\n\t\t\t\t\telse\n\t\t\t\t\t\tMB_FAILURE(pos, 4);\n\t\t\t\t}\n\n\t\t\t\tthis_char = ((c & 0x07) << 18) | ((str[pos + 1] & 0x3f) << 12) | ((str[pos + 2] & 0x3f) << 6) | (str[pos + 3] & 0x3f);\n\t\t\t\tif (this_char < 0x10000 || this_char > 0x10FFFF) { /* non-shortest form or outside range */\n\t\t\t\t\tMB_FAILURE(pos, 4);\n\t\t\t\t}\n\t\t\t\tpos += 4;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t *\n\t\t * The set-user-ID and set-group-ID bits of a file will be\n\t\t * cleared upon successful return from chown()\n\t\t */\n\t\tif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\n\t\t    !inode_capable(VFS_I(ip), CAP_FSETID))\n\t\t\tip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\n\n\t\t/*\n\t\t * Change the ownerships and register quota modifications\n\t\t * in the transaction.",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t *\n\t\t * The set-user-ID and set-group-ID bits of a file will be\n\t\t * cleared upon successful return from chown()\n\t\t */\n\t\tif ((ip->i_d.di_mode & (S_ISUID|S_ISGID)) &&\n\t\t    !capable_wrt_inode_uidgid(VFS_I(ip), CAP_FSETID))\n\t\t\tip->i_d.di_mode &= ~(S_ISUID|S_ISGID);\n\n\t\t/*\n\t\t * Change the ownerships and register quota modifications\n\t\t * in the transaction.",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\t\tvoid *buf,\n\t\t\t\t\tpj_size_t *length,\n\t\t\t\t\tunsigned nack_cnt,\n\t\t\t\t\tconst pjmedia_rtcp_fb_nack nack[])\n{\n    pjmedia_rtcp_common *hdr;\n    pj_uint8_t *p;\n    unsigned len, i;\n\n    PJ_ASSERT_RETURN(session && buf && length && nack_cnt && nack, PJ_EINVAL);\n\n    len = (3 + nack_cnt) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP-FB NACK header */\n    hdr = (pjmedia_rtcp_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_rr_pkt.common,  sizeof(*hdr));\n    hdr->pt = RTCP_RTPFB;\n    hdr->count = 1; /* FMT = 1 */\n    hdr->length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Build RTCP-FB NACK FCI */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < nack_cnt; ++i) {\n\tpj_uint16_t val;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\t\tvoid *buf,\n\t\t\t\t\tpj_size_t *length,\n\t\t\t\t\tunsigned nack_cnt,\n\t\t\t\t\tconst pjmedia_rtcp_fb_nack nack[])\n{\n    pjmedia_rtcp_fb_common *hdr;\n    pj_uint8_t *p;\n    unsigned len, i;\n\n    PJ_ASSERT_RETURN(session && buf && length && nack_cnt && nack, PJ_EINVAL);\n\n    len = (3 + nack_cnt) * 4;\n    if (len > *length)\n\treturn PJ_ETOOSMALL;\n\n    /* Build RTCP-FB NACK header */\n    hdr = (pjmedia_rtcp_fb_common*)buf;\n    pj_memcpy(hdr, &session->rtcp_fb_com, sizeof(*hdr));\n    hdr->rtcp_common.pt = RTCP_RTPFB;\n    hdr->rtcp_common.count = 1; /* FMT = 1 */\n    hdr->rtcp_common.length = pj_htons((pj_uint16_t)(len/4 - 1));\n\n    /* Build RTCP-FB NACK FCI */\n    p = (pj_uint8_t*)hdr + sizeof(*hdr);\n    for (i = 0; i < nack_cnt; ++i) {\n\tpj_uint16_t val;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static const char *jsi_evalprint(Jsi_Value *v)\n{\n    static char buf[100];\n    if (!v)\n        return \"nil\";\n    if (v->vt == JSI_VT_NUMBER) {\n        snprintf(buf, 100, \"NUM:%\" JSI_NUMGFMT \" \", v->d.num);\n    } else if (v->vt == JSI_VT_BOOL) {\n        snprintf(buf, 100, \"BOO:%d\", v->d.val);\n    } else if (v->vt == JSI_VT_STRING) {\n        snprintf(buf, 100, \"STR:'%s'\", v->d.s.str);\n    } else if (v->vt == JSI_VT_VARIABLE) {\n        snprintf(buf, 100, \"VAR:%p\", v->d.lval);\n    } else if (v->vt == JSI_VT_NULL) {\n        snprintf(buf, 100, \"NULL\");\n    } else if (v->vt == JSI_VT_OBJECT) {\n        snprintf(buf, 100, \"OBJ:%p\", v->d.obj);\n    } else if (v->vt == JSI_VT_UNDEF) {\n        snprintf(buf, 100, \"UNDEFINED\");\n    }\n    return buf;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static const char *jsi_evalprint(Jsi_Value *v)\n{\n    static char buf[JSI_MAX_NUMBER_STRING];\n    if (!v)\n        return \"nil\";\n    if (v->vt == JSI_VT_NUMBER) {\n        snprintf(buf, sizeof(buf), \"NUM:%\" JSI_NUMGFMT \" \", v->d.num);\n    } else if (v->vt == JSI_VT_BOOL) {\n        snprintf(buf, sizeof(buf), \"BOO:%d\", v->d.val);\n    } else if (v->vt == JSI_VT_STRING) {\n        snprintf(buf, sizeof(buf), \"STR:'%s'\", v->d.s.str);\n    } else if (v->vt == JSI_VT_VARIABLE) {\n        snprintf(buf, sizeof(buf), \"VAR:%p\", v->d.lval);\n    } else if (v->vt == JSI_VT_NULL) {\n        snprintf(buf, sizeof(buf), \"NULL\");\n    } else if (v->vt == JSI_VT_OBJECT) {\n        snprintf(buf, sizeof(buf), \"OBJ:%p\", v->d.obj);\n    } else if (v->vt == JSI_VT_UNDEF) {\n        snprintf(buf, sizeof(buf), \"UNDEFINED\");\n    }\n    return buf;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        int          GetU8    (int nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n            if ( nPos < 0 || nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            return m_sFile[ nPos ];",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        int          GetU8    (const unsigned int& nPos, bool *pbSuccess)\n        {\n            //*pbSuccess = true;\n            if ( nPos >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            return m_sFile[ nPos ];",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\n\tseq_puts(m, \"key:\");\n\tseq_puts(m, key->description);\n\tif (key_is_instantiated(key))\n\t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\n\tseq_puts(m, \"key:\");\n\tseq_puts(m, key->description);\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \" pid:%d ci:%zu\", rka->pid, rka->callout_len);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    const CompressedComponentMetadata& metadata =\n        compressed.component_metadata(i);\n    if (DataTypeCanUseMemcpy(metadata.dtype())) {\n      out->emplace_back(metadata.dtype(), metadata.tensor_shape());\n      TensorBuffer* buffer = DMAHelper::buffer(&out->back());\n      iov[i].iov_base = buffer->data();\n      iov[i].iov_len = buffer->size();\n    } else {\n      // Allocate an empty Tensor. We will fill it out later after\n      // uncompressing into the tensor_proto_str.\n      out->emplace_back();\n      tensor_proto_strs.emplace_back();",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    const CompressedComponentMetadata& metadata =\n        compressed.component_metadata(i);\n    if (DataTypeCanUseMemcpy(metadata.dtype())) {\n      out->emplace_back(metadata.dtype(), metadata.tensor_shape());\n      TensorBuffer* buffer = DMAHelper::buffer(&out->back());\n      if (buffer) {\n        iov[i].iov_base = buffer->data();\n        iov[i].iov_len = buffer->size();\n      } else {\n        iov[i].iov_base = nullptr;\n        iov[i].iov_len = 0;\n      }\n    } else {\n      // Allocate an empty Tensor. We will fill it out later after\n      // uncompressing into the tensor_proto_str.\n      out->emplace_back();\n      tensor_proto_strs.emplace_back();",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t interprocess_token)\n{\n    OM_uint32 maj;\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)context_handle;\n\n    /* We don't currently support exporting partially established contexts. */\n    if (!ctx->established)\n        return GSS_S_UNAVAILABLE;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "iakerb_gss_export_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t interprocess_token)\n{\n    OM_uint32 maj;\n    iakerb_ctx_id_t ctx = (iakerb_ctx_id_t)*context_handle;\n\n    /* We don't currently support exporting partially established contexts. */\n    if (!ctx->established)\n        return GSS_S_UNAVAILABLE;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  int32_t input_offset = -input->params.zero_point;\n  int32_t filter_offset = -filter->params.zero_point;\n  int32_t output_offset = output->params.zero_point;\n  // Only the Pie path supports quantized models and float inputs/outputs.\n  if (input->type == kTfLiteFloat32) {\n    TfLiteTensor* input_quantized = GetTemporary(context, node, /*index=*/0);\n    TfLiteTensor* scaling_factors = GetTemporary(context, node, /*index=*/1);\n    TfLiteTensor* accum_scratch = GetTemporary(context, node, /*index=*/2);\n    TfLiteTensor* input_offsets = GetTemporary(context, node, /*index=*/3);\n    TfLiteTensor* row_sums = GetTemporary(context, node, /*index=*/4);\n    return EvalHybrid(context, node, params, data, input, filter, bias,\n                      input_quantized, scaling_factors, accum_scratch, row_sums,\n                      input_offsets, output);\n  } else {\n    FullyConnectedParams op_params;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  int32_t input_offset = -input->params.zero_point;\n  int32_t filter_offset = -filter->params.zero_point;\n  int32_t output_offset = output->params.zero_point;\n  // Only the Pie path supports quantized models and float inputs/outputs.\n  if (input->type == kTfLiteFloat32) {\n    TfLiteTensor* input_quantized;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/0,\n                                                &input_quantized));\n    TfLiteTensor* scaling_factors;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, /*index=*/1,\n                                                &scaling_factors));\n    TfLiteTensor* accum_scratch;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, /*index=*/2, &accum_scratch));\n    TfLiteTensor* input_offsets;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, /*index=*/3, &input_offsets));\n    TfLiteTensor* row_sums;\n    TF_LITE_ENSURE_OK(context,\n                      GetTemporarySafe(context, node, /*index=*/4, &row_sums));\n    return EvalHybrid(context, node, params, data, input, filter, bias,\n                      input_quantized, scaling_factors, accum_scratch, row_sums,\n                      input_offsets, output);\n  } else {\n    FullyConnectedParams op_params;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ripng_print(netdissect_options *ndo, const u_char *dat, unsigned int length)\n{\n\tregister const struct rip6 *rp = (const struct rip6 *)dat;\n\tregister const struct netinfo6 *ni;\n\tregister u_int amt;\n\tregister u_int i;\n\tint j;\n\tint trunc;\n\n\tif (ndo->ndo_snapend < dat)\n\t\treturn;\n\tamt = ndo->ndo_snapend - dat;\n\ti = min(length, amt);\n\tif (i < (sizeof(struct rip6) - sizeof(struct netinfo6)))\n\t\treturn;\n\ti -= (sizeof(struct rip6) - sizeof(struct netinfo6));\n\n\tswitch (rp->rip6_cmd) {\n\n\tcase RIP6_REQUEST:\n\t\tj = length / sizeof(*ni);\n\t\tif (j == 1\n\t\t    &&  rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6\n\t\t    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {\n\t\t\tND_PRINT((ndo, \" ripng-req dump\"));\n\t\t\tbreak;\n\t\t}\n\t\tif (j * sizeof(*ni) != length - 4)\n\t\t\tND_PRINT((ndo, \" ripng-req %d[%u]:\", j, length));\n\t\telse\n\t\t\tND_PRINT((ndo, \" ripng-req %d:\", j));\n\t\ttrunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);\n\t\tfor (ni = rp->rip6_nets; i >= sizeof(*ni);\n\t\t    i -= sizeof(*ni), ++ni) {\n\t\t\tif (ndo->ndo_vflag > 1)\n\t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\trip6_entry_print(ndo, ni, 0);\n\t\t}\n\t\tbreak;\n\tcase RIP6_RESPONSE:\n\t\tj = length / sizeof(*ni);\n\t\tif (j * sizeof(*ni) != length - 4)\n\t\t\tND_PRINT((ndo, \" ripng-resp %d[%u]:\", j, length));\n\t\telse\n\t\t\tND_PRINT((ndo, \" ripng-resp %d:\", j));\n\t\ttrunc = ((i / sizeof(*ni)) * sizeof(*ni) != i);\n\t\tfor (ni = rp->rip6_nets; i >= sizeof(*ni);\n\t\t    i -= sizeof(*ni), ++ni) {\n\t\t\tif (ndo->ndo_vflag > 1)\n\t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\trip6_entry_print(ndo, ni, ni->rip6_metric);\n\t\t}\n\t\tif (trunc)\n\t\t\tND_PRINT((ndo, \"[|ripng]\"));\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \" ripng-%d ?? %u\", rp->rip6_cmd, length));\n\t\tbreak;\n\t}\n\tif (rp->rip6_vers != RIP6_VERSION)\n\t\tND_PRINT((ndo, \" [vers %d]\", rp->rip6_vers));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ripng_print(netdissect_options *ndo, const u_char *dat, unsigned int length)\n{\n\tregister const struct rip6 *rp = (const struct rip6 *)dat;\n\tregister const struct netinfo6 *ni;\n\tunsigned int length_left;\n\tu_int j;\n\n\tND_TCHECK(rp->rip6_cmd);\n\tswitch (rp->rip6_cmd) {\n\n\tcase RIP6_REQUEST:\n\t\tlength_left = length;\n\t\tif (length_left < (sizeof(struct rip6) - sizeof(struct netinfo6)))\n\t\t\tgoto trunc;\n\t\tlength_left -= (sizeof(struct rip6) - sizeof(struct netinfo6));\n \t\tj = length_left / sizeof(*ni);\n\t\tif (j == 1) {\n\t\t\tND_TCHECK(rp->rip6_nets);\n\t\t\tif (rp->rip6_nets->rip6_metric == HOPCNT_INFINITY6\n\t\t\t    &&  IN6_IS_ADDR_UNSPECIFIED(&rp->rip6_nets->rip6_dest)) {\n\t\t\t\tND_PRINT((ndo, \" ripng-req dump\"));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j * sizeof(*ni) != length_left)\n\t\t\tND_PRINT((ndo, \" ripng-req %u[%u]:\", j, length));\n\t\telse\n\t\t\tND_PRINT((ndo, \" ripng-req %u:\", j));\n\t\tfor (ni = rp->rip6_nets; length_left >= sizeof(*ni);\n\t\t    length_left -= sizeof(*ni), ++ni) {\n\t\t\tND_TCHECK(*ni);\n\t\t\tif (ndo->ndo_vflag > 1)\n\t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\trip6_entry_print(ndo, ni, 0);\n\t\t}\n\t\tif (length_left != 0)\n\t\t\tgoto trunc;\n\t\tbreak;\n\tcase RIP6_RESPONSE:\n\t\tlength_left = length;\n\t\tif (length_left < (sizeof(struct rip6) - sizeof(struct netinfo6)))\n\t\t\tgoto trunc;\n\t\tlength_left -= (sizeof(struct rip6) - sizeof(struct netinfo6));\n\t\tj = length_left / sizeof(*ni);\n\t\tif (j * sizeof(*ni) != length_left)\n\t\t\tND_PRINT((ndo, \" ripng-resp %d[%u]:\", j, length));\n\t\telse\n\t\t\tND_PRINT((ndo, \" ripng-resp %d:\", j));\n\t\tfor (ni = rp->rip6_nets; length_left >= sizeof(*ni);\n\t\t    length_left -= sizeof(*ni), ++ni) {\n\t\t\tND_TCHECK(*ni);\n\t\t\tif (ndo->ndo_vflag > 1)\n\t\t\t\tND_PRINT((ndo, \"\\n\\t\"));\n\t\t\telse\n\t\t\t\tND_PRINT((ndo, \" \"));\n\t\t\trip6_entry_print(ndo, ni, ni->rip6_metric);\n\t\t}\n\t\tif (length_left != 0)\n\t\t\tgoto trunc;\n\t\tbreak;\n\tdefault:\n\t\tND_PRINT((ndo, \" ripng-%d ?? %u\", rp->rip6_cmd, length));\n\t\tbreak;\n\t}\n\tND_TCHECK(rp->rip6_vers);\n\tif (rp->rip6_vers != RIP6_VERSION)\n\t\tND_PRINT((ndo, \" [vers %d]\", rp->rip6_vers));\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"[|ripng]\"));\n\treturn;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len - JP2_BOX_HDRLEN(false))) {\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (dataflag) {\n\t\tif (jas_stream_copy(out, tmpstream, box->len -\n\t\t  JP2_BOX_HDRLEN(false))) {\n\t\t\tjas_eprintf(\"cannot copy box data\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tjas_stream_close(tmpstream);\n\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tcan_unload = FALSE;\n\t\tbreak;\n\t    }\n    }\n    if (!can_unload)\n\tsemsg(_(e_attempt_to_delete_buffer_that_is_in_use_str), buf->b_fname);\n    return can_unload;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tcan_unload = FALSE;\n\t\tbreak;\n\t    }\n    }\n    if (!can_unload)\n    {\n\tchar_u *fname = buf->b_fname != NULL ? buf->b_fname : buf->b_ffname;\n\n\tsemsg(_(e_attempt_to_delete_buffer_that_is_in_use_str),\n\t\t\t\tfname != NULL ? fname : (char_u *)\"[No Name]\");\n    }\n    return can_unload;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\to2 = 6 + n->offset; /* Start of interesting data */\n\tif ((o2 + 10 < o2) || (o2 + 10 < 10) || (o2 + 10 > buf_size)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\n\tcase olympusV2:\n\t\t/* Olympus S760, S770 */\n\t\tdatao = o2;\n\t\to2 += 8;\n\t\tif ((o2 + 4 < o2) || (o2 + 4 < 4) || (o2 + 4 > buf_size)) return;\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Olympus maker note v2 (0x%02x, %02x, %02x, %02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3]);\n\n\t\tif ((buf[o2] == 'I') && (buf[o2 + 1] == 'I'))\n\t\t}\n\t\tbreak;\n\n\tcase nikonV2:\n\t\to2 += 6;\n\t\tif ((o2 + 12 < o2) || (o2 + 12 < 12) || (o2 + 12 > buf_size)) return;\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Nikon maker note v2 (0x%02x, %02x, %02x, \"\n\t\t\t\"%02x, %02x, %02x, %02x, %02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3],\n\t\t\tbuf[o2 + 4], buf[o2 + 5], buf[o2 + 6], buf[o2 + 7]);\n\t\t\t\"Unknown Olympus variant %i.\", n->version);\n\t\treturn;\n\t}\n\n\t/* Sanity check the offset */\n\tif ((o2 + 2 < o2) || (o2 + 2 < 2) || (o2 + 2 > buf_size)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\n\t/* Parse all c entries, storing ones that are successfully parsed */\n\ttcount = 0;\n\tfor (i = c, o = o2; i; --i, o += 12) {\n\t\tsize_t s;\n\t\tif ((o + 12 < o) || (o + 12 < 12) || (o + 12 > buf_size)) {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteOlympus\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t\t\t    \"0x%x %d %ld*(%d)\",\n\t\t    n->entries[tcount].tag,\n\t\t    n->entries[tcount].format,\n\t\t    n->entries[tcount].components,\n\t\t    (int)exif_format_get_size(n->entries[tcount].format)); */\n\n\t    /*\n\t     * Size? If bigger than 4 bytes, the actual data is not\n\t     * in the entry but somewhere else (offset).\n\t     */\n\t    s = exif_format_get_size (n->entries[tcount].format) *\n\t\t\t\t/* Some Sanyo models (e.g. VPC-C5, C40) suffer from a bug when\n\t\t\t\t * writing the offset for the MNOTE_OLYMPUS_TAG_THUMBNAILIMAGE\n\t\t\t\t * tag in its MakerNote. The offset is actually the absolute\n\t\t\t\t * position in the file instead of the position within the IFD.\n\t\t\t\t */\n\t\t\t    if (dataofs + s > buf_size && n->version == sanyoV1) {\n\t\t\t\t\t/* fix pointer */\n\t\t\t\t\tdataofs -= datao + 6;\n\t\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\t  \"ExifMnoteOlympus\",\n\t\t\t\t\t\t  \"Inconsistent thumbnail tag offset; attempting to recover\");\n\t\t\t    }\n#endif\n\t\t\t}\n\t\t\tif ((dataofs + s < dataofs) || (dataofs + s < s) || \n\t\t\t    (dataofs + s > buf_size)) {\n\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t  \"ExifMnoteOlympus\",\n\t\t\t\t\t  \"Tag data past end of buffer (%u > %u)\",\n\t\t\t\t\t  (unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\to2 = 6 + n->offset; /* Start of interesting data */\n\tif (CHECKOVERFLOW(o2,buf_size,10)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteDataOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\n\tcase olympusV2:\n\t\t/* Olympus S760, S770 */\n\t\tdatao = o2;\n\t\to2 += 8;\n\t\tif (CHECKOVERFLOW(o2,buf_size,4)) return;\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Olympus maker note v2 (0x%02x, %02x, %02x, %02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3]);\n\n\t\tif ((buf[o2] == 'I') && (buf[o2 + 1] == 'I'))\n\t\t}\n\t\tbreak;\n\n\tcase nikonV2:\n\t\to2 += 6;\n\t\tif (CHECKOVERFLOW(o2,buf_size,12)) return;\n\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG, \"ExifMnoteDataOlympus\",\n\t\t\t\"Parsing Nikon maker note v2 (0x%02x, %02x, %02x, \"\n\t\t\t\"%02x, %02x, %02x, %02x, %02x)...\",\n\t\t\tbuf[o2 + 0], buf[o2 + 1], buf[o2 + 2], buf[o2 + 3],\n\t\t\tbuf[o2 + 4], buf[o2 + 5], buf[o2 + 6], buf[o2 + 7]);\n\t\t\t\"Unknown Olympus variant %i.\", n->version);\n\t\treturn;\n\t}\n\n\t/* Sanity check the offset */\n\tif (CHECKOVERFLOW(o2,buf_size,2)) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t  \"ExifMnoteOlympus\", \"Short MakerNote\");\n\t\treturn;\n\t}\n\n\n\t/* Parse all c entries, storing ones that are successfully parsed */\n\ttcount = 0;\n\tfor (i = c, o = o2; i; --i, o += 12) {\n\t\tsize_t s;\n\t\tif (CHECKOVERFLOW(o, buf_size, 12)) {\n\t\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA,\n\t\t\t\t  \"ExifMnoteOlympus\", \"Short MakerNote\");\n\t\t\tbreak;\n\t\t}\n\n\t\t    n->entries[tcount].tag,\n\t\t    n->entries[tcount].format,\n\t\t    n->entries[tcount].components,\n\t\t    (int)exif_format_get_size(n->entries[tcount].format)); */\n\n\t    /* Check if we overflow the multiplication. Use buf_size as the max size for integer overflow detection,\n\t     * we will check the buffer sizes closer later. */\n\t    if (exif_format_get_size (n->entries[tcount].format) &&\n\t\tbuf_size / exif_format_get_size (n->entries[tcount].format) < n->entries[tcount].components\n\t    ) {\n\t\texif_log (en->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifMnoteOlympus\", \"Tag size overflow detected (%u * %lu)\", exif_format_get_size (n->entries[tcount].format), n->entries[tcount].components);\n\t\tcontinue;\n\t    }\n\t    /*\n\t     * Size? If bigger than 4 bytes, the actual data is not\n\t     * in the entry but somewhere else (offset).\n\t     */\n\t    s = exif_format_get_size (n->entries[tcount].format) *\n\t\t\t\t/* Some Sanyo models (e.g. VPC-C5, C40) suffer from a bug when\n\t\t\t\t * writing the offset for the MNOTE_OLYMPUS_TAG_THUMBNAILIMAGE\n\t\t\t\t * tag in its MakerNote. The offset is actually the absolute\n\t\t\t\t * position in the file instead of the position within the IFD.\n\t\t\t\t */\n\t\t\t    if (dataofs > (buf_size - s) && n->version == sanyoV1) {\n\t\t\t\t\t/* fix pointer */\n\t\t\t\t\tdataofs -= datao + 6;\n\t\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t\t  \"ExifMnoteOlympus\",\n\t\t\t\t\t\t  \"Inconsistent thumbnail tag offset; attempting to recover\");\n\t\t\t    }\n#endif\n\t\t\t}\n\t\t\tif (CHECKOVERFLOW(dataofs, buf_size, s)) {\n\t\t\t\texif_log (en->log, EXIF_LOG_CODE_DEBUG,\n\t\t\t\t\t  \"ExifMnoteOlympus\",\n\t\t\t\t\t  \"Tag data past end of buffer (%u > %u)\",\n\t\t\t\t\t  (unsigned)(dataofs + s), buf_size);\n\t\t\t\tcontinue;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    int\t\tcc = *name_end;\n    char_u\t*p = lvp->ll_name;\n    int\t\tret = OK;\n    size_t\tlen;\n    char_u\t*buf;\n    isntype_T\tisn = ISN_EXEC;\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    // Cannot use :lockvar and :unlockvar on local variables.\n    if (p[1] != ':')\n    {\n\tchar_u *end = find_name_end(p, NULL, NULL, FNE_CHECK_START);\n    buf = alloc(len);\n    if (buf == NULL)\n\tret = FAIL;\n    else\n    {\n\tchar *cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\";\n\n\tif (deep < 0)\n\t    vim_snprintf((char *)buf, len, \"%s! %s\", cmd, p);\n\telse\n\t    vim_snprintf((char *)buf, len, \"%s %d %s\", cmd, deep, p);\n\tret = generate_EXEC_copy(cctx, isn, buf);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    char_u\t*p = lvp->ll_name;\n    int\t\tret = OK;\n    size_t\tlen;\n    char_u\t*buf;\n    isntype_T\tisn = ISN_EXEC;\n    char\t*cmd = eap->cmdidx == CMD_lockvar ? \"lockvar\" : \"unlockvar\";\n\n    if (cctx->ctx_skip == SKIP_YES)\n\treturn OK;\n\n    if (*p == NUL)\n    {\n\tsemsg(_(e_argument_required_for_str), cmd);\n\treturn FAIL;\n    }\n\n    // Cannot use :lockvar and :unlockvar on local variables.\n    if (p[1] != ':')\n    {\n\tchar_u *end = find_name_end(p, NULL, NULL, FNE_CHECK_START);\n    len = name_end - p + 20;\n    buf = alloc(len);\n    if (buf == NULL)\n\tret = FAIL;\n    else\n    {\n\tif (deep < 0)\n\t    vim_snprintf((char *)buf, len, \"%s! %s\", cmd, p);\n\telse\n\t    vim_snprintf((char *)buf, len, \"%s %d %s\", cmd, deep, p);\n\tret = generate_EXEC_copy(cctx, isn, buf);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "cssp_read_tsrequest(STREAM token, STREAM pubkey)\n{\n\tSTREAM s;\n\tint length;\n\tint tagval;\n\n\ts = tcp_recv(NULL, 4);\n\n\tif (s == NULL)\n\t\treturn False;\n\t\tlength = (s->p[2] << 8) | s->p[3];\n\telse\n\t\treturn False;\n\n\t// receive the remainings of message\n\ts = tcp_recv(s, length);\n\n\t// parse the response and into nego token\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\treturn False;\n\n\t// version [0]\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\treturn False;\n\tin_uint8s(s, length);\n\n\t// negoToken [1]\n\tif (token)\n\t{\n\t\t\treturn False;\n\n\t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)\n\t\t\treturn False;\n\n\t\ttoken->end = token->p = token->data;\n\t\tout_uint8p(token, s->p, length);\n\t\ts_mark_end(token);\n\t}\n\n\t// pubKey [3]",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "cssp_read_tsrequest(STREAM token, STREAM pubkey)\n{\n\tSTREAM s;\n\tint length;\n\tint tagval;\n\tstruct stream packet;\n\n\ts = tcp_recv(NULL, 4);\n\n\tif (s == NULL)\n\t\treturn False;\n\telse\n\t\treturn False;\n\n\t// receive the remainings of message\n\ts = tcp_recv(s, length);\n\tpacket = *s;\n\n\t// parse the response and into nego token\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED))\n\t\treturn False;\n\n\t// version [0]\n\tif (!ber_in_header(s, &tagval, &length) ||\n\t    tagval != (BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0))\n\t\treturn False;\n\n\tif (!s_check_rem(s, length))\n\t{\n\t\t rdp_protocol_error(\"cssp_read_tsrequest(), consume of version from stream would overrun\",\n\t\t\t\t    &packet);\n\t}\n\tin_uint8s(s, length);\n\n\t// negoToken [1]\n\tif (token)\n\t{\n\t\t\treturn False;\n\n\t\tif (!ber_in_header(s, &tagval, &length) || tagval != BER_TAG_OCTET_STRING)\n\t\t\treturn False;\n\n\t\tif (!s_check_rem(s, length))\n\t\t{\n\t\t\trdp_protocol_error(\"cssp_read_tsrequest(), consume of token from stream would overrun\",\n\t\t\t\t\t   &packet);\n\t\t}\n\n\t\ts_realloc(token, length);\n\t\ts_reset(token);\n\t\tout_uint8p(token, s->p, length);\n\t\ts_mark_end(token);\n\t}\n\n\t// pubKey [3]",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "#endif\n\n#ifdef FEAT_KEYMAP\n    else if (varp == &curbuf->b_p_keymap)\n    {\n\t/* load or unload key mapping tables */\n\terrmsg = keymap_init();\n\n\tif (errmsg == NULL)\n\t{\n\t    if (*curbuf->b_p_keymap != NUL)\n\t    {\n    {\n\tif (!gui_mch_set_rendering_options(p_rop))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    /* Options that are a list of flags. */\n    else\n    {\n\tp = NULL;\n\tif (varp == &p_ww)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "#endif\n\n#ifdef FEAT_KEYMAP\n    else if (varp == &curbuf->b_p_keymap)\n    {\n\tif (!valid_filetype(*varp))\n\t    errmsg = e_invarg;\n\telse\n\t    /* load or unload key mapping tables */\n\t    errmsg = keymap_init();\n\n\tif (errmsg == NULL)\n\t{\n\t    if (*curbuf->b_p_keymap != NUL)\n\t    {\n\tif (!gui_mch_set_rendering_options(p_rop))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_AUTOCMD\n    else if (gvarp == &p_ft)\n    {\n\tif (!valid_filetype(*varp))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n#ifdef FEAT_SYN_HL\n    else if (gvarp == &p_syn)\n    {\n\tif (!valid_filetype(*varp))\n\t    errmsg = e_invarg;\n    }\n#endif\n\n    /* Options that are a list of flags. */\n    else\n    {\n\tp = NULL;\n\tif (varp == &p_ww)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                if (obj_tlen < 4)\n                    return-1;\n\n\t\t/* read variable length subobjects */\n\t\ttotal_subobj_len = obj_tlen;\n                while(total_subobj_len > 0) {\n                    subobj_len  = EXTRACT_16BITS(obj_tptr);\n                    subobj_type = (EXTRACT_16BITS(obj_tptr+2))>>8;\n                    af = (EXTRACT_16BITS(obj_tptr+2))&0x00FF;\n\n                    ND_PRINT((ndo, \"%s  Subobject Type: %s (%u), AF: %s (%u), length: %u\",\n                           tok2str(rsvp_obj_generalized_uni_values, \"Unknown\", subobj_type),\n                           subobj_type,\n                           tok2str(af_values, \"Unknown\", af), af,\n                           subobj_len));\n\n                    if(subobj_len == 0)\n                        goto invalid;\n\n                    switch(subobj_type) {\n                    case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS:\n                    case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                    return-1;\n\n\t\t/* read variable length subobjects */\n\t\ttotal_subobj_len = obj_tlen;\n                while(total_subobj_len > 0) {\n                    /* If RFC 3476 Section 3.1 defined that a sub-object of the\n                     * GENERALIZED_UNI RSVP object must have the Length field as\n                     * a multiple of 4, instead of the check below it would be\n                     * better to test total_subobj_len only once before the loop.\n                     * So long as it does not define it and this while loop does\n                     * not implement such a requirement, let's accept that within\n                     * each iteration subobj_len may happen to be a multiple of 1\n                     * and test it and total_subobj_len respectively.\n                     */\n                    if (total_subobj_len < 4)\n                        goto invalid;\n                    subobj_len  = EXTRACT_16BITS(obj_tptr);\n                    subobj_type = (EXTRACT_16BITS(obj_tptr+2))>>8;\n                    af = (EXTRACT_16BITS(obj_tptr+2))&0x00FF;\n\n                    ND_PRINT((ndo, \"%s  Subobject Type: %s (%u), AF: %s (%u), length: %u\",\n                           tok2str(rsvp_obj_generalized_uni_values, \"Unknown\", subobj_type),\n                           subobj_type,\n                           tok2str(af_values, \"Unknown\", af), af,\n                           subobj_len));\n\n                    /* In addition to what is explained above, the same spec does not\n                     * explicitly say that the same Length field includes the 4-octet\n                     * sub-object header, but as long as this while loop implements it\n                     * as it does include, let's keep the check below consistent with\n                     * the rest of the code.\n                     */\n                    if(subobj_len < 4 || subobj_len > total_subobj_len)\n                        goto invalid;\n\n                    switch(subobj_type) {\n                    case RSVP_GEN_UNI_SUBOBJ_SOURCE_TNA_ADDRESS:\n                    case RSVP_GEN_UNI_SUBOBJ_DESTINATION_TNA_ADDRESS:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    /* Close the slave transport */\n    if (adapter->del_base) {\n        pjmedia_transport_close(adapter->slave_tp);\n    }\n\n    /* Self destruct.. */\n    pj_pool_release(adapter->pool);\n\n    return PJ_SUCCESS;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    /* Close the slave transport */\n    if (adapter->del_base) {\n        pjmedia_transport_close(adapter->slave_tp);\n    }\n\n    if (adapter->base.grp_lock) {\n        pj_grp_lock_dec_ref(adapter->base.grp_lock);\n    } else {\n        adapter_on_destroy(tp);\n    }\n\n    return PJ_SUCCESS;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static struct ip_options *ip_options_get_alloc(const int optlen)\n{\n\treturn kzalloc(sizeof(struct ip_options) + ((optlen + 3) & ~3),\n\t\t       GFP_KERNEL);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static struct ip_options_rcu *ip_options_get_alloc(const int optlen)\n{\n\treturn kzalloc(sizeof(struct ip_options_rcu) + ((optlen + 3) & ~3),\n\t\t       GFP_KERNEL);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "otError Commissioner::GeneratePskc(const char *              aPassPhrase,\n                                   const char *              aNetworkName,\n                                   const Mac::ExtendedPanId &aExtPanId,\n                                   Pskc &                    aPskc)\n{\n    otError     error      = OT_ERROR_NONE;\n    const char *saltPrefix = \"Thread\";\n    uint8_t     salt[OT_PBKDF2_SALT_MAX_LEN];\n    uint16_t    saltLen = 0;\n\n    VerifyOrExit((strlen(aPassPhrase) >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&\n                     (strlen(aPassPhrase) <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE) &&\n                     (strlen(aNetworkName) <= OT_NETWORK_NAME_MAX_SIZE),\n                 error = OT_ERROR_INVALID_ARGS);\n\n    memset(salt, 0, sizeof(salt));\n    memcpy(salt, saltPrefix, strlen(saltPrefix));\n    saltLen += static_cast<uint16_t>(strlen(saltPrefix));\n\n    memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId));\n    saltLen += OT_EXT_PAN_ID_SIZE;\n\n    memcpy(salt + saltLen, aNetworkName, strlen(aNetworkName));\n    saltLen += static_cast<uint16_t>(strlen(aNetworkName));\n\n    otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), static_cast<uint16_t>(strlen(aPassPhrase)),\n                 reinterpret_cast<const uint8_t *>(salt), saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);\n\nexit:\n    return error;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "otError Commissioner::GeneratePskc(const char *              aPassPhrase,\n                                   const char *              aNetworkName,\n                                   const Mac::ExtendedPanId &aExtPanId,\n                                   Pskc &                    aPskc)\n{\n    otError    error        = OT_ERROR_NONE;\n    const char saltPrefix[] = \"Thread\";\n    uint8_t    salt[OT_PBKDF2_SALT_MAX_LEN];\n    uint16_t   saltLen = 0;\n    uint16_t   passphraseLen;\n    uint8_t    networkNameLen;\n\n    passphraseLen  = static_cast<uint16_t>(strnlen(aPassPhrase, OT_COMMISSIONING_PASSPHRASE_MAX_SIZE + 1));\n    networkNameLen = static_cast<uint8_t>(strnlen(aNetworkName, OT_NETWORK_NAME_MAX_SIZE + 1));\n\n    VerifyOrExit((passphraseLen >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&\n                     (passphraseLen <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE) &&\n                     (networkNameLen <= OT_NETWORK_NAME_MAX_SIZE),\n                 error = OT_ERROR_INVALID_ARGS);\n\n    memset(salt, 0, sizeof(salt));\n    memcpy(salt, saltPrefix, sizeof(saltPrefix) - 1);\n    saltLen += static_cast<uint16_t>(sizeof(saltPrefix) - 1);\n\n    memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId));\n    saltLen += OT_EXT_PAN_ID_SIZE;\n\n    memcpy(salt + saltLen, aNetworkName, networkNameLen);\n    saltLen += networkNameLen;\n\n    otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), passphraseLen, reinterpret_cast<const uint8_t *>(salt),\n                 saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);\n\nexit:\n    return error;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\t    struct pid *pid, const struct cred *cred)\n{\n\tscm->pid  = get_pid(pid);\n\tscm->cred = cred ? get_cred(cred) : NULL;\n\tscm->creds.pid = pid_vnr(pid);\n\tscm->creds.uid = cred ? cred->euid : INVALID_UID;\n\tscm->creds.gid = cred ? cred->egid : INVALID_GID;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\t    struct pid *pid, const struct cred *cred)\n{\n\tscm->pid  = get_pid(pid);\n\tscm->cred = cred ? get_cred(cred) : NULL;\n\tscm->creds.pid = pid_vnr(pid);\n\tscm->creds.uid = cred ? cred->uid : INVALID_UID;\n\tscm->creds.gid = cred ? cred->gid : INVALID_GID;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tout_buf = kzalloc(DJREPORT_SHORT_LENGTH, GFP_ATOMIC);\n\tif (!out_buf)\n\t\treturn -ENOMEM;\n\n\tif (count < DJREPORT_SHORT_LENGTH - 2)\n\t\tcount = DJREPORT_SHORT_LENGTH - 2;\n\n\tout_buf[0] = REPORT_ID_DJ_SHORT;\n\tout_buf[1] = djdev->device_index;\n\tmemcpy(out_buf + 2, buf, count);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tout_buf = kzalloc(DJREPORT_SHORT_LENGTH, GFP_ATOMIC);\n\tif (!out_buf)\n\t\treturn -ENOMEM;\n\n\tif (count > DJREPORT_SHORT_LENGTH - 2)\n\t\tcount = DJREPORT_SHORT_LENGTH - 2;\n\n\tout_buf[0] = REPORT_ID_DJ_SHORT;\n\tout_buf[1] = djdev->device_index;\n\tmemcpy(out_buf + 2, buf, count);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        register int iLeft = MAX(0, (int)floor (dCenter - width_d));\n        int iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n        double dTotalWeight = 0.0;\n\t\tint iSrc;\n\n        res->ContribRow[u].Left = iLeft;\n        res->ContribRow[u].Right = iRight;\n\n        /* Cut edge points to fit in filter window in case of spill-off */\n        if (iRight - iLeft + 1 > windows_size)  {\n            if (iLeft < ((int)src_size - 1 / 2))  {\n                iLeft++;\n            } else {\n                iRight--;\n            }\n        }\n\n        for (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n            dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n        }\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        /* get the significant edge points affecting the pixel */\n        register int iLeft = MAX(0, (int)floor (dCenter - width_d));\n        int iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1);\n        double dTotalWeight = 0.0;\n\t\tint iSrc;\n\n        /* Cut edge points to fit in filter window in case of spill-off */\n        if (iRight - iLeft + 1 > windows_size)  {\n            if (iLeft < ((int)src_size - 1 / 2))  {\n                iLeft++;\n            } else {\n                iRight--;\n            }\n        }\n\n        res->ContribRow[u].Left = iLeft;\n        res->ContribRow[u].Right = iRight;\n\n        for (iSrc = iLeft; iSrc <= iRight; iSrc++) {\n            dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc)));\n        }\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void ed_mul_sim_trick(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\t\tconst bn_t m) {\n\ted_t t0[1 << (ED_WIDTH / 2)], t1[1 << (ED_WIDTH / 2)], t[1 << ED_WIDTH];\n\tbn_t n;\n\tint l0, l1, w = ED_WIDTH / 2;\n\tuint8_t w0[RLC_FP_BITS + 1], w1[RLC_FP_BITS + 1];\n\n\tbn_null(n);\n\n\tif (bn_is_zero(k) || ed_is_infty(p)) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void ed_mul_sim_trick(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\t\tconst bn_t m) {\n\ted_t t0[1 << (ED_WIDTH / 2)], t1[1 << (ED_WIDTH / 2)], t[1 << ED_WIDTH];\n\tbn_t n;\n\tsize_t l0, l1, w = ED_WIDTH / 2;\n\tuint8_t w0[RLC_FP_BITS + 1], w1[RLC_FP_BITS + 1];\n\n\tbn_null(n);\n\n\tif (bn_is_zero(k) || ed_is_infty(p)) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        } else if (startcode == USER_DATA_STARTCODE) {\n            decode_user_data(ctx, gb);\n        } else if (startcode == GOP_STARTCODE) {\n            mpeg4_decode_gop_header(s, gb);\n        } else if (startcode == VOS_STARTCODE) {\n            mpeg4_decode_profile_level(s, gb);\n            if (s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n                (s->avctx->level > 0 && s->avctx->level < 9)) {\n                s->studio_profile = 1;\n                next_start_code_studio(gb);\n                extension_and_user_data(s, gb, 0);\n            }\n        } else if (startcode == VISUAL_OBJ_STARTCODE) {\n            if (s->studio_profile) {\n                if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n                    return ret;\n            } else\nend:\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n    s->avctx->has_b_frames = !s->low_delay;\n\n    if (s->studio_profile) {\n        if (!s->avctx->bits_per_raw_sample) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        return decode_studio_vop_header(ctx, gb);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        } else if (startcode == USER_DATA_STARTCODE) {\n            decode_user_data(ctx, gb);\n        } else if (startcode == GOP_STARTCODE) {\n            mpeg4_decode_gop_header(s, gb);\n        } else if (startcode == VOS_STARTCODE) {\n            int profile, level;\n            mpeg4_decode_profile_level(s, gb, &profile, &level);\n            if (profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO &&\n                (level > 0 && level < 9)) {\n                s->studio_profile = 1;\n                next_start_code_studio(gb);\n                extension_and_user_data(s, gb, 0);\n            } else if (s->studio_profile) {\n                avpriv_request_sample(s->avctx, \"Mixes studio and non studio profile\\n\");\n                return AVERROR_PATCHWELCOME;\n            }\n            s->avctx->profile = profile;\n            s->avctx->level   = level;\n        } else if (startcode == VISUAL_OBJ_STARTCODE) {\n            if (s->studio_profile) {\n                if ((ret = decode_studiovisualobject(ctx, gb)) < 0)\n                    return ret;\n            } else\n    if (s->avctx->flags & AV_CODEC_FLAG_LOW_DELAY)\n        s->low_delay = 1;\n    s->avctx->has_b_frames = !s->low_delay;\n\n    if (s->studio_profile) {\n        av_assert0(s->avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        if (!s->avctx->bits_per_raw_sample) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Missing VOL header\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        return decode_studio_vop_header(ctx, gb);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, int open_flags)\n{\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tmemcpy(state->stateid.data, stateid->data, sizeof(state->stateid.data));\n\tmemcpy(state->open_stateid.data, stateid->data, sizeof(state->open_stateid.data));\n\tswitch (open_flags) {\n\t\tcase FMODE_READ:\n\t\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void nfs_set_open_stateid_locked(struct nfs4_state *state, nfs4_stateid *stateid, fmode_t fmode)\n{\n\tif (test_bit(NFS_DELEGATED_STATE, &state->flags) == 0)\n\t\tmemcpy(state->stateid.data, stateid->data, sizeof(state->stateid.data));\n\tmemcpy(state->open_stateid.data, stateid->data, sizeof(state->open_stateid.data));\n\tswitch (fmode) {\n\t\tcase FMODE_READ:\n\t\t\tset_bit(NFS_O_RDONLY_STATE, &state->flags);\n\t\t\tbreak;\n\t\tcase FMODE_WRITE:\n\t\t\tset_bit(NFS_O_WRONLY_STATE, &state->flags);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n\t\tgoto out;\n\n\tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n\tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\n\tif (error)\n\t\tgoto out_drop_write;\n\n\tfh_drop_write(fh);\n\n\tnfserr = fh_getattr(fh, &resp->stat);\n\n\t/* argp->acl_{access,default} may have been allocated in\n\t   nfssvc_decode_setaclargs. */\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\treturn nfserr;\nout_drop_write:\n\tfh_drop_write(fh);\nout_errno:\n\tnfserr = nfserrno(error);\n\tgoto out;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n\t\tgoto out;\n\n\tinode = d_inode(fh->fh_dentry);\n\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\n\tfh_lock(fh);\n\n\terror = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);\n\tif (error)\n\t\tgoto out_drop_lock;\n\terror = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);\n\tif (error)\n\t\tgoto out_drop_lock;\n\n\tfh_unlock(fh);\n\n\tfh_drop_write(fh);\n\n\tnfserr = fh_getattr(fh, &resp->stat);\n\n\t/* argp->acl_{access,default} may have been allocated in\n\t   nfssvc_decode_setaclargs. */\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\treturn nfserr;\nout_drop_lock:\n\tfh_unlock(fh);\n\tfh_drop_write(fh);\nout_errno:\n\tnfserr = nfserrno(error);\n\tgoto out;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t{\n\t\tStream_Write_UINT8(s, brush->style);\n\t}\n\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tbrush->hatch = brush->index;\n\t\tbrush->bpp = BMF_BPP[brush->style & 0x07];\n\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_04)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tStream_Write_UINT8(s, brush->style);\n\t}\n\n\tif (brush->style & CACHED_BRUSH)\n\t{\n\t\tBOOL rc;\n\t\tbrush->hatch = brush->index;\n\t\tbrush->bpp = get_bmf_bpp(brush->style, &rc);\n\t\tif (!rc)\n\t\t\treturn FALSE;\n\t\tif (brush->bpp == 0)\n\t\t\tbrush->bpp = 1;\n\t}\n\n\tif (fieldFlags & ORDER_FIELD_04)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  if (GpuDriver::WaitStreamOnEvent(context_, AsGpuStream(stream)->gpu_stream(),\n                                   AsGpuEvent(event)->gpu_event())) {\n    return ::tsl::OkStatus();\n  } else {\n    return tsl::Status(\n        port::error::INTERNAL,\n        absl::StrFormat(\"error recording waiting for CUDA event on stream %p\",\n                        stream));\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  if (GpuDriver::WaitStreamOnEvent(context_, AsGpuStream(stream)->gpu_stream(),\n                                   AsGpuEvent(event)->gpu_event())) {\n    return ::tsl::OkStatus();\n  } else {\n    return tsl::Status(\n        tsl::error::INTERNAL,\n        absl::StrFormat(\"error recording waiting for CUDA event on stream %p\",\n                        stream));\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "   error_t error;\n   uint16_t status;\n   uint16_t value;\n\n   //Read interrupt status register\n   status = enc624j600ReadReg(interface, ENC624J600_REG_EIR);\n\n   //Check whether the link state has changed\n   if((status & EIR_LINKIF) != 0)\n   {\n      //Clear interrupt flag\n      enc624j600ClearBit(interface, ENC624J600_REG_EIR, EIR_LINKIF);\n      //Read Ethernet status register\n      value = enc624j600ReadReg(interface, ENC624J600_REG_ESTAT);\n\n      //Check link state\n      if((value & ESTAT_PHYLNK) != 0)\n      {\n         //Read PHY status register 3\n         value = enc624j600ReadPhyReg(interface, ENC624J600_PHY_REG_PHSTAT3);\n\n         //Get current speed\n         if((value & PHSTAT3_SPDDPX1) != 0)\n         {\n            interface->linkSpeed = NIC_LINK_SPEED_100MBPS;\n         }\n         else\n         {\n            interface->linkSpeed = NIC_LINK_SPEED_10MBPS;\n         }\n\n         //Determine the new duplex mode\n         if((value & PHSTAT3_SPDDPX2) != 0)\n         {\n            interface->duplexMode = NIC_FULL_DUPLEX_MODE;\n         }\n         else\n         {\n      //Process link state change event\n      nicNotifyLinkChange(interface);\n   }\n\n   //Check whether a packet has been received?\n   if((status & EIR_PKTIF) != 0)\n   {\n      //Clear interrupt flag\n      enc624j600ClearBit(interface, ENC624J600_REG_EIR, EIR_PKTIF);\n\n      //Process all pending packets\n      do\n      {\n         //Read incoming packet\n         //No more data in the receive buffer?\n      } while(error != ERROR_BUFFER_EMPTY);\n   }\n\n   //Re-enable LINKIE and PKTIE interrupts\n   enc624j600SetBit(interface, ENC624J600_REG_EIE, EIE_LINKIE | EIE_PKTIE);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "   error_t error;\n   uint16_t status;\n   uint16_t value;\n\n   //Read interrupt status register\n   status = enc624j600ReadReg(interface, ENC624J600_EIR);\n\n   //Check whether the link state has changed\n   if((status & ENC624J600_EIR_LINKIF) != 0)\n   {\n      //Clear interrupt flag\n      enc624j600ClearBit(interface, ENC624J600_EIR, ENC624J600_EIR_LINKIF);\n      //Read Ethernet status register\n      value = enc624j600ReadReg(interface, ENC624J600_ESTAT);\n\n      //Check link state\n      if((value & ENC624J600_ESTAT_PHYLNK) != 0)\n      {\n         //Read PHY status register 3\n         value = enc624j600ReadPhyReg(interface, ENC624J600_PHSTAT3);\n\n         //Get current speed\n         if((value & ENC624J600_PHSTAT3_SPDDPX1) != 0)\n         {\n            interface->linkSpeed = NIC_LINK_SPEED_100MBPS;\n         }\n         else\n         {\n            interface->linkSpeed = NIC_LINK_SPEED_10MBPS;\n         }\n\n         //Determine the new duplex mode\n         if((value & ENC624J600_PHSTAT3_SPDDPX2) != 0)\n         {\n            interface->duplexMode = NIC_FULL_DUPLEX_MODE;\n         }\n         else\n         {\n      //Process link state change event\n      nicNotifyLinkChange(interface);\n   }\n\n   //Check whether a packet has been received?\n   if((status & ENC624J600_EIR_PKTIF) != 0)\n   {\n      //Clear interrupt flag\n      enc624j600ClearBit(interface, ENC624J600_EIR, ENC624J600_EIR_PKTIF);\n\n      //Process all pending packets\n      do\n      {\n         //Read incoming packet\n         //No more data in the receive buffer?\n      } while(error != ERROR_BUFFER_EMPTY);\n   }\n\n   //Re-enable LINKIE and PKTIE interrupts\n   enc624j600SetBit(interface, ENC624J600_EIE, ENC624J600_EIE_LINKIE |\n      ENC624J600_EIE_PKTIE);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;\n\t\tssid_ie = brcmf_parse_tlvs(\n\t\t\t\t(u8 *)&settings->beacon.head[ie_offset],\n\t\t\t\tsettings->beacon.head_len - ie_offset,\n\t\t\t\tWLAN_EID_SSID);\n\t\tif (!ssid_ie)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(ssid_le.SSID, ssid_ie->data, ssid_ie->len);\n\t\tssid_le.SSID_len = cpu_to_le32(ssid_ie->len);\n\t\tbrcmf_dbg(TRACE, \"SSID is (%s) in Head\\n\", ssid_le.SSID);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;\n\t\tssid_ie = brcmf_parse_tlvs(\n\t\t\t\t(u8 *)&settings->beacon.head[ie_offset],\n\t\t\t\tsettings->beacon.head_len - ie_offset,\n\t\t\t\tWLAN_EID_SSID);\n\t\tif (!ssid_ie || ssid_ie->len > IEEE80211_MAX_SSID_LEN)\n\t\t\treturn -EINVAL;\n\n\t\tmemcpy(ssid_le.SSID, ssid_ie->data, ssid_ie->len);\n\t\tssid_le.SSID_len = cpu_to_le32(ssid_ie->len);\n\t\tbrcmf_dbg(TRACE, \"SSID is (%s) in Head\\n\", ssid_le.SSID);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "              private_key:\n                filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n            validation_context:\n              trusted_ca:\n                filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n              match_subject_alt_names:\n              - exact: localhost\n              - exact: 127.0.0.1\n    typed_extension_protocol_options:\n      envoy.extensions.upstreams.http.v3.HttpProtocolOptions:\n        \"@type\": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\n        use_downstream_protocol_config:\n          http3_protocol_options: {}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "              private_key:\n                filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/san_uri_key.pem\"\n            validation_context:\n              trusted_ca:\n                filename: \"{{ test_rundir }}/test/extensions/transport_sockets/tls/test_data/ca_cert.pem\"\n              match_typed_subject_alt_names:\n              - matcher:\n                  exact: localhost\n                san_type: URI\n              - matcher:\n                  exact: 127.0.0.1\n                san_type: IP_ADDRESS\n    typed_extension_protocol_options:\n      envoy.extensions.upstreams.http.v3.HttpProtocolOptions:\n        \"@type\": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions\n        use_downstream_protocol_config:\n          http3_protocol_options: {}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tblk_rq_init(q, flush_rq);\n\n\t/*\n\t * Borrow tag from the first request since they can't\n\t * be in flight at the same time.\n\t */\n\tif (q->mq_ops) {\n\t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n\t\tflush_rq->tag = first_rq->tag;\n\t}\n\n\tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tblk_rq_init(q, flush_rq);\n\n\t/*\n\t * Borrow tag from the first request since they can't\n\t * be in flight at the same time. And acquire the tag's\n\t * ownership for flush req.\n\t */\n\tif (q->mq_ops) {\n\t\tstruct blk_mq_hw_ctx *hctx;\n\n\t\tflush_rq->mq_ctx = first_rq->mq_ctx;\n\t\tflush_rq->tag = first_rq->tag;\n\t\tfq->orig_rq = first_rq;\n\n\t\thctx = q->mq_ops->map_queue(q, first_rq->mq_ctx->cpu);\n\t\tblk_mq_tag_set_rq(hctx, first_rq->tag, flush_rq);\n\t}\n\n\tflush_rq->cmd_type = REQ_TYPE_FS;\n\tflush_rq->cmd_flags = WRITE_FLUSH | REQ_FLUSH_SEQ;\n\tflush_rq->rq_disk = first_rq->rq_disk;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n    check_1_6_dummy(entry, mask, n_ks_tuple, ks_tuple, &password);\n\n    /*\n     * Argument sanity checking, and opening up the DB\n     */\n    if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_LAST_SUCCESS) || (mask & KADM5_LAST_FAILED) ||\n       (mask & KADM5_FAIL_AUTH_COUNT))\n        return KADM5_BAD_MASK;\n    if ((mask & KADM5_KEY_DATA) && entry->n_key_data != 0)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if (entry == NULL)\n        return EINVAL;\n\n    /*\n     * Check to see if the principal exists\n     */\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    check_1_6_dummy(entry, mask, n_ks_tuple, ks_tuple, &password);\n\n    /*\n     * Argument sanity checking, and opening up the DB\n     */\n    if (entry == NULL)\n        return EINVAL;\n    if(!(mask & KADM5_PRINCIPAL) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_LAST_SUCCESS) || (mask & KADM5_LAST_FAILED) ||\n       (mask & KADM5_FAIL_AUTH_COUNT))\n        return KADM5_BAD_MASK;\n    if ((mask & KADM5_KEY_DATA) && entry->n_key_data != 0)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && entry->policy == NULL)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n\n    /*\n     * Check to see if the principal exists\n     */\n    ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t(unsigned long) dev->bid_devno,\n\t\t\t(long) dev->bid_time,\n\t\t\t(long) dev->bid_utime);\n\n\tif (dev->bid_pri)\n\t\tfprintf(file, \" PRI=\\\"%d\\\"\", dev->bid_pri);\n\tlist_for_each(p, &dev->bid_tags) {\n\t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n\t\tfprintf(file, \" %s=\\\"%s\\\"\", tag->bit_name,tag->bit_val);\n\t}\n\tfprintf(file, \">%s</device>\\n\", dev->bid_name);\n\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t(long) dev->bid_time,\n\t\t\t(long) dev->bid_utime);\n\n\tif (dev->bid_pri)\n\t\tfprintf(file, \" PRI=\\\"%d\\\"\", dev->bid_pri);\n\n\tlist_for_each(p, &dev->bid_tags) {\n\t\tblkid_tag tag = list_entry(p, struct blkid_struct_tag, bit_tags);\n\n\t\tfputc(' ', file);\t\t\t/* space between tags */\n\t\tfputs(tag->bit_name, file);\t\t/* tag NAME */\n\t\tfputc('=', file);\t\t\t/* separator between NAME and VALUE */\n\t\tsave_quoted(tag->bit_val, file);\t/* tag \"VALUE\" */\n\t}\n\tfprintf(file, \">%s</device>\\n\", dev->bid_name);\n\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      done();\n      col_params->Unref();\n    };\n    core::RefCountPtr<CollectiveGroupResource> resource;\n    OP_REQUIRES_OK_ASYNC(c, LookupResource(c, HandleFromInput(c, 1), &resource),\n                         done);\n\n    Tensor group_assignment = c->input(2);\n\n    OP_REQUIRES_OK_ASYNC(\n        c,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      done();\n      col_params->Unref();\n    };\n    core::RefCountPtr<CollectiveGroupResource> resource;\n    OP_REQUIRES_OK_ASYNC(c, LookupResource(c, HandleFromInput(c, 1), &resource),\n                         done_with_cleanup);\n\n    Tensor group_assignment = c->input(2);\n\n    OP_REQUIRES_OK_ASYNC(\n        c,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  if (activation_mode != dnn::ActivationMode::kRelu &&\n      activation_mode != dnn::ActivationMode::kRelu6 &&\n      activation_mode != dnn::ActivationMode::kElu &&\n      activation_mode != dnn::ActivationMode::kLeakyRelu &&\n      activation_mode != dnn::ActivationMode::kNone) {\n    return tsl::Status(port::error::INVALID_ARGUMENT,\n                       \"CuDNN fusion only supports activations of \"\n                       \"{Relu, Relu6, Elu, <None>}.\");\n  }\n\n  if (!actually_use_cudnn_frontend) {\n    std::vector<dnn::AlgorithmDesc> algorithms;\n\n    auto cuda_compute_capability = stream->GetCudaComputeCapability();\n    if (!GetConvolveAlgorithms(cuda_compute_capability, input_type,\n                               &algorithms)) {\n      return tsl::Status(port::error::UNKNOWN,\n                         \"Listing fused convolve algorithms failed.\");\n    }\n\n    for (const auto& algo : algorithms) {\n      // Only CUDNN_CONVOLUTION_FWD_ALGO_IMPLICIT_PRECOMP_GEMM is supported\n  auto op_graph_status = GetCudnnFusedOperationGraph(\n      kind, input_type, bias_type, output_type, conv_scale, side_input_scale,\n      leakyrelu_alpha, input_descriptor, filter_descriptor, bias_descriptor,\n      output_descriptor, convolution_descriptor, activation_mode, cudnn);\n  if (!op_graph_status.status().ok()) {\n    return tsl::Status(port::error::INTERNAL,\n                       absl::StrCat(\"Cudnn graph failed to build: \",\n                                    op_graph_status.status().ToString()));\n  }\n  auto op_graph = std::move(op_graph_status).value();\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  if (activation_mode != dnn::ActivationMode::kRelu &&\n      activation_mode != dnn::ActivationMode::kRelu6 &&\n      activation_mode != dnn::ActivationMode::kElu &&\n      activation_mode != dnn::ActivationMode::kLeakyRelu &&\n      activation_mode != dnn::ActivationMode::kNone) {\n    return tsl::Status(tsl::error::INVALID_ARGUMENT,\n                       \"CuDNN fusion only supports activations of \"\n                       \"{Relu, Relu6, Elu, <None>}.\");\n  }\n\n  if (!actually_use_cudnn_frontend) {\n    std::vector<dnn::AlgorithmDesc> algorithms;\n\n    auto cuda_compute_capability = stream->GetCudaComputeCapability();\n    if (!GetConvolveAlgorithms(cuda_compute_capability, input_type,\n                               &algorithms)) {\n      return tsl::Status(tsl::error::UNKNOWN,\n                         \"Listing fused convolve algorithms failed.\");\n    }\n\n    for (const auto& algo : algorithms) {\n      // Only CUDNN_CONVOLUTION_FWD_ALGO_IMPLICIT_PRECOMP_GEMM is supported\n  auto op_graph_status = GetCudnnFusedOperationGraph(\n      kind, input_type, bias_type, output_type, conv_scale, side_input_scale,\n      leakyrelu_alpha, input_descriptor, filter_descriptor, bias_descriptor,\n      output_descriptor, convolution_descriptor, activation_mode, cudnn);\n  if (!op_graph_status.status().ok()) {\n    return tsl::Status(tsl::error::INTERNAL,\n                       absl::StrCat(\"Cudnn graph failed to build: \",\n                                    op_graph_status.status().ToString()));\n  }\n  auto op_graph = std::move(op_graph_status).value();\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ikev1_attrmap_print(netdissect_options *ndo,\n\t\t    const u_char *p, const u_char *ep,\n\t\t    const struct attrmap *map, size_t nmap)\n{\n\tint totlen;\n\tuint32_t t, v;\n\n\tif (p[0] & 0x80)\n\t\ttotlen = 4;\n\telse\n\t\ttotlen = 4 + EXTRACT_16BITS(&p[2]);\n\tif (ep < p + totlen) {\n\t\tND_PRINT((ndo,\"[|attr]\"));\n\t\treturn ep + 1;\n\t}\n\n\tND_PRINT((ndo,\"(\"));\n\tt = EXTRACT_16BITS(&p[0]) & 0x7fff;\n\tif (map && t < nmap && map[t].type)\n\t\tND_PRINT((ndo,\"type=%s \", map[t].type));\n\telse\n\t\tND_PRINT((ndo,\"type=#%d \", t));\n\tif (p[0] & 0x80) {\n\t\tND_PRINT((ndo,\"value=\"));\n\t\tv = EXTRACT_16BITS(&p[2]);\n\t\tif (map && t < nmap && v < map[t].nvalue && map[t].value[v])\n\t\t\tND_PRINT((ndo,\"%s\", map[t].value[v]));\n\t\telse\n\t\t\trawprint(ndo, (const uint8_t *)&p[2], 2);\n\t} else {\n\t\tND_PRINT((ndo,\"len=%d value=\", EXTRACT_16BITS(&p[2])));\n\t\trawprint(ndo, (const uint8_t *)&p[4], EXTRACT_16BITS(&p[2]));\n\t}\n\tND_PRINT((ndo,\")\"));\n\treturn p + totlen;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ikev1_attrmap_print(netdissect_options *ndo,\n\t\t    const u_char *p, const u_char *ep2,\n\t\t    const struct attrmap *map, size_t nmap)\n{\n\tint totlen;\n\tuint32_t t, v;\n\n\tND_TCHECK(p[0]);\n\tif (p[0] & 0x80)\n\t\ttotlen = 4;\n\telse {\n\t\tND_TCHECK_16BITS(&p[2]);\n\t\ttotlen = 4 + EXTRACT_16BITS(&p[2]);\n\t}\n\tif (ep2 < p + totlen) {\n\t\tND_PRINT((ndo,\"[|attr]\"));\n\t\treturn ep2 + 1;\n\t}\n\n\tND_TCHECK_16BITS(&p[0]);\n\tND_PRINT((ndo,\"(\"));\n\tt = EXTRACT_16BITS(&p[0]) & 0x7fff;\n\tif (map && t < nmap && map[t].type)\n\t\tND_PRINT((ndo,\"type=%s \", map[t].type));\n\telse\n\t\tND_PRINT((ndo,\"type=#%d \", t));\n\tif (p[0] & 0x80) {\n\t\tND_PRINT((ndo,\"value=\"));\n\t\tND_TCHECK_16BITS(&p[2]);\n\t\tv = EXTRACT_16BITS(&p[2]);\n\t\tif (map && t < nmap && v < map[t].nvalue && map[t].value[v])\n\t\t\tND_PRINT((ndo,\"%s\", map[t].value[v]));\n\t\telse {\n\t\t\tif (!rawprint(ndo, (const uint8_t *)&p[2], 2)) {\n\t\t\t\tND_PRINT((ndo,\")\"));\n\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tND_PRINT((ndo,\"len=%d value=\", totlen - 4));\n\t\tif (!rawprint(ndo, (const uint8_t *)&p[4], totlen - 4)) {\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tgoto trunc;\n\t\t}\n\t}\n\tND_PRINT((ndo,\")\"));\n\treturn p + totlen;\n\ntrunc:\n\treturn NULL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int pure_strcmp(const char * const s1, const char * const s2)\n{\n    return pure_memcmp(s1, s2, strlen(s1) + 1U);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int pure_strcmp(const char * const s1, const char * const s2)\n{\n    const size_t s1_len = strlen(s1);\n    const size_t s2_len = strlen(s2);\n    const size_t len = (s1_len < s2_len) ? s1_len : s2_len;\n\n    return pure_memcmp(s1, s2, len + 1);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "_libssh2_packet_add(LIBSSH2_SESSION * session, unsigned char *data,\n                    size_t datalen, int macstate)\n{\n    int rc = 0;\n    char *message = NULL;\n    char *language = NULL;\n    size_t message_len = 0;\n    size_t language_len = 0;\n    LIBSSH2_CHANNEL *channelp = NULL;\n    size_t data_head = 0;\n    unsigned char msg = data[0];\n              string    language tag [RFC3066]\n            */\n\n        case SSH_MSG_DISCONNECT:\n            if(datalen >= 5) {\n                size_t reason = _libssh2_ntohu32(data + 1);\n\n                if(datalen >= 9) {\n                    message_len = _libssh2_ntohu32(data + 5);\n\n                    if(message_len < datalen-13) {\n                        /* 9 = packet_type(1) + reason(4) + message_len(4) */\n                        message = (char *) data + 9;\n\n                        language_len =\n                            _libssh2_ntohu32(data + 9 + message_len);\n                        language = (char *) data + 9 + message_len + 4;\n\n                        if(language_len > (datalen-13-message_len)) {\n                            /* bad input, clear info */\n                            language = message = NULL;\n                            language_len = message_len = 0;\n                        }\n                    }\n                    else\n                        /* bad size, clear it */\n                        message_len = 0;\n                }\n                if(session->ssh_msg_disconnect) {\n                    LIBSSH2_DISCONNECT(session, reason, message,\n                                       message_len, language, language_len);\n                }\n                _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                               \"Disconnect(%d): %s(%s)\", reason,\n                               message, language);\n            }\n\n        case SSH_MSG_DEBUG:\n            if(datalen >= 2) {\n                int always_display = data[1];\n\n                if(datalen >= 6) {\n                    message_len = _libssh2_ntohu32(data + 2);\n\n                    if(message_len <= (datalen - 10)) {\n                        /* 6 = packet_type(1) + display(1) + message_len(4) */\n                        message = (char *) data + 6;\n                        language_len = _libssh2_ntohu32(data + 6 +\n                                                        message_len);\n\n                        if(language_len <= (datalen - 10 - message_len))\n                            language = (char *) data + 10 + message_len;\n                    }\n                }\n\n                if(session->ssh_msg_debug) {\n                    LIBSSH2_DEBUG(session, always_display, message,\n                                  message_len, language, language_len);\n                }\n            }\n            /*\n             * _libssh2_debug will actually truncate this for us so\n             * that it's not an inordinate about of data\n             */\n            _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n        case SSH_MSG_GLOBAL_REQUEST:\n            if(datalen >= 5) {\n                uint32_t len = 0;\n                unsigned char want_reply = 0;\n                len = _libssh2_ntohu32(data + 1);\n                if(datalen >= (6 + len)) {\n                    want_reply = data[5 + len];\n                    _libssh2_debug(session,\n                                   LIBSSH2_TRACE_CONN,\n                                   \"Received global request type %.*s (wr %X)\",\n                                   len, data + 5, want_reply);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "_libssh2_packet_add(LIBSSH2_SESSION * session, unsigned char *data,\n                    size_t datalen, int macstate)\n{\n    int rc = 0;\n    unsigned char *message = NULL;\n    unsigned char *language = NULL;\n    size_t message_len = 0;\n    size_t language_len = 0;\n    LIBSSH2_CHANNEL *channelp = NULL;\n    size_t data_head = 0;\n    unsigned char msg = data[0];\n              string    language tag [RFC3066]\n            */\n\n        case SSH_MSG_DISCONNECT:\n            if(datalen >= 5) {\n                uint32_t reason = 0;\n                struct string_buf buf;\n                buf.data = (unsigned char *)data;\n                buf.dataptr = buf.data;\n                buf.len = datalen;\n                buf.dataptr++; /* advance past type */\n\n                _libssh2_get_u32(&buf, &reason);\n                _libssh2_get_string(&buf, &message, &message_len);\n                _libssh2_get_string(&buf, &language, &language_len);\n\n                if(session->ssh_msg_disconnect) {\n                    LIBSSH2_DISCONNECT(session, reason, (const char *)message,\n                                       message_len, (const char *)language,\n                                       language_len);\n                }\n\n                _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n                               \"Disconnect(%d): %s(%s)\", reason,\n                               message, language);\n            }\n\n        case SSH_MSG_DEBUG:\n            if(datalen >= 2) {\n                int always_display = data[1];\n\n                if(datalen >= 6) {\n                    struct string_buf buf;\n                    buf.data = (unsigned char *)data;\n                    buf.dataptr = buf.data;\n                    buf.len = datalen;\n                    buf.dataptr += 2; /* advance past type & always display */\n\n                    _libssh2_get_string(&buf, &message, &message_len);\n                    _libssh2_get_string(&buf, &language, &language_len);\n                }\n\n                if(session->ssh_msg_debug) {\n                    LIBSSH2_DEBUG(session, always_display,\n                                  (const char *)message,\n                                  message_len, (const char *)language,\n                                  language_len);\n                }\n            }\n\n            /*\n             * _libssh2_debug will actually truncate this for us so\n             * that it's not an inordinate about of data\n             */\n            _libssh2_debug(session, LIBSSH2_TRACE_TRANS,\n        case SSH_MSG_GLOBAL_REQUEST:\n            if(datalen >= 5) {\n                uint32_t len = 0;\n                unsigned char want_reply = 0;\n                len = _libssh2_ntohu32(data + 1);\n                if((len <= (UINT_MAX - 6)) && (datalen >= (6 + len))) {\n                    want_reply = data[5 + len];\n                    _libssh2_debug(session,\n                                   LIBSSH2_TRACE_CONN,\n                                   \"Received global request type %.*s (wr %X)\",\n                                   len, data + 5, want_reply);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void recovery_character(const char *character)\n{\n    if (!awaiting_character) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void recovery_character(const char *character)\n{\n    if (!awaiting_character || !recovery_started) {\n        recovery_abort();\n        fsm_sendFailure(FailureType_Failure_UnexpectedMessage, \"Not in Recovery mode\");\n        layoutHome();\n        return;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t    while (jumpidx != curwin->w_jumplistidx)\n\t    {\n\t\tbuf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    if (buf == curbuf || !buf->b_p_bl)\n\t\t\tbuf = NULL;\t// skip current and unlisted bufs\n\t\t    else if (buf->b_ml.ml_mfp == NULL)\n\t\t    {\n\t\t\t// skip unloaded buf, but may keep it for later\n\t\t\tif (bp == NULL)\n\t\t\t    bp = buf;\n\t\t    buf = curbuf->b_prev;\n\t\t    forward = FALSE;\n\t\t    continue;\n\t\t}\n\t\t// in non-help buffer, try to skip help buffers, and vv\n\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl)\n\t\t{\n\t\t    if (buf->b_ml.ml_mfp != NULL)   // found loaded buffer\n\t\t\tbreak;\n\t\t    if (bp == NULL)\t// remember unloaded buf for later\n\t\t\tbp = buf;\n\tif (buf == NULL)\t// No loaded buffer, use unloaded one\n\t    buf = bp;\n\tif (buf == NULL)\t// No loaded buffer, find listed one\n\t{\n\t    FOR_ALL_BUFFERS(buf)\n\t\tif (buf->b_p_bl && buf != curbuf)\n\t\t    break;\n\t}\n\tif (buf == NULL)\t// Still no buffer, just take one\n\t{\n\t    if (curbuf->b_next != NULL)\n\t\tbuf = curbuf->b_next;\n\t    else\n\t\tbuf = curbuf->b_prev;\n\t}\n    }\n\n    if (buf == NULL)\n    {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t    while (jumpidx != curwin->w_jumplistidx)\n\t    {\n\t\tbuf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    // Skip current and unlisted bufs.  Also skip a quickfix\n\t\t    // buffer, it might be deleted soon.\n\t\t    if (buf == curbuf || !buf->b_p_bl\n#if defined(FEAT_QUICKFIX)\n\t\t\t    || bt_quickfix(buf)\n#endif\n\t\t\t    )\n\t\t\tbuf = NULL;\n\t\t    else if (buf->b_ml.ml_mfp == NULL)\n\t\t    {\n\t\t\t// skip unloaded buf, but may keep it for later\n\t\t\tif (bp == NULL)\n\t\t\t    bp = buf;\n\t\t    buf = curbuf->b_prev;\n\t\t    forward = FALSE;\n\t\t    continue;\n\t\t}\n\t\t// in non-help buffer, try to skip help buffers, and vv\n\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl\n#if defined(FEAT_QUICKFIX)\n\t\t\t    && !bt_quickfix(buf)\n#endif\n\t\t\t   )\n\t\t{\n\t\t    if (buf->b_ml.ml_mfp != NULL)   // found loaded buffer\n\t\t\tbreak;\n\t\t    if (bp == NULL)\t// remember unloaded buf for later\n\t\t\tbp = buf;\n\tif (buf == NULL)\t// No loaded buffer, use unloaded one\n\t    buf = bp;\n\tif (buf == NULL)\t// No loaded buffer, find listed one\n\t{\n\t    FOR_ALL_BUFFERS(buf)\n\t\tif (buf->b_p_bl && buf != curbuf\n#if defined(FEAT_QUICKFIX)\n\t\t\t    && !bt_quickfix(buf)\n#endif\n\t\t       )\n\t\t    break;\n\t}\n\tif (buf == NULL)\t// Still no buffer, just take one\n\t{\n\t    if (curbuf->b_next != NULL)\n\t\tbuf = curbuf->b_next;\n\t    else\n\t\tbuf = curbuf->b_prev;\n#if defined(FEAT_QUICKFIX)\n\t    if (bt_quickfix(buf))\n\t\tbuf = NULL;\n#endif\n\t}\n    }\n\n    if (buf == NULL)\n    {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                break;\n\n        case BGPTYPE_PMSI_TUNNEL:\n        {\n                uint8_t tunnel_type, flags;\n\n                tunnel_type = *(tptr+1);\n                flags = *tptr;\n                tlen = len;\n\n                ND_TCHECK2(tptr[0], 5);\n                ND_PRINT((ndo, \"\\n\\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u\",\n                       tok2str(bgp_pmsi_tunnel_values, \"Unknown\", tunnel_type),\n                       tunnel_type,\n                       bittok2str(bgp_pmsi_flag_values, \"none\", flags),\n                       EXTRACT_24BITS(tptr+2)>>4));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n        case BGPTYPE_PMSI_TUNNEL:\n        {\n                uint8_t tunnel_type, flags;\n\n                ND_TCHECK2(tptr[0], 5);\n                tunnel_type = *(tptr+1);\n                flags = *tptr;\n                tlen = len;\n\n                ND_PRINT((ndo, \"\\n\\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u\",\n                       tok2str(bgp_pmsi_tunnel_values, \"Unknown\", tunnel_type),\n                       tunnel_type,\n                       bittok2str(bgp_pmsi_flag_values, \"none\", flags),\n                       EXTRACT_24BITS(tptr+2)>>4));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ast2obj_arg(void* _o)\n{\n    arg_ty o = (arg_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    result = PyType_GenericNew(arg_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_identifier(o->arg);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ast2obj_arg(void* _o)\n{\n    arg_ty o = (arg_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_RETURN_NONE;\n    }\n\n    result = PyType_GenericNew(arg_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_identifier(o->arg);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        apache::thrift::skip(prot, elemType);\n      }\n      prot.readListEnd();\n      return;\n    }\n    default:\n      return;\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        apache::thrift::skip(prot, elemType);\n      }\n      prot.readListEnd();\n      return;\n    }\n    default: {\n      TProtocolException::throwInvalidSkipType(arg_type);\n    }\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic->pending_events;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_vcpu_has_lapic(vcpu) && vcpu->arch.apic->pending_events;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/config/integration/certs/upstreamcacert.pem\"\n      match_subject_alt_names:\n        exact: \"::1\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  const std::string client_ctx_yaml = R\"EOF(\n  common_tls_context:\n    validation_context:\n      trusted_ca:\n        filename: \"{{ test_rundir }}/test/config/integration/certs/upstreamcacert.pem\"\n      match_typed_subject_alt_names:\n      - san_type: IP_ADDRESS\n        matcher:\n          exact: \"::1\"\n)EOF\";\n\n  const std::string server_ctx_yaml = R\"EOF(\n  common_tls_context:\n    tls_certificates:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    avio_rl64(pb);            // reserved 16 bytes\n    avio_rl64(pb);            // ...\n    count = avio_rl32(pb);    // markers count\n    avio_rl16(pb);            // reserved 2 bytes\n    name_len = avio_rl16(pb); // name length\n    for (i = 0; i < name_len; i++)\n        avio_r8(pb); // skip the name\n\n    for (i = 0; i < count; i++) {\n        int64_t pres_time;\n        int name_len;\n\n        avio_rl64(pb);             // offset, 8 bytes\n        pres_time = avio_rl64(pb); // presentation time\n        pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             // entry length",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    avio_rl64(pb);            // reserved 16 bytes\n    avio_rl64(pb);            // ...\n    count = avio_rl32(pb);    // markers count\n    avio_rl16(pb);            // reserved 2 bytes\n    name_len = avio_rl16(pb); // name length\n    avio_skip(pb, name_len);\n\n    for (i = 0; i < count; i++) {\n        int64_t pres_time;\n        int name_len;\n\n        if (avio_feof(pb))\n            return AVERROR_INVALIDDATA;\n\n        avio_rl64(pb);             // offset, 8 bytes\n        pres_time = avio_rl64(pb); // presentation time\n        pres_time -= asf->hdr.preroll * 10000;\n        avio_rl16(pb);             // entry length",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  xla::LocalClientOptions client_options;\n  client_options.set_platform(platform.ValueOrDie());\n  client_options.set_intra_op_parallelism_threads(\n      device->tensorflow_cpu_worker_threads()->num_threads);\n\n  string allowed_gpus =\n      flr->config_proto()->gpu_options().visible_device_list();\n  TF_ASSIGN_OR_RETURN(absl::optional<std::set<int>> gpu_ids,\n                      ParseVisibleDeviceList(allowed_gpus));\n  client_options.set_allowed_devices(gpu_ids);\n\n  auto client = xla::ClientLibrary::GetOrCreateLocalClient(client_options);\n  if (!client.ok()) {\n    return client.status();\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  xla::LocalClientOptions client_options;\n  client_options.set_platform(platform.ValueOrDie());\n  client_options.set_intra_op_parallelism_threads(\n      device->tensorflow_cpu_worker_threads()->num_threads);\n\n  if (flr->config_proto()) {\n    string allowed_gpus =\n        flr->config_proto()->gpu_options().visible_device_list();\n    TF_ASSIGN_OR_RETURN(absl::optional<std::set<int>> gpu_ids,\n                        ParseVisibleDeviceList(allowed_gpus));\n    client_options.set_allowed_devices(gpu_ids);\n  }\n\n  auto client = xla::ClientLibrary::GetOrCreateLocalClient(client_options);\n  if (!client.ok()) {\n    return client.status();\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tnext_ip = perf_instruction_pointer(regs);\n\tlr = regs->link;\n\tsp = regs->gpr[1];\n\tperf_callchain_store(entry, next_ip);\n\n\tfor (;;) {\n\t\tfp = (unsigned long __user *) sp;\n\t\tif (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &next_sp))\n\t\t\treturn;\n\t\tif (level > 0 && read_user_stack_64(&fp[2], &next_ip))\n\t\t\treturn;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tnext_ip = perf_instruction_pointer(regs);\n\tlr = regs->link;\n\tsp = regs->gpr[1];\n\tperf_callchain_store(entry, next_ip);\n\n\twhile (entry->nr < PERF_MAX_STACK_DEPTH) {\n\t\tfp = (unsigned long __user *) sp;\n\t\tif (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &next_sp))\n\t\t\treturn;\n\t\tif (level > 0 && read_user_stack_64(&fp[2], &next_ip))\n\t\t\treturn;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\t\tsbp->flags,\n\t\t\t\t\tsbp->name,\n\t\t\t\t\tsbp->namelen,\n\t\t\t\t\tsbp->valuelen,\n\t\t\t\t\t&sbp->name[sbp->namelen]);\n\t\tif (error)\n\t\t\treturn error;\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\t\tsbp->flags,\n\t\t\t\t\tsbp->name,\n\t\t\t\t\tsbp->namelen,\n\t\t\t\t\tsbp->valuelen,\n\t\t\t\t\t&sbp->name[sbp->namelen]);\n\t\tif (error) {\n\t\t\tkmem_free(sbuf);\n\t\t\treturn error;\n\t\t}\n\t\tif (context->seen_enough)\n\t\t\tbreak;\n\t\tcursor->offset++;\n\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void handle_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        uint8_t buf[64];\n        memcpy(buf, msg, sizeof(buf));\n\n        uint16_t msgId = buf[4] | ((uint16_t)buf[3]) << 8;\n        uint32_t msgSize = buf[8]        |\n                ((uint32_t)buf[7]) <<  8 |\n                ((uint32_t)buf[6]) << 16 |\n                ((uint32_t)buf[5]) << 24;\n\n        if (msgSize > 64 - 9) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Malformed tiny packet\");\n            return;\n        }\n\n        // Determine callback handler and message map type.\n        const MessagesMap_t *entry = message_map_entry(NORMAL_MSG, msgId, IN_MSG);\n        if (!entry) {\n            (*msg_failure)(FailureType_Failure_UnexpectedMessage, \"Unknown message\");\n            return;\n        }\n\n        tiny_dispatch(entry, buf + 9, msgSize);\n    } else {\n        usb_rx_helper(msg, len, NORMAL_MSG);\n    }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void handle_usb_rx(const void *msg, size_t len)\n{\n    if (msg_tiny_flag) {\n        msg_read_tiny(msg, len);\n    } else {\n        usb_rx_helper(msg, len, NORMAL_MSG);\n    }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        if (frame->colorspace != AVCOL_SPC_UNSPECIFIED)\n            print_str(\"color_space\", av_color_space_name(frame->colorspace));\n        else\n            print_str_opt(\"color_space\", av_color_space_name(frame->colorspace));\n\n        if (frame->color_primaries != AVCOL_PRI_UNSPECIFIED)\n            print_str(\"color_primaries\", av_color_primaries_name(frame->color_primaries));\n        else\n            print_str_opt(\"color_primaries\", av_color_primaries_name(frame->color_primaries));\n\n        if (frame->color_trc != AVCOL_TRC_UNSPECIFIED)\n            print_str(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n        else\n            print_str_opt(\"color_transfer\", av_color_transfer_name(frame->color_trc));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        if (frame->colorspace != AVCOL_SPC_UNSPECIFIED)\n            print_str(\"color_space\", av_color_space_name(frame->colorspace));\n        else\n            print_str_opt(\"color_space\", av_color_space_name(frame->colorspace));\n\n        print_primaries(w, frame->color_primaries);\n\n        if (frame->color_trc != AVCOL_TRC_UNSPECIFIED)\n            print_str(\"color_transfer\", av_color_transfer_name(frame->color_trc));\n        else\n            print_str_opt(\"color_transfer\", av_color_transfer_name(frame->color_trc));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void IOBuf::reserveSlow(std::size_t minHeadroom, std::size_t minTailroom) {\n  size_t newCapacity = (size_t)length_ + minHeadroom + minTailroom;\n  DCHECK_LT(newCapacity, UINT32_MAX);\n\n  // reserveSlow() is dangerous if anyone else is sharing the buffer, as we may\n  // reallocate and free the original buffer.  It should only ever be called if\n  // we are the only user of the buffer.\n  DCHECK(!isSharedOne());",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void IOBuf::reserveSlow(std::size_t minHeadroom, std::size_t minTailroom) {\n  size_t newCapacity = length_;\n  if (!checked_add(&newCapacity, newCapacity, minHeadroom) ||\n      !checked_add(&newCapacity, newCapacity, minTailroom) ||\n      newCapacity > kMaxIOBufSize) {\n    // overflow\n    throw_exception<std::bad_alloc>();\n  }\n\n  // reserveSlow() is dangerous if anyone else is sharing the buffer, as we may\n  // reallocate and free the original buffer.  It should only ever be called if\n  // we are the only user of the buffer.\n  DCHECK(!isSharedOne());",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int msg_parse_fetch (IMAP_HEADER *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp;\n\n  if (!s)\n    return -1;\n\n  while (*s)\n        dprint (1, (debugfile, \"msg_parse_fetch(): bogus INTERNALDATE entry: %s\\n\", s));\n        return -1;\n      }\n      s++;\n      ptmp = tmp;\n      while (*s && *s != '\\\"')\n        *ptmp++ = *s++;\n      if (*s != '\\\"')\n        return -1;\n      s++; /* skip past the trailing \" */\n      *ptmp = 0;\n      h->received = imap_parse_date (tmp);\n    else if (ascii_strncasecmp (\"RFC822.SIZE\", s, 11) == 0)\n    {\n      s += 11;\n      SKIPWS (s);\n      ptmp = tmp;\n      while (isdigit ((unsigned char) *s))\n        *ptmp++ = *s++;\n      *ptmp = 0;\n      if (mutt_atol (tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if (!ascii_strncasecmp (\"BODY\", s, 4) ||",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int msg_parse_fetch (IMAP_HEADER *h, char *s)\n{\n  char tmp[SHORT_STRING];\n  char *ptmp;\n  size_t dlen;\n\n  if (!s)\n    return -1;\n\n  while (*s)\n        dprint (1, (debugfile, \"msg_parse_fetch(): bogus INTERNALDATE entry: %s\\n\", s));\n        return -1;\n      }\n      s++;\n      ptmp = tmp;\n      dlen = sizeof(tmp) - 1;\n      while (*s && *s != '\\\"' && dlen)\n      {\n        *ptmp++ = *s++;\n        dlen--;\n      }\n      if (*s != '\\\"')\n        return -1;\n      s++; /* skip past the trailing \" */\n      *ptmp = 0;\n      h->received = imap_parse_date (tmp);\n    else if (ascii_strncasecmp (\"RFC822.SIZE\", s, 11) == 0)\n    {\n      s += 11;\n      SKIPWS (s);\n      ptmp = tmp;\n      dlen = sizeof(tmp) - 1;\n      while (isdigit ((unsigned char) *s) && dlen)\n      {\n        *ptmp++ = *s++;\n        dlen--;\n      }\n      *ptmp = 0;\n      if (mutt_atol (tmp, &h->content_length) < 0)\n        return -1;\n    }\n    else if (!ascii_strncasecmp (\"BODY\", s, 4) ||",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint16 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)\n{\n        uint8* bufp = buf;\n        int32  bytes_read = 0;\n        uint32 strip, nstrips   = TIFFNumberOfStrips(in);\n        uint32 stripsize = TIFFStripSize(in);\n        uint32 rows = 0;\n        uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n        tsize_t scanline_size = TIFFScanlineSize(in);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "MONGO_EXPORT int bson_append_binary( bson *b, const char *name, char type, const char *str, int len ) {\n    if ( type == BSON_BIN_BINARY_OLD ) {\n        int subtwolen = len + 4;\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+4+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32( b, &subtwolen );\n        bson_append_byte( b, type );\n        bson_append32( b, &len );\n        bson_append( b, str, len );\n    }\n    else {\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32( b, &len );\n        bson_append_byte( b, type );\n        bson_append( b, str, len );\n    }\n    return BSON_OK;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "MONGO_EXPORT int bson_append_binary( bson *b, const char *name, char type, const char *str, size_t len ) {\n    if ( type == BSON_BIN_BINARY_OLD ) {\n        int subtwolen = len + 4;\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+4+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32_as_int( b, ( int )subtwolen );\n        bson_append_byte( b, type );\n        bson_append32_as_int( b, ( int )len );\n        bson_append( b, str, len );\n    }\n    else {\n        if ( bson_append_estart( b, BSON_BINDATA, name, 4+1+len ) == BSON_ERROR )\n            return BSON_ERROR;\n        bson_append32_as_int( b, ( int )len );\n        bson_append_byte( b, type );\n        bson_append( b, str, len );\n    }\n    return BSON_OK;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void show_object(struct object *obj,\n\t\t\tstruct strbuf *path, const char *component,\n\t\t\tvoid *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tfinish_object(obj, path, component, cb_data);\n\tif (info->flags & REV_LIST_QUIET)\n\t\treturn;\n\tshow_object_with_name(stdout, obj, path, component);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void show_object(struct object *obj, const char *name, void *cb_data)\n{\n\tstruct rev_list_info *info = cb_data;\n\tfinish_object(obj, name, cb_data);\n\tif (info->flags & REV_LIST_QUIET)\n\t\treturn;\n\tshow_object_with_name(stdout, obj, name);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "            // this SwitchImm starts.\n            const uint8_t *tablestart = (const uint8_t *)llvh::alignAddr(\n                (const uint8_t *)ip + ip->iSwitchImm.op2, sizeof(uint32_t));\n\n            // Read the offset from the table.\n            const uint32_t *loc =\n                (const uint32_t *)tablestart + uintVal - ip->iSwitchImm.op4;\n\n            ip = IPADD(*loc);\n            DISPATCH;\n          }\n        }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "            // this SwitchImm starts.\n            const uint8_t *tablestart = (const uint8_t *)llvh::alignAddr(\n                (const uint8_t *)ip + ip->iSwitchImm.op2, sizeof(uint32_t));\n\n            // Read the offset from the table.\n            // Must be signed to account for backwards branching.\n            const int32_t *loc =\n                (const int32_t *)tablestart + uintVal - ip->iSwitchImm.op4;\n\n            ip = IPADD(*loc);\n            DISPATCH;\n          }\n        }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (collen > 0)\n\t\t\t\t{\n\t\t\t\t\tcolor = CVAL(in);\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (replen > 0)\n\t\t\t\t{\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (collen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = CVAL(in);\n\t\t\t\t\tif (x & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (replen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && collen > 0)\n\t\t\t\t{\n\t\t\t\t\tcolor = CVAL(in);\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && replen > 0)\n\t\t\t\t{\n\t\t\t\t\t*out = color;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\treplen--;\n\t\t\t\tif ((revcode <= 47) && (revcode >= 16))\n\t\t\t\t{\n\t\t\t\t\treplen = revcode;\n\t\t\t\t\tcollen = 0;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && collen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = CVAL(in);\n\t\t\t\t\tif (x & 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tx = x >> 1;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;\n\t\t\t\t\tcollen--;\n\t\t\t\t}\n\t\t\t\twhile (indexw < width && replen > 0)\n\t\t\t\t{\n\t\t\t\t\tx = last_line[indexw * 4] + color;\n\t\t\t\t\t*out = x;\n\t\t\t\t\tout += 4;\n\t\t\t\t\tindexw++;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {\n\tint i;\n\tif (!bin || !bin->segment_entries) {\n\t\treturn NULL;\n\t}\n\tRList *segments = r_list_newf (free);\n\tfor (i = 0; i < bin->ne_header->SegCount; i++) {\n\t\tRBinSection *bs = R_NEW0 (RBinSection);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tn->m_next = m->m_next;\n\t\t\tm->m_next = NULL;\n\t\t\tn->m_len = 0;\n\t\t\treturn (n);\n\t\t}\n\t\tif (m->m_flags & M_EXT)\n\t\t\tgoto extpacket;\n\t\tif (remain > MHLEN) {\n\t\t\t/* m can't be the lead packet */\n\t\t\tm_align(n, 0);\n\t\t\tn->m_next = m_split(m, len, wait);\n\t\t\tif (n->m_next == NULL) {\n\t\t\t\t(void) m_free(n);\n\t\t\t\treturn (NULL);\n\t\t\t} else {\n\t\t\t\tn->m_len = 0;\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t} else\n\t\t\tm_align(n, remain);\n\t} else if (remain == 0) {\n\t\tn = m->m_next;\n\t\tm->m_next = NULL;\n\t\treturn (n);\n\t} else {\n\t\tMGET(n, wait, m->m_type);\n\t\tif (n == NULL)\n\t\t\treturn (NULL);\n\t\tm_align(n, remain);\n\t}\nextpacket:\n\tif (m->m_flags & M_EXT) {\n\t\tn->m_ext = m->m_ext;\n\t\tMCLADDREFERENCE(m, n);\n\t\tn->m_data = m->m_data + len;\n\t} else {\n\t\tmemcpy(mtod(n, caddr_t), mtod(m, caddr_t) + len, remain);\n\t}\n\tn->m_len = remain;\n\tm->m_len = len;\n\tn->m_next = m->m_next;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tn->m_next = m->m_next;\n\t\t\tm->m_next = NULL;\n\t\t\tn->m_len = 0;\n\t\t\treturn (n);\n\t\t}\n\t\tif ((m->m_flags & M_EXT) == 0 && remain > MHLEN) {\n\t\t\t/* m can't be the lead packet */\n\t\t\tm_align(n, 0);\n\t\t\tn->m_next = m_split(m, len, wait);\n\t\t\tif (n->m_next == NULL) {\n\t\t\t\t(void) m_free(n);\n\t\t\t\treturn (NULL);\n\t\t\t} else {\n\t\t\t\tn->m_len = 0;\n\t\t\t\treturn (n);\n\t\t\t}\n\t\t}\n\t} else if (remain == 0) {\n\t\tn = m->m_next;\n\t\tm->m_next = NULL;\n\t\treturn (n);\n\t} else {\n\t\tMGET(n, wait, m->m_type);\n\t\tif (n == NULL)\n\t\t\treturn (NULL);\n\t}\n\tif (m->m_flags & M_EXT) {\n\t\tn->m_ext = m->m_ext;\n\t\tMCLADDREFERENCE(m, n);\n\t\tn->m_data = m->m_data + len;\n\t} else {\n\t\tm_align(n, remain);\n\t\tmemcpy(mtod(n, caddr_t), mtod(m, caddr_t) + len, remain);\n\t}\n\tn->m_len = remain;\n\tm->m_len = len;\n\tn->m_next = m->m_next;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tbreak;\n\tcase SPL_FS_FILE:\n\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"An object of class %s cannot be cloned\", old_object->ce->name);\n\t\tbreak;\n\t}\n\t\n\tintern->file_class = source->file_class;\n\tintern->info_class = source->info_class;\n\tintern->oth = source->oth;\n\tintern->oth_handler = source->oth_handler;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tbreak;\n\tcase SPL_FS_FILE:\n\t\tphp_error_docref(NULL TSRMLS_CC, E_ERROR, \"An object of class %s cannot be cloned\", old_object->ce->name);\n\t\tbreak;\n\t}\n\n\tintern->file_class = source->file_class;\n\tintern->info_class = source->info_class;\n\tintern->oth = source->oth;\n\tintern->oth_handler = source->oth_handler;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int sendMessageAndForget(short ptype, short paylen, const void* payload) {\n    int ret;\n\n    // Unlike regular sockets, ENet sockets aren't safe to invoke from multiple\n    // threads at once. We have to synchronize them with a lock.\n    if (ServerMajorVersion >= 5) {\n        PltLockMutex(&enetMutex);\n        ret = sendMessageEnet(ptype, paylen, payload);\n        PltUnlockMutex(&enetMutex);\n    }\n    else {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int sendMessageAndForget(short ptype, short paylen, const void* payload) {\n    int ret;\n\n    // Unlike regular sockets, ENet sockets aren't safe to invoke from multiple\n    // threads at once. We have to synchronize them with a lock.\n    if (AppVersionQuad[0] >= 5) {\n        PltLockMutex(&enetMutex);\n        ret = sendMessageEnet(ptype, paylen, payload);\n        PltUnlockMutex(&enetMutex);\n    }\n    else {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tmask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);\n\ttype &= mask;\n\n\talg = crypto_alg_lookup(name, type, mask);\n\tif (!alg) {\n\t\trequest_module(\"%s\", name);\n\n\t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n\t\t      CRYPTO_ALG_NEED_FALLBACK))\n\t\t\trequest_module(\"%s-all\", name);\n\n\t\talg = crypto_alg_lookup(name, type, mask);\n\t}\n\n\tif (alg)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tmask &= ~(CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD);\n\ttype &= mask;\n\n\talg = crypto_alg_lookup(name, type, mask);\n\tif (!alg) {\n\t\trequest_module(\"crypto-%s\", name);\n\n\t\tif (!((type ^ CRYPTO_ALG_NEED_FALLBACK) & mask &\n\t\t      CRYPTO_ALG_NEED_FALLBACK))\n\t\t\trequest_module(\"crypto-%s-all\", name);\n\n\t\talg = crypto_alg_lookup(name, type, mask);\n\t}\n\n\tif (alg)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info;\n\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info = {};\n\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "chpass_principal3_2_svc(chpass3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "chpass_principal3_2_svc(chpass3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ngx_http_lua_copy_request_headers(ngx_http_request_t *sr, ngx_http_request_t *r)\n{\n    ngx_table_elt_t                 *header;\n    ngx_list_part_t                 *part;\n    ngx_uint_t                       i;\n\n    if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    dd(\"before: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n\n    part = &r->headers_in.headers.part;\n    header = part->elts;\n\n    for (i = 0; /* void */; i++) {\n\n        if (i >= part->nelts) {\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        dd(\"setting request header %.*s: %.*s\", (int) header[i].key.len,\n           header[i].key.data, (int) header[i].value.len,\n           header[i].value.data);\n\n        if (ngx_http_lua_set_input_header(sr, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n            return NGX_ERROR;\n        }\n    }\n\n    dd(\"after: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n\n    return NGX_OK;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ngx_http_lua_copy_request_headers(ngx_http_request_t *sr,\n    ngx_http_request_t *pr, int pr_not_chunked)\n{\n    ngx_table_elt_t                 *clh, *header;\n    ngx_list_part_t                 *part;\n    ngx_uint_t                       i;\n    u_char                          *p;\n    off_t                            len;\n\n    dd(\"before: parent req headers count: %d\",\n       (int) pr->headers_in.headers.part.nelts);\n\n    if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    if (sr->request_body && !pr_not_chunked) {\n\n        /* craft our own Content-Length */\n\n        len = sr->request_body->buf ? ngx_buf_size(sr->request_body->buf) : 0;\n\n        clh = ngx_list_push(&sr->headers_in.headers);\n        if (clh == NULL) {\n            return NGX_ERROR;\n        }\n\n        clh->hash = ngx_http_lua_content_length_hash;\n        clh->key = ngx_http_lua_content_length_header_key;\n        clh->lowcase_key = ngx_pnalloc(sr->pool, clh->key.len);\n        if (clh->lowcase_key == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_strlow(clh->lowcase_key, clh->key.data, clh->key.len);\n\n        p = ngx_palloc(sr->pool, NGX_OFF_T_LEN);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        clh->value.data = p;\n        clh->value.len = ngx_sprintf(clh->value.data, \"%O\", len)\n                         - clh->value.data;\n\n        sr->headers_in.content_length = clh;\n        sr->headers_in.content_length_n = len;\n\n        dd(\"sr crafted content-length: %.*s\",\n           (int) sr->headers_in.content_length->value.len,\n           sr->headers_in.content_length->value.data);\n    }\n\n    /* copy the parent request's headers */\n\n    part = &pr->headers_in.headers.part;\n    header = part->elts;\n\n    for (i = 0; /* void */; i++) {\n\n        if (i >= part->nelts) {\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        if (!pr_not_chunked && header[i].key.len == sizeof(\"Content-Length\") - 1\n            && ngx_strncasecmp(header[i].key.data, (u_char *) \"Content-Length\",\n                               sizeof(\"Content-Length\") - 1) == 0)\n        {\n            continue;\n        }\n\n        dd(\"sr copied req header %.*s: %.*s\", (int) header[i].key.len,\n           header[i].key.data, (int) header[i].value.len,\n           header[i].value.data);\n\n        if (ngx_http_lua_set_input_header(sr, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n            return NGX_ERROR;\n        }\n    }\n\n    dd(\"after: parent req headers count: %d\",\n       (int) pr->headers_in.headers.part.nelts);\n\n    return NGX_OK;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void fp2_write_bin(uint8_t *bin, int len, const fp2_t a, int pack) {\n\tfp2_t t;\n\n\tfp2_null(t);\n\n\tRLC_TRY {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void fp2_write_bin(uint8_t *bin, size_t len, const fp2_t a, int pack) {\n\tfp2_t t;\n\n\tfp2_null(t);\n\n\tRLC_TRY {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  char* host;\n  char* port;\n  char* user;\n  char* password;\n  char* mysql_socket;\n  int   result;\n  D_imp_xxh(dbh);\n\n  /* TODO- resolve this so that it is set only if DBI is 1.607 */\n#define TAKE_IMP_DATA_VERSION 1\n#if TAKE_IMP_DATA_VERSION\n\t\t  user ? user : \"NULL\",\n\t\t  password ? password : \"NULL\",\n\t\t  host ? host : \"NULL\",\n\t\t  port ? port : \"NULL\");\n\n  if (!imp_dbh->pmysql) {\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\n  }\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\n  if (!result)\n      Safefree(imp_dbh->pmysql);\n  return result;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  char* port;\n  char* user;\n  char* password;\n  char* mysql_socket;\n  int   result;\n  int\tfresh = 0;\n  D_imp_xxh(dbh);\n\n  /* TODO- resolve this so that it is set only if DBI is 1.607 */\n#define TAKE_IMP_DATA_VERSION 1\n#if TAKE_IMP_DATA_VERSION\n\t\t  password ? password : \"NULL\",\n\t\t  host ? host : \"NULL\",\n\t\t  port ? port : \"NULL\");\n\n  if (!imp_dbh->pmysql) {\n     fresh = 1;\n     Newz(908, imp_dbh->pmysql, 1, MYSQL);\n  }\n  result = mysql_dr_connect(dbh, imp_dbh->pmysql, mysql_socket, host, port, user,\n\t\t\t  password, dbname, imp_dbh) ? TRUE : FALSE;\n  if (fresh && !result) {\n      /* Prevent leaks, but do not free in case of a reconnect. See #97625 */\n      do_error(dbh, mysql_errno(imp_dbh->pmysql),\n              mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n      Safefree(imp_dbh->pmysql);\n      imp_dbh->pmysql = NULL;\n  }\n  return result;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t\tm_inventory_mgr->setInventoryModified(ma->from_inv);\n\t\tif (ma->from_inv != ma->to_inv)\n\t\t\tm_inventory_mgr->setInventoryModified(ma->to_inv);\n\n\t\tbool from_inv_is_current_player =\n\t\t\t(ma->from_inv.type == InventoryLocation::PLAYER) &&\n\t\t\t(ma->from_inv.name == player->getName());\n\n\t\tbool to_inv_is_current_player =\n\t\t\t(ma->to_inv.type == InventoryLocation::PLAYER) &&\n\t\t\t(ma->to_inv.name == player->getName());\n\n\t\tInventoryLocation *remote = from_inv_is_current_player ?\n\t\t\t&ma->to_inv : &ma->from_inv;\n\n\t\t// Check for out-of-range interaction",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\t\tm_inventory_mgr->setInventoryModified(ma->from_inv);\n\t\tif (ma->from_inv != ma->to_inv)\n\t\t\tm_inventory_mgr->setInventoryModified(ma->to_inv);\n\n\t\tbool from_inv_is_current_player = false;\n\t\tif (ma->from_inv.type == InventoryLocation::PLAYER) {\n\t\t\tif (ma->from_inv.name != player->getName())\n\t\t\t\treturn;\n\t\t\tfrom_inv_is_current_player = true;\n\t\t}\n\t\t\n\t\tbool to_inv_is_current_player = false;\n\t\tif (ma->to_inv.type == InventoryLocation::PLAYER) {\n\t\t\tif (ma->to_inv.name != player->getName())\n\t\t\t\treturn;\n\t\t\tto_inv_is_current_player = true;\n\t\t}\n\n\t\tInventoryLocation *remote = from_inv_is_current_player ?\n\t\t\t&ma->to_inv : &ma->from_inv;\n\n\t\t// Check for out-of-range interaction",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  mutt_debug(3, \"Subscribing to %s\\n\", list.name);\n\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  /* escape \\ and \" */\n  imap_quote_string(errstr, sizeof(errstr), list.name);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  mutt_debug(3, \"Subscribing to %s\\n\", list.name);\n\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  /* escape \\ and \" */\n  imap_quote_string(errstr, sizeof(errstr), list.name, true);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "construct_command_line(struct manager_ctx *manager, struct server *server)\n{\n    static char cmd[BUF_SIZE];\n    char *method = manager->method;\n    int i;\n\n    build_config(working_dir, server);\n\n    if (server->method) method = server->method;\n    memset(cmd, 0, BUF_SIZE);\n    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n\n    if (manager->acl != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "construct_command_line(struct manager_ctx *manager, struct server *server)\n{\n    static char cmd[BUF_SIZE];\n    int i;\n    int port;\n\n    port = atoi(server->port);\n\n    build_config(working_dir, manager, server);\n\n    memset(cmd, 0, BUF_SIZE);\n    snprintf(cmd, BUF_SIZE,\n             \"%s --manager-address %s -f %s/.shadowsocks_%d.pid -c %s/.shadowsocks_%d.conf\",\n             executable, manager->manager_address, working_dir, port, working_dir, port);\n\n    if (manager->acl != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "         hashTable[k / 16] |= (1 << (k % 16));\n      }\n   }\n\n   //Write the hash table to the KSZ8851 controller\n   ksz8851WriteReg(interface, KSZ8851_REG_MAHTR0, hashTable[0]);\n   ksz8851WriteReg(interface, KSZ8851_REG_MAHTR1, hashTable[1]);\n   ksz8851WriteReg(interface, KSZ8851_REG_MAHTR2, hashTable[2]);\n   ksz8851WriteReg(interface, KSZ8851_REG_MAHTR3, hashTable[3]);\n\n   //Debug message\n   TRACE_DEBUG(\"  MAHTR0 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_REG_MAHTR0));\n   TRACE_DEBUG(\"  MAHTR1 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_REG_MAHTR1));\n   TRACE_DEBUG(\"  MAHTR2 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_REG_MAHTR2));\n   TRACE_DEBUG(\"  MAHTR3 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_REG_MAHTR3));\n\n   //Successful processing\n   return NO_ERROR;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "         hashTable[k / 16] |= (1 << (k % 16));\n      }\n   }\n\n   //Write the hash table to the KSZ8851 controller\n   ksz8851WriteReg(interface, KSZ8851_MAHTR0, hashTable[0]);\n   ksz8851WriteReg(interface, KSZ8851_MAHTR1, hashTable[1]);\n   ksz8851WriteReg(interface, KSZ8851_MAHTR2, hashTable[2]);\n   ksz8851WriteReg(interface, KSZ8851_MAHTR3, hashTable[3]);\n\n   //Debug message\n   TRACE_DEBUG(\"  MAHTR0 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_MAHTR0));\n   TRACE_DEBUG(\"  MAHTR1 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_MAHTR1));\n   TRACE_DEBUG(\"  MAHTR2 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_MAHTR2));\n   TRACE_DEBUG(\"  MAHTR3 = %04\" PRIX16 \"\\r\\n\", ksz8851ReadReg(interface, KSZ8851_MAHTR3));\n\n   //Successful processing\n   return NO_ERROR;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n\tunsigned long *msr_bitmap;\n\n\tif (is_guest_mode(vcpu))\n\t\tmsr_bitmap = vmx_msr_bitmap_nested;\n\telse if (vcpu->arch.apic_base & X2APIC_ENABLE) {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n\tunsigned long *msr_bitmap;\n\n\tif (is_guest_mode(vcpu))\n\t\tmsr_bitmap = vmx_msr_bitmap_nested;\n\telse if (cpu_has_secondary_exec_ctrls() &&\n\t\t (vmcs_read32(SECONDARY_VM_EXEC_CONTROL) &\n\t\t  SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE)) {\n\t\tif (is_long_mode(vcpu))\n\t\t\tmsr_bitmap = vmx_msr_bitmap_longmode_x2apic;\n\t\telse\n\t\t\tmsr_bitmap = vmx_msr_bitmap_legacy_x2apic;\n\t} else {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "checked_xmalloc (size_t size)\n{\n    alloc_limit_assert (\"checked_xmalloc\", size);\n    return xmalloc (size);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "checked_xmalloc (size_t num, size_t size)\n{\n    size_t res;\n    if (check_mul_overflow(num, size, &res))\n        abort();\n\n    alloc_limit_assert (\"checked_xmalloc\", res);\n    return xmalloc (num, size);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t value;\n\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, &value, 1, 1000);\n\treturn ret >= 0 ? value : ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tint ret;\n\tuint8_t *buffer;\n\tuint8_t value;\n\n\tbuffer = kmalloc(1, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n\t\t\t\t0, reg, buffer, 1, 1000);\n\n\tif (ret >= 0) {\n\t\tvalue = buffer[0];\n\t\tkfree(buffer);\n\t\treturn value;\n\t} else {\n\t\tkfree(buffer);\n\t\treturn ret;\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    if (it != res.headers.end()) {\n      content_type = it->second;\n      res.headers.erase(it);\n    }\n\n    res.headers.emplace(\"Content-Type\",\n                        \"multipart/byteranges; boundary=\" + boundary);\n  }\n\n  auto type = detail::encoding_type(req, res);\n\n  if (res.body.empty()) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    if (it != res.headers.end()) {\n      content_type = it->second;\n      res.headers.erase(it);\n    }\n\n    res.set_header(\"Content-Type\",\n                   \"multipart/byteranges; boundary=\" + boundary);\n  }\n\n  auto type = detail::encoding_type(req, res);\n\n  if (res.body.empty()) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        WINHTTP_HEADER_NAME_BY_INDEX,\n        WINHTTP_NO_OUTPUT_BUFFER,\n        &responseHeadersTempLength,\n        WINHTTP_NO_HEADER_INDEX);\n\n    if ((responseHeadersTemp = (wchar_t*)malloc((size_t)responseHeadersTempLength + 2)) == NULL)\n    {\n        result = HTTPAPI_ALLOC_FAILED;\n        LogError(\"malloc failed: (result = %\" PRI_MU_ENUM \")\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n    }\n    else if (! WinHttpQueryHeaders(\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"WideCharToMultiByte failed\");\n                break;\n            }\n            else if ((tokenTemp = (char*)malloc(sizeof(char) * tokenTemp_size)) == NULL)\n            {\n                result = HTTPAPI_ALLOC_FAILED;\n                LogError(\"malloc failed\");\n                break;\n            }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        WINHTTP_HEADER_NAME_BY_INDEX,\n        WINHTTP_NO_OUTPUT_BUFFER,\n        &responseHeadersTempLength,\n        WINHTTP_NO_HEADER_INDEX);\n\n    size_t malloc_size = safe_add_size_t((size_t)responseHeadersTempLength, 2);\n    if (malloc_size == SIZE_MAX)\n    {\n        LogError(\"Invalid malloc size\");\n        responseHeadersTemp = NULL;\n    }\n    else\n    {\n        responseHeadersTemp = (wchar_t*)malloc(malloc_size);\n    }\n\n    if (responseHeadersTemp == NULL)\n    {\n        result = HTTPAPI_ALLOC_FAILED;\n        LogError(\"malloc failed: (result = %\" PRI_MU_ENUM \")\", MU_ENUM_VALUE(HTTPAPI_RESULT, result));\n    }\n    else if (! WinHttpQueryHeaders(\n            {\n                result = HTTPAPI_STRING_PROCESSING_ERROR;\n                LogError(\"WideCharToMultiByte failed\");\n                break;\n            }\n            else if ((malloc_size = safe_multiply_size_t(sizeof(char), tokenTemp_size)) == SIZE_MAX)\n            {\n                result = HTTPAPI_ALLOC_FAILED;\n                LogError(\"invalid malloc size\");\n                break;\n            }\n            else if ((tokenTemp = (char*)malloc(malloc_size)) == NULL)\n            {\n                result = HTTPAPI_ALLOC_FAILED;\n                LogError(\"malloc failed\");\n                break;\n            }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n\n    for (p = 0; p < 4 && in->data[p]; p++) {\n        int w = inlink->w;\n        int h = inlink->h;\n        int r = s->radius;\n        if (p) {\n            w = s->chroma_w;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "            return AVERROR(ENOMEM);\n        }\n        av_frame_copy_props(out, in);\n    }\n\n    for (p = 0; p < 4 && in->data[p] && in->linesize[p]; p++) {\n        int w = inlink->w;\n        int h = inlink->h;\n        int r = s->radius;\n        if (p) {\n            w = s->chroma_w;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        /* Capture the filenames in the input directory */\n    if ((safiles = getFilenamesInDirectory(dirin)) == NULL)\n        return ERROR_INT(\"safiles not made\", procName, 1);\n\n        /* Generate output text file names */\n    sprintf(charbuf, \"%s/%s.html\", dirout, rootname);\n    mainname = stringNew(charbuf);\n    sprintf(charbuf, \"%s/%s-links.html\", dirout, rootname);\n    linkname = stringNew(charbuf);\n    linknameshort = stringJoin(rootname, \"-links.html\");\n\n        /* Generate the thumbs and views */\n    sathumbs = sarrayCreate(0);\n\n            /* Make and store the thumbnail images */\n        pixGetDimensions(pix, &w, NULL, &d);\n        factor = (l_float32)thumbwidth / (l_float32)w;\n        pixthumb = pixScale(pix, factor, factor);\n        sprintf(charbuf, \"%s_thumb_%03d\", rootname, index);\n        sarrayAddString(sathumbs, charbuf, L_COPY);\n        outname = genPathname(dirout, charbuf);\n        WriteFormattedPix(outname, pixthumb);\n        lept_free(outname);\n        pixDestroy(&pixthumb);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        /* Capture the filenames in the input directory */\n    if ((safiles = getFilenamesInDirectory(dirin)) == NULL)\n        return ERROR_INT(\"safiles not made\", procName, 1);\n\n        /* Generate output text file names */\n    snprintf(charbuf, sizeof(charbuf), \"%s/%s.html\", dirout, rootname);\n    mainname = stringNew(charbuf);\n    snprintf(charbuf, sizeof(charbuf), \"%s/%s-links.html\", dirout, rootname);\n    linkname = stringNew(charbuf);\n    linknameshort = stringJoin(rootname, \"-links.html\");\n\n        /* Generate the thumbs and views */\n    sathumbs = sarrayCreate(0);\n\n            /* Make and store the thumbnail images */\n        pixGetDimensions(pix, &w, NULL, &d);\n        factor = (l_float32)thumbwidth / (l_float32)w;\n        pixthumb = pixScale(pix, factor, factor);\n        snprintf(charbuf, sizeof(charbuf), \"%s_thumb_%03d\", rootname, index);\n        sarrayAddString(sathumbs, charbuf, L_COPY);\n        outname = genPathname(dirout, charbuf);\n        WriteFormattedPix(outname, pixthumb);\n        lept_free(outname);\n        pixDestroy(&pixthumb);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    const CudnnTensorDescriptor& output_nd,\n    const dnn::AlgorithmDesc& algorithm_desc,\n    ScratchAllocator* scratch_allocator) {\n  if (IsTensorMathOpSet(conv) != algorithm_desc.tensor_ops_enabled()) {\n    return tsl::Status(\n        port::error::INTERNAL,\n        \"Mismatch between cudnn conv and algorithm descriptors.\");\n  }\n\n  // Query the size of the workspace and allocate it.\n  size_t size_in_bytes;\n\n  int64_t size_in_bytes_int64_t = size_in_bytes;\n\n  if (ABSL_PREDICT_FALSE(size_in_bytes_int64_t < 0)) {\n    return tsl::Status(\n        port::error::INTERNAL,\n        \"cudnnGetConvolutionBackwardDataWorkspaceSize() returned \"\n        \"negative sizeInBytes value. This could be a cudnn bug.\");\n  }\n\n  if (size_in_bytes_int64_t == 0) {\n    return DeviceMemory<uint8_t>();\n  }\n\n  if (ABSL_PREDICT_FALSE(!scratch_allocator)) {\n    return tsl::Status(port::error::INVALID_ARGUMENT,\n                       \"No scratch allocator provided\");\n  }\n\n  return scratch_allocator->AllocateBytes(size_in_bytes);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    const CudnnTensorDescriptor& output_nd,\n    const dnn::AlgorithmDesc& algorithm_desc,\n    ScratchAllocator* scratch_allocator) {\n  if (IsTensorMathOpSet(conv) != algorithm_desc.tensor_ops_enabled()) {\n    return tsl::Status(\n        tsl::error::INTERNAL,\n        \"Mismatch between cudnn conv and algorithm descriptors.\");\n  }\n\n  // Query the size of the workspace and allocate it.\n  size_t size_in_bytes;\n\n  int64_t size_in_bytes_int64_t = size_in_bytes;\n\n  if (ABSL_PREDICT_FALSE(size_in_bytes_int64_t < 0)) {\n    return tsl::Status(\n        tsl::error::INTERNAL,\n        \"cudnnGetConvolutionBackwardDataWorkspaceSize() returned \"\n        \"negative sizeInBytes value. This could be a cudnn bug.\");\n  }\n\n  if (size_in_bytes_int64_t == 0) {\n    return DeviceMemory<uint8_t>();\n  }\n\n  if (ABSL_PREDICT_FALSE(!scratch_allocator)) {\n    return tsl::Status(tsl::error::INVALID_ARGUMENT,\n                       \"No scratch allocator provided\");\n  }\n\n  return scratch_allocator->AllocateBytes(size_in_bytes);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "rs_filter_graph(RSFilter *filter)\n{\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\tGString *str = g_string_new(\"digraph G {\\n\");\n\n\trs_filter_graph_helper(str, filter);\n\n\tg_string_append_printf(str, \"}\\n\");\n\tg_file_set_contents(\"/tmp/rs-filter-graph\", str->str, str->len, NULL);\n\n\tif (0 != system(\"dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\"))\n\t\tg_warning(\"Calling dot failed\");\n\tif (0 != system(\"gnome-open /tmp/rs-filter-graph.png\"))\n\t\tg_warning(\"Calling gnome-open failed.\");\n\n\tg_string_free(str, TRUE);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "rs_filter_graph(RSFilter *filter)\n{\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\tgchar *dot_filename;\n\tgchar *png_filename;\n\tgchar *command_line;\n\tGString *str = g_string_new(\"digraph G {\\n\");\n\n\trs_filter_graph_helper(str, filter);\n\n\tg_string_append_printf(str, \"}\\n\");\n\n\t/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */\n\tdot_filename = g_strdup_printf(\"/tmp/rs-filter-graph.%u\", g_random_int());\n\tpng_filename = g_strdup_printf(\"%s.%u.png\", dot_filename, g_random_int());\n\n\tg_file_set_contents(dot_filename, str->str, str->len, NULL);\n\n\tcommand_line = g_strdup_printf(\"dot -Tpng >%s <%s\", png_filename, dot_filename);\n\tif (0 != system(command_line))\n\t\tg_warning(\"Calling dot failed\");\n\tg_free(command_line);\n\n\tcommand_line = g_strdup_printf(\"gnome-open %s\", png_filename);\n\tif (0 != system(command_line))\n\t\tg_warning(\"Calling gnome-open failed.\");\n\tg_free(command_line);\n\n\tg_free(dot_filename);\n\tg_free(png_filename);\n\tg_string_free(str, TRUE);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    key.clear();\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    if (*ref_lookup_response.entry_ == nullptr) {\n      maybeCreateInline(ref_lookup_response.entry_, *ref_lookup_response.key_, std::move(value));\n    } else {\n      appendToHeader((*ref_lookup_response.entry_)->value(), value.getStringView());\n      value.clear();\n    }\n  } else {\n    std::list<HeaderEntryImpl>::iterator i = headers_.insert(std::move(key), std::move(value));\n    i->entry_ = i;\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    key.clear();\n    StaticLookupResponse ref_lookup_response = cb(*this);\n    if (*ref_lookup_response.entry_ == nullptr) {\n      maybeCreateInline(ref_lookup_response.entry_, *ref_lookup_response.key_, std::move(value));\n    } else {\n      const uint64_t added_size =\n          appendToHeader((*ref_lookup_response.entry_)->value(), value.getStringView());\n      addSize(added_size);\n      value.clear();\n    }\n  } else {\n    addSize(key.size() + value.size());\n    std::list<HeaderEntryImpl>::iterator i = headers_.insert(std::move(key), std::move(value));\n    i->entry_ = i;\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n  RegClassInfoValid = false;\n  isThumb2 = AFI->isThumb2Function();\n  isThumb1 = AFI->isThumbFunction() && !isThumb2;\n\n  bool Modified = false;\n  for (MachineBasicBlock &MBB : Fn) {\n    Modified |= LoadStoreMultipleOpti(MBB);\n    if (STI->hasV5TOps() && !AFI->shouldSignReturnAddress())\n      Modified |= MergeReturnIntoLDM(MBB);\n    if (isThumb1)\n      Modified |= CombineMovBx(MBB);\n  }\n\n  Allocator.DestroyAll();\n  return Modified;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n  RegClassInfoValid = false;\n  isThumb2 = AFI->isThumb2Function();\n  isThumb1 = AFI->isThumbFunction() && !isThumb2;\n\n  bool Modified = false, ModifiedLDMReturn = false;\n  for (MachineBasicBlock &MBB : Fn) {\n    Modified |= LoadStoreMultipleOpti(MBB);\n    if (STI->hasV5TOps() && !AFI->shouldSignReturnAddress())\n      ModifiedLDMReturn |= MergeReturnIntoLDM(MBB);\n    if (isThumb1)\n      Modified |= CombineMovBx(MBB);\n  }\n  Modified |= ModifiedLDMReturn;\n\n  // If we merged a BX instruction into an LDM, we need to re-calculate whether\n  // LR is restored. This check needs to consider the whole function, not just\n  // the instruction(s) we changed, because there may be other BX returns which\n  // still need LR to be restored.\n  if (ModifiedLDMReturn)\n    ARMFrameLowering::updateLRRestored(Fn);\n\n  Allocator.DestroyAll();\n  return Modified;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )\":mongo:\", 7 );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, strlen( pass ) );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void mongo_pass_digest( const char *user, const char *pass, char hex_digest[33] ) {\n    mongo_md5_state_t st;\n    mongo_md5_byte_t digest[16];\n\n    mongo_md5_init( &st );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )user, ( int )strlen( user ) );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )\":mongo:\", 7 );\n    mongo_md5_append( &st, ( const mongo_md5_byte_t * )pass, ( int )strlen( pass ) );\n    mongo_md5_finish( &st, digest );\n    digest2hex( digest, hex_digest );\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  POP_CACHE *cache;\n  HEADER *h = ctx->hdrs[msgno];\n  unsigned short bcache = 1;\n\n  /* see if we already have the message in body cache */\n  if ((msg->fp = mutt_bcache_get (pop_data->bcache, h->data)))\n    return 0;\n\n  /*\n   * see if we already have the message in our cache in\n   * case $message_cachedir is unset\n\n    mutt_progress_init (&progressbar, _(\"Fetching message...\"),\n\t\t\tMUTT_PROGRESS_SIZE, NetInc, h->content->length + h->content->offset - 1);\n\n    /* see if we can put in body cache; use our cache as fallback */\n    if (!(msg->fp = mutt_bcache_put (pop_data->bcache, h->data, 1)))\n    {\n      /* no */\n      bcache = 0;\n      mutt_mktemp (path, sizeof (path));\n      if (!(msg->fp = safe_fopen (path, \"w+\")))\n\n  /* Update the header information.  Previously, we only downloaded a\n   * portion of the headers, those required for the main display.\n   */\n  if (bcache)\n    mutt_bcache_commit (pop_data->bcache, h->data);\n  else\n  {\n    cache->index = h->index;\n    cache->path = safe_strdup (path);\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  POP_CACHE *cache;\n  HEADER *h = ctx->hdrs[msgno];\n  unsigned short bcache = 1;\n\n  /* see if we already have the message in body cache */\n  if ((msg->fp = mutt_bcache_get (pop_data->bcache, cache_id (h->data))))\n    return 0;\n\n  /*\n   * see if we already have the message in our cache in\n   * case $message_cachedir is unset\n\n    mutt_progress_init (&progressbar, _(\"Fetching message...\"),\n\t\t\tMUTT_PROGRESS_SIZE, NetInc, h->content->length + h->content->offset - 1);\n\n    /* see if we can put in body cache; use our cache as fallback */\n    if (!(msg->fp = mutt_bcache_put (pop_data->bcache, cache_id (h->data), 1)))\n    {\n      /* no */\n      bcache = 0;\n      mutt_mktemp (path, sizeof (path));\n      if (!(msg->fp = safe_fopen (path, \"w+\")))\n\n  /* Update the header information.  Previously, we only downloaded a\n   * portion of the headers, those required for the main display.\n   */\n  if (bcache)\n    mutt_bcache_commit (pop_data->bcache, cache_id (h->data));\n  else\n  {\n    cache->index = h->index;\n    cache->path = safe_strdup (path);\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "inline typename V::VariantType FBUnserializer<V>::unserializeThing() {\n  size_t code = nextCode();\n\n  switch (code) {\n    case FB_SERIALIZE_BYTE:\n    case FB_SERIALIZE_I16:\n    case FB_SERIALIZE_I32:\n    case FB_SERIALIZE_I64:\n      return V::fromInt64(unserializeInt64());\n    case FB_SERIALIZE_VARCHAR:\n    case FB_SERIALIZE_STRING:\n      return V::fromString(unserializeString());\n    case FB_SERIALIZE_STRUCT:\n      return V::fromMap(unserializeMap());\n    case FB_SERIALIZE_NULL:\n      ++p_;\n      return V::createNull();\n    case FB_SERIALIZE_DOUBLE:\n      return V::fromDouble(unserializeDouble());\n    case FB_SERIALIZE_BOOLEAN:\n      return V::fromBool(unserializeBoolean());\n    case FB_SERIALIZE_VECTOR:\n      return V::fromVector(unserializeVector());\n    case FB_SERIALIZE_LIST:\n      return V::fromVector(unserializeList());\n    case FB_SERIALIZE_SET:\n      return V::fromSet(unserializeSet());\n    default:\n      throw UnserializeError(\"Invalid code: \" + folly::to<std::string>(code)\n                             + \" at location \" + folly::to<std::string>(p_));\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "FBUnserializer<V>::unserializeThing(size_t depth) {\n  if (UNLIKELY(depth > 1024)) {\n    throw UnserializeError(\"depth > 1024\");\n  }\n\n  size_t code = nextCode();\n\n  switch (code) {\n    case FB_SERIALIZE_BYTE:\n    case FB_SERIALIZE_I16:\n    case FB_SERIALIZE_I32:\n    case FB_SERIALIZE_I64:\n      return V::fromInt64(unserializeInt64());\n    case FB_SERIALIZE_VARCHAR:\n    case FB_SERIALIZE_STRING:\n      return V::fromString(unserializeString());\n    case FB_SERIALIZE_STRUCT:\n      return V::fromMap(unserializeMap(depth));\n    case FB_SERIALIZE_NULL:\n      ++p_;\n      return V::createNull();\n    case FB_SERIALIZE_DOUBLE:\n      return V::fromDouble(unserializeDouble());\n    case FB_SERIALIZE_BOOLEAN:\n      return V::fromBool(unserializeBoolean());\n    case FB_SERIALIZE_VECTOR:\n      return V::fromVector(unserializeVector(depth));\n    case FB_SERIALIZE_LIST:\n      return V::fromVector(unserializeList(depth));\n    case FB_SERIALIZE_SET:\n      return V::fromSet(unserializeSet(depth));\n    default:\n      throw UnserializeError(\"Invalid code: \" + folly::to<std::string>(code)\n                             + \" at location \" + folly::to<std::string>(p_));\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void svhandler_flash_erase_sector(void) {\n  uint32_t sector = _param_1;\n\n  // Do not allow firmware to erase bootstrap or bootloader sectors.\n  if ((sector == FLASH_BOOTSTRAP_SECTOR) ||\n      (sector >= FLASH_BOOT_SECTOR_FIRST && sector <= FLASH_BOOT_SECTOR_LAST)) {\n    return;\n  }\n\n  // Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void svhandler_flash_erase_sector(void) {\n  uint8_t sector = _param_1;\n\n  // Verify requested sector is allowed.\n  if (!allow_svhandler_flash_sector_num(sector)) return;\n\n  // Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tconst char *curl_url;\n\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\n\tif (submodule_url_is_relative(url)) {\n\t\t/*\n\t\t * This could be appended to an http URL and url-decoded;\n\t\t * check for malicious characters.\n\t\t */\n\t\tchar *decoded = url_decode(url);\n\t\tint has_nl = !!strchr(decoded, '\\n');\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\t}\n\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tif (looks_like_command_line_option(url))\n\t\treturn -1;\n\n\tif (submodule_url_is_relative(url)) {\n\t\tchar *decoded;\n\t\tconst char *next;\n\t\tint has_nl;\n\n\t\t/*\n\t\t * This could be appended to an http URL and url-decoded;\n\t\t * check for malicious characters.\n\t\t */\n\t\tdecoded = url_decode(url);\n\t\thas_nl = !!strchr(decoded, '\\n');\n\n\t\tfree(decoded);\n\t\tif (has_nl)\n\t\t\treturn -1;\n\n\t\t/*\n\t\t * URLs which escape their root via \"../\" can overwrite\n\t\t * the host field and previous components, resolving to\n\t\t * URLs like https::example.com/submodule.git that were\n\t\t * susceptible to CVE-2020-11008.\n\t\t */\n\t\tif (count_leading_dotdots(url, &next) > 0 &&\n\t\t    *next == ':')\n\t\t\treturn -1;\n\t}\n\n\telse if (url_to_curl_url(url, &curl_url)) {\n\t\tstruct credential c = CREDENTIAL_INIT;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      strings::StrCat(ndef->name(), \"_init_ord_\", device_ordinal);\n\n  TF_RETURN_IF_ERROR(\n      InstantiatePartition(*init_graph, fname, device, &fhandle, nullptr));\n\n  FunctionLibraryRuntime::Options opts;\n  opts.step_container = ctx->step_container();\n  opts.cancellation_manager = ctx->cancellation_manager();\n  opts.stats_collector = ctx->stats_collector();\n\n  // Blocking on threads in the same thread pool is disallowed because",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      strings::StrCat(ndef->name(), \"_init_ord_\", device_ordinal);\n\n  TF_RETURN_IF_ERROR(\n      InstantiatePartition(*init_graph, fname, device, &fhandle, nullptr));\n\n  FunctionLibraryRuntime::Options opts(ctx->step_id());\n  opts.step_container = ctx->step_container();\n  opts.cancellation_manager = ctx->cancellation_manager();\n  opts.stats_collector = ctx->stats_collector();\n\n  // Blocking on threads in the same thread pool is disallowed because",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  imp_dbh->enable_utf8 = FALSE;  /* initialize mysql_enable_utf8 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    do_error(dbh, mysql_errno(imp_dbh->pmysql),\n            mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  imp_dbh->enable_utf8 = FALSE;  /* initialize mysql_enable_utf8 */\n#endif\n\n  if (!my_login(aTHX_ dbh, imp_dbh))\n  {\n    if(imp_dbh->pmysql)\n        do_error(dbh, mysql_errno(imp_dbh->pmysql),\n                mysql_error(imp_dbh->pmysql) ,mysql_sqlstate(imp_dbh->pmysql));\n    return FALSE;\n  }\n\n    /*\n     *  Tell DBI, that dbh->disconnect should be called for this handle",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "            LogError(\"NULL pointer error\");\n        }\n        else\n        {\n            /* Here we got some bytes so we'll buffer them so the receive functions can consumer it */\n            new_received_bytes = (unsigned char*)realloc(http_instance->received_bytes, http_instance->received_bytes_count + size);\n            if (new_received_bytes == NULL)\n            {\n                http_instance->is_io_error = 1;\n                LogError(\"Error allocating memory for received data\");\n            }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "            LogError(\"NULL pointer error\");\n        }\n        else\n        {\n            /* Here we got some bytes so we'll buffer them so the receive functions can consumer it */\n            size_t malloc_size = http_instance->received_bytes_count + size;\n            if (malloc_size < size)\n            {\n                // check for int overflow\n                new_received_bytes = NULL;\n                LogError(\"Invalid size parameter\");\n            }\n            else\n            {\n                new_received_bytes = (unsigned char*)realloc(http_instance->received_bytes, malloc_size);\n            }\n\n            if (new_received_bytes == NULL)\n            {\n                http_instance->is_io_error = 1;\n                LogError(\"Error allocating memory for received data\");\n            }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void MSG_WriteBits( msg_t *msg, int value, int bits ) {\n\tint\ti;\n\n\toldsize += bits;\n\n\t// this isn't an exact overflow check, but close enough\n\tif ( msg->maxsize - msg->cursize < 4 ) {\n\t\tmsg->overflowed = qtrue;\n\t\treturn;\n\t}\n\n\tif ( bits == 0 || bits < -31 || bits > 32 ) {\n\t\tCom_Error( ERR_DROP, \"MSG_WriteBits: bad bits %i\", bits );\n\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t}\n\n\tif ( msg->oob ) {\n\t\tif ( bits == 8 ) {\n\t\t\tmsg->data[msg->cursize] = value;\n\t\t\tmsg->cursize += 1;\n\t\t\tmsg->bit += 8;\n\t\t} else if ( bits == 16 ) {\n\t\t}\n\t} else {\n\t\tvalue &= (0xffffffff >> (32 - bits));\n\t\tif ( bits&7 ) {\n\t\t\tint nbits;\n\t\t\tnbits = bits&7;\n\t\t\tfor( i = 0; i < nbits; i++ ) {\n\t\t\t\tHuff_putBit( (value & 1), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 1);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif ( bits ) {\n\t\t\tfor( i = 0; i < bits; i += 8 ) {\n\t\t\t\tHuff_offsetTransmit( &msgHuff.compressor, (value & 0xff), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 8);\n\t\t\t}\n\t\t}\n\t\tmsg->cursize = (msg->bit >> 3) + 1;\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void MSG_WriteBits( msg_t *msg, int value, int bits ) {\n\tint\ti;\n\n\toldsize += bits;\n\n\tif ( msg->overflowed ) {\n\t\treturn;\n\t}\n\n\tif ( bits == 0 || bits < -31 || bits > 32 ) {\n\t\tCom_Error( ERR_DROP, \"MSG_WriteBits: bad bits %i\", bits );\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t}\n\n\tif ( msg->oob ) {\n\t\tif ( msg->cursize + ( bits >> 3 ) > msg->maxsize ) {\n\t\t\tmsg->overflowed = qtrue;\n\t\t\treturn;\n\t\t}\n\n\t\tif ( bits == 8 ) {\n\t\t\tmsg->data[msg->cursize] = value;\n\t\t\tmsg->cursize += 1;\n\t\t\tmsg->bit += 8;\n\t\t} else if ( bits == 16 ) {\n\t} else {\n\t\tvalue &= (0xffffffff >> (32 - bits));\n\t\tif ( bits&7 ) {\n\t\t\tint nbits;\n\t\t\tnbits = bits&7;\n\t\t\tif ( msg->bit + nbits > msg->maxsize << 3 ) {\n\t\t\t\tmsg->overflowed = qtrue;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor( i = 0; i < nbits; i++ ) {\n\t\t\t\tHuff_putBit( (value & 1), msg->data, &msg->bit );\n\t\t\t\tvalue = (value >> 1);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif ( bits ) {\n\t\t\tfor( i = 0; i < bits; i += 8 ) {\n\t\t\t\tHuff_offsetTransmit( &msgHuff.compressor, (value & 0xff), msg->data, &msg->bit, msg->maxsize << 3 );\n\t\t\t\tvalue = (value >> 8);\n\n\t\t\t\tif ( msg->bit > msg->maxsize << 3 ) {\n\t\t\t\t\tmsg->overflowed = qtrue;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmsg->cursize = (msg->bit >> 3) + 1;\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "          stl_reverse_facet\n          (stl, stl->neighbors_start[facet_num].neighbor[j]);\n        }\n      }\n      /* If this edge of the facet is connected: */\n      if(stl->neighbors_start[facet_num].neighbor[j] != -1) {\n        /* If we haven't fixed this facet yet, add it to the list: */\n        if(norm_sw[stl->neighbors_start[facet_num].neighbor[j]] != 1) {\n          /* Add node to beginning of list. */\n          newn = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n          if(newn == NULL) perror(\"stl_fix_normal_directions\");",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "          stl_reverse_facet\n          (stl, stl->neighbors_start[facet_num].neighbor[j]);\n        }\n      }\n      /* If this edge of the facet is connected: */\n      if(stl->neighbors_start[facet_num].neighbor[j] != -1 &&\n         stl->neighbors_start[facet_num].neighbor[j] < stl->stats.number_of_facets*sizeof(char)) {\n        /* If we haven't fixed this facet yet, add it to the list: */\n        if(norm_sw[stl->neighbors_start[facet_num].neighbor[j]] != 1) {\n          /* Add node to beginning of list. */\n          newn = (struct stl_normal*)malloc(sizeof(struct stl_normal));\n          if(newn == NULL) perror(\"stl_fix_normal_directions\");",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length, \n                                         uint32 width, uint16 spp,\n                                         struct dump_opts *dump)\n  {\n  int i, j, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;\n  int32  bytes_read = 0;\n  uint16 bps, nstrips, planar, strips_per_sample;\n  uint32 src_rowsize, dst_rowsize, rows_processed, rps;\n  uint32 rows_this_strip = 0;\n  tsample_t s;\n  tstrip_t  strip;\n  tsize_t scanlinesize = TIFFScanlineSize(in);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length, \n                                         uint32 width, uint16 spp,\n                                         struct dump_opts *dump)\n  {\n  int i, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;\n  uint32 j;\n  int32  bytes_read = 0;\n  uint16 bps, planar;\n  uint32 nstrips;\n  uint32 strips_per_sample;\n  uint32 src_rowsize, dst_rowsize, rows_processed, rps;\n  uint32 rows_this_strip = 0;\n  tsample_t s;\n  tstrip_t  strip;\n  tsize_t scanlinesize = TIFFScanlineSize(in);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    // Note: While this code performs some basic verifications, it generally\n    // assumes consistent op defs and attributes. If more complete\n    // verifications are needed, they should be done by separately, and in a\n    // way that can be reused for type inference.\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        if (attr == nullptr) {\n          return Status(\n              error::INVALID_ARGUMENT,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    // Note: While this code performs some basic verifications, it generally\n    // assumes consistent op defs and attributes. If more complete\n    // verifications are needed, they should be done by separately, and in a\n    // way that can be reused for type inference.\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(j);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        if (attr == nullptr) {\n          return Status(\n              error::INVALID_ARGUMENT,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int lmf_header_load(lmf_header *lmfh, RBuffer *buf, Sdb *db) {\n\tif (r_buf_size (buf) < sizeof (lmf_header)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, \"iiiiiiiicccciiiicc\", 1) < QNX_HDR_SIZE) {\n\t\treturn false;\n\t}\n\tr_strf_buffer (32);\n\tsdb_set (db, \"qnx.version\", r_strf (\"0x%xH\", lmfh->version), 0);\n\tsdb_set (db, \"qnx.cflags\", r_strf (\"0x%xH\", lmfh->cflags), 0);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int lmf_header_load(lmf_header *lmfh, RBuffer *buf, Sdb *db) {\n\tif (r_buf_size (buf) < sizeof (lmf_header)) {\n\t\treturn false;\n\t}\n\tif (r_buf_fread_at (buf, QNX_HEADER_ADDR, (ut8 *) lmfh, \"iiiiiiiicccciiiicc\", 1) != QNX_HDR_SIZE) {\n\t\treturn false;\n\t}\n\tr_strf_buffer (32);\n\tsdb_set (db, \"qnx.version\", r_strf (\"0x%xH\", lmfh->version), 0);\n\tsdb_set (db, \"qnx.cflags\", r_strf (\"0x%xH\", lmfh->cflags), 0);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int jas_matrix_resize(jas_matrix_t *matrix, int numrows, int numcols)\n{\n\tint size;\n\tint i;\n\n\tsize = numrows * numcols;\n\tif (size > matrix->datasize_ || numrows > matrix->maxrows_) {\n\t\treturn -1;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int jas_matrix_resize(jas_matrix_t *matrix, jas_matind_t numrows,\n  jas_matind_t numcols)\n{\n\tjas_matind_t size;\n\tjas_matind_t i;\n\n\tsize = numrows * numcols;\n\tif (size > matrix->datasize_ || numrows > matrix->maxrows_) {\n\t\treturn -1;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    auto usersessionIt = sessionMap.find(sessionId);\n    if (usersessionIt == sessionMap.end()){\n      cout << \"Bad session ID, redirecting to login.\" << endl;\n      body = getLogin();\n    } else\n      uid = sessionMap[sessionId];\n  }\n  map<string, string> resHeaders;\n  resHeaders[\"Server\"] = \"CSE461\";\n  resHeaders[\"Content-Type\"] = \"text/html; charset=UTF-8\";\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    auto usersessionIt = sessionMap.find(sessionId);\n    if (usersessionIt == sessionMap.end()){\n      cout << \"Bad session ID, redirecting to login.\" << endl;\n      body = getLogin();\n    } else\n      uid = usersessionIt->second;\n  }\n  map<string, string> resHeaders;\n  resHeaders[\"Server\"] = \"CSE461\";\n  resHeaders[\"Content-Type\"] = \"text/html; charset=UTF-8\";\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    dwarfstring_constructor_static(&m1,locallinebuf,\n        sizeof(locallinebuf));\n    if(!is_single_table && is_actuals_table) {\n        dwarfstring_append_printf_s(&m1,\"%-15s \",(char *)prefix);\n        dwarfstring_append_printf_i(&m1,\"%3d \",opcode);\n        dwarfstring_append_printf_u(&m1,\"0x%\" DW_PR_XZEROS DW_PR_DUx ,\n            regs->lr_address);\n        dwarfstring_append_printf_u(&m1,\"/%01u\",regs->lr_op_index);\n        dwarfstring_append_printf_u(&m1,\" %5lu\", regs->lr_line);\n        dwarfstring_append_printf_u(&m1,\" %3d\",regs->lr_isa);\n        dwarfstring_append_printf_i(&m1,\"   %1d\", regs->lr_basic_block);\n        dwarfstring_append_printf_i(&m1,\"%1d\\n\",  regs->lr_end_sequence);\n        _dwarf_printf(dbg,dwarfstring_string(&m1));\n        dwarfstring_destructor(&m1);\n        return;\n    }\n    if(!is_single_table && !is_actuals_table) {\n            regs->lr_subprogram) {\n            dwarfstring_append_printf_u(&m1,\n                \"   x%02\" DW_PR_DUx ,\n                regs->lr_discriminator); /* DWARF4 */\n            dwarfstring_append_printf_u(&m1,\n                \"  x%02\" DW_PR_DUx , regs->lr_call_context); /* EXPERIMENTAL */\n            dwarfstring_append_printf_u(&m1,\n                \"  x%02\" DW_PR_DUx , regs->lr_subprogram); /* EXPERIMENTAL */\n            dwarfstring_append_printf_i(&m1,\n                \"  %1d\", regs->lr_is_stmt);\n            dwarfstring_append_printf_i(&m1,\n                \"%1d\", (int) regs->lr_isa);\n            dwarfstring_append_printf_i(&m1,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    dwarfstring_constructor_static(&m1,locallinebuf,\n        sizeof(locallinebuf));\n    if(!is_single_table && is_actuals_table) {\n        dwarfstring_append_printf_s(&m1,\"%-15s \",(char *)prefix);\n        dwarfstring_append_printf_i(&m1,\"%3d \",opcode);\n        dwarfstring_append_printf_u(&m1,\"0x%\" DW_PR_XZEROS DW_PR_DUx,\n            regs->lr_address);\n        dwarfstring_append_printf_u(&m1,\"/%01u\",regs->lr_op_index);\n        dwarfstring_append_printf_u(&m1,\" %5lu\", regs->lr_line);\n        dwarfstring_append_printf_u(&m1,\" %3d\",regs->lr_isa);\n        dwarfstring_append_printf_i(&m1,\"   %1d\",\n            regs->lr_basic_block);\n        dwarfstring_append_printf_i(&m1,\"%1d\\n\",\n            regs->lr_end_sequence);\n        _dwarf_printf(dbg,dwarfstring_string(&m1));\n        dwarfstring_destructor(&m1);\n        return;\n    }\n    if(!is_single_table && !is_actuals_table) {\n            regs->lr_subprogram) {\n            dwarfstring_append_printf_u(&m1,\n                \"   x%02\" DW_PR_DUx ,\n                regs->lr_discriminator); /* DWARF4 */\n            dwarfstring_append_printf_u(&m1,\n                \"  x%02\" DW_PR_DUx,\n                regs->lr_call_context); /* EXPERIMENTAL */\n            dwarfstring_append_printf_u(&m1,\n                \"  x%02\" DW_PR_DUx ,\n                regs->lr_subprogram); /* EXPERIMENTAL */\n            dwarfstring_append_printf_i(&m1,\n                \"  %1d\", regs->lr_is_stmt);\n            dwarfstring_append_printf_i(&m1,\n                \"%1d\", (int) regs->lr_isa);\n            dwarfstring_append_printf_i(&m1,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static inline u32 net_hash_mix(const struct net *net)\n{\n#ifdef CONFIG_NET_NS\n\treturn (u32)(((unsigned long)net) >> ilog2(sizeof(*net)));\n#else\n\treturn 0;\n#endif\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static inline u32 net_hash_mix(const struct net *net)\n{\n\treturn net->hash_mix;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "       || s[1] != 0x01\n       || s[padlen+2] != 0x00) {\n\treturn \"3\"\"SIG padding does not check out\";\n    }\n\n    s += padlen + 3;\n    (*psig) = s;\n\n    /* return SUCCESS */\n    return NULL;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "       || s[1] != 0x01\n       || s[padlen+2] != 0x00) {\n\treturn \"3\"\"SIG padding does not check out\";\n    }\n\n    /* signature starts after ASN wrapped padding [00,01,FF..FF,00] */\n    (*psig) = s + padlen + 3;\n\n    /* verify padding contents */\n    {\n        const u_char *p;\n        size_t cnt_ffs = 0;\n\n        for (p = s+2; p < s+padlen+2; p++)\n            if (*p == 0xFF)\n                cnt_ffs ++;\n\n        if (cnt_ffs != padlen)\n            return \"4\" \"invalid Padding String\";\n    }\n\n    /* return SUCCESS */\n    return NULL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void pp_mil_k8(fp8_t r, ep2_t *t, ep2_t *q, ep_t *p, int m, bn_t a) {\n\tfp8_t l;\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep2_t *_q = RLC_ALLOCA(ep2_t, m);\n\tint i, j, len = bn_bits(a) + 1;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tif (m == 0) {\n\t\treturn;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void pp_mil_k8(fp8_t r, ep2_t *t, ep2_t *q, ep_t *p, int m, bn_t a) {\n\tfp8_t l;\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep2_t *_q = RLC_ALLOCA(ep2_t, m);\n\tsize_t len = bn_bits(a) + 1;\n\tint i, j;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tif (m == 0) {\n\t\treturn;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\nstatic void bfq_idle_slice_timer_body(struct bfq_queue *bfqq)\n{\n\tstruct bfq_data *bfqd = bfqq->bfqd;\n\tenum bfqq_expiration reason;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\tbfq_clear_bfqq_wait_request(bfqq);\n\n\tif (bfqq != bfqd->in_service_queue) {\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t\treturn;\n\t}\n\n\tif (bfq_bfqq_budget_timeout(bfqq))\n\t\t/*\n\t\t * Also here the queue can be safely expired\n\t\t * for budget timeout without wasting\n\t\t * guarantees\n\t\t */\n\t\treason = BFQQE_BUDGET_TIMEOUT;\n\telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n\t\t/*\n\t\t * The queue may not be empty upon timer expiration,\n\t\t * because we may not disable the timer when the\n\t\t * first request of the in-service queue arrives\n\t\t * during disk idling.\n\t\t */\n\t\treason = BFQQE_TOO_IDLE;\n\telse\n\t\tgoto schedule_dispatch;\n\n\tbfq_bfqq_expire(bfqd, bfqq, true, reason);\n\nschedule_dispatch:\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\tbfq_schedule_dispatch(bfqd);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void\nbfq_idle_slice_timer_body(struct bfq_data *bfqd, struct bfq_queue *bfqq)\n{\n\tenum bfqq_expiration reason;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&bfqd->lock, flags);\n\n\t/*\n\t * Considering that bfqq may be in race, we should firstly check\n\t * whether bfqq is in service before doing something on it. If\n\t * the bfqq in race is not in service, it has already been expired\n\t * through __bfq_bfqq_expire func and its wait_request flags has\n\t * been cleared in __bfq_bfqd_reset_in_service func.\n\t */\n\tif (bfqq != bfqd->in_service_queue) {\n\t\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\t\treturn;\n\t}\n\n\tbfq_clear_bfqq_wait_request(bfqq);\n\n\tif (bfq_bfqq_budget_timeout(bfqq))\n\t\t/*\n\t\t * Also here the queue can be safely expired\n\t\t * for budget timeout without wasting\n\t\t * guarantees\n\t\t */\n\t\treason = BFQQE_BUDGET_TIMEOUT;\n\telse if (bfqq->queued[0] == 0 && bfqq->queued[1] == 0)\n\t\t/*\n\t\t * The queue may not be empty upon timer expiration,\n\t\t * because we may not disable the timer when the\n\t\t * first request of the in-service queue arrives\n\t\t * during disk idling.\n\t\t */\n\t\treason = BFQQE_TOO_IDLE;\n\telse\n\t\tgoto schedule_dispatch;\n\n\tbfq_bfqq_expire(bfqd, bfqq, true, reason);\n\nschedule_dispatch:\n\tspin_unlock_irqrestore(&bfqd->lock, flags);\n\tbfq_schedule_dispatch(bfqd);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t    REG_EXTENDED|REG_NEWLINE|\n\t\t    ((m->str_flags & STRING_IGNORE_CASE) ? REG_ICASE : 0));\n\t\tif (rc) {\n\t\t\tfile_regerror(&rx, rc, ms);\n\t\t\tv = (uint64_t)-1;\n\t\t} else {\n\t\t\tregmatch_t pmatch[1];\n#ifndef REG_STARTEND\n#define\tREG_STARTEND\t0\n\t\t\tsize_t l = ms->search.s_len - 1;\n\t\t\tchar c = ms->search.s[l];\n\t\t\t((char *)(intptr_t)ms->search.s)[l] = '\\0';\n#else\n\t\t\tpmatch[0].rm_so = 0;\n\t\t\tpmatch[0].rm_eo = ms->search.s_len;\n#endif\n\t\t\trc = file_regexec(&rx, (const char *)ms->search.s,\n\t\t\t    1, pmatch, REG_STARTEND);\n#if REG_STARTEND == 0\n\t\t\t((char *)(intptr_t)ms->search.s)[l] = c;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t    ((m->str_flags & STRING_IGNORE_CASE) ? REG_ICASE : 0));\n\t\tif (rc) {\n\t\t\tfile_regerror(&rx, rc, ms);\n\t\t\tv = (uint64_t)-1;\n\t\t} else {\n#ifndef REG_STARTEND\n\t\t\tchar c;\n#endif\n\t\t\tregmatch_t pmatch[1];\n\t\t\tsize_t slen = ms->search.s_len;\n\t\t\t/* Limit by offset if requested */\n\t\t\tif (m->str_range > 0)\n\t\t\t\tslen = MIN(slen, m->str_range);\n#ifndef REG_STARTEND\n#define\tREG_STARTEND\t0\n\t\t\tif (slen != 0)\n\t\t\t\tslen--;\n\t\t\tc = ms->search.s[slen];\n\t\t\t((char *)(intptr_t)ms->search.s)[slen] = '\\0';\n#else\n\t\t\tpmatch[0].rm_so = 0;\n\t\t\tpmatch[0].rm_eo = slen;\n#endif\n\t\t\trc = file_regexec(&rx, (const char *)ms->search.s,\n\t\t\t    1, pmatch, REG_STARTEND);\n#if REG_STARTEND == 0\n\t\t\t((char *)(intptr_t)ms->search.s)[l] = c;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "mm_answer_pam_free_ctx(int sock, Buffer *m)\n{\n\n\tdebug3(\"%s\", __func__);\n\t(sshpam_device.free_ctx)(sshpam_ctxt);\n\tbuffer_clear(m);\n\tmm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"pam\";\n\treturn (sshpam_authok == sshpam_ctxt);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "mm_answer_pam_free_ctx(int sock, Buffer *m)\n{\n\tint r = sshpam_authok != NULL && sshpam_authok == sshpam_ctxt;\n\n\tdebug3(\"%s\", __func__);\n\t(sshpam_device.free_ctx)(sshpam_ctxt);\n\tsshpam_ctxt = sshpam_authok = NULL;\n\tbuffer_clear(m);\n\tmm_request_send(sock, MONITOR_ANS_PAM_FREE_CTX, m);\n\tauth_method = \"keyboard-interactive\";\n\tauth_submethod = \"pam\";\n\treturn r;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "WRITE_JSON_ELEMENT(ArrStart) {\n    /* increase depth, save: before first array entry no comma needed. */\n    ctx->commaNeeded[++ctx->depth] = false;\n    return writeChar(ctx, '[');\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "WRITE_JSON_ELEMENT(ObjStart) {\n    /* increase depth, save: before first key-value no comma needed. */\n    if(ctx->depth >= UA_JSON_ENCODING_MAX_RECURSION)\n        return UA_STATUSCODE_BADENCODINGERROR;\n    ctx->depth++;\n    ctx->commaNeeded[ctx->depth] = false;\n    return writeChar(ctx, '{');\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX])\n\t\treturn -EINVAL;\n\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n\tstruct nfc_dev *dev;\n\tu32 device_idx, target_idx;\n\tint rc;\n\n\tif (!info->attrs[NFC_ATTR_DEVICE_INDEX] ||\n\t    !info->attrs[NFC_ATTR_TARGET_INDEX])\n\t\treturn -EINVAL;\n\n\tdevice_idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]);\n\n\tdev = nfc_get_device(device_idx);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      TF_RETURN_IF_ERROR(context->allocate_temp(\n          DT_BOOL, TensorShape({dense_rows}), &empty_row_indicator_t));\n      empty_row_indicator = empty_row_indicator_t.vec<bool>().data();\n    }\n\n    TF_RETURN_IF_ERROR(wrap_kernel_call(ComputeEmptyRowIndicatorKernel<Tindex>,\n                                        /*device=*/device, /*size=*/dense_rows,\n                                        elements_per_row, empty_row_indicator));\n\n    // For each row, the number of empty rows up to and including that row.\n    Tensor num_empty_rows_through_t;\n    TF_RETURN_IF_ERROR(context->allocate_temp(\n        index_type, TensorShape({dense_rows}), &num_empty_rows_through_t));\n                             num_empty_rows_through, output_indices,\n                             output_values, reverse_index_map),\n            done);\n      }\n\n      OP_REQUIRES_OK_ASYNC(\n          context,\n          wrap_kernel_call(ScatterNewElementsKernel<T, Tindex>,\n                           /*device=*/device, /*size=*/dense_rows, rank,\n                           default_value, num_empty_rows_through,\n                           input_row_ends, empty_row_indicator, output_indices,\n                           output_values),\n          done);\n\n      done();\n    };\n\n    context->device()",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      TF_RETURN_IF_ERROR(context->allocate_temp(\n          DT_BOOL, TensorShape({dense_rows}), &empty_row_indicator_t));\n      empty_row_indicator = empty_row_indicator_t.vec<bool>().data();\n    }\n\n    if (dense_rows > 0) {\n      TF_RETURN_IF_ERROR(\n          wrap_kernel_call(ComputeEmptyRowIndicatorKernel<Tindex>,\n                           /*device=*/device, /*size=*/dense_rows,\n                           elements_per_row, empty_row_indicator));\n    }\n\n    // For each row, the number of empty rows up to and including that row.\n    Tensor num_empty_rows_through_t;\n    TF_RETURN_IF_ERROR(context->allocate_temp(\n        index_type, TensorShape({dense_rows}), &num_empty_rows_through_t));\n                             num_empty_rows_through, output_indices,\n                             output_values, reverse_index_map),\n            done);\n      }\n\n      if (dense_rows > 0) {\n        OP_REQUIRES_OK_ASYNC(\n            context,\n            wrap_kernel_call(ScatterNewElementsKernel<T, Tindex>,\n                             /*device=*/device, /*size=*/dense_rows, rank,\n                             default_value, num_empty_rows_through,\n                             input_row_ends, empty_row_indicator,\n                             output_indices, output_values),\n            done);\n      }\n\n      done();\n    };\n\n    context->device()",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\t    ((*stp)->direction == PF_IN &&\n\t\t\t\t    PF_AEQ(&sn->addr, &sk->addr[0], sk->af))) &&\n\t\t\t\t    ((*stp)->rule.ptr->flush &\n\t\t\t\t    PF_FLUSH_GLOBAL ||\n\t\t\t\t    (*stp)->rule.ptr == st->rule.ptr)) {\n\t\t\t\t\tst->timeout = PFTM_PURGE;\n\t\t\t\t\tpf_set_protostate(st, PF_PEER_BOTH,\n\t\t\t\t\t    TCPS_CLOSED);\n\t\t\t\t\tkilled++;\n\t\t\t\t}\n\t\t\t}\n\t\tif (pf_status.debug >= LOG_NOTICE)\n\t\t\taddlog(\"\\n\");\n\t}\n\n\t/* kill this state */\n\t(*stp)->timeout = PFTM_PURGE;\n\tpf_set_protostate(*stp, PF_PEER_BOTH, TCPS_CLOSED);\n\treturn (1);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\t    ((*stp)->direction == PF_IN &&\n\t\t\t\t    PF_AEQ(&sn->addr, &sk->addr[0], sk->af))) &&\n\t\t\t\t    ((*stp)->rule.ptr->flush &\n\t\t\t\t    PF_FLUSH_GLOBAL ||\n\t\t\t\t    (*stp)->rule.ptr == st->rule.ptr)) {\n\t\t\t\t\tpf_update_state_timeout(st, PFTM_PURGE);\n\t\t\t\t\tpf_set_protostate(st, PF_PEER_BOTH,\n\t\t\t\t\t    TCPS_CLOSED);\n\t\t\t\t\tkilled++;\n\t\t\t\t}\n\t\t\t}\n\t\tif (pf_status.debug >= LOG_NOTICE)\n\t\t\taddlog(\"\\n\");\n\t}\n\n\t/* kill this state */\n\tpf_update_state_timeout(*stp, PFTM_PURGE);\n\tpf_set_protostate(*stp, PF_PEER_BOTH, TCPS_CLOSED);\n\treturn (1);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tdpIOCtxPtr dctx;\n\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain <= 0) {\n\t\t\t/* 2.0.34: EOF is incorrect. We use 0 for\n\t\t\t * errors and EOF, just like fileGetbuf,\n\t\t\t * which is a simple fread() wrapper.\n\t\t\t * TBB. Original bug report: Daniel Cowgill. */\n\t\t\treturn 0; /* NOT EOF */\n\t\t}\n\n\t\trlen = remain;\n\t}\n\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tdynamicPtr *dp;\n\n\tdctx = (dpIOCtxPtr) ctx;\n\tdp = dctx->dp;\n\n\tif (dp->pos < 0 || dp->pos >= dp->realSize) {\n\t\treturn 0;\n\t}\n\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain <= 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\trlen = remain;\n\t}\n\n\tif (dp->pos + rlen > dp->realSize) {\n\t\trlen = dp->realSize - dp->pos;\n\t}\n\n\tmemcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);\n\tdp->pos += rlen;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int crxParamInit(CrxBandParam **param, uint64_t subbandMdatOffset,\n                 uint64_t subbandDataSize, uint32_t subbandWidth,\n                 uint32_t subbandHeight, int32_t supportsPartial,\n                 uint32_t roundedBitsMask, LibRaw_abstract_datastream *input)\n{\n  int32_t progrDataSize = supportsPartial ? 0 : sizeof(int32_t) * subbandWidth;\n  int32_t paramLength = 2 * subbandWidth + 4;\n  uint8_t *paramBuf = (uint8_t *)calloc(\n      1, sizeof(CrxBandParam) + sizeof(int32_t) * paramLength + progrDataSize);\n\n  if (!paramBuf)\n    return -1;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int crxParamInit(\n#ifdef LIBRAW_CR3_MEMPOOL\n\tlibraw_memmgr&  mm,\n#endif\t\n\tCrxBandParam **param, uint64_t subbandMdatOffset,\n                 uint64_t subbandDataSize, uint32_t subbandWidth,\n                 uint32_t subbandHeight, int32_t supportsPartial,\n                 uint32_t roundedBitsMask, LibRaw_abstract_datastream *input)\n{\n  int32_t progrDataSize = supportsPartial ? 0 : sizeof(int32_t) * subbandWidth;\n  int32_t paramLength = 2 * subbandWidth + 4;\n  uint8_t *paramBuf = (uint8_t *)\n#ifdef LIBRAW_CR3_MEMPOOL\n\t  mm.\n#endif\n\t  calloc(\n      1, sizeof(CrxBandParam) + sizeof(int32_t) * paramLength + progrDataSize);\n\n  if (!paramBuf)\n    return -1;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "HexInStream::HexInStream(InStream& is, int bufSize_)\n: bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_LEN), offset(0), in_stream(is)\n{\n  ptr = end = start = new U8[bufSize];\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "HexInStream::HexInStream(InStream& is, size_t bufSize_)\n: bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_LEN), offset(0), in_stream(is)\n{\n  ptr = end = start = new U8[bufSize];\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t      i--;\n\t      break;\n\t    }\n\t}\n      else\n\tus[j++] = caprtl_to_unicode[(int) s[i]];\n    }\n\n  return j;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t      i--;\n\t      break;\n\t    }\n\t}\n      else\n      {\n        if ((int)s[i] < 0)\n          us[j++] = '?';\n        else\n          us[j++] = caprtl_to_unicode[(int) s[i]];\n      }\n    }\n\n  return j;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif ((f = (struct mschmd_file **) calloc(numf, sizeof(struct mschmd_file *)))) {\n\t  for (i=0, file=chm->files; file; file = file->next) f[i++] = file;\n\t  qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);\n\n\t  for (i = 0; i < numf; i++) {\n\t    char *outname = create_output_name((unsigned char *)f[i]->filename,NULL,0,1,0);\n\t    printf(\"Extracting %s\\n\", outname);\n\t    ensure_filepath(outname);\n\t    if (chmd->extract(chmd, f[i], outname)) {\n\t      printf(\"%s: extract error on \\\"%s\\\": %s\\n\",\n\t\t     *argv, f[i]->filename, ERROR(chmd));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif ((f = (struct mschmd_file **) calloc(numf, sizeof(struct mschmd_file *)))) {\n\t  for (i=0, file=chm->files; file; file = file->next) f[i++] = file;\n\t  qsort(f, numf, sizeof(struct mschmd_file *), &sortfunc);\n\n\t  for (i = 0; i < numf; i++) {\n\t    char *outname = create_output_name(f[i]->filename);\n\t    printf(\"Extracting %s\\n\", outname);\n\t    ensure_filepath(outname);\n\t    if (chmd->extract(chmd, f[i], outname)) {\n\t      printf(\"%s: extract error on \\\"%s\\\": %s\\n\",\n\t\t     *argv, f[i]->filename, ERROR(chmd));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    if (!sock || (count && !buf))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_sendto_ocall(\n            &ret,\n            sock->host_fd,\n            (struct oe_sockaddr*)dest_addr,\n            addrlen) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    ssize_t ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n\n    oe_errno = 0;\n\n    /*\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendto.html\n     * for more detail.\n     */\n    if (!sock || (count && !buf) || count > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_sendto_ocall(\n            &ret,\n            sock->host_fd,\n            addrlen) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    /*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The return value should not exceed count.\n     */\n    if (ret > (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tresult = L2CAP_CONF_UNKNOWN;\n\t\t\t*((u8 *) ptr++) = type;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (result == L2CAP_CONF_SUCCESS) {\n\t\t/* Configure output options and let the other side know\n\t\t * which ones we don't like. */\n\n\t\tif (rfc.mode == L2CAP_MODE_BASIC) {\n\t\t\tif (mtu < pi->omtu)\n\t\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\t\telse {\n\t\t\t\tpi->omtu = mtu;\n\t\t\t\tpi->conf_state |= L2CAP_CONF_OUTPUT_DONE;\n\t\t\t}\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);\n\t\t} else {\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\tmemset(&rfc, 0, sizeof(rfc));\n\t\t\trfc.mode = L2CAP_MODE_BASIC;\n\n\t\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\t\t}\n\t}\n\n\trsp->scid   = cpu_to_le16(pi->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(0x0000);\n\n\treturn ptr - data;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t*((u8 *) ptr++) = type;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pi->num_conf_rsp || pi->num_conf_req)\n\t\tgoto done;\n\n\tswitch (pi->mode) {\n\tcase L2CAP_MODE_STREAMING:\n\tcase L2CAP_MODE_ERTM:\n\t\tpi->conf_state |= L2CAP_CONF_STATE2_DEVICE;\n\t\tif (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask))\n\t\t\treturn -ECONNREFUSED;\n\t\tbreak;\n\tdefault:\n\t\tpi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);\n\t\tbreak;\n\t}\n\ndone:\n\tif (pi->mode != rfc.mode) {\n\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\trfc.mode = pi->mode;\n\n\t\tif (pi->num_conf_rsp == 1)\n\t\t\treturn -ECONNREFUSED;\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\t}\n\n\n\tif (result == L2CAP_CONF_SUCCESS) {\n\t\t/* Configure output options and let the other side know\n\t\t * which ones we don't like. */\n\n\t\tif (mtu < L2CAP_DEFAULT_MIN_MTU)\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\t\telse {\n\t\t\tpi->omtu = mtu;\n\t\t\tpi->conf_state |= L2CAP_CONF_MTU_DONE;\n\t\t}\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);\n\n\t\tswitch (rfc.mode) {\n\t\tcase L2CAP_MODE_BASIC:\n\t\t\tpi->fcs = L2CAP_FCS_NONE;\n\t\t\tpi->conf_state |= L2CAP_CONF_MODE_DONE;\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_ERTM:\n\t\t\tpi->remote_tx_win = rfc.txwin_size;\n\t\t\tpi->remote_max_tx = rfc.max_transmit;\n\t\t\tpi->max_pdu_size = rfc.max_pdu_size;\n\n\t\t\trfc.retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;\n\t\t\trfc.monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;\n\n\t\t\tpi->conf_state |= L2CAP_CONF_MODE_DONE;\n\t\t\tbreak;\n\n\t\tcase L2CAP_MODE_STREAMING:\n\t\t\tpi->remote_tx_win = rfc.txwin_size;\n\t\t\tpi->max_pdu_size = rfc.max_pdu_size;\n\n\t\t\tpi->conf_state |= L2CAP_CONF_MODE_DONE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tresult = L2CAP_CONF_UNACCEPT;\n\n\t\t\tmemset(&rfc, 0, sizeof(rfc));\n\t\t\trfc.mode = pi->mode;\n\t\t}\n\n\t\tl2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,\n\t\t\t\t\tsizeof(rfc), (unsigned long) &rfc);\n\n\t\tif (result == L2CAP_CONF_SUCCESS)\n\t\t\tpi->conf_state |= L2CAP_CONF_OUTPUT_DONE;\n\t}\n\trsp->scid   = cpu_to_le16(pi->dcid);\n\trsp->result = cpu_to_le16(result);\n\trsp->flags  = cpu_to_le16(0x0000);\n\n\treturn ptr - data;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tfree (buf);\n\t\t\tbreak;\n\t\t}\n\t\tint j;\n\t\tint count = 0;\n\t\tfor (j = 0; j < section->size; j += 8) {\n\t\t\tut64 addr64 = K_RPTR (buf + j);\n\t\t\tut64 paddr64 = section->paddr + paddr + j;\n\t\t\tif (mode == R_K_CONSTRUCTOR_TO_ENTRY) {\n\t\t\t\tRBinAddr *ba = newEntry (paddr64, addr64, type);\n\t\t\t\tr_list_append (ret, ba);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tfree (buf);\n\t\t\tbreak;\n\t\t}\n\t\tint j;\n\t\tint count = 0;\n\t\tfor (j = 0; j + 7 < section->size; j += 8) {\n\t\t\tut64 addr64 = K_RPTR (buf + j);\n\t\t\tut64 paddr64 = section->paddr + paddr + j;\n\t\t\tif (mode == R_K_CONSTRUCTOR_TO_ENTRY) {\n\t\t\t\tRBinAddr *ba = newEntry (paddr64, addr64, type);\n\t\t\t\tr_list_append (ret, ba);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tunsigned fsindex, gsindex;\n\tfpu_switch_t fpu;\n\n\tfpu = switch_fpu_prepare(prev_p, next_p, cpu);\n\n\t/*\n\t * Reload esp0, LDT and the page table pointer:\n\t */\n\tload_sp0(tss, next);\n\n\t/*\n\t * Switch DS and ES.\n\t * This won't pick up thread selector changes, but I guess that is ok.\n\t */\n\tsavesegment(es, prev->es);\n\tif (unlikely(next->es | prev->es))\n\t\tloadsegment(es, next->es);\n\n\tsavesegment(ds, prev->ds);\n\tif (unlikely(next->ds | prev->ds))\n\t\tloadsegment(ds, next->ds);\n\n\n\t/* We must save %fs and %gs before load_TLS() because\n\t * %fs and %gs may be cleared by load_TLS().\n\t *\n\t * (e.g. xen_load_tls())\n\t */\n\tsavesegment(fs, fsindex);\n\tsavesegment(gs, gsindex);\n\n\tload_TLS(next, cpu);\n\n\t/*\n\t * Leave lazy mode, flushing any hypercalls made here.\n\t * This must be done before restoring TLS segments so\n\t * the GDT and LDT are properly updated, and must be\n\t * done before math_state_restore, so the TS bit is up\n\t * to date.\n\t */\n\tarch_end_context_switch(next_p);\n\n\t/*\n\t * Switch FS and GS.\n\t *\n\t * Segment register != 0 always requires a reload.  Also\n\t * reload when it has changed.  When prev process used 64bit\n\t * base always reload to avoid an information leak.\n\t */\n\tif (unlikely(fsindex | next->fsindex | prev->fs)) {\n\t\tloadsegment(fs, next->fsindex);\n\t\t/*\n\t\t * Check if the user used a selector != 0; if yes\n\t\t *  clear 64bit base, since overloaded base is always\n\t\t *  mapped to the Null selector\n\t\t */\n\t\tif (fsindex)\n\t\t\tprev->fs = 0;\n\t}\n\t/* when next process has a 64bit base use it */\n\tif (next->fs)\n\t\twrmsrl(MSR_FS_BASE, next->fs);\n\tprev->fsindex = fsindex;\n\n\tif (unlikely(gsindex | next->gsindex | prev->gs)) {\n\t\tload_gs_index(next->gsindex);\n\t\tif (gsindex)\n\t\t\tprev->gs = 0;\n\t}\n\tif (next->gs)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, next->gs);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tunsigned fsindex, gsindex;\n\tfpu_switch_t fpu;\n\n\tfpu = switch_fpu_prepare(prev_p, next_p, cpu);\n\n\t/* Reload esp0 and ss1. */\n\tload_sp0(tss, next);\n\n\t/* We must save %fs and %gs before load_TLS() because\n\t * %fs and %gs may be cleared by load_TLS().\n\t *\n\t * (e.g. xen_load_tls())\n\t */\n\tsavesegment(fs, fsindex);\n\tsavesegment(gs, gsindex);\n\n\t/*\n\t * Load TLS before restoring any segments so that segment loads\n\t * reference the correct GDT entries.\n\t */\n\tload_TLS(next, cpu);\n\n\t/*\n\t * Leave lazy mode, flushing any hypercalls made here.  This\n\t * must be done after loading TLS entries in the GDT but before\n\t * loading segments that might reference them, and and it must\n\t * be done before math_state_restore, so the TS bit is up to\n\t * date.\n\t */\n\tarch_end_context_switch(next_p);\n\n\t/* Switch DS and ES.\n\t *\n\t * Reading them only returns the selectors, but writing them (if\n\t * nonzero) loads the full descriptor from the GDT or LDT.  The\n\t * LDT for next is loaded in switch_mm, and the GDT is loaded\n\t * above.\n\t *\n\t * We therefore need to write new values to the segment\n\t * registers on every context switch unless both the new and old\n\t * values are zero.\n\t *\n\t * Note that we don't need to do anything for CS and SS, as\n\t * those are saved and restored as part of pt_regs.\n\t */\n\tsavesegment(es, prev->es);\n\tif (unlikely(next->es | prev->es))\n\t\tloadsegment(es, next->es);\n\n\tsavesegment(ds, prev->ds);\n\tif (unlikely(next->ds | prev->ds))\n\t\tloadsegment(ds, next->ds);\n\n\t/*\n\t * Switch FS and GS.\n\t *\n\t * These are even more complicated than FS and GS: they have\n\t * 64-bit bases are that controlled by arch_prctl.  Those bases\n\t * only differ from the values in the GDT or LDT if the selector\n\t * is 0.\n\t *\n\t * Loading the segment register resets the hidden base part of\n\t * the register to 0 or the value from the GDT / LDT.  If the\n\t * next base address zero, writing 0 to the segment register is\n\t * much faster than using wrmsr to explicitly zero the base.\n\t *\n\t * The thread_struct.fs and thread_struct.gs values are 0\n\t * if the fs and gs bases respectively are not overridden\n\t * from the values implied by fsindex and gsindex.  They\n\t * are nonzero, and store the nonzero base addresses, if\n\t * the bases are overridden.\n\t *\n\t * (fs != 0 && fsindex != 0) || (gs != 0 && gsindex != 0) should\n\t * be impossible.\n\t *\n\t * Therefore we need to reload the segment registers if either\n\t * the old or new selector is nonzero, and we need to override\n\t * the base address if next thread expects it to be overridden.\n\t *\n\t * This code is unnecessarily slow in the case where the old and\n\t * new indexes are zero and the new base is nonzero -- it will\n\t * unnecessarily write 0 to the selector before writing the new\n\t * base address.\n\t *\n\t * Note: This all depends on arch_prctl being the only way that\n\t * user code can override the segment base.  Once wrfsbase and\n\t * wrgsbase are enabled, most of this code will need to change.\n\t */\n\tif (unlikely(fsindex | next->fsindex | prev->fs)) {\n\t\tloadsegment(fs, next->fsindex);\n\n\t\t/*\n\t\t * If user code wrote a nonzero value to FS, then it also\n\t\t * cleared the overridden base address.\n\t\t *\n\t\t * XXX: if user code wrote 0 to FS and cleared the base\n\t\t * address itself, we won't notice and we'll incorrectly\n\t\t * restore the prior base address next time we reschdule\n\t\t * the process.\n\t\t */\n\t\tif (fsindex)\n\t\t\tprev->fs = 0;\n\t}\n\tif (next->fs)\n\t\twrmsrl(MSR_FS_BASE, next->fs);\n\tprev->fsindex = fsindex;\n\n\tif (unlikely(gsindex | next->gsindex | prev->gs)) {\n\t\tload_gs_index(next->gsindex);\n\n\t\t/* This works (and fails) the same way as fsindex above. */\n\t\tif (gsindex)\n\t\t\tprev->gs = 0;\n\t}\n\tif (next->gs)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, next->gs);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int TLSInStream::readTLS(U8* buf, int len, bool wait)\n{\n  int n;\n\n  n = in->check(1, 1, wait);\n  if (n == 0)\n    return 0;\n\n  n = gnutls_record_recv(session, (void *) buf, len);\n  if (n == GNUTLS_E_INTERRUPTED || n == GNUTLS_E_AGAIN)\n    return 0;\n\n  if (n < 0) throw TLSException(\"readTLS\", n);\n\n  return n;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "size_t TLSInStream::readTLS(U8* buf, size_t len, bool wait)\n{\n  int n;\n\n  n = in->check(1, 1, wait);\n  if (n == 0)\n    return 0;\n\n  n = gnutls_record_recv(session, (void *) buf, len);\n  if (n == GNUTLS_E_INTERRUPTED || n == GNUTLS_E_AGAIN)\n    return 0;\n\n  if (n < 0) throw TLSException(\"readTLS\", n);\n\n  return n;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static s16 swf_get_s16(SWFReader *read)\n{\n\ts16 val;\n\tu8 v1;\n\tv1 = swf_read_int(read, 8);\n\tval = swf_read_sint(read, 8);\n\tval = (val<<8)&0xFF00;\n\tval |= (v1&0xFF);\n\treturn val;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static s16 swf_get_s16(SWFReader *read)\n{\n\treturn (s16) gf_bs_read_u16_le(read->bs);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "         if(!error)\n         {\n            //Properly terminate the string\n            token[n] = '\\0';\n            //Check whether a separator is present\n            separator = strchr(token, ':');\n\n            //Separator found?\n            if(separator != NULL)\n            {\n               //Split the line\n\n      //Parse the Authorization header field\n      while(token != NULL)\n      {\n         //Check whether a separator is present\n         separator = strchr(token, '=');\n\n         //Separator found?\n         if(separator != NULL)\n         {\n            //Split the string",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "         if(!error)\n         {\n            //Properly terminate the string\n            token[n] = '\\0';\n            //Check whether a separator is present\n            separator = osStrchr(token, ':');\n\n            //Separator found?\n            if(separator != NULL)\n            {\n               //Split the line\n\n      //Parse the Authorization header field\n      while(token != NULL)\n      {\n         //Check whether a separator is present\n         separator = osStrchr(token, '=');\n\n         //Separator found?\n         if(separator != NULL)\n         {\n            //Split the string",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        }\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket]; (void)chains;\n\n        unsigned const v_sym = get_te32(&dynp0[-1+ x_sym].d_val);\n        if (!nbucket\n        || (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)  // FIXME: weak\n        || ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2  // headers\n                + sizeof(*buckets)*nbucket  // buckets\n                + sizeof(*chains) *nbucket  // chains\n           ))\n        upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;\n      //unsigned     const *const gashend = &hasharr[n_bucket];  // minimum\n\n        upx_uint64_t const v_sym = get_te64(&dynp0[-1+ x_sym].d_val);\n        if (!n_bucket || !n_bitmask\n        || (-1+ n_bitmask) & n_bitmask  // not a power of 2\n        || 8*sizeof(upx_uint64_t) <= gnu_shift  // shifted result always == 0\n        || (n_bucket>>30)  // fie on fuzzers\n        || (n_bitmask>>30)\n        || (file_size/sizeof(unsigned)) <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)  // FIXME: weak",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        }\n        unsigned const nbucket = get_te32(&hashtab[0]);\n        unsigned const *const buckets = &hashtab[2];\n        unsigned const *const chains = &buckets[nbucket]; (void)chains;\n\n        unsigned const v_sym = !x_sym ? 0 : get_te32(&dynp0[-1+ x_sym].d_val);\n        if (!nbucket || !v_sym\n        || (nbucket>>31) || (file_size/sizeof(unsigned)) <= (2*nbucket)  // FIXME: weak\n        || ((v_hsh < v_sym) && (v_sym - v_hsh) < (sizeof(unsigned)*2  // headers\n                + sizeof(*buckets)*nbucket  // buckets\n                + sizeof(*chains) *nbucket  // chains\n           ))\n        upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4];\n        unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask];\n        unsigned     const *const hasharr = &buckets[n_bucket]; (void)hasharr;\n      //unsigned     const *const gashend = &hasharr[n_bucket];  // minimum\n\n        upx_uint64_t const v_sym = !x_sym ? 0 : get_te64(&dynp0[-1+ x_sym].d_val);\n        if (!n_bucket || !n_bitmask || !v_sym\n        || (-1+ n_bitmask) & n_bitmask  // not a power of 2\n        || 8*sizeof(upx_uint64_t) <= gnu_shift  // shifted result always == 0\n        || (n_bucket>>30)  // fie on fuzzers\n        || (n_bitmask>>30)\n        || (file_size/sizeof(unsigned)) <= ((sizeof(*bitmask)/sizeof(unsigned))*n_bitmask + 2*n_bucket)  // FIXME: weak",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n\tint count, i;\n\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > XFS_ACL_MAX_ENTRIES)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "xfs_acl_from_disk(struct xfs_acl *aclp)\n{\n\tstruct posix_acl_entry *acl_e;\n\tstruct posix_acl *acl;\n\tstruct xfs_acl_entry *ace;\n\tunsigned int count, i;\n\n\tcount = be32_to_cpu(aclp->acl_cnt);\n\tif (count > XFS_ACL_MAX_ENTRIES)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t * otherwise the trapped I/O case will skew the results too much\n\t * to be useful.\n\t */\n\tif (!expected) {\n\t\tunaligned_fixups_notify(current, instruction, regs);\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0,\n\t\t\t      regs, address);\n\t}\n\n\tret = -EFAULT;\n\tswitch (instruction&0xF000) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t * otherwise the trapped I/O case will skew the results too much\n\t * to be useful.\n\t */\n\tif (!expected) {\n\t\tunaligned_fixups_notify(current, instruction, regs);\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1,\n\t\t\t      regs, address);\n\t}\n\n\tret = -EFAULT;\n\tswitch (instruction&0xF000) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int DSA_verify(int type, const unsigned char *dgst, int dgst_len,\n\t     const unsigned char *sigbuf, int siglen, DSA *dsa)\n\t{\n\tDSA_SIG *s;\n\tint ret=-1;\n\n\ts = DSA_SIG_new();\n\tif (s == NULL) return(ret);\n\tif (d2i_DSA_SIG(&s,&sigbuf,siglen) == NULL) goto err;\n\tret=DSA_do_verify(dgst,dgst_len,s,dsa);\nerr:\n\tDSA_SIG_free(s);\n\treturn(ret);\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int DSA_verify(int type, const unsigned char *dgst, int dgst_len,\n\t     const unsigned char *sigbuf, int siglen, DSA *dsa)\n\t{\n\tDSA_SIG *s;\n\tconst unsigned char *p = sigbuf;\n\tunsigned char *der = NULL;\n\tint derlen = -1;\n\tint ret=-1;\n\n\ts = DSA_SIG_new();\n\tif (s == NULL) return(ret);\n\tif (d2i_DSA_SIG(&s,&p,siglen) == NULL) goto err;\n\t/* Ensure signature uses DER and doesn't have trailing garbage */\n\tderlen = i2d_DSA_SIG(s, &der);\n\tif (derlen != siglen || memcmp(sigbuf, der, derlen))\n\t\tgoto err;\n\tret=DSA_do_verify(dgst,dgst_len,s,dsa);\nerr:\n\tif (derlen > 0)\n\t\t{\n\t\tOPENSSL_cleanse(der, derlen);\n\t\tOPENSSL_free(der);\n\t\t}\n\tDSA_SIG_free(s);\n\treturn(ret);\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  char tty_pathname[2 + 2 * NAME_MAX];\n  char *real_tty_path = tty_pathname;\n  int result = 0;\n  struct utmp *ut, line, buffer;\n\n  {\n    int d = __open (\"/dev/tty\", 0);\n    if (d < 0)\n      return errno;\n\n    result = __ttyname_r (d, real_tty_path, sizeof (tty_pathname));\n    (void) __close (d);\n\n    if (result != 0)\n      {\n\t__set_errno (result);\n\treturn result;\n      }\n  }\n\n  real_tty_path += 5;\t\t/* Remove \"/dev/\".  */\n\n  __setutent ();\n  strncpy (line.ut_line, real_tty_path, sizeof line.ut_line);\n      else\n\tresult = errno;\n    }\n  else\n    {\n      size_t needed = strlen (ut->ut_line) + 1;\n\n      if (needed < name_len)\n\t{\n\t  __set_errno (ERANGE);\n\t  result = ERANGE;\n\t}\n      else\n\t{\n\t  memcpy (name, ut->ut_line, needed);\n\t  result = 0;\n\t}\n    }\n  __endutent ();\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  char tty_pathname[2 + 2 * NAME_MAX];\n  char *real_tty_path = tty_pathname;\n  int result = 0;\n  struct utmp *ut, line, buffer;\n\n  /* Get name of tty connected to fd 0.  Return if not a tty or\n     if fd 0 isn't open.  Note that a lot of documentation says that\n     getlogin() is based on the controlling terminal---what they\n     really mean is \"the terminal connected to standard input\".  The\n     getlogin() implementation of DEC Unix, SunOS, Solaris, HP-UX all\n     return NULL if fd 0 has been closed, so this is the compatible\n     thing to do.  Note that ttyname(open(\"/dev/tty\")) on those\n     systems returns /dev/tty, so that is not a possible solution for\n     getlogin().  */\n\n  result = __ttyname_r (0, real_tty_path, sizeof (tty_pathname));\n  \n  if (result != 0)\n    return result;\n\n  real_tty_path += 5;\t\t/* Remove \"/dev/\".  */\n\n  __setutent ();\n  strncpy (line.ut_line, real_tty_path, sizeof line.ut_line);\n      else\n\tresult = errno;\n    }\n  else\n    {\n      size_t needed = strlen (ut->ut_user) + 1;\n\n      if (needed > name_len)\n\t{\n\t  __set_errno (ERANGE);\n\t  result = ERANGE;\n\t}\n      else\n\t{\n\t  memcpy (name, ut->ut_user, needed);\n\t  result = 0;\n\t}\n    }\n  __endutent ();\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {\n\tD eprintf (\"Dragons at 0x%x\\n\", off);\n\tut64 size = r_buf_size (buf);\n\tif (off >= size) {\n\t\treturn NULL;\n\t}\n\tsize -= off;\n\tif (!size) {\n\t\treturn NULL;\n\t}\n\tut8 *b = malloc (size);\n\tif (!b) {\n\t\treturn NULL;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static RCoreSymCacheElement *parseDragons(RBinFile *bf, RBuffer *buf, int off, int bits, R_OWN char *file_name) {\n\tD eprintf (\"Dragons at 0x%x\\n\", off);\n\tst64 size = r_buf_size (buf);\n\tif (off >= size) {\n\t\treturn NULL;\n\t}\n\tsize -= off;\n\tif (!size) {\n\t\treturn NULL;\n\t}\n\tif (size < 32) {\n\t\treturn NULL;\n\t}\n\tut8 *b = malloc (size);\n\tif (!b) {\n\t\treturn NULL;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t/* We throwed the options of the initial SYN away, so we hope\n\t * the ACK carries the same options again (see RFC1122 4.2.3.8)\n\t */\n\tif (opt && opt->optlen) {\n\t\tint opt_size = sizeof(struct ip_options) + opt->optlen;\n\n\t\tireq->opt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (ireq->opt != NULL && ip_options_echo(ireq->opt, skb)) {\n\t\t\tkfree(ireq->opt);\n\t\t\tireq->opt = NULL;\n\t\t}\n\t}\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\t/* We throwed the options of the initial SYN away, so we hope\n\t * the ACK carries the same options again (see RFC1122 4.2.3.8)\n\t */\n\tif (opt && opt->optlen) {\n\t\tint opt_size = sizeof(struct ip_options_rcu) + opt->optlen;\n\n\t\tireq->opt = kmalloc(opt_size, GFP_ATOMIC);\n\t\tif (ireq->opt != NULL && ip_options_echo(&ireq->opt->opt, skb)) {\n\t\t\tkfree(ireq->opt);\n\t\t\tireq->opt = NULL;\n\t\t}\n\t}\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  mrb_value proc = mrb_get_arg1(mrb);\n\n  if (!mrb_proc_p(proc)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"not a proc\");\n  }\n  mrb_proc_copy(mrb_proc_ptr(self), mrb_proc_ptr(proc));\n  return self;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  mrb_value proc = mrb_get_arg1(mrb);\n\n  if (!mrb_proc_p(proc)) {\n    mrb_raise(mrb, E_ARGUMENT_ERROR, \"not a proc\");\n  }\n  mrb_proc_copy(mrb, mrb_proc_ptr(self), mrb_proc_ptr(proc));\n  return self;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        Settings.setCheckUpgradeAutomatic(dialog.exec() == QMessageBox::Yes);\n        if (dialog.checkBox()->isChecked())\n            Settings.setAskUpgradeAutomatic(false);\n    }\n    showStatusMessage(\"Checking for upgrade...\");\n    m_network.get(QNetworkRequest(QUrl(\"http://check.shotcut.org/version.json\")));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        Settings.setCheckUpgradeAutomatic(dialog.exec() == QMessageBox::Yes);\n        if (dialog.checkBox()->isChecked())\n            Settings.setAskUpgradeAutomatic(false);\n    }\n    showStatusMessage(\"Checking for upgrade...\");\n    m_network.get(QNetworkRequest(QUrl(\"https://check.shotcut.org/version.json\")));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n    if (ncolors < 0) {\n        ncolors = 256;\n        quality_mode = SIXEL_QUALITY_HIGHCOLOR;\n    } else {\n        if (ncolors > SIXEL_PALETTE_MAX) {\n            ncolors = 256;\n        } else if (ncolors < 2) {\n            ncolors = 2;\n        }\n        quality_mode = SIXEL_QUALITY_LOW;\n    }\n    headsize = sizeof(sixel_dither_t);\n    datasize = (size_t)(ncolors * 3);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    if (ncolors < 0) {\n        ncolors = 256;\n        quality_mode = SIXEL_QUALITY_HIGHCOLOR;\n    } else {\n        if (ncolors > SIXEL_PALETTE_MAX) {\n            status = SIXEL_BAD_INPUT;\n            ncolors = 256;\n        } else if (ncolors < 1) {\n            status = SIXEL_BAD_INPUT;\n            sixel_helper_set_additional_message(\n                \"sixel_dither_new: palette colors must be more than 0\");\n            goto end;\n        }\n        quality_mode = SIXEL_QUALITY_LOW;\n    }\n    headsize = sizeof(sixel_dither_t);\n    datasize = (size_t)(ncolors * 3);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tret = -EBUSY;\n\n\tmutex_lock(&key_construction_mutex);\n\n\t/* can't instantiate twice */\n\tif (!test_bit(KEY_FLAG_INSTANTIATED, &key->flags)) {\n\t\t/* instantiate the key */\n\t\tret = key->type->instantiate(key, prep);\n\n\t\tif (ret == 0) {\n\t\t\t/* mark the key as being instantiated */\n\t\t\tatomic_inc(&key->user->nikeys);\n\t\t\tset_bit(KEY_FLAG_INSTANTIATED, &key->flags);\n\n\t\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\t\tawaken = 1;\n\n\t\t\t/* and link it into the destination keyring */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tret = -EBUSY;\n\n\tmutex_lock(&key_construction_mutex);\n\n\t/* can't instantiate twice */\n\tif (key->state == KEY_IS_UNINSTANTIATED) {\n\t\t/* instantiate the key */\n\t\tret = key->type->instantiate(key, prep);\n\n\t\tif (ret == 0) {\n\t\t\t/* mark the key as being instantiated */\n\t\t\tatomic_inc(&key->user->nikeys);\n\t\t\tmark_key_instantiated(key, 0);\n\n\t\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\t\tawaken = 1;\n\n\t\t\t/* and link it into the destination keyring */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    case HEVC_NAL_RADL_R:\n    case HEVC_NAL_RASL_N:\n    case HEVC_NAL_RASL_R:\n        ret = hls_slice_header(s);\n        if (ret < 0)\n            return ret;\n\n        if (\n            (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONINTRA && s->sh.slice_type != HEVC_SLICE_I) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONKEY && !IS_IRAP(s))) {\n            break;\n        }\n\n        if (s->sh.first_slice_in_pic_flag) {\n            if (s->ref) {\n                av_log(s->avctx, AV_LOG_ERROR, \"Two slices reporting being the first in the same frame.\\n\");\n                goto fail;\n            }\n            if (s->max_ra == INT_MAX) {\n                if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {\n                    s->max_ra = s->poc;\n                } else {\n                    if (IS_IDR(s))",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    case HEVC_NAL_RASL_N:\n    case HEVC_NAL_RASL_R:\n        ret = hls_slice_header(s);\n        if (ret < 0)\n            return ret;\n        if (ret == 1) {\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n\n        if (\n            (s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONINTRA && s->sh.slice_type != HEVC_SLICE_I) ||\n            (s->avctx->skip_frame >= AVDISCARD_NONKEY && !IS_IRAP(s))) {\n            break;\n        }\n\n        if (s->sh.first_slice_in_pic_flag) {\n            if (s->max_ra == INT_MAX) {\n                if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {\n                    s->max_ra = s->poc;\n                } else {\n                    if (IS_IDR(s))",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "uint16_t enc28j60ReadPhyReg(NetInterface *interface, uint16_t address)\n{\n   uint16_t data;\n\n   //Write register address\n   enc28j60WriteReg(interface, ENC28J60_REG_MIREGADR, address & REG_ADDR_MASK);\n\n   //Start read operation\n   enc28j60WriteReg(interface, ENC28J60_REG_MICMD, MICMD_MIIRD);\n   //Wait for the read operation to complete\n   while((enc28j60ReadReg(interface, ENC28J60_REG_MISTAT) & MISTAT_BUSY) != 0)\n   {\n   }\n\n   //Clear command register\n   enc28j60WriteReg(interface, ENC28J60_REG_MICMD, 0);\n\n   //Read the lower 8 bits\n   data = enc28j60ReadReg(interface, ENC28J60_REG_MIRDL);\n   //Read the upper 8 bits\n   data |= enc28j60ReadReg(interface, ENC28J60_REG_MIRDH) << 8;\n\n   //Return register contents\n   return data;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "uint16_t enc28j60ReadPhyReg(NetInterface *interface, uint16_t address)\n{\n   uint16_t data;\n\n   //Write register address\n   enc28j60WriteReg(interface, ENC28J60_MIREGADR, address & REG_ADDR_MASK);\n\n   //Start read operation\n   enc28j60WriteReg(interface, ENC28J60_MICMD, ENC28J60_MICMD_MIIRD);\n   //Wait for the read operation to complete\n   while((enc28j60ReadReg(interface, ENC28J60_MISTAT) & ENC28J60_MISTAT_BUSY) != 0)\n   {\n   }\n\n   //Clear command register\n   enc28j60WriteReg(interface, ENC28J60_MICMD, 0);\n\n   //Read the lower 8 bits\n   data = enc28j60ReadReg(interface, ENC28J60_MIRDL);\n   //Read the upper 8 bits\n   data |= enc28j60ReadReg(interface, ENC28J60_MIRDH) << 8;\n\n   //Return register contents\n   return data;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t/* Allow mapping to your own filesystem ids */\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, current_fsuid()))\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, current_fsgid()))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* Allow anyone to set a mapping that doesn't require privilege */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t/* Allow mapping to your own filesystem ids */\n\tif ((new_map->nr_extents == 1) && (new_map->extent[0].count == 1)) {\n\t\tu32 id = new_map->extent[0].lower_first;\n\t\tif (cap_setid == CAP_SETUID) {\n\t\t\tkuid_t uid = make_kuid(ns->parent, id);\n\t\t\tif (uid_eq(uid, file->f_cred->fsuid))\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (cap_setid == CAP_SETGID) {\n\t\t\tkgid_t gid = make_kgid(ns->parent, id);\n\t\t\tif (gid_eq(gid, file->f_cred->fsgid))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\t/* Allow anyone to set a mapping that doesn't require privilege */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "R_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaAnnotation *annotation = NULL;\n\tRBinJavaElementValuePair *evps = NULL;\n\tut64 offset = 0;\n\tannotation = R_NEW0 (RBinJavaAnnotation);\n\tif (!annotation) {\n\t\treturn NULL;\n\t}\n\t// (ut16) read and set annotation_value.type_idx;\n\tannotation->type_idx = R_BIN_JAVA_USHORT (buffer, offset);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "R_API RBinJavaAnnotation *r_bin_java_annotation_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tRBinJavaElementValuePair *evps = NULL;\n\tut64 offset = 0;\n\tif (sz < 8) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAnnotation *annotation = R_NEW0 (RBinJavaAnnotation);\n\tif (!annotation) {\n\t\treturn NULL;\n\t}\n\t// (ut16) read and set annotation_value.type_idx;\n\tannotation->type_idx = R_BIN_JAVA_USHORT (buffer, offset);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif (pps_id > 255) return -1;\n\tsi->pps = &avc->pps[pps_id];\n\tif (!si->pps->slice_group_count) return -2;\n\tsi->sps = &avc->sps[si->pps->sps_id];\n\tif (!si->sps->log2_max_frame_num) return -2;\n\tavc->sps_active_idx = si->pps->sps_id;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id > 255)) return -1;\n\tsi->pps = &avc->pps[pps_id];\n\tif (!si->pps->slice_group_count) return -2;\n\tsi->sps = &avc->sps[si->pps->sps_id];\n\tif (!si->sps->log2_max_frame_num) return -2;\n\tavc->sps_active_idx = si->pps->sps_id;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tcase SO_SNDLOWAT:\n\t\tv.val = 1;\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tv.val = test_bit(SOCK_PASSCRED, &sock->flags) ? 1 : 0;\n\t\tbreak;\n\n\tcase SO_PEERCRED:\n\t{\n\t\tstruct ucred peercred;\n\tcase SO_ACCEPTCONN:\n\t\tv.val = sk->sk_state == TCP_LISTEN;\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tv.val = test_bit(SOCK_PASSSEC, &sock->flags) ? 1 : 0;\n\t\tbreak;\n\n\tcase SO_PEERSEC:\n\t\treturn security_socket_getpeersec_stream(sock, optval, optlen, len);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tcase SO_SNDLOWAT:\n\t\tv.val = 1;\n\t\tbreak;\n\n\tcase SO_PASSCRED:\n\t\tv.val = !!test_bit(SOCK_PASSCRED, &sock->flags);\n\t\tbreak;\n\n\tcase SO_PEERCRED:\n\t{\n\t\tstruct ucred peercred;\n\tcase SO_ACCEPTCONN:\n\t\tv.val = sk->sk_state == TCP_LISTEN;\n\t\tbreak;\n\n\tcase SO_PASSSEC:\n\t\tv.val = !!test_bit(SOCK_PASSSEC, &sock->flags);\n\t\tbreak;\n\n\tcase SO_PEERSEC:\n\t\treturn security_socket_getpeersec_stream(sock, optval, optlen, len);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  if (!nTiles)\n    return -1;\n\n  if (!img->tiles)\n  {\n    img->tiles = (CrxTile *)malloc(\n        sizeof(CrxTile) * nTiles +\n        sizeof(CrxPlaneComp) * nTiles * img->nPlanes +\n        sizeof(CrxSubband) * nTiles * img->nPlanes * img->subbandCount);\n    if (!img->tiles)\n      return -1;\n\n    // memory areas in allocated chunk\n    CrxTile *tile = img->tiles;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  if (!nTiles)\n    return -1;\n\n  if (!img->tiles)\n  {\n    img->tiles = (CrxTile *)\n#ifdef LIBRAW_CR3_MEMPOOL\n\t\timg->memmgr.\n#endif\n\t\tcalloc(\n        sizeof(CrxTile) * nTiles +\n        sizeof(CrxPlaneComp) * nTiles * img->nPlanes +\n        sizeof(CrxSubband) * nTiles * img->nPlanes * img->subbandCount,1);\n    if (!img->tiles)\n      return -1;\n\n    // memory areas in allocated chunk\n    CrxTile *tile = img->tiles;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t/*register global QP*/\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\n\t/*register TWICE: once for the command, and for the scenegraph globalQP*/\n\tnode->sgprivate->num_instances = 2;\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\t//if node was just created (num_instances == 0), unregister\n\t\t//otherwise (USE node) don't do anything\n\t\tif (!node->sgprivate->num_instances) {\n\t\t\tnode->sgprivate->num_instances = 1;\n\t\t\tgf_node_unregister(node, NULL);\n\t\t}\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t/*register global QP*/\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\n\t/*register TWICE: once for the command, and for the scenegraph globalQP*/\n\tgf_node_unregister(node, NULL);\n\tgf_node_unregister(node, NULL);\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = &rt_waiter;\n\tq.requeue_pi_key = &key2;\n\n\t/* Prepare to wait on uaddr. */\n\tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n\tif (ret)\n\t\tgoto out_key2;\n\n\t/* Queue the futex_q, drop the hb lock, wait for wakeup. */\n\n\t/*\n\t * In order for us to be here, we know our q.key == key2, and since\n\t * we took the hb->lock above, we also know that futex_requeue() has\n\t * completed and we no longer have to concern ourselves with a wakeup\n\t * race with the atomic proxy lock acquition by the requeue code.\n\t */\n\n\t/* Check if the requeue code acquired the second futex for us. */\n\tif (!q.rt_waiter) {\n\t\t/*",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = &rt_waiter;\n\tq.requeue_pi_key = &key2;\n\n\t/*\n\t * Prepare to wait on uaddr. On success, increments q.key (key1) ref\n\t * count.\n\t */\n\tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n\tif (ret)\n\t\tgoto out_key2;\n\n\t/* Queue the futex_q, drop the hb lock, wait for wakeup. */\n\n\t/*\n\t * In order for us to be here, we know our q.key == key2, and since\n\t * we took the hb->lock above, we also know that futex_requeue() has\n\t * completed and we no longer have to concern ourselves with a wakeup\n\t * race with the atomic proxy lock acquisition by the requeue code. The\n\t * futex_requeue dropped our key1 reference and incremented our key2\n\t * reference count.\n\t */\n\n\t/* Check if the requeue code acquired the second futex for us. */\n\tif (!q.rt_waiter) {\n\t\t/*",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tunsigned *sli_cnt,\n\t\t\t\t\tpjmedia_rtcp_fb_sli sli[])\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n    pj_uint8_t *p;\n    unsigned cnt, i;\n\n    PJ_ASSERT_RETURN(buf && sli_cnt && sli, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL);\n\n    /* PLI uses pt==RTCP_PSFB and FMT==2 */\n    if (hdr->pt != RTCP_PSFB || hdr->count != 2)\n\treturn PJ_ENOTFOUND;\n\n    cnt = pj_ntohs((pj_uint16_t)hdr->length) - 2;\n    if (length < (cnt+3)*4)\n\treturn PJ_ETOOSMALL;\n\n    *sli_cnt = PJ_MIN(*sli_cnt, cnt);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length,\n\t\t\t\t\tunsigned *sli_cnt,\n\t\t\t\t\tpjmedia_rtcp_fb_sli sli[])\n{\n    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;\n    pj_uint8_t *p;\n    unsigned cnt, i;\n\n    PJ_ASSERT_RETURN(buf && sli_cnt && sli, PJ_EINVAL);\n    PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_fb_common), PJ_ETOOSMALL);\n\n    /* PLI uses pt==RTCP_PSFB and FMT==2 */\n    if (hdr->rtcp_common.pt != RTCP_PSFB || hdr->rtcp_common.count != 2)\n\treturn PJ_ENOTFOUND;\n\n    cnt = pj_ntohs((pj_uint16_t)hdr->rtcp_common.length) - 2;\n    if (length < (cnt+3)*4)\n\treturn PJ_ETOOSMALL;\n\n    *sli_cnt = PJ_MIN(*sli_cnt, cnt);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\n\tif (PageDirty(page)) {\n\t\tclear_page_dirty_for_io(page);\n\t\t/*\n\t\t * Want to mark the page and the radix tree as dirty, and\n\t\t * redo the accounting that clear_page_dirty_for_io undid,\n\t\t * but we can't use set_page_dirty because that function\n\t\t * is actually a signal that all of the page has become dirty.\n\t\t * Whereas only part of our page may be dirty.\n\t\t */\n\t\tif (PageSwapBacked(page))\n\t\t\tSetPageDirty(newpage);\n\t\telse\n\t\t\t__set_page_dirty_nobuffers(newpage);\n \t}\n\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (PageChecked(page))\n\t\tSetPageChecked(newpage);\n\tif (PageMappedToDisk(page))\n\t\tSetPageMappedToDisk(newpage);\n\n\t/* Move dirty on pages not done by migrate_page_move_mapping() */\n\tif (PageDirty(page))\n\t\tSetPageDirty(newpage);\n\n\tif (page_is_young(page))\n\t\tset_page_young(newpage);\n\tif (page_is_idle(page))\n\t\tset_page_idle(newpage);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    }\n    else\n    {\n        const PdfArray* arr;\n        if (!indexObj->TryGetArray(arr))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n\n        for (auto index : *arr)\n            indices.push_back(index.GetNumber());\n    }\n\n    // indices must be a multiple of 2\n    if (indices.size() % 2 != 0)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid XRef Stream /Index\");\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    }\n    else\n    {\n        const PdfArray* arr;\n        if (!indexObj->TryGetArray(arr))\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream, \"Invalid XRef Stream /Index\");\n\n        for (auto index : *arr)\n            indices.push_back(index.GetNumber());\n    }\n\n    // indices must be a multiple of 2\n    if (indices.size() % 2 != 0)\n        PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream, \"Invalid XRef Stream /Index\");\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "dn2ancestor(\n    Slapi_Backend *be,\n    const Slapi_DN\t*sdn,\n\tSlapi_DN *ancestordn,\n    back_txn\t\t*txn,\n    int\t\t\t*err\n)\n{\n\tstruct backentry *e = NULL;\n\n\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> dn2ancestor \\\"%s\\\"\\n\", slapi_sdn_get_dn(sdn), 0, 0 );\n\n    /* first, check to see if the given sdn is empty or a root suffix of the\n       given backend - if so, it has no parent */\n    if (!slapi_sdn_isempty(sdn) && !slapi_be_issuffix( be, sdn )) {\n        Slapi_DN ancestorndn;\n          So, why not just use a char* for the ancestorndn?  Because dn2entry requires\n          a Slapi_DN with the normalized dn.\n        */\n\n        /* stop when we get to \"\", or a backend suffix point */\n        while (!e && !slapi_sdn_isempty(&ancestorndn) && !slapi_be_issuffix( be, &ancestorndn )) {\n            /* find the entry - it uses the ndn, so no further conversion is necessary */\n            e= dn2entry(be,&ancestorndn,txn,err);\n            if (!e) {\n                /* not found, so set ancestordn to its parent and try again */\n                ptr = slapi_dn_find_parent(slapi_sdn_get_ndn(&ancestorndn));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "dn2ancestor(\n    Slapi_Backend *be,\n    const Slapi_DN\t*sdn,\n    Slapi_DN *ancestordn,\n    back_txn\t\t*txn,\n    int\t\t\t*err,\n    int allow_suffix\n)\n{\n    struct backentry *e = NULL;\n\n    LDAPDebug( LDAP_DEBUG_TRACE, \"=> dn2ancestor \\\"%s\\\"\\n\", slapi_sdn_get_dn(sdn), 0, 0 );\n\n    /* first, check to see if the given sdn is empty or a root suffix of the\n       given backend - if so, it has no parent */\n    if (!slapi_sdn_isempty(sdn) && !slapi_be_issuffix( be, sdn )) {\n        Slapi_DN ancestorndn;\n          So, why not just use a char* for the ancestorndn?  Because dn2entry requires\n          a Slapi_DN with the normalized dn.\n        */\n\n        /* stop when we get to \"\", or a backend suffix point */\n        while (!e && !slapi_sdn_isempty(&ancestorndn)) {\n            if (!allow_suffix) {\n                /* Original behavior. */\n                if (slapi_be_issuffix(be, &ancestorndn)) {\n                    break;\n                }\n            }\n            /* find the entry - it uses the ndn, so no further conversion is necessary */\n            e= dn2entry(be,&ancestorndn,txn,err);\n            if (!e) {\n                /* not found, so set ancestordn to its parent and try again */\n                ptr = slapi_dn_find_parent(slapi_sdn_get_ndn(&ancestorndn));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tstruct sk_buff *skb;\n\n\tnoblock = flags & MSG_DONTWAIT;\n\n\tif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Retrieve the head sk_buff from the socket's receive queue. */\n\terr = 0;\n\tskb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);\n\tif (err)\n\terr = skb_copy_datagram_iovec(skb, sizeof(*dg), msg->msg_iov,\n\t\tpayload_len);\n\tif (err)\n\t\tgoto out;\n\n\tmsg->msg_namelen = 0;\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_vm *vm_addr;\n\n\t\t/* Provide the address of the sender. */\n\t\tvm_addr = (struct sockaddr_vm *)msg->msg_name;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tnoblock = flags & MSG_DONTWAIT;\n\n\tif (flags & MSG_OOB || flags & MSG_ERRQUEUE)\n\t\treturn -EOPNOTSUPP;\n\n\tmsg->msg_namelen = 0;\n\n\t/* Retrieve the head sk_buff from the socket's receive queue. */\n\terr = 0;\n\tskb = skb_recv_datagram(&vsk->sk, flags, noblock, &err);\n\tif (err)\n\t/* Place the datagram payload in the user's iovec. */\n\terr = skb_copy_datagram_iovec(skb, sizeof(*dg), msg->msg_iov,\n\t\tpayload_len);\n\tif (err)\n\t\tgoto out;\n\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_vm *vm_addr;\n\n\t\t/* Provide the address of the sender. */\n\t\tvm_addr = (struct sockaddr_vm *)msg->msg_name;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    struct stat *st, char *range_str)\n{\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct media_type\t*media, multipart_media;\n\tstruct range\t\t*range;\n\tstruct evbuffer\t\t*evb = NULL;\n\tsize_t\t\t\t content_length;\n\tint\t\t\t code = 500, fd = -1, i, nranges, ret;\n\tuint32_t\t\t boundary;\n\tchar\t\t\t content_range[64];\n\tconst char\t\t*errstr = NULL;\n\n\t/* Ignore range request for methods other than GET */\n\tif (desc->http_method != HTTP_METHOD_GET)\n\t\treturn server_file_request(env, clt, path, st);\n\n\tif ((range = parse_range(range_str, st->st_size, &nranges)) == NULL) {\n\t\tcode = 416;\n\t\t(void)snprintf(content_range, sizeof(content_range),\n\t\t    \"bytes */%lld\", st->st_size);\n\t\terrstr = content_range;\n\t\tgoto abort;\n\t/* Now open the file, should be readable or we have another problem */\n\tif ((fd = open(path, O_RDONLY)) == -1)\n\t\tgoto abort;\n\n\tmedia = media_find_config(env, srv_conf, path);\n\tif ((evb = evbuffer_new()) == NULL) {\n\t\terrstr = \"failed to allocate file buffer\";\n\t\tgoto abort;\n\t}\n\n\tif (nranges == 1) {\n\t\t(void)snprintf(content_range, sizeof(content_range),\n\t\t    \"bytes %lld-%lld/%lld\", range->start, range->end,\n\t\t    st->st_size);\n\t\tif (kv_add(&resp->http_headers, \"Content-Range\",\n\t\t    content_range) == NULL)\n\t\t\tgoto abort;\n\n\t\tcontent_length = range->end - range->start + 1;\n\t\tif (buffer_add_range(fd, evb, range) == 0)\n\t\t\tgoto abort;\n\n\t} else {\n\t\tcontent_length = 0;\n\t\tboundary = arc4random();\n\t\t/* Generate a multipart payload of byteranges */\n\t\twhile (nranges--) {\n\t\t\tif ((i = evbuffer_add_printf(evb, \"\\r\\n--%ud\\r\\n\",\n\t\t\t    boundary)) == -1)\n\t\t\t\tgoto abort;\n\n\t\t\tcontent_length += i;\n\t\t\tif ((i = evbuffer_add_printf(evb,\n\t\t\t    \"Content-Type: %s/%s\\r\\n\",\n\t\t\t    media->media_type, media->media_subtype)) == -1)\n\t\t\t\tgoto abort;\n\n\t\t\tcontent_length += i;\n\t\t\tif ((i = evbuffer_add_printf(evb,\n\t\t\t    \"Content-Range: bytes %lld-%lld/%lld\\r\\n\\r\\n\",\n\t\t\t    range->start, range->end, st->st_size)) == -1)\n\t\t\t\tgoto abort;\n\n\t\t\tcontent_length += i;\n\t\t\tif (buffer_add_range(fd, evb, range) == 0)\n\t\t\t\tgoto abort;\n\n\t\t\tcontent_length += range->end - range->start + 1;\n\t\t\trange++;\n\t\t}\n\n\t\tif ((i = evbuffer_add_printf(evb, \"\\r\\n--%ud--\\r\\n\",\n\t\t    boundary)) == -1)\n\t\t\tgoto abort;\n\n\t\tcontent_length += i;\n\n\t\t/* prepare multipart/byteranges media type */\n\t\t(void)strlcpy(multipart_media.media_type, \"multipart\",\n\t\t    sizeof(multipart_media.media_type));\n\t\t(void)snprintf(multipart_media.media_subtype,\n\t\t    sizeof(multipart_media.media_subtype),\n\t\t    \"byteranges; boundary=%ud\", boundary);\n\t\tmedia = &multipart_media;\n\t}\n\n\tclose(fd);\n\tfd = -1;\n\n\tret = server_response_http(clt, 206, media, content_length,\n\t    MINIMUM(time(NULL), st->st_mtim.tv_sec));\n\tswitch (ret) {\n\tcase -1:\n\t\tgoto fail;\n\tcase 0:\n\t\t/* Connection is already finished */\n\t\tgoto done;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (server_bufferevent_write_buffer(clt, evb) == -1)\n\t\tgoto fail;\n\n\tbufferevent_enable(clt->clt_bev, EV_READ|EV_WRITE);\n\tif (clt->clt_persist)\n\t\tclt->clt_toread = TOREAD_HTTP_HEADER;\n\telse\n\t\tclt->clt_toread = TOREAD_HTTP_NONE;\n\tclt->clt_done = 0;\n\n done:\n\tevbuffer_free(evb);\n\tserver_reset_http(clt);\n\treturn (0);\n fail:\n\tbufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);\n\tbufferevent_free(clt->clt_bev);\n\tclt->clt_bev = NULL;\n abort:\n\tif (evb != NULL)\n\t\tevbuffer_free(evb);\n\tif (fd != -1)\n\t\tclose(fd);\n\tif (errstr == NULL)\n\t\terrstr = strerror(errno);\n\tserver_abort_http(clt, code, errstr);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n\tstruct server_config\t*srv_conf = clt->clt_srv_conf;\n\tstruct http_descriptor\t*resp = clt->clt_descresp;\n\tstruct http_descriptor\t*desc = clt->clt_descreq;\n\tstruct media_type\t*media, multipart_media;\n\tstruct range_data\t*r = &clt->clt_ranges;\n\tstruct range\t\t*range;\n\tsize_t\t\t\t content_length = 0;\n\tint\t\t\t code = 500, fd = -1, i, nranges, ret;\n\tchar\t\t\t content_range[64];\n\tconst char\t\t*errstr = NULL;\n\n\t/* Ignore range request for methods other than GET */\n\tif (desc->http_method != HTTP_METHOD_GET)\n\t\treturn server_file_request(env, clt, path, st);\n\n\tif ((nranges = parse_ranges(clt, range_str, st->st_size)) < 1) {\n\t\tcode = 416;\n\t\t(void)snprintf(content_range, sizeof(content_range),\n\t\t    \"bytes */%lld\", st->st_size);\n\t\terrstr = content_range;\n\t\tgoto abort;\n\t/* Now open the file, should be readable or we have another problem */\n\tif ((fd = open(path, O_RDONLY)) == -1)\n\t\tgoto abort;\n\n\tmedia = media_find_config(env, srv_conf, path);\n\tr->range_media = media;\n\n\tif (nranges == 1) {\n\t\trange = &r->range[0];\n\t\t(void)snprintf(content_range, sizeof(content_range),\n\t\t    \"bytes %lld-%lld/%lld\", range->start, range->end,\n\t\t    st->st_size);\n\t\tif (kv_add(&resp->http_headers, \"Content-Range\",\n\t\t    content_range) == NULL)\n\t\t\tgoto abort;\n\n\t\trange = &r->range[0];\n\t\tcontent_length += range->end - range->start + 1;\n\t} else {\n\t\t/* Add boundary, all parts will be handled by the callback */\n\t\tarc4random_buf(&clt->clt_boundary, sizeof(clt->clt_boundary));\n\n\t\t/* Calculate Content-Length of the complete multipart body */\n\t\tfor (i = 0; i < nranges; i++) {\n\t\t\trange = &r->range[i];\n\n\t\t\t/* calculate Content-Length of the complete body */\n\t\t\tif ((ret = snprintf(NULL, 0,\n\t\t\t    \"\\r\\n--%llu\\r\\n\"\n\t\t\t    \"Content-Type: %s/%s\\r\\n\"\n\t\t\t    \"Content-Range: bytes %lld-%lld/%lld\\r\\n\\r\\n\",\n\t\t\t    clt->clt_boundary,\n\t\t\t    media->media_type, media->media_subtype,\n\t\t\t    range->start, range->end, st->st_size)) < 0)\n\t\t\t\tgoto abort;\n\n\t\t\t/* Add data length */\n\t\t\tcontent_length += ret + range->end - range->start + 1;\n\n\t\t}\n\t\tif ((ret = snprintf(NULL, 0, \"\\r\\n--%llu--\\r\\n\",\n\t\t    clt->clt_boundary)) < 0)\n\t\t\tgoto abort;\n\t\tcontent_length += ret;\n\n\t\t/* prepare multipart/byteranges media type */\n\t\t(void)strlcpy(multipart_media.media_type, \"multipart\",\n\t\t    sizeof(multipart_media.media_type));\n\t\t(void)snprintf(multipart_media.media_subtype,\n\t\t    sizeof(multipart_media.media_subtype),\n\t\t    \"byteranges; boundary=%llu\", clt->clt_boundary);\n\t\tmedia = &multipart_media;\n\t}\n\n\t/* Start with first range */\n\tr->range_toread = TOREAD_HTTP_RANGE;\n\n\tret = server_response_http(clt, 206, media, content_length,\n\t    MINIMUM(time(NULL), st->st_mtim.tv_sec));\n\tswitch (ret) {\n\tcase -1:\n\t\tgoto fail;\n\tcase 0:\n\t\t/* Connection is already finished */\n\t\tclose(fd);\n\t\tgoto done;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tclt->clt_fd = fd;\n\tif (clt->clt_srvbev != NULL)\n\t\tbufferevent_free(clt->clt_srvbev);\n\n\tclt->clt_srvbev_throttled = 0;\n\tclt->clt_srvbev = bufferevent_new(clt->clt_fd, server_read_httprange,\n\t    server_write, server_file_error, clt);\n\tif (clt->clt_srvbev == NULL) {\n\t\terrstr = \"failed to allocate file buffer event\";\n\t\tgoto fail;\n\t}\n\n\t/* Adjust read watermark to the socket output buffer size */\n\tbufferevent_setwatermark(clt->clt_srvbev, EV_READ, 0,\n\t    clt->clt_sndbufsiz);\n\n\tbufferevent_settimeout(clt->clt_srvbev,\n\t    srv_conf->timeout.tv_sec, srv_conf->timeout.tv_sec);\n\tbufferevent_enable(clt->clt_srvbev, EV_READ);\n\tbufferevent_disable(clt->clt_bev, EV_READ);\n\n done:\n\tserver_reset_http(clt);\n\treturn (0);\n fail:\n\tbufferevent_disable(clt->clt_bev, EV_READ|EV_WRITE);\n\tbufferevent_free(clt->clt_bev);\n\tclt->clt_bev = NULL;\n abort:\n\tif (fd != -1)\n\t\tclose(fd);\n\tif (errstr == NULL)\n\t\terrstr = strerror(errno);\n\tserver_abort_http(clt, code, errstr);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\n\t\tcb->args[0] = 1;\n\n\t\terr = nlmsg_parse(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t  xfrma_policy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t}\n\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t}\n\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\n\treturn skb->len;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\n\t\terr = nlmsg_parse(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t  xfrma_policy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t\tcb->args[0] = 1;\n\t}\n\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\n\treturn skb->len;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tspectre_v2_enabled = mode;\n\tpr_info(\"%s\\n\", spectre_v2_strings[mode]);\n\n\t/*\n\t * If neither SMEP nor PTI are available, there is a risk of\n\t * hitting userspace addresses in the RSB after a context switch\n\t * from a shallow call stack to a deeper one. To prevent this fill\n\t * the entire RSB, even when using IBRS.\n\t *\n\t * Skylake era CPUs have a separate issue with *underflow* of the\n\t * RSB, when they will predict 'ret' targets from the generic BTB.\n\t * The proper mitigation for this is IBRS. If IBRS is not supported\n\t * or deactivated in favour of retpolines the RSB fill on context\n\t * switch is required.\n\t */\n\tif ((!boot_cpu_has(X86_FEATURE_PTI) &&\n\t     !boot_cpu_has(X86_FEATURE_SMEP)) || is_skylake_era()) {\n\t\tsetup_force_cpu_cap(X86_FEATURE_RSB_CTXSW);\n\t\tpr_info(\"Spectre v2 mitigation: Filling RSB on context switch\\n\");\n\t}\n\n\t/* Initialize Indirect Branch Prediction Barrier if supported */\n\tif (boot_cpu_has(X86_FEATURE_IBPB)) {\n\t\tsetup_force_cpu_cap(X86_FEATURE_USE_IBPB);\n\t\tpr_info(\"Spectre v2 mitigation: Enabling Indirect Branch Prediction Barrier\\n\");",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tspectre_v2_enabled = mode;\n\tpr_info(\"%s\\n\", spectre_v2_strings[mode]);\n\n\t/*\n\t * If spectre v2 protection has been enabled, unconditionally fill\n\t * RSB during a context switch; this protects against two independent\n\t * issues:\n\t *\n\t *\t- RSB underflow (and switch to BTB) on Skylake+\n\t *\t- SpectreRSB variant of spectre v2 on X86_BUG_SPECTRE_V2 CPUs\n\t */\n\tsetup_force_cpu_cap(X86_FEATURE_RSB_CTXSW);\n\tpr_info(\"Spectre v2 / SpectreRSB mitigation: Filling RSB on context switch\\n\");\n\n\t/* Initialize Indirect Branch Prediction Barrier if supported */\n\tif (boot_cpu_has(X86_FEATURE_IBPB)) {\n\t\tsetup_force_cpu_cap(X86_FEATURE_USE_IBPB);\n\t\tpr_info(\"Spectre v2 mitigation: Enabling Indirect Branch Prediction Barrier\\n\");",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tstatus = (auth->setup)(ctx, pw, &prompt, auth);\n\t\tif (status == AUTH_FAILURE)\n\t\t    SET(auth->flags, FLAG_DISABLED);\n\t\telse if (status == AUTH_NONINTERACTIVE)\n\t\t    goto done;\n\t\telse if (status == AUTH_ERROR || user_interrupted())\n\t\t    goto done;\t\t/* assume error msg already printed */\n\t    }\n\t}\n\tif (num_methods == 0) {\n\t    audit_failure(ctx, ctx->runas.argv,\n\t    ret = false;\n\t    break;\n\tcase AUTH_NONINTERACTIVE:\n\t    SET(validated, FLAG_NO_USER_INPUT);\n\t    FALLTHROUGH;\n\tcase AUTH_ERROR:\n\tdefault:\n\t    log_auth_failure(ctx, validated, 0);\n\t    ret = -1;\n\t    break;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tstatus = (auth->setup)(ctx, pw, &prompt, auth);\n\t\tif (status == AUTH_FAILURE)\n\t\t    SET(auth->flags, FLAG_DISABLED);\n\t\telse if (status == AUTH_NONINTERACTIVE)\n\t\t    goto done;\n\t\telse if (status != AUTH_SUCCESS || user_interrupted())\n\t\t    goto done;\t\t/* assume error msg already printed */\n\t    }\n\t}\n\tif (num_methods == 0) {\n\t    audit_failure(ctx, ctx->runas.argv,\n\t    log_auth_failure(ctx, validated, ntries);\n\t    ret = false;\n\t    break;\n\tcase AUTH_NONINTERACTIVE:\n\t    SET(validated, FLAG_NO_USER_INPUT);\n\t    FALLTHROUGH;\n\tdefault:\n\t    log_auth_failure(ctx, validated, 0);\n\t    ret = -1;\n\t    break;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "forbidden_name(struct compiling *c, identifier name, const node *n,\n               int full_checks)\n{\n    assert(PyUnicode_Check(name));\n    if (PyUnicode_CompareWithASCIIString(name, \"__debug__\") == 0) {\n        ast_error(c, n, \"assignment to keyword\");\n        return 1;\n    }\n    if (full_checks) {\n        const char * const *p;\n        for (p = FORBIDDEN; *p; p++) {\n            if (PyUnicode_CompareWithASCIIString(name, *p) == 0) {\n                ast_error(c, n, \"assignment to keyword\");\n                return 1;\n            }\n        }\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "forbidden_name(struct compiling *c, identifier name, const node *n,\n               int full_checks)\n{\n    assert(PyUnicode_Check(name));\n    if (_PyUnicode_EqualToASCIIString(name, \"__debug__\")) {\n        ast_error(c, n, \"assignment to keyword\");\n        return 1;\n    }\n    if (full_checks) {\n        const char * const *p;\n        for (p = FORBIDDEN; *p; p++) {\n            if (_PyUnicode_EqualToASCIIString(name, *p)) {\n                ast_error(c, n, \"assignment to keyword\");\n                return 1;\n            }\n        }\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\targ_pattern = Z_STRVAL_PP(arg_pattern_zval);\n\t\targ_pattern_len = Z_STRLEN_PP(arg_pattern_zval);\n\t} else {\n\t\t/* FIXME: this code is not multibyte aware! */\n\t\tconvert_to_long_ex(arg_pattern_zval);\n\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\t\n\t\tpat_buf[1] = '\\0';\n\n\t\targ_pattern = pat_buf;\n\t\targ_pattern_len = 1;\t\n\t}\n\t/* create regex pattern buffer */\n\tre = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);\n\tif (re == NULL) {\n\t\tRETURN_FALSE;\n\t\t\t\t\t\tp += fwd;\n\t\t\t\t\t\ti += fwd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\tif (eval) {\n\t\t\t\tzval v;\n\t\t\t\t/* null terminate buffer */\n\t\t\t\tsmart_str_0(&eval_buf);\n\t\t\t\t/* do eval */\n\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL(v), Z_STRLEN(v));\n\t\t\t\t/* Clean up */\n\t\t\t\teval_buf.len = 0;\n\t\t\t\tzval_dtor(&v);\n\t\t\t} else if (is_callable) {\n\t\t\t\tzval *retval_ptr;\n\t\t\t\tzval **args[1];\n\t\t\t\tzval *subpats;\n\t\t\t\tint i;\n\t\t\t\t\n\t\t\t\tMAKE_STD_ZVAL(subpats);\n\t\t\t\tarray_init(subpats);\n\t\t\t\t\n\t\t\t\tfor (i = 0; i < regs->num_regs; i++) {\n\t\t\t\t\tadd_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);\n\t\t\t\t}\t\t\t\t\n\t\t\t\t\n\t\t\t\targs[0] = &subpats;\n\t\t\t\t/* null terminate buffer */\n\t\t\t\tsmart_str_0(&eval_buf);\n\t\t\t\t\n\t\t\t\targ_replace_fci.param_count = 1;\n\t\t\t\targ_replace_fci.params = args;\n\t\t\t\targ_replace_fci.retval_ptr_ptr = &retval_ptr;\n\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {\n\t\t\t\t\tconvert_to_string_ex(&retval_ptr);\n\t\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));\n\t\t\t\t\teval_buf.len = 0;\n\t\t\t\t\tzval_ptr_dtor(&retval_ptr);\n\t\t\t\t} else {\n\t\t\t\t\tefree(description);\n\t\t\t\t\tif (!EG(exception)) {\n\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call custom replacement function\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tzval_ptr_dtor(&subpats);\n\t\t\tn = regs->end[0];\n\t\t\tif ((pos - (OnigUChar *)string) < n) {\n\t\t\t\tpos = (OnigUChar *)string + n;\n\t\t\t} else {\n\t\t\t\tif (pos < string_lim) {\n\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1); \n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t} else { /* nomatch */\n\t\t\t/* stick that last bit of string on our output */\n\t\tonig_region_free(regs, 1);\n\t}\n\tsmart_str_free(&eval_buf);\n\n\tif (err <= -2) {\n\t\tsmart_str_free(&out_buf);\t\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tsmart_str_appendc(&out_buf, '\\0');\n\t\tRETVAL_STRINGL((char *)out_buf.c, out_buf.len - 1, 0);\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\targ_pattern = Z_STRVAL_PP(arg_pattern_zval);\n\t\targ_pattern_len = Z_STRLEN_PP(arg_pattern_zval);\n\t} else {\n\t\t/* FIXME: this code is not multibyte aware! */\n\t\tconvert_to_long_ex(arg_pattern_zval);\n\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\n\t\tpat_buf[1] = '\\0';\n\n\t\targ_pattern = pat_buf;\n\t\targ_pattern_len = 1;\n\t}\n\t/* create regex pattern buffer */\n\tre = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);\n\tif (re == NULL) {\n\t\tRETURN_FALSE;\n\t\t\t\t\t\tp += fwd;\n\t\t\t\t\t\ti += fwd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (eval) {\n\t\t\t\tzval v;\n\t\t\t\t/* null terminate buffer */\n\t\t\t\tsmart_str_0(&eval_buf);\n\t\t\t\t/* do eval */\n\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL(v), Z_STRLEN(v));\n\t\t\t\t/* Clean up */\n\t\t\t\teval_buf.len = 0;\n\t\t\t\tzval_dtor(&v);\n\t\t\t} else if (is_callable) {\n\t\t\t\tzval *retval_ptr = NULL;\n\t\t\t\tzval **args[1];\n\t\t\t\tzval *subpats;\n\t\t\t\tint i;\n\n\t\t\t\tMAKE_STD_ZVAL(subpats);\n\t\t\t\tarray_init(subpats);\n\n\t\t\t\tfor (i = 0; i < regs->num_regs; i++) {\n\t\t\t\t\tadd_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);\n\t\t\t\t}\n\n\t\t\t\targs[0] = &subpats;\n\t\t\t\t/* null terminate buffer */\n\t\t\t\tsmart_str_0(&eval_buf);\n\n\t\t\t\targ_replace_fci.param_count = 1;\n\t\t\t\targ_replace_fci.params = args;\n\t\t\t\targ_replace_fci.retval_ptr_ptr = &retval_ptr;\n\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {\n\t\t\t\t\tconvert_to_string_ex(&retval_ptr);\n\t\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));\n\t\t\t\t\teval_buf.len = 0;\n\t\t\t\t\tzval_ptr_dtor(&retval_ptr);\n\t\t\t\t} else {\n\t\t\t\t\tif (!EG(exception)) {\n\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call custom replacement function\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tzval_ptr_dtor(&subpats);\n\t\t\tn = regs->end[0];\n\t\t\tif ((pos - (OnigUChar *)string) < n) {\n\t\t\t\tpos = (OnigUChar *)string + n;\n\t\t\t} else {\n\t\t\t\tif (pos < string_lim) {\n\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1);\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t} else { /* nomatch */\n\t\t\t/* stick that last bit of string on our output */\n\t\tonig_region_free(regs, 1);\n\t}\n\tsmart_str_free(&eval_buf);\n\n\tif (err <= -2) {\n\t\tsmart_str_free(&out_buf);\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tsmart_str_appendc(&out_buf, '\\0');\n\t\tRETVAL_STRINGL((char *)out_buf.c, out_buf.len - 1, 0);\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tif (!s.isDirty ()) {\n\t\t\t    y2debug (\"Skipping file %s that was not changed.\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\ts.initReadBy ();\n\t\t\t// ensure that the directories exist\n\t\t\tPathname pn (filename);\n\t\t\tPathInfo::assert_dir (pn.dirname ());\n\t\t\tofstream of(filename.c_str());\n\t\t\tif (!of.good())\n\t\t\t{\n\t\t\t    bugs++;\n\t\t\t    y2error (\"Can not open file %s for write\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\twrite_helper (s, of, 0);\n\t\t\ts.clean();\n\t\t\tof.close ();\n\t\t    }\n\t\telse\n\t\t    {\n\t\t\ty2error (\"Value %s encountered at multifile top level\",\n\t\t\t\t ci->e ().getName ());\n\t\tunlink ((*i).c_str());\n\t    }\n    }\n    else\n    {\n\t// ensure that the directories exist\n\tPathname pn (file);\n\tPathInfo::assert_dir (pn.dirname ());\n\tofstream of(file.c_str());\n\tif (!of.good())\n\t{\n\t    y2error (\"Can not open file %s for write\", file.c_str());\n\t    return -1;\n\t}\n\n\twrite_helper (inifile, of, 0);\n\n\tof.close();\n\ttimestamp = getTimeStamp ();\n    }\n    inifile.clean ();\n    return bugs ? -1 : 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tif (!s.isDirty ()) {\n\t\t\t    y2debug (\"Skipping file %s that was not changed.\", filename.c_str());\n\t\t\t    continue;\n\t\t\t}\n\t\t\ts.initReadBy ();\n                        bugs += write_file(filename, s);\n\t\t    }\n\t\telse\n\t\t    {\n\t\t\ty2error (\"Value %s encountered at multifile top level\",\n\t\t\t\t ci->e ().getName ());\n\t\tunlink ((*i).c_str());\n\t    }\n    }\n    else\n    {\n        bugs += write_file(file, inifile);\n\ttimestamp = getTimeStamp ();\n    }\n    return bugs ? -1 : 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  mysql->client_flag|= CLIENT_CAPABILITIES;\n\n  if (mysql->client_flag & CLIENT_MULTI_STATEMENTS)\n    mysql->client_flag|= CLIENT_MULTI_RESULTS;\n\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  if (mysql->options.ssl_key || mysql->options.ssl_cert ||\n      mysql->options.ssl_ca || mysql->options.ssl_capath ||\n      mysql->options.ssl_cipher ||\n      (mysql->options.extension && mysql->options.extension->ssl_crl) || \n      (mysql->options.extension && mysql->options.extension->ssl_crlpath))\n    mysql->options.use_ssl= 1;\n  if (mysql->options.use_ssl)\n    mysql->client_flag|= CLIENT_SSL;\n#endif /* HAVE_OPENSSL && !EMBEDDED_LIBRARY*/\n  if (mpvio->db)\n    mysql->client_flag|= CLIENT_CONNECT_WITH_DB;\n  else\n    mysql->client_flag&= ~CLIENT_CONNECT_WITH_DB;\n    int2store(buff, mysql->client_flag);\n    int3store(buff+2, net->max_packet_size);\n    end= buff+5;\n  }\n#ifdef HAVE_OPENSSL\n  if (mysql->client_flag & CLIENT_SSL)\n  {\n    /* Do the SSL layering. */\n    struct st_mysql_options *options= &mysql->options;\n    struct st_VioSSLFd *ssl_fd;\n    enum enum_ssl_init_error ssl_init_error;\n    const char *cert_error;\n    unsigned long ssl_error;\n\n    /*\n      Send mysql->client_flag, max_packet_size - unencrypted otherwise\n      the server does not know we want to do SSL\n    */\n      goto error;\n    }\n\n    MYSQL_TRACE(SSL_CONNECTED, mysql, ());\n    MYSQL_TRACE_STAGE(mysql, AUTHENTICATE);\n  }\n#endif /* HAVE_OPENSSL */\n\n  DBUG_PRINT(\"info\",(\"Server version = '%s'  capabilites: %lu  status: %u  client_flag: %lu\",\n\t\t     mysql->server_version, mysql->server_capabilities,\n\t\t     mysql->server_status, mysql->client_flag));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n  if (mysql->client_flag & CLIENT_MULTI_STATEMENTS)\n    mysql->client_flag|= CLIENT_MULTI_RESULTS;\n\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  /* consider SSL if any of the SSL mysql_options() is issued */\n  if (mysql->options.ssl_key || mysql->options.ssl_cert ||\n      mysql->options.ssl_ca || mysql->options.ssl_capath ||\n      mysql->options.ssl_cipher ||\n      (mysql->options.extension && mysql->options.extension->ssl_crl) ||\n      (mysql->options.extension && mysql->options.extension->ssl_crlpath) ||\n      (mysql->options.extension && mysql->options.extension->ssl_enforce))\n    mysql->options.use_ssl = TRUE;\n  if (mysql->options.use_ssl)\n    mysql->client_flag |= CLIENT_SSL;\n#endif /* HAVE_OPENSSL && !EMBEDDED_LIBRARY*/\n  if (mpvio->db)\n    mysql->client_flag|= CLIENT_CONNECT_WITH_DB;\n  else\n    mysql->client_flag&= ~CLIENT_CONNECT_WITH_DB;\n    int2store(buff, mysql->client_flag);\n    int3store(buff+2, net->max_packet_size);\n    end= buff+5;\n  }\n#ifdef HAVE_OPENSSL\n\n  if (mysql->options.extension && mysql->options.extension->ssl_enforce)\n  {\n    /*\n      ssl_enforce=1 means enforce ssl\n      Don't fallback on unencrypted connection.\n    */\n    /* can't turn enforce on without turning on use_ssl too */\n    DBUG_ASSERT(mysql->options.use_ssl);\n    /* enforce=true takes precendence over use=false */\n    if (!(mysql->server_capabilities & CLIENT_SSL))\n    {\n      set_mysql_extended_error(mysql, CR_SSL_CONNECTION_ERROR, unknown_sqlstate,\n                               ER(CR_SSL_CONNECTION_ERROR),\n                               \"SSL is required but the server doesn't \"\n                               \"support it\"\n                               );\n      goto error;\n    }\n  }\n\n  /*\n\n   use_ssl=0 => Disable ssl and connect using unencrypted channel if server\n     allows it\n\n   use_ssl=1, ssl_enforce=0 (default) => attempt ssl connection if possible but\n     fallback on unencrypted connection if possible.\n\n  */\n  if ((mysql->server_capabilities & CLIENT_SSL) && mysql->options.use_ssl)\n  {\n    /* Do the SSL layering. */\n    struct st_mysql_options *options= &mysql->options;\n    struct st_VioSSLFd *ssl_fd;\n    enum enum_ssl_init_error ssl_init_error;\n    const char *cert_error;\n    unsigned long ssl_error;\n\n    if (!mysql->options.ssl_cipher)\n    {\n      SET_OPTION(ssl_cipher, default_ssl_cipher);\n    }\n\n    /*\n      Send mysql->client_flag, max_packet_size - unencrypted otherwise\n      the server does not know we want to do SSL\n    */\n    }\n\n    MYSQL_TRACE(SSL_CONNECTED, mysql, ());\n    MYSQL_TRACE_STAGE(mysql, AUTHENTICATE);\n  }\n\n#endif /* HAVE_OPENSSL */\n\n  DBUG_PRINT(\"info\",(\"Server version = '%s'  capabilites: %lu  status: %u  client_flag: %lu\",\n\t\t     mysql->server_version, mysql->server_capabilities,\n\t\t     mysql->server_status, mysql->client_flag));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      goto Cfunc;\n    case LUA_VLCF:  /* light C function */\n      f = fvalue(s2v(func));\n     Cfunc: {\n      int n;  /* number of returns */\n      CallInfo *ci = next_ci(L);\n      checkstackp(L, LUA_MINSTACK, func);  /* ensure minimum stack size */\n      ci->nresults = nresults;\n      ci->callstatus = CIST_C;\n      ci->top = L->top + LUA_MINSTACK;\n      ci->func = func;\n      L->ci = ci;\n      lua_assert(ci->top <= L->stack_last);\n      if (L->hookmask & LUA_MASKCALL) {\n        int narg = cast_int(L->top - func) - 1;\n        luaD_hook(L, LUA_HOOKCALL, -1, 1, narg);\n      }\n      api_checknelems(L, n);\n      luaD_poscall(L, ci, n);\n      break;\n    }\n    case LUA_VLCL: {  /* Lua function */\n      CallInfo *ci = next_ci(L);\n      Proto *p = clLvalue(s2v(func))->p;\n      int narg = cast_int(L->top - func) - 1;  /* number of real arguments */\n      int nfixparams = p->numparams;\n      int fsize = p->maxstacksize;  /* frame size */\n      checkstackp(L, fsize, func);\n      ci->nresults = nresults;\n      ci->u.l.savedpc = p->code;  /* starting point */\n      ci->callstatus = 0;\n      ci->top = func + 1 + fsize;\n      ci->func = func;\n      lua_assert(ci->top <= L->stack_last);\n      luaV_execute(L, ci);  /* run the function */\n      break;\n    }\n    default: {  /* not a function */\n      checkstackp(L, 1, func);  /* space for metamethod */\n      luaD_tryfuncTM(L, func);  /* try to get '__call' metamethod */\n      goto retry;  /* try again with metamethod */\n    }\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      goto Cfunc;\n    case LUA_VLCF:  /* light C function */\n      f = fvalue(s2v(func));\n     Cfunc: {\n      int n;  /* number of returns */\n      CallInfo *ci;\n      checkstackGCp(L, LUA_MINSTACK, func);  /* ensure minimum stack size */\n      L->ci = ci = next_ci(L);\n      ci->nresults = nresults;\n      ci->callstatus = CIST_C;\n      ci->top = L->top + LUA_MINSTACK;\n      ci->func = func;\n      lua_assert(ci->top <= L->stack_last);\n      if (L->hookmask & LUA_MASKCALL) {\n        int narg = cast_int(L->top - func) - 1;\n        luaD_hook(L, LUA_HOOKCALL, -1, 1, narg);\n      }\n      api_checknelems(L, n);\n      luaD_poscall(L, ci, n);\n      break;\n    }\n    case LUA_VLCL: {  /* Lua function */\n      CallInfo *ci;\n      Proto *p = clLvalue(s2v(func))->p;\n      int narg = cast_int(L->top - func) - 1;  /* number of real arguments */\n      int nfixparams = p->numparams;\n      int fsize = p->maxstacksize;  /* frame size */\n      checkstackGCp(L, fsize, func);\n      L->ci = ci = next_ci(L);\n      ci->nresults = nresults;\n      ci->u.l.savedpc = p->code;  /* starting point */\n      ci->callstatus = 0;\n      ci->top = func + 1 + fsize;\n      ci->func = func;\n      lua_assert(ci->top <= L->stack_last);\n      luaV_execute(L, ci);  /* run the function */\n      break;\n    }\n    default: {  /* not a function */\n      checkstackGCp(L, 1, func);  /* space for metamethod */\n      luaD_tryfuncTM(L, func);  /* try to get '__call' metamethod */\n      goto retry;  /* try again with metamethod */\n    }\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    // For each given example, traverse through all trees keeping track of the\n    // features used to split and the associated logits at each point along the\n    // path. Note: feature_ids has one less value than logits_path because the\n    // first value of each logit path will be the bias.\n    auto do_work = [&resource, &bucketized_features, &output_debug_info,\n                    last_tree](int32 start, int32 end) {\n      for (int32 i = start; i < end; ++i) {\n        // Proto to store debug outputs, per example.\n        boosted_trees::DebugOutput example_debug_info;\n        // Initial bias prediction. E.g., prediction based off training mean.\n        const auto& tree_logits = resource->node_value(0, 0);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    // For each given example, traverse through all trees keeping track of the\n    // features used to split and the associated logits at each point along the\n    // path. Note: feature_ids has one less value than logits_path because the\n    // first value of each logit path will be the bias.\n    auto do_work = [&resource, &bucketized_features, &output_debug_info,\n                    last_tree](int64 start, int64 end) {\n      for (int32 i = start; i < end; ++i) {\n        // Proto to store debug outputs, per example.\n        boosted_trees::DebugOutput example_debug_info;\n        // Initial bias prediction. E.g., prediction based off training mean.\n        const auto& tree_logits = resource->node_value(0, 0);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n\t\n    *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n\t\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n    \n    /* By setting to 0xAA, we expose bugs in\n    yy_init_globals. Leave at 0x00 for releases. */\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n    \n    re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n    \n    return yy_init_globals ( *ptr_yy_globals );",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n\n    *ptr_yy_globals = (yyscan_t) re_yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n\n    /* By setting to 0xAA, we expose bugs in\n    yy_init_globals. Leave at 0x00 for releases. */\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n\n    re_yyset_extra (yy_user_defined, *ptr_yy_globals);\n\n    return yy_init_globals ( *ptr_yy_globals );",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\n\t\treturn err;\n\t}\n\n\tskblen = skb->len;\n\tcopied = skb->len;\n\t\t\t\t sizeof(pkt_status), &pkt_status);\n\t\t}\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skblen;\n\n\treturn err ? : copied;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tlock_sock(sk);\n\n\tskb = skb_recv_datagram(sk, flags, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\terr = 0;\n\n\t\trelease_sock(sk);\n\t\treturn err;\n\t}\n\n\tskblen = skb->len;\n\tcopied = skb->len;\n\t\t}\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\trelease_sock(sk);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skblen;\n\n\treturn err ? : copied;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    if (r == 0) {\n        // n - 1 is odd, so n was even. But there is only one even prime:\n        return n == 2;\n    }\n\n    for (auto a : tests) {\n        // Technically: ASSERT(2 <= a && a <= n - 2)\n        ASSERT(a < n);\n        auto x = ModularPower(a, d, n);\n        if (x == 1 || x == predecessor)\n            continue;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    if (r == 0) {\n        // n - 1 is odd, so n was even. But there is only one even prime:\n        return n == 2;\n    }\n\n    for (auto& a : tests) {\n        // Technically: ASSERT(2 <= a && a <= n - 2)\n        ASSERT(a < n);\n        auto x = ModularPower(a, d, n);\n        if (x == 1 || x == predecessor)\n            continue;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n  std::vector<const NodeDef*> train_nodes;\n  TF_RETURN_IF_ERROR(ComputeTransitiveFanin(graph_, item.fetch, &train_nodes));\n  LOG(INFO) << \"Number of training nodes: \" << train_nodes.size();\n\n  const NodeDef* dequeue_node;\n  for (const auto& train_node : train_nodes) {\n    if (IsDequeueOp(*train_node)) {\n      dequeue_node = train_node;\n      break;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n  std::vector<const NodeDef*> train_nodes;\n  TF_RETURN_IF_ERROR(ComputeTransitiveFanin(graph_, item.fetch, &train_nodes));\n  LOG(INFO) << \"Number of training nodes: \" << train_nodes.size();\n\n  const NodeDef* dequeue_node = nullptr;\n  for (const auto& train_node : train_nodes) {\n    if (IsDequeueOp(*train_node)) {\n      dequeue_node = train_node;\n      break;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n\tget_file(file);\n\t*res = file;\n\treturn filp_close(file, files);\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\t*res = NULL;\n\treturn -ENOENT;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t__put_unused_fd(files, fd);\n\tspin_unlock(&files->file_lock);\n\tget_file(file);\n\t*res = file;\n\treturn 0;\n\nout_unlock:\n\tspin_unlock(&files->file_lock);\n\t*res = NULL;\n\treturn -ENOENT;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ast_for_async_stmt(struct compiling *c, const node *n)\n{\n    /* async_stmt: ASYNC (funcdef | with_stmt | for_stmt) */\n    REQ(n, async_stmt);\n    REQ(CHILD(n, 0), ASYNC);\n\n    switch (TYPE(CHILD(n, 1))) {\n        case funcdef:\n            return ast_for_funcdef_impl(c, CHILD(n, 1), NULL,\n                                        1 /* is_async */);\n        case with_stmt:\n            return ast_for_with_stmt(c, CHILD(n, 1),\n                                     1 /* is_async */);\n\n        case for_stmt:\n            return ast_for_for_stmt(c, CHILD(n, 1),\n                                    1 /* is_async */);\n\n        default:\n            PyErr_Format(PyExc_SystemError,\n                         \"invalid async stament: %s\",\n                         STR(CHILD(n, 1)));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ast_for_async_stmt(struct compiling *c, const node *n)\n{\n    /* async_stmt: 'async' (funcdef | with_stmt | for_stmt) */\n    REQ(n, async_stmt);\n    REQ(CHILD(n, 0), NAME);\n    assert(strcmp(STR(CHILD(n, 0)), \"async\") == 0);\n\n    switch (TYPE(CHILD(n, 1))) {\n        case funcdef:\n            return ast_for_funcdef_impl(c, n, NULL,\n                                        true /* is_async */);\n        case with_stmt:\n            return ast_for_with_stmt(c, n,\n                                     true /* is_async */);\n\n        case for_stmt:\n            return ast_for_for_stmt(c, n,\n                                    true /* is_async */);\n\n        default:\n            PyErr_Format(PyExc_SystemError,\n                         \"invalid async stament: %s\",\n                         STR(CHILD(n, 1)));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from))\n\t\treturn -EFAULT;\n\n\tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_kbuf;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from)) {\n\t\tret = -EFAULT;\n\t\tgoto free_kbuf;\n\t}\n\n\tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_kbuf;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "net_bind(short unsigned *port, int type, const char *log_service_name)\n{\n  struct addrinfo hints = { 0 };\n  struct addrinfo *servinfo;\n  struct addrinfo *ptr;\n  const char *cfgaddr;\n  char addr[INET6_ADDRSTRLEN];\n  char strport[8];\n  int yes = 1;\n  int no = 0;\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not create service '%s' with address %s, port %hu: %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", *port, strerror(errno));\n      goto error;\n    }\n\n  // Get the port that was assigned\n  ret = getsockname(fd, ptr->ai_addr, &ptr->ai_addrlen);\n  if (ret < 0)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not find address of service '%s': %s\\n\", log_service_name, strerror(errno));\n      goto error;\n    }\n\n  net_port_get(port, (union net_sockaddr *)ptr->ai_addr);\n  net_address_get(addr, sizeof(addr), (union net_sockaddr *)ptr->ai_addr);\n\n  DPRINTF(E_DBG, L_MISC, \"Service '%s' bound to %s, port %hu, socket %d\\n\", log_service_name, addr, *port, fd);\n\n  return fd;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "net_bind(short unsigned *port, int type, const char *log_service_name)\n{\n  struct addrinfo hints = { 0 };\n  struct addrinfo *servinfo;\n  struct addrinfo *ptr;\n  union net_sockaddr naddr = { 0 };\n  socklen_t naddr_len = sizeof(naddr);\n  const char *cfgaddr;\n  char addr[INET6_ADDRSTRLEN];\n  char strport[8];\n  int yes = 1;\n  int no = 0;\n    {\n      DPRINTF(E_LOG, L_MISC, \"Could not create service '%s' with address %s, port %hu: %s\\n\", log_service_name, cfgaddr ? cfgaddr : \"(ANY)\", *port, strerror(errno));\n      goto error;\n    }\n\n  // Get our address (as string) and the port that was assigned (necessary when\n  // caller didn't specify a port)\n  ret = getsockname(fd, &naddr.sa, &naddr_len);\n  if (ret < 0)\n    {\n      DPRINTF(E_LOG, L_MISC, \"Error finding address of service '%s': %s\\n\", log_service_name, strerror(errno));\n      goto error;\n    }\n  else if (naddr_len > sizeof(naddr))\n    {\n      DPRINTF(E_LOG, L_MISC, \"Unexpected address length of service '%s'\\n\", log_service_name);\n      goto error;\n    }\n\n  net_port_get(port, &naddr);\n  net_address_get(addr, sizeof(addr), &naddr);\n\n  DPRINTF(E_DBG, L_MISC, \"Service '%s' bound to %s, port %hu, socket %d\\n\", log_service_name, addr, *port, fd);\n\n  return fd;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void TPUPartitionedCallOp::ExecuteFunctions(\n    const std::vector<DeviceAndFHandle>& functions, OpKernelContext* ctx,\n    int device_ordinal, int64_t ordinal_selector_req_id, DoneCallback done) {\n  profiler::TraceMe trace_me(\"TPUPartitionedCallOp-ExecuteFunctions\");\n  FunctionLibraryRuntime::Options opts;\n  opts.step_container = ctx->step_container();\n  opts.stats_collector = ctx->stats_collector();\n  // TODO(akshayka): Consider selecting a runner on a per-device basis,\n  // i.e., using device-specific threadpools when available.\n  opts.runner = ctx->runner();",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void TPUPartitionedCallOp::ExecuteFunctions(\n    const std::vector<DeviceAndFHandle>& functions, OpKernelContext* ctx,\n    int device_ordinal, int64_t ordinal_selector_req_id, DoneCallback done) {\n  profiler::TraceMe trace_me(\"TPUPartitionedCallOp-ExecuteFunctions\");\n  FunctionLibraryRuntime::Options opts(ctx->step_id());\n  opts.step_container = ctx->step_container();\n  opts.stats_collector = ctx->stats_collector();\n  // TODO(akshayka): Consider selecting a runner on a per-device basis,\n  // i.e., using device-specific threadpools when available.\n  opts.runner = ctx->runner();",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    asdl_seq *_target, *seq = NULL, *suite_seq;\n    expr_ty expression;\n    expr_ty target, first;\n    const node *node_target;\n    int end_lineno, end_col_offset;\n    /* for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite] */\n    REQ(n, for_stmt);\n\n    if (NCH(n) == 9) {\n        seq = ast_for_suite(c, CHILD(n, 8));\n        if (!seq)\n            return NULL;\n    }\n\n    node_target = CHILD(n, 1);\n                       c->c_arena);\n\n    expression = ast_for_testlist(c, CHILD(n, 3));\n    if (!expression)\n        return NULL;\n    suite_seq = ast_for_suite(c, CHILD(n, 5));\n    if (!suite_seq)\n        return NULL;\n\n    if (seq != NULL) {\n        get_last_end_pos(seq, &end_lineno, &end_col_offset);\n    } else {\n        get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n    }\n    if (is_async)\n        return AsyncFor(target, expression, suite_seq, seq,\n                        LINENO(n0), n0->n_col_offset,\n                        end_lineno, end_col_offset, c->c_arena);\n    else\n        return For(target, expression, suite_seq, seq,\n                   LINENO(n), n->n_col_offset,\n                   end_lineno, end_col_offset, c->c_arena);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    asdl_seq *_target, *seq = NULL, *suite_seq;\n    expr_ty expression;\n    expr_ty target, first;\n    const node *node_target;\n    int end_lineno, end_col_offset;\n    int has_type_comment;\n    string type_comment;\n    /* for_stmt: 'for' exprlist 'in' testlist ':' [TYPE_COMMENT] suite ['else' ':' suite] */\n    REQ(n, for_stmt);\n\n    has_type_comment = TYPE(CHILD(n, 5)) == TYPE_COMMENT;\n\n    if (NCH(n) == 9 + has_type_comment) {\n        seq = ast_for_suite(c, CHILD(n, 8 + has_type_comment));\n        if (!seq)\n            return NULL;\n    }\n\n    node_target = CHILD(n, 1);\n                       c->c_arena);\n\n    expression = ast_for_testlist(c, CHILD(n, 3));\n    if (!expression)\n        return NULL;\n    suite_seq = ast_for_suite(c, CHILD(n, 5 + has_type_comment));\n    if (!suite_seq)\n        return NULL;\n\n    if (seq != NULL) {\n        get_last_end_pos(seq, &end_lineno, &end_col_offset);\n    } else {\n        get_last_end_pos(suite_seq, &end_lineno, &end_col_offset);\n    }\n\n    if (has_type_comment) {\n        type_comment = NEW_TYPE_COMMENT(CHILD(n, 5));\n        if (!type_comment)\n            return NULL;\n    }\n    else\n        type_comment = NULL;\n\n    if (is_async)\n        return AsyncFor(target, expression, suite_seq, seq, type_comment,\n                        LINENO(n0), n0->n_col_offset,\n                        end_lineno, end_col_offset, c->c_arena);\n    else\n        return For(target, expression, suite_seq, seq, type_comment,\n                   LINENO(n), n->n_col_offset,\n                   end_lineno, end_col_offset, c->c_arena);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "          else\n          {\n            ismatch = 1;\n          }\n\n          if (ismatch && remove(groups[g].files[f].file->d_name) == 0)\n          {\n            set_file_action(&groups[g].files[f], FILEACTION_DELIST, deletiontally);\n\n            deletedbytes += groups[g].files[f].file->size;\n            ++totaldeleted;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "          else\n          {\n            ismatch = 1;\n          }\n\n          if (ismatch && removeifnotchanged(groups[g].files[f].file, 0) == 0)\n          {\n            set_file_action(&groups[g].files[f], FILEACTION_DELIST, deletiontally);\n\n            deletedbytes += groups[g].files[f].file->size;\n            ++totaldeleted;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t   le16toh(b->reserved) == 1 ? \"\" : \"s\");\n    printf(\"First FAT starts at byte %llu (sector %llu)\\n\",\n\t   (unsigned long long)fs->fat_start,\n\t   (unsigned long long)fs->fat_start / lss);\n    printf(\"%10d FATs, %d bit entries\\n\", b->fats, fs->fat_bits);\n    printf(\"%10d bytes per FAT (= %u sectors)\\n\", fs->fat_size,\n\t   fs->fat_size / lss);\n    if (!fs->root_cluster) {\n\tprintf(\"Root directory starts at byte %llu (sector %llu)\\n\",\n\t       (unsigned long long)fs->root_start,\n\t       (unsigned long long)fs->root_start / lss);\n\tprintf(\"%10d root directory entries\\n\", fs->root_entries);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t   le16toh(b->reserved) == 1 ? \"\" : \"s\");\n    printf(\"First FAT starts at byte %llu (sector %llu)\\n\",\n\t   (unsigned long long)fs->fat_start,\n\t   (unsigned long long)fs->fat_start / lss);\n    printf(\"%10d FATs, %d bit entries\\n\", b->fats, fs->fat_bits);\n    printf(\"%10lld bytes per FAT (= %llu sectors)\\n\", (long long)fs->fat_size,\n\t   (long long)fs->fat_size / lss);\n    if (!fs->root_cluster) {\n\tprintf(\"Root directory starts at byte %llu (sector %llu)\\n\",\n\t       (unsigned long long)fs->root_start,\n\t       (unsigned long long)fs->root_start / lss);\n\tprintf(\"%10d root directory entries\\n\", fs->root_entries);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void ep4_mul_sim_plain(ep4_t r, const ep4_t p, const bn_t k,\n\t\tconst ep4_t q, const bn_t m, ep4_t *t) {\n\tint i, l, l0, l1, n0, n1, w, gen;\n\tint8_t naf0[2 * RLC_FP_BITS + 1], naf1[2 * RLC_FP_BITS + 1], *_k, *_m;\n\tep4_t t0[1 << (EP_WIDTH - 2)];\n\tep4_t t1[1 << (EP_WIDTH - 2)];\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void ep4_mul_sim_plain(ep4_t r, const ep4_t p, const bn_t k,\n\t\tconst ep4_t q, const bn_t m, ep4_t *t) {\n\tint i, n0, n1, w, gen;\n\tint8_t naf0[2 * RLC_FP_BITS + 1], naf1[2 * RLC_FP_BITS + 1], *_k, *_m;\n\tep4_t t0[1 << (EP_WIDTH - 2)];\n\tep4_t t1[1 << (EP_WIDTH - 2)];\n\tsize_t l, l0, l1;\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      if (error == SSL_ERROR_WANT_WRITE) {\n        // The caller will register for write event if not already.\n        *partialWritten = uint32_t(offset);\n        return WriteResult(totalWritten);\n      }\n      auto writeResult = interpretSSLError(int(bytes), error);\n      if (writeResult.writeReturn < 0) {\n        return writeResult;\n      } // else fall through to below to correctly record totalWritten\n    }\n\n    totalWritten += bytes;\n\n    if (bytes == (ssize_t)len) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      if (error == SSL_ERROR_WANT_WRITE) {\n        // The caller will register for write event if not already.\n        *partialWritten = uint32_t(offset);\n        return WriteResult(totalWritten);\n      }\n      return interpretSSLError(int(bytes), error);\n    }\n\n    totalWritten += bytes;\n\n    if (bytes == (ssize_t)len) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\turl_len = strlen(url_begin);\n\n\tif (url_len < 1)\n\t\treturn false;\n\n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n\n\tif (port_len) {\n\t\tchar *slash;\n\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\turl_len = strlen(url_begin);\n\n\tif (url_len < 1)\n\t\treturn false;\n\n\tsnprintf(url_address, 254, \"%.*s\", url_len, url_begin);\n\n\tif (port_len) {\n\t\tchar *slash;\n\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    // way that can be reused for type inference.\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        DCHECK(attr != nullptr);\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    // way that can be reused for type inference.\n    for (int j = 0; j < t->args_size(); j++) {\n      auto* arg = t->mutable_args(i);\n      if (arg->type_id() == TFT_VAR) {\n        const auto* attr = attrs.Find(arg->s());\n        if (attr == nullptr) {\n          return Status(\n              error::INVALID_ARGUMENT,\n              absl::StrCat(\"Could not find an attribute for key \", arg->s()));\n        }\n        if (attr->value_case() == AttrValue::kList) {\n          const auto& attr_list = attr->list();\n          arg->set_type_id(TFT_PRODUCT);\n          for (int i = 0; i < attr_list.type_size(); i++) {\n            map_dtype_to_tensor(attr_list.type(i), arg->add_args());",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void do_free_keypair(struct rsa_keypair *key)\n{\n\tcrypto_bignum_free(key->e);\n\tcrypto_bignum_free(key->d);\n\tcrypto_bignum_free(key->n);\n\tcrypto_bignum_free(key->p);\n\tcrypto_bignum_free(key->q);\n\tcrypto_bignum_free(key->qp);\n\tcrypto_bignum_free(key->dp);\n\tcrypto_bignum_free(key->dq);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void do_free_keypair(struct rsa_keypair *key)\n{\n\tcrypto_bignum_free(&key->e);\n\tcrypto_bignum_free(&key->d);\n\tcrypto_bignum_free(&key->n);\n\tcrypto_bignum_free(&key->p);\n\tcrypto_bignum_free(&key->q);\n\tcrypto_bignum_free(&key->qp);\n\tcrypto_bignum_free(&key->dp);\n\tcrypto_bignum_free(&key->dq);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int xmkstemp(char **tmpname, char *dir)\n{\n\tchar *localtmp;\n\tchar *tmpenv;\n\tmode_t old_mode;\n\tint fd, rc;\n\n\t/* Some use cases must be capable of being moved atomically\n\t * with rename(2), which is the reason why dir is here.  */\n\tif (dir != NULL)\n\t\ttmpenv = dir;\n\telse\n\t\ttmpenv = getenv(\"TMPDIR\");\n\n\tif (tmpenv)\n\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", tmpenv,\n\t\t\t  program_invocation_short_name);\n\telse\n\t\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", _PATH_TMP,\n\t\t\t  program_invocation_short_name);\n\n\tif (rc < 0)\n\t\treturn -1;\n\n\told_mode = umask(077);\n\tfd = mkostemp(localtmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int xmkstemp(char **tmpname, const char *dir, const char *prefix)\n{\n\tchar *localtmp;\n\tconst char *tmpenv;\n\tmode_t old_mode;\n\tint fd, rc;\n\n\t/* Some use cases must be capable of being moved atomically\n\t * with rename(2), which is the reason why dir is here.  */\n\ttmpenv = dir ? dir : getenv(\"TMPDIR\");\n\tif (!tmpenv)\n\t\ttmpenv = _PATH_TMP;\n\n\trc = asprintf(&localtmp, \"%s/%s.XXXXXX\", tmpenv, prefix);\n\tif (rc < 0)\n\t\treturn -1;\n\n\told_mode = umask(077);\n\tfd = mkostemp(localtmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    int isKey = 0;\n    char *key = NULL;\n    if (!v)\n        goto done;\n    if (lenPtr) *lenPtr = 0;\n    char unibuf[200];\n    switch(v->vt) {\n        case JSI_VT_STRING:\n            ntxt = v->d.s.str;\n            goto done;\n        case JSI_VT_UNDEF:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    int isKey = 0;\n    char *key = NULL;\n    if (!v)\n        goto done;\n    if (lenPtr) *lenPtr = 0;\n    char unibuf[JSI_MAX_NUMBER_STRING*2];\n    switch(v->vt) {\n        case JSI_VT_STRING:\n            ntxt = v->d.s.str;\n            goto done;\n        case JSI_VT_UNDEF:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\texit(-1);\n\t}\n\n\tpfd.fd = fd;\n\n\twhile (1) {\n\t\tpfd.events = POLLIN;\n\t\tpfd.revents = 0;\n\t\tpoll(&pfd, 1, -1);\n\n\t\tlen = recv(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0);\n\n\t\tif (len < 0) {\n\t\t\tsyslog(LOG_ERR, \"recv failed; error:%d\", len);\n\t\t\tclose(fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tincoming_msg = (struct nlmsghdr *)kvp_recv_buffer;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t}\n\n\tpfd.fd = fd;\n\n\twhile (1) {\n\t\tstruct sockaddr *addr_p = (struct sockaddr *) &addr;\n\t\tsocklen_t addr_l = sizeof(addr);\n\t\tpfd.events = POLLIN;\n\t\tpfd.revents = 0;\n\t\tpoll(&pfd, 1, -1);\n\n\t\tlen = recvfrom(fd, kvp_recv_buffer, sizeof(kvp_recv_buffer), 0,\n\t\t\t\taddr_p, &addr_l);\n\n\t\tif (len < 0 || addr.nl_pid) {\n\t\t\tsyslog(LOG_ERR, \"recvfrom failed; pid:%u error:%d %s\",\n\t\t\t\t\taddr.nl_pid, errno, strerror(errno));\n\t\t\tclose(fd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tincoming_msg = (struct nlmsghdr *)kvp_recv_buffer;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif (pps_id > 255)\n\t\treturn -1;\n\tsi->pps = &avc->pps[pps_id];\n\tsi->pps->id = pps_id;\n\tif (!si->pps->slice_group_count)\n\t\treturn -2;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id > 255))\n\t\treturn -1;\n\tsi->pps = &avc->pps[pps_id];\n\tsi->pps->id = pps_id;\n\tif (!si->pps->slice_group_count)\n\t\treturn -2;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    StreamTcpUTInit(&stt.ra_ctx);\n    stream_config.async_oneside = TRUE;\n\n    tcph.th_win = htons(5480);\n    tcph.th_seq = htonl(10);\n    tcph.th_ack = htonl(11);\n    tcph.th_flags = TH_SYN;\n    p->tcph = &tcph;\n\n    FAIL_IF(StreamTcpPacket(&tv, p, &stt, &pq) == -1);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    StreamTcpUTInit(&stt.ra_ctx);\n    stream_config.async_oneside = TRUE;\n\n    tcph.th_win = htons(5480);\n    tcph.th_seq = htonl(10);\n    tcph.th_ack = 0;\n    tcph.th_flags = TH_SYN;\n    p->tcph = &tcph;\n\n    FAIL_IF(StreamTcpPacket(&tv, p, &stt, &pq) == -1);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t\tunsigned int dataoff, unsigned int *timeouts)\n{\n\treturn true;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t\tunsigned int dataoff, unsigned int *timeouts)\n{\n\treturn nf_generic_should_process(nf_ct_protonum(ct));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t/*\n\t * print the time in human-readable format.\n\t */\n\tif (i) {\n\t\ttime_t seconds = i - JAN_1970;\n\t\tstruct tm *tm;\n\t\tchar time_buf[128];\n\n\t\ttm = localtime(&seconds);\n\t\tstrftime(time_buf, sizeof (time_buf), \"%Y/%m/%d %H:%M:%S\", tm);\n\t\tND_PRINT(\" (%s)\", time_buf);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\t/*\n\t * print the time in human-readable format.\n\t */\n\tif (i) {\n\t\ttime_t seconds = i - JAN_1970;\n\t\tchar time_buf[128];\n\n\t\tND_PRINT(\" (%s)\",\n\t\t    nd_format_time(time_buf, sizeof (time_buf), \"%Y/%m/%d %H:%M:%S\",\n\t\t      localtime(&seconds)));\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&slave_active_lock, flags);\n\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\tif (timeri->master)\n\t\tlist_add_tail(&timeri->active_list,\n\t\t\t      &timeri->master->slave_active_head);\n\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\treturn 1; /* delayed start */\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&slave_active_lock, flags);\n\ttimeri->flags |= SNDRV_TIMER_IFLG_RUNNING;\n\tif (timeri->master && timeri->timer) {\n\t\tspin_lock(&timeri->timer->lock);\n\t\tlist_add_tail(&timeri->active_list,\n\t\t\t      &timeri->master->slave_active_head);\n\t\tspin_unlock(&timeri->timer->lock);\n\t}\n\tspin_unlock_irqrestore(&slave_active_lock, flags);\n\treturn 1; /* delayed start */\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tdev_uc_flush(bond_dev);\n\t\t\tdev_mc_flush(bond_dev);\n\n\t\t\tif (slave_dev->type != ARPHRD_ETHER)\n\t\t\t\tbond_setup_by_slave(bond_dev, slave_dev);\n\t\t\telse\n\t\t\t\tether_setup(bond_dev);\n\n\t\t\tnetdev_bonding_change(bond_dev,\n\t\t\t\t\t      NETDEV_POST_TYPE_CHANGE);\n\t\t}\n\t} else if (bond_dev->type != slave_dev->type) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tdev_uc_flush(bond_dev);\n\t\t\tdev_mc_flush(bond_dev);\n\n\t\t\tif (slave_dev->type != ARPHRD_ETHER)\n\t\t\t\tbond_setup_by_slave(bond_dev, slave_dev);\n\t\t\telse {\n\t\t\t\tether_setup(bond_dev);\n\t\t\t\tbond_dev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\t\t\t}\n\n\t\t\tnetdev_bonding_change(bond_dev,\n\t\t\t\t\t      NETDEV_POST_TYPE_CHANGE);\n\t\t}\n\t} else if (bond_dev->type != slave_dev->type) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static struct page *alloc_huge_page(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long addr, int avoid_reserve)\n{\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *page;\n\tstruct address_space *mapping = vma->vm_file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tlong chg;\n\n\t/*\n\t * Processes that did not create the mapping will have no reserves and\n\t * will not have accounted against quota. Check that the quota can be\n\t * made before satisfying the allocation\n\t * MAP_NORESERVE mappings may also need pages and quota allocated\n\t * if no reserve mapping overlaps.\n\t */\n\tchg = vma_needs_reservation(h, vma, addr);\n\tif (chg < 0)\n\t\treturn ERR_PTR(-VM_FAULT_OOM);\n\tif (chg)\n\t\tif (hugetlb_get_quota(inode->i_mapping, chg))\n\t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n\n\tspin_lock(&hugetlb_lock);\n\tpage = dequeue_huge_page_vma(h, vma, addr, avoid_reserve);\n\tspin_unlock(&hugetlb_lock);\n\n\tif (!page) {\n\t\tpage = alloc_buddy_huge_page(h, NUMA_NO_NODE);\n\t\tif (!page) {\n\t\t\thugetlb_put_quota(inode->i_mapping, chg);\n\t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n\t\t}\n\t}\n\n\tset_page_private(page, (unsigned long) mapping);\n\n\tvma_commit_reservation(h, vma, addr);\n\n\treturn page;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static struct page *alloc_huge_page(struct vm_area_struct *vma,\n\t\t\t\t    unsigned long addr, int avoid_reserve)\n{\n\tstruct hugepage_subpool *spool = subpool_vma(vma);\n\tstruct hstate *h = hstate_vma(vma);\n\tstruct page *page;\n\tlong chg;\n\n\t/*\n\t * Processes that did not create the mapping will have no\n\t * reserves and will not have accounted against subpool\n\t * limit. Check that the subpool limit can be made before\n\t * satisfying the allocation MAP_NORESERVE mappings may also\n\t * need pages and subpool limit allocated allocated if no reserve\n\t * mapping overlaps.\n\t */\n\tchg = vma_needs_reservation(h, vma, addr);\n\tif (chg < 0)\n\t\treturn ERR_PTR(-VM_FAULT_OOM);\n\tif (chg)\n\t\tif (hugepage_subpool_get_pages(spool, chg))\n\t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n\n\tspin_lock(&hugetlb_lock);\n\tpage = dequeue_huge_page_vma(h, vma, addr, avoid_reserve);\n\tspin_unlock(&hugetlb_lock);\n\n\tif (!page) {\n\t\tpage = alloc_buddy_huge_page(h, NUMA_NO_NODE);\n\t\tif (!page) {\n\t\t\thugepage_subpool_put_pages(spool, chg);\n\t\t\treturn ERR_PTR(-VM_FAULT_SIGBUS);\n\t\t}\n\t}\n\n\tset_page_private(page, (unsigned long)spool);\n\n\tvma_commit_reservation(h, vma, addr);\n\n\treturn page;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t/* Just skip any block with length == 0 (no report content) */\n\tif (rb_len) {\n\t    switch (rb_hdr->bt) {\n\t\tcase BT_RR_TIME:\n\t\t    rb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*) rb_hdr;\n\t\t    break;\n\t\tcase BT_DLRR:\n\t\t    rb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*) rb_hdr;\n\t\t    break;\n\t\tcase BT_STATS:\n\t\t    rb_stats = (pjmedia_rtcp_xr_rb_stats*) rb_hdr;\n\t\t    break;\n\t\tcase BT_VOIP_METRICS:\n\t\t    rb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*) rb_hdr;\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\t/* Just skip any block with length == 0 (no report content) */\n\tif (rb_len) {\n\t    switch (rb_hdr->bt) {\n\t\tcase BT_RR_TIME:\n\t\t    if ((char*)rb_hdr + sizeof(*rb_rr_time) <=\n\t\t\t(char*)pkt + size) \n\t\t    {\n\t\t\trb_rr_time = (pjmedia_rtcp_xr_rb_rr_time*)rb_hdr;\n\t\t    }\n\t\t    break;\n\t\tcase BT_DLRR:\n\t\t    if ((char*)rb_hdr + sizeof(*rb_dlrr) <=\n\t\t\t(char*)pkt + size)\n\t\t    {\n\t\t\trb_dlrr = (pjmedia_rtcp_xr_rb_dlrr*)rb_hdr;\n\t\t    }\n\t\t    break;\n\t\tcase BT_STATS:\n\t\t    if ((char*)rb_hdr + sizeof(*rb_stats) <=\n\t\t\t(char*)pkt + size)\n\t\t    {\n\t\t\trb_stats = (pjmedia_rtcp_xr_rb_stats*)rb_hdr;\n\t\t    }\n\t\t    break;\n\t\tcase BT_VOIP_METRICS:\n\t\t    if ((char*)rb_hdr + sizeof(*rb_voip_mtc) <=\n\t\t\t(char*)pkt + size)\n\t\t    {\n\t\t\trb_voip_mtc = (pjmedia_rtcp_xr_rb_voip_mtc*)rb_hdr;\n\t\t    }\n\t\t    break;\n\t\tdefault:\n\t\t    break;\n\t    }\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void Logger::addPeer(const QString &ip, bool blocked, const QString &reason)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), ip, blocked, reason };\n    m_peers.push_back(temp);\n\n    if (m_peers.size() >= MAX_LOG_MESSAGES)\n        m_peers.pop_front();\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void Logger::addPeer(const QString &ip, bool blocked, const QString &reason)\n{\n    QWriteLocker locker(&lock);\n\n    Log::Peer temp = { peerCounter++, QDateTime::currentMSecsSinceEpoch(), Utils::String::toHtmlEscaped(ip), blocked, Utils::String::toHtmlEscaped(reason) };\n    m_peers.push_back(temp);\n\n    if (m_peers.size() >= MAX_LOG_MESSAGES)\n        m_peers.pop_front();\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t/* Copy the address and add cmsg data. */\n\tif (family == AF_INET) {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_port = 0 /* skb->h.uh->source */;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\n\t\tif (isk->cmsg_flags)\n\t\t\tip_cmsg_recv(msg, skb);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tstruct ipv6hdr *ip6 = ipv6_hdr(skb);\n\t\tstruct sockaddr_in6 *sin6 =\n\t\t\t(struct sockaddr_in6 *)msg->msg_name;\n\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = 0;\n\t\tsin6->sin6_addr = ip6->saddr;\n\t\tsin6->sin6_flowinfo = 0;\n\t\tif (np->sndflow)\n\t\t\tsin6->sin6_flowinfo = ip6_flowinfo(ip6);\n\n\t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t\t  IP6CB(skb)->iif);\n\t\t*addr_len = sizeof(*sin6);\n\n\t\tif (inet6_sk(sk)->rxopt.all)\n\t\t\tpingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);\n#endif\n\t} else {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\t/* Copy the address and add cmsg data. */\n\tif (family == AF_INET) {\n\t\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\n\t\tif (sin) {\n\t\t\tsin->sin_family = AF_INET;\n\t\t\tsin->sin_port = 0 /* skb->h.uh->source */;\n\t\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t\t*addr_len = sizeof(*sin);\n\t\t}\n\n\t\tif (isk->cmsg_flags)\n\t\t\tip_cmsg_recv(msg, skb);\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\t\tstruct ipv6hdr *ip6 = ipv6_hdr(skb);\n\t\tstruct sockaddr_in6 *sin6 =\n\t\t\t(struct sockaddr_in6 *)msg->msg_name;\n\n\t\tif (sin6) {\n\t\t\tsin6->sin6_family = AF_INET6;\n\t\t\tsin6->sin6_port = 0;\n\t\t\tsin6->sin6_addr = ip6->saddr;\n\t\t\tsin6->sin6_flowinfo = 0;\n\t\t\tif (np->sndflow)\n\t\t\t\tsin6->sin6_flowinfo = ip6_flowinfo(ip6);\n\t\t\tsin6->sin6_scope_id =\n\t\t\t\tipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t    IP6CB(skb)->iif);\n\t\t\t*addr_len = sizeof(*sin6);\n\t\t}\n\n\t\tif (inet6_sk(sk)->rxopt.all)\n\t\t\tpingv6_ops.ip6_datagram_recv_ctl(sk, msg, skb);\n#endif\n\t} else {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\\n\", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* This is a video frame, get call number */\n\t\tfr->callno = find_callno(ntohs(vh->callno) & ~0x8000, dcallno, &sin, new, fd);\n\t\tminivid = 1;\n\t} else if ((meta->zeros == 0) && !(ntohs(meta->metacmd) & 0x8000))\n\t\treturn socket_process_meta(res, meta, &sin, fd, fr);\n\n#ifdef DEBUG_SUPPORT\n\t\tf.frametype = AST_FRAME_NULL;\n\t\tf.subclass = 0;\n\t}\n\n\tif (!fr->callno)\n\t\tfr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, new, fd);\n\n\tif (fr->callno > 0)\n\t\tast_mutex_lock(&iaxsl[fr->callno]);\n\n\tif (!fr->callno || !iaxs[fr->callno]) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\\n\", ast_inet_ntoa(sin.sin_addr), ntohs(sin.sin_port));\n\t\t\treturn 1;\n\t\t}\n\n\t\t/* This is a video frame, get call number */\n\t\tfr->callno = find_callno(ntohs(vh->callno) & ~0x8000, dcallno, &sin, new, fd, 0);\n\t\tminivid = 1;\n\t} else if ((meta->zeros == 0) && !(ntohs(meta->metacmd) & 0x8000))\n\t\treturn socket_process_meta(res, meta, &sin, fd, fr);\n\n#ifdef DEBUG_SUPPORT\n\t\tf.frametype = AST_FRAME_NULL;\n\t\tf.subclass = 0;\n\t}\n\n\tif (!fr->callno)\n\t\tfr->callno = find_callno(ntohs(mh->callno) & ~IAX_FLAG_FULL, dcallno, &sin, new, fd, ntohs(mh->callno) & IAX_FLAG_FULL);\n\n\tif (fr->callno > 0)\n\t\tast_mutex_lock(&iaxsl[fr->callno]);\n\n\tif (!fr->callno || !iaxs[fr->callno]) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tgoto error;\n\t/* parse the number */\n\tsize = 0;\n\tnumber = 0;\n\twhile (p<end && *p>='0' && *p<='9') {\n\t\tnumber = number*10 + (*p)-'0';\n\t\tif (number<0) {\n\t\t\tLM_ERR(\"number overflow at pos %d in len number [%.*s]\\n\",\n\t\t\t\t(int)(p-buffer),(int)(end-buffer), buffer);\n\t\t\treturn 0;\n\t\t}\n\t\tsize ++;\n\t\tp++;\n\t}\n\tif (p==end || size==0)\n\t\tgoto error;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tgoto error;\n\t/* parse the number */\n\tsize = 0;\n\tnumber = 0;\n\twhile (p<end && *p>='0' && *p<='9') {\n\t\t/* do not actually cause an integer overflow, as it is UB! --liviu */\n\t\tif (number > 214748363) {\n\t\t\tLM_ERR(\"integer overflow risk at pos %d in len number [%.*s]\\n\",\n\t\t\t\t(int)(p-buffer),(int)(end-buffer), buffer);\n\t\t\treturn 0;\n\t\t}\n\n\t\tnumber = number*10 + (*p)-'0';\n\t\tsize ++;\n\t\tp++;\n\t}\n\tif (p==end || size==0)\n\t\tgoto error;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      result-=(QuantumRange+1.0)*floor((double) result/(QuantumRange+1.0));\n      break;\n    }\n    case AndEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel & (size_t) (value+0.5));\n      break;\n    }\n    case CosineEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*(0.5*cos((double) (2.0*MagickPI*\n        LaplacianNoise,value);\n      break;\n    }\n    case LeftShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel << (size_t) (value+0.5));\n      break;\n    }\n    case LogEvaluateOperator:\n    {\n      if ((QuantumScale*pixel) >= MagickEpsilon)\n      result=(MagickRealType) (value*pixel);\n      break;\n    }\n    case OrEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel | (size_t) (value+0.5));\n      break;\n    }\n    case PoissonNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        (double) value));\n      break;\n    }\n    case RightShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel >> (size_t) (value+0.5));\n      break;\n    }\n    case RootMeanSquareEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel*pixel+value);\n        UniformNoise,value);\n      break;\n    }\n    case XorEvaluateOperator:\n    {\n      result=(MagickRealType) ((size_t) pixel ^ (size_t) (value+0.5));\n      break;\n    }\n  }\n  return(result);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      result-=(QuantumRange+1.0)*floor((double) result/(QuantumRange+1.0));\n      break;\n    }\n    case AndEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel & (ssize_t) (value+0.5));\n      break;\n    }\n    case CosineEvaluateOperator:\n    {\n      result=(MagickRealType) (QuantumRange*(0.5*cos((double) (2.0*MagickPI*\n        LaplacianNoise,value);\n      break;\n    }\n    case LeftShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel << (ssize_t) (value+0.5));\n      break;\n    }\n    case LogEvaluateOperator:\n    {\n      if ((QuantumScale*pixel) >= MagickEpsilon)\n      result=(MagickRealType) (value*pixel);\n      break;\n    }\n    case OrEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel | (ssize_t) (value+0.5));\n      break;\n    }\n    case PoissonNoiseEvaluateOperator:\n    {\n      result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel,\n        (double) value));\n      break;\n    }\n    case RightShiftEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel >> (ssize_t) (value+0.5));\n      break;\n    }\n    case RootMeanSquareEvaluateOperator:\n    {\n      result=(MagickRealType) (pixel*pixel+value);\n        UniformNoise,value);\n      break;\n    }\n    case XorEvaluateOperator:\n    {\n      result=(MagickRealType) ((ssize_t) pixel ^ (ssize_t) (value+0.5));\n      break;\n    }\n  }\n  return(result);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static u16 read_16(cdk_stream_t s)\n{\n\tbyte buf[2];\n\tsize_t nread;\n\n\tassert(s != NULL);\n\n\tstream_read(s, buf, 2, &nread);\n\tif (nread != 2)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static u16 read_16(cdk_stream_t s)\n{\n\tbyte buf[2];\n\tsize_t nread = 0;\n\n\tassert(s != NULL);\n\n\tstream_read(s, buf, 2, &nread);\n\tif (nread != 2)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n{\n\tstatic u32 ip6_proxy_idents_hashrnd __read_mostly;\n\tstruct in6_addr buf[2];\n\tstruct in6_addr *addrs;\n\tu32 id;\n\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n\tif (!addrs)\n\t\treturn 0;\n\n\tnet_get_random_once(&ip6_proxy_idents_hashrnd,\n\t\t\t    sizeof(ip6_proxy_idents_hashrnd));\n\n\tid = __ipv6_select_ident(net, ip6_proxy_idents_hashrnd,\n\t\t\t\t &addrs[1], &addrs[0]);\n\treturn htonl(id);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "__be32 ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)\n{\n\tstruct in6_addr buf[2];\n\tstruct in6_addr *addrs;\n\tu32 id;\n\n\taddrs = skb_header_pointer(skb,\n\t\t\t\t   offsetof(struct ipv6hdr, saddr),\n\t\t\t\t   sizeof(buf), buf);\n\tif (!addrs)\n\t\treturn 0;\n\n\tid = __ipv6_select_ident(net, &addrs[1], &addrs[0]);\n\treturn htonl(id);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void fb_read_bin(fb_t a, const uint8_t *bin, int len) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tif (len != RLC_FB_BYTES) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void fb_read_bin(fb_t a, const uint8_t *bin, size_t len) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tif (len != RLC_FB_BYTES) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void outbound_phy_packet_callback(struct fw_packet *packet,\n\t\t\t\t\t struct fw_card *card, int status)\n{\n\tstruct outbound_phy_packet_event *e =\n\t\tcontainer_of(packet, struct outbound_phy_packet_event, p);\n\n\tswitch (status) {\n\t/* expected: */\n\tcase ACK_COMPLETE:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\t/* should never happen with PHY packets: */\n\tcase ACK_TYPE_ERROR:\te->phy_packet.rcode = RCODE_TYPE_ERROR;\tbreak;\n\t/* stale generation; cancelled; on certain controllers: no ack */\n\tdefault:\t\te->phy_packet.rcode = status;\t\tbreak;\n\t}\n\te->phy_packet.data[0] = packet->timestamp;\n\n\tqueue_event(e->client, &e->event, &e->phy_packet,\n\t\t    sizeof(e->phy_packet) + e->phy_packet.length, NULL, 0);\n\tclient_put(e->client);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void outbound_phy_packet_callback(struct fw_packet *packet,\n\t\t\t\t\t struct fw_card *card, int status)\n{\n\tstruct outbound_phy_packet_event *e =\n\t\tcontainer_of(packet, struct outbound_phy_packet_event, p);\n\tstruct client *e_client;\n\n\tswitch (status) {\n\t/* expected: */\n\tcase ACK_COMPLETE:\te->phy_packet.rcode = RCODE_COMPLETE;\tbreak;\n\t/* should never happen with PHY packets: */\n\t/* stale generation; cancelled; on certain controllers: no ack */\n\tdefault:\t\te->phy_packet.rcode = status;\t\tbreak;\n\t}\n\te->phy_packet.data[0] = packet->timestamp;\n\n\te_client = e->client;\n\tqueue_event(e->client, &e->event, &e->phy_packet,\n\t\t    sizeof(e->phy_packet) + e->phy_packet.length, NULL, 0);\n\tclient_put(e_client);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tcase PASTE_CMDLINE:\n\t\t    put_on_cmdline(buf, idx, TRUE);\n\t\t    break;\n\n\t\tcase PASTE_EX:\n\t\t    if (gap != NULL && ga_grow(gap, idx) == OK)\n\t\t    {\n\t\t\tmch_memmove((char *)gap->ga_data + gap->ga_len,\n\t\t\t\t\t\t\t     buf, (size_t)idx);\n\t\t\tgap->ga_len += idx;\n\t\t    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tcase PASTE_CMDLINE:\n\t\t    put_on_cmdline(buf, idx, TRUE);\n\t\t    break;\n\n\t\tcase PASTE_EX:\n\t\t    // add one for the NUL that is going to be appended\n\t\t    if (gap != NULL && ga_grow(gap, idx + 1) == OK)\n\t\t    {\n\t\t\tmch_memmove((char *)gap->ga_data + gap->ga_len,\n\t\t\t\t\t\t\t     buf, (size_t)idx);\n\t\t\tgap->ga_len += idx;\n\t\t    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int ZlibInStream::pos()\n{\n  return offset + ptr - start;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "size_t ZlibInStream::pos()\n{\n  return offset + ptr - start;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tstruct udp_sock *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n\tstruct in6_addr *daddr, *final_p, final;\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_len = msg->msg_namelen;\n\tint ulen = len;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t\tconnected = 0;\n\t}\n\tif (!opt)\n\t\topt = np->opt;\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\n\tfl6.flowi6_proto = sk->sk_protocol;\n\t\tdst = NULL;\n\t}\n\nout:\n\tdst_release(dst);\n\tfl6_sock_release(flowlabel);\n\tif (!err)\n\t\treturn len;\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tDECLARE_SOCKADDR(struct sockaddr_in6 *, sin6, msg->msg_name);\n\tstruct in6_addr *daddr, *final_p, final;\n\tstruct ipv6_txoptions *opt = NULL;\n\tstruct ipv6_txoptions *opt_to_free = NULL;\n\tstruct ip6_flowlabel *flowlabel = NULL;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\tint addr_len = msg->msg_namelen;\n\tint ulen = len;\n\t\t}\n\t\tif (!(opt->opt_nflen|opt->opt_flen))\n\t\t\topt = NULL;\n\t\tconnected = 0;\n\t}\n\tif (!opt) {\n\t\topt = txopt_get(np);\n\t\topt_to_free = opt;\n\t}\n\tif (flowlabel)\n\t\topt = fl6_merge_options(&opt_space, flowlabel, opt);\n\topt = ipv6_fixup_options(&opt_space, opt);\n\n\tfl6.flowi6_proto = sk->sk_protocol;\n\t}\n\nout:\n\tdst_release(dst);\n\tfl6_sock_release(flowlabel);\n\ttxopt_put(opt_to_free);\n\tif (!err)\n\t\treturn len;\n\t/*\n\t * ENOBUFS = no kernel mem, SOCK_NOSPACE = no sndbuf space.  Reporting\n\t * ENOBUFS might not be good (it's not tunable per se), but otherwise",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        if (pindex->pprev)\n            pindex->pprev->pnext = pindex;\n\n    // Resurrect memory transactions that were in the disconnected branch\n    BOOST_FOREACH(CTransaction& tx, vResurrect)\n        tx.AcceptToMemoryPool(txdb, false);\n\n    // Delete redundant memory transactions that are in the connected branch\n    BOOST_FOREACH(CTransaction &tx, vDelete) {\n        mempool.remove(tx);\n        mempool.removeConflicts(tx);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        if (pindex->pprev)\n            pindex->pprev->pnext = pindex;\n\n    // Resurrect memory transactions that were in the disconnected branch\n    BOOST_FOREACH(CTransaction& tx, vResurrect)\n      tx.AcceptToMemoryPool(txdb, true, false);\n\n    // Delete redundant memory transactions that are in the connected branch\n    BOOST_FOREACH(CTransaction &tx, vDelete) {\n        mempool.remove(tx);\n        mempool.removeConflicts(tx);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tmemcpy(&ualg->cru_name, &alg->cra_name, sizeof(ualg->cru_name));\n\tmemcpy(&ualg->cru_driver_name, &alg->cra_driver_name,\n\t       sizeof(ualg->cru_driver_name));\n\tmemcpy(&ualg->cru_module_name, module_name(alg->cra_module),\n\t       CRYPTO_MAX_ALG_NAME);\n\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\n\t\tsnprintf(rl.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"larval\");\n\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n\t\t\t    sizeof(struct crypto_report_larval), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int crypto_report_one(struct crypto_alg *alg,\n\t\t\t     struct crypto_user_alg *ualg, struct sk_buff *skb)\n{\n\tstrncpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));\n\tstrncpy(ualg->cru_driver_name, alg->cra_driver_name,\n\t\tsizeof(ualg->cru_driver_name));\n\tstrncpy(ualg->cru_module_name, module_name(alg->cra_module),\n\t\tsizeof(ualg->cru_module_name));\n\n\tualg->cru_type = 0;\n\tualg->cru_mask = 0;\n\tualg->cru_flags = alg->cra_flags;\n\tualg->cru_refcnt = atomic_read(&alg->cra_refcnt);\n\n\tif (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))\n\t\tgoto nla_put_failure;\n\tif (alg->cra_flags & CRYPTO_ALG_LARVAL) {\n\t\tstruct crypto_report_larval rl;\n\n\t\tstrncpy(rl.type, \"larval\", sizeof(rl.type));\n\t\tif (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,\n\t\t\t    sizeof(struct crypto_report_larval), &rl))\n\t\t\tgoto nla_put_failure;\n\t\tgoto out;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tif (!s) continue;\n\t\tGF_BitStream *bs = gf_bs_new(s->data, s->dataLength, GF_BITSTREAM_READ);\n\t\tGF_TextSample *txt = gf_isom_parse_text_sample(bs);\n\t\tif (txt) {\n\t\t\ttimes.vals[i] = (u32) s->DTS;\n\t\t\tnames.vals[i] = gf_strdup(txt->text);\n\t\t\tgf_isom_delete_text_sample(txt);\n\t\t}\n\t\tgf_bs_del(bs);\n\t\tgf_isom_sample_del(&s);\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tif (!s) continue;\n\t\tGF_BitStream *bs = gf_bs_new(s->data, s->dataLength, GF_BITSTREAM_READ);\n\t\tGF_TextSample *txt = gf_isom_parse_text_sample(bs);\n\t\tif (txt) {\n\t\t\ttimes.vals[i] = (u32) s->DTS;\n\t\t\tnames.vals[i] = gf_strdup(txt->text ? txt->text : \"\");\n\t\t\tgf_isom_delete_text_sample(txt);\n\t\t}\n\t\tgf_bs_del(bs);\n\t\tgf_isom_sample_del(&s);\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "tvb_get_manuf_name(tvbuff_t *tvb, gint offset)\n{\n    return get_manuf_name(tvb_get_ptr(tvb, offset, 3));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "tvb_get_manuf_name(tvbuff_t *tvb, gint offset)\n{\n    guint8 buf[6] = { 0 };\n    tvb_memcpy(tvb, buf, offset, 3);\n    return get_manuf_name(buf, sizeof(buf));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int jas_memdump(FILE *out, void *data, size_t len)\n{\n\tsize_t i;\n\tsize_t j;\n\tuchar *dp;\n\tdp = data;\n\tfor (i = 0; i < len; i += 16) {\n\t\tfprintf(out, \"%04zx:\", i);\n\t\tfor (j = 0; j < 16; ++j) {\n\t\t\tif (i + j < len) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int jas_memdump(FILE *out, void *data, size_t len)\n{\n\tsize_t i;\n\tsize_t j;\n\tjas_uchar *dp;\n\tdp = data;\n\tfor (i = 0; i < len; i += 16) {\n\t\tfprintf(out, \"%04zx:\", i);\n\t\tfor (j = 0; j < 16; ++j) {\n\t\t\tif (i + j < len) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      {\n        goto err_close_conn;\n      }\n      if (ans == MUTT_YES)\n      {\n        enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_NO_FLAGS);\n        if (rc == IMAP_EXEC_FATAL)\n          goto bail;\n        if (rc != IMAP_EXEC_ERROR)\n        {\n          if (mutt_ssl_starttls(adata->conn))",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      {\n        goto err_close_conn;\n      }\n      if (ans == MUTT_YES)\n      {\n        enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_SINGLE);\n        // Clear any data after the STARTTLS acknowledgement\n        mutt_socket_empty(adata->conn);\n\n        if (rc == IMAP_EXEC_FATAL)\n          goto bail;\n        if (rc != IMAP_EXEC_ERROR)\n        {\n          if (mutt_ssl_starttls(adata->conn))",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n\n    OP_REQUIRES_OK(context, ValidateInput(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in));\n\n    const Tensor* num_buckets_t;\n    OP_REQUIRES_OK(context, context->input(\"num_buckets\", &num_buckets_t));\n    const int64 num_buckets = num_buckets_t->scalar<int64>()();\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n\n    // Set internal_type to invalid_type so that the check will be ignored.\n    DataType internal_type = DT_INVALID;\n    OP_REQUIRES_OK(\n        context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,\n                               dense_list_in, internal_type));\n\n    const Tensor* num_buckets_t;\n    OP_REQUIRES_OK(context, context->input(\"num_buckets\", &num_buckets_t));\n    const int64 num_buckets = num_buckets_t->scalar<int64>()();\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n  }\n\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    // Create the segmentation map structure and set to 0.\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n\n  if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n    cm->above_seg_context = (PARTITION_CONTEXT *)vpx_calloc(\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n\n  return 0;\n\nfail:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  vp9_set_mb_mi(cm, width, height);\n  new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n  if (cm->mi_alloc_size < new_mi_size) {\n    cm->free_mi(cm);\n    if (cm->alloc_mi(cm, new_mi_size)) goto fail;\n  }\n  if (cm->above_context_alloc_cols < cm->mi_cols) {\n    vpx_free(cm->above_context);\n    cm->above_context = (ENTROPY_CONTEXT *)vpx_calloc(\n        2 * mi_cols_aligned_to_sb(cm->mi_cols) * MAX_MB_PLANE,\n        sizeof(*cm->above_context));\n        mi_cols_aligned_to_sb(cm->mi_cols), sizeof(*cm->above_seg_context));\n    if (!cm->above_seg_context) goto fail;\n    cm->above_context_alloc_cols = cm->mi_cols;\n  }\n\n  if (cm->seg_map_alloc_size < cm->mi_rows * cm->mi_cols) {\n    // Create the segmentation map structure and set to 0.\n    free_seg_map(cm);\n    if (alloc_seg_map(cm, cm->mi_rows * cm->mi_cols)) goto fail;\n  }\n\n  if (vp9_alloc_loop_filter(cm)) goto fail;\n\n  return 0;\n\nfail:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\n\tcase ';':\t\t/* argument terminator */\n\t\tedp->nargs++;\n\t\tbreak;\n\n\tdefault:\t\t/* end of escape sequence */\n\t\toargs = edp->nargs++;\n\t\tif (edp->nargs > SUN_EMUL_NARGS)\n\t\t\tedp->nargs = SUN_EMUL_NARGS;\n\t\trc = wsemul_sun_control(edp, instate);\n\t\tif (rc != 0) {\n\t\t\t/* undo nargs progress */\n\t\t\tedp->nargs = oargs;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tedp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +\n\t\t    (instate->inchar - '0');\n\t\tbreak;\n\n\tcase ';':\t\t/* argument terminator */\n\t\tif (edp->nargs < SUN_EMUL_NARGS)\n\t\t\tedp->nargs++;\n\t\tbreak;\n\n\tdefault:\t\t/* end of escape sequence */\n\t\toargs = edp->nargs;\n\t\tif (edp->nargs < SUN_EMUL_NARGS)\n\t\t\tedp->nargs++;\n\t\trc = wsemul_sun_control(edp, instate);\n\t\tif (rc != 0) {\n\t\t\t/* undo nargs progress */\n\t\t\tedp->nargs = oargs;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn Boolean::New(Isolate::GetCurrent(), result);\n\t\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tauto Phase3() -> Local<Value> final {\n\t\t\treturn Undefined(Isolate::GetCurrent());\n\t\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t * a ClientHello. They can look as if they're replayed,\n\t\t * since they arrive from different connections and\n\t\t * would be dropped unnecessarily.\n\t\t */\n\t\tif (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&\n\t\t    *p == SSL3_MT_CLIENT_HELLO) &&\n\t\t    !dtls1_record_replay_check(s, bitmap))\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\ts->packet_length=0; /* dump this record */\n\t\t\tgoto again;     /* get another record */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t * a ClientHello. They can look as if they're replayed,\n\t\t * since they arrive from different connections and\n\t\t * would be dropped unnecessarily.\n\t\t */\n\t\tif (!(s->d1->listen && rr->type == SSL3_RT_HANDSHAKE &&\n\t\t    s->packet_length > DTLS1_RT_HEADER_LENGTH &&\n\t\t    s->packet[DTLS1_RT_HEADER_LENGTH] == SSL3_MT_CLIENT_HELLO) &&\n\t\t    !dtls1_record_replay_check(s, bitmap))\n\t\t\t{\n\t\t\trr->length = 0;\n\t\t\ts->packet_length=0; /* dump this record */\n\t\t\tgoto again;     /* get another record */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t//get the data\n\tgf_bs_read_data(bs, tmpName, to_read);\n\n\t//then get the break\n\ti = 0;\n\twhile ( (tmpName[i] != 0) && (i < to_read) ) {\n\t\ti++;\n\t}\n\t//check the data is consistent\n\tif (i == to_read) {\n\t\tgf_free(tmpName);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t//get the data\n\tgf_bs_read_data(bs, tmpName, to_read);\n\n\t//then get the break\n\ti = 0;\n\twhile ( (i < to_read) && (tmpName[i] != 0) ) {\n\t\ti++;\n\t}\n\t//check the data is consistent\n\tif (i == to_read) {\n\t\tgf_free(tmpName);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects[0] || object->list.objects[1]->list.length != 1) {\n\t\tr_asn1_free_object (object);\n\t\tfree (container);\n\t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tcontainer = R_NEW0 (RCMS);\n\tif (!container) {\n\t\treturn NULL;\n\t}\n\tobject = r_asn1_create_object (buffer, length);\n\tif (!object || object->list.length != 2 || !object->list.objects ||\n\t\t!object->list.objects[0] || !object->list.objects[1] ||\n\t\tobject->list.objects[1]->list.length != 1) {\n\t\tr_asn1_free_object (object);\n\t\tfree (container);\n\t\treturn NULL;\n\t}\n\tcontainer->contentType = r_asn1_stringify_oid (object->list.objects[0]->sector, object->list.objects[0]->length);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "parse_memory(VALUE klass, VALUE data)\n{\n  xmlParserCtxtPtr ctxt;\n\n  if (NIL_P(data)) {\n    rb_raise(rb_eArgError, \"data cannot be nil\");\n  }\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n\n  ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(data),",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "parse_memory(VALUE klass, VALUE data)\n{\n  xmlParserCtxtPtr ctxt;\n\n  Check_Type(data, T_STRING);\n\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n\n  ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(data),",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                                                 (pprev ? pprev : str), p);\n      }\n    }\n    else {\n      if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n        *low = p - reg->dmax;\n        if (*low > s) {\n          *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n                                          *low, (const UChar** )low_prev);\n          if (low_prev && IS_NULL(*low_prev))\n            *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                   (pprev ? pprev : s), *low);\n        }\n        else {\n          if (low_prev)\n            *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                   (pprev ? pprev : str), *low);\n        }\n      }\n    }\n    /* no needs to adjust *high, *high is used as range check only */\n    *high = p - reg->dmin;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                                                 (pprev ? pprev : str), p);\n      }\n    }\n    else {\n      if (reg->dmax != ONIG_INFINITE_DISTANCE) {\n        if (p - str < reg->dmax) {\n          *low = (UChar* )str;\n          if (low_prev)\n            *low_prev = onigenc_get_prev_char_head(reg->enc, str, *low);\n        }\n        else {\n          *low = p - reg->dmax;\n          if (*low > s) {\n            *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n                                                 *low, (const UChar** )low_prev);\n            if (low_prev && IS_NULL(*low_prev))\n              *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : s), *low);\n          }\n          else {\n            if (low_prev)\n              *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : str), *low);\n          }\n        }\n      }\n    }\n    /* no needs to adjust *high, *high is used as range check only */\n    *high = p - reg->dmin;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        new_cell->pen = screen->pen;\n      }\n    }\n  }\n\n  if(buffer)\n    vterm_allocator_free(screen->vt, buffer);\n\n  return new_buffer;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        new_cell->pen = screen->pen;\n      }\n    }\n  }\n\n  vterm_allocator_free(screen->vt, buffer);\n\n  return new_buffer;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "find_auth_end (FlatpakProxyClient *client, Buffer *buffer)\n{\n  guchar *match;\n  int i;\n\n  /* First try to match any leftover at the start */\n  if (client->auth_end_offset > 0)\n    {\n      gsize left = strlen (AUTH_END_STRING) - client->auth_end_offset;\n      gsize to_match = MIN (left, buffer->pos);\n      /* Matched at least up to to_match */\n      if (memcmp (buffer->data, &AUTH_END_STRING[client->auth_end_offset], to_match) == 0)\n        {\n          client->auth_end_offset += to_match;\n\n          /* Matched all */\n          if (client->auth_end_offset == strlen (AUTH_END_STRING))\n            return to_match;\n\n          /* Matched to end of buffer */\n          return -1;\n        }\n\n      /* Did not actually match at start */\n      client->auth_end_offset = -1;\n    }\n\n  /* Look for whole match inside buffer */\n  match = memmem (buffer, buffer->pos,\n                  AUTH_END_STRING, strlen (AUTH_END_STRING));\n  if (match != NULL)\n    return match - buffer->data + strlen (AUTH_END_STRING);\n\n  /* Record longest prefix match at the end */\n  for (i = MIN (strlen (AUTH_END_STRING) - 1, buffer->pos); i > 0; i--)\n    {\n      if (memcmp (buffer->data + buffer->pos - i, AUTH_END_STRING, i) == 0)\n        {\n          client->auth_end_offset = i;\n          break;\n        }\n    }\n\n  return -1;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "find_auth_end (FlatpakProxyClient *client, Buffer *buffer)\n{\n  goffset offset = 0;\n  gsize original_size = client->auth_buffer->len;\n\n  /* Add the new data to the remaining data from last iteration */\n  g_byte_array_append (client->auth_buffer, buffer->data, buffer->pos);\n\n  while (TRUE)\n    {\n      guint8 *line_start = client->auth_buffer->data + offset;\n      gsize remaining_data = client->auth_buffer->len - offset;\n      guint8 *line_end;\n\n      line_end = memmem (line_start, remaining_data,\n                         AUTH_LINE_SENTINEL, strlen (AUTH_LINE_SENTINEL));\n      if (line_end) /* Found end of line */\n        {\n          offset = (line_end + strlen (AUTH_LINE_SENTINEL) - line_start);\n\n          if (!auth_line_is_valid (line_start, line_end))\n            return FIND_AUTH_END_ABORT;\n\n          *line_end = 0;\n          if (auth_line_is_begin (line_start))\n            return offset - original_size;\n\n          /* continue with next line */\n        }\n      else\n        {\n          /* No end-of-line in this buffer */\n          g_byte_array_remove_range (client->auth_buffer, 0, offset);\n\n          /* Abort if more than 16k before newline, similar to what dbus-daemon does */\n          if (client->auth_buffer->len >= 16*1024)\n            return FIND_AUTH_END_ABORT;\n\n          return FIND_AUTH_END_CONTINUE;\n        }\n    }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t} else {\n\t\t\t/*\n\t\t\t * Get a reference to this pipe buffer,\n\t\t\t * so we can copy the contents over.\n\t\t\t */\n\t\t\tpipe_buf_get(ipipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\n\t\t\t/*\n\t\t\t * Don't inherit the gift flag, we need to\n\t\t\t * prevent multiple steals of this page.",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t} else {\n\t\t\t/*\n\t\t\t * Get a reference to this pipe buffer,\n\t\t\t * so we can copy the contents over.\n\t\t\t */\n\t\t\tif (!pipe_buf_get(ipipe, ibuf)) {\n\t\t\t\tif (ret == 0)\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t*obuf = *ibuf;\n\n\t\t\t/*\n\t\t\t * Don't inherit the gift flag, we need to\n\t\t\t * prevent multiple steals of this page.",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n    DefragInit();\n\n    /* Build a packet, its not a fragment but shouldn't matter for\n     * this test. */\n    p1 = BuildTestPacket(id, 0, 0, 'A', 8);\n    if (p1 == NULL) {\n        goto end;\n    }\n\n    /* Get a tracker. It shouldn't look like its already in use. */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n    DefragInit();\n\n    /* Build a packet, its not a fragment but shouldn't matter for\n     * this test. */\n    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 0, 'A', 8);\n    if (p1 == NULL) {\n        goto end;\n    }\n\n    /* Get a tracker. It shouldn't look like its already in use. */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void xen_irq_lateeoi_locked(struct irq_info *info)\n{\n\tevtchn_port_t evtchn;\n\n\tevtchn = info->evtchn;\n\tif (!VALID_EVTCHN(evtchn))\n\t\treturn;\n\n\tunmask_evtchn(evtchn);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void xen_irq_lateeoi_locked(struct irq_info *info)\n{\n\tevtchn_port_t evtchn;\n\tunsigned int cpu;\n\n\tevtchn = info->evtchn;\n\tif (!VALID_EVTCHN(evtchn) || !list_empty(&info->eoi_list))\n\t\treturn;\n\n\tcpu = info->eoi_cpu;\n\tif (info->eoi_time && info->irq_epoch == per_cpu(irq_epoch, cpu)) {\n\t\tlateeoi_list_add(info);\n\t\treturn;\n\t}\n\n\tinfo->eoi_time = 0;\n\tunmask_evtchn(evtchn);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int context_init(SERVICE_OPTIONS *section) { /* init TLS context */\n    /* create TLS context */\n#if OPENSSL_VERSION_NUMBER>=0x10100000L\n    if(section->option.client)\n        section->ctx=SSL_CTX_new(TLS_client_method());\n    else /* server mode */\n        section->ctx=SSL_CTX_new(TLS_server_method());\n#endif /* OPENSSL_VERSION_NUMBER<0x10100000L */\n    if(!section->ctx) {\n        sslerror(\"SSL_CTX_new\");\n        return 1; /* FAILED */\n    }\n    /* for callbacks */\n    if(!SSL_CTX_set_ex_data(section->ctx, index_ssl_ctx_opt, section)) {\n        sslerror(\"SSL_CTX_set_ex_data\");\n        return 1; /* FAILED */\n    }\n    current_section=section; /* setup current section for callbacks */\n\n    /* ciphers */\n    if(section->cipher_list) {\n        s_log(LOG_DEBUG, \"Ciphers: %s\", section->cipher_list);\n        if(!SSL_CTX_set_cipher_list(section->ctx, section->cipher_list)) {\n\n    /* initialize OpenSSL CONF options */\n    if(conf_init(section))\n        return 1; /* FAILED */\n\n    /* mode */\n#ifdef SSL_MODE_RELEASE_BUFFERS\n    SSL_CTX_set_mode(section->ctx,\n        SSL_MODE_ENABLE_PARTIAL_WRITE |\n        SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER |\n        SSL_MODE_RELEASE_BUFFERS);\n\n    /* initialize verification of the peer server certificate */\n    if(verify_init(section))\n        return 1; /* FAILED */\n\n    /* initialize the DH/ECDH key agreement in the server mode */\n    if(!section->option.client) {\n#ifndef OPENSSL_NO_TLSEXT\n        SSL_CTX_set_tlsext_servername_callback(section->ctx, servername_cb);\n#endif /* OPENSSL_NO_TLSEXT */\n#ifndef OPENSSL_NO_DH\n        dh_init(section); /* ignore the result (errors are not critical) */\n#endif /* OPENSSL_NO_DH */\n#ifndef OPENSSL_NO_ECDH\n        ecdh_init(section); /* ignore the result (errors are not critical) */\n#endif /* OPENSSL_NO_ECDH */\n    }\n\n    return 0; /* OK */\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int context_init(SERVICE_OPTIONS *section) { /* init TLS context */\n    /* create a new TLS context */\n#if OPENSSL_VERSION_NUMBER>=0x10100000L\n    if(section->option.client)\n        section->ctx=SSL_CTX_new(TLS_client_method());\n    else /* server mode */\n        section->ctx=SSL_CTX_new(TLS_server_method());\n#endif /* OPENSSL_VERSION_NUMBER<0x10100000L */\n    if(!section->ctx) {\n        sslerror(\"SSL_CTX_new\");\n        return 1; /* FAILED */\n    }\n\n    /* allow callbacks to access their SERVICE_OPTIONS structure */\n    if(!SSL_CTX_set_ex_data(section->ctx, index_ssl_ctx_opt, section)) {\n        sslerror(\"SSL_CTX_set_ex_data\");\n        return 1; /* FAILED */\n    }\n    current_section=section; /* setup current section for callbacks */\n\n#if OPENSSL_VERSION_NUMBER>=0x10100000L\n    /* set the security level */\n    if(section->security_level>=0) {\n        /* set the user-specified value */\n        SSL_CTX_set_security_level(section->ctx, section->security_level);\n        s_log(LOG_INFO, \"User-specified security level set: %d\",\n            section->security_level);\n    } else if(SSL_CTX_get_security_level(section->ctx)<DEFAULT_SECURITY_LEVEL) {\n        /* set our default, as it is more secure than the OpenSSL default */\n        SSL_CTX_set_security_level(section->ctx, DEFAULT_SECURITY_LEVEL);\n        s_log(LOG_INFO, \"stunnel default security level set: %d\",\n            DEFAULT_SECURITY_LEVEL);\n    } else { /* our default is not more secure than the OpenSSL default */\n        s_log(LOG_INFO, \"OpenSSL security level is used: %d\",\n            SSL_CTX_get_security_level(section->ctx));\n    }\n#endif /* OpenSSL 1.1.0 or later */\n\n    /* ciphers */\n    if(section->cipher_list) {\n        s_log(LOG_DEBUG, \"Ciphers: %s\", section->cipher_list);\n        if(!SSL_CTX_set_cipher_list(section->ctx, section->cipher_list)) {\n\n    /* initialize OpenSSL CONF options */\n    if(conf_init(section))\n        return 1; /* FAILED */\n\n    /* setup mode of operation for the TLS state machine */\n#ifdef SSL_MODE_RELEASE_BUFFERS\n    SSL_CTX_set_mode(section->ctx,\n        SSL_MODE_ENABLE_PARTIAL_WRITE |\n        SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER |\n        SSL_MODE_RELEASE_BUFFERS);\n\n    /* initialize verification of the peer server certificate */\n    if(verify_init(section))\n        return 1; /* FAILED */\n\n    /* initialize the DH/ECDH key agreement */\n#ifndef OPENSSL_NO_TLSEXT\n    if(!section->option.client)\n        SSL_CTX_set_tlsext_servername_callback(section->ctx, servername_cb);\n#endif /* OPENSSL_NO_TLSEXT */\n#ifndef OPENSSL_NO_DH\n    dh_init(section); /* ignore the result (errors are not critical) */\n#endif /* OPENSSL_NO_DH */\n#ifndef OPENSSL_NO_ECDH\n    ecdh_init(section); /* ignore the result (errors are not critical) */\n#endif /* OPENSSL_NO_ECDH */\n\n    return 0; /* OK */\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback)\n{\n    char des_pass[9], *epass;\n    char *pw_epasswd = auth->data;\n    size_t pw_len;\n    int matched = 0;\n    debug_decl(sudo_passwd_verify, SUDOERS_DEBUG_AUTH);\n\n    /* An empty plain-text password must match an empty encrypted password. */\n    if (pass[0] == '\\0')\n\tdebug_return_int(pw_epasswd[0] ? AUTH_FAILURE : AUTH_SUCCESS);\n    /*\n     * Truncate to 8 chars if standard DES since not all crypt()'s do this.\n     */\n    pw_len = strlen(pw_epasswd);\n    if (pw_len == DESLEN || HAS_AGEINFO(pw_epasswd, pw_len)) {\n\tstrlcpy(des_pass, pass, sizeof(des_pass));\n\tpass = des_pass;\n    }\n\n    /*\n     * Normal UN*X password check.\n     * HP-UX may add aging info (separated by a ',') at the end so\n     * only compare the first DESLEN characters in that case.\n     */\n    epass = (char *) crypt(pass, pw_epasswd);\n    if (epass != NULL) {\n\tif (HAS_AGEINFO(pw_epasswd, pw_len) && strlen(epass) == DESLEN)\n\t    matched = !strncmp(pw_epasswd, epass, DESLEN);\n\telse\n\t    matched = !strcmp(pw_epasswd, epass);\n    }\n\n    explicit_bzero(des_pass, sizeof(des_pass));\n\n    debug_return_int(matched ? AUTH_SUCCESS : AUTH_FAILURE);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    const char *pass, sudo_auth *auth, struct sudo_conv_callback *callback)\n{\n    char des_pass[9], *epass;\n    char *pw_epasswd = auth->data;\n    size_t pw_len;\n    int ret;\n    debug_decl(sudo_passwd_verify, SUDOERS_DEBUG_AUTH);\n\n    /* An empty plain-text password must match an empty encrypted password. */\n    if (pass[0] == '\\0')\n\tdebug_return_int(pw_epasswd[0] ? AUTH_FAILURE : AUTH_SUCCESS);\n    /*\n     * Truncate to 8 chars if standard DES since not all crypt()'s do this.\n     */\n    pw_len = strlen(pw_epasswd);\n    if (pw_len == DESLEN || HAS_AGEINFO(pw_epasswd, pw_len)) {\n\t(void)strlcpy(des_pass, pass, sizeof(des_pass));\n\tpass = des_pass;\n    }\n\n    /*\n     * Normal UN*X password check.\n     * HP-UX may add aging info (separated by a ',') at the end so\n     * only compare the first DESLEN characters in that case.\n     */\n    epass = (char *) crypt(pass, pw_epasswd);\n    ret = AUTH_FAILURE;\n    if (epass != NULL) {\n\tif (HAS_AGEINFO(pw_epasswd, pw_len) && strlen(epass) == DESLEN) {\n\t    if (strncmp(pw_epasswd, epass, DESLEN) == 0)\n\t\tret = AUTH_SUCCESS;\n\t} else {\n\t    if (strcmp(pw_epasswd, epass) == 0)\n\t\tret = AUTH_SUCCESS;\n\t}\n    }\n\n    explicit_bzero(des_pass, sizeof(des_pass));\n\n    debug_return_int(ret);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tts->ess[es->pid] = es;\n\t\t\tgf_list_add(pmt->program->streams, es);\n\t\t\tif (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);\n\n\t\t\tnb_es++;\n\t\t}\n\n\t\tif (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;\n\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;\n\t}\n\n\t//Table 2-139, implied hierarchy indexes\n\tif (nb_hevc_temp + nb_shvc + nb_shvc_temp + nb_mhvc+ nb_mhvc_temp) {\n\t\tfor (i=0; i<gf_list_count(pmt->program->streams); i++) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tts->ess[es->pid] = es;\n\t\t\tgf_list_add(pmt->program->streams, es);\n\t\t\tif (!(es->flags & GF_M2TS_ES_IS_SECTION) ) gf_m2ts_set_pes_framing(pes, GF_M2TS_PES_FRAMING_SKIP);\n\n\t\t\tnb_es++;\n\n\t\t\tif (es->stream_type == GF_M2TS_VIDEO_HEVC) nb_hevc++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_HEVC_TEMPORAL) nb_hevc_temp++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC) nb_shvc++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_SHVC_TEMPORAL) nb_shvc_temp++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC) nb_mhvc++;\n\t\t\telse if (es->stream_type == GF_M2TS_VIDEO_MHVC_TEMPORAL) nb_mhvc_temp++;\n\t\t}\n\t}\n\n\t//Table 2-139, implied hierarchy indexes\n\tif (nb_hevc_temp + nb_shvc + nb_shvc_temp + nb_mhvc+ nb_mhvc_temp) {\n\t\tfor (i=0; i<gf_list_count(pmt->program->streams); i++) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "/* static */ tsl::Status GpuDriver::GetGpuISAVersion(int* version,\n                                                     CUdevice device) {\n  return tsl::Status{\n      port::error::INTERNAL,\n      \"Feature not supported on CUDA platform (GetGpuISAVersion)\"};\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "/* static */ tsl::Status GpuDriver::GetGpuISAVersion(int* version,\n                                                     CUdevice device) {\n  return tsl::Status{\n      tsl::error::INTERNAL,\n      \"Feature not supported on CUDA platform (GetGpuISAVersion)\"};\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int Archive::Read(void *Data,size_t Size)\n{\n  size_t Result;\n  if (QOpen.Read(Data,Size,Result))\n    return (int)Result;\n  return File::Read(Data,Size);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int Archive::Read(void *Data,size_t Size)\n{\n#ifdef USE_QOPEN\n  size_t QResult;\n  if (QOpen.Read(Data,Size,QResult))\n    return (int)QResult;\n#endif\n#ifdef USE_ARCMEM\n  size_t AResult;\n  if (ArcMem.Read(Data,Size,AResult))\n    return (int)AResult;\n#endif\n  return File::Read(Data,Size);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\twhile (*s == ',' || *s == ' ')\n\t    s++;\n\tif (!*s)\n\t    break;\n\tif (vim_strchr((char_u *)\".wbuksid]tU\", *s) == NULL)\n\t    return illegal_char(args->os_errbuf, *s);\n\tif (*++s != NUL && *s != ',' && *s != ' ')\n\t{\n\t    if (s[-1] == 'k' || s[-1] == 's')\n\t    {\n\t\t// skip optional filename after 'k' and 's'\n\t    }\n\t    else\n\t    {\n\t\tif (args->os_errbuf != NULL)\n\t\t{\n\t\t    sprintf((char *)args->os_errbuf,\n\t\t\t    _(e_illegal_character_after_chr), *--s);\n\t\t    return args->os_errbuf;\n\t\t}\n\t\treturn \"\";\n\t    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\twhile (*s == ',' || *s == ' ')\n\t    s++;\n\tif (!*s)\n\t    break;\n\tif (vim_strchr((char_u *)\".wbuksid]tU\", *s) == NULL)\n\t    return illegal_char(args->os_errbuf, args->os_errbuflen, *s);\n\tif (*++s != NUL && *s != ',' && *s != ' ')\n\t{\n\t    if (s[-1] == 'k' || s[-1] == 's')\n\t    {\n\t\t// skip optional filename after 'k' and 's'\n\t    }\n\t    else\n\t    {\n\t\tif (args->os_errbuf != NULL)\n\t\t{\n\t\t    snprintf((char *)args->os_errbuf, args->os_errbuflen,\n\t\t\t    _(e_illegal_character_after_chr), *--s);\n\t\t    return args->os_errbuf;\n\t\t}\n\t\treturn \"\";\n\t    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    void runTest() override\n    {\n        beginTest (\"ZIP\");\n\n        ZipFile::Builder builder;\n        StringArray entryNames { \"first\", \"second\", \"third\" };\n        HashMap<String, MemoryBlock> blocks;\n\n        for (auto& entryName : entryNames)\n        {\n            auto& block = blocks.getReference (entryName);\n            MemoryOutputStream mo (block, false);\n            mo << entryName;\n            mo.flush();\n            builder.addEntry (new MemoryInputStream (block, false), 9, entryName, Time::getCurrentTime());\n        }\n\n        MemoryBlock data;\n        MemoryOutputStream mo (data, false);\n        builder.writeToStream (mo, nullptr);\n        MemoryInputStream mi (data, false);\n\n        ZipFile zip (mi);\n\n        expectEquals (zip.getNumEntries(), entryNames.size());\n\n        for (auto& entryName : entryNames)\n        {\n            auto* entry = zip.getEntry (entryName);\n            std::unique_ptr<InputStream> input (zip.createStreamForEntry (*entry));\n            expectEquals (input->readEntireStreamAsString(), entryName);\n        }\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    void runTest() override\n    {\n        beginTest (\"ZIP\");\n\n        StringArray entryNames { \"first\", \"second\", \"third\" };\n        auto data = createZipMemoryBlock (entryNames);\n        MemoryInputStream mi (data, false);\n        ZipFile zip (mi);\n\n        expectEquals (zip.getNumEntries(), entryNames.size());\n\n        for (auto& entryName : entryNames)\n        {\n            auto* entry = zip.getEntry (entryName);\n            std::unique_ptr<InputStream> input (zip.createStreamForEntry (*entry));\n            expectEquals (input->readEntireStreamAsString(), entryName);\n        }\n\n        beginTest (\"ZipSlip\");\n        runZipSlipTest();\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t * Find a \"hole\" in the attribute address space large enough for\n\t * us to drop the new attribute's value into. Because CRC enable\n\t * attributes have headers, we can't just do a straight byte to FSB\n\t * conversion and have to take the header space into account.\n\t */\n\tblkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);\n\terror = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,\n\t\t\t\t\t\t   XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\n\t * so that we can know they are all on disk before we turn off\n\t * the INCOMPLETE flag.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tvaluelen = args->valuelen;\n\twhile (valuelen > 0) {\n\t\tstruct xfs_buf\t*bp;\n\t\txfs_daddr_t\tdblkno;\n\t\tint\t\tdblkcnt;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t * Find a \"hole\" in the attribute address space large enough for\n\t * us to drop the new attribute's value into. Because CRC enable\n\t * attributes have headers, we can't just do a straight byte to FSB\n\t * conversion and have to take the header space into account.\n\t */\n\tblkcnt = xfs_attr3_rmt_blocks(mp, args->rmtvaluelen);\n\terror = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,\n\t\t\t\t\t\t   XFS_ATTR_FORK);\n\tif (error)\n\t\treturn error;\n\n\t * so that we can know they are all on disk before we turn off\n\t * the INCOMPLETE flag.\n\t */\n\tlblkno = args->rmtblkno;\n\tblkcnt = args->rmtblkcnt;\n\tvaluelen = args->rmtvaluelen;\n\twhile (valuelen > 0) {\n\t\tstruct xfs_buf\t*bp;\n\t\txfs_daddr_t\tdblkno;\n\t\tint\t\tdblkcnt;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len,\n        bigint *modulus, bigint *pub_exp)\n{\n    int i, size;\n    bigint *decrypted_bi, *dat_bi;\n    bigint *bir = NULL;\n    uint8_t *block = (uint8_t *)malloc(sig_len);\n\n    /* decrypt */\n    dat_bi = bi_import(ctx, sig, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);\n\n    bi_export(ctx, decrypted_bi, block, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    i = 10; /* start at the first possible non-padded byte */\n    while (block[i++] && i < sig_len);\n    size = sig_len - i;\n\n    /* get only the bit we want */\n    if (size > 0)\n    {\n        int len;\n        const uint8_t *sig_ptr = get_signature(&block[i], &len);\n\n        if (sig_ptr)\n        {\n            bir = bi_import(ctx, sig_ptr, len);\n        }\n    }\n    free(block);\n    /* save a few bytes of memory */\n    bi_clear_cache(ctx);\n    return bir;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static bigint *sig_verify(BI_CTX *ctx, const uint8_t *sig, int sig_len, uint8_t sig_type,\n        bigint *modulus, bigint *pub_exp)\n{\n    int i;\n    bigint *decrypted_bi, *dat_bi;\n    bigint *bir = NULL;\n    uint8_t *block = (uint8_t *)malloc(sig_len);\n\n    const uint8_t *sig_prefix = NULL;\n    uint8_t sig_prefix_size = 0, hash_len = 0;\n    /* adjust our expections */\n    switch (sig_type)\n    {\n        case SIG_TYPE_MD5:\n            sig_prefix = sig_prefix_md5;\n            sig_prefix_size = sizeof(sig_prefix_md5);\n        break;\n        case SIG_TYPE_SHA1:\n            sig_prefix = sig_prefix_sha1;\n            sig_prefix_size = sizeof(sig_prefix_sha1);\n        break;\n        case SIG_TYPE_SHA256:\n            sig_prefix = sig_prefix_sha256;\n            sig_prefix_size = sizeof(sig_prefix_sha256);\n        break;\n        case SIG_TYPE_SHA384:\n            sig_prefix = sig_prefix_sha384;\n            sig_prefix_size = sizeof(sig_prefix_sha384);\n        break;\n        case SIG_TYPE_SHA512:\n            sig_prefix = sig_prefix_sha512;\n            sig_prefix_size = sizeof(sig_prefix_sha512);\n        break;\n    }\n    if (sig_prefix)\n        hash_len = sig_prefix[sig_prefix_size - 1];\n\n    /* check length (#A) */\n    if (sig_len < 2 + 8 + 1 + sig_prefix_size + hash_len)\n        goto err;\n\n    /* decrypt */\n    dat_bi = bi_import(ctx, sig, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    decrypted_bi = bi_mod_power2(ctx, dat_bi, modulus, pub_exp);\n\n    bi_export(ctx, decrypted_bi, block, sig_len);\n    ctx->mod_offset = BIGINT_M_OFFSET;\n\n    /* check the first 2 bytes */\n    if (block[0] != 0 || block[1] != 1)\n        goto err;\n\n    /* check the padding */\n    i = 2; /* start at the first padding byte */\n    while (i < sig_len - 1 - sig_prefix_size - hash_len)\n    { /* together with (#A), we require at least 8 bytes of padding */\n        if (block[i++] != 0xFF)\n            goto err;\n    }\n\n    /* check end of padding */\n    if (block[i++] != 0)\n        goto err;\n\n    /* check the ASN.1 metadata */\n    if (memcmp_P(block+i, sig_prefix, sig_prefix_size))\n        goto err;\n\n    /* now we can get the hash we need */\n    bir = bi_import(ctx, block + i + sig_prefix_size, hash_len);\n\nerr:\n    free(block);\n    /* save a few bytes of memory */\n    bi_clear_cache(ctx);\n    return bir;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional max pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional max pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t*new_node = NULL;\n\tnode = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tfor (i = 2; i <= file_de->file_num_ext; i++) {\n\t\tret = exfat_de_iter_get(iter, i, &dentry);\n\t\tif (ret || dentry->type != EXFAT_NAME)\n\t\t\tbreak;\n\t\tmemcpy(node->name +\n\t\t       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t*new_node = NULL;\n\tnode = exfat_alloc_inode(le16_to_cpu(file_de->file_attr));\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tfor (i = 2; i <= MIN(file_de->file_num_ext, 1 + MAX_NAME_DENTRIES); i++) {\n\t\tret = exfat_de_iter_get(iter, i, &dentry);\n\t\tif (ret || dentry->type != EXFAT_NAME)\n\t\t\tbreak;\n\t\tmemcpy(node->name +\n\t\t       (i - 2) * ENTRY_NAME_MAX, dentry->name_unicode,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t/* This will run the backlog queue.  */\n\trelease_sock(sk);\n\n\t/* Supposedly, no process has access to the socket, but\n\t * the net layers still may.\n\t */\n\tlocal_bh_disable();\n\tbh_lock_sock(sk);\n\n\t/* Hold the sock, since sk_common_release() will put sock_put()\n\t * and we have just a little more cleanup.\n\t */\n\tsock_hold(sk);\n\tsk_common_release(sk);\n\n\tbh_unlock_sock(sk);\n\tlocal_bh_enable();\n\n\tsock_put(sk);\n\n\tSCTP_DBG_OBJCNT_DEC(sock);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t/* This will run the backlog queue.  */\n\trelease_sock(sk);\n\n\t/* Supposedly, no process has access to the socket, but\n\t * the net layers still may.\n\t * Also, sctp_destroy_sock() needs to be called with addr_wq_lock\n\t * held and that should be grabbed before socket lock.\n\t */\n\tspin_lock_bh(&net->sctp.addr_wq_lock);\n\tbh_lock_sock(sk);\n\n\t/* Hold the sock, since sk_common_release() will put sock_put()\n\t * and we have just a little more cleanup.\n\t */\n\tsock_hold(sk);\n\tsk_common_release(sk);\n\n\tbh_unlock_sock(sk);\n\tspin_unlock_bh(&net->sctp.addr_wq_lock);\n\n\tsock_put(sk);\n\n\tSCTP_DBG_OBJCNT_DEC(sock);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static pyc_object *get_list_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (list size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static pyc_object *get_list_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (list size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tTAILQ_INIT(&port->p_vlans);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\tif (length < SONMP_SIZE) {\n\t\tlog_warnx(\"sonmp\", \"too short SONMP frame received on %s\", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (PEEK_CMP(mcastaddr, sizeof(mcastaddr)) != 0)\n\t\t/* There is two multicast address. We just handle only one of",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tTAILQ_INIT(&port->p_vlans);\n#endif\n\n\tlength = s;\n\tpos = (u_int8_t*)frame;\n\tif (length < SONMP_SIZE + 2*ETHER_ADDR_LEN + sizeof(u_int16_t)) {\n\t\tlog_warnx(\"sonmp\", \"too short SONMP frame received on %s\", hardware->h_ifname);\n\t\tgoto malformed;\n\t}\n\tif (PEEK_CMP(mcastaddr, sizeof(mcastaddr)) != 0)\n\t\t/* There is two multicast address. We just handle only one of",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tsize_t len = (*size > 0) ? *size : strlen(buf);\n\tif (len <= 0) return NULL;\n\tunsigned char *outbuf = (unsigned char*)malloc((len/4)*3+3);\n\tconst char *ptr = buf;\n\tint p = 0;\n\tsize_t l = 0;\n\n\tdo {\n\t\tptr += strspn(ptr, \"\\r\\n\\t \");\n\t\tif (*ptr == '\\0' || ptr >= buf+len) {\n\t\t\tbreak;\n\t\t}\n\t\tl = strcspn(ptr, \"\\r\\n\\t \");\n\t\tif (l > 3 && ptr+l <= buf+len) {\n\t\t\tp+=base64decode_block(outbuf+p, ptr, l);\n\t\t\tptr += l;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t} while (1);\n\n\toutbuf[p] = 0;\n\t*size = p;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tsize_t len = (*size > 0) ? *size : strlen(buf);\n\tif (len <= 0) return NULL;\n\tunsigned char *outbuf = (unsigned char*)malloc((len/4)*3+3);\n\tconst char *ptr = buf;\n\tint p = 0;\n\tint wv, w1, w2, w3, w4;\n\tint tmpval[4];\n\tint tmpcnt = 0;\n\n\tdo {\n\t\twhile (ptr < buf+len && (*ptr == ' ' || *ptr == '\\t' || *ptr == '\\n' || *ptr == '\\r')) {\n\t\t\tptr++;\n\t\t}\n\t\tif (*ptr == '\\0' || ptr >= buf+len) {\n\t\t\tbreak;\n\t\t}\n\t\tif ((wv = base64_table[(int)(unsigned char)*ptr++]) == -1) {\n\t\t\tcontinue;\n\t\t}\n\t\ttmpval[tmpcnt++] = wv;\n\t\tif (tmpcnt == 4) {\n\t\t\ttmpcnt = 0;\n\t\t\tw1 = tmpval[0];\n\t\t\tw2 = tmpval[1];\n\t\t\tw3 = tmpval[2];\n\t\t\tw4 = tmpval[3];\n\n\t\t\tif (w2 >= 0) {\n\t\t\t\toutbuf[p++] = (unsigned char)(((w1 << 2) + (w2 >> 4)) & 0xFF);\n\t\t\t}\n\t\t\tif (w3 >= 0) {\n\t\t\t\toutbuf[p++] = (unsigned char)(((w2 << 4) + (w3 >> 2)) & 0xFF);\n\t\t\t}\n\t\t\tif (w4 >= 0) {\n\t\t\t\toutbuf[p++] = (unsigned char)(((w3 << 6) + w4) & 0xFF);\n\t\t\t}\n\t\t}\n\t} while (1);\n\n\toutbuf[p] = 0;\n\t*size = p;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (iocb->ki_pos + iter->count > i_size_read(inode) &&\n\t    !ocfs2_supports_append_dio(osb))\n\t\treturn 0;\n\n\tif (iov_iter_rw(iter) == READ)\n\t\tget_block = ocfs2_get_block;\n\telse\n\t\tget_block = ocfs2_dio_get_block;\n\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t    iter, get_block,\n\t\t\t\t    ocfs2_dio_end_io, NULL, 0);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (iocb->ki_pos + iter->count > i_size_read(inode) &&\n\t    !ocfs2_supports_append_dio(osb))\n\t\treturn 0;\n\n\tif (iov_iter_rw(iter) == READ)\n\t\tget_block = ocfs2_lock_get_block;\n\telse\n\t\tget_block = ocfs2_dio_wr_get_block;\n\n\treturn __blockdev_direct_IO(iocb, inode, inode->i_sb->s_bdev,\n\t\t\t\t    iter, get_block,\n\t\t\t\t    ocfs2_dio_end_io, NULL, 0);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void __net_random_once_deferred(struct work_struct *w)\n{\n\tstruct __net_random_once_work *work =\n\t\tcontainer_of(w, struct __net_random_once_work, work);\n\tif (!static_key_enabled(work->key))\n\t\tstatic_key_slow_inc(work->key);\n\tkfree(work);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void __net_random_once_deferred(struct work_struct *w)\n{\n\tstruct __net_random_once_work *work =\n\t\tcontainer_of(w, struct __net_random_once_work, work);\n\tBUG_ON(!static_key_enabled(work->key));\n\tstatic_key_slow_dec(work->key);\n\tkfree(work);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t */\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\t}\n\n\terr = skb_append_datato_frags(sk,skb, getfrag, from,\n\t\t\t\t      (length - transhdrlen));\n\tif (!err) {\n\t\tstruct frag_hdr fhdr;\n\n\t\t/* Specify the length of each IPv6 datagram fragment.\n\t\t * It has to be a multiple of 8.\n\t\t */\n\t\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\tipv6_select_ident(&fhdr, rt);\n\t\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\n\t\treturn 0;\n\t}\n\t/* There is not enough support do UPD LSO,\n\t * so follow normal path\n\t */\n\tkfree_skb(skb);\n\n\treturn err;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t/* There is support for UDP large send offload by network\n\t * device, so create one single skb packet containing complete\n\t * udp datagram\n\t */\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {\n\t\tstruct frag_hdr fhdr;\n\n\t\tskb = sock_alloc_send_skb(sk,\n\t\t\thh_len + fragheaderlen + transhdrlen + 20,\n\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\tif (skb == NULL)\n\t\t\treturn err;\n\t\t/* initialize protocol header pointer */\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\n\t\t/* Specify the length of each IPv6 datagram fragment.\n\t\t * It has to be a multiple of 8.\n\t\t */\n\t\tskb_shinfo(skb)->gso_size = (mtu - fragheaderlen -\n\t\t\t\t\t     sizeof(struct frag_hdr)) & ~7;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\tipv6_select_ident(&fhdr, rt);\n\t\tskb_shinfo(skb)->ip6_frag_id = fhdr.identification;\n\t\t__skb_queue_tail(&sk->sk_write_queue, skb);\n\t}\n\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tport = (char *)json_string_value(json_array_get(val, 1));\n\tif (!port)\n\t\tport = pool->stratum_port;\n\n\tsprintf(address, \"%s:%s\", url, port);\n\n\tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n\t\treturn false;\n\n\tapplog(LOG_WARNING, \"Stratum reconnect requested from pool %d to %s\", pool->pool_no, address);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tport = (char *)json_string_value(json_array_get(val, 1));\n\tif (!port)\n\t\tport = pool->stratum_port;\n\n\tsnprintf(address, 254, \"%s:%s\", url, port);\n\n\tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n\t\treturn false;\n\n\tapplog(LOG_WARNING, \"Stratum reconnect requested from pool %d to %s\", pool->pool_no, address);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "Status GetMatchingPaths(FileSystem* fs, Env* env, const string& pattern,\n                        std::vector<string>* results) {\n  results->clear();\n  if (pattern.empty()) {\n    return Status::OK();\n  }\n\n  string fixed_prefix = pattern.substr(0, pattern.find_first_of(\"*?[\\\\\"));\n  string eval_pattern = pattern;\n  string dir(io::Dirname(fixed_prefix));\n  // If dir is empty then we need to fix up fixed_prefix and eval_pattern to\n  // include . as the top level directory.\n  if (dir.empty()) {\n    dir = \".\";\n    fixed_prefix = io::JoinPath(dir, fixed_prefix);\n    eval_pattern = io::JoinPath(dir, eval_pattern);\n  }\n  bool is_directory = pattern[pattern.size() - 1] == '/';\n#ifdef PLATFORM_WINDOWS\n  is_directory = is_directory || pattern[pattern.size() - 1] == '\\\\';\n#endif\n  std::vector<string> dirs;\n  if (!is_directory) {\n    dirs.emplace_back(eval_pattern);\n  }\n  StringPiece tmp_dir(io::Dirname(eval_pattern));\n  while (tmp_dir.size() > dir.size()) {\n    dirs.emplace_back(string(tmp_dir));\n    tmp_dir = io::Dirname(tmp_dir);\n  }\n  dirs.emplace_back(dir);\n  std::reverse(dirs.begin(), dirs.end());\n  // Setup a parallel BFS to explore everything under dir.\n  std::deque<std::pair<string, int>> dir_q;\n  std::deque<std::pair<string, int>> next_dir_q;\n  dir_q.emplace_back(std::make_pair(dirs[0], 0));\n  Status ret;  // Status to return.\n  mutex results_mutex;\n  condition_variable results_cond;\n  mutex next_que_mutex;\n  condition_variable next_que_cond;\n  while (!dir_q.empty()) {\n    next_dir_q.clear();\n    std::vector<Status> new_rets(dir_q.size());\n    auto handle_level = [fs, &results, &dir_q, &next_dir_q, &new_rets,\n                         &is_directory, &dirs, &results_mutex, &results_cond,\n                         &next_que_mutex, &next_que_cond](int i) {\n      string current_dir = dir_q.at(i).first;\n      int dir_index = dir_q.at(i).second;\n      dir_index++;\n      std::vector<string> children;\n      Status s = fs->GetChildren(current_dir, &children);\n      // In case PERMISSION_DENIED is encountered, we bail here.\n      if (s.code() == tensorflow::error::PERMISSION_DENIED) {\n        return;\n      }\n      new_rets[i] = s;\n      if (children.empty()) return;\n\n      // children_dir_status holds is_dir status for children. It can have three\n      // possible values: OK for true; FAILED_PRECONDITION for false; CANCELLED\n      // if we don't calculate IsDirectory (we might do that because there isn't\n      // any point in exploring that child path).\n      std::vector<Status> children_dir_status;\n\n      // This IsDirectory call can be expensive for some FS. Parallelizing it.\n      children_dir_status.resize(children.size());\n      auto handle_children = [fs, &current_dir, &children, &dirs, dir_index,\n                              is_directory, &children_dir_status](int j) {\n        const string child_path = io::JoinPath(current_dir, children[j]);\n        if (!fs->Match(child_path, dirs[dir_index])) {\n          children_dir_status[j] =\n              Status(tensorflow::error::CANCELLED, \"Operation not needed\");\n        } else if (dir_index != dirs.size() - 1) {\n          children_dir_status[j] = fs->IsDirectory(child_path);\n        } else {\n          children_dir_status[j] =\n              is_directory ? fs->IsDirectory(child_path) : Status::OK();\n        }\n      };\n      ForEach(0, children.size(), handle_children);\n\n      for (size_t j = 0; j < children.size(); ++j) {\n        const string child_path = io::JoinPath(current_dir, children[j]);\n        // If the IsDirectory call was cancelled we bail.\n        if (children_dir_status[j].code() == tensorflow::error::CANCELLED) {\n          continue;\n        }\n        if (children_dir_status[j].ok()) {\n          if (dir_index != dirs.size() - 1) {\n            mutex_lock lk(next_que_mutex);\n            next_dir_q.emplace_back(std::make_pair(child_path, dir_index));\n            next_que_cond.notify_one();\n          } else {\n            mutex_lock lk(results_mutex);\n            results->emplace_back(child_path);\n            results_cond.notify_one();\n          }\n        }\n      }\n    };\n    ForEach(0, dir_q.size(), handle_level);\n\n    ret.Update(new_rets[dir_q.size() - 1]);\n    std::swap(dir_q, next_dir_q);\n  }\n  return ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "Status GetMatchingPaths(FileSystem* fs, Env* env, const string& pattern,\n                        std::vector<string>* results) {\n  // Check that `fs`, `env` and `results` are non-null.\n  if (fs == nullptr || env == nullptr || results == nullptr) {\n    return Status(tensorflow::error::INVALID_ARGUMENT,\n                  \"Filesystem calls GetMatchingPaths with nullptr arguments\");\n  }\n\n  // By design, we don't match anything on empty pattern\n  results->clear();\n  if (pattern.empty()) {\n    return Status::OK();\n  }\n\n  // The pattern can contain globbing characters at multiple levels, e.g.:\n  //\n  //   foo/ba?/baz/f*r\n  //\n  // To match the full pattern, we must match every prefix subpattern and then\n  // operate on the children for each match. Thus, we separate all subpatterns\n  // in the `dirs` vector below.\n  std::vector<std::string> dirs = AllDirectoryPrefixes(pattern);\n\n  // We can have patterns that have several parents where no globbing is being\n  // done, for example, `foo/bar/baz/*`. We don't need to expand the directories\n  // which don't contain the globbing characters.\n  int matching_index = GetFirstGlobbingEntry(dirs);\n\n  // If we don't have globbing characters in the pattern then it specifies a\n  // path in the filesystem. We add it to the result set if it exists.\n  if (matching_index == dirs.size()) {\n    if (fs->FileExists(pattern).ok()) {\n      results->emplace_back(pattern);\n    }\n    return Status::OK();\n  }\n\n  // To expand the globbing, we do a BFS from `dirs[matching_index-1]`.\n  // At every step, we work on a pair `{dir, ix}` such that `dir` is a real\n  // directory, `ix < dirs.size() - 1` and `dirs[ix+1]` is a globbing pattern.\n  // To expand the pattern, we select from all the children of `dir` only those\n  // that match against `dirs[ix+1]`.\n  // If there are more entries in `dirs` after `dirs[ix+1]` this mean we have\n  // more patterns to match. So, we add to the queue only those children that\n  // are also directories, paired with `ix+1`.\n  // If there are no more entries in `dirs`, we return all children as part of\n  // the answer.\n  // Since we can get into a combinatorial explosion issue (e.g., pattern\n  // `/*/*/*`), we process the queue in parallel. Each parallel processing takes\n  // elements from `expand_queue` and adds them to `next_expand_queue`, after\n  // which we swap these two queues (similar to double buffering algorithms).\n  // PRECONDITION: `IsGlobbingPattern(dirs[0]) == false`\n  // PRECONDITION: `matching_index > 0`\n  // INVARIANT: If `{d, ix}` is in queue, then `d` and `dirs[ix]` are at the\n  //            same level in the filesystem tree.\n  // INVARIANT: If `{d, _}` is in queue, then `IsGlobbingPattern(d) == false`.\n  // INVARIANT: If `{d, _}` is in queue, then `d` is a real directory.\n  // INVARIANT: If `{_, ix}` is in queue, then `ix < dirs.size() - 1`.\n  // INVARIANT: If `{_, ix}` is in queue, `IsGlobbingPattern(dirs[ix + 1])`.\n  std::deque<std::pair<string, int>> expand_queue;\n  std::deque<std::pair<string, int>> next_expand_queue;\n  expand_queue.emplace_back(dirs[matching_index - 1], matching_index - 1);\n\n  // Adding to `result` or `new_expand_queue` need to be protected by mutexes\n  // since there are multiple threads writing to these.\n  mutex result_mutex;\n  mutex queue_mutex;\n\n  while (!expand_queue.empty()) {\n    next_expand_queue.clear();\n\n    // The work item for every item in `expand_queue`.\n    // pattern, we process them in parallel.\n    auto handle_level = [&fs, &results, &dirs, &expand_queue,\n                         &next_expand_queue, &result_mutex,\n                         &queue_mutex](int i) {\n      // See invariants above, all of these are valid accesses.\n      const auto& queue_item = expand_queue.at(i);\n      const std::string& parent = queue_item.first;\n      const int index = queue_item.second + 1;\n      const std::string& match_pattern = dirs[index];\n\n      // Get all children of `parent`. If this fails, return early.\n      std::vector<std::string> children;\n      Status s = fs->GetChildren(parent, &children);\n      if (s.code() == tensorflow::error::PERMISSION_DENIED) {\n        return;\n      }\n\n      // Also return early if we don't have any children\n      if (children.empty()) {\n        return;\n      }\n\n      // Since we can get extremely many children here and on some filesystems\n      // `IsDirectory` is expensive, we process the children in parallel.\n      // We also check that children match the pattern in parallel, for speedup.\n      // We store the status of the match and `IsDirectory` in\n      // `children_status` array, one element for each children.\n      std::vector<Status> children_status(children.size());\n      auto handle_children = [&fs, &match_pattern, &parent, &children,\n                              &children_status](int j) {\n        const std::string path = io::JoinPath(parent, children[j]);\n        if (!fs->Match(path, match_pattern)) {\n          children_status[j] =\n              Status(tensorflow::error::CANCELLED, \"Operation not needed\");\n        } else {\n          children_status[j] = fs->IsDirectory(path);\n        }\n      };\n      ForEach(0, children.size(), handle_children);\n\n      // At this point, pairing `children` with `children_status` will tell us\n      // if a children:\n      //   * does not match the pattern\n      //   * matches the pattern and is a directory\n      //   * matches the pattern and is not a directory\n      // We fully ignore the first case.\n      // If we matched the last pattern (`index == dirs.size() - 1`) then all\n      // remaining children get added to the result.\n      // Otherwise, only the directories get added to the next queue.\n      for (size_t j = 0; j < children.size(); j++) {\n        if (children_status[j].code() == tensorflow::error::CANCELLED) {\n          continue;\n        }\n\n        const std::string path = io::JoinPath(parent, children[j]);\n        if (index == dirs.size() - 1) {\n          mutex_lock l(result_mutex);\n          results->emplace_back(path);\n        } else if (children_status[j].ok()) {\n          mutex_lock l(queue_mutex);\n          next_expand_queue.emplace_back(path, index);\n        }\n      }\n    };\n    ForEach(0, expand_queue.size(), handle_level);\n\n    // After evaluating one level, swap the \"buffers\"\n    std::swap(expand_queue, next_expand_queue);\n  }\n\n  return Status::OK();\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tfor (;;) {\n\t\tstruct sem_array *sma;\n\t\tstruct sem_undo *un;\n\t\tstruct list_head tasks;\n\t\tint semid;\n\t\tint i;\n\n\t\trcu_read_lock();\n\t\tun = list_entry_rcu(ulp->list_proc.next,\n\t\t\t\t    struct sem_undo, list_proc);\n\t\tif (&un->list_proc == &ulp->list_proc)\n\t\t\tsemid = -1;\n\t\t else\n\t\t\tsemid = un->semid;\n\t\trcu_read_unlock();\n\n\t\tif (semid == -1)\n\t\t\tbreak;\n\n\t\tsma = sem_lock_check(tsk->nsproxy->ipc_ns, un->semid);\n\n\t\t/* exit_sem raced with IPC_RMID, nothing to do */\n\t\tif (IS_ERR(sma))\n\t\t\tcontinue;\n\n\t\tun = __lookup_undo(ulp, semid);\n\t\tif (un == NULL) {\n\t\t\t/* exit_sem raced with IPC_RMID+semget() that created\n\t\t\t * exactly the same semid. Nothing to do.\n\t\t\t */\n\t\t\tsem_unlock(sma);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* remove un from the linked lists */\n\t\tassert_spin_locked(&sma->sem_perm.lock);\n\t\t\t}\n\t\t}\n\t\t/* maybe some queued-up processes were waiting for this */\n\t\tINIT_LIST_HEAD(&tasks);\n\t\tdo_smart_update(sma, NULL, 0, 1, &tasks);\n\t\tsem_unlock(sma);\n\t\twake_up_sem_queue_do(&tasks);\n\n\t\tkfree_rcu(un, rcu);\n\t}\n\tkfree(ulp);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tfor (;;) {\n\t\tstruct sem_array *sma;\n\t\tstruct sem_undo *un;\n\t\tstruct list_head tasks;\n\t\tint semid, i;\n\n\t\trcu_read_lock();\n\t\tun = list_entry_rcu(ulp->list_proc.next,\n\t\t\t\t    struct sem_undo, list_proc);\n\t\tif (&un->list_proc == &ulp->list_proc)\n\t\t\tsemid = -1;\n\t\t else\n\t\t\tsemid = un->semid;\n\n\t\tif (semid == -1) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\n\t\tsma = sem_obtain_object_check(tsk->nsproxy->ipc_ns, un->semid);\n\t\t/* exit_sem raced with IPC_RMID, nothing to do */\n\t\tif (IS_ERR(sma)) {\n\t\t\trcu_read_unlock();\n\t\t\tcontinue;\n\t\t}\n\n\t\tsem_lock(sma, NULL, -1);\n\t\tun = __lookup_undo(ulp, semid);\n\t\tif (un == NULL) {\n\t\t\t/* exit_sem raced with IPC_RMID+semget() that created\n\t\t\t * exactly the same semid. Nothing to do.\n\t\t\t */\n\t\t\tsem_unlock(sma, -1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* remove un from the linked lists */\n\t\tassert_spin_locked(&sma->sem_perm.lock);\n\t\t\t}\n\t\t}\n\t\t/* maybe some queued-up processes were waiting for this */\n\t\tINIT_LIST_HEAD(&tasks);\n\t\tdo_smart_update(sma, NULL, 0, 1, &tasks);\n\t\tsem_unlock(sma, -1);\n\t\twake_up_sem_queue_do(&tasks);\n\n\t\tkfree_rcu(un, rcu);\n\t}\n\tkfree(ulp);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\n/* Eliminate warning about unused variable. */\nbox = 0;\nout = 0;\n\treturn -1;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int jp2_pclr_putdata(jp2_box_t *box, jas_stream_t *out)\n{\n#if 0\n\tjp2_pclr_t *pclr = &box->data.pclr;\n#endif\n\t/* Eliminate warning about unused variable. */\n\tbox = 0;\n\tout = 0;\n\treturn -1;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\terr = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,\n\t\t\t\t\t  nft_expr_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_EXPR_DATA])\n\t\treturn -EINVAL;\n\n\ttype = __nft_expr_type_get(ctx->family, tb[NFTA_EXPR_NAME]);\n\tif (!type)\n\t\treturn -ENOENT;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\terr = nla_parse_nested_deprecated(tb, NFTA_EXPR_MAX, nla,\n\t\t\t\t\t  nft_expr_policy, NULL);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!tb[NFTA_EXPR_DATA] || !tb[NFTA_EXPR_NAME])\n\t\treturn -EINVAL;\n\n\ttype = __nft_expr_type_get(ctx->family, tb[NFTA_EXPR_NAME]);\n\tif (!type)\n\t\treturn -ENOENT;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n    /* In the previous versions, MSBs of the seed affect   */\n    /* only MSBs of the array mt[].                        */\n    /* 2002/01/09 modified by Makoto Matsumoto             */\n    mt->mt_buffer_[i] =\n\t(1812433253UL * (mt->mt_buffer_[i-1] ^ \n\t\t\t (mt->mt_buffer_[i-1] >> 30)) + i);\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n    /* In the previous versions, MSBs of the seed affect   */\n    /* only MSBs of the array mt[].                        */\n    /* 2002/01/09 modified by Makoto Matsumoto             */\n    mt->mt_buffer_[i] =\n\t(1812433253UL * (mt->mt_buffer_[i-1] ^\n\t\t\t (mt->mt_buffer_[i-1] >> 30)) + i);\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  size_t l1, l2=0;\n  if ((l1 = php_strnlen(buffer+2, length-2)) > 0) {\n    exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Company\",\n                     TAG_NONE, TAG_FMT_STRING, l1, buffer+2);\n    if (length > 2+l1+1) {\n      l2 = php_strnlen(buffer+2+l1+1, length-2-l1+1);\n      exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Info\",\n                       TAG_NONE, TAG_FMT_STRING, l2, buffer+2+l1+1);\n    }\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  size_t l1, l2=0;\n  if ((l1 = php_strnlen(buffer+2, length-2)) > 0) {\n    exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Company\",\n                     TAG_NONE, TAG_FMT_STRING, l1, buffer+2);\n    if (length > 2+l1+1) {\n      l2 = php_strnlen(buffer+2+l1+1, length-2-l1-1);\n      exif_iif_add_tag(ImageInfo, SECTION_APP12, \"Info\",\n                       TAG_NONE, TAG_FMT_STRING, l2, buffer+2+l1+1);\n    }\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t * ipc_duration_ms test floods the DSP for the time specified\n\t * in the debugfs entry.\n\t */\n\tdentry = file->f_path.dentry;\n\tif (strcmp(dentry->d_name.name, \"ipc_flood_count\") &&\n\t    strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\"))\n\t\treturn -EINVAL;\n\n\tif (!strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\"))\n\t\tflood_duration_test = true;\n\n\t/* test completion criterion */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t * ipc_duration_ms test floods the DSP for the time specified\n\t * in the debugfs entry.\n\t */\n\tdentry = file->f_path.dentry;\n\tif (strcmp(dentry->d_name.name, \"ipc_flood_count\") &&\n\t    strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\")) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!strcmp(dentry->d_name.name, \"ipc_flood_duration_ms\"))\n\t\tflood_duration_test = true;\n\n\t/* test completion criterion */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    int errStatus = 0;\n    vector <uint8_t> encrPrivKey(BUF_LEN, 0);\n    vector<char> pubKeyX(BUF_LEN, 0);\n    vector<char> pubKeyY(BUF_LEN, 0);\n\n    uint32_t encLen = 0;\n    PRINT_SRC_LINE\n    auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), &encLen,\n                                             pubKeyX.data(),\n                                             pubKeyY.data());\n    REQUIRE(status == SGX_SUCCESS);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    int errStatus = 0;\n    vector <uint8_t> encrPrivKey(BUF_LEN, 0);\n    vector<char> pubKeyX(BUF_LEN, 0);\n    vector<char> pubKeyY(BUF_LEN, 0);\n\n    uint64_t encLen = 0;\n    PRINT_SRC_LINE\n    auto status = trustedGenerateEcdsaKeyAES(eid, &errStatus, errMsg.data(), encrPrivKey.data(), &encLen,\n                                             pubKeyX.data(),\n                                             pubKeyY.data());\n    REQUIRE(status == SGX_SUCCESS);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tstruct timespec ktspec;\n\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT,\n\t\t\t\t      (struct timespec *) timeout);\n\n\tif (timeout == NULL)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n\n\tif (get_compat_timespec(&ktspec, timeout))\n\t\treturn -EFAULT;\n\n\tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && put_compat_timespec(&ktspec, timeout))\n\t\tdatagrams = -EFAULT;\n\n\treturn datagrams;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tint datagrams;\n\tstruct timespec ktspec;\n\n\tif (flags & MSG_CMSG_COMPAT)\n\t\treturn -EINVAL;\n\n\tif (timeout == NULL)\n\t\treturn __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t      flags | MSG_CMSG_COMPAT, NULL);\n\n\tif (compat_get_timespec(&ktspec, timeout))\n\t\treturn -EFAULT;\n\n\tdatagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,\n\t\t\t\t   flags | MSG_CMSG_COMPAT, &ktspec);\n\tif (datagrams > 0 && compat_put_timespec(&ktspec, timeout))\n\t\tdatagrams = -EFAULT;\n\n\treturn datagrams;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int jas_iccgetuint32(jas_stream_t *in, jas_iccuint32_t *val)\n{\n\tulonglong tmp;\n\tif (jas_iccgetuint(in, 4, &tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int jas_iccgetuint32(jas_stream_t *in, jas_iccuint32_t *val)\n{\n\tjas_ulonglong tmp;\n\tif (jas_iccgetuint(in, 4, &tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    {\n      return ret;\n    }\n\n  /* First encode */\n  snprintf_func (ecmd, TESTBUFSIZE, \"%s %s -f %s %s %s %s %s %s %s\", \n\t    program_name, test_softcfg_str,\n\t    has_adler32 ? \"\" : \"-n \",\n\t    has_apphead ? \"-A=encode_apphead \" : \"-A= \",\n\t    has_secondary ? \"-S djw \" : \"-S none \",\n\t    has_source ? \"-s \" : \"\",\n\n  /* Now recode */\n  snprintf_func (recmd, TESTBUFSIZE,\n\t    \"%s recode %s -f %s %s %s %s %s\", program_name, test_softcfg_str,\n\t    recoded_adler32 ? \"\" : \"-n \",\n\t    !change_apphead ? \"\" : \n\t        (recoded_apphead ? \"-A=recode_apphead \" : \"-A= \"),\n\t    recoded_secondary ? \"-S djw \" : \"-S none \",\n\t    TEST_DELTA_FILE,\n\t    TEST_COPY_FILE);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    {\n      return ret;\n    }\n\n  /* First encode */\n  snprintf_func (ecmd, TESTBUFSIZE, \"%s %s -f %s %s %s %s %s %s %s\",\n\t    program_name, test_softcfg_str,\n\t    has_adler32 ? \"\" : \"-n \",\n\t    has_apphead ? \"-A=encode_apphead \" : \"-A= \",\n\t    has_secondary ? \"-S djw \" : \"-S none \",\n\t    has_source ? \"-s \" : \"\",\n\n  /* Now recode */\n  snprintf_func (recmd, TESTBUFSIZE,\n\t    \"%s recode %s -f %s %s %s %s %s\", program_name, test_softcfg_str,\n\t    recoded_adler32 ? \"\" : \"-n \",\n\t    !change_apphead ? \"\" :\n\t        (recoded_apphead ? \"-A=recode_apphead \" : \"-A= \"),\n\t    recoded_secondary ? \"-S djw \" : \"-S none \",\n\t    TEST_DELTA_FILE,\n\t    TEST_COPY_FILE);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tmd->from_user = 1;\n\t\telse\n\t\t\tmd->from_user = 0;\n\t}\n\n\tif (unlikely(iov_count > MAX_UIOVEC))\n\t\treturn -EINVAL;\n\n\tif (iov_count) {\n\t\tint size = sizeof(struct iovec) * iov_count;\n\t\tstruct iovec *iov;\n\t\tstruct iov_iter i;\n\n\t\tiov = memdup_user(hp->dxferp, size);\n\t\tif (IS_ERR(iov))\n\t\t\treturn PTR_ERR(iov);\n\n\t\tiov_iter_init(&i, rw, iov, iov_count,\n\t\t\t      min_t(size_t, hp->dxfer_len,\n\t\t\t\t    iov_length(iov, iov_count)));\n\n\t\tres = blk_rq_map_user_iov(q, rq, md, &i, GFP_ATOMIC);\n\t\tkfree(iov);\n\t} else\n\t\tres = blk_rq_map_user(q, rq, md, hp->dxferp,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tif (dxfer_dir == SG_DXFER_TO_FROM_DEV)\n\t\t\tmd->from_user = 1;\n\t\telse\n\t\t\tmd->from_user = 0;\n\t}\n\n\tif (iov_count) {\n\t\tstruct iovec *iov = NULL;\n\t\tstruct iov_iter i;\n\n\t\tres = import_iovec(rw, hp->dxferp, iov_count, 0, &iov, &i);\n\t\tif (res < 0)\n\t\t\treturn res;\n\n\t\tiov_iter_truncate(&i, hp->dxfer_len);\n\n\t\tres = blk_rq_map_user_iov(q, rq, md, &i, GFP_ATOMIC);\n\t\tkfree(iov);\n\t} else\n\t\tres = blk_rq_map_user(q, rq, md, hp->dxferp,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tstruct dccp_sock *dp = dccp_sk(sk);\n\t__be16 orig_sport, orig_dport;\n\t__be32 daddr, nexthop;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\tint err;\n\n\tdp->dccps_role = DCCP_ROLE_CLIENT;\n\n\tif (addr_len < sizeof(struct sockaddr_in))\n\t\treturn -EINVAL;\n\n\tif (usin->sin_family != AF_INET)\n\t\treturn -EAFNOSUPPORT;\n\n\tnexthop = daddr = usin->sin_addr.s_addr;\n\tif (inet->opt != NULL && inet->opt->srr) {\n\t\tif (daddr == 0)\n\t\t\treturn -EINVAL;\n\t\tnexthop = inet->opt->faddr;\n\t}\n\n\torig_sport = inet->inet_sport;\n\torig_dport = usin->sin_port;\n\trt = ip_route_connect(&fl4, nexthop, inet->inet_saddr,\n\tif (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {\n\t\tip_rt_put(rt);\n\t\treturn -ENETUNREACH;\n\t}\n\n\tif (inet->opt == NULL || !inet->opt->srr)\n\t\tdaddr = rt->rt_dst;\n\n\tif (inet->inet_saddr == 0)\n\t\tinet->inet_saddr = rt->rt_src;\n\tinet->inet_rcv_saddr = inet->inet_saddr;\n\n\tinet->inet_dport = usin->sin_port;\n\tinet->inet_daddr = daddr;\n\n\tinet_csk(sk)->icsk_ext_hdr_len = 0;\n\tif (inet->opt != NULL)\n\t\tinet_csk(sk)->icsk_ext_hdr_len = inet->opt->optlen;\n\t/*\n\t * Socket identity is still unknown (sport may be zero).\n\t * However we set state to DCCP_REQUESTING and not releasing socket\n\t * lock select source port, enter ourselves into the hash tables and\n\t * complete initialization after this.",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t__be16 orig_sport, orig_dport;\n\t__be32 daddr, nexthop;\n\tstruct flowi4 fl4;\n\tstruct rtable *rt;\n\tint err;\n\tstruct ip_options_rcu *inet_opt;\n\n\tdp->dccps_role = DCCP_ROLE_CLIENT;\n\n\tif (addr_len < sizeof(struct sockaddr_in))\n\t\treturn -EINVAL;\n\n\tif (usin->sin_family != AF_INET)\n\t\treturn -EAFNOSUPPORT;\n\n\tnexthop = daddr = usin->sin_addr.s_addr;\n\n\tinet_opt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t     sock_owned_by_user(sk));\n\tif (inet_opt != NULL && inet_opt->opt.srr) {\n\t\tif (daddr == 0)\n\t\t\treturn -EINVAL;\n\t\tnexthop = inet_opt->opt.faddr;\n\t}\n\n\torig_sport = inet->inet_sport;\n\torig_dport = usin->sin_port;\n\trt = ip_route_connect(&fl4, nexthop, inet->inet_saddr,\n\tif (rt->rt_flags & (RTCF_MULTICAST | RTCF_BROADCAST)) {\n\t\tip_rt_put(rt);\n\t\treturn -ENETUNREACH;\n\t}\n\n\tif (inet_opt == NULL || !inet_opt->opt.srr)\n\t\tdaddr = rt->rt_dst;\n\n\tif (inet->inet_saddr == 0)\n\t\tinet->inet_saddr = rt->rt_src;\n\tinet->inet_rcv_saddr = inet->inet_saddr;\n\n\tinet->inet_dport = usin->sin_port;\n\tinet->inet_daddr = daddr;\n\n\tinet_csk(sk)->icsk_ext_hdr_len = 0;\n\tif (inet_opt)\n\t\tinet_csk(sk)->icsk_ext_hdr_len = inet_opt->opt.optlen;\n\t/*\n\t * Socket identity is still unknown (sport may be zero).\n\t * However we set state to DCCP_REQUESTING and not releasing socket\n\t * lock select source port, enter ourselves into the hash tables and\n\t * complete initialization after this.",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void trustedEncryptKeyAES(int *errStatus, char *errString, const char *key,\n                          uint8_t *encryptedPrivateKey, uint32_t *enc_len) {\n    LOG_INFO(__FUNCTION__);\n\n    *errString = 0;\n    *errStatus = UNKNOWN_ERROR;\n\n    CHECK_STATE(key);\n    CHECK_STATE(encryptedPrivateKey);\n\n    *errStatus = UNKNOWN_ERROR;\n\n    int status = AES_encrypt_DH((char *)key, encryptedPrivateKey, BUF_LEN);\n\n    CHECK_STATUS2(\"AES encrypt failed with status %d\");\n\n    *enc_len = strlen(key) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n    SAFE_CHAR_BUF(decryptedKey, BUF_LEN);\n\n    status = AES_decrypt_DH(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);\n\n    CHECK_STATUS2(\"trustedDecryptKey failed with status %d\");\n\n    uint64_t decryptedKeyLen = strnlen(decryptedKey, MAX_KEY_LENGTH);\n\n    }\n\n    *errStatus = -8;\n\n    if (strncmp(key, decryptedKey, MAX_KEY_LENGTH) != 0) {\n        snprintf(errString, BUF_LEN, \"Decrypted key does not match original key\");\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    SET_SUCCESS",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void trustedEncryptKeyAES(int *errStatus, char *errString, const char *key,\n                          uint8_t *encryptedPrivateKey, uint64_t *enc_len) {\n    LOG_INFO(__FUNCTION__);\n\n    *errString = 0;\n    *errStatus = UNKNOWN_ERROR;\n\n    CHECK_STATE(key);\n    CHECK_STATE(encryptedPrivateKey);\n\n    *errStatus = UNKNOWN_ERROR;\n\n    int status = AES_encrypt((char *)key, encryptedPrivateKey, BUF_LEN,\n                             DKG, DECRYPTABLE, enc_len);\n\n    CHECK_STATUS2(\"AES encrypt failed with status %d\");\n\n    SAFE_CHAR_BUF(decryptedKey, BUF_LEN);\n\n    status = AES_decrypt(encryptedPrivateKey, *enc_len, decryptedKey, BUF_LEN);\n\n    CHECK_STATUS2(\"trustedDecryptKey failed with status %d\");\n\n    uint64_t decryptedKeyLen = strnlen(decryptedKey, MAX_KEY_LENGTH);\n\n\n    *errStatus = -8;\n\n    if (strncmp(key, decryptedKey, MAX_KEY_LENGTH) != 0) {\n        snprintf(errString, BUF_LEN, \"Decrypted key does not match original key\");\n        LOG_ERROR(key);\n        LOG_ERROR(decryptedKey);\n        LOG_ERROR(errString);\n        goto clean;\n    }\n\n    SET_SUCCESS",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "string sanitize_proprietary_tags(string input_string)\n{\n  unsigned int i;\n  size_t input_string_size;\n  bool strip = false;\n  bool tag_open = false;\n  int tag_open_idx = 0; //Are we within < > ?\n  bool closing_tag_open = false; //Are we within </ > ?\n  int orig_tag_open_idx = 0;\n    buffer[i] = 0;\n    tagname[i] = 0;\n    close_tagname[i] = 0;\n  }\n\n  input_string_size = input_string.size();\n\n  for (i = 0; i < input_string_size; i++)\n  {\n    if (input_string.c_str()[i] == '<')\n    {\n      tag_open = true;\n      tag_open_idx = i;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "string sanitize_proprietary_tags(string input_string)\n{\n  unsigned int i;\n  bool strip = false;\n  bool tag_open = false;\n  int tag_open_idx = 0; //Are we within < > ?\n  bool closing_tag_open = false; //Are we within </ > ?\n  int orig_tag_open_idx = 0;\n    buffer[i] = 0;\n    tagname[i] = 0;\n    close_tagname[i] = 0;\n  }\n\n  size_t input_string_size = input_string.size();\n\n  // Minimum workaround to prevent buffer overflow: Stop iterating\n  // once the (fixed!) size of the output buffers is reached. In\n  // response to\n  // https://www.talosintelligence.com/vulnerability_reports/TALOS-2017-0317\n  //\n  // However, this code is a huge mess anyway and is in no way\n  // anything like up-to-date C++ code. Please, anyone, replace it\n  // with something more modern. Thanks. - cstim, 2017-09-17.\n  for (i = 0; i < std::min(input_string_size, size_t(READ_BUFFER_SIZE)); i++)\n  {\n    if (input_string.c_str()[i] == '<')\n    {\n      tag_open = true;\n      tag_open_idx = i;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "       would leave the BOM in the buffer and return. On the next call to this\n       function, our XmlPrologTok call would return XML_TOK_INVALID, since it\n       is not valid to have multiple BOMs.\n    */\n    else if (tok == XML_TOK_BOM) {\n#  ifdef XML_DTD\n      if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                    XML_ACCOUNT_DIRECT)) {\n        accountingOnAbort(parser);\n        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "       would leave the BOM in the buffer and return. On the next call to this\n       function, our XmlPrologTok call would return XML_TOK_INVALID, since it\n       is not valid to have multiple BOMs.\n    */\n    else if (tok == XML_TOK_BOM) {\n#  if defined(XML_DTD) || XML_GE == 1\n      if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                    XML_ACCOUNT_DIRECT)) {\n        accountingOnAbort(parser);\n        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tproglen += 64;\n\t\taddrs[i] = proglen;\n\t}\n\tctx.cleanup_addr = proglen;\n\n\tfor (pass = 0; pass < 10; pass++) {\n\t\tproglen = do_jit(prog, addrs, image, oldproglen, &ctx);\n\t\tif (proglen <= 0) {\n\t\t\timage = NULL;\n\t\t\tif (header)\n\t\t\t\tbpf_jit_binary_free(header);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tproglen += 64;\n\t\taddrs[i] = proglen;\n\t}\n\tctx.cleanup_addr = proglen;\n\n\t/* JITed image shrinks with every pass and the loop iterates\n\t * until the image stops shrinking. Very large bpf programs\n\t * may converge on the last pass. In such case do one more\n\t * pass to emit the final image\n\t */\n\tfor (pass = 0; pass < 10 || image; pass++) {\n\t\tproglen = do_jit(prog, addrs, image, oldproglen, &ctx);\n\t\tif (proglen <= 0) {\n\t\t\timage = NULL;\n\t\t\tif (header)\n\t\t\t\tbpf_jit_binary_free(header);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int mi_repair_parallel(MI_CHECK *param, register MI_INFO *info,\n\t\t\tconst char * name, int rep_quick)\n{\n  int got_error;\n  uint i,key, total_key_length, istep;\n  ulong rec_length;\n  ha_rows start_records;\n    (void) end_io_cache(&new_data_cache);\n  if (!got_error)\n  {\n    /* Replace the actual file with the temporary file */\n    if (new_file >= 0)\n    {\n      mysql_file_close(new_file, MYF(0));\n      info->dfile=new_file= -1;\n      if (change_to_newfile(share->data_file_name, MI_NAME_DEXT, DATA_TMP_EXT,\n\t\t\t    (param->testflag & T_BACKUP_DATA ?\n\t\t\t     MYF(MY_REDEL_MAKE_BACKUP): MYF(0))) ||\n\t  mi_open_datafile(info,share,name,-1))\n\tgot_error=1;\n    }\n  }\n  if (got_error)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int mi_repair_parallel(MI_CHECK *param, register MI_INFO *info,\n                       const char * name, int rep_quick, my_bool no_copy_stat)\n{\n  int got_error;\n  uint i,key, total_key_length, istep;\n  ulong rec_length;\n  ha_rows start_records;\n  if (!got_error)\n  {\n    /* Replace the actual file with the temporary file */\n    if (new_file >= 0)\n    {\n      myf flags= 0;\n      if (param->testflag & T_BACKUP_DATA)\n        flags |= MY_REDEL_MAKE_BACKUP;\n      if (no_copy_stat)\n        flags |= MY_REDEL_NO_COPY_STAT;\n      mysql_file_close(new_file, MYF(0));\n      info->dfile=new_file= -1;\n      if (change_to_newfile(share->data_file_name, MI_NAME_DEXT, DATA_TMP_EXT,\n\t\t\t    flags) ||\n\t  mi_open_datafile(info,share,name,-1))\n\tgot_error=1;\n    }\n  }\n  if (got_error)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrncpy(extra_response->key, key, strlen(key) + 1);\n\tstrncpy(extra_response->value, NOTUNDERSTOOD,\n\t\t\tstrlen(NOTUNDERSTOOD) + 1);\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\" struct iscsi_extra_response.\\n\");\n\t\treturn -1;\n\t}\n\tINIT_LIST_HEAD(&extra_response->er_list);\n\n\tstrlcpy(extra_response->key, key, sizeof(extra_response->key));\n\tstrlcpy(extra_response->value, NOTUNDERSTOOD,\n\t\tsizeof(extra_response->value));\n\n\tlist_add_tail(&extra_response->er_list,\n\t\t\t&param_list->extra_response_list);\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, const bn_t d) {\n\tint i, l, n0, n1, l0, l1;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;\n\tfp24_t r, t0[1 << (EP_WIDTH - 2)];\n\tfp24_t s, t1[1 << (EP_WIDTH - 2)];\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp24_exp_cyc(e, c, d);\n\t}\n\n\tfp24_null(s);\n\n\tRLC_TRY {\n\t\tfp24_new(r);\n\t\tfp24_new(s);\n\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n\t\t\tfp24_null(t0[i]);\n\t\t\tfp24_null(t1[i]);\n\t\t\tfp24_new(t0[i]);\n\t\t\tfp24_new(t1[i]);\n\t\t}\n\t\tbn_rec_naf(naf0, &l0, b, FP_WIDTH);\n\t\tbn_rec_naf(naf1, &l1, d, FP_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfor (i = 0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(d) == RLC_NEG) {\n\t\t\tfor (i = 0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\n\t\t_k = naf0 + l - 1;\n\t\t_m = naf1 + l - 1;\n\n\t\tfp24_set_dig(r, 1);\n\t\tfor (i = l - 1; i >= 0; i--, _k--, _m--) {\n\t\t\tfp24_sqr(r, r);\n\n\t\t\tn0 = *_k;\n\t\t\tn1 = *_m;\n\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp24_free(r);\n\t\tfp24_free(s);\n\t\tfor (i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp24_free(t0[i]);\n\t\t\tfp24_free(t1[i]);\n\t\t}\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void fp24_exp_cyc_sim(fp24_t e, const fp24_t a, const bn_t b, const fp24_t c, const bn_t d) {\n\tint n0, n1;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;\n\tfp24_t r, t0[1 << (EP_WIDTH - 2)];\n\tfp24_t s, t1[1 << (EP_WIDTH - 2)];\n\tsize_t l, l0, l1;\n\n\tif (bn_is_zero(b)) {\n\t\treturn fp24_exp_cyc(e, c, d);\n\t}\n\n\tfp24_null(s);\n\n\tRLC_TRY {\n\t\tfp24_new(r);\n\t\tfp24_new(s);\n\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i ++) {\n\t\t\tfp24_null(t0[i]);\n\t\t\tfp24_null(t1[i]);\n\t\t\tfp24_new(t0[i]);\n\t\t\tfp24_new(t1[i]);\n\t\t}\n\t\tbn_rec_naf(naf0, &l0, b, FP_WIDTH);\n\t\tbn_rec_naf(naf1, &l1, d, FP_WIDTH);\n\n\t\tl = RLC_MAX(l0, l1);\n\t\tif (bn_sign(b) == RLC_NEG) {\n\t\t\tfor (size_t i = 0; i < l0; i++) {\n\t\t\t\tnaf0[i] = -naf0[i];\n\t\t\t}\n\t\t}\n\t\tif (bn_sign(d) == RLC_NEG) {\n\t\t\tfor (size_t i = 0; i < l1; i++) {\n\t\t\t\tnaf1[i] = -naf1[i];\n\t\t\t}\n\t\t}\n\n\t\t_k = naf0 + l - 1;\n\t\t_m = naf1 + l - 1;\n\n\t\tfp24_set_dig(r, 1);\n\t\tfor (int i = l - 1; i >= 0; i--, _k--, _m--) {\n\t\t\tfp24_sqr(r, r);\n\n\t\t\tn0 = *_k;\n\t\t\tn1 = *_m;\n\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfp24_free(r);\n\t\tfp24_free(s);\n\t\tfor (int i = 0; i < (1 << (FP_WIDTH - 2)); i++) {\n\t\t\tfp24_free(t0[i]);\n\t\t\tfp24_free(t1[i]);\n\t\t}\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  /* access to vararg values? */\n      return findvararg(ci, -n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "const char *luaG_findlocal (lua_State *L, CallInfo *ci, int n, StkId *pos) {\n  StkId base = ci->func + 1;\n  const char *name = NULL;\n  if (isLua(ci)) {\n    if (n < 0)  /* access to vararg values? */\n      return findvararg(ci, n, pos);\n    else\n      name = luaF_getlocalname(ci_func(ci)->p, n, currentpc(ci));\n  }\n  if (name == NULL) {  /* no 'standard' name? */\n    StkId limit = (ci == L->ci) ? L->top : ci->next->func;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\toffset = 0;\n\t\t\t++from;\n\t\t\tcontinue;\n\t\t}\n\t\tbase = (unsigned long)from->iov_base + offset;\n\t\tsize = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;\n\t\tnum_pages = get_user_pages_fast(base, size, 0, &page[i]);\n\t\tif ((num_pages != size) ||\n\t\t    (num_pages > MAX_SKB_FRAGS - skb_shinfo(skb)->nr_frags)) {\n\t\t\tfor (i = 0; i < num_pages; i++)\n\t\t\t\tput_page(page[i]);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\ttruesize = size * PAGE_SIZE;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t++from;\n\t\t\tcontinue;\n\t\t}\n\t\tbase = (unsigned long)from->iov_base + offset;\n\t\tsize = ((base & ~PAGE_MASK) + len + ~PAGE_MASK) >> PAGE_SHIFT;\n\t\tif (i + size > MAX_SKB_FRAGS)\n\t\t\treturn -EMSGSIZE;\n\t\tnum_pages = get_user_pages_fast(base, size, 0, &page[i]);\n\t\tif (num_pages != size) {\n\t\t\tfor (i = 0; i < num_pages; i++)\n\t\t\t\tput_page(page[i]);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\ttruesize = size * PAGE_SIZE;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    \n    int i, n = 0, len = Jsi_ObjGetLength(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = Jsi_ObjGetLength(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static Jsi_RC jsi_ArrayFlatSub(Jsi_Interp *interp, Jsi_Obj* nobj, Jsi_Value *arr, int depth) {\n    \n    int i, n = 0, len = jsi_SizeOfArray(interp, arr->d.obj);\n    if (len <= 0) return JSI_OK;\n    Jsi_RC rc = JSI_OK;\n    int clen = jsi_SizeOfArray(interp, nobj);\n    for (i = 0; i < len && rc == JSI_OK; i++) {\n        Jsi_Value *t = Jsi_ValueArrayIndex(interp, arr, i);\n        if (t && depth>0 && Jsi_ValueIsArray(interp, t))\n            rc = jsi_ArrayFlatSub(interp, nobj, t , depth-1);\n        else if (!Jsi_ValueIsUndef(interp, t))",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        {\n            SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n            return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        ret = x509parse_crt( ssl->session_negotiate->peer_cert, ssl->in_msg + i,\n                             n );\n        if( ret != 0 )\n        {\n            SSL_DEBUG_RET( 1, \" x509parse_crt\", ret );\n            return( ret );\n        }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        {\n            SSL_DEBUG_MSG( 1, ( \"bad certificate message\" ) );\n            return( POLARSSL_ERR_SSL_BAD_HS_CERTIFICATE );\n        }\n\n        ret = x509parse_crt_der( ssl->session_negotiate->peer_cert,\n                                 ssl->in_msg + i, n );\n        if( ret != 0 )\n        {\n            SSL_DEBUG_RET( 1, \" x509parse_crt\", ret );\n            return( ret );\n        }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "bool ActiveStreamDecoderFilter::complete() { return parent_.state_.remote_complete_; }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "bool ActiveStreamDecoderFilter::complete() { return parent_.state_.remote_decode_complete_; }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t}\n#elif defined(__APPLE__)\n\td = M_fs_path_mac_tmpdir();\n#else\n\tconst char *const_temp;\n\t/* Try Unix env var. */\n#  ifdef HAVE_SECURE_GETENV\n\tconst_temp = secure_getenv(\"TMPDIR\");\n#  else\n\tconst_temp = getenv(\"TMPDIR\");\n#  endif",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t}\n#elif defined(__APPLE__)\n\td = M_fs_path_mac_tmpdir();\n#else\n\tconst char *const_temp;\n\t/* Unix doens't have a fancy function to get the standard\n\t * temporary directory an application can use. Instead there\n\t * is a convoluted set of possible paths that could be used.\n\t *\n\t * We're going to go though each one in a priority order and\n\t * verify if we can read and write the directory. If so then\n\t * that's the one that will be used. We are fine using access\n\t * here because it doesn't matter if the path ends up being\n\t * changed out from underneath us later on. When it's used\n\t * at that time it will fail. Right now we just want to get\n\t * a path that can be tried. */\n\n\t/* Try Unix env vars.\n\t *\n\t * This is not ideal but a valid way to set the temporary directory\n\t * for a user. Per Single Unix Specification 4 and probably other things.\n\t */\n#  ifdef HAVE_SECURE_GETENV\n\tconst_temp = secure_getenv(\"TMPDIR\");\n#  else\n\tconst_temp = getenv(\"TMPDIR\");\n#  endif",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, int open_flags)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *deleg_cur;\n\tint ret = 0;\n\n\topen_flags &= (FMODE_READ|FMODE_WRITE);\n\n\trcu_read_lock();\n\tdeleg_cur = rcu_dereference(nfsi->delegation);\n\tif (deleg_cur == NULL)\n\t\tgoto no_delegation;\n\n\tspin_lock(&deleg_cur->lock);\n\tif (nfsi->delegation != deleg_cur ||\n\t    (deleg_cur->type & open_flags) != open_flags)\n\t\tgoto no_delegation_unlock;\n\n\tif (delegation == NULL)\n\t\tdelegation = &deleg_cur->stateid;\n\telse if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)\n\t\tgoto no_delegation_unlock;\n\n\tnfs_mark_delegation_referenced(deleg_cur);\n\t__update_open_stateid(state, open_stateid, &deleg_cur->stateid, open_flags);\n\tret = 1;\nno_delegation_unlock:\n\tspin_unlock(&deleg_cur->lock);\nno_delegation:\n\trcu_read_unlock();\n\n\tif (!ret && open_stateid != NULL) {\n\t\t__update_open_stateid(state, open_stateid, NULL, open_flags);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, fmode_t fmode)\n{\n\tstruct nfs_inode *nfsi = NFS_I(state->inode);\n\tstruct nfs_delegation *deleg_cur;\n\tint ret = 0;\n\n\tfmode &= (FMODE_READ|FMODE_WRITE);\n\n\trcu_read_lock();\n\tdeleg_cur = rcu_dereference(nfsi->delegation);\n\tif (deleg_cur == NULL)\n\t\tgoto no_delegation;\n\n\tspin_lock(&deleg_cur->lock);\n\tif (nfsi->delegation != deleg_cur ||\n\t    (deleg_cur->type & fmode) != fmode)\n\t\tgoto no_delegation_unlock;\n\n\tif (delegation == NULL)\n\t\tdelegation = &deleg_cur->stateid;\n\telse if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)\n\t\tgoto no_delegation_unlock;\n\n\tnfs_mark_delegation_referenced(deleg_cur);\n\t__update_open_stateid(state, open_stateid, &deleg_cur->stateid, fmode);\n\tret = 1;\nno_delegation_unlock:\n\tspin_unlock(&deleg_cur->lock);\nno_delegation:\n\trcu_read_unlock();\n\n\tif (!ret && open_stateid != NULL) {\n\t\t__update_open_stateid(state, open_stateid, NULL, fmode);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      timer.reset(new GpuTimer(parent_));  // NOLINT\n      // The start and stop of the timer should be as close to the Cudnn call as\n      // possible. It is still possible for other threads to issue workload on\n      // to this stream. So it could take multiple profiling measurements.\n      if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n        return tsl::Status(port::error::INTERNAL, \"Failed to start timer\");\n      }\n    }\n\n    cudnnStatus_t status = cudnnBackendExecute(\n        cudnn.handle(), plan_.get_raw_desc(), variantPack.get_raw_desc());\n    RETURN_IF_CUDNN_ERROR(status);\n\n    if (is_profiling) {\n      if (!timer->Stop(AsGpuStream(stream))) {\n        return tsl::Status(port::error::INTERNAL, \"Failed to stop timer\");\n      }\n      TF_ASSIGN_OR_RETURN(auto desc, ToAlgorithmDesc());\n      profile_result->set_algorithm(desc);\n      profile_result->set_elapsed_time_in_ms(timer->GetElapsedMilliseconds());\n      profile_result->set_scratch_size(scratch_memory.size());",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      timer.reset(new GpuTimer(parent_));  // NOLINT\n      // The start and stop of the timer should be as close to the Cudnn call as\n      // possible. It is still possible for other threads to issue workload on\n      // to this stream. So it could take multiple profiling measurements.\n      if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n        return tsl::Status(tsl::error::INTERNAL, \"Failed to start timer\");\n      }\n    }\n\n    cudnnStatus_t status = cudnnBackendExecute(\n        cudnn.handle(), plan_.get_raw_desc(), variantPack.get_raw_desc());\n    RETURN_IF_CUDNN_ERROR(status);\n\n    if (is_profiling) {\n      if (!timer->Stop(AsGpuStream(stream))) {\n        return tsl::Status(tsl::error::INTERNAL, \"Failed to stop timer\");\n      }\n      TF_ASSIGN_OR_RETURN(auto desc, ToAlgorithmDesc());\n      profile_result->set_algorithm(desc);\n      profile_result->set_elapsed_time_in_ms(timer->GetElapsedMilliseconds());\n      profile_result->set_scratch_size(scratch_memory.size());",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      void Init(void)\n      {\n        for(int i = 0;i < 18;i++) {\n          X[i].Init();\n          M[i].Init();\n        }\n      }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      void Init(void)\n      {\n        for(int i = 0;i < MagnitudeContexts;i++) {\n          X[i].Init();\n          M[i].Init();\n        }\n      }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    return accessor->getter.get(runtime)->executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    SymbolID id{};\n    LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n    auto propRes = vmcast<HostObject>(selfHandle.get())->get(id);\n    if (propRes == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return createPseudoHandle(*propRes);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    return accessor->getter.get(runtime)->executeCall0(\n        runtime->makeHandle(accessor->getter), runtime, receiver);\n  } else if (desc.flags.hostObject) {\n    SymbolID id{};\n    LAZY_TO_IDENTIFIER(runtime, nameValPrimitiveHandle, id);\n    auto propRes = vmcast<HostObject>(propObj.get())->get(id);\n    if (propRes == ExecutionStatus::EXCEPTION)\n      return ExecutionStatus::EXCEPTION;\n    return createPseudoHandle(*propRes);\n  } else {\n    assert(desc.flags.proxyObject && \"descriptor flags are impossible\");",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                tls_io_instance->certificate = NULL;\n            }\n\n            // Store the certificate\n            len = strlen(cert);\n            tls_io_instance->certificate = malloc(len + 1);\n            if (tls_io_instance->certificate == NULL)\n            {\n                result = MU_FAILURE;\n            }\n            else\n            {\n                strcpy(tls_io_instance->certificate, cert);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                tls_io_instance->certificate = NULL;\n            }\n\n            // Store the certificate\n            len = strlen(cert);\n            size_t malloc_size = safe_add_size_t(len, 1);\n            if (malloc_size == SIZE_MAX ||\n                (tls_io_instance->certificate = malloc(malloc_size)) == NULL)\n            {\n                LogError(\"malloc failure, size:%zu\", malloc_size);\n                result = MU_FAILURE;\n            }\n            else\n            {\n                strcpy(tls_io_instance->certificate, cert);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n  const char *header;\n  uint length, counter = 0;\n  ulong rowcount = 0L;\n  char tables[NAME_LEN+1], rows[NAME_LEN+1];\n  char query[255];\n  MYSQL_FIELD *field;\n  MYSQL_RES *result;\n  MYSQL_ROW row= NULL, rrow;\n\n  if (!(result=mysql_list_dbs(mysql,wild)))\n\t  {\n            /* Print the count of tables and rows for each database */\n            MYSQL_ROW trow;\n\t    while ((trow = mysql_fetch_row(tresult)))\n\t    {\n\t      sprintf(query,\"SELECT COUNT(*) FROM `%s`\",trow[0]);\n\t      if (!(mysql_query(mysql,query)))\n\t      {\n\t\tMYSQL_RES *rresult;\n\t\tif ((rresult = mysql_store_result(mysql)))\n\t\t{",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n  const char *header;\n  uint length, counter = 0;\n  ulong rowcount = 0L;\n  char tables[NAME_LEN+1], rows[NAME_LEN+1];\n  char query[NAME_LEN + 100];\n  MYSQL_FIELD *field;\n  MYSQL_RES *result;\n  MYSQL_ROW row= NULL, rrow;\n\n  if (!(result=mysql_list_dbs(mysql,wild)))\n\t  {\n            /* Print the count of tables and rows for each database */\n            MYSQL_ROW trow;\n\t    while ((trow = mysql_fetch_row(tresult)))\n\t    {\n              my_snprintf(query, sizeof(query),\n                          \"SELECT COUNT(*) FROM `%s`\", trow[0]);\n\t      if (!(mysql_query(mysql,query)))\n\t      {\n\t\tMYSQL_RES *rresult;\n\t\tif ((rresult = mysql_store_result(mysql)))\n\t\t{",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tsize_t         wrote_len;\n\tsize_t         wrote_total  = 0;\n\tsize_t         offset;\n\tM_fs_error_t   res;\n\n\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n \t * to new file. */\n\tif (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n\t\t/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without\n \t\t * any permissions and to ensure that anything that has the file already open won't be able to read the new\n\t\t * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition\n\t\t * between deleting and creating the file where someone could create the file and have access. However,\n\t\t * depending on the OS they may have access even if the file is created with no perms... */\n\t\tres = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\treturn res;\n\t\t}\n\t}\n\t/* Open the old file */\n\tres = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\treturn res;\n\t}\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tM_fs_file_close(fd_old);\n\t\t\treturn res;\n\t\t}\n\t\tperms = M_fs_info_get_perms(info);\n\t}\n\tres = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);\n\tM_fs_info_destroy(info);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_fs_file_close(fd_old);\n\t\treturn res;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tsize_t         read_len;\n\tsize_t         wrote_len;\n\tsize_t         wrote_total  = 0;\n\tsize_t         offset;\n\tM_fs_error_t   res;\n\n\t/* Open the old file */\n\tres = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\treturn res;\n\t}\n\t\t\tM_fs_file_close(fd_old);\n\t\t\treturn res;\n\t\t}\n\t\tperms = M_fs_info_get_perms(info);\n\t}\n\n\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n\t * to new file. */\n\tres = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);\n\tM_fs_info_destroy(info);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_fs_file_close(fd_old);\n\t\treturn res;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tint j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tmemcpy(file->name, d, len);\n\t\t\tfile->namelen = len;\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tsize_t j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tfile->namelen = MIN(sizeof file->name, len);\n\t\t\tmemcpy(file->name, d, file->namelen);\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        Mipmapcount includes the main image, so start from one\n      */\n      for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) w * h * pixel_size;\n        (void) SeekBlob(image, offset, SEEK_CUR);\n        \n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        Mipmapcount includes the main image, so start from one\n      */\n      for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)\n      {\n        offset = (MagickOffsetType) w * h * pixel_size;\n        if (SeekBlob(image, offset, SEEK_CUR) < 0)\n          break;\n        w = DIV2(w);\n        h = DIV2(h);\n      }\n    }\n  return(MagickTrue);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tthrottle_event.header.type = PERF_RECORD_UNTHROTTLE;\n\n\tperf_event_header__init_id(&throttle_event.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tthrottle_event.header.size, 1, 0);\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, throttle_event);\n\tperf_event__output_id_sample(event, &handle, &sample);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tthrottle_event.header.type = PERF_RECORD_UNTHROTTLE;\n\n\tperf_event_header__init_id(&throttle_event.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tthrottle_event.header.size, 0);\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, throttle_event);\n\tperf_event__output_id_sample(event, &handle, &sample);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "            {\n                session->sessionKey.t.size = 0;\n            }\n            else\n            {\n                rval = tpm_kdfa(sapi_context, session->authHash, &(key.b), label, &( session->nonceNewer.b ),\n                        &( session->nonceOlder.b ), bytes * 8, (TPM2B_MAX_BUFFER *)&( session->sessionKey ) );\n            }\n\n            if( rval != TPM_RC_SUCCESS )\n            {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "            {\n                session->sessionKey.t.size = 0;\n            }\n            else\n            {\n                rval = tpm_kdfa(session->authHash, &(key.b), label, &( session->nonceNewer.b ),\n                        &( session->nonceOlder.b ), bytes * 8, (TPM2B_MAX_BUFFER *)&( session->sessionKey ) );\n            }\n\n            if( rval != TPM_RC_SUCCESS )\n            {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tvoid *vapic;\n\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\n\tvapic = kmap_atomic(vcpu->arch.apic->vapic_page);\n\t*(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr)) = data;\n\tkunmap_atomic(vapic);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\tsizeof(u32));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\t/* Throw away the key data */\n\t\tif (key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tsecurity_key_free(key);\n\n\t\t/* deal with the user's key tracking and quota */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tlist_del(&key->graveyard_link);\n\n\t\tkdebug(\"- %u\", key->serial);\n\t\tkey_check(key);\n\n\t\t/* Throw away the key data if the key is instantiated */\n\t\tif (test_bit(KEY_FLAG_INSTANTIATED, &key->flags) &&\n\t\t    !test_bit(KEY_FLAG_NEGATIVE, &key->flags) &&\n\t\t    key->type->destroy)\n\t\t\tkey->type->destroy(key);\n\n\t\tsecurity_key_free(key);\n\n\t\t/* deal with the user's key tracking and quota */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tvirtual ~CxFile() { };",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tvirtual ~CxFile() { }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      goto zipfile_step_out;\n    }\n  }else{\n    if( zName[nName-1]!='/' ){\n      zName = zFree = sqlite3_mprintf(\"%s/\", zName);\n      nName++;\n      if( zName==0 ){\n        rc = SQLITE_NOMEM;\n        goto zipfile_step_out;\n      }\n    }else{\n      while( nName>1 && zName[nName-2]=='/' ) nName--;\n    }\n  }\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      rc = SQLITE_ERROR;\n      goto zipfile_step_out;\n    }\n  }else{\n    if( zName[nName-1]!='/' ){\n      zName = zFree = sqlite3_mprintf(\"%s/\", zName);\n      if( zName==0 ){\n        rc = SQLITE_NOMEM;\n        goto zipfile_step_out;\n      }\n      nName = (int)strlen(zName);\n    }else{\n      while( nName>1 && zName[nName-2]=='/' ) nName--;\n    }\n  }\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "write_link_file(const NetplanNetDefinition* def, const char* rootdir, const char* path)\n{\n    GString* s = NULL;\n    mode_t orig_umask;\n\n    /* Don't write .link files for virtual devices; they use .netdev instead.\n     * Don't write .link files for MODEM devices, as they aren't supported by networkd.\n     */\n    if (def->type >= NETPLAN_DEF_TYPE_VIRTUAL || def->type == NETPLAN_DEF_TYPE_MODEM)\n\n    if (def->large_receive_offload != NETPLAN_TRISTATE_UNSET)\n        g_string_append_printf(s, \"LargeReceiveOffload=%s\\n\",\n        (def->large_receive_offload ? \"true\" : \"false\"));\n\n    orig_umask = umask(022);\n    _netplan_g_string_free_to_file(s, rootdir, path, \".link\");\n    umask(orig_umask);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "write_link_file(const NetplanNetDefinition* def, const char* rootdir, const char* path)\n{\n    GString* s = NULL;\n\n    /* Don't write .link files for virtual devices; they use .netdev instead.\n     * Don't write .link files for MODEM devices, as they aren't supported by networkd.\n     */\n    if (def->type >= NETPLAN_DEF_TYPE_VIRTUAL || def->type == NETPLAN_DEF_TYPE_MODEM)\n\n    if (def->large_receive_offload != NETPLAN_TRISTATE_UNSET)\n        g_string_append_printf(s, \"LargeReceiveOffload=%s\\n\",\n        (def->large_receive_offload ? \"true\" : \"false\"));\n\n    _netplan_g_string_free_to_file_with_permissions(s, rootdir, path, \".link\", \"root\", \"root\", 0640);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t       volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINSDP;\n\n    /* check equal sign */\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* x= */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t       volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINSDP;\n\n    /* check equal sign */\n    if ((scanner->curptr+1 >= scanner->end) || *(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* x= */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tfname = read_filename();\n\t\tif (fname == NULL) {\n\t\t\tfd_printf(STO, \"*** cannot read filename ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\trun_cmd(tty_fd, xfr_cmd, fname, NULL);\n\t\tfree(fname);\n\t\tbreak;\n\tcase KEY_BREAK:\n\t\tterm_break(tty_fd);\n\t\tfd_printf(STO, \"\\r\\n*** break sent ***\\r\\n\");",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tfname = read_filename();\n\t\tif (fname == NULL) {\n\t\t\tfd_printf(STO, \"*** cannot read filename ***\\r\\n\");\n\t\t\tbreak;\n\t\t}\n\t\trun_cmd(tty_fd, xfr_cmd, fname);\n\t\tfree(fname);\n\t\tbreak;\n\tcase KEY_BREAK:\n\t\tterm_break(tty_fd);\n\t\tfd_printf(STO, \"\\r\\n*** break sent ***\\r\\n\");",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask) {\n\t\t\tunsigned long mask = PSW_MASK_USER;\n\n\t\t\tmask |= is_ri_task(child) ? PSW_MASK_RI : 0;\n\t\t\tif ((data & ~mask) != PSW_USER_BITS)\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW_MASK_EA) && !(data & PSW_MASK_BA))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t */\n\t\tif (addr == (addr_t) &dummy->regs.psw.mask) {\n\t\t\tunsigned long mask = PSW_MASK_USER;\n\n\t\t\tmask |= is_ri_task(child) ? PSW_MASK_RI : 0;\n\t\t\tif ((data ^ PSW_USER_BITS) & ~mask)\n\t\t\t\t/* Invalid psw mask. */\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW_MASK_ASC) == PSW_ASC_HOME)\n\t\t\t\t/* Invalid address-space-control bits */\n\t\t\t\treturn -EINVAL;\n\t\t\tif ((data & PSW_MASK_EA) && !(data & PSW_MASK_BA))\n\t\t\t\t/* Invalid addressing mode bits */\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t\t*(addr_t *)((addr_t) &task_pt_regs(child)->psw + addr) = data;\n\n\t} else if (addr < (addr_t) (&dummy->regs.orig_gpr2)) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n    if (src_end - src < 2)\n        return 0;\n    zsize = (src[0] << 8) | src[1]; src += 2;\n\n    if (src_end - src < zsize)\n        return AVERROR_INVALIDDATA;\n\n    ret = uncompress(c->kempf_buf, &dlen, src, zsize);\n    if (ret)\n        return AVERROR_INVALIDDATA;\n    bstride = FFALIGN(width, 16) >> 4;\n    // blocks are coded LSB and we need normal bitreader for JPEG data\n    bits = 0;\n    for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {\n        for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {\n            if (!bits) {\n                bitbuf = *src++;\n                bits   = 8;\n            }\n            coded = bitbuf & 1;\n            bits--;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n    if (src_end - src < 2)\n        return 0;\n    zsize = (src[0] << 8) | src[1]; src += 2;\n\n    if (src_end - src < zsize + (sub_type != 2))\n        return AVERROR_INVALIDDATA;\n\n    ret = uncompress(c->kempf_buf, &dlen, src, zsize);\n    if (ret)\n        return AVERROR_INVALIDDATA;\n    // blocks are coded LSB and we need normal bitreader for JPEG data\n    bits = 0;\n    for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {\n        for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {\n            if (!bits) {\n                if (src >= src_end)\n                    return AVERROR_INVALIDDATA;\n                bitbuf = *src++;\n                bits   = 8;\n            }\n            coded = bitbuf & 1;\n            bits--;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    int *err, gchar **err_info)\n{\n\tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n\tchar\tline[TOSHIBA_LINE_LENGTH];\n\tint\tnum_items_scanned;\n\tint\tpkt_len, pktnum, hr, min, sec, csec;\n\tchar\tchannel[10], direction[10];\n\tint\ti, hex_lines;\n\tguint8\t*pd;\n\n\t/* Our file pointer should be on the line containing the\n\t\t/* Check for \"OFFSET 0001-0203\" at beginning of line */\n\t\tline[16] = '\\0';\n\n\t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n\n\tnum_items_scanned = sscanf(line+64, \"LEN=%9d\", &pkt_len);\n\tif (num_items_scanned != 1) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n\t\treturn FALSE;\n\t}\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\t\t\tpseudo_header->eth.fcs_len = -1;\n\t\t\tbreak;\n\t}\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, TOSHIBA_MAX_PACKET_LEN);\n\tpd = ws_buffer_start_ptr(buf);\n\n\t/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data */\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    int *err, gchar **err_info)\n{\n\tunion wtap_pseudo_header *pseudo_header = &phdr->pseudo_header;\n\tchar\tline[TOSHIBA_LINE_LENGTH];\n\tint\tnum_items_scanned;\n\tguint\tpkt_len;\n\tint\tpktnum, hr, min, sec, csec;\n\tchar\tchannel[10], direction[10];\n\tint\ti, hex_lines;\n\tguint8\t*pd;\n\n\t/* Our file pointer should be on the line containing the\n\t\t/* Check for \"OFFSET 0001-0203\" at beginning of line */\n\t\tline[16] = '\\0';\n\n\t} while (strcmp(line, \"OFFSET 0001-0203\") != 0);\n\n\tnum_items_scanned = sscanf(line+64, \"LEN=%9u\", &pkt_len);\n\tif (num_items_scanned != 1) {\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup(\"toshiba: OFFSET line doesn't have valid LEN item\");\n\t\treturn FALSE;\n\t}\n\tif (pkt_len > WTAP_MAX_PACKET_SIZE) {\n\t\t/*\n\t\t * Probably a corrupt capture file; don't blow up trying\n\t\t * to allocate space for an immensely-large packet.\n\t\t */\n\t\t*err = WTAP_ERR_BAD_FILE;\n\t\t*err_info = g_strdup_printf(\"toshiba: File has %u-byte packet, bigger than maximum of %u\",\n\t\t    pkt_len, WTAP_MAX_PACKET_SIZE);\n\t\treturn FALSE;\n\t}\n\n\tphdr->rec_type = REC_TYPE_PACKET;\n\tphdr->presence_flags = WTAP_HAS_TS|WTAP_HAS_CAP_LEN;\n\t\t\tpseudo_header->eth.fcs_len = -1;\n\t\t\tbreak;\n\t}\n\n\t/* Make sure we have enough room for the packet */\n\tws_buffer_assure_space(buf, pkt_len);\n\tpd = ws_buffer_start_ptr(buf);\n\n\t/* Calculate the number of hex dump lines, each\n\t * containing 16 bytes of data */\n\thex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "char *string_crypt(const char *key, const char *salt) {\n  assert(key);\n  assert(salt);\n\n  char random_salt[12];\n  if (!*salt) {\n    memcpy(random_salt,\"$1$\",3);\n    ito64(random_salt+3,rand(),8);\n    random_salt[11] = '\\0';\n    return string_crypt(key, random_salt);\n  }\n\n  if ((strlen(salt) > sizeof(\"$2X$00$\")) &&\n    (salt[0] == '$') &&\n    (salt[1] == '2') &&\n    (salt[2] >= 'a') && (salt[2] <= 'z') &&\n    (salt[3] == '$') &&\n    (salt[4] >= '0') && (salt[4] <= '3') &&\n    (salt[5] >= '0') && (salt[5] <= '9') &&\n    (salt[6] == '$')) {\n    // Bundled blowfish crypt()\n    char output[61];\n    if (php_crypt_blowfish_rn(key, salt, output, sizeof(output))) {\n      return strdup(output);\n    }\n\n  } else {\n    // System crypt() function",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "char *string_crypt(const char *key, const char *salt) {\n  assertx(key);\n  assertx(salt);\n\n  char random_salt[12];\n  if (!*salt) {\n    memcpy(random_salt,\"$1$\",3);\n    ito64(random_salt+3,rand(),8);\n    random_salt[11] = '\\0';\n    return string_crypt(key, random_salt);\n  }\n\n  auto const saltLen = strlen(salt);\n  if ((saltLen > sizeof(\"$2X$00$\")) &&\n    (salt[0] == '$') &&\n    (salt[1] == '2') &&\n    (salt[2] >= 'a') && (salt[2] <= 'z') &&\n    (salt[3] == '$') &&\n    (salt[4] >= '0') && (salt[4] <= '3') &&\n    (salt[5] >= '0') && (salt[5] <= '9') &&\n    (salt[6] == '$')) {\n    // Bundled blowfish crypt()\n    char output[61];\n\n    static constexpr size_t maxSaltLength = 123;\n    char paddedSalt[maxSaltLength + 1];\n    paddedSalt[0] = paddedSalt[maxSaltLength] = '\\0';\n\n    memset(&paddedSalt[1], '$', maxSaltLength - 1);\n    memcpy(paddedSalt, salt, std::min(maxSaltLength, saltLen));\n    paddedSalt[saltLen] = '\\0';\n\n    if (php_crypt_blowfish_rn(key, paddedSalt, output, sizeof(output))) {\n      return strdup(output);\n    }\n\n  } else {\n    // System crypt() function",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tint ydest;\n\tint i;\n\tint colorMap[gdMaxColors];\n\t/* Stretch vectors */\n\tint *stx, *sty;\n\t\n\tif (overflow2(sizeof(int), srcW)) {\n\t\treturn;\n\t}\n\tif (overflow2(sizeof(int), srcH)) {\n\t\treturn;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tint ydest;\n\tint i;\n\tint colorMap[gdMaxColors];\n\t/* Stretch vectors */\n\tint *stx, *sty;\n\n\tif (overflow2(sizeof(int), srcW)) {\n\t\treturn;\n\t}\n\tif (overflow2(sizeof(int), srcH)) {\n\t\treturn;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        return (SLAPI_BIND_FAIL);\n    }\n\n    ec = dse_get_entry_copy(pdse, sdn, DSE_USE_LOCK);\n    if (ec == NULL) {\n        slapi_send_ldap_result(pb, LDAP_NO_SUCH_OBJECT, NULL, NULL, 0, NULL);\n        return (SLAPI_BIND_FAIL);\n    }\n\n    switch (method) {\n    case LDAP_AUTH_SIMPLE: {\n        Slapi_Value cv;\n        if (slapi_entry_attr_find(ec, \"userpassword\", &attr) != 0) {\n            slapi_send_ldap_result(pb, LDAP_INAPPROPRIATE_AUTH, NULL, NULL, 0, NULL);\n            slapi_entry_free(ec);\n            return SLAPI_BIND_FAIL;\n        }\n        bvals = attr_get_present_values(attr);\n\n        slapi_value_init_berval(&cv, cred);\n        if (slapi_pw_find_sv(bvals, &cv) != 0) {\n            slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n            slapi_entry_free(ec);\n            value_done(&cv);\n            return SLAPI_BIND_FAIL;\n        }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        return (SLAPI_BIND_FAIL);\n    }\n\n    ec = dse_get_entry_copy(pdse, sdn, DSE_USE_LOCK);\n    if (ec == NULL) {\n        slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Entry does not exist\");\n        slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n        return (SLAPI_BIND_FAIL);\n    }\n\n    switch (method) {\n    case LDAP_AUTH_SIMPLE: {\n        Slapi_Value cv;\n        if (slapi_entry_attr_find(ec, \"userpassword\", &attr) != 0) {\n            slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Entry does not have userpassword set\");\n            slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n            slapi_entry_free(ec);\n            return SLAPI_BIND_FAIL;\n        }\n        bvals = attr_get_present_values(attr);\n\n        slapi_value_init_berval(&cv, cred);\n        if (slapi_pw_find_sv(bvals, &cv) != 0) {\n            slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, \"Invalid credentials\");\n            slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL);\n            slapi_entry_free(ec);\n            value_done(&cv);\n            return SLAPI_BIND_FAIL;\n        }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ex_function(exarg_T *eap)\n{\n    (void)define_function(eap, NULL);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ex_function(exarg_T *eap)\n{\n    char_u *line_to_free = NULL;\n\n    (void)define_function(eap, NULL, &line_to_free);\n    vim_free(line_to_free);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void ed_mul_sim_lot(ed_t r, const ed_t p[], const bn_t k[], int n) {\n\tint i, j, l, *_l = RLC_ALLOCA(int, n);\n\ted_t *_p = RLC_ALLOCA(ed_t, n);\n\tint8_t *naf = NULL;\n\n\tRLC_TRY {\n\t\tl = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tl = RLC_MAX(l, bn_bits(k[i]) + 1);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void ed_mul_sim_lot(ed_t r, const ed_t p[], const bn_t k[], int n) {\n\tint i, j;\n\tint8_t *naf = NULL;\n\ted_t *_p = RLC_ALLOCA(ed_t, n);\n\tsize_t l, *_l = RLC_ALLOCA(size_t, n);\n\n\tRLC_TRY {\n\t\tl = 0;\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tl = RLC_MAX(l, bn_bits(k[i]) + 1);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void ext4_free_io_end(ext4_io_end_t *io)\n{\n\tBUG_ON(!io);\n\tiput(io->inode);\n\tkfree(io);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void ext4_free_io_end(ext4_io_end_t *io)\n{\n\tBUG_ON(!io);\n\tif (io->page)\n\t\tput_page(io->page);\n\tiput(io->inode);\n\tkfree(io);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "#endif /* OSFC2 */\n\n#if defined(HAVE_GETSPNAM) && !defined(M_UNIX)\n\t/*\n\t *      Check if password has expired.\n\t */\n\tif (spwd && spwd->sp_expire > 0 &&\n\t    (request->timestamp / 86400) > spwd->sp_expire) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: password has expired\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n#if defined(__FreeBSD__) || defined(bsdi) || defined(_PWF_EXPIRE)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n#if defined(HAVE_GETSPNAM) && !defined(M_UNIX)\n\t/*\n\t *      Check if password has expired.\n\t */\n\tif (spwd && spwd->sp_lstchg > 0 && spwd->sp_max >= 0 &&\n\t    (request->timestamp / 86400) > (spwd->sp_lstchg + spwd->sp_max)) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: password has expired\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n\t/*\n\t *      Check if account has expired.\n\t */\n\tif (spwd && spwd->sp_expire > 0 &&\n\t    (request->timestamp / 86400) > spwd->sp_expire) {\n\t\tradlog_request(L_AUTH, 0, request, \"[%s]: account has expired\", name);\n\t\treturn RLM_MODULE_REJECT;\n\t}\n#endif\n\n#if defined(__FreeBSD__) || defined(bsdi) || defined(_PWF_EXPIRE)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    // min command length is 2, plus the \"\\r\\n\"\n    if (cmdlen < 4) {\n        return -1;\n    }\n\n    const char *s = memchr(command, ' ', cmdlen-2);\n    if (s != NULL) {\n        cl = s - command;\n    } else {\n        cl = cmdlen - 2;\n    }\n    pr->keytoken = 0;\n    pr->has_space = false;\n    pr->parsed = cl + 1;\n    pr->request = command;\n    pr->reqlen = cmdlen;\n    int token_max = PARSER_MAX_TOKENS;\n\n    int cmd = -1;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    // min command length is 2, plus the \"\\r\\n\"\n    if (cmdlen < 4) {\n        return -1;\n    }\n\n    // Commands can end with bare '\\n's. Depressingly I intended to be strict\n    // with a \\r\\n requirement but never did this and need backcompat.\n    // In this case we _know_ \\n is at cmdlen because we can't enter this\n    // function otherwise.\n    if (cm[cmdlen-2] == '\\r') {\n        pr->endlen = cmdlen - 2;\n    } else {\n        pr->endlen = cmdlen - 1;\n    }\n\n    const char *s = memchr(command, ' ', pr->endlen);\n    if (s != NULL) {\n        cl = s - command;\n    } else {\n        cl = pr->endlen;\n    }\n    pr->keytoken = 0;\n    pr->has_space = false;\n    pr->parsed = cl;\n    pr->request = command;\n    pr->reqlen = cmdlen;\n    int token_max = PARSER_MAX_TOKENS;\n\n    int cmd = -1;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ast2obj_alias(void* _o)\n{\n    alias_ty o = (alias_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    result = PyType_GenericNew(alias_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_identifier(o->name);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ast2obj_alias(void* _o)\n{\n    alias_ty o = (alias_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_RETURN_NONE;\n    }\n\n    result = PyType_GenericNew(alias_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_identifier(o->name);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static pj_status_t ssl_flush_wbio(dtls_srtp *ds, unsigned idx)\n{\n    pj_size_t len;\n    pj_status_t status = PJ_SUCCESS;\n\n    pj_lock_acquire(ds->ossl_lock);\n\n    if (!ds->ossl_wbio[idx]) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_EGONE;\n    }\n\n    /* Check whether there is data to send */\n    if (BIO_ctrl_pending(ds->ossl_wbio[idx]) > 0) {\n        /* Yes, get and send it */\n        len = BIO_read(ds->ossl_wbio[idx], ds->buf[idx], sizeof(ds->buf));\n        if (len > 0) {\n            pj_lock_release(ds->ossl_lock);\n\n            status = send_raw(ds, idx, ds->buf[idx], len);\n            if (status != PJ_SUCCESS) {\n#if DTLS_DEBUG\n                pj_perror(2, ds->base.name, status, \"Send error\");\n#endif\n                /* This error should be recoverable, remote will retransmit\n                 * its packet when not receiving from us.\n                 */\n            }\n            pj_lock_acquire(ds->ossl_lock);\n        }\n    }\n\n    if (!ds->ossl_ssl[idx]) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_EGONE;\n    }\n\n    /* Just return if handshake completion procedure (key parsing, fingerprint\n     * verification, etc) has been done or handshake is still in progress.\n     */\n    if (ds->nego_completed[idx] || !SSL_is_init_finished(ds->ossl_ssl[idx])) {\n        pj_lock_release(ds->ossl_lock);\n        return PJ_SUCCESS;\n    }\n\n    /* Yes, SSL handshake is done! */\n    ds->nego_completed[idx] = PJ_TRUE;\n    PJ_LOG(2,(ds->base.name, \"DTLS-SRTP negotiation for %s completed!\",\n                             CHANNEL_TO_STRING(idx)));\n\n    pj_lock_release(ds->ossl_lock);\n\n    /* Stop the retransmission clock. Note that the clock may not be stopped\n     * if this function is called from clock thread context. We'll try again\n     * later in socket context.\n     */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static pj_status_t ssl_flush_wbio(dtls_srtp *ds, unsigned idx)\n{\n    pj_size_t len;\n    pj_status_t status = PJ_SUCCESS;\n\n    DTLS_LOCK(ds);\n\n    if (!ds->ossl_wbio[idx]) {\n        DTLS_UNLOCK(ds);\n        return PJ_EGONE;\n    }\n\n    /* Check whether there is data to send */\n    if (BIO_ctrl_pending(ds->ossl_wbio[idx]) > 0) {\n        /* Yes, get and send it */\n        len = BIO_read(ds->ossl_wbio[idx], ds->buf[idx], sizeof(ds->buf));\n        if (len > 0) {\n            DTLS_UNLOCK(ds);\n\n            status = send_raw(ds, idx, ds->buf[idx], len);\n            if (status != PJ_SUCCESS) {\n#if DTLS_DEBUG\n                pj_perror(2, ds->base.name, status, \"Send error\");\n#endif\n                /* This error should be recoverable, remote will retransmit\n                 * its packet when not receiving from us.\n                 */\n            }\n            DTLS_LOCK(ds);\n        }\n    }\n\n    if (!ds->ossl_ssl[idx]) {\n        DTLS_UNLOCK(ds);\n        return PJ_EGONE;\n    }\n\n    /* Just return if handshake completion procedure (key parsing, fingerprint\n     * verification, etc) has been done or handshake is still in progress.\n     */\n    if (ds->nego_completed[idx] || !SSL_is_init_finished(ds->ossl_ssl[idx])) {\n        DTLS_UNLOCK(ds);\n        return PJ_SUCCESS;\n    }\n\n    /* Yes, SSL handshake is done! */\n    ds->nego_completed[idx] = PJ_TRUE;\n    PJ_LOG(2,(ds->base.name, \"DTLS-SRTP negotiation for %s completed!\",\n                             CHANNEL_TO_STRING(idx)));\n\n    DTLS_UNLOCK(ds);\n\n    /* Stop the retransmission clock. Note that the clock may not be stopped\n     * if this function is called from clock thread context. We'll try again\n     * later in socket context.\n     */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "header_put_be_int (SF_PRIVATE *psf, int x)\n{\tif (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)\n\t{\tpsf->header [psf->headindex++] = (x >> 24) ;\n\t\tpsf->header [psf->headindex++] = (x >> 16) ;\n\t\tpsf->header [psf->headindex++] = (x >> 8) ;\n\t\tpsf->header [psf->headindex++] = x ;\n\t\t} ;\n} /* header_put_be_int */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "header_put_be_int (SF_PRIVATE *psf, int x)\n{\tpsf->header.ptr [psf->header.indx++] = (x >> 24) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 16) ;\n\tpsf->header.ptr [psf->header.indx++] = (x >> 8) ;\n\tpsf->header.ptr [psf->header.indx++] = x ;\n} /* header_put_be_int */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (addr_len)\n\t\t*addr_len = sizeof(*sin);\n\n\tif (flags & MSG_ERRQUEUE) {\n\t\terr = ip_recv_error(sk, msg, len);\n\t\tgoto out;\n\t}\n\t/* Copy the address. */\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tsin->sin_port = 0;\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t}\n\tif (inet->cmsg_flags)\n\t\tip_cmsg_recv(msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tint err = -EOPNOTSUPP;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\tstruct sk_buff *skb;\n\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\n\tif (flags & MSG_ERRQUEUE) {\n\t\terr = ip_recv_error(sk, msg, len);\n\t\tgoto out;\n\t}\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tsin->sin_port = 0;\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\t}\n\tif (inet->cmsg_flags)\n\t\tip_cmsg_recv(msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tu16 offset = sizeof(struct ipv6hdr);\n\tstruct ipv6_opt_hdr *exthdr =\n\t\t\t\t(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\n\twhile (offset + 1 <= packet_len) {\n\n\t\tswitch (**nexthdr) {\n\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\t\t\treturn offset;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\n\t\toffset += ipv6_optlen(exthdr);\n\t\t*nexthdr = &exthdr->nexthdr;\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t}\n\n\treturn offset;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)\n{\n\tu16 offset = sizeof(struct ipv6hdr);\n\tunsigned int packet_len = skb_tail_pointer(skb) -\n\t\tskb_network_header(skb);\n\tint found_rhdr = 0;\n\t*nexthdr = &ipv6_hdr(skb)->nexthdr;\n\n\twhile (offset <= packet_len) {\n\t\tstruct ipv6_opt_hdr *exthdr;\n\n\t\tswitch (**nexthdr) {\n\n\t\tcase NEXTHDR_HOP:\n\t\t\tbreak;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn offset;\n\t\t}\n\n\t\tif (offset + sizeof(struct ipv6_opt_hdr) > packet_len)\n\t\t\treturn -EINVAL;\n\n\t\texthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +\n\t\t\t\t\t\t offset);\n\t\toffset += ipv6_optlen(exthdr);\n\t\t*nexthdr = &exthdr->nexthdr;\n\t}\n\n\treturn -EINVAL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "               host_dst);\n\n  result = implementation_->SynchronousMemcpy(host_dst, device_src, size);\n  if (!result.ok()) {\n    result = tsl::Status(\n        port::error::INTERNAL,\n        absl::StrFormat(\"failed to synchronously memcpy device-to-host: device \"\n                        \"%p to host %p size %d: %s\",\n                        device_src.opaque(), host_dst, size,\n                        result.ToString()));\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "               host_dst);\n\n  result = implementation_->SynchronousMemcpy(host_dst, device_src, size);\n  if (!result.ok()) {\n    result = tsl::Status(\n        tsl::error::INTERNAL,\n        absl::StrFormat(\"failed to synchronously memcpy device-to-host: device \"\n                        \"%p to host %p size %d: %s\",\n                        device_src.opaque(), host_dst, size,\n                        result.ToString()));\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void fp24_exp_dig(fp24_t c, const fp24_t a, dig_t b) {\n\tbn_t _b;\n\tfp24_t t, v;\n\tint8_t u, naf[RLC_DIG + 1];\n\tint l;\n\n\tif (b == 0) {\n\t\tfp24_set_dig(c, 1);\n\t\treturn;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void fp24_exp_dig(fp24_t c, const fp24_t a, dig_t b) {\n\tbn_t _b;\n\tfp24_t t, v;\n\tint8_t u, naf[RLC_DIG + 1];\n\tsize_t l;\n\n\tif (b == 0) {\n\t\tfp24_set_dig(c, 1);\n\t\treturn;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tstruct hash_ctx *ctx = ask->private;\n\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tint err;\n\n\terr = crypto_ahash_export(req, state);\n\tif (err)\n\t\treturn err;\n\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = 1;\n\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tstruct ahash_request *req = &ctx->req;\n\tchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];\n\tstruct sock *sk2;\n\tstruct alg_sock *ask2;\n\tstruct hash_ctx *ctx2;\n\tbool more;\n\tint err;\n\n\tlock_sock(sk);\n\tmore = ctx->more;\n\terr = more ? crypto_ahash_export(req, state) : 0;\n\trelease_sock(sk);\n\n\tif (err)\n\t\treturn err;\n\n\terr = af_alg_accept(ask->parent, newsock);\n\tif (err)\n\t\treturn err;\n\n\tsk2 = newsock->sk;\n\task2 = alg_sk(sk2);\n\tctx2 = ask2->private;\n\tctx2->more = more;\n\n\tif (!more)\n\t\treturn err;\n\n\terr = crypto_ahash_import(&ctx2->req, state);\n\tif (err) {\n\t\tsock_orphan(sk2);\n\t\tsock_put(sk2);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  char *ciphers;\n  SSL_METHOD_QUAL SSL_METHOD *req_method = NULL;\n  X509_LOOKUP *lookup = NULL;\n  curl_socket_t sockfd = conn->sock[sockindex];\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  ctx_option_t ctx_options = 0;\n\n#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n  bool sni;\n  const char * const hostname = SSL_HOST_NAME();\n\n      infof(data, \"WARNING: failed to configure server name indication (SNI) \"\n            \"TLS extension\\n\");\n  }\n#endif\n\n  /* Check if there's a cached ID we can/should use here! */\n  if(SSL_SET_OPTION(primary.sessionid)) {\n    void *ssl_sessionid = NULL;\n    int data_idx = ossl_get_ssl_data_index();\n    int connectdata_idx = ossl_get_ssl_conn_index();\n    int sockindex_idx = ossl_get_ssl_sockindex_index();\n    int proxy_idx = ossl_get_proxy_index();\n\n    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&\n       proxy_idx >= 0) {\n      /* Store the data needed for the \"new session\" callback.\n       * The sockindex is stored as a pointer to an array element. */\n      SSL_set_ex_data(backend->handle, data_idx, data);\n      SSL_set_ex_data(backend->handle, connectdata_idx, conn);\n      SSL_set_ex_data(backend->handle, sockindex_idx, conn->sock + sockindex);\n#ifndef CURL_DISABLE_PROXY\n      SSL_set_ex_data(backend->handle, proxy_idx, SSL_IS_PROXY() ? (void *) 1:\n                      NULL);\n#else\n      SSL_set_ex_data(backend->handle, proxy_idx, NULL);\n#endif\n\n    }\n\n    Curl_ssl_sessionid_lock(data);\n    if(!Curl_ssl_getsessionid(data, conn, SSL_IS_PROXY() ? TRUE : FALSE,\n                              &ssl_sessionid, NULL, sockindex)) {\n      /* we got a session id, use it! */\n      if(!SSL_set_session(backend->handle, ssl_sessionid)) {\n        Curl_ssl_sessionid_unlock(data);\n        failf(data, \"SSL: SSL_set_session failed: %s\",\n              ossl_strerror(ERR_get_error(), error_buffer,\n                            sizeof(error_buffer)));\n        return CURLE_SSL_CONNECT_ERROR;\n      }\n      /* Informational message */\n      infof(data, \"SSL re-using session ID\\n\");\n    }\n    Curl_ssl_sessionid_unlock(data);\n  }\n\n#ifndef CURL_DISABLE_PROXY\n  if(conn->proxy_ssl[sockindex].use) {\n    BIO *const bio = BIO_new(BIO_f_ssl());\n    SSL *handle = conn->proxy_ssl[sockindex].backend->handle;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  SSL_METHOD_QUAL SSL_METHOD *req_method = NULL;\n  X509_LOOKUP *lookup = NULL;\n  curl_socket_t sockfd = conn->sock[sockindex];\n  struct ssl_connect_data *connssl = &conn->ssl[sockindex];\n  ctx_option_t ctx_options = 0;\n  void *ssl_sessionid = NULL;\n\n#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n  bool sni;\n  const char * const hostname = SSL_HOST_NAME();\n\n      infof(data, \"WARNING: failed to configure server name indication (SNI) \"\n            \"TLS extension\\n\");\n  }\n#endif\n\n  ossl_associate_connection(data, conn, sockindex);\n\n  Curl_ssl_sessionid_lock(data);\n  if(!Curl_ssl_getsessionid(data, conn, SSL_IS_PROXY() ? TRUE : FALSE,\n                            &ssl_sessionid, NULL, sockindex)) {\n    /* we got a session id, use it! */\n    if(!SSL_set_session(backend->handle, ssl_sessionid)) {\n      Curl_ssl_sessionid_unlock(data);\n      failf(data, \"SSL: SSL_set_session failed: %s\",\n            ossl_strerror(ERR_get_error(), error_buffer,\n                          sizeof(error_buffer)));\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n    /* Informational message */\n    infof(data, \"SSL re-using session ID\\n\");\n  }\n  Curl_ssl_sessionid_unlock(data);\n\n#ifndef CURL_DISABLE_PROXY\n  if(conn->proxy_ssl[sockindex].use) {\n    BIO *const bio = BIO_new(BIO_f_ssl());\n    SSL *handle = conn->proxy_ssl[sockindex].backend->handle;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "R_API bool r_socket_connect(RSocket *s, const char *host, const char *port, int proto, unsigned int timeout) {\n\tr_return_val_if_fail (s, false);\n#if __WINDOWS__\n\tstruct sockaddr_in sa;\n\tstruct hostent *he;\n\tWSADATA wsadata;\n\tTIMEVAL Timeout;\n\tTimeout.tv_sec = timeout;\n\tTimeout.tv_usec = 0;\n\n\tif (WSAStartup (MAKEWORD (1, 1), &wsadata) == SOCKET_ERROR) {\n\t\teprintf (\"Error creating socket.\");\n\t\treturn false;\n\t}\n\ts->fd = socket (AF_INET, SOCK_STREAM, 0);\n\tif (s->fd == R_INVALID_SOCKET) {\n\t\treturn false;\n\t}\n\n\tunsigned long iMode = 1;\n\tint iResult = ioctlsocket (s->fd, FIONBIO, &iMode);\n\tif (iResult != NO_ERROR) {\n\t\teprintf (\"ioctlsocket error: %d\\n\", iResult);\n\t}\n\tmemset (&sa, 0, sizeof (sa));\n\tsa.sin_family = AF_INET;\n\the = (struct hostent *)gethostbyname (host);\n\tif (he == (struct hostent*)0) {\n#ifdef _MSC_VER\n\t\tclosesocket (s->fd);\n#else\n\t\tclose (s->fd);\n#endif\n\t\treturn false;\n\t}\n\tsa.sin_addr = *((struct in_addr *)he->h_addr);\n\ts->port = r_socket_port_by_name (port);\n\ts->proto = proto;\n\tsa.sin_port = htons (s->port);\n\tif (!connect (s->fd, (const struct sockaddr*)&sa, sizeof (struct sockaddr))) {\n#ifdef _MSC_VER\n\t\tclosesocket (s->fd);\n#else\n\t\tclose (s->fd);\n#endif\n\t\treturn false;\n\t}\n\tiMode = 0;\n\tiResult = ioctlsocket (s->fd, FIONBIO, &iMode);\n\tif (iResult != NO_ERROR) {\n\t\teprintf (\"ioctlsocket error: %d\\n\", iResult);\n\t}\n\tif (timeout > 0) {\n\t\tr_socket_block_time (s, 1, timeout, 0);\n\t}\n\tfd_set Write, Err;\n\tFD_ZERO (&Write);\n\tFD_ZERO (&Err);\n\tFD_SET (s->fd, &Write);\n\tFD_SET (s->fd, &Err);\n\tselect (0, NULL, &Write, &Err, &Timeout);\n\tif (FD_ISSET (s->fd, &Write)) {\n\t\treturn true;\n\t}\n\treturn false;\n#elif __UNIX__\n\tint ret;\n\tstruct addrinfo hints = {0};\n\tstruct addrinfo *res, *rp;\n\tif (!proto) {\n\t\tproto = R_SOCKET_PROTO_TCP;\n\t}\n\tr_sys_signal (SIGPIPE, SIG_IGN);\n\tif (proto == R_SOCKET_PROTO_UNIX) {\n\t\tif (!__connect_unix (s, host)) {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\thints.ai_family = AF_UNSPEC; /* Allow IPv4 or IPv6 */\n\t\thints.ai_protocol = proto;\n\t\tint gai = getaddrinfo (host, port, &hints, &res);\n\t\tif (gai != 0) {\n\t\t\tif (ret == 0) {\n\t\t\t\tfreeaddrinfo (res);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (errno == EINPROGRESS) {\n\t\t\t\tstruct timeval tv;\n\t\t\t\ttv.tv_sec = timeout;\n\t\t\t\ttv.tv_usec = 0;\n\t\t\t\tfd_set wfds;\n\t\t\t\tFD_ZERO(&wfds);\n\t\t\t\tFD_SET(s->fd, &wfds);\n\n\t\t\t\tif ((ret = select (s->fd + 1, NULL, &wfds, NULL, &tv)) != -1) {\n\t\t\t\t\tif (r_socket_is_connected (s)) {\n\t\t\t\t\t\tfreeaddrinfo (res);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tperror (\"connect\");\n\t\t\t\t}\n\t\t\t}\n\t\tif (!rp) {\n\t\t\teprintf (\"Could not resolve address '%s' or failed to connect\\n\", host);\n\t\t\treturn false;\n\t\t}\n\t}\n#endif\n#if HAVE_LIB_SSL\n\tif (s->is_ssl) {\n\t\ts->ctx = SSL_CTX_new (SSLv23_client_method ());\n\t\tif (!s->ctx) {\n\t\t\tr_socket_free (s);\n\t\t\treturn false;\n\t\t}\n\t\ts->sfd = SSL_new (s->ctx);\n\t\tSSL_set_fd (s->sfd, s->fd);\n\t\tif (SSL_connect (s->sfd) != 1) {\n\t\t\tr_socket_free (s);\n\t\t\treturn false;\n\t\t}\n\t}\n#endif\n\treturn true;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "R_API bool r_socket_connect(RSocket *s, const char *host, const char *port, int proto, unsigned int timeout) {\n\tr_return_val_if_fail (s, false);\n#if __WINDOWS__\n#define gai_strerror gai_strerrorA\n\tstruct sockaddr_in sa;\n\tWSADATA wsadata;\n\n\tif (WSAStartup (MAKEWORD (1, 1), &wsadata) == SOCKET_ERROR) {\n\t\teprintf (\"Error creating socket.\");\n\t\treturn false;\n\t}\n#endif\n\tint ret;\n\tstruct addrinfo hints = { 0 };\n\tstruct addrinfo *res, *rp;\n\tif (!proto) {\n\t\tproto = R_SOCKET_PROTO_TCP;\n\t}\n#if __UNIX__\n\tr_sys_signal (SIGPIPE, SIG_IGN);\n#endif\n\tif (proto == R_SOCKET_PROTO_UNIX) {\n#if __UNIX__\n\t\tif (!__connect_unix (s, host)) {\n\t\t\treturn false;\n\t\t}\n#endif\n\t} else {\n\t\thints.ai_family = AF_UNSPEC; /* Allow IPv4 or IPv6 */\n\t\thints.ai_protocol = proto;\n\t\tint gai = getaddrinfo (host, port, &hints, &res);\n\t\tif (gai != 0) {\n\t\t\tif (ret == 0) {\n\t\t\t\tfreeaddrinfo (res);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (errno == EINPROGRESS) {\n\t\t\t\tstruct timeval tv = {timeout, 0};\n\t\t\t\tfd_set wfds;\n\t\t\t\tFD_ZERO (&wfds);\n\t\t\t\tFD_SET (s->fd, &wfds);\n\n\t\t\t\tif ((ret = select (s->fd + 1, NULL, &wfds, NULL, &tv)) != -1) {\n\t\t\t\t\tif (r_socket_is_connected (s)) {\n\t\t\t\t\t\tfreeaddrinfo (res);\n\t\t\t\t\t\tgoto success;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tperror (\"connect\");\n\t\t\t\t}\n\t\t\t}\n\t\tif (!rp) {\n\t\t\teprintf (\"Could not resolve address '%s' or failed to connect\\n\", host);\n\t\t\treturn false;\n\t\t}\n\t}\nsuccess:\n#if HAVE_LIB_SSL\n\tif (s->is_ssl) {\n\t\ts->ctx = SSL_CTX_new (SSLv23_client_method ());\n\t\tif (!s->ctx) {\n\t\t\tr_socket_close (s);\n\t\t\treturn false;\n\t\t}\n\t\ts->sfd = SSL_new (s->ctx);\n\t\tSSL_set_fd (s->sfd, s->fd);\n\t\tint ret = SSL_connect (s->sfd);\n\t\tif (ret != 1) {\n\t\t\tint error = SSL_get_error (s->sfd, ret);\n\t\t\tint tries = 10;\n\t\t\twhile (tries && ret && (error == SSL_ERROR_WANT_READ || error == SSL_ERROR_WANT_WRITE)) {\n\t\t\t\tstruct timeval tv = {1, 0};\n\t\t\t\tfd_set rfds, wfds;\n\t\t\t\tFD_ZERO (&rfds);\n\t\t\t\tFD_ZERO (&wfds);\n\t\t\t\tif (error == SSL_ERROR_WANT_READ) {\n\t\t\t\t\tFD_SET (s->fd, &rfds);\n\t\t\t\t} else {\n\t\t\t\t\tFD_SET (s->fd, &wfds);\n\t\t\t\t}\n\t\t\t\tif ((ret = select (s->fd + 1, &rfds, &wfds, NULL, &tv)) < 1) {\n\t\t\t\t\tr_socket_close (s);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tret = SSL_connect (s->sfd);\n\t\t\t\tif (ret == 1) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\terror = SSL_get_error (s->sfd, ret);\n\t\t\t\ttries--;\n\t\t\t}\n\t\t\tr_socket_close (s);\n\t\t\treturn false;\n\t\t}\n\t}\n#endif\n\treturn true;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (fnum == 0 && other_file && ffname != NULL)\n\t    (void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);\n\tgoto theend;\n    }\n\n    /*\n     * End Visual mode before switching to another buffer, so the text can be\n     * copied into the GUI selection buffer.\n     */\n    reset_VIsual();\n\n#if defined(FEAT_EVAL)\n    if ((command != NULL || newlnum > (linenr_T)0)\n\t    && *get_vim_var_str(VV_SWAPCOMMAND) == NUL)\n    {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (fnum == 0 && other_file && ffname != NULL)\n\t    (void)setaltfname(ffname, sfname, newlnum < 0 ? 0 : newlnum);\n\tgoto theend;\n    }\n\n    \n     // End Visual mode before switching to another buffer, so the text can be\n     // copied into the GUI selection buffer.\n     // Careful: may trigger ModeChanged() autocommand\n     \n    // Should we block autocommands here?\n    reset_VIsual();\n\n    // autocommands freed window :(\n    if (oldwin != NULL && !win_valid(oldwin))\n\toldwin = NULL;\n\n#if defined(FEAT_EVAL)\n    if ((command != NULL || newlnum > (linenr_T)0)\n\t    && *get_vim_var_str(VV_SWAPCOMMAND) == NUL)\n    {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "raptor_libxml_getEntity(void* user_data, const xmlChar *name) {\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  return libxml2_getEntity(sax2->xc, name);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "raptor_libxml_getEntity(void* user_data, const xmlChar *name)\n{\n  raptor_sax2* sax2 = (raptor_sax2*)user_data;\n  xmlParserCtxtPtr xc = sax2->xc;\n  xmlEntityPtr ret = NULL;\n\n  if(!xc)\n    return NULL;\n\n  if(!xc->inSubset) {\n    /* looks for hardcoded set of entity names - lt, gt etc. */\n    ret = xmlGetPredefinedEntity(name);\n    if(ret) {\n      RAPTOR_DEBUG2(\"Entity '%s' found in predefined set\\n\", name);\n      return ret;\n    }\n  }\n\n  /* This section uses xmlGetDocEntity which looks for entities in\n   * memory only, never from a file or URI \n   */\n  if(xc->myDoc && (xc->myDoc->standalone == 1)) {\n    RAPTOR_DEBUG2(\"Entity '%s' document is standalone\\n\", name);\n    /* Document is standalone: no entities are required to interpret doc */\n    if(xc->inSubset == 2) {\n      xc->myDoc->standalone = 0;\n      ret = xmlGetDocEntity(xc->myDoc, name);\n      xc->myDoc->standalone = 1;\n    } else {\n      ret = xmlGetDocEntity(xc->myDoc, name);\n      if(!ret) {\n        xc->myDoc->standalone = 0;\n        ret = xmlGetDocEntity(xc->myDoc, name);\n        xc->myDoc->standalone = 1;\n      }\n    }\n  } else {\n    ret = xmlGetDocEntity(xc->myDoc, name);\n  }\n\n  if(ret && !ret->children &&\n    (ret->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {\n    /* Entity is an external general parsed entity. It may be in a\n     * catalog file, user file or user URI\n     */\n    int val = 0;\n    xmlNodePtr children;\n    int load_entity = 0;\n\n    load_entity = RAPTOR_OPTIONS_GET_NUMERIC(sax2, RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES);\n    if(load_entity)\n      load_entity = raptor_sax2_check_load_uri_string(sax2, ret->URI);\n\n    if(!load_entity) {\n      RAPTOR_DEBUG2(\"Not getting entity URI %s by policy\\n\", ret->URI);\n      children = xmlNewText((const xmlChar*)\"\");\n    } else {\n      /* Disable SAX2 handlers so that the SAX2 events do not all get\n       * sent to callbacks during dealing with the entity parsing.\n       */\n      sax2->enabled = 0;\n      val = xmlParseCtxtExternalEntity(xc, ret->URI, ret->ExternalID, &children);\n      sax2->enabled = 1;\n    }\n    \n    if(!val) {\n      xmlAddChildList((xmlNodePtr)ret, children);\n    } else {\n      xc->validate = 0;\n      return NULL;\n    }\n    \n    ret->owner = 1;\n\n    /* Mark this entity as having been checked - never do this again */\n    if(!ret->checked)\n      ret->checked = 1;\n  }\n\n  return ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void svhandler_flash_pgm_word(void) {\n  uint32_t dst = _param_1;\n  uint32_t src = _param_2;\n\n  // Do not allow firmware to erase bootstrap or bootloader sectors.\n  if ((dst >= BSTRP_FLASH_SECT_START) &&\n      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {\n    return;\n  }\n\n  if ((dst >= BLDR_FLASH_SECT_START) &&\n      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {\n    return;\n  }\n\n  // Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void svhandler_flash_pgm_word(void) {\n  uint32_t dst = _param_1;\n  uint32_t src = _param_2;\n\n  // Verify requested address range is allowed.\n  if (!allow_svhandler_flash_range(dst, dst + sizeof(uint32_t))) return;\n\n  // Unlock flash.\n  flash_clear_status_flags();\n  flash_unlock();\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "            imgdata.image[i][1] = lut[imgdata.image[i][1]];\n            imgdata.image[i][2] = lut[imgdata.image[i][2]];\n            imgdata.image[i][3] = lut[imgdata.image[i][3]];\n        }\n\n    C.data_maximum = lut[C.data_maximum];\n    C.maximum = lut[C.maximum];\n    // no need to adjust the minumum, black is already subtracted\n    free(lut);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "            imgdata.image[i][1] = lut[imgdata.image[i][1]];\n            imgdata.image[i][2] = lut[imgdata.image[i][2]];\n            imgdata.image[i][3] = lut[imgdata.image[i][3]];\n        }\n\n\tif(C.data_maximum <=TBLN)\n\t\tC.data_maximum = lut[C.data_maximum];\n\tif(C.maximum <= TBLN)\n\t\tC.maximum = lut[C.maximum];\n    // no need to adjust the minumum, black is already subtracted\n    free(lut);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_entry *entry;\n\tsize_t size;\n\tint error;\n\tstruct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\n\terror = -ENODATA;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n\tstruct buffer_head *bh = NULL;\n\tstruct ext4_xattr_entry *entry;\n\tsize_t size;\n\tint error;\n\tstruct mb2_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);\n\n\tea_idebug(inode, \"name=%d.%s, buffer=%p, buffer_size=%ld\",\n\t\t  name_index, name, buffer, (long)buffer_size);\n\n\terror = -ENODATA;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\t\tif(lasttag == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\talBITMAPINFOHEADER bih;\n\n\t\t\t\t\t\tmemcpy(&bih, hdrl_data + i, sizeof(alBITMAPINFOHEADER));\n\t\t\t\t\t\tAVI->bitmap_info_header = (alBITMAPINFOHEADER *)\n\t\t\t\t\t\t                          gf_malloc(str2ulong((unsigned char *)&bih.bi_size));\n\t\t\t\t\t\tif (AVI->bitmap_info_header != NULL)\n\t\t\t\t\t\t\tmemcpy(AVI->bitmap_info_header, hdrl_data + i,\n\t\t\t\t\t\t\t       str2ulong((unsigned char *)&bih.bi_size));\n\n\t\t\t\t\t\tAVI->width  = str2ulong(hdrl_data+i+4);\n\t\t\t\t\t\tAVI->height = str2ulong(hdrl_data+i+8);\n\t\t\t\t\t\tvids_strf_seen = 1;\n\t\t\t\t\t\t//ThOe\n\t\t\t\t\tchar *a;\n\n\t\t\t\t\tif(lasttag == 1) // V I D E O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*)hdrl_data+i;\n\n\t\t\t\t\t\tAVI->video_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemset(AVI->video_superindex, 0, sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->video_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->video_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t                                gf_malloc (AVI->video_superindex->wLongsPerEntry * AVI->video_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2) // A U D I O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*) hdrl_data+i;\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->dwSize = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->track[AVI->aptr].audio_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t        gf_malloc (AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry *\n\t\t\t\t\t\t                   AVI->track[AVI->aptr].audio_superindex->nEntriesInUse * sizeof (u32));\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\t\tif(lasttag == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\talBITMAPINFOHEADER bih;\n\n\t\t\t\t\t\tmemcpy(&bih, hdrl_data + i, sizeof(alBITMAPINFOHEADER));\n\t\t\t\t\t\tbih.bi_size = str2ulong((unsigned char *)&bih.bi_size);\n\n\t\t\t\t\t\tif (i + bih.bi_size > hdrl_len) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->bitmap_info_header = (alBITMAPINFOHEADER *) gf_malloc(bih.bi_size);\n\t\t\t\t\t\tif (AVI->bitmap_info_header != NULL)\n\t\t\t\t\t\t\tmemcpy(AVI->bitmap_info_header, hdrl_data + i, bih.bi_size);\n\n\t\t\t\t\t\tAVI->width  = str2ulong(hdrl_data+i+4);\n\t\t\t\t\t\tAVI->height = str2ulong(hdrl_data+i+8);\n\t\t\t\t\t\tvids_strf_seen = 1;\n\t\t\t\t\t\t//ThOe\n\n\t\t\t\t\tif(lasttag == 1) // V I D E O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*)hdrl_data+i;\n\t\t\t\t\t\tint avail = hdrl_len-i;\n\t\t\t\t\t\tif (avail<32) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->video_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemset(AVI->video_superindex, 0, sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->video_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->video_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tavail -= 32;\n\t\t\t\t\t\tif (avail < AVI->video_superindex->nEntriesInUse*16) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->video_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t                                gf_malloc (AVI->video_superindex->wLongsPerEntry * AVI->video_superindex->nEntriesInUse * sizeof (u32));\n\n\t\t\t\t\t\t// position of ix## chunks\n\t\t\t\t\t}\n\t\t\t\t\telse if(lasttag == 2) // A U D I O\n\t\t\t\t\t{\n\n\t\t\t\t\t\ta = (char*) hdrl_data+i;\n\t\t\t\t\t\tint avail = hdrl_len-i;\n\t\t\t\t\t\tif (avail<32) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex = (avisuperindex_chunk *) gf_malloc (sizeof (avisuperindex_chunk));\n\t\t\t\t\t\tmemcpy (AVI->track[AVI->aptr].audio_superindex->fcc, a, 4);\n\t\t\t\t\t\ta += 4;\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->dwSize = str2ulong((unsigned char*)a);\n\t\t\t\t\t\ta += 4;\n\n\t\t\t\t\t\tif (AVI->track[AVI->aptr].audio_superindex->bIndexSubType != 0) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[avilib] Invalid Header, bIndexSubType != 0\\n\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tavail -= 32;\n\t\t\t\t\t\tif (avail < AVI->track[AVI->aptr].audio_superindex->nEntriesInUse*16) ERR_EXIT(AVI_ERR_READ)\n\n\t\t\t\t\t\tAVI->track[AVI->aptr].audio_superindex->aIndex = (avisuperindex_entry*)\n\t\t\t\t\t\t        gf_malloc (AVI->track[AVI->aptr].audio_superindex->wLongsPerEntry *\n\t\t\t\t\t\t                   AVI->track[AVI->aptr].audio_superindex->nEntriesInUse * sizeof (u32));\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\ttwcb = kzalloc(sizeof(*twcb), GFP_KERNEL);\n\tif (!twcb)\n\t\treturn;\n\tinit_task_work(&twcb->twork, binder_do_fd_close);\n\t__close_fd_get_file(fd, &twcb->file);\n\tif (twcb->file)\n\t\ttask_work_add(current, &twcb->twork, TWA_RESUME);\n\telse\n\t\tkfree(twcb);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\ttwcb = kzalloc(sizeof(*twcb), GFP_KERNEL);\n\tif (!twcb)\n\t\treturn;\n\tinit_task_work(&twcb->twork, binder_do_fd_close);\n\t__close_fd_get_file(fd, &twcb->file);\n\tif (twcb->file) {\n\t\tfilp_close(twcb->file, current->files);\n\t\ttask_work_add(current, &twcb->twork, TWA_RESUME);\n\t} else {\n\t\tkfree(twcb);\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  // Check we have all the inputs and outputs we need.\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 12);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size,\n                    params->merge_outputs ? 1 : 2);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* fw_input_weights =\n      GetInput(context, node, kFwWeightsTensor);\n  const TfLiteTensor* fw_recurrent_weights =\n      GetInput(context, node, kFwRecurrentWeightsTensor);\n  const TfLiteTensor* fw_bias = GetInput(context, node, kFwBiasTensor);\n  const TfLiteTensor* fw_hidden_state =\n      GetInput(context, node, kFwHiddenStateTensor);\n  const TfLiteTensor* bw_input_weights =\n      GetInput(context, node, kBwWeightsTensor);\n  const TfLiteTensor* bw_recurrent_weights =\n      GetInput(context, node, kBwRecurrentWeightsTensor);\n  const TfLiteTensor* bw_bias = GetInput(context, node, kBwBiasTensor);\n  const TfLiteTensor* bw_hidden_state =\n      GetInput(context, node, kBwHiddenStateTensor);\n\n  const TfLiteTensor* aux_input =\n      GetOptionalInputTensor(context, node, kAuxInputTensor);\n  const TfLiteTensor* fw_aux_input_weights =\n      GetOptionalInputTensor(context, node, kFwAuxWeightsTensor);\n      node->temporaries = TfLiteIntArrayCreate(kNumTemporaryTensors - 1);\n    }\n\n    node->temporaries->data[kInputQuantized] =\n        op_data->scratch_tensor_index + kInputQuantized;\n    TfLiteTensor* input_quantized =\n        GetTemporary(context, node, kInputQuantized);\n    input_quantized->type = fw_input_weights->type;\n    input_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {\n      TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                       input_quantized_size));\n    }\n\n    node->temporaries->data[kFwHiddenStateQuantized] =\n        op_data->scratch_tensor_index + kFwHiddenStateQuantized;\n    TfLiteTensor* fw_hidden_state_quantized =\n        GetTemporary(context, node, kFwHiddenStateQuantized);\n    fw_hidden_state_quantized->type = fw_input_weights->type;\n    fw_hidden_state_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(fw_hidden_state_quantized->dims,\n                             fw_hidden_state->dims)) {\n      TfLiteIntArray* fw_hidden_state_quantized_size =\n                                         fw_hidden_state_quantized_size));\n    }\n\n    node->temporaries->data[kBwHiddenStateQuantized] =\n        op_data->scratch_tensor_index + kBwHiddenStateQuantized;\n    TfLiteTensor* bw_hidden_state_quantized =\n        GetTemporary(context, node, kBwHiddenStateQuantized);\n    bw_hidden_state_quantized->type = fw_input_weights->type;\n    bw_hidden_state_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(bw_hidden_state_quantized->dims,\n                             bw_hidden_state->dims)) {\n      TfLiteIntArray* bw_hidden_state_quantized_size =\n    }\n\n    // Allocate temporary tensors to store scaling factors of quantization.\n    node->temporaries->data[kScalingFactors] =\n        op_data->scratch_tensor_index + kScalingFactors;\n    TfLiteTensor* scaling_factors =\n        GetTemporary(context, node, kScalingFactors);\n    scaling_factors->type = kTfLiteFloat32;\n    scaling_factors->allocation_type = kTfLiteArenaRw;\n    int scaling_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {\n      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,\n                                                       scaling_factors_size));\n    }\n    node->temporaries->data[kAccumScratch] =\n        op_data->scratch_tensor_index + kAccumScratch;\n    TfLiteTensor* accum_scratch = GetTemporary(context, node, kAccumScratch);\n    accum_scratch->type = kTfLiteInt32;\n    accum_scratch->allocation_type = kTfLiteArenaRw;\n    int accum_scratch_dims[2] = {std::max(fw_num_units, bw_num_units),\n                                 batch_size};\n    if (!TfLiteIntArrayEqualsArray(accum_scratch->dims, 2,\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, accum_scratch,\n                                                       accum_scratch_size));\n    }\n    node->temporaries->data[kZeroPoints] =\n        op_data->scratch_tensor_index + kZeroPoints;\n    TfLiteTensor* zero_points =\n        GetTemporary(context, node, /*index=*/kZeroPoints);\n    zero_points->type = kTfLiteInt32;\n    zero_points->allocation_type = kTfLiteArenaRw;\n    int zero_points_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(zero_points->dims, 1, zero_points_dims)) {\n      TfLiteIntArray* zero_points_size = TfLiteIntArrayCreate(1);\n                                                       zero_points_size));\n    }\n    const int num_row_sums = has_aux_input ? 3 : 2;\n    node->temporaries->data[kFwRowSums] =\n        op_data->scratch_tensor_index + kFwRowSums;\n    TfLiteTensor* fw_row_sums =\n        GetTemporary(context, node, /*index=*/kFwRowSums);\n    fw_row_sums->type = kTfLiteInt32;\n    fw_row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int fw_row_sums_dims[2] = {num_row_sums, fw_num_units};\n    if (!TfLiteIntArrayEqualsArray(fw_row_sums->dims, 2, fw_row_sums_dims)) {\n      TfLiteIntArray* fw_row_sums_size = TfLiteIntArrayCreate(2);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, fw_row_sums,\n                                                       fw_row_sums_size));\n    }\n    node->temporaries->data[kBwRowSums] =\n        op_data->scratch_tensor_index + kBwRowSums;\n    TfLiteTensor* bw_row_sums = GetTemporary(context, node,\n                                             /*index=*/kBwRowSums);\n    bw_row_sums->type = kTfLiteInt32;\n    bw_row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int bw_row_sums_dims[2] = {num_row_sums, bw_num_units};\n    if (!TfLiteIntArrayEqualsArray(bw_row_sums->dims, 2, bw_row_sums_dims)) {\n      TfLiteIntArray* bw_row_sums_size = TfLiteIntArrayCreate(2);\n                                                       bw_row_sums_size));\n    }\n    if (has_aux_input) {\n      node->temporaries->data[kAuxInputQuantized] =\n          op_data->scratch_tensor_index + kAuxInputQuantized;\n      TfLiteTensor* aux_input_quantized =\n          GetTemporary(context, node, kAuxInputQuantized);\n      aux_input_quantized->type = fw_input_weights->type;\n      aux_input_quantized->allocation_type = kTfLiteArenaRw;\n      if (!TfLiteIntArrayEqual(aux_input_quantized->dims, aux_input->dims)) {\n        TfLiteIntArray* aux_input_quantized_size =\n            TfLiteIntArrayCopy(aux_input->dims);\n      }\n    }\n  }\n\n  // Resize outputs.\n  TfLiteTensor* fw_output = GetOutput(context, node, kFwOutputTensor);\n  TfLiteIntArray* fw_output_size_array = TfLiteIntArrayCreate(3);\n  fw_output_size_array->data[0] = (time_major) ? max_time : batch_size;\n  fw_output_size_array->data[1] = (time_major) ? batch_size : max_time;\n  fw_output_size_array->data[2] =\n      params->merge_outputs ? fw_num_units + bw_num_units : fw_num_units;\n  TF_LITE_ENSURE_OK(\n      context, context->ResizeTensor(context, fw_output, fw_output_size_array));\n  if (!params->merge_outputs) {\n    TfLiteTensor* bw_output = GetOutput(context, node, kBwOutputTensor);\n    TfLiteIntArray* bw_output_size_array = TfLiteIntArrayCreate(3);\n    bw_output_size_array->data[0] = batch_size;\n    bw_output_size_array->data[1] = max_time;\n    bw_output_size_array->data[2] = bw_num_units;\n    TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, bw_output,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  // Check we have all the inputs and outputs we need.\n  TF_LITE_ENSURE_EQ(context, node->inputs->size, 12);\n  TF_LITE_ENSURE_EQ(context, node->outputs->size,\n                    params->merge_outputs ? 1 : 2);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  const TfLiteTensor* fw_input_weights;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kFwWeightsTensor,\n                                          &fw_input_weights));\n  const TfLiteTensor* fw_recurrent_weights;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kFwRecurrentWeightsTensor,\n                                 &fw_recurrent_weights));\n  const TfLiteTensor* fw_bias;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kFwBiasTensor, &fw_bias));\n  const TfLiteTensor* fw_hidden_state;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kFwHiddenStateTensor,\n                                          &fw_hidden_state));\n  const TfLiteTensor* bw_input_weights;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kBwWeightsTensor,\n                                          &bw_input_weights));\n  const TfLiteTensor* bw_recurrent_weights;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kBwRecurrentWeightsTensor,\n                                 &bw_recurrent_weights));\n  const TfLiteTensor* bw_bias;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kBwBiasTensor, &bw_bias));\n  const TfLiteTensor* bw_hidden_state;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kBwHiddenStateTensor,\n                                          &bw_hidden_state));\n\n  const TfLiteTensor* aux_input =\n      GetOptionalInputTensor(context, node, kAuxInputTensor);\n  const TfLiteTensor* fw_aux_input_weights =\n      GetOptionalInputTensor(context, node, kFwAuxWeightsTensor);\n      node->temporaries = TfLiteIntArrayCreate(kNumTemporaryTensors - 1);\n    }\n\n    node->temporaries->data[kInputQuantized] =\n        op_data->scratch_tensor_index + kInputQuantized;\n    TfLiteTensor* input_quantized;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, kInputQuantized,\n                                                &input_quantized));\n    input_quantized->type = fw_input_weights->type;\n    input_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) {\n      TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized,\n                                                       input_quantized_size));\n    }\n\n    node->temporaries->data[kFwHiddenStateQuantized] =\n        op_data->scratch_tensor_index + kFwHiddenStateQuantized;\n    TfLiteTensor* fw_hidden_state_quantized;\n    TF_LITE_ENSURE_OK(context,\n                      GetTemporarySafe(context, node, kFwHiddenStateQuantized,\n                                       &fw_hidden_state_quantized));\n    fw_hidden_state_quantized->type = fw_input_weights->type;\n    fw_hidden_state_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(fw_hidden_state_quantized->dims,\n                             fw_hidden_state->dims)) {\n      TfLiteIntArray* fw_hidden_state_quantized_size =\n                                         fw_hidden_state_quantized_size));\n    }\n\n    node->temporaries->data[kBwHiddenStateQuantized] =\n        op_data->scratch_tensor_index + kBwHiddenStateQuantized;\n    TfLiteTensor* bw_hidden_state_quantized;\n    TF_LITE_ENSURE_OK(context,\n                      GetTemporarySafe(context, node, kBwHiddenStateQuantized,\n                                       &bw_hidden_state_quantized));\n    bw_hidden_state_quantized->type = fw_input_weights->type;\n    bw_hidden_state_quantized->allocation_type = kTfLiteArenaRw;\n    if (!TfLiteIntArrayEqual(bw_hidden_state_quantized->dims,\n                             bw_hidden_state->dims)) {\n      TfLiteIntArray* bw_hidden_state_quantized_size =\n    }\n\n    // Allocate temporary tensors to store scaling factors of quantization.\n    node->temporaries->data[kScalingFactors] =\n        op_data->scratch_tensor_index + kScalingFactors;\n    TfLiteTensor* scaling_factors;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, kScalingFactors,\n                                                &scaling_factors));\n    scaling_factors->type = kTfLiteFloat32;\n    scaling_factors->allocation_type = kTfLiteArenaRw;\n    int scaling_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) {\n      TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors,\n                                                       scaling_factors_size));\n    }\n    node->temporaries->data[kAccumScratch] =\n        op_data->scratch_tensor_index + kAccumScratch;\n    TfLiteTensor* accum_scratch;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, kAccumScratch,\n                                                &accum_scratch));\n    accum_scratch->type = kTfLiteInt32;\n    accum_scratch->allocation_type = kTfLiteArenaRw;\n    int accum_scratch_dims[2] = {std::max(fw_num_units, bw_num_units),\n                                 batch_size};\n    if (!TfLiteIntArrayEqualsArray(accum_scratch->dims, 2,\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, accum_scratch,\n                                                       accum_scratch_size));\n    }\n    node->temporaries->data[kZeroPoints] =\n        op_data->scratch_tensor_index + kZeroPoints;\n    TfLiteTensor* zero_points;\n    TF_LITE_ENSURE_OK(\n        context,\n        GetTemporarySafe(context, node, /*index=*/kZeroPoints, &zero_points));\n    zero_points->type = kTfLiteInt32;\n    zero_points->allocation_type = kTfLiteArenaRw;\n    int zero_points_dims[1] = {batch_size};\n    if (!TfLiteIntArrayEqualsArray(zero_points->dims, 1, zero_points_dims)) {\n      TfLiteIntArray* zero_points_size = TfLiteIntArrayCreate(1);\n                                                       zero_points_size));\n    }\n    const int num_row_sums = has_aux_input ? 3 : 2;\n    node->temporaries->data[kFwRowSums] =\n        op_data->scratch_tensor_index + kFwRowSums;\n    TfLiteTensor* fw_row_sums;\n    TF_LITE_ENSURE_OK(\n        context,\n        GetTemporarySafe(context, node, /*index=*/kFwRowSums, &fw_row_sums));\n    fw_row_sums->type = kTfLiteInt32;\n    fw_row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int fw_row_sums_dims[2] = {num_row_sums, fw_num_units};\n    if (!TfLiteIntArrayEqualsArray(fw_row_sums->dims, 2, fw_row_sums_dims)) {\n      TfLiteIntArray* fw_row_sums_size = TfLiteIntArrayCreate(2);\n      TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, fw_row_sums,\n                                                       fw_row_sums_size));\n    }\n    node->temporaries->data[kBwRowSums] =\n        op_data->scratch_tensor_index + kBwRowSums;\n    TfLiteTensor* bw_row_sums;\n    TF_LITE_ENSURE_OK(\n        context,\n        GetTemporarySafe(context, node, /*index=*/kBwRowSums, &bw_row_sums));\n    bw_row_sums->type = kTfLiteInt32;\n    bw_row_sums->allocation_type = kTfLiteArenaRwPersistent;\n    int bw_row_sums_dims[2] = {num_row_sums, bw_num_units};\n    if (!TfLiteIntArrayEqualsArray(bw_row_sums->dims, 2, bw_row_sums_dims)) {\n      TfLiteIntArray* bw_row_sums_size = TfLiteIntArrayCreate(2);\n                                                       bw_row_sums_size));\n    }\n    if (has_aux_input) {\n      node->temporaries->data[kAuxInputQuantized] =\n          op_data->scratch_tensor_index + kAuxInputQuantized;\n      TfLiteTensor* aux_input_quantized;\n      TF_LITE_ENSURE_OK(context,\n                        GetTemporarySafe(context, node, kAuxInputQuantized,\n                                         &aux_input_quantized));\n      aux_input_quantized->type = fw_input_weights->type;\n      aux_input_quantized->allocation_type = kTfLiteArenaRw;\n      if (!TfLiteIntArrayEqual(aux_input_quantized->dims, aux_input->dims)) {\n        TfLiteIntArray* aux_input_quantized_size =\n            TfLiteIntArrayCopy(aux_input->dims);\n      }\n    }\n  }\n\n  // Resize outputs.\n  TfLiteTensor* fw_output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kFwOutputTensor, &fw_output));\n  TfLiteIntArray* fw_output_size_array = TfLiteIntArrayCreate(3);\n  fw_output_size_array->data[0] = (time_major) ? max_time : batch_size;\n  fw_output_size_array->data[1] = (time_major) ? batch_size : max_time;\n  fw_output_size_array->data[2] =\n      params->merge_outputs ? fw_num_units + bw_num_units : fw_num_units;\n  TF_LITE_ENSURE_OK(\n      context, context->ResizeTensor(context, fw_output, fw_output_size_array));\n  if (!params->merge_outputs) {\n    TfLiteTensor* bw_output;\n    TF_LITE_ENSURE_OK(\n        context, GetOutputSafe(context, node, kBwOutputTensor, &bw_output));\n    TfLiteIntArray* bw_output_size_array = TfLiteIntArrayCreate(3);\n    bw_output_size_array->data[0] = batch_size;\n    bw_output_size_array->data[1] = max_time;\n    bw_output_size_array->data[2] = bw_num_units;\n    TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, bw_output,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "R_API RBinJavaAttrInfo *r_bin_java_read_next_attr_from_buffer(ut8 *buffer, st64 sz, st64 buf_offset) {\n\tRBinJavaAttrInfo *attr = NULL;\n\tchar *name = NULL;\n\tut64 offset = 0;\n\tut16 name_idx;\n\tst64 nsz;\n\tRBinJavaAttrMetas *type_info = NULL;\n\n\tif (!buffer || ((int) sz) < 4 || buf_offset < 0) {\n\t\teprintf (\"r_bin_Java_read_next_attr_from_buffer: invalid buffer size %d\\n\", (int) sz);\n\t\treturn NULL;\n\t}\n\tname_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tnsz = R_BIN_JAVA_UINT (buffer, offset);\n\toffset += 4;\n\tname = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, name_idx);\n\tif (!name) {\n\t\tname = strdup (\"unknown\");\n\t}\n\tIFDBG eprintf(\"r_bin_java_read_next_attr: name_idx = %d is %s\\n\", name_idx, name);\n\ttype_info = r_bin_java_get_attr_type_by_name (name);\n\tif (type_info) {\n\t\tIFDBG eprintf(\"Typeinfo: %s, was %s\\n\", type_info->name, name);\n\t\t// printf (\"SZ %d %d %d\\n\", nsz, sz, buf_offset);\n\t\tif (nsz > sz) {\n\t\t\tfree (name);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "R_API RBinJavaAttrInfo *r_bin_java_read_next_attr_from_buffer(ut8 *buffer, st64 sz, st64 buf_offset) {\n\tRBinJavaAttrInfo *attr = NULL;\n\tut64 offset = 0;\n\tut16 name_idx;\n\tst64 nsz;\n\n\tif (!buffer || ((int) sz) < 4 || buf_offset < 0) {\n\t\teprintf (\"r_bin_Java_read_next_attr_from_buffer: invalid buffer size %d\\n\", (int) sz);\n\t\treturn NULL;\n\t}\n\tname_idx = R_BIN_JAVA_USHORT (buffer, offset);\n\toffset += 2;\n\tnsz = R_BIN_JAVA_UINT (buffer, offset);\n\toffset += 4;\n\n\tchar *name = r_bin_java_get_utf8_from_bin_cp_list (R_BIN_JAVA_GLOBAL_BIN, name_idx);\n\tif (!name) {\n\t\tname = strdup (\"unknown\");\n\t}\n\tIFDBG eprintf(\"r_bin_java_read_next_attr: name_idx = %d is %s\\n\", name_idx, name);\n\tRBinJavaAttrMetas *type_info = r_bin_java_get_attr_type_by_name (name);\n\tif (type_info) {\n\t\tIFDBG eprintf(\"Typeinfo: %s, was %s\\n\", type_info->name, name);\n\t\t// printf (\"SZ %d %d %d\\n\", nsz, sz, buf_offset);\n\t\tif (nsz > sz) {\n\t\t\tfree (name);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void fp3_write_bin(uint8_t *bin, int len, const fp3_t a) {\n\tif (len != 3 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp_write_bin(bin, RLC_FP_BYTES, a[0]);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void fp3_write_bin(uint8_t *bin, size_t len, const fp3_t a) {\n\tif (len != 3 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp_write_bin(bin, RLC_FP_BYTES, a[0]);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t    goto end;\n\t}\n\n\t/* copy the supplied context handle */\n\tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n    } else\n\tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n\n    /*\n     * get the appropriate cred handle from the union cred struct.\n     * defaults to GSS_C_NO_CREDENTIAL if there is no cred, which will\n     * use the default credential.\n\tret_flags,\n\ttime_rec);\n\n    if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n\t/*\n\t * The spec says the preferred method is to delete all context info on\n\t * the first call to init, and on all subsequent calls make the caller\n\t * responsible for calling gss_delete_sec_context.  However, if the\n\t * mechanism decided to delete the internal context, we should also\n\t * delete the union context.\n\t */\n\tmap_error(minor_status, mech);\n\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n\t    *context_handle = GSS_C_NO_CONTEXT;\n\tif (*context_handle == GSS_C_NO_CONTEXT) {\n\t    free(union_ctx_id->mech_type->elements);\n\t    free(union_ctx_id->mech_type);\n\t    free(union_ctx_id);\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t    goto end;\n\t}\n\n\t/* copy the supplied context handle */\n\tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n    } else {\n\tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n\t    status = GSS_S_NO_CONTEXT;\n\t    goto end;\n\t}\n    }\n\n    /*\n     * get the appropriate cred handle from the union cred struct.\n     * defaults to GSS_C_NO_CREDENTIAL if there is no cred, which will\n     * use the default credential.\n\tret_flags,\n\ttime_rec);\n\n    if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n\t/*\n\t * RFC 2744 5.19 requires that we not create a context on a failed\n\t * first call to init, and recommends that on a failed subsequent call\n\t * we make the caller responsible for calling gss_delete_sec_context.\n\t * Even if the mech deleted its context, keep the union context around\n\t * for the caller to delete.\n\t */\n\tmap_error(minor_status, mech);\n\tif (*context_handle == GSS_C_NO_CONTEXT) {\n\t    free(union_ctx_id->mech_type->elements);\n\t    free(union_ctx_id->mech_type);\n\t    free(union_ctx_id);\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    }\n\n    g_string_append(s, \"\\n[Service]\\nType=oneshot\\n\");\n    g_string_append_printf(s, \"ExecStart=\" SBINDIR \"/netplan apply --sriov-only\\n\");\n\n    _netplan_g_string_free_to_file(s, rootdir, path, NULL);\n\n    _netplan_safe_mkdir_p_dir(link);\n    if (symlink(path, link) < 0 && errno != EEXIST) {\n        // LCOV_EXCL_START\n        g_set_error(error, G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    }\n\n    g_string_append(s, \"\\n[Service]\\nType=oneshot\\n\");\n    g_string_append_printf(s, \"ExecStart=\" SBINDIR \"/netplan apply --sriov-only\\n\");\n\n    _netplan_g_string_free_to_file_with_permissions(s, rootdir, path, NULL, \"root\", \"root\", 0640);\n\n    _netplan_safe_mkdir_p_dir(link);\n    if (symlink(path, link) < 0 && errno != EEXIST) {\n        // LCOV_EXCL_START\n        g_set_error(error, G_MARKUP_ERROR, G_MARKUP_ERROR_INVALID_CONTENT,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "usm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval = (struct usmStateReference *)\n        calloc(1, sizeof(struct usmStateReference));\n\n    return retval;\n}                               /* end usm_malloc_usmStateReference() */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "usm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval;\n\n    retval = calloc(1, sizeof(struct usmStateReference));\n    if (retval)\n        retval->refcnt = 1;\n\n    return retval;\n}                               /* end usm_malloc_usmStateReference() */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(\n    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,\n    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {\n  ASSERT(codec_client_ != nullptr);\n  // Send the request to Envoy.\n  IntegrationStreamDecoderPtr response;\n  if (request_body_size) {\n    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);\n  } else {\n    response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  }\n  waitForNextUpstreamRequest(upstream_index);\n  // Send response headers, and end_stream if there is no response body.\n  upstream_request_->encodeHeaders(response_headers, response_size == 0);\n  // Send any response data, with end_stream true.\n  if (response_size) {\n    upstream_request_->encodeData(response_size, true);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(\n    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,\n    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index,\n    std::chrono::milliseconds time) {\n  ASSERT(codec_client_ != nullptr);\n  // Send the request to Envoy.\n  IntegrationStreamDecoderPtr response;\n  if (request_body_size) {\n    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);\n  } else {\n    response = codec_client_->makeHeaderOnlyRequest(request_headers);\n  }\n  waitForNextUpstreamRequest(upstream_index, time);\n  // Send response headers, and end_stream if there is no response body.\n  upstream_request_->encodeHeaders(response_headers, response_size == 0);\n  // Send any response data, with end_stream true.\n  if (response_size) {\n    upstream_request_->encodeData(response_size, true);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\telse\n\t\t\t\tSendMessage(hPlugins, CB_SELECTSTRING, 0, (LPARAM)_this->m_server->GetDSMPluginName());\n\n\t\t\t// Modif sf@2002\n\t\t\tSendMessage(GetDlgItem(hwnd, IDC_PLUGIN_CHECK), BM_SETCHECK, _this->m_server->IsDSMPluginEnabled(), 0);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_PLUGIN_BUTTON), _this->m_server->IsDSMPluginEnabled());\n\n\t\t\t// Query window option - Taken from TightVNC advanced properties \n\t\t\tBOOL queryEnabled = (_this->m_server->QuerySetting() == 4);\n\t\t\tSendMessage(GetDlgItem(hwnd, IDQUERY), BM_SETCHECK, queryEnabled, 0);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDQUERYTIMEOUT), queryEnabled);\n\t\t\t}\n\n\t\t// sf@2002 - DSM Plugin\n\t\tcase IDC_PLUGIN_CHECK:\n\t\t\t{\n\t\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_PLUGIN_BUTTON),\n\t\t\t\t\tSendMessage(GetDlgItem(hwnd, IDC_PLUGIN_CHECK), BM_GETCHECK, 0, 0) == BST_CHECKED);\n\t\t\t}\n\t\t\treturn TRUE;\n\t\t\t// Marscha@2004 - authSSP: moved MSLogon checkbox back to admin props page\n\t\t\t// Reason: Different UI for old and new mslogon group config.\n\t\tcase IDC_MSLOGON_CHECKD:\n\t\t\t{\n\t\t\t\tHWND hPlugin = GetDlgItem(hwnd, IDC_PLUGIN_CHECK);\n\t\t\t\tif (SendMessage(hPlugin, BM_GETCHECK, 0, 0) == BST_CHECKED)\n\t\t\t\t{\n\t\t\t\t\tTCHAR szPlugin[MAX_PATH];\n\t\t\t\t\tGetDlgItemText(hwnd, IDC_PLUGINS_COMBO, szPlugin, MAX_PATH);\n\t\t\t\t\tif (!_this->m_server->GetDSMPluginPointer()->IsLoaded())\n\t\t\t\t\t\t_this->m_server->GetDSMPluginPointer()->LoadPlugin(szPlugin, false);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// sf@2003 - We check if the loaded plugin is the same than",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\telse\n\t\t\t\tSendMessage(hPlugins, CB_SELECTSTRING, 0, (LPARAM)_this->m_server->GetDSMPluginName());\n\n\t\t\t// Modif sf@2002\n\t\t\tSendMessage(GetDlgItem(hwnd, IDC_PLUGIN_CHECK), BM_SETCHECK, _this->m_server->IsDSMPluginEnabled(), 0);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_PLUGIN_BUTTON),  (_this->m_server->AuthClientCount() == 0 ? _this->m_server->IsDSMPluginEnabled(): false));\n\n\t\t\t// Query window option - Taken from TightVNC advanced properties \n\t\t\tBOOL queryEnabled = (_this->m_server->QuerySetting() == 4);\n\t\t\tSendMessage(GetDlgItem(hwnd, IDQUERY), BM_SETCHECK, queryEnabled, 0);\n\t\t\tEnableWindow(GetDlgItem(hwnd, IDQUERYTIMEOUT), queryEnabled);\n\t\t\t}\n\n\t\t// sf@2002 - DSM Plugin\n\t\tcase IDC_PLUGIN_CHECK:\n\t\t\t{\n\t\t\t\tEnableWindow(GetDlgItem(hwnd, IDC_PLUGIN_BUTTON), _this->m_server->AuthClientCount() == 0 \n\t\t\t\t\t\t? SendMessage(GetDlgItem(hwnd, IDC_PLUGIN_CHECK), BM_GETCHECK, 0, 0) == BST_CHECKED \n\t\t\t\t\t\t: BST_UNCHECKED);\n\t\t\t}\n\t\t\treturn TRUE;\n\t\t\t// Marscha@2004 - authSSP: moved MSLogon checkbox back to admin props page\n\t\t\t// Reason: Different UI for old and new mslogon group config.\n\t\tcase IDC_MSLOGON_CHECKD:\n\t\t\t\tHWND hPlugin = GetDlgItem(hwnd, IDC_PLUGIN_CHECK);\n\t\t\t\tif (SendMessage(hPlugin, BM_GETCHECK, 0, 0) == BST_CHECKED)\n\t\t\t\t{\n\t\t\t\t\tTCHAR szPlugin[MAX_PATH];\n\t\t\t\t\tGetDlgItemText(hwnd, IDC_PLUGINS_COMBO, szPlugin, MAX_PATH);\n\t\t\t\t\tPathStripPathA(szPlugin);\n\n\t\t\t\t\tif (!_this->m_server->GetDSMPluginPointer()->IsLoaded())\n\t\t\t\t\t\t_this->m_server->GetDSMPluginPointer()->LoadPlugin(szPlugin, false);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// sf@2003 - We check if the loaded plugin is the same than",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void ZlibInStream::deinit()\n{\n  assert(zs != NULL);\n  removeUnderlying();\n  inflateEnd(zs);\n  delete zs;\n  zs = NULL;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void ZlibInStream::deinit()\n{\n  assert(zs != NULL);\n  setUnderlying(NULL, 0);\n  inflateEnd(zs);\n  delete zs;\n  zs = NULL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      dprint (1, (debugfile, \"Error receiving server response.\\n\"));\n      gss_release_name (&min_stat, &target_name);\n      goto bail;\n    }\n\n    request_buf.length = mutt_from_base64 (buf2, idata->buf + 2);\n    request_buf.value = buf2;\n    sec_token = &request_buf;\n\n    /* Write client data */\n    maj_stat = gss_init_sec_context (&min_stat, GSS_C_NO_CREDENTIAL, &context,\n  if (rc != IMAP_CMD_RESPOND)\n  {\n    dprint (1, (debugfile, \"Error receiving server response.\\n\"));\n    goto bail;\n  }\n  request_buf.length = mutt_from_base64 (buf2, idata->buf + 2);\n  request_buf.value = buf2;\n\n  maj_stat = gss_unwrap (&min_stat, context, &request_buf, &send_token,\n    &cflags, &quality);\n  if (maj_stat != GSS_S_COMPLETE)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      dprint (1, (debugfile, \"Error receiving server response.\\n\"));\n      gss_release_name (&min_stat, &target_name);\n      goto bail;\n    }\n\n    request_buf.length = mutt_from_base64 (buf2, idata->buf + 2, sizeof(buf2));\n    request_buf.value = buf2;\n    sec_token = &request_buf;\n\n    /* Write client data */\n    maj_stat = gss_init_sec_context (&min_stat, GSS_C_NO_CREDENTIAL, &context,\n  if (rc != IMAP_CMD_RESPOND)\n  {\n    dprint (1, (debugfile, \"Error receiving server response.\\n\"));\n    goto bail;\n  }\n  request_buf.length = mutt_from_base64 (buf2, idata->buf + 2, sizeof(buf2));\n  request_buf.value = buf2;\n\n  maj_stat = gss_unwrap (&min_stat, context, &request_buf, &send_token,\n    &cflags, &quality);\n  if (maj_stat != GSS_S_COMPLETE)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\nagain:\n\tmutex_lock(&gts->ts_ctxlock);\n\tpreempt_disable();\n\n\tgru_check_context_placement(gts);\n\n\tif (!gts->ts_gru) {\n\t\tSTAT(load_user_context);\n\t\tif (!gru_assign_gru_context(gts)) {\n\t\t\tpreempt_enable();",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\nagain:\n\tmutex_lock(&gts->ts_ctxlock);\n\tpreempt_disable();\n\n\tif (gru_check_context_placement(gts)) {\n\t\tpreempt_enable();\n\t\tmutex_unlock(&gts->ts_ctxlock);\n\t\tgru_unload_context(gts, 1);\n\t\treturn VM_FAULT_NOPAGE;\n\t}\n\n\tif (!gts->ts_gru) {\n\t\tSTAT(load_user_context);\n\t\tif (!gru_assign_gru_context(gts)) {\n\t\t\tpreempt_enable();",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    pos_T\tfound_pos;\n    int\t\tfound_len = 0;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\t*endp;\n    hlf_T\tattr;\n    int\t\tlen;\n#ifdef FEAT_SYN_HL\n    int\t\thas_syntax = syntax_present(wp);\n#endif\n    int\t\tcol;\n     */\n    lnum = wp->w_cursor.lnum;\n    CLEAR_POS(&found_pos);\n\n    while (!got_int)\n    {\n\tline = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\n\tlen = (int)STRLEN(line);\n\tif (buflen < len + MAXWLEN + 2)\n\t{\n\t    // one.\n\t    line = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\t}\n\n\t// Copy the line into \"buf\" and append the start of the next line if\n\t// possible.\n\tSTRCPY(buf, line);\n\tif (lnum < wp->w_buffer->b_ml.ml_line_count)\n\t    spell_cat_line(buf + STRLEN(buf),\n\t\t\t  ml_get_buf(wp->w_buffer, lnum + 1, FALSE), MAXWLEN);\n\n\n\t    // Capcol skips over the inserted space.\n\t    --capcol;\n\n\t    // But after empty line check first word in next line\n\t    if (*skipwhite(line) == NUL)\n\t\tcapcol = 0;\n\t}\n\n\tline_breakcheck();\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    pos_T\tfound_pos;\n    int\t\tfound_len = 0;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\t*endp;\n    hlf_T\tattr = 0;\n    int\t\tlen;\n#ifdef FEAT_SYN_HL\n    int\t\thas_syntax = syntax_present(wp);\n#endif\n    int\t\tcol;\n    lnum = wp->w_cursor.lnum;\n    CLEAR_POS(&found_pos);\n\n    while (!got_int)\n    {\n\tint empty_line;\n\n\tline = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\n\tlen = (int)STRLEN(line);\n\tif (buflen < len + MAXWLEN + 2)\n\t{\n\t    // one.\n\t    line = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\t}\n\n\t// Copy the line into \"buf\" and append the start of the next line if\n\t// possible.  Note: this ml_get_buf() may make \"line\" invalid, check\n\t// for empty line first.\n\tempty_line = *skipwhite(line) == NUL;\n\tSTRCPY(buf, line);\n\tif (lnum < wp->w_buffer->b_ml.ml_line_count)\n\t    spell_cat_line(buf + STRLEN(buf),\n\t\t\t  ml_get_buf(wp->w_buffer, lnum + 1, FALSE), MAXWLEN);\n\n\n\t    // Capcol skips over the inserted space.\n\t    --capcol;\n\n\t    // But after empty line check first word in next line\n\t    if (empty_line)\n\t\tcapcol = 0;\n\t}\n\n\tline_breakcheck();\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tif (proto == IPPROTO_UDP &&\n\t\t    (rt->dst.dev->features & NETIF_F_UFO)) {\n\n\t\t\terr = ip6_ufo_append_data(sk, getfrag, from, length,\n\t\t\t\t\t\t  hh_len, fragheaderlen,\n\t\t\t\t\t\t  transhdrlen, mtu, flags);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\treturn 0;\n\t\t}\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tif (proto == IPPROTO_UDP &&\n\t\t    (rt->dst.dev->features & NETIF_F_UFO)) {\n\n\t\t\terr = ip6_ufo_append_data(sk, getfrag, from, length,\n\t\t\t\t\t\t  hh_len, fragheaderlen,\n\t\t\t\t\t\t  transhdrlen, mtu, flags, rt);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\treturn 0;\n\t\t}\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "DWORD NSISCALL CreateRestrictedDirectory(LPCTSTR path)\n{\n  const SECURITY_INFORMATION si = OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION|DACL_SECURITY_INFORMATION|PROTECTED_DACL_SECURITY_INFORMATION;\n  PSID admingrpsid = GetAdminGrpSid();\n  SECURITY_DESCRIPTOR sd = { 1, 0, SE_DACL_PRESENT, admingrpsid, admingrpsid, NULL, GetAdminGrpAcl() };\n  SECURITY_ATTRIBUTES sa = { sizeof(SECURITY_ATTRIBUTES), &sd, FALSE };\n  DWORD ec = CreateDirectory(path, &sa) ? ERROR_SUCCESS : GetLastError();\n  if (ERROR_ALREADY_EXISTS == ec)\n    ec = SetFileSecurity(path, si, &sd) ? ERROR_SUCCESS : GetLastError();\n  return ec;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "DWORD NSISCALL CreateRestrictedDirectory(LPCTSTR path)\n{\n  PSID admingrpsid = GetAdminGrpSid();\n  SECURITY_DESCRIPTOR sd = { 1, 0, SE_DACL_PRESENT, admingrpsid, admingrpsid, NULL, GetAdminGrpAcl() };\n  SECURITY_ATTRIBUTES sa = { sizeof(SECURITY_ATTRIBUTES), &sd, FALSE };\n  return CreateDirectory(path, &sa) ? ERROR_SUCCESS : GetLastError();\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n    i = OBJ_obj2nid(p7->type);\n    p7->state = PKCS7_S_HEADER;\n\n    switch (i) {\n    case NID_pkcs7_signed:\n        data_body = PKCS7_get_octet_string(p7->d.sign->contents);\n        if (!PKCS7_is_detached(p7) && data_body == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_INVALID_SIGNED_DATA_TYPE);\n            goto err;\n        }\n        md_sk = p7->d.sign->md_algs;\n        break;\n    case NID_pkcs7_signedAndEnveloped:\n        rsk = p7->d.signed_and_enveloped->recipientinfo;\n        md_sk = p7->d.signed_and_enveloped->md_algs;\n        data_body = p7->d.signed_and_enveloped->enc_data->enc_data;\n        enc_alg = p7->d.signed_and_enveloped->enc_data->algorithm;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n            goto err;\n        }\n        break;\n    case NID_pkcs7_enveloped:\n        rsk = p7->d.enveloped->recipientinfo;\n        enc_alg = p7->d.enveloped->enc_data->algorithm;\n        data_body = p7->d.enveloped->enc_data->enc_data;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    default:\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\n        goto err;\n    }\n\n    /* We will be checking the signature */\n    if (md_sk != NULL) {\n            out = etmp;\n        else\n            BIO_push(out, etmp);\n        etmp = NULL;\n    }\n    if (PKCS7_is_detached(p7) || (in_bio != NULL)) {\n        bio = in_bio;\n    } else {\n        if (data_body->length > 0)\n            bio = BIO_new_mem_buf(data_body->data, data_body->length);\n        else {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    i = OBJ_obj2nid(p7->type);\n    p7->state = PKCS7_S_HEADER;\n\n    switch (i) {\n    case NID_pkcs7_signed:\n        /*\n         * p7->d.sign->contents is a PKCS7 structure consisting of a contentType\n         * field and optional content.\n         * data_body is NULL if that structure has no (=detached) content\n         * or if the contentType is wrong (i.e., not \"data\").\n         */\n        data_body = PKCS7_get_octet_string(p7->d.sign->contents);\n        if (!PKCS7_is_detached(p7) && data_body == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_INVALID_SIGNED_DATA_TYPE);\n            goto err;\n        md_sk = p7->d.sign->md_algs;\n        break;\n    case NID_pkcs7_signedAndEnveloped:\n        rsk = p7->d.signed_and_enveloped->recipientinfo;\n        md_sk = p7->d.signed_and_enveloped->md_algs;\n        /* data_body is NULL if the optional EncryptedContent is missing. */\n        data_body = p7->d.signed_and_enveloped->enc_data->enc_data;\n        enc_alg = p7->d.signed_and_enveloped->enc_data->algorithm;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n        }\n        break;\n    case NID_pkcs7_enveloped:\n        rsk = p7->d.enveloped->recipientinfo;\n        enc_alg = p7->d.enveloped->enc_data->algorithm;\n        /* data_body is NULL if the optional EncryptedContent is missing. */\n        data_body = p7->d.enveloped->enc_data->enc_data;\n        evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n        if (evp_cipher == NULL) {\n            PKCS7err(PKCS7_F_PKCS7_DATADECODE,\n                     PKCS7_R_UNSUPPORTED_CIPHER_TYPE);\n            goto err;\n        }\n        break;\n    default:\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_UNSUPPORTED_CONTENT_TYPE);\n        goto err;\n    }\n\n    /* Detached content must be supplied via in_bio instead. */\n    if (data_body == NULL && in_bio == NULL) {\n        PKCS7err(PKCS7_F_PKCS7_DATADECODE, PKCS7_R_NO_CONTENT);\n        goto err;\n    }\n\n    /* We will be checking the signature */\n    if (md_sk != NULL) {\n            out = etmp;\n        else\n            BIO_push(out, etmp);\n        etmp = NULL;\n    }\n    if (in_bio != NULL) {\n        bio = in_bio;\n    } else {\n        if (data_body->length > 0)\n            bio = BIO_new_mem_buf(data_body->data, data_body->length);\n        else {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t/*\n\t * If unsharing a user namespace must also unshare the thread.\n\t */\n\tif (unshare_flags & CLONE_NEWUSER)\n\t\tunshare_flags |= CLONE_THREAD;\n\t/*\n\t * If unsharing a pid namespace must also unshare the thread.\n\t */\n\tif (unshare_flags & CLONE_NEWPID)\n\t\tunshare_flags |= CLONE_THREAD;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\t/*\n\t * If unsharing a user namespace must also unshare the thread.\n\t */\n\tif (unshare_flags & CLONE_NEWUSER)\n\t\tunshare_flags |= CLONE_THREAD | CLONE_FS;\n\t/*\n\t * If unsharing a pid namespace must also unshare the thread.\n\t */\n\tif (unshare_flags & CLONE_NEWPID)\n\t\tunshare_flags |= CLONE_THREAD;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static u32 crc32sum(u32 crc, u8 * RESTRICT buf, size_t size) {\n    while (size--) crc = crc32Table[(crc ^ *(buf++)) & 0xff] ^ (crc >> 8);\n    return crc;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static u32 crc32sum(u32 crc, u8 * RESTRICT buf, size_t size) {\n    // Test endianness. The code needs to be different for LE and BE systems.\n    u32 test = 1;\n    if (*(u8 *) &test) {\n        while (size--) crc = crc32Table[(crc ^ *(buf++)) & 0xff] ^ (crc >> 8);\n        return crc;\n    } else {\n        while (size--) crc = crc32Table[((crc >> 24) ^ *(buf++)) & 0xff] ^ (crc << 8);\n        return crc;\n    }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tint result;\n\tstruct sockaddr_in addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(port);\n\n\taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tint result;\n\tstruct sockaddr_in addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\taddr.sin_port = htons(port);\n\n\taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    char *key = 0;\n    char *typespec = 0;\n    unsigned char doc_stack[DOC_STACK_SIZE];\n    size_t doc_stack_pointer = 0;\n    size_t array_index = 0;\n    unsigned int array_index_stack[ARRAY_INDEX_STACK_SIZE];\n    size_t array_index_stack_pointer = 0;\n    char array_index_buffer[ARRAY_INDEX_BUFFER_SIZE]; /* max BSON size */\n    int end_of_data;\n    const bcon *bcp;\n    for (end_of_data = 0, bcp = bc; ret == BCON_OK && !end_of_data; bcp++) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    char *key = 0;\n    char *typespec = 0;\n    unsigned char doc_stack[DOC_STACK_SIZE];\n    size_t doc_stack_pointer = 0;\n    size_t array_index = 0;\n    size_t array_index_stack[ARRAY_INDEX_STACK_SIZE];\n    size_t array_index_stack_pointer = 0;\n    char array_index_buffer[ARRAY_INDEX_BUFFER_SIZE]; /* max BSON size */\n    int end_of_data;\n    const bcon *bcp;\n    for (end_of_data = 0, bcp = bc; ret == BCON_OK && !end_of_data; bcp++) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n    //if (block->host) {\n    //    ram_block_notify_remove(block->host, block->max_length);\n    //}\n\n    QLIST_REMOVE(block, next);\n    uc->ram_list.mru_block = NULL;\n    /* Write list before version */\n    //smp_wmb();\n    // call_rcu(block, reclaim_ramblock, rcu);\n    reclaim_ramblock(uc, block);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n    //if (block->host) {\n    //    ram_block_notify_remove(block->host, block->max_length);\n    //}\n\n    QLIST_REMOVE_RCU(block, next);\n    uc->ram_list.mru_block = NULL;\n    /* Write list before version */\n    //smp_wmb();\n    // call_rcu(block, reclaim_ramblock, rcu);\n    reclaim_ramblock(uc, block);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tswitch(tga->bits) {\n\tcase 8:\n\tcase 16:\n\tcase 24:\n\tcase 32:\n\t\tbreak;\n\tdefault:\n\t\tgd_error(\"bps %i not supported\", tga->bits);\n\t\treturn -1;\n\t\tbreak;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tprintf(\"flip h/v: %i / %i\\n\", tga->fliph, tga->flipv);\n\tprintf(\"alpha: %i\\n\", tga->alphabits);\n\tprintf(\"wxh: %i %i\\n\", tga->width, tga->height);\n#endif\n\n\tif (!((tga->bits == TGA_BPP_24 && tga->alphabits == 0)\n\t\t|| (tga->bits == TGA_BPP_32 && tga->alphabits == 8)))\n\t{\n\t\tgd_error_ex(GD_WARNING, \"gd-tga: %u bits per pixel with %u alpha bits not supported\\n\",\n\t\t\ttga->bits, tga->alphabits);\n\t\treturn -1;\n\t}\n\n\ttga->ident = NULL;\n\n\tif (tga->identsize > 0) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif (vps_id >= 16) {\n\t\treturn -1;\n\t}\n\tmemset(&ptl, 0, sizeof(ptl));\n\tmax_sub_layers_minus1 = 0;\n\tsps_ext_or_max_sub_layers_minus1 = 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\t//nalu header already parsed\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif ((vps_id<0) || (vps_id >= 16)) {\n\t\treturn -1;\n\t}\n\tmemset(&ptl, 0, sizeof(ptl));\n\tmax_sub_layers_minus1 = 0;\n\tsps_ext_or_max_sub_layers_minus1 = 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "_isBidi (const uint32_t *label, size_t llen)\n{\n  while (llen-- > 0) {\n    int bc = uc_bidi_category (*label++);\n\n    if (bc == UC_BIDI_R || bc == UC_BIDI_AL || bc == UC_BIDI_AN)\n      return 1;\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "_isBidi (const uint32_t *label, size_t llen)\n{\n  for (; (ssize_t) llen > 0; llen--) {\n    int bc = uc_bidi_category (*label++);\n\n    if (bc == UC_BIDI_R || bc == UC_BIDI_AL || bc == UC_BIDI_AN)\n      return 1;\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t * Use xrstors to restore context if it is enabled. xrstors supports\n\t * compacted format of xsave area which is not supported by xrstor.\n\t */\n\talternative_input(\n\t\t\"1: \" XRSTOR,\n\t\t\"1: \" XRSTORS,\n\t\tX86_FEATURE_XSAVES,\n\t\t\"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t: \"memory\");\n\n\tasm volatile(\"2:\\n\"",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t * Use xrstors to restore context if it is enabled. xrstors supports\n\t * compacted format of xsave area which is not supported by xrstor.\n\t */\n\talternative_input(\n\t\t\"1: \" XRSTOR,\n\t\tXRSTORS,\n\t\tX86_FEATURE_XSAVES,\n\t\t\"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t: \"memory\");\n\n\tasm volatile(\"2:\\n\"",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "tsl::StatusOr<Platform*> MultiPlatformManagerImpl::LookupByIdLocked(\n    const Platform::Id& id) {\n  auto it = id_map_.find(id);\n  if (it == id_map_.end()) {\n    return tsl::Status(\n        port::error::NOT_FOUND,\n        absl::StrFormat(\"could not find registered platform with id: %p\", id));\n  }\n  return it->second;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "tsl::StatusOr<Platform*> MultiPlatformManagerImpl::LookupByIdLocked(\n    const Platform::Id& id) {\n  auto it = id_map_.find(id);\n  if (it == id_map_.end()) {\n    return tsl::Status(\n        tsl::error::NOT_FOUND,\n        absl::StrFormat(\"could not find registered platform with id: %p\", id));\n  }\n  return it->second;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "PJ_DEF(void) pjsip_auth_create_digest( pj_str_t *result,\n\t\t\t\t       const pj_str_t *nonce,\n\t\t\t\t       const pj_str_t *nc,\n\t\t\t\t       const pj_str_t *cnonce,\n\t\t\t\t       const pj_str_t *qop,\n\t\t\t\t       const pj_str_t *uri,\n\t\t\t\t       const pj_str_t *realm,\n\t\t\t\t       const pjsip_cred_info *cred_info,\n\t\t\t\t       const pj_str_t *method)\n{\n    char ha1[PJSIP_MD5STRLEN];\n    char ha2[PJSIP_MD5STRLEN];\n    unsigned char digest[16];\n    pj_md5_context pms;\n\tpj_md5_final(&pms, digest);\n\n\tdigestNtoStr(digest, 16, ha1);\n\n    } else if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_DIGEST) {\n\tpj_assert(cred_info->data.slen == 32);\n\tpj_memcpy( ha1, cred_info->data.ptr, cred_info->data.slen );\n    } else {\n\tpj_assert(!\"Invalid data_type\");\n    }\n\n    AUTH_TRACE_((THIS_FILE, \"  ha1=%.32s\", ha1));\n\n    /***\n    /* Convert digest to string and store in chal->response. */\n    result->slen = PJSIP_MD5STRLEN;\n    digestNtoStr(digest, 16, result->ptr);\n\n    AUTH_TRACE_((THIS_FILE, \"  digest=%.32s\", result->ptr));\n    AUTH_TRACE_((THIS_FILE, \"Digest created\"));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "PJ_DEF(pj_status_t) pjsip_auth_create_digest( pj_str_t *result,\n\t\t\t\t\t      const pj_str_t *nonce,\n\t\t\t\t\t      const pj_str_t *nc,\n\t\t\t\t\t      const pj_str_t *cnonce,\n\t\t\t\t\t      const pj_str_t *qop,\n\t\t\t\t\t      const pj_str_t *uri,\n\t\t\t\t\t      const pj_str_t *realm,\n\t\t\t\t\t      const pjsip_cred_info *cred_info,\n\t\t\t\t\t      const pj_str_t *method)\n{\n    char ha1[PJSIP_MD5STRLEN];\n    char ha2[PJSIP_MD5STRLEN];\n    unsigned char digest[16];\n    pj_md5_context pms;\n\tpj_md5_final(&pms, digest);\n\n\tdigestNtoStr(digest, 16, ha1);\n\n    } else if ((cred_info->data_type & PASSWD_MASK) == PJSIP_CRED_DATA_DIGEST) {\n\tif (cred_info->data.slen != 32) {\n\t    pj_assert(!\"Invalid cred_info data length\");\n\t    pj_bzero(result->ptr, result->slen);\n\t    result->slen = 0;\n\t    return PJ_EINVAL;\n\t}\n\tpj_memcpy( ha1, cred_info->data.ptr, cred_info->data.slen );\n    } else {\n\tpj_assert(!\"Invalid data_type\");\n\tpj_bzero(result->ptr, result->slen);\n\tresult->slen = 0;\n\treturn PJ_EINVAL;\n    }\n\n    AUTH_TRACE_((THIS_FILE, \"  ha1=%.32s\", ha1));\n\n    /***\n    result->slen = PJSIP_MD5STRLEN;\n    digestNtoStr(digest, 16, result->ptr);\n\n    AUTH_TRACE_((THIS_FILE, \"  digest=%.32s\", result->ptr));\n    AUTH_TRACE_((THIS_FILE, \"Digest created\"));\n    return PJ_SUCCESS;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    const std::unordered_map<std::string, std::string> &getCookies() const\n    {\n        return cookies();\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "            &getCookies() const\n    {\n        return cookies();\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tif (mapping_writably_mapped(mapping))\n\t\t\tflush_dcache_page(page);\n\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tflush_dcache_page(page);\n\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = tmp;\n\t\treq->num_pages++;\n\n\t\tiov_iter_advance(ii, tmp);\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tflush_dcache_page(page);\n\n\t\ttmp = iov_iter_copy_from_user_atomic(page, ii, offset, bytes);\n\t\tflush_dcache_page(page);\n\n\t\tiov_iter_advance(ii, tmp);\n\t\tif (!tmp) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tbytes = min(bytes, iov_iter_single_seg_count(ii));\n\t\t\tgoto again;\n\n\t\terr = 0;\n\t\treq->pages[req->num_pages] = page;\n\t\treq->page_descs[req->num_pages].length = tmp;\n\t\treq->num_pages++;\n\n\t\tcount += tmp;\n\t\tpos += tmp;\n\t\toffset += tmp;\n\t\tif (offset == PAGE_CACHE_SIZE)\n\t\t\toffset = 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void ep2_mul_sim_endom(ep2_t r, const ep2_t p, const bn_t k, ep2_t q,\n\t\tconst bn_t m) {\n\tint i, j, l, _l[4];\n\tbn_t _k[4], _m[4], n, u;\n\tint8_t naf0[4][RLC_FP_BITS + 1];\n\tint8_t naf1[4][RLC_FP_BITS + 1];\n\tep2_t _p[4], _q[4];\n\n\tbn_null(u);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(u);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbn_null(_k[i]);\n\t\t\tbn_new(_k[i]);\n\t\t\tbn_null(_m[i]);\n\t\t\tbn_new(_m[i]);\n\t\t\tep2_null(_p[i]);\n\t\tbn_rec_frb(_k, 4, _k[0], u, n, ep_curve_is_pairf() == EP_BN);\n\t\tbn_mod(_m[0], m, n);\n\t\tbn_rec_frb(_m, 4, _m[0], u, n, ep_curve_is_pairf() == EP_BN);\n\n\t\tl = 0;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\tbn_rec_naf(naf0[i], &_l[i], _k[i], 2);\n\t\t\tif (bn_sign(_k[i]) == RLC_NEG) {\n\t\t\t\tep2_neg(_p[i], _p[i]);\n\t\t\t}\n\t\t\t}\n\t\t\tl = RLC_MAX(l, _l[i]);\n\t\t}\n\n\t\tep2_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tep2_dbl(r, r);\n\t\t\tfor (j = 0; j < 4; j++) {\n\t\t\t\tif (naf0[j][i] > 0) {\n\t\t\t\t\tep2_add(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t\tif (naf0[j][i] < 0) {\n\t\t\t\t\tep2_sub(r, r, _p[j]);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(u);\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tbn_free(_k[i]);\n\t\t\tbn_free(_m[i]);\n\t\t\tep2_free(_p[i]);\n\t\t\tep2_free(_q[i]);\n\t\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void ep2_mul_sim_endom(ep2_t r, const ep2_t p, const bn_t k, ep2_t q,\n\t\tconst bn_t m) {\n\tsize_t l, _l[4];\n\tbn_t _k[4], _m[4], n, u;\n\tint8_t naf0[4][RLC_FP_BITS + 1];\n\tint8_t naf1[4][RLC_FP_BITS + 1];\n\tep2_t _p[4], _q[4];\n\n\tbn_null(u);\n\n\tRLC_TRY {\n\t\tbn_new(n);\n\t\tbn_new(u);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tbn_null(_k[i]);\n\t\t\tbn_new(_k[i]);\n\t\t\tbn_null(_m[i]);\n\t\t\tbn_new(_m[i]);\n\t\t\tep2_null(_p[i]);\n\t\tbn_rec_frb(_k, 4, _k[0], u, n, ep_curve_is_pairf() == EP_BN);\n\t\tbn_mod(_m[0], m, n);\n\t\tbn_rec_frb(_m, 4, _m[0], u, n, ep_curve_is_pairf() == EP_BN);\n\n\t\tl = 0;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t_l[i] = RLC_FP_BITS + 1;\n\t\t\tbn_rec_naf(naf0[i], &_l[i], _k[i], 2);\n\t\t\tif (bn_sign(_k[i]) == RLC_NEG) {\n\t\t\t\tep2_neg(_p[i], _p[i]);\n\t\t\t}\n\t\t\t}\n\t\t\tl = RLC_MAX(l, _l[i]);\n\t\t}\n\n\t\tep2_set_infty(r);\n\t\tfor (int i = l - 1; i >= 0; i--) {\n\t\t\tep2_dbl(r, r);\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tif (naf0[j][i] > 0) {\n\t\t\t\t\tep2_add(r, r, _p[j]);\n\t\t\t\t}\n\t\t\t\tif (naf0[j][i] < 0) {\n\t\t\t\t\tep2_sub(r, r, _p[j]);\n\t} RLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t} RLC_FINALLY {\n\t\tbn_free(n);\n\t\tbn_free(u);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tbn_free(_k[i]);\n\t\t\tbn_free(_m[i]);\n\t\t\tep2_free(_p[i]);\n\t\t\tep2_free(_q[i]);\n\t\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteSpaceToDepthParams*>(node->builtin_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n#define TF_LITE_SPACE_TO_DEPTH(type, scalar)                               \\\n  tflite::SpaceToDepthParams op_params;                                    \\\n  op_params.block_size = params->block_size;                               \\\n  type::SpaceToDepth(op_params, GetTensorShape(input),                     \\",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteSpaceToDepthParams*>(node->builtin_data);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n#define TF_LITE_SPACE_TO_DEPTH(type, scalar)                               \\\n  tflite::SpaceToDepthParams op_params;                                    \\\n  op_params.block_size = params->block_size;                               \\\n  type::SpaceToDepth(op_params, GetTensorShape(input),                     \\",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static size_t ntlm_av_pair_get_next_offset(NTLM_AV_PAIR* pAvPair)\n{\n\treturn ntlm_av_pair_get_len(pAvPair) + sizeof(NTLM_AV_PAIR);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static BOOL ntlm_av_pair_get_next_offset(const NTLM_AV_PAIR* pAvPair, size_t size, size_t* pOffset)\n{\n\tsize_t avLen;\n\tif (!pOffset)\n\t\treturn FALSE;\n\n\tif (!ntlm_av_pair_get_len(pAvPair, size, &avLen))\n\t\treturn FALSE;\n\t*pOffset = avLen + sizeof(NTLM_AV_PAIR);\n\treturn TRUE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long debugctlmsr;\n\n\t/* Record the guest's net vcpu time for enforced NMI injections. */\n\tif (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked))\n\t\tvmx->entry_time = ktime_get();\n\n\t}\n\n\tif (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n\tif (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n\n\t/* When single-stepping over STI and MOV SS, we must clear the\n\t * corresponding interruptibility bits in the guest state. Otherwise\n\t * vmentry fails as it then expects bit 14 (BS) in pending debug\n\t * exceptions being set, but that's not correct for the guest debugging",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long debugctlmsr, cr4;\n\n\t/* Record the guest's net vcpu time for enforced NMI injections. */\n\tif (unlikely(!cpu_has_virtual_nmis() && vmx->soft_vnmi_blocked))\n\t\tvmx->entry_time = ktime_get();\n\n\n\tif (test_bit(VCPU_REGS_RSP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n\tif (test_bit(VCPU_REGS_RIP, (unsigned long *)&vcpu->arch.regs_dirty))\n\t\tvmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n\n\tcr4 = read_cr4();\n\tif (unlikely(cr4 != vmx->host_state.vmcs_host_cr4)) {\n\t\tvmcs_writel(HOST_CR4, cr4);\n\t\tvmx->host_state.vmcs_host_cr4 = cr4;\n\t}\n\n\t/* When single-stepping over STI and MOV SS, we must clear the\n\t * corresponding interruptibility bits in the guest state. Otherwise\n\t * vmentry fails as it then expects bit 14 (BS) in pending debug\n\t * exceptions being set, but that's not correct for the guest debugging",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    if(SSL_CONN_CONFIG(cipher_list)) {\n      result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list));\n      if(CURLE_OK != result) {\n        failf(data, \"Unable to set ciphers to passed via SSL_CONN_CONFIG\");\n        return result;\n      }\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      failf(data, \"Unrecognized parameter passed via CURLOPT_SSLVERSION\");\n      return CURLE_SSL_CONNECT_ERROR;\n    }\n\n    if(SSL_CONN_CONFIG(cipher_list)) {\n      result = set_ssl_ciphers(&schannel_cred, SSL_CONN_CONFIG(cipher_list),\n                               BACKEND->algIds);\n      if(CURLE_OK != result) {\n        failf(data, \"Unable to set ciphers to passed via SSL_CONN_CONFIG\");\n        return result;\n      }\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "raw_copy_to_user(void __user *dst, const void *src, unsigned long size)\n{\n\tint ret = 0;\n\n\tif (!__builtin_constant_p(size))\n\t\treturn copy_user_generic((__force void *)dst, src, size);\n\tswitch (size) {\n\tcase 1:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u8 *)src, (u8 __user *)dst,\n\t\t\t      ret, \"b\", \"b\", \"iq\", 1);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 2:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u16 *)src, (u16 __user *)dst,\n\t\t\t      ret, \"w\", \"w\", \"ir\", 2);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 4:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u32 *)src, (u32 __user *)dst,\n\t\t\t      ret, \"l\", \"k\", \"ir\", 4);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 8:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u64 *)src, (u64 __user *)dst,\n\t\t\t      ret, \"q\", \"\", \"er\", 8);\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 10:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u64 *)src, (u64 __user *)dst,\n\t\t\t       ret, \"q\", \"\", \"er\", 10);\n\t\tif (likely(!ret)) {\n\t\t\tasm(\"\":::\"memory\");\n\t\t\t__put_user_asm(4[(u16 *)src], 4 + (u16 __user *)dst,\n\t\t\t\t       ret, \"w\", \"w\", \"ir\", 2);\n\t\t}\n\t\t__uaccess_end();\n\t\treturn ret;\n\tcase 16:\n\t\t__uaccess_begin();\n\t\t__put_user_asm(*(u64 *)src, (u64 __user *)dst,\n\t\t\t       ret, \"q\", \"\", \"er\", 16);\n\t\tif (likely(!ret)) {\n\t\t\tasm(\"\":::\"memory\");\n\t\t\t__put_user_asm(1[(u64 *)src], 1 + (u64 __user *)dst,\n\t\t\t\t       ret, \"q\", \"\", \"er\", 8);\n\t\t}\n\t\t__uaccess_end();\n\t\treturn ret;\n\tdefault:\n\t\treturn copy_user_generic((__force void *)dst, src, size);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "raw_copy_to_user(void __user *dst, const void *src, unsigned long size)\n{\n\treturn copy_user_generic((__force void *)dst, src, size);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    Inivars();\n    argc--;\n    axohelp = *argv++;\n    if ( argc <= 0 ) {\n        PrintHelp(axohelp);\n\treturn -1;\n    }\n    while ( (*argv)[0] == '-' ) {   /* we have options */\n        s = *argv;\n        if ( s[1] == '-' ) {\n  \t    /* Double \"--\", treat as \"-\" */\n            VerboseFlag = 1;\n        }\n        else {\n \t    fprintf(stderr,\"%s: Illegal option %s\\n\", axohelp, *argv);\n            PrintHelpPrompt(axohelp);\n\t    return -1;\n        }\n        argc--; argv++;\n        if ( argc <= 0 ) {\n            fprintf(stderr,\"%s: Not enough arguments\\n\",axohelp);\n            PrintHelpPrompt(axohelp);\n\t    return -1;\n        }\n    }\n    if ( argc != 1 ) {\n        fprintf(stderr,\"%s: Too many arguments\\n\",axohelp);\n        PrintHelpPrompt(axohelp);\n        return -1;\n    }\n/*\n    The filename is now in s. We copy it to a separate string and\n    paste on the extension .ax1 (if needed), and construct the\n    name of the output file.\n    }\n    else {\n        strcpy( inname+length, \".ax1\" );\n        strcpy( outname+length, \".ax2\" );\n    }\n    if ( ( inbuffer = ReadInput(inname) ) == 0 ) return(-1);\n    if ( ( outfile = fopen(outname,\"w\") ) == 0 ) {\n        fprintf(stderr,\"%s: Cannot create file %s\\n\",axohelp,outname);\n        exit(-1);\n    }\n    num = ScanForObjects(inbuffer);\n    for ( i = 0; i < num; i++ ) {\n        numobject = i+1;\n        if ( DoOneObject(inputs[i]) < 0 ) { error++; }\n    }\n    fclose(outfile);\n    if ( error > 0 ) {\n        fprintf(stderr,\"%s: %d objects in %s were not translated correctly.\\n\",\n            axohelp,error,inname);\n        return(-1);\n    }\n    return(0);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    Inivars();\n    argc--;\n    axohelp = *argv++;\n    if ( argc <= 0 ) {\n        PrintHelp(axohelp);\n\treturn 1;\n    }\n    while ( (*argv)[0] == '-' ) {   /* we have options */\n        s = *argv;\n        if ( s[1] == '-' ) {\n  \t    /* Double \"--\", treat as \"-\" */\n            VerboseFlag = 1;\n        }\n        else {\n \t    fprintf(stderr,\"%s: Illegal option %s\\n\", axohelp, *argv);\n            PrintHelpPrompt(axohelp);\n\t    return 1;\n        }\n        argc--; argv++;\n        if ( argc <= 0 ) {\n            fprintf(stderr,\"%s: Not enough arguments\\n\",axohelp);\n            PrintHelpPrompt(axohelp);\n\t    return 1;\n        }\n    }\n    if ( argc != 1 ) {\n        fprintf(stderr,\"%s: Too many arguments\\n\",axohelp);\n        PrintHelpPrompt(axohelp);\n        return 1;\n    }\n/*\n    The filename is now in s. We copy it to a separate string and\n    paste on the extension .ax1 (if needed), and construct the\n    name of the output file.\n    }\n    else {\n        strcpy( inname+length, \".ax1\" );\n        strcpy( outname+length, \".ax2\" );\n    }\n    if ( ( inbuffer = ReadInput(inname) ) == 0 ) return(1);\n    if ( ( outfile = fopen(outname,\"w\") ) == 0 ) {\n        fprintf(stderr,\"%s: Cannot create file %s\\n\",axohelp,outname);\n        exit(1);\n    }\n    num = ScanForObjects(inbuffer);\n    for ( i = 0; i < num; i++ ) {\n        numobject = i+1;\n        if ( DoOneObject(inputs[i]) < 0 ) { error++; }\n    }\n    fclose(outfile);\n    if ( error > 0 ) {\n        fprintf(stderr,\"%s: %d objects in %s were not translated correctly.\\n\",\n            axohelp,error,inname);\n        return(1);\n    }\n    return(0);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint retval = 0;\n\tint bytes_read = 0;\n\tchar in_buffer[20];\n\tunsigned long flags;\n\n\tdev = file->private_data;\n\n\tmutex_lock(&dev->io_mutex);\n\tif (!dev->interface) {\t\t/* already disconnected */\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tbytes_read = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (*ppos < bytes_read) {\n\t\tif (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))\n\t\t\tretval = -EFAULT;\n\t\telse {\n\t\t\tretval = bytes_read - *ppos;\n\t\t\t*ppos += bytes_read;\n\t\t}\n\t}\n\nexit:\n\tmutex_unlock(&dev->io_mutex);\n\treturn retval;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint len = 0;\n\tchar in_buffer[20];\n\tunsigned long flags;\n\n\tdev = file->private_data;\n\n\tmutex_lock(&dev->io_mutex);\n\tif (!dev->interface) {\t\t/* already disconnected */\n\t\tmutex_unlock(&dev->io_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tlen = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tmutex_unlock(&dev->io_mutex);\n\n\treturn simple_read_from_buffer(buffer, count, ppos, in_buffer, len);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"ablkcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_ablkcipher.geniv ?: \"<default>\");\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int crypto_ablkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tstrncpy(rblkcipher.type, \"ablkcipher\", sizeof(rblkcipher.type));\n\tstrncpy(rblkcipher.geniv, alg->cra_ablkcipher.geniv ?: \"<default>\",\n\t\tsizeof(rblkcipher.geniv));\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_ablkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_ablkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_ablkcipher.ivsize;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "            }\n\n        } else {\n            /* UTF-8 string. */\n\n            p = njs_string_offset(string_prop.start, end, from);\n            p = njs_utf8_next(p, end);\n\n            i = from + 1;\n\n            while (i-- > to) {\n                pos = njs_utf8_prev(p);\n\n                /* This cannot fail. */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "            }\n\n        } else {\n            /* UTF-8 string. */\n\n            p = NULL;\n            i = from + 1;\n\n            if (i > to) {\n                p = njs_string_offset(string_prop.start, end, from);\n                p = njs_utf8_next(p, end);\n            }\n\n            while (i-- > to) {\n                pos = njs_utf8_prev(p);\n\n                /* This cannot fail. */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (r < 0 || r >= MAXPATHLEN) {\n\t\tWARN(\"pathnme too long for '%s'\", mntent->mnt_dir);\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (r < 0 || r >= MAXPATHLEN) {\n\t\tWARN(\"pathnme too long for '%s'\", mntent->mnt_dir);\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, rootfs->mount);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int ref_pic_list_struct(GetBitContext *gb, RefPicListStruct *rpl)\n{\n    uint32_t delta_poc_st, strp_entry_sign_flag = 0;\n    rpl->ref_pic_num = get_ue_golomb_long(gb);\n    if (rpl->ref_pic_num > 0) {\n        delta_poc_st = get_ue_golomb_long(gb);\n\n        rpl->ref_pics[0] = delta_poc_st;\n        if (rpl->ref_pics[0] != 0) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int ref_pic_list_struct(EVCParserSPS *sps, GetBitContext *gb, RefPicListStruct *rpl)\n{\n    uint32_t delta_poc_st, strp_entry_sign_flag = 0;\n    rpl->ref_pic_num = get_ue_golomb_long(gb);\n\n    if ((unsigned)rpl->ref_pic_num  > sps->sps_max_dec_pic_buffering_minus1)\n        return AVERROR_INVALIDDATA;\n\n    if (rpl->ref_pic_num > 0) {\n        delta_poc_st = get_ue_golomb_long(gb);\n\n        rpl->ref_pics[0] = delta_poc_st;\n        if (rpl->ref_pics[0] != 0) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n\n    /* we have an error following */\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    reason = malloc((uint64_t)reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ReadReason(rfbClient* client)\n{\n    uint32_t reasonLen;\n    char *reason;\n\n    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;\n    reasonLen = rfbClientSwap32IfLE(reasonLen);\n    if(reasonLen > 1<<20) {\n      rfbClientLog(\"VNC connection failed, but sent reason length of %u exceeds limit of 1MB\",(unsigned int)reasonLen);\n      return;\n    }\n    reason = malloc(reasonLen+1);\n    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }\n    reason[reasonLen]=0;\n    rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n    free(reason);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "mptctl_readtest (unsigned long arg)\n{\n\tstruct mpt_ioctl_test __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_test\t karg;\n\tMPT_ADAPTER *ioc;\n\tint iocnum;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to read in mpt_ioctl_test struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_readtest() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_readtest called.\\n\",\n\t    ioc->name));\n\t/* Fill in the data and return the structure to the calling",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "mptctl_readtest (MPT_ADAPTER *ioc, unsigned long arg)\n{\n\tstruct mpt_ioctl_test __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_test\t karg;\n\n\tif (copy_from_user(&karg, uarg, sizeof(struct mpt_ioctl_test))) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_readtest - \"\n\t\t\t\"Unable to read in mpt_ioctl_test struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \"mptctl_readtest called.\\n\",\n\t    ioc->name));\n\t/* Fill in the data and return the structure to the calling",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "NOEXPORT void reload_config() {\n    static int delay=10; /* 10ms */\n#ifdef HAVE_CHROOT\n    struct stat sb;\n#endif /* HAVE_CHROOT */\n\n    if(options_parse(CONF_RELOAD)) {\n    else\n#endif /* HAVE_CHROOT */\n        log_close(SINK_SYSLOG|SINK_OUTFILE);\n    /* there is no race condition here:\n     * client threads are not allowed to use global options */\n    options_free();\n    options_apply();\n    /* we hope that a sane openlog(3) implementation won't\n     * attempt to reopen /dev/log if it's already open */\n    log_open(SINK_SYSLOG|SINK_OUTFILE);\n    log_flush(LOG_MODE_CONFIGURED);\n    ui_config_reloaded();\n    /* we use \"|\" instead of \"||\" to attempt initialization of both subsystems */\n    if(bind_ports() | exec_connect_start()) {\n        s_poll_sleep(delay/1000, delay%1000); /* sleep to avoid log trashing */\n        signal_post(SIGNAL_RELOAD_CONFIG); /* retry */\n        delay*=2;\n        if(delay > 10000) /* 10s */\n            delay=10000;\n    } else {\n        delay=10; /* 10ms */\n    }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "NOEXPORT void reload_config() {\n    static int delay=10; /* default of 10ms */\n#ifdef HAVE_CHROOT\n    struct stat sb;\n#endif /* HAVE_CHROOT */\n\n    if(options_parse(CONF_RELOAD)) {\n    else\n#endif /* HAVE_CHROOT */\n        log_close(SINK_SYSLOG|SINK_OUTFILE);\n    /* there is no race condition here:\n     * client threads are not allowed to use global options */\n    options_free(1); /* free the current options */\n    options_apply(); /* apply the new options */\n    /* we hope that a sane openlog(3) implementation won't\n     * attempt to reopen /dev/log if it's already open */\n    log_open(SINK_SYSLOG|SINK_OUTFILE);\n    log_flush(LOG_MODE_CONFIGURED);\n    ui_config_reloaded();\n    /* we use \"|\" instead of \"||\" to attempt initialization of both subsystems */\n    if(bind_ports() | exec_connect_start()) { /* failed */\n        unbind_ports();\n        s_poll_sleep(delay/1000, delay%1000); /* sleep to avoid log trashing */\n        signal_post(SIGNAL_RELOAD_CONFIG); /* retry */\n        delay*=2;\n        if(delay > 10000) /* limit to 10s */\n            delay=10000;\n    } else { /* success */\n        delay=10; /* reset back to 10ms */\n    }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    size_t buf_size;\n    int root_type = MSGPACK_OBJECT_ARRAY;\n    msgpack_unpacked result;\n    flb_sds_t error_msg = NULL;\n    int response = 200;\n    flb_sds_t input_name;\n    msgpack_object_array *inputs = NULL;\n    size_t off = 0;\n    int i;\n    \n\n    /* initialize buffers */\n    msgpack_sbuffer_init(&mp_sbuf);\n    msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);\n\n            continue;\n        }\n        if (result.data.via.map.ptr[i].key.type != MSGPACK_OBJECT_STR) {\n            continue;\n        }\n        if (result.data.via.map.ptr[i].key.via.str.size < strlen(\"inputs\")) {\n            continue;\n        }\n        if (strncmp(result.data.via.map.ptr[i].key.via.str.ptr, \"inputs\", strlen(\"inputs\"))) {\n            continue;\n        }\n        inputs = &result.data.via.map.ptr[i].val.via.array;\n    }\n\n    if (inputs == NULL) {\n        response = 503;\n        error_msg = flb_sds_create(\"inputs not found\");\n        goto unpack_error;\n    }\n    \n    msgpack_pack_map(&mp_pck, 2);\n\n    msgpack_pack_str_with_body(&mp_pck, \"inputs\", strlen(\"inputs\"));\n    msgpack_pack_map(&mp_pck, inputs->size);\n\n    for (i = 0; i < inputs->size; i++) {\n        input_name = flb_sds_create_len(inputs->ptr[i].via.str.ptr, inputs->ptr[i].via.str.size);\n        msgpack_pack_str_with_body(&mp_pck, input_name, flb_sds_len(input_name));\n\n        if (inputs->ptr[i].type != MSGPACK_OBJECT_STR) {\n            msgpack_pack_map(&mp_pck, 1);\n            msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n            msgpack_pack_str_with_body(&mp_pck, \"error\", strlen(\"error\"));\n        }\n        else {\n            if (request->method == MK_METHOD_POST || request->method == MK_METHOD_GET) {\n                ret = msgpack_params_enable_trace((struct flb_hs *)data, &result, input_name);\n                if (ret != 0) {\n                    msgpack_pack_map(&mp_pck, 2);\n                    msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n                    msgpack_pack_str_with_body(&mp_pck, \"error\", strlen(\"error\"));\n                    msgpack_pack_str_with_body(&mp_pck, \"returncode\", strlen(\"returncode\"));\n                    msgpack_pack_int64(&mp_pck, ret);\n                }\n                else {\n                    msgpack_pack_map(&mp_pck, 1);\n                    msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n                    msgpack_pack_str_with_body(&mp_pck, \"ok\", strlen(\"ok\"));\n                }\n            }\n            else if (request->method == MK_METHOD_DELETE) {\n                disable_trace_input((struct flb_hs *)data, input_name);\n            }\n            else {\n                msgpack_pack_map(&mp_pck, 2);\n                msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n                msgpack_pack_str_with_body(&mp_pck, \"error\", strlen(\"error\"));\n                msgpack_pack_str_with_body(&mp_pck, \"message\", strlen(\"message\"));\n                msgpack_pack_str_with_body(&mp_pck, \"method not allowed\", strlen(\"method not allowed\"));\n            }\n        }\n    }\n\n    msgpack_pack_str_with_body(&mp_pck, \"result\", strlen(\"result\"));\nunpack_error:\n        flb_free(buf);\n    }\n    msgpack_unpacked_destroy(&result);\n    if (response == 404) {\n        msgpack_pack_map(&mp_pck, 1);\n        msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n        msgpack_pack_str_with_body(&mp_pck, \"not found\", strlen(\"not found\"));\n    }\n    else if (response == 503) {\n        msgpack_pack_map(&mp_pck, 2);\n        msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n        msgpack_pack_str_with_body(&mp_pck, \"error\", strlen(\"error\"));\n        msgpack_pack_str_with_body(&mp_pck, \"message\", strlen(\"message\"));\n        if (error_msg) {\n            msgpack_pack_str_with_body(&mp_pck, error_msg, flb_sds_len(error_msg));\n            flb_sds_destroy(error_msg);\n        }\n        else {\n            msgpack_pack_str_with_body(&mp_pck, \"unknown error\", strlen(\"unknown error\"));\n        }\n    }\n    else {\n        msgpack_pack_map(&mp_pck, 1);\n        msgpack_pack_str_with_body(&mp_pck, \"status\", strlen(\"status\"));\n        msgpack_pack_str_with_body(&mp_pck, \"ok\", strlen(\"ok\"));\n    }\n\n    /* Export to JSON */\n    out_buf = flb_msgpack_raw_to_json_sds(mp_sbuf.data, mp_sbuf.size);\n    if (out_buf == NULL) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    size_t buf_size;\n    int root_type = MSGPACK_OBJECT_ARRAY;\n    msgpack_unpacked result;\n    flb_sds_t error_msg = NULL;\n    int response = 200;\n    const char *input_name;\n    ssize_t input_nlen;\n    msgpack_object_array *inputs = NULL;\n    size_t off = 0;\n    int i;\n\n    /* initialize buffers */\n    msgpack_sbuffer_init(&mp_sbuf);\n    msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);\n\n            continue;\n        }\n        if (result.data.via.map.ptr[i].key.type != MSGPACK_OBJECT_STR) {\n            continue;\n        }\n        if (result.data.via.map.ptr[i].key.via.str.size < STR_INPUTS_LEN) {\n            continue;\n        }\n        if (strncmp(result.data.via.map.ptr[i].key.via.str.ptr, STR_INPUTS, STR_INPUTS_LEN)) {\n            continue;\n        }\n        inputs = &result.data.via.map.ptr[i].val.via.array;\n    }\n\n    if (inputs == NULL) {\n        response = 503;\n        error_msg = flb_sds_create(\"inputs not found\");\n        goto unpack_error;\n    }\n\n    msgpack_pack_map(&mp_pck, 2);\n\n    msgpack_pack_str_with_body(&mp_pck, STR_INPUTS, STR_INPUTS_LEN);\n    msgpack_pack_map(&mp_pck, inputs->size);\n\n    for (i = 0; i < inputs->size; i++) {\n\n        if (inputs->ptr[i].type != MSGPACK_OBJECT_STR || inputs->ptr[i].via.str.ptr == NULL) {\n            response = 503;\n            error_msg = flb_sds_create(\"invalid input\");\n            msgpack_sbuffer_clear(&mp_sbuf);\n            goto unpack_error;\n        }\n    }\n\n    for (i = 0; i < inputs->size; i++) {\n\n        input_name = inputs->ptr[i].via.str.ptr;\n        input_nlen = inputs->ptr[i].via.str.size;\n\n        msgpack_pack_str_with_body(&mp_pck, input_name, input_nlen);\n\n        if (request->method == MK_METHOD_POST) {\n\n            ret = msgpack_params_enable_trace((struct flb_hs *)data, &result,\n                                              input_name, input_nlen);\n\n            if (ret != 0) {\n                msgpack_pack_map(&mp_pck, 2);\n                msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n                msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_ERROR, HTTP_RESULT_ERROR_LEN);\n                msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_RETURNCODE,\n                                           HTTP_FIELD_RETURNCODE_LEN);\n                msgpack_pack_int64(&mp_pck, ret);\n            }\n            else {\n                msgpack_pack_map(&mp_pck, 1);\n                msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n                msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n            }\n        }\n        else if (request->method == MK_METHOD_DELETE) {\n            disable_trace_input((struct flb_hs *)data, input_name, input_nlen);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n        }\n        else {\n            msgpack_pack_map(&mp_pck, 2);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_ERROR, HTTP_RESULT_ERROR_LEN);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_MESSAGE, HTTP_FIELD_MESSAGE_LEN);\n            msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_METHODNOTALLOWED,\n                                       HTTP_RESULT_METHODNOTALLOWED_LEN);\n        }\n    }\n\n    msgpack_pack_str_with_body(&mp_pck, \"result\", strlen(\"result\"));\nunpack_error:\n        flb_free(buf);\n    }\n    msgpack_unpacked_destroy(&result);\n    if (response == 404) {\n        msgpack_pack_map(&mp_pck, 1);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_NOTFOUND, HTTP_RESULT_NOTFOUND_LEN);\n    }\n    else if (response == 503) {\n        msgpack_pack_map(&mp_pck, 2);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_MESSAGE, HTTP_FIELD_MESSAGE_LEN);\n        if (error_msg) {\n            msgpack_pack_str_with_body(&mp_pck, error_msg, flb_sds_len(error_msg));\n            flb_sds_destroy(error_msg);\n        }\n        else {\n            msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_UNKNOWNERROR,\n                                       HTTP_RESULT_UNKNOWNERROR_LEN);\n        }\n    }\n    else {\n        msgpack_pack_map(&mp_pck, 1);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n        msgpack_pack_str_with_body(&mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n    }\n\n    /* Export to JSON */\n    out_buf = flb_msgpack_raw_to_json_sds(mp_sbuf.data, mp_sbuf.size);\n    if (out_buf == NULL) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "bool SecurityManager::discovered_participant(IdentityToken&& remote_identity_token,\n        const GUID_t& remote_participant_key)\n{\n    IdentityHandle* remote_identity_handle = nullptr;\n    SecurityException exception;\n    AuthenticationStatus auth_status = AUTHENTICATION_INIT;\n\n    // Find information\n        auth_status = dp_it->second.get_auth_status();\n\n        if(auth_status == AUTHENTICATION_INIT)\n            return false;\n    }\n\n    if(auth_status == AUTHENTICATION_REQUEST_NOT_SEND)\n    {\n        remote_identity_handle = dp_it->second.get_identity_handle();\n        assert(remote_identity_handle);\n    }\n    mutex_.unlock();\n\n    bool returnedValue = true;\n\n    // Maybe send request.\n    if(remote_identity_handle != nullptr)\n    {\n        returnedValue = on_request_not_send(remote_participant_key, remote_identity_handle);\n    }\n\n    return returnedValue;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "bool SecurityManager::discovered_participant(IdentityToken&& remote_identity_token,\n        const GUID_t& remote_participant_key)\n{\n    if(authentication_plugin_ == nullptr)\n        return true;\n\n    IdentityHandle* remote_identity_handle = nullptr;\n    SecurityException exception;\n    AuthenticationStatus auth_status = AUTHENTICATION_INIT;\n\n    // Find information\n\n        if(auth_status == AUTHENTICATION_INIT)\n            return false;\n    }\n\n    int64_t last_sequence_number = 0;\n\n    if(auth_status == AUTHENTICATION_REQUEST_NOT_SEND)\n    {\n        remote_identity_handle = dp_it->second.get_identity_handle();\n        assert(remote_identity_handle);\n        last_sequence_number = dp_it->second.get_last_sequence_number();\n\n    }\n    mutex_.unlock();\n\n    bool returnedValue = true;\n\n    // Maybe send request.\n    if(remote_identity_handle != nullptr)\n    {\n        returnedValue = on_process_handshake(remote_participant_key, AUTHENTICATION_REQUEST_NOT_SEND,\n                MessageIdentity(), HandshakeMessageToken(),\n                remote_identity_handle, nullptr, last_sequence_number);\n    }\n\n    return returnedValue;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tOM_uint32 *minor_status,\n\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_OID desired_object,\n\t\tgss_buffer_set_t *data_set)\n{\n\tOM_uint32 ret;\n\tret = gss_inquire_sec_context_by_oid(minor_status,\n\t\t\t    context_handle,\n\t\t\t    desired_object,\n\t\t\t    data_set);\n\treturn (ret);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tconst gss_ctx_id_t context_handle,\n\t\tconst gss_OID desired_object,\n\t\tgss_buffer_set_t *data_set)\n{\n\tOM_uint32 ret;\n\tspnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n\t/* There are no SPNEGO-specific OIDs for this function. */\n\tif (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t\treturn (GSS_S_UNAVAILABLE);\n\n\tret = gss_inquire_sec_context_by_oid(minor_status,\n\t\t\t    sc->ctx_handle,\n\t\t\t    desired_object,\n\t\t\t    data_set);\n\treturn (ret);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "inline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0) {\n      return 4;\n    }\n  }\n  return 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "inline size_t codepoint_length(const char *s8, size_t l) {\n  if (l) {\n    auto b = static_cast<uint8_t>(s8[0]);\n    if ((b & 0x80) == 0) {\n      return 1;\n    } else if ((b & 0xE0) == 0xC0 && l >= 2) {\n      return 2;\n    } else if ((b & 0xF0) == 0xE0 && l >= 3) {\n      return 3;\n    } else if ((b & 0xF8) == 0xF0 && l >= 4) {\n      return 4;\n    }\n  }\n  return 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void TestJlCompress::extractDir_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::newRow(\"simple\") << \"jlextdir.zip\" << (\n            QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\");\n    QTest::newRow(\"separate dir\") << \"sepdir.zip\" << (\n            QStringList() << \"laj/\" << \"laj/lajfile.txt\");\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void TestJlCompress::extractDir_data()\n{\n    QTest::addColumn<QString>(\"zipName\");\n    QTest::addColumn<QStringList>(\"fileNames\");\n    QTest::addColumn<QStringList>(\"expectedExtracted\");\n    QTest::newRow(\"simple\") << \"jlextdir.zip\"\n        << (QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\")\n        << (QStringList() << \"test0.txt\" << \"testdir1/test1.txt\"\n            << \"testdir2/test2.txt\" << \"testdir2/subdir/test2sub.txt\");\n    QTest::newRow(\"separate dir\") << \"sepdir.zip\"\n        << (QStringList() << \"laj/\" << \"laj/lajfile.txt\")\n        << (QStringList() << \"laj/\" << \"laj/lajfile.txt\");\n    QTest::newRow(\"Zip Slip\") << \"zipslip.zip\"\n        << (QStringList() << \"test0.txt\" << \"../zipslip.txt\")\n        << (QStringList() << \"test0.txt\");\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tif (ctx->might_cancel) {\n\t\tctx->might_cancel = false;\n\t\tspin_lock(&cancel_lock);\n\t\tlist_del_rcu(&ctx->clist);\n\t\tspin_unlock(&cancel_lock);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void timerfd_remove_cancel(struct timerfd_ctx *ctx)\n{\n\tspin_lock(&ctx->cancel_lock);\n\t__timerfd_remove_cancel(ctx);\n\tspin_unlock(&ctx->cancel_lock);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static inline __attribute__((unused)) ssize_t fiobj_send_free(intptr_t uuid,\n                                                              FIOBJ o) {\n  fio_str_info_s s = fiobj_obj2cstr(o);\n  return fio_write2(uuid, .data.buffer = (void *)(o),\n                    .offset = (((intptr_t)s.data) - ((intptr_t)(o))),\n                    .length = s.len, .after.dealloc = fiobj4sock_dealloc);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static inline __attribute__((unused)) ssize_t fiobj_send_free(intptr_t uuid,\n                                                              FIOBJ o) {\n  fio_str_info_s s = fiobj_obj2cstr(o);\n  return fio_write2(uuid, .data.buffer = (void *)(o),\n                    .offset = (uintptr_t)(((intptr_t)s.data) - ((intptr_t)(o))),\n                    .length = s.len, .after.dealloc = fiobj4sock_dealloc);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rpcomp;\n\n\tsnprintf(rpcomp.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"pcomp\");\n\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rpcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int crypto_pcomp_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_comp rpcomp;\n\n\tstrncpy(rpcomp.type, \"pcomp\", sizeof(rpcomp.type));\n\tif (nla_put(skb, CRYPTOCFGA_REPORT_COMPRESS,\n\t\t    sizeof(struct crypto_report_comp), &rpcomp))\n\t\tgoto nla_put_failure;\n\treturn 0;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      entry.word0 = 0;\n\n      //Update the ALE table\n      am335xEthWriteEntry(index, &entry);\n\n      //Sucessful processing\n      error = NO_ERROR;\n   }\n   else\n   {\n      //Entry not found",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      entry.word0 = 0;\n\n      //Update the ALE table\n      am335xEthWriteEntry(index, &entry);\n\n      //Successful processing\n      error = NO_ERROR;\n   }\n   else\n   {\n      //Entry not found",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tsize_t slen, int bls) {\n\tg1_t g1;\n\tg2_t g2;\n\tgt_t e, u, v;\n\tbn_t k, n;\n\tint len, dlen = strlen(data), result = 1;\n\tuint8_t *buf = RLC_ALLOCA(uint8_t, 1 + 8 * RLC_FP_BYTES + dlen);\n\n\tg1_null(g1);\n\tg2_null(g2);\n\tgt_null(e);\n\tgt_null(u);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tsize_t slen, int bls) {\n\tg1_t g1;\n\tg2_t g2;\n\tgt_t e, u, v;\n\tbn_t k, n;\n\tsize_t len, dlen = strlen(data);\n\tuint8_t *buf = RLC_ALLOCA(uint8_t, 1 + 8 * RLC_FP_BYTES + dlen);\n\tint result = 1;\n\n\tg1_null(g1);\n\tg2_null(g2);\n\tgt_null(e);\n\tgt_null(u);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        r = RET_NERRNO(pipe2(error_pipe, O_CLOEXEC|O_NONBLOCK));\n        if (r < 0)\n                return r;\n\n        if (ret) {\n                r = RET_NERRNO(pipe2(return_pipe, O_CLOEXEC));\n                if (r < 0)\n                        return r;\n        }\n\n        if (ret_package_metadata) {\n                r = RET_NERRNO(pipe2(json_pipe, O_CLOEXEC));\n                if (r < 0)\n                        return r;\n        }\n\n        /* Parsing possibly malformed data is crash-happy, so fork. In case we crash,\n                r = parse_elf(fd, executable, ret ? &buf : NULL, ret_package_metadata ? &package_metadata : NULL);\n                if (r < 0)\n                        goto child_fail;\n\n                if (buf) {\n                        r = loop_write(return_pipe[1], buf, strlen(buf), false);\n                        if (r < 0)\n                                goto child_fail;\n\n                        return_pipe[1] = safe_close(return_pipe[1]);\n                }\n\n                if (package_metadata) {\n                        _cleanup_fclose_ FILE *json_out = NULL;\n\n                        json_out = take_fdopen(&json_pipe[1], \"w\");\n                        if (!json_out) {\n                                r = -errno;\n                                goto child_fail;\n                        }\n\n                        json_variant_dump(package_metadata, JSON_FORMAT_FLUSH, json_out, NULL);\n                }\n\n                _exit(EXIT_SUCCESS);\n\n        child_fail:\n                if (!json_in)\n                        return -errno;\n\n                r = json_parse_file(json_in, NULL, 0, &package_metadata, NULL, NULL);\n                if (r < 0 && r != -ENODATA) /* ENODATA: json was empty, so we got nothing, but that's ok */\n                        return r;\n        }\n\n        if (ret)\n                *ret = TAKE_PTR(buf);\n        if (ret_package_metadata)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        r = RET_NERRNO(pipe2(error_pipe, O_CLOEXEC|O_NONBLOCK));\n        if (r < 0)\n                return r;\n\n        if (ret) {\n                r = RET_NERRNO(pipe2(return_pipe, O_CLOEXEC|O_NONBLOCK));\n                if (r < 0)\n                        return r;\n        }\n\n        if (ret_package_metadata) {\n                r = RET_NERRNO(pipe2(json_pipe, O_CLOEXEC|O_NONBLOCK));\n                if (r < 0)\n                        return r;\n        }\n\n        /* Parsing possibly malformed data is crash-happy, so fork. In case we crash,\n                r = parse_elf(fd, executable, ret ? &buf : NULL, ret_package_metadata ? &package_metadata : NULL);\n                if (r < 0)\n                        goto child_fail;\n\n                if (buf) {\n                        size_t len = strlen(buf);\n\n                        if (len > COREDUMP_PIPE_MAX) {\n                                /* This is iffy. A backtrace can be a few hundred kilobytes, but too much is\n                                 * too much. Let's log a warning and ignore the rest. */\n                                log_warning(\"Generated backtrace is %zu bytes (more than the limit of %u bytes), backtrace will be truncated.\",\n                                            len, COREDUMP_PIPE_MAX);\n                                len = COREDUMP_PIPE_MAX;\n                        }\n\n                        /* Bump the space for the returned string.\n                         * Failure is ignored, because partial output is still useful. */\n                        (void) fcntl(return_pipe[1], F_SETPIPE_SZ, len);\n\n                        r = loop_write(return_pipe[1], buf, len, false);\n                        if (r == -EAGAIN)\n                                log_warning(\"Write failed, backtrace will be truncated.\");\n                        else if (r < 0)\n                                goto child_fail;\n\n                        return_pipe[1] = safe_close(return_pipe[1]);\n                }\n\n                if (package_metadata) {\n                        _cleanup_fclose_ FILE *json_out = NULL;\n\n                        /* Bump the space for the returned string. We don't know how much space we'll need in\n                         * advance, so we'll just try to write as much as possible and maybe fail later. */\n                        (void) fcntl(json_pipe[1], F_SETPIPE_SZ, COREDUMP_PIPE_MAX);\n\n                        json_out = take_fdopen(&json_pipe[1], \"w\");\n                        if (!json_out) {\n                                r = -errno;\n                                goto child_fail;\n                        }\n\n                        r = json_variant_dump(package_metadata, JSON_FORMAT_FLUSH, json_out, NULL);\n                        if (r < 0)\n                                log_warning_errno(r, \"Failed to write JSON package metadata, ignoring: %m\");\n                }\n\n                _exit(EXIT_SUCCESS);\n\n        child_fail:\n                if (!json_in)\n                        return -errno;\n\n                r = json_parse_file(json_in, NULL, 0, &package_metadata, NULL, NULL);\n                if (r < 0 && r != -ENODATA) /* ENODATA: json was empty, so we got nothing, but that's ok */\n                        log_warning_errno(r, \"Failed to read or parse json metadata, ignoring: %m\");\n        }\n\n        if (ret)\n                *ret = TAKE_PTR(buf);\n        if (ret_package_metadata)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void SmallVectorBase::grow_pod(void *FirstEl, size_t MinCapacity,\n                               size_t TSize) {\n  // Ensure we can fit the new capacity in 32 bits.\n  if (MinCapacity > UINT32_MAX)\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n\n  size_t NewCapacity = 2 * capacity() + 1; // Always grow.\n  NewCapacity =\n      std::min(std::max(NewCapacity, MinCapacity), size_t(UINT32_MAX));\n\n  void *NewElts;\n  if (BeginX == FirstEl) {\n    NewElts = safe_malloc(NewCapacity * TSize);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void SmallVectorBase::grow_pod(void *FirstEl, size_t MinCapacity,\n                               size_t TSize) {\n  constexpr size_t MinGrowth = 1;\n  size_t NewCapacity = 2 * capacity() + MinGrowth; // Always grow.\n  NewCapacity = static_cast<unsigned>(std::max(NewCapacity, MinCapacity));\n\n  // Ensure that NewCapacity did not overflow an unsigned int,\n  // and that the capacity in bytes will not overflow a size_t.\n  if (NewCapacity <= this->capacity() ||\n      NewCapacity < MinCapacity ||\n      NewCapacity > size_t(-1) / TSize)\n    report_bad_alloc_error(\"SmallVector capacity overflow during allocation\");\n\n  void *NewElts;\n  if (BeginX == FirstEl) {\n    NewElts = safe_malloc(NewCapacity * TSize);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tret = key_payload_reserve(key, datalen);\n\n\tif (ret == 0) {\n\t\t/* attach the new data, displacing the old */\n\t\tzap = key->payload.data[0];\n\t\trcu_assign_keypointer(key, upayload);\n\t\tkey->expiry = 0;\n\t}\n\n\tif (zap)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tret = key_payload_reserve(key, datalen);\n\n\tif (ret == 0) {\n\t\t/* attach the new data, displacing the old */\n\t\tif (!test_bit(KEY_FLAG_NEGATIVE, &key->flags))\n\t\t\tzap = key->payload.data[0];\n\t\telse\n\t\t\tzap = NULL;\n\t\trcu_assign_keypointer(key, upayload);\n\t\tkey->expiry = 0;\n\t}\n\n\tif (zap)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n   int i = 1;\n   struct filter_op *array = NULL;\n   struct unfold_elm *ue;\n\n   BUG_IF(tree_root == NULL);\n  \n   fprintf(stdout, \" Unfolding the meta-tree \");\n   fflush(stdout);\n     \n   /* start the recursion on the tree */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n   int i = 1;\n   struct filter_op *array = NULL;\n   struct unfold_elm *ue;\n\n   // invalid file\n   if (tree_root == NULL)\n      return 0;\n  \n   fprintf(stdout, \" Unfolding the meta-tree \");\n   fflush(stdout);\n     \n   /* start the recursion on the tree */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "modify_principal_2_svc(mprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    restriction_t                   *rp;\n    const char                      *errmsg = NULL;\n\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "modify_principal_2_svc(mprinc_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    restriction_t                   *rp;\n    const char                      *errmsg = NULL;\n\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t     k++, rem_sz -= ret_sz) {\n\n\t\tnum = (rem_sz > scatter_elem_sz_prev) ?\n\t\t\tscatter_elem_sz_prev : rem_sz;\n\n\t\tschp->pages[k] = alloc_pages(gfp_mask, order);\n\t\tif (!schp->pages[k])\n\t\t\tgoto out;\n\n\t\tif (num == scatter_elem_sz_prev) {\n\t\t\tif (unlikely(ret_sz > scatter_elem_sz_prev)) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t     k++, rem_sz -= ret_sz) {\n\n\t\tnum = (rem_sz > scatter_elem_sz_prev) ?\n\t\t\tscatter_elem_sz_prev : rem_sz;\n\n\t\tschp->pages[k] = alloc_pages(gfp_mask | __GFP_ZERO, order);\n\t\tif (!schp->pages[k])\n\t\t\tgoto out;\n\n\t\tif (num == scatter_elem_sz_prev) {\n\t\t\tif (unlikely(ret_sz > scatter_elem_sz_prev)) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "     4) pixel index in y direction\n  */\n\n  if( session->loglevel >= 3 ) (*session->logfile) << \"SPECTRA handler reached\" << endl;\n\n  int resolution, tile, x, y;\n\n\n  // Time this command\n  if( session->loglevel >= 2 ) command_timer.start();\n\n\n  // Parse the argument list\n  string arg = argument;\n  int delimitter = arg.find( \",\" );\n  resolution = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  tile = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  x = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  y = atoi( arg.substr(0,arg.length()).c_str() );\n\n  if( session->loglevel >= 5 ){ \n    (*session->logfile) << \"SPECTRA :: resolution: \" << resolution\n\t\t\t<< \", tile: \" << tile\n\t\t\t<< \", x: \" << x",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "     4) pixel index in y direction\n  */\n\n  if( session->loglevel >= 3 ) (*session->logfile) << \"SPECTRA handler reached\" << endl;\n\n\n  // Make sure we have set our image\n  this->session = session;\n  checkImage();\n\n\n  // Time this command\n  if( session->loglevel >= 2 ) command_timer.start();\n\n\n  // Parse the argument list\n  string arg = argument;\n  int delimitter = arg.find( \",\" );\n  int resolution = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  int tile = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  int x = atoi( arg.substr(0,delimitter).c_str() );\n\n  arg = arg.substr( delimitter + 1, arg.length() );\n  delimitter = arg.find( \",\" );\n  int y = atoi( arg.substr(0,arg.length()).c_str() );\n\n  if( session->loglevel >= 5 ){ \n    (*session->logfile) << \"SPECTRA :: resolution: \" << resolution\n\t\t\t<< \", tile: \" << tile\n\t\t\t<< \", x: \" << x",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tgoto out_free;\n\t}\n\n\tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);\n\t/* Don't allow unprivileged users to change mount flags */\n\tif ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n\n\t/* Don't allow unprivileged users to reveal what is under a mount */\n\tif ((flag & CL_UNPRIVILEGED) && list_empty(&old->mnt_expire))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCKED;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tgoto out_free;\n\t}\n\n\tmnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);\n\t/* Don't allow unprivileged users to change mount flags */\n\tif (flag & CL_UNPRIVILEGED) {\n\t\tmnt->mnt.mnt_flags |= MNT_LOCK_ATIME;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_READONLY)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_READONLY;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NODEV)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NODEV;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOSUID)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOSUID;\n\n\t\tif (mnt->mnt.mnt_flags & MNT_NOEXEC)\n\t\t\tmnt->mnt.mnt_flags |= MNT_LOCK_NOEXEC;\n\t}\n\n\t/* Don't allow unprivileged users to reveal what is under a mount */\n\tif ((flag & CL_UNPRIVILEGED) && list_empty(&old->mnt_expire))\n\t\tmnt->mnt.mnt_flags |= MNT_LOCKED;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n\t\tconst void *data, size_t datalen)\n{\n\tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n\t__be32 *pdata = (__be32 *)data;\n\n\tif (*pdata == ctx->from) {\n\t\tpr_debug(\"%s: %pI4 to %pI4\\n\", __func__,\n\t\t\t (void *)&ctx->from, (void *)&ctx->to);\n\n\t\tif (*ctx->check)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int snmp_helper(void *context, size_t hdrlen, unsigned char tag,\n\t\tconst void *data, size_t datalen)\n{\n\tstruct snmp_ctx *ctx = (struct snmp_ctx *)context;\n\t__be32 *pdata;\n\n\tif (datalen != 4)\n\t\treturn -EINVAL;\n\tpdata = (__be32 *)data;\n\tif (*pdata == ctx->from) {\n\t\tpr_debug(\"%s: %pI4 to %pI4\\n\", __func__,\n\t\t\t (void *)&ctx->from, (void *)&ctx->to);\n\n\t\tif (*ctx->check)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                yyjson_obj_iter_init(rhs, &iter);\n                lhs = unsafe_yyjson_get_first(lhs);\n                while (len-- > 0) {\n                    rhs = yyjson_obj_iter_getn(&iter, lhs->uni.str,\n                                               unsafe_yyjson_get_len(lhs));\n                    if (!rhs || !unsafe_yyjson_equals(lhs + 1, rhs))\n                        return false;\n                    lhs = unsafe_yyjson_get_next(lhs + 1);\n                }\n            }\n            /* yyjson allows duplicate keys, so the check may be inaccurate */\n            return true;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                yyjson_obj_iter_init(rhs, &iter);\n                lhs = unsafe_yyjson_get_first(lhs);\n                while (len-- > 0) {\n                    rhs = yyjson_obj_iter_getn(&iter, lhs->uni.str,\n                                               unsafe_yyjson_get_len(lhs));\n                    if (!rhs) return false;\n                    if (!unsafe_yyjson_equals(lhs + 1, rhs)) return false;\n                    lhs = unsafe_yyjson_get_next(lhs + 1);\n                }\n            }\n            /* yyjson allows duplicate keys, so the check may be inaccurate */\n            return true;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list && *return_list) {\n      free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                                     return_list, return_size,\n                                     persistent ? 1 : 0);\n  }\n  if (!ret) {\n    if (return_list && *return_list) {\n      req::free(*return_list);\n      *return_list = nullptr;\n    }\n    return_size = 0;\n  }\n  return ret;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tu8 sps_ptl_dpb_hrd_params_present_flag;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\tsps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif (sps_id >= 16) {\n\t\treturn -1;\n\t}\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif (vps_id >= 16) {\n\t\treturn -1;\n\t}\n\tif (!vps_id && !vvc->vps[0].state) {\n\t\tvvc->vps[0].state = 1;\n\t\tvvc->vps[0].num_ptl = 1;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tu8 sps_ptl_dpb_hrd_params_present_flag;\n\n\tif (vui_flag_pos) *vui_flag_pos = 0;\n\n\tsps_id = gf_bs_read_int_log(bs, 4, \"sps_id\");\n\tif ((sps_id<0) || (sps_id >= 16)) {\n\t\treturn -1;\n\t}\n\tvps_id = gf_bs_read_int_log(bs, 4, \"vps_id\");\n\tif ((vps_id<0) || (vps_id >= 16)) {\n\t\treturn -1;\n\t}\n\tif (!vps_id && !vvc->vps[0].state) {\n\t\tvvc->vps[0].state = 1;\n\t\tvvc->vps[0].num_ptl = 1;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t/* this is just /cgroup/controller, return its contents */\n\t\t\tcgroup = \"/\";\n\t\t}\n\t}\n\n\tif (cgroup && !fc_may_access(fc, controller, cgroup, NULL, O_RDONLY)) {\n\t\treturn -EACCES;\n\t}\n\n\t/* we'll free this at cg_releasedir */\n\tdir_info = malloc(sizeof(*dir_info));\n\tif (!dir_info)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t/* this is just /cgroup/controller, return its contents */\n\t\t\tcgroup = \"/\";\n\t\t}\n\t}\n\n\tif (cgroup) {\n\t\tif (!caller_may_see_dir(fc->pid, controller, cgroup))\n\t\t\treturn -ENOENT;\n\t\tif (!fc_may_access(fc, controller, cgroup, NULL, O_RDONLY))\n\t\t\treturn -EACCES;\n\t}\n\n\t/* we'll free this at cg_releasedir */\n\tdir_info = malloc(sizeof(*dir_info));\n\tif (!dir_info)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "loop:\n\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tif (ret)\n\t\treturn -EFAULT;\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > 33)\n\t\t\t/* the command may now also take up the space\n\t\t\t * initially intended for the reply & the\n\t\t\t * reply count. Needed for long 82078 commands\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < 16; i++)\n\t\tptr->reply[i] = 0;\n\tptr->resultcode = 0;\n\tptr->kernel_data = NULL;\n\n\tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\t*rcmd = ptr;\n\tret = copy_from_user(ptr, param, sizeof(*ptr));\n\tptr->next = NULL;\n\tptr->buffer_length = 0;\n\tptr->kernel_data = NULL;\n\tif (ret)\n\t\treturn -EFAULT;\n\tparam += sizeof(struct floppy_raw_cmd);\n\tif (ptr->cmd_count > 33)\n\t\t\t/* the command may now also take up the space\n\t\t\t * initially intended for the reply & the\n\t\t\t * reply count. Needed for long 82078 commands\n\t\t\t */\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < 16; i++)\n\t\tptr->reply[i] = 0;\n\tptr->resultcode = 0;\n\n\tif (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {\n\t\tif (ptr->length <= 0)\n\t\t\treturn -EINVAL;\n\t\tptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,\n\t\tv4l2_kioctl func)\n{\n\tchar\tsbuf[128];\n\tvoid    *mbuf = NULL;\n\tvoid\t*parg = NULL;\n\tlong\terr  = -EINVAL;\n\tint     is_ext_ctrl;\n\tsize_t  ctrls_size = 0;\n\tvoid __user *user_ptr = NULL;\n\n\tis_ext_ctrl = (cmd == VIDIOC_S_EXT_CTRLS || cmd == VIDIOC_G_EXT_CTRLS ||\n\t\t       cmd == VIDIOC_TRY_EXT_CTRLS);\n\n\t/*  Copy arguments into temp kernel buffer  */\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_NONE:\n\t\tparg = NULL;\n\t\tbreak;\n\tcase _IOC_READ:\n\tcase _IOC_WRITE:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n\t\t\tparg = sbuf;\n\t\t} else {\n\t\t\t/* too big to allocate from stack */\n\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\n\t\t\t\treturn -ENOMEM;\n\t\t\tparg = mbuf;\n\t\t}\n\n\t\terr = -EFAULT;\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE)\n\t\t\tif (copy_from_user(parg, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\t\tgoto out;\n\t\tbreak;\n\t}\n\tif (is_ext_ctrl) {\n\t\tstruct v4l2_ext_controls *p = parg;\n\n\t\t/* In case of an error, tell the caller that it wasn't\n\t\t   a specific control that caused it. */\n\t\tp->error_idx = p->count;\n\t\tuser_ptr = (void __user *)p->controls;\n\t\tif (p->count) {\n\t\t\tctrls_size = sizeof(struct v4l2_ext_control) * p->count;\n\t\t\t/* Note: v4l2_ext_controls fits in sbuf[] so mbuf is still NULL. */\n\t\t\tmbuf = kmalloc(ctrls_size, GFP_KERNEL);\n\t\t\terr = -ENOMEM;\n\t\t\tif (NULL == mbuf)\n\t\t\t\tgoto out_ext_ctrl;\n\t\t\terr = -EFAULT;\n\t\t\tif (copy_from_user(mbuf, user_ptr, ctrls_size))\n\t\t\t\tgoto out_ext_ctrl;\n\t\t\tp->controls = mbuf;\n\t\t}\n\t}\n\n\t/* call driver */\n\terr = func(file, cmd, parg);\n\tif (err == -ENOIOCTLCMD)\n\t\terr = -EINVAL;\n\tif (is_ext_ctrl) {\n\t\tstruct v4l2_ext_controls *p = parg;\n\n\t\tp->controls = (void *)user_ptr;\n\t\tif (p->count && err == 0 && copy_to_user(user_ptr, mbuf, ctrls_size))\n\t\t\terr = -EFAULT;\n\t\tgoto out_ext_ctrl;\n\t}\n\tif (err < 0)\n\t\tgoto out;\n\nout_ext_ctrl:\n\t/*  Copy results into user buffer  */\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_READ:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,\n\t       v4l2_kioctl func)\n{\n\tchar\tsbuf[128];\n\tvoid    *mbuf = NULL;\n\tvoid\t*parg = (void *)arg;\n\tlong\terr  = -EINVAL;\n\tbool\thas_array_args;\n\tsize_t  array_size = 0;\n\tvoid __user *user_ptr = NULL;\n\tvoid\t**kernel_ptr = NULL;\n\n\t/*  Copy arguments into temp kernel buffer  */\n\tif (_IOC_DIR(cmd) != _IOC_NONE) {\n\t\tif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\n\t\t\tparg = sbuf;\n\t\t} else {\n\t\t\t/* too big to allocate from stack */\n\t\t\tmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\n\t\t\t\treturn -ENOMEM;\n\t\t\tparg = mbuf;\n\t\t}\n\n\t\terr = -EFAULT;\n\t\tif (_IOC_DIR(cmd) & _IOC_WRITE) {\n\t\t\tunsigned long n = cmd_input_size(cmd);\n\n\t\t\tif (copy_from_user(parg, (void __user *)arg, n))\n\t\t\t\tgoto out;\n\n\t\t\t/* zero out anything we don't copy from userspace */\n\t\t\tif (n < _IOC_SIZE(cmd))\n\t\t\t\tmemset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n);\n\t\t} else {\n\t\t\t/* read-only ioctl */\n\t\t\tmemset(parg, 0, _IOC_SIZE(cmd));\n\t\t}\n\t}\n\n\terr = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr);\n\tif (err < 0)\n\t\tgoto out;\n\thas_array_args = err;\n\n\tif (has_array_args) {\n\t\t/*\n\t\t * When adding new types of array args, make sure that the\n\t\t * parent argument to ioctl (which contains the pointer to the\n\t\t * array) fits into sbuf (so that mbuf will still remain\n\t\t * unused up to here).\n\t\t */\n\t\tmbuf = kmalloc(array_size, GFP_KERNEL);\n\t\terr = -ENOMEM;\n\t\tif (NULL == mbuf)\n\t\t\tgoto out_array_args;\n\t\terr = -EFAULT;\n\t\tif (copy_from_user(mbuf, user_ptr, array_size))\n\t\t\tgoto out_array_args;\n\t\t*kernel_ptr = mbuf;\n\t}\n\n\t/* Handles IOCTL */\n\terr = func(file, cmd, parg);\n\tif (err == -ENOIOCTLCMD)\n\t\terr = -EINVAL;\n\n\tif (has_array_args) {\n\t\t*kernel_ptr = user_ptr;\n\t\tif (copy_to_user(user_ptr, mbuf, array_size))\n\t\t\terr = -EFAULT;\n\t\tgoto out_array_args;\n\t}\n\tif (err < 0)\n\t\tgoto out;\n\nout_array_args:\n\t/*  Copy results into user buffer  */\n\tswitch (_IOC_DIR(cmd)) {\n\tcase _IOC_READ:\n\tcase (_IOC_WRITE | _IOC_READ):\n\t\tif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (type == kGenericOptimized) {\n    optimized_ops::Floor(GetTensorShape(input), GetTensorData<float>(input),\n                         GetTensorShape(output), GetTensorData<float>(output));\n  } else {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  if (type == kGenericOptimized) {\n    optimized_ops::Floor(GetTensorShape(input), GetTensorData<float>(input),\n                         GetTensorShape(output), GetTensorData<float>(output));\n  } else {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void fp54_exp_cyc_sps(fp54_t c, const fp54_t a, const int *b, int len, int sign) {\n\tint i, j, k, w = len;\n    fp54_t t, *u = RLC_ALLOCA(fp54_t, w);\n\n\tif (len == 0) {\n\t\tRLC_FREE(u);\n\t\tfp54_set_dig(c, 1);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void fp54_exp_cyc_sps(fp54_t c, const fp54_t a, const int *b, size_t len,\n\t\tint sign) {\n\tsize_t i, j, k, w = len;\n    fp54_t t, *u = RLC_ALLOCA(fp54_t, w);\n\n\tif (len == 0) {\n\t\tRLC_FREE(u);\n\t\tfp54_set_dig(c, 1);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "NTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,\n                               size_t* pcbAvPairListRemaining)\n{\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\tpAvPair = NULL;\n\n\twhile (pAvPair)\n\t{\n\t\tUINT16 id = ntlm_av_pair_get_id(pAvPair);\n\n\t\tif (id == AvId)\n\t\t\tbreak;\n\t\tif (id == MsvAvEOL)\n\t\t{\n\t\t\tpAvPair = NULL;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "NTLM_AV_PAIR* ntlm_av_pair_get(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList, NTLM_AV_ID AvId,\n                               size_t* pcbAvPairListRemaining)\n{\n\tUINT16 id;\n\tsize_t cbAvPair = cbAvPairList;\n\tNTLM_AV_PAIR* pAvPair = pAvPairList;\n\n\tif (!ntlm_av_pair_check(pAvPair, cbAvPair))\n\t\tpAvPair = NULL;\n\n\twhile (pAvPair && ntlm_av_pair_get_id(pAvPair, cbAvPair, &id))\n\t{\n\t\tif (id == AvId)\n\t\t\tbreak;\n\t\tif (id == MsvAvEOL)\n\t\t{\n\t\t\tpAvPair = NULL;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tskb_reset_network_header(skb);\n\n\t\t/* initialize protocol header pointer */\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb->csum = 0;\n\n\t\t/* specify the length of each IP datagram fragment */\n\t\tskb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;\n\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\t__skb_queue_tail(queue, skb);\n\t}\n\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t/* initialize network header pointer */\n\t\tskb_reset_network_header(skb);\n\n\t\t/* initialize protocol header pointer */\n\t\tskb->transport_header = skb->network_header + fragheaderlen;\n\n\t\tskb->csum = 0;\n\n\n\t\t__skb_queue_tail(queue, skb);\n\t} else if (skb_is_gso(skb)) {\n\t\tgoto append;\n\t}\n\n\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t/* specify the length of each IP datagram fragment */\n\tskb_shinfo(skb)->gso_size = maxfraglen - fragheaderlen;\n\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\nappend:\n\treturn skb_append_datato_frags(sk, skb, getfrag, from,\n\t\t\t\t       (length - transhdrlen));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "define_function(exarg_T *eap, char_u *name_arg, char_u **line_to_free)\n{\n    int\t\tj;\n    int\t\tc;\n    int\t\tsaved_did_emsg;\n    char_u\t*name = name_arg;\n    // invalid.\n    ++p;\n    if (get_function_args(&p, ')', &newargs,\n\t\t\teap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,\n\t\t\t NULL, &varargs, &default_args, eap->skip,\n\t\t\t eap, line_to_free) == FAIL)\n\tgoto errret_2;\n    whitep = p;\n\n    if (eap->cmdidx == CMD_def)\n    {\n    // Save the starting line number.\n    sourcing_lnum_top = SOURCING_LNUM;\n\n    // Do not define the function when getting the body fails and when\n    // skipping.\n    if (get_function_body(eap, &newlines, line_arg, line_to_free) == FAIL\n\t    || eap->skip)\n\tgoto erret;\n\n    /*\n     * If there are no errors, add the function",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "define_function(exarg_T *eap, char_u *name_arg, garray_T *lines_to_free)\n{\n    int\t\tj;\n    int\t\tc;\n    int\t\tsaved_did_emsg;\n    char_u\t*name = name_arg;\n    // invalid.\n    ++p;\n    if (get_function_args(&p, ')', &newargs,\n\t\t\teap->cmdidx == CMD_def ? &argtypes : NULL, FALSE,\n\t\t\t NULL, &varargs, &default_args, eap->skip,\n\t\t\t eap, lines_to_free) == FAIL)\n\tgoto errret_2;\n    whitep = p;\n\n    if (eap->cmdidx == CMD_def)\n    {\n    // Save the starting line number.\n    sourcing_lnum_top = SOURCING_LNUM;\n\n    // Do not define the function when getting the body fails and when\n    // skipping.\n    if (get_function_body(eap, &newlines, line_arg, lines_to_free) == FAIL\n\t    || eap->skip)\n\tgoto erret;\n\n    /*\n     * If there are no errors, add the function",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (!pdev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tqmp = platform_get_drvdata(pdev);\n\n\treturn qmp ? qmp : ERR_PTR(-EPROBE_DEFER);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (!pdev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tqmp = platform_get_drvdata(pdev);\n\n\tif (!qmp) {\n\t\tput_device(&pdev->dev);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\treturn qmp;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\t\t\t     unsigned options,\n\t\t\t\t\t\t     pj_ssize_t buff_size,\n\t\t\t\t\t\t     pjmedia_port **p_port )\n{\n    pjmedia_wave_hdr wave_hdr;\n    pj_ssize_t size_to_read, size_read;\n    struct file_reader_port *fport;\n    pjmedia_audio_format_detail *ad;\n    pj_off_t pos;\n    pj_str_t name;\n    unsigned samples_per_frame;\n    status = pj_file_open( pool, filename, PJ_O_RDONLY, &fport->fd);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Read the file header plus fmt header only. */\n    size_read = size_to_read = sizeof(wave_hdr) - 8;\n    status = pj_file_read( fport->fd, &wave_hdr, &size_read);\n    if (status != PJ_SUCCESS) {\n\tpj_file_close(fport->fd);\n\treturn status;\n    }\n\n    /* If length of fmt_header is greater than 16, skip the remaining\n     * fmt header data.\n     */\n    if (wave_hdr.fmt_hdr.len > 16) {\n\tsize_to_read = wave_hdr.fmt_hdr.len - 16;\n\tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n\t    pj_file_close(fport->fd);\n\t    return status;\n\t}\n\t    wave_hdr.data_hdr.data = PJMEDIA_DATA_TAG;\n\t    wave_hdr.data_hdr.len = subchunk.len;\n\t    break;\n\t}\n\n\t/* Otherwise skip the chunk contents */\n\tsize_to_read = subchunk.len;\n\tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n\t    pj_file_close(fport->fd);\n\t    return status;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\t\t\t     unsigned options,\n\t\t\t\t\t\t     pj_ssize_t buff_size,\n\t\t\t\t\t\t     pjmedia_port **p_port )\n{\n    pjmedia_wave_hdr wave_hdr;\n    pj_ssize_t size_read;\n    pj_off_t size_to_read;\n    struct file_reader_port *fport;\n    pjmedia_audio_format_detail *ad;\n    pj_off_t pos;\n    pj_str_t name;\n    unsigned samples_per_frame;\n    status = pj_file_open( pool, filename, PJ_O_RDONLY, &fport->fd);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Read the file header plus fmt header only. */\n    size_to_read = size_read = sizeof(wave_hdr) - 8;\n    status = pj_file_read( fport->fd, &wave_hdr, &size_read);\n    if (status != PJ_SUCCESS) {\n\tpj_file_close(fport->fd);\n\treturn status;\n    }\n\n    /* If length of fmt_header is greater than 16, skip the remaining\n     * fmt header data.\n     */\n    if (wave_hdr.fmt_hdr.len > 16) {\n\tPJ_CHECK_OVERFLOW_UINT32_TO_LONG(wave_hdr.fmt_hdr.len - 16,\n\t\t      pj_file_close(fport->fd); return PJMEDIA_ENOTVALIDWAVE;);\n\tsize_to_read = (pj_off_t)wave_hdr.fmt_hdr.len - 16;\n\tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n\t    pj_file_close(fport->fd);\n\t    return status;\n\t}\n\t    wave_hdr.data_hdr.len = subchunk.len;\n\t    break;\n\t}\n\n\t/* Otherwise skip the chunk contents */\n\tPJ_CHECK_OVERFLOW_UINT32_TO_LONG(subchunk.len, \n\t\t      pj_file_close(fport->fd); return PJMEDIA_ENOTVALIDWAVE;);\n\tsize_to_read = subchunk.len;\n\n\tstatus = pj_file_setpos(fport->fd, size_to_read, PJ_SEEK_CUR);\n\tif (status != PJ_SUCCESS) {\n\t    pj_file_close(fport->fd);\n\t    return status;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  if (clone_info)\n    clone_info=DestroyImageInfo(clone_info);\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    image=NULL;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  }\n\n  RelinquishMagickMemory(BImgBuff);\n  if (quantum_info != (QuantumInfo *) NULL)\n    quantum_info=DestroyQuantumInfo(quantum_info);\nEND_OF_READING:\n  CloseBlob(image);\n\n\n  {\n    Image *p;\n    while (p != (Image *) NULL)\n      {\n        Image *tmp=p;\n        if ((p->rows == 0) || (p->columns == 0)) {\n          p=p->previous;\n          if (tmp == image2)\n            image2=(Image *) NULL;\n          DeleteImageFromList(&tmp);\n        } else {\n          image=p;\n          p=p->previous;\n        }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    common_context->add_alpn_protocols(Http::Utility::AlpnNames::get().Http2);\n    common_context->add_alpn_protocols(Http::Utility::AlpnNames::get().Http11);\n    common_context->add_alpn_protocols(Http::Utility::AlpnNames::get().Http3);\n  }\n  if (!options.san_.empty()) {\n    common_context->mutable_validation_context()->add_match_subject_alt_names()->set_exact(\n        options.san_);\n  }\n  for (const std::string& cipher_suite : options.cipher_suites_) {\n    common_context->mutable_tls_params()->add_cipher_suites(cipher_suite);\n  }\n  if (!options.sni_.empty()) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    common_context->add_alpn_protocols(Http::Utility::AlpnNames::get().Http2);\n    common_context->add_alpn_protocols(Http::Utility::AlpnNames::get().Http11);\n    common_context->add_alpn_protocols(Http::Utility::AlpnNames::get().Http3);\n  }\n  if (!options.san_.empty()) {\n    envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher* matcher =\n        common_context->mutable_validation_context()->add_match_typed_subject_alt_names();\n    matcher->mutable_matcher()->set_exact(options.san_);\n    matcher->set_san_type(\n        envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::DNS);\n    matcher = common_context->mutable_validation_context()->add_match_typed_subject_alt_names();\n    matcher->mutable_matcher()->set_exact(options.san_);\n    matcher->set_san_type(\n        envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::URI);\n    matcher = common_context->mutable_validation_context()->add_match_typed_subject_alt_names();\n    matcher->mutable_matcher()->set_exact(options.san_);\n    matcher->set_san_type(\n        envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::EMAIL);\n    matcher = common_context->mutable_validation_context()->add_match_typed_subject_alt_names();\n    matcher->mutable_matcher()->set_exact(options.san_);\n    matcher->set_san_type(\n        envoy::extensions::transport_sockets::tls::v3::SubjectAltNameMatcher::IP_ADDRESS);\n  }\n  for (const std::string& cipher_suite : options.cipher_suites_) {\n    common_context->mutable_tls_params()->add_cipher_suites(cipher_suite);\n  }\n  if (!options.sni_.empty()) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void Context::onLog() {\n  if (wasm_->onLog_) {\n    wasm_->onLog_(this, id_);\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void Context::onLog() {\n  if (in_vm_context_created_ && wasm_->onLog_) {\n    wasm_->onLog_(this, id_);\n  }\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int may_create_in_sticky(struct dentry * const dir,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir->d_inode->i_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir->d_inode->i_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\n\tif (likely(dir->d_inode->i_mode & 0002) ||\n\t    (dir->d_inode->i_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int may_create_in_sticky(umode_t dir_mode, kuid_t dir_uid,\n\t\t\t\tstruct inode * const inode)\n{\n\tif ((!sysctl_protected_fifos && S_ISFIFO(inode->i_mode)) ||\n\t    (!sysctl_protected_regular && S_ISREG(inode->i_mode)) ||\n\t    likely(!(dir_mode & S_ISVTX)) ||\n\t    uid_eq(inode->i_uid, dir_uid) ||\n\t    uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn 0;\n\n\tif (likely(dir_mode & 0002) ||\n\t    (dir_mode & 0020 &&\n\t     ((sysctl_protected_fifos >= 2 && S_ISFIFO(inode->i_mode)) ||\n\t      (sysctl_protected_regular >= 2 && S_ISREG(inode->i_mode))))) {\n\t\tconst char *operation = S_ISFIFO(inode->i_mode) ?\n\t\t\t\t\t\"sticky_create_fifo\" :\n\t\t\t\t\t\"sticky_create_regular\";",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    *pixels;\n\n  unsigned int\n    depth;\n\n\n  (void) SeekBlob(image,0,SEEK_SET);\n  while (EOFBlob(image) != MagickFalse)\n  {\n    /*\n     Object parser loop.\n        if (HDR.Type[1] == 0)\n          InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);\n        else\n          InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);\n      }\n    quantum_info=DestroyQuantumInfo(quantum_info);\n    rotate_image=RotateImage(image,90.0,exception);\n    if (rotate_image != (Image *) NULL)\n      {\n        image=DestroyImage(image);\n        image=rotate_image;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n  unsigned int\n    depth;\n\n\n  quantum_info=(QuantumInfo *) NULL;\n  (void) SeekBlob(image,0,SEEK_SET);\n  while (EOFBlob(image) != MagickFalse)\n  {\n    /*\n     Object parser loop.\n        if (HDR.Type[1] == 0)\n          InsertComplexDoubleRow(image,(double *) pixels,y,0,0,exception);\n        else\n          InsertComplexFloatRow(image,(float *) pixels,y,0,0,exception);\n      }\n    if (quantum_info != (QuantumInfo *) NULL)\n      quantum_info=DestroyQuantumInfo(quantum_info);\n    rotate_image=RotateImage(image,90.0,exception);\n    if (rotate_image != (Image *) NULL)\n      {\n        image=DestroyImage(image);\n        image=rotate_image;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "pf_remove_state(struct pf_state *st)\n{\n\tPF_ASSERT_LOCKED();\n\n\tif (st->timeout == PFTM_UNLINKED)\n\t\treturn;\n\n\tst->timeout = PFTM_UNLINKED;\n\n\t/* handle load balancing related tasks */\n\tpf_postprocess_addr(st);\n\n\tif (st->src.state == PF_TCPS_PROXY_DST) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "pf_remove_state(struct pf_state *st)\n{\n\tPF_ASSERT_LOCKED();\n\n\tmtx_enter(&st->mtx);\n\tif (st->timeout == PFTM_UNLINKED) {\n\t\tmtx_leave(&st->mtx);\n\t\treturn;\n\t}\n\tst->timeout = PFTM_UNLINKED;\n\tmtx_leave(&st->mtx);\n\n\t/* handle load balancing related tasks */\n\tpf_postprocess_addr(st);\n\n\tif (st->src.state == PF_TCPS_PROXY_DST) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void TLSOutStream::flush()\n{\n  U8* sentUpTo = start;\n  while (sentUpTo < ptr) {\n    int n = writeTLS(sentUpTo, ptr - sentUpTo);\n    sentUpTo += n;\n    offset += n;\n  }\n\n  ptr = start;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void TLSOutStream::flush()\n{\n  U8* sentUpTo = start;\n  while (sentUpTo < ptr) {\n    size_t n = writeTLS(sentUpTo, ptr - sentUpTo);\n    sentUpTo += n;\n    offset += n;\n  }\n\n  ptr = start;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tif (argcnt < 2) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: interfaces <ifa> <ifb> ...\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t}\n\n\t\t\tfor (i = 0; T.iflist[i] && i < MAXINTERFACES; i++);\n\n\t\t \tif (i + argcnt-1 > MAXINTERFACES) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: to many interfaces, more than %d\", linenum, MAXINTERFACES);\n\t\t\t\terrcnt++;\n\t\t\t} else {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tif (argcnt < 2) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: interfaces <ifa> <ifb> ...\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t}\n\n\t\t\tfor (i = 0; T.iflist[i] && i < MAXINTERFACES; i++) { \n                        };\n\n\t\t \tif (i + argcnt-1 > MAXINTERFACES) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: to many interfaces, more than %d\", linenum, MAXINTERFACES);\n\t\t\t\terrcnt++;\n\t\t\t} else {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  struct pop3_conn *pop3c = &conn->proto.pop3c;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n\n  /* url decode the path and use this mailbox */\n  pop3c->mailbox = curl_easy_unescape(data, path, 0, NULL);\n  if(!pop3c->mailbox)\n    return CURLE_OUT_OF_MEMORY;\n\n  return CURLE_OK;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  struct pop3_conn *pop3c = &conn->proto.pop3c;\n  struct SessionHandle *data = conn->data;\n  const char *path = data->state.path;\n\n  /* url decode the path and use this mailbox */\n  return Curl_urldecode(data, path, 0, &pop3c->mailbox, NULL, TRUE);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    state_param = o_strdup(\"\");\n  }\n  // Check if client is allowed to perform this request\n  if (check_result_value(j_client, G_OK)) {\n    // Client is allowed to use auth_code grant with this redirection_uri\n    if (u_map_has_key(request->map_url, \"g_continue\")) {\n      if (!o_strnullempty(u_map_get(request->map_url, \"scope\"))) {\n        j_session = validate_session_client_scope(config, request, u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"));\n        if (check_result_value(j_session, G_OK)) {\n          if (json_object_get(json_object_get(j_session, \"session\"), \"authorization_required\") == json_false()) {\n            // User has granted access to the cleaned scope list for this client\n            // Generate code, generate the url and redirect to it\n          y_log_message(Y_LOG_LEVEL_ERROR, \"check_auth_type_auth_code_grant - oauth2 - Error validate_session_client_scope\");\n          response->status = 302;\n        }\n        json_decref(j_session);\n      } else {\n        // Scope is not allowed for this user\n        y_log_message(Y_LOG_LEVEL_DEBUG, \"check_auth_type_auth_code_grant - oauth2 - scope list is missing or empty, origin: %s\", ip_source);\n        response->status = 302;\n        redirect_url = msprintf(\"%s%serror=invalid_scope%s\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"), state_param);\n        ulfius_add_header_to_response(response, \"Location\", redirect_url);\n        o_free(redirect_url);\n      }\n    } else {\n      // Redirect to login page\n      redirect_url = get_login_url(config, request, \"auth\", u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"), NULL);\n      ulfius_add_header_to_response(response, \"Location\", redirect_url);\n      o_free(redirect_url);\n      response->status = 302;\n    }\n  } else {\n    // client is not authorized\n    response->status = 302;\n    redirect_url = msprintf(\"%s%serror=unauthorized_client%s%s\", u_map_get(request->map_url, \"redirect_uri\"), (o_strchr(u_map_get(request->map_url, \"redirect_uri\"), '?')!=NULL?\"&\":\"?\"), (u_map_get(request->map_url, \"state\")!=NULL?\"&state=\":\"\"), (u_map_get(request->map_url, \"state\")!=NULL?u_map_get(request->map_url, \"state\"):\"\"));\n    ulfius_add_header_to_response(response, \"Location\", redirect_url);\n    o_free(redirect_url);\n    config->glewlwyd_config->glewlwyd_plugin_callback_metrics_increment_counter(config->glewlwyd_config, GLWD_METRICS_OAUTH2_UNAUTHORIZED_CLIENT, 1, \"plugin\", config->name, NULL);\n  }\n  o_free(state_param);\n  json_decref(j_client);\n  return U_CALLBACK_CONTINUE;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    state_param = o_strdup(\"\");\n  }\n  // Check if client is allowed to perform this request\n  if (check_result_value(j_client, G_OK)) {\n    // Client is allowed to use auth_code grant with this redirection_uri\n    if (!o_strnullempty(u_map_get(request->map_url, \"scope\"))) {\n      if (u_map_has_key(request->map_url, \"g_continue\")) {\n        j_session = validate_session_client_scope(config, request, u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"));\n        if (check_result_value(j_session, G_OK)) {\n          if (json_object_get(json_object_get(j_session, \"session\"), \"authorization_required\") == json_false()) {\n            // User has granted access to the cleaned scope list for this client\n            // Generate code, generate the url and redirect to it\n          y_log_message(Y_LOG_LEVEL_ERROR, \"check_auth_type_auth_code_grant - oauth2 - Error validate_session_client_scope\");\n          response->status = 302;\n        }\n        json_decref(j_session);\n      } else {\n        // Redirect to login page\n        redirect_url = get_login_url(config, request, \"auth\", u_map_get(request->map_url, \"client_id\"), u_map_get(request->map_url, \"scope\"), NULL);\n        ulfius_add_header_to_response(response, \"Location\", redirect_url);\n        o_free(redirect_url);\n        response->status = 302;\n      }\n    } else {\n      // Scope is not allowed for this user\n      y_log_message(Y_LOG_LEVEL_DEBUG, \"check_auth_type_auth_code_grant - oauth2 - scope list is missing or empty, origin: %s\", ip_source);\n      response->status = 403;\n    }\n  } else {\n    // client is not authorized\n    response->status = 403;\n    config->glewlwyd_config->glewlwyd_plugin_callback_metrics_increment_counter(config->glewlwyd_config, GLWD_METRICS_OAUTH2_UNAUTHORIZED_CLIENT, 1, \"plugin\", config->name, NULL);\n  }\n  o_free(state_param);\n  json_decref(j_client);\n  return U_CALLBACK_CONTINUE;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n    PyObject* tmp = NULL;\n    identifier arg;\n    expr_ty value;\n\n    if (exists_not_none(obj, &PyId_arg)) {\n        int res;\n        tmp = _PyObject_GetAttrId(obj, &PyId_arg);\n        if (tmp == NULL) goto failed;\n        res = obj2ast_identifier(tmp, &arg, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    } else {\n        arg = NULL;\n    }\n    if (_PyObject_HasAttrId(obj, &PyId_value)) {\n        int res;\n        tmp = _PyObject_GetAttrId(obj, &PyId_value);\n        if (tmp == NULL) goto failed;\n        res = obj2ast_expr(tmp, &value, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    } else {\n        PyErr_SetString(PyExc_TypeError, \"required field \\\"value\\\" missing from keyword\");\n        return 1;\n    }\n    *out = keyword(arg, value, arena);\n    return 0;\nfailed:\n    Py_XDECREF(tmp);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n    PyObject* tmp = NULL;\n    identifier arg;\n    expr_ty value;\n\n    if (lookup_attr_id(obj, &PyId_arg, &tmp) < 0) {\n        return 1;\n    }\n    if (tmp == NULL || tmp == Py_None) {\n        Py_CLEAR(tmp);\n        arg = NULL;\n    }\n    else {\n        int res;\n        res = obj2ast_identifier(tmp, &arg, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    }\n    if (lookup_attr_id(obj, &PyId_value, &tmp) < 0) {\n        return 1;\n    }\n    if (tmp == NULL) {\n        PyErr_SetString(PyExc_TypeError, \"required field \\\"value\\\" missing from keyword\");\n        return 1;\n    }\n    else {\n        int res;\n        res = obj2ast_expr(tmp, &value, arena);\n        if (res != 0) goto failed;\n        Py_CLEAR(tmp);\n    }\n    *out = keyword(arg, value, arena);\n    return 0;\nfailed:\n    Py_XDECREF(tmp);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void dbEvalSetColumn(DbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[200];\n\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n\n    switch( sqlite3_column_type(pStmt, iCol) ) {\n    case SQLITE_BLOB: {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void dbEvalSetColumn(DbEvalContext *p, int iCol, Jsi_DString *dStr) {\n    Jsi_Interp *interp = p->jdb->interp;\n    char nbuf[JSI_MAX_NUMBER_STRING];\n\n    sqlite3_stmt *pStmt = p->pPreStmt->pStmt;\n\n    switch( sqlite3_column_type(pStmt, iCol) ) {\n    case SQLITE_BLOB: {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "FontData::FontData(FontData* data, int32_t offset) {\n  Init(data->array_);\n  Bound(data->bound_offset_ + offset,\n        (data->bound_length_ == GROWABLE_SIZE)\n            ? GROWABLE_SIZE : data->bound_length_ - offset);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "FontData::FontData(FontData* data, int32_t offset) {\n  Init(data->array_);\n  Bound(data->bound_offset_ + offset,\n        (data->bound_length_ == GROWABLE_SIZE)\n        ? GROWABLE_SIZE : data->bound_length_ - offset);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tif (atomic_dec_and_test(&ucounts->count)) {\n\t\tspin_lock_irqsave(&ucounts_lock, flags);\n\t\thlist_del_init(&ucounts->node);\n\t\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\n\t\tkfree(ucounts);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void put_ucounts(struct ucounts *ucounts)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ucounts_lock, flags);\n\tucounts->count -= 1;\n\tif (!ucounts->count)\n\t\thlist_del_init(&ucounts->node);\n\telse\n\t\tucounts = NULL;\n\tspin_unlock_irqrestore(&ucounts_lock, flags);\n\n\tkfree(ucounts);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void CZNC::ForceEncoding() {\n    m_uiForceEncoding++;\n#ifdef HAVE_ICU\n    for (Csock* pSock : GetManager()) {\n        if (pSock->GetEncoding().empty()) {\n            pSock->SetEncoding(\"UTF-8\");\n        }\n    }\n#endif\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void CZNC::ForceEncoding() {\n    m_uiForceEncoding++;\n#ifdef HAVE_ICU\n    for (Csock* pSock : GetManager()) {\n        pSock->SetEncoding(FixupEncoding(pSock->GetEncoding()));\n    }\n#endif\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t    (mi_is_any_key_active(share->state.key_map) ||\n\t     (rep_quick && !param->keys_in_use && !recreate)) &&\n\t    mi_test_if_sort_rep(info, info->state->records,\n\t\t\t\tinfo->s->state.key_map,\n\t\t\t\tparam->force_sort))\n\t{\n          if (param->testflag & T_REP_BY_SORT)\n            error=mi_repair_by_sort(param,info,filename,rep_quick);\n          else\n            error=mi_repair_parallel(param,info,filename,rep_quick);\n\t  state_updated=1;\n\t}\n\telse if (param->testflag & T_REP_ANY)\n\t  error=mi_repair(param, info,filename,rep_quick);\n      }\n      if (!error && param->testflag & T_SORT_RECORDS)\n      {\n\t/*\n\t  The data file is nowadays reopened in the repair code so we should\n\t  datafile=info->dfile;\t/* This is now locked */\n\t  if (!error && !update_index)\n\t  {\n\t    if (param->verbose)\n\t      puts(\"Table had a compressed index;  We must now recreate the index\");\n\t    error=mi_repair_by_sort(param,info,filename,1);\n\t  }\n\t}\n      }\n      if (!error && param->testflag & T_SORT_INDEX)\n\terror=mi_sort_index(param,info,filename);\n      if (!error)\n\tshare->state.changed&= ~(STATE_CHANGED | STATE_CRASHED |\n\t\t\t\t STATE_CRASHED_ON_REPAIR);\n      else\n\tmi_mark_crashed(info);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t     (rep_quick && !param->keys_in_use && !recreate)) &&\n\t    mi_test_if_sort_rep(info, info->state->records,\n\t\t\t\tinfo->s->state.key_map,\n\t\t\t\tparam->force_sort))\n\t{\n          /*\n            The new file might not be created with the right stats depending\n            on how myisamchk is run, so we must copy file stats from old to new.\n          */\n          if (param->testflag & T_REP_BY_SORT)\n            error= mi_repair_by_sort(param, info, filename, rep_quick, FALSE);\n          else\n            error= mi_repair_parallel(param, info, filename, rep_quick, FALSE);\n\t  state_updated=1;\n\t}\n\telse if (param->testflag & T_REP_ANY)\n\t  error= mi_repair(param, info, filename, rep_quick, FALSE);\n      }\n      if (!error && param->testflag & T_SORT_RECORDS)\n      {\n\t/*\n\t  The data file is nowadays reopened in the repair code so we should\n\t  datafile=info->dfile;\t/* This is now locked */\n\t  if (!error && !update_index)\n\t  {\n\t    if (param->verbose)\n\t      puts(\"Table had a compressed index;  We must now recreate the index\");\n\t    error= mi_repair_by_sort(param, info, filename, 1, FALSE);\n\t  }\n\t}\n      }\n      if (!error && param->testflag & T_SORT_INDEX)\n\terror= mi_sort_index(param, info, filename, FALSE);\n      if (!error)\n\tshare->state.changed&= ~(STATE_CHANGED | STATE_CRASHED |\n\t\t\t\t STATE_CRASHED_ON_REPAIR);\n      else\n\tmi_mark_crashed(info);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + (inuse / 8) + 2*EXTRA_STACK;\n  if (goodsize > LUAI_MAXSTACK)\n    goodsize = LUAI_MAXSTACK;  /* respect stack limit */\n  /* if thread is currently not handling a stack overflow and its\n     good size is smaller than current size, shrink its stack */\n  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) &&\n      goodsize < L->stacksize)\n    luaD_reallocstack(L, goodsize, 0);  /* ok if that fails */\n  else  /* don't change stack */\n    condmovestack(L,{},{});  /* (change only for debugging) */\n  luaE_shrinkCI(L);  /* shrink CI list */\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void luaD_shrinkstack (lua_State *L) {\n  int inuse = stackinuse(L);\n  int goodsize = inuse + BASIC_STACK_SIZE;\n  if (goodsize > LUAI_MAXSTACK)\n    goodsize = LUAI_MAXSTACK;  /* respect stack limit */\n  /* if thread is currently not handling a stack overflow and its\n     good size is smaller than current size, shrink its stack */\n  if (inuse <= (LUAI_MAXSTACK - EXTRA_STACK) && goodsize < L->stacksize)\n    luaD_reallocstack(L, goodsize, 0);  /* ok if that fails */\n  else  /* don't change stack */\n    condmovestack(L,{},{});  /* (change only for debugging) */\n  luaE_shrinkCI(L);  /* shrink CI list */\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        {\n            int class = getClientTypeByName(argv[1]);\n            unsigned long long hard, soft;\n            int soft_seconds;\n\n            if (class == -1) {\n                err = \"Unrecognized client limit class\";\n                goto loaderr;\n            }\n            hard = memtoll(argv[2],NULL);\n            soft = memtoll(argv[3],NULL);\n            soft_seconds = atoi(argv[4]);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        {\n            int class = getClientTypeByName(argv[1]);\n            unsigned long long hard, soft;\n            int soft_seconds;\n\n            if (class == -1 || class == CLIENT_TYPE_MASTER) {\n                err = \"Unrecognized client limit class: the user specified \"\n                \"an invalid one, or 'master' which has no buffer limits.\";\n                goto loaderr;\n            }\n            hard = memtoll(argv[2],NULL);\n            soft = memtoll(argv[3],NULL);\n            soft_seconds = atoi(argv[4]);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  const struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\n\tif (!dst)\n\t\tgoto out;\n\n\t/* Yes, checking route validity in not connected\n\t * case is not very simple. Take into account,\n\t * that we do not support routing by source, TOS,\n\t * and MSG_DONTROUTE \t\t--ANK (980726)\n\t *",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  const struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt;\n\n\tif (!dst)\n\t\tgoto out;\n\n\tif (dst->ops->family != AF_INET6) {\n\t\tdst_release(dst);\n\t\treturn NULL;\n\t}\n\n\trt = (struct rt6_info *)dst;\n\t/* Yes, checking route validity in not connected\n\t * case is not very simple. Take into account,\n\t * that we do not support routing by source, TOS,\n\t * and MSG_DONTROUTE \t\t--ANK (980726)\n\t *",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t    case XD3_RUN: *rptr++ = 'R'; break;\n\t    case XD3_CPY: *rptr++ = 'C'; break;\n\t    default: CHECK(0);\n\t    }\n\n\t  snprintf_func (rptr, rbuf+TESTBUFSIZE-rptr, \"%d/%d\", \n\t\t\t inst->pos, inst->size);\n\t  rptr += strlen (rptr);\n\n\t  if (inst->type == XD3_CPY)\n\t    {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t    case XD3_RUN: *rptr++ = 'R'; break;\n\t    case XD3_CPY: *rptr++ = 'C'; break;\n\t    default: CHECK(0);\n\t    }\n\n\t  snprintf_func (rptr, rbuf+TESTBUFSIZE-rptr, \"%d/%d\",\n\t\t\t inst->pos, inst->size);\n\t  rptr += strlen (rptr);\n\n\t  if (inst->type == XD3_CPY)\n\t    {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "zfs_groupmember(zfsvfs_t *zfsvfs, uint64_t id, cred_t *cr)\n{\n#ifdef HAVE_KSID\n\tksid_t\t\t*ksid = crgetsid(cr, KSID_GROUP);\n\tksidlist_t\t*ksidlist = crgetsidlist(cr);\n\tuid_t\t\tgid;\n\n\tif (ksid && ksidlist) {\n\t\tint\t\ti;\n\t\tksid_t\t\t*ksid_groups;\n\t\tuint32_t\tidx = FUID_INDEX(id);\n\t\t\t\t    ksid_groups[i].ks_domain->kd_name) == 0) &&\n\t\t\t\t    rid == ksid_groups[i].ks_rid)\n\t\t\t\t\treturn (B_TRUE);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Not found in ksidlist, check posix groups\n\t */\n\tgid = zfs_fuid_map_id(zfsvfs, id, cr, ZFS_GROUP);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "zfs_groupmember(zfsvfs_t *zfsvfs, uint64_t id, cred_t *cr)\n{\n#ifdef HAVE_KSID\n\tuid_t\t\tgid;\n\n#ifdef illumos\n\tksid_t\t\t*ksid = crgetsid(cr, KSID_GROUP);\n\tksidlist_t\t*ksidlist = crgetsidlist(cr);\n\n\tif (ksid && ksidlist) {\n\t\tint\t\ti;\n\t\tksid_t\t\t*ksid_groups;\n\t\tuint32_t\tidx = FUID_INDEX(id);\n\t\t\t\t    rid == ksid_groups[i].ks_rid)\n\t\t\t\t\treturn (B_TRUE);\n\t\t\t}\n\t\t}\n\t}\n#endif /* illumos */\n\n\t/*\n\t * Not found in ksidlist, check posix groups\n\t */\n\tgid = zfs_fuid_map_id(zfsvfs, id, cr, ZFS_GROUP);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tstruct smb_acl *parent_pdacl;\n\tstruct smb_ntsd *parent_pntsd = NULL;\n\tstruct smb_sid owner_sid, group_sid;\n\tstruct dentry *parent = path->dentry->d_parent;\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0;\n\tint rc = 0, num_aces, dacloffset, pntsd_type, acl_len;\n\tchar *aces_base;\n\tbool is_dir = S_ISDIR(d_inode(path->dentry)->i_mode);\n\n\tacl_len = ksmbd_vfs_get_sd_xattr(conn, user_ns,\n\t\t\t\t\t parent, &parent_pntsd);\n\tif (acl_len <= 0)\n\t\treturn -ENOENT;\n\tdacloffset = le32_to_cpu(parent_pntsd->dacloffset);\n\tif (!dacloffset) {\n\t\trc = -EINVAL;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\tparent_pdacl = (struct smb_acl *)((char *)parent_pntsd + dacloffset);\n\tnum_aces = le32_to_cpu(parent_pdacl->num_aces);\n\tpntsd_type = le16_to_cpu(parent_pntsd->type);\n\n\taces_base = kmalloc(sizeof(struct smb_ace) * num_aces * 2, GFP_KERNEL);\n\tif (!aces_base) {\n\t\trc = -ENOMEM;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\taces = (struct smb_ace *)aces_base;\n\tparent_aces = (struct smb_ace *)((char *)parent_pdacl +\n\t\t\tsizeof(struct smb_acl));\n\n\tif (pntsd_type & DACL_AUTO_INHERITED)\n\t\tinherited_flags = INHERITED_ACE;\n\n\tfor (i = 0; i < num_aces; i++) {\n\t\tflags = parent_aces->flags;\n\t\tif (!smb_inherit_flags(flags, is_dir))\n\t\t\tgoto pass;\n\t\tif (is_dir) {\n\t\t\tflags &= ~(INHERIT_ONLY_ACE | INHERITED_ACE);\n\t\t\t    parent_aces->access_req);\n\t\tnt_size += le16_to_cpu(aces->size);\n\t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n\t\tace_cnt++;\npass:\n\t\tparent_aces =\n\t\t\t(struct smb_ace *)((char *)parent_aces + le16_to_cpu(parent_aces->size));\n\t}\n\n\tif (nt_size > 0) {\n\t\tstruct smb_ntsd *pntsd;\n\t\tstruct smb_acl *pdacl;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tstruct smb_acl *parent_pdacl;\n\tstruct smb_ntsd *parent_pntsd = NULL;\n\tstruct smb_sid owner_sid, group_sid;\n\tstruct dentry *parent = path->dentry->d_parent;\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0, pdacl_size;\n\tint rc = 0, num_aces, dacloffset, pntsd_type, pntsd_size, acl_len, aces_size;\n\tchar *aces_base;\n\tbool is_dir = S_ISDIR(d_inode(path->dentry)->i_mode);\n\n\tpntsd_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,\n\t\t\t\t\t    parent, &parent_pntsd);\n\tif (pntsd_size <= 0)\n\t\treturn -ENOENT;\n\tdacloffset = le32_to_cpu(parent_pntsd->dacloffset);\n\tif (!dacloffset || (dacloffset + sizeof(struct smb_acl) > pntsd_size)) {\n\t\trc = -EINVAL;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\tparent_pdacl = (struct smb_acl *)((char *)parent_pntsd + dacloffset);\n\tacl_len = pntsd_size - dacloffset;\n\tnum_aces = le32_to_cpu(parent_pdacl->num_aces);\n\tpntsd_type = le16_to_cpu(parent_pntsd->type);\n\tpdacl_size = le16_to_cpu(parent_pdacl->size);\n\n\tif (pdacl_size > acl_len || pdacl_size < sizeof(struct smb_acl)) {\n\t\trc = -EINVAL;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\taces_base = kmalloc(sizeof(struct smb_ace) * num_aces * 2, GFP_KERNEL);\n\tif (!aces_base) {\n\t\trc = -ENOMEM;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\taces = (struct smb_ace *)aces_base;\n\tparent_aces = (struct smb_ace *)((char *)parent_pdacl +\n\t\t\tsizeof(struct smb_acl));\n\taces_size = acl_len - sizeof(struct smb_acl);\n\n\tif (pntsd_type & DACL_AUTO_INHERITED)\n\t\tinherited_flags = INHERITED_ACE;\n\n\tfor (i = 0; i < num_aces; i++) {\n\t\tint pace_size;\n\n\t\tif (offsetof(struct smb_ace, access_req) > aces_size)\n\t\t\tbreak;\n\n\t\tpace_size = le16_to_cpu(parent_aces->size);\n\t\tif (pace_size > aces_size)\n\t\t\tbreak;\n\n\t\taces_size -= pace_size;\n\n\t\tflags = parent_aces->flags;\n\t\tif (!smb_inherit_flags(flags, is_dir))\n\t\t\tgoto pass;\n\t\tif (is_dir) {\n\t\t\tflags &= ~(INHERIT_ONLY_ACE | INHERITED_ACE);\n\t\t\t    parent_aces->access_req);\n\t\tnt_size += le16_to_cpu(aces->size);\n\t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n\t\tace_cnt++;\npass:\n\t\tparent_aces = (struct smb_ace *)((char *)parent_aces + pace_size);\n\t}\n\n\tif (nt_size > 0) {\n\t\tstruct smb_ntsd *pntsd;\n\t\tstruct smb_acl *pdacl;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "mrb_proc_copy(struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    /* already initialized proc */\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(NULL, (mrb_irep*)a->body.irep);\n  }\n  a->upper = b->upper;\n  a->e.env = b->e.env;\n  /* a->e.target_class = a->e.target_class; */\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "mrb_proc_copy(mrb_state *mrb, struct RProc *a, struct RProc *b)\n{\n  if (a->body.irep) {\n    /* already initialized proc */\n    return;\n  }\n  a->flags = b->flags;\n  a->body = b->body;\n  a->upper = b->upper;\n  if (!MRB_PROC_CFUNC_P(a) && a->body.irep) {\n    mrb_irep_incref(mrb, (mrb_irep*)a->body.irep);\n  }\n  a->e.env = b->e.env;\n  /* a->e.target_class = a->e.target_class; */\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        BSIZE += std::max(BSIZE, need);\n        char * buf = new char[BSIZE + YYMAXFILL];\n        if (!buf) fatal(\"out of memory\");\n\n        memmove(buf, tok, copy);\n        shift_ptrs_and_fpos(buf - bot);\n        delete [] bot;\n        bot = buf;\n\n        free = BSIZE - copy;\n    }\n\n    if (!read(free)) {\n        eof = lim;\n        memset(lim, 0, YYMAXFILL);\n        lim += YYMAXFILL;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        BSIZE += std::max(BSIZE, need);\n        char * buf = new char[BSIZE + YYMAXFILL];\n        if (!buf) fatal(\"out of memory\");\n\n        memmove(buf, tok, copy);\n        shift_ptrs_and_fpos(buf - tok);\n        delete [] bot;\n        bot = buf;\n\n        free = BSIZE - copy;\n    }\n\n    DASSERT(lim + free <= bot + BSIZE);\n    if (!read(free)) {\n        eof = lim;\n        memset(lim, 0, YYMAXFILL);\n        lim += YYMAXFILL;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\t\tupdate_memslots(slots, NULL);\n\n\t\told_memslots = kvm->memslots;\n\t\trcu_assign_pointer(kvm->memslots, slots);\n\t\tsynchronize_srcu_expedited(&kvm->srcu);\n\t\t/* From this point no new shadow pages pointing to a deleted,\n\t\t * or moved, memslot will be created.\n\t\t *\n\t\t * validation of sp->gfn happens in:\n\t\t * \t- gfn_to_hva (kvm_read_guest, gfn_to_pfn)\n\n\tr = kvm_arch_prepare_memory_region(kvm, &new, old, mem, user_alloc);\n\tif (r)\n\t\tgoto out_free;\n\n\t/* map/unmap the pages in iommu page table */\n\tif (npages) {\n\t\tr = kvm_iommu_map_pages(kvm, &new);\n\t\tif (r)\n\t\t\tgoto out_free;\n\t} else\n\t\tkvm_iommu_unmap_pages(kvm, &old);\n\n\tr = -ENOMEM;\n\tslots = kmemdup(kvm->memslots, sizeof(struct kvm_memslots),\n\t\t\tGFP_KERNEL);\n\tif (!slots)\n\t\tgoto out_free;\n\n\t/* actual memory is freed via old in kvm_free_physmem_slot below */\n\tif (!npages) {\n\t\tnew.dirty_bitmap = NULL;\n\t\tmemset(&new.arch, 0, sizeof(new.arch));\n\n\tkvm_free_physmem_slot(&old, &new);\n\tkfree(old_memslots);\n\n\treturn 0;\n\nout_free:\n\tkvm_free_physmem_slot(&new, &old);\nout:\n\treturn r;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tupdate_memslots(slots, NULL);\n\n\t\told_memslots = kvm->memslots;\n\t\trcu_assign_pointer(kvm->memslots, slots);\n\t\tsynchronize_srcu_expedited(&kvm->srcu);\n\t\t/* slot was deleted or moved, clear iommu mapping */\n\t\tkvm_iommu_unmap_pages(kvm, &old);\n\t\t/* From this point no new shadow pages pointing to a deleted,\n\t\t * or moved, memslot will be created.\n\t\t *\n\t\t * validation of sp->gfn happens in:\n\t\t * \t- gfn_to_hva (kvm_read_guest, gfn_to_pfn)\n\t}\n\n\tr = kvm_arch_prepare_memory_region(kvm, &new, old, mem, user_alloc);\n\tif (r)\n\t\tgoto out_free;\n\n\tr = -ENOMEM;\n\tslots = kmemdup(kvm->memslots, sizeof(struct kvm_memslots),\n\t\t\tGFP_KERNEL);\n\tif (!slots)\n\t\tgoto out_free;\n\n\t/* map new memory slot into the iommu */\n\tif (npages) {\n\t\tr = kvm_iommu_map_pages(kvm, &new);\n\t\tif (r)\n\t\t\tgoto out_slots;\n\t}\n\n\t/* actual memory is freed via old in kvm_free_physmem_slot below */\n\tif (!npages) {\n\t\tnew.dirty_bitmap = NULL;\n\t\tmemset(&new.arch, 0, sizeof(new.arch));\n\tkvm_free_physmem_slot(&old, &new);\n\tkfree(old_memslots);\n\n\treturn 0;\n\nout_slots:\n\tkfree(slots);\nout_free:\n\tkvm_free_physmem_slot(&new, &old);\nout:\n\treturn r;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n    unsigned char key[OU_key_bytes_V4];\n    compute_O_rc4_key(user_password, owner_password, data, key);\n    unsigned char O_data[key_bytes];\n    memcpy(O_data, QUtil::unsigned_char_pointer(data.getO()), key_bytes);\n    iterate_rc4(O_data, key_bytes, key, data.getLengthBytes(),\n                (data.getR() >= 3) ? 20 : 1, true);\n    std::string new_user_password =\n        std::string(reinterpret_cast<char*>(O_data), key_bytes);\n    bool result = false;\n    if (check_user_password(new_user_password, data))",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n    unsigned char key[OU_key_bytes_V4];\n    compute_O_rc4_key(user_password, owner_password, data, key);\n    unsigned char O_data[key_bytes];\n    memcpy(O_data, QUtil::unsigned_char_pointer(data.getO()), key_bytes);\n    std::string k1(reinterpret_cast<char*>(key), OU_key_bytes_V4);\n    pad_short_parameter(k1, data.getLengthBytes());\n    iterate_rc4(O_data, key_bytes, QUtil::unsigned_char_pointer(k1),\n                data.getLengthBytes(),\n                (data.getR() >= 3) ? 20 : 1, true);\n    std::string new_user_password =\n        std::string(reinterpret_cast<char*>(O_data), key_bytes);\n    bool result = false;\n    if (check_user_password(new_user_password, data))",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t * lower file is fput() when all eCryptfs files for the inode are\n\t * released. */\n\tflags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;\n\t(*lower_file) = dentry_open(&req.path, flags, cred);\n\tif (!IS_ERR(*lower_file))\n\t\tgoto out;\n\tif ((flags & O_ACCMODE) == O_RDONLY) {\n\t\trc = PTR_ERR((*lower_file));\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\t}\n\tlist_add_tail(&req.kthread_ctl_list, &ecryptfs_kthread_ctl.req_list);\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n\twait_for_completion(&req.done);\n\tif (IS_ERR(*lower_file))\n\t\trc = PTR_ERR(*lower_file);\nout:\n\treturn rc;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t * lower file is fput() when all eCryptfs files for the inode are\n\t * released. */\n\tflags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;\n\t(*lower_file) = dentry_open(&req.path, flags, cred);\n\tif (!IS_ERR(*lower_file))\n\t\tgoto have_file;\n\tif ((flags & O_ACCMODE) == O_RDONLY) {\n\t\trc = PTR_ERR((*lower_file));\n\t\tgoto out;\n\t}\n\tmutex_lock(&ecryptfs_kthread_ctl.mux);\n\t}\n\tlist_add_tail(&req.kthread_ctl_list, &ecryptfs_kthread_ctl.req_list);\n\tmutex_unlock(&ecryptfs_kthread_ctl.mux);\n\twake_up(&ecryptfs_kthread_ctl.wait);\n\twait_for_completion(&req.done);\n\tif (IS_ERR(*lower_file)) {\n\t\trc = PTR_ERR(*lower_file);\n\t\tgoto out;\n\t}\nhave_file:\n\tif ((*lower_file)->f_op->mmap == NULL) {\n\t\tfput(*lower_file);\n\t\t*lower_file = NULL;\n\t\trc = -EMEDIUMTYPE;\n\t}\nout:\n\treturn rc;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ast2obj_arguments(void* _o)\n{\n    arguments_ty o = (arguments_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    result = PyType_GenericNew(arguments_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_list(o->args, ast2obj_arg);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ast2obj_arguments(void* _o)\n{\n    arguments_ty o = (arguments_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_RETURN_NONE;\n    }\n\n    result = PyType_GenericNew(arguments_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_list(o->args, ast2obj_arg);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void infra_ip_create_ratedata(struct infra_cache* infra,\n\tstruct sockaddr_storage* addr, socklen_t addrlen, time_t timenow)\n{\n\thashvalue_type h = hash_addr(addr, addrlen, 0);\n\tstruct ip_rate_key* k = (struct ip_rate_key*)calloc(1, sizeof(*k));\n\tstruct ip_rate_data* d = (struct ip_rate_data*)calloc(1, sizeof(*d));\n\tif(!k || !d) {\n\tlock_rw_init(&k->entry.lock);\n\tk->entry.hash = h;\n\tk->entry.key = k;\n\tk->entry.data = d;\n\td->qps[0] = 1;\n\td->timestamp[0] = timenow;\n\tslabhash_insert(infra->client_ip_rates, h, &k->entry, d, NULL);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void infra_ip_create_ratedata(struct infra_cache* infra,\n\tstruct sockaddr_storage* addr, socklen_t addrlen, time_t timenow,\n\tint mesh_wait)\n{\n\thashvalue_type h = hash_addr(addr, addrlen, 0);\n\tstruct ip_rate_key* k = (struct ip_rate_key*)calloc(1, sizeof(*k));\n\tstruct ip_rate_data* d = (struct ip_rate_data*)calloc(1, sizeof(*d));\n\tif(!k || !d) {\n\tk->entry.hash = h;\n\tk->entry.key = k;\n\tk->entry.data = d;\n\td->qps[0] = 1;\n\td->timestamp[0] = timenow;\n\td->mesh_wait = mesh_wait;\n\tslabhash_insert(infra->client_ip_rates, h, &k->entry, d, NULL);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tStream_Read_UINT32(irp->input, SharedAccess);      /* SharedAccess (4 bytes) */\n\tStream_Read_UINT32(irp->input, CreateDisposition); /* CreateDisposition (4 bytes) */\n\tStream_Seek_UINT32(irp->input);                    /* CreateOptions (4 bytes) */\n\tStream_Read_UINT32(irp->input, PathLength);        /* PathLength (4 bytes) */\n\n\tif (Stream_GetRemainingLength(irp->input) < PathLength)\n\t\treturn ERROR_INVALID_DATA;\n\n\tStream_Seek(irp->input, PathLength); /* Path (variable) */\n\tassert(PathLength == 0);             /* MS-RDPESP 2.2.2.2 */\n#ifndef _WIN32\n\t/* Windows 2012 server sends on a first call :\n\t *     DesiredAccess     = 0x00100080: SYNCHRONIZE | FILE_READ_ATTRIBUTES\n\t *     SharedAccess      = 0x00000007: FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tStream_Read_UINT32(irp->input, SharedAccess);      /* SharedAccess (4 bytes) */\n\tStream_Read_UINT32(irp->input, CreateDisposition); /* CreateDisposition (4 bytes) */\n\tStream_Seek_UINT32(irp->input);                    /* CreateOptions (4 bytes) */\n\tStream_Read_UINT32(irp->input, PathLength);        /* PathLength (4 bytes) */\n\n\tif (!Stream_SafeSeek(irp->input, PathLength)) /* Path (variable) */\n\t\treturn ERROR_INVALID_DATA;\n\n\tassert(PathLength == 0);             /* MS-RDPESP 2.2.2.2 */\n#ifndef _WIN32\n\t/* Windows 2012 server sends on a first call :\n\t *     DesiredAccess     = 0x00100080: SYNCHRONIZE | FILE_READ_ATTRIBUTES\n\t *     SharedAccess      = 0x00000007: FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    size_t oft = strtoul(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    LOG(LL_DEBUG,\n        (\"%p %d bytes @ %d [%s]\", c->fd, (int) hm->body.len, (int) oft, name));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", name, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  if (name[0] == '\\0') {\n    mg_http_reply(c, 400, \"\", \"%s\", \"name required\");\n    return -1;\n  } else {\n    FILE *fp;\n    long oft = strtol(offset, NULL, 0);\n    snprintf(path, sizeof(path), \"%s%c%s\", dir, MG_DIRSEP, name);\n    remove_double_dots(path);\n    LOG(LL_DEBUG, (\"%d bytes @ %ld [%s]\", (int) hm->body.len, oft, path));\n    if ((fp = fopen(path, oft == 0 ? \"wb\" : \"ab\")) == NULL) {\n      mg_http_reply(c, 400, \"\", \"fopen(%s): %d\", path, errno);\n      return -2;\n    } else {\n      fwrite(hm->body.ptr, 1, hm->body.len, fp);\n      fclose(fp);\n      mg_http_reply(c, 200, \"\", \"\");",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\telse\n\t    next = peek_next_line_from_context(evalarg->eval_cctx);\n\n\tif (next != NULL)\n\t{\n\t    *getnext = TRUE;\n\t    return skipwhite(next);\n\t}\n    }\n    return p;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\telse\n\t    next = peek_next_line_from_context(evalarg->eval_cctx);\n\n\tif (next != NULL)\n\t{\n\t    *getnext = *p != NL;\n\t    return skipwhite(next);\n\t}\n    }\n    return p;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n    /* ok run this for all files to be sure all are good for playback. */\n    for (index=file_count-1; index>=0; index--) {\n\n\tpjmedia_wave_hdr wavehdr;\n\tpj_ssize_t size_to_read, size_read;\n\n\t/* we end with the last one so we are good to go if still in function*/\n\tpj_memcpy(filename, file_list[index].ptr, file_list[index].slen);\n\tfilename[file_list[index].slen] = '\\0';\n\n\t\t\t       &fport->fd_list[index]);\n\tif (status != PJ_SUCCESS)\n\t    goto on_error;\n\t\n\t/* Read the file header plus fmt header only. */\n\tsize_read = size_to_read = sizeof(wavehdr) - 8;\n\tstatus = pj_file_read( fport->fd_list[index], &wavehdr, &size_read);\n\tif (status != PJ_SUCCESS) {\n\t    goto on_error;\n\t}\n\n\t\n\t/* If length of fmt_header is greater than 16, skip the remaining\n\t * fmt header data.\n\t */\n\tif (wavehdr.fmt_hdr.len > 16) {\n\t    size_to_read = wavehdr.fmt_hdr.len - 16;\n\t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n\t\t\t\t    PJ_SEEK_CUR);\n\t    if (status != PJ_SUCCESS) {\n\t\tgoto on_error;\n\t    }\n\t\twavehdr.data_hdr.data = PJMEDIA_DATA_TAG;\n\t\twavehdr.data_hdr.len = subchunk.len;\n\t\tbreak;\n\t    }\n\t    \n\t    /* Otherwise skip the chunk contents */\n\t    size_to_read = subchunk.len;\n\t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n\t\t\t\t    PJ_SEEK_CUR);\n\t    if (status != PJ_SUCCESS) {\n\t\tgoto on_error;\n\t    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n    /* ok run this for all files to be sure all are good for playback. */\n    for (index=file_count-1; index>=0; index--) {\n\n\tpjmedia_wave_hdr wavehdr;\n\tpj_ssize_t size_read;\n\tpj_off_t size_to_read;\n\n\t/* we end with the last one so we are good to go if still in function*/\n\tpj_memcpy(filename, file_list[index].ptr, file_list[index].slen);\n\tfilename[file_list[index].slen] = '\\0';\n\n\t\t\t       &fport->fd_list[index]);\n\tif (status != PJ_SUCCESS)\n\t    goto on_error;\n\t\n\t/* Read the file header plus fmt header only. */\n\tsize_to_read = size_read = sizeof(wavehdr) - 8;\t\n\tstatus = pj_file_read( fport->fd_list[index], &wavehdr, &size_read);\n\tif (status != PJ_SUCCESS) {\n\t    goto on_error;\n\t}\n\n\t\n\t/* If length of fmt_header is greater than 16, skip the remaining\n\t * fmt header data.\n\t */\n\tif (wavehdr.fmt_hdr.len > 16) {\n\t    PJ_CHECK_OVERFLOW_UINT32_TO_LONG(wavehdr.fmt_hdr.len-16,\n\t\t\t       status = PJMEDIA_ENOTVALIDWAVE; goto on_error;);\n\t    size_to_read = (pj_off_t)wavehdr.fmt_hdr.len - 16;\n\t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n\t\t\t\t    PJ_SEEK_CUR);\n\t    if (status != PJ_SUCCESS) {\n\t\tgoto on_error;\n\t    }\n\t\twavehdr.data_hdr.len = subchunk.len;\n\t\tbreak;\n\t    }\n\t    \n\t    /* Otherwise skip the chunk contents */\n\t    PJ_CHECK_OVERFLOW_UINT32_TO_LONG(subchunk.len, \n\t\t\t       status = PJMEDIA_ENOTVALIDWAVE; goto on_error;);\n\t    size_to_read = subchunk.len;\n\n\t    status = pj_file_setpos(fport->fd_list[index], size_to_read, \n\t\t\t\t    PJ_SEEK_CUR);\n\t    if (status != PJ_SUCCESS) {\n\t\tgoto on_error;\n\t    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "inline void AveragePool(const PoolParams& params,\n                        const RuntimeShape& input_shape,\n                        const int8_t* input_data,\n                        const RuntimeShape& output_shape, int8_t* output_data) {\n  TFLITE_DCHECK_LE(params.quantized_activation_min,\n                   params.quantized_activation_max);\n  TFLITE_DCHECK_EQ(input_shape.DimensionsCount(), 4);\n  TFLITE_DCHECK_EQ(output_shape.DimensionsCount(), 4);\n  const int batches = MatchingDim(input_shape, 0, output_shape, 0);\n  const int depth = MatchingDim(input_shape, 3, output_shape, 3);\n  const int input_height = input_shape.Dims(1);\n  const int input_width = input_shape.Dims(2);\n  const int output_height = output_shape.Dims(1);\n  const int output_width = output_shape.Dims(2);\n  const int stride_height = params.stride_height;\n  const int stride_width = params.stride_width;\n  for (int batch = 0; batch < batches; ++batch) {\n    for (int out_y = 0; out_y < output_height; ++out_y) {\n      for (int out_x = 0; out_x < output_width; ++out_x) {\n        for (int channel = 0; channel < depth; ++channel) {\n          const int in_x_origin =\n              (out_x * stride_width) - params.padding_values.width;\n          const int in_y_origin =\n              (out_y * stride_height) - params.padding_values.height;\n          // Compute the boundaries of the filter region clamped so as to\n          // ensure that the filter window fits in the input array.\n          const int filter_x_start = std::max(0, -in_x_origin);\n          const int filter_x_end =\n              std::min(params.filter_width, input_width - in_x_origin);\n          const int filter_y_start = std::max(0, -in_y_origin);\n          const int filter_y_end =\n              std::min(params.filter_height, input_height - in_y_origin);\n          int32_t acc = 0;\n          int filter_count = 0;\n          for (int filter_y = filter_y_start; filter_y < filter_y_end;\n               ++filter_y) {\n            for (int filter_x = filter_x_start; filter_x < filter_x_end;\n                 ++filter_x) {\n              const int in_x = in_x_origin + filter_x;\n              const int in_y = in_y_origin + filter_y;\n              acc +=\n                  input_data[Offset(input_shape, batch, in_y, in_x, channel)];\n              filter_count++;\n            }\n          }\n          // Round to the closest integer value.\n          acc = acc > 0 ? (acc + filter_count / 2) / filter_count\n                        : (acc - filter_count / 2) / filter_count;\n          acc = std::max(acc, params.quantized_activation_min);\n          acc = std::min(acc, params.quantized_activation_max);\n          output_data[Offset(output_shape, batch, out_y, out_x, channel)] =\n              static_cast<int8_t>(acc);\n        }\n      }\n    }\n  }\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "inline bool AveragePool(const PoolParams& params,\n                        const RuntimeShape& input_shape,\n                        const int8_t* input_data,\n                        const RuntimeShape& output_shape, int8_t* output_data) {\n  TFLITE_DCHECK_LE(params.quantized_activation_min,\n                   params.quantized_activation_max);\n  TFLITE_DCHECK_EQ(input_shape.DimensionsCount(), 4);\n  TFLITE_DCHECK_EQ(output_shape.DimensionsCount(), 4);\n  const int batches = MatchingDim(input_shape, 0, output_shape, 0);\n  const int depth = MatchingDim(input_shape, 3, output_shape, 3);\n  const int input_height = input_shape.Dims(1);\n  const int input_width = input_shape.Dims(2);\n  const int output_height = output_shape.Dims(1);\n  const int output_width = output_shape.Dims(2);\n  const int stride_height = params.stride_height;\n  const int stride_width = params.stride_width;\n  for (int batch = 0; batch < batches; ++batch) {\n    for (int out_y = 0; out_y < output_height; ++out_y) {\n      for (int out_x = 0; out_x < output_width; ++out_x) {\n        for (int channel = 0; channel < depth; ++channel) {\n          const int in_x_origin =\n              (out_x * stride_width) - params.padding_values.width;\n          const int in_y_origin =\n              (out_y * stride_height) - params.padding_values.height;\n          // Compute the boundaries of the filter region clamped so as to\n          // ensure that the filter window fits in the input array.\n          const int filter_x_start = std::max(0, -in_x_origin);\n          const int filter_x_end =\n              std::min(params.filter_width, input_width - in_x_origin);\n          const int filter_y_start = std::max(0, -in_y_origin);\n          const int filter_y_end =\n              std::min(params.filter_height, input_height - in_y_origin);\n          int32_t acc = 0;\n          int filter_count = 0;\n          for (int filter_y = filter_y_start; filter_y < filter_y_end;\n               ++filter_y) {\n            for (int filter_x = filter_x_start; filter_x < filter_x_end;\n                 ++filter_x) {\n              const int in_x = in_x_origin + filter_x;\n              const int in_y = in_y_origin + filter_y;\n              acc +=\n                  input_data[Offset(input_shape, batch, in_y, in_x, channel)];\n              filter_count++;\n            }\n          }\n          if (filter_count == 0) return false;\n          // Round to the closest integer value.\n          acc = acc > 0 ? (acc + filter_count / 2) / filter_count\n                        : (acc - filter_count / 2) / filter_count;\n          acc = std::max(acc, params.quantized_activation_min);\n          acc = std::min(acc, params.quantized_activation_max);\n          output_data[Offset(output_shape, batch, out_y, out_x, channel)] =\n              static_cast<int8_t>(acc);\n        }\n      }\n    }\n  }\n  return true;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n  const json &indices_obj = GetValue(indices_iterator);\n  const json &values_obj = GetValue(values_iterator);\n\n  int indices_buffer_view = 0, indices_byte_offset = 0, component_type = 0;\n  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj, \"bufferView\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&indices_byte_offset, err, indices_obj, \"byteOffset\",\n                       false);\n  if (!ParseIntegerProperty(&component_type, err, indices_obj, \"componentType\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n\n  int values_buffer_view = 0, values_byte_offset = 0;\n  if (!ParseIntegerProperty(&values_buffer_view, err, values_obj, \"bufferView\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&values_byte_offset, err, values_obj, \"byteOffset\",\n                       false);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n  const json &indices_obj = GetValue(indices_iterator);\n  const json &values_obj = GetValue(values_iterator);\n\n  int indices_buffer_view = 0, indices_byte_offset = 0, component_type = 0;\n  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj,\n                            \"bufferView\", true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&indices_byte_offset, err, indices_obj, \"byteOffset\",\n                       false);\n  if (!ParseIntegerProperty(&component_type, err, indices_obj, \"componentType\",\n                            true, \"SparseAccessor\")) {\n    return false;\n  }\n\n  int values_buffer_view = 0, values_byte_offset = 0;\n  if (!ParseIntegerProperty(&values_buffer_view, err, values_obj, \"bufferView\",\n                            true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&values_byte_offset, err, values_obj, \"byteOffset\",\n                       false);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "{\n\tFILE *dest = (status == 0) ? stdout : stderr;\n\n\tif(status == 0){\n\t\tfprintf(dest,\n\t\t\t\"%s(1)\\t\\t\\tcopyright <Pierre-Fran\u00e7ois Monville>\\t\\t\\t%s(1)\\n\\nNAME\\n\\t%s -- crypt or decrypt any data\\n\\nSYNOPSIS\\n\\t%s [-h | --help] FILE [-s | --standard | KEYFILE]\\n\\nDESCRIPTION\\n\\t(FR) permet de chiffrer et de d\u00e9chiffrer toutes les donn\u00e9es entr\u00e9es en param\u00e8tre le mot de passe demand\u00e9 au d\u00e9but est hash\u00e9 puis sert de graine pour le PRNG le PRNG permet de fournir une cl\u00e9 unique \u00e9gale \u00e0 la longueur du fichier \u00e0 coder. La cl\u00e9 unique subit un xor avec le mot de passe (le mot de passe est r\u00e9p\u00e9t\u00e9 autant de fois que n\u00e9c\u00e9ssaire). Le fichier subit un xor avec cette cl\u00e9 Puis un brouilleur est utilis\u00e9, il m\u00e9lange la table des caract\u00e8res (ascii) en utilisant le PRNG ou en utilisant le keyFile fourni.\\n\\t(EN) Can crypt and decrypt any data given in argument. The password asked is hashed to be used as a seed for the PRNG. The PRNG gives a unique key which has the same length as the source file. The key is xored with the password (the password is repeated as long as necessary). The file is then xored with this new key, then a scrambler is used. It scrambles the ascii table using the PRNG or the keyFile given\\n\\nOPTIONS\\n\\tthe options are as follows:\\n\\n\\t-h | --help\\tfurther help.\\n\\n\\t-s | --standard\\tput the scrambler on off.\\n\\n\\t-i | --inverted\\tinverts the coding/decoding process, first it xors then it scrambles.\\n\\nEXIT STATUS\\n\\tthe %s program exits 0 on success, and anything else if an error occurs.\\n\\nEXAMPLES\\n\\tthe command:\\t%s file1\\n\\n\\tlets you choose between crypting or decrypting then it will prompt for a password that crypt/decrypt file1 as xfile1 in the same folder, file1 is not modified.\\n\\n\\tthe command:\\t%s file2 keyfile1\\n\\n\\tlets you choose between crypting or decrypting, will prompt for the password that crypt/decrypt file2, uses keyfile1 to generate the scrambler then crypt/decrypt file2 as file2x in the same folder, file2 is not modified.\\n\\n\\tthe command:\\t%s file3 -s\\n\\n\\tlets you choose between crypting or decrypting, will prompt for a password that crypt/decrypt the file without using the scrambler, resulting in using the unique key only.\\n\", progName, progName, progName, progName, progName, progName, progName, progName);\n\t} else{\n\t\tfprintf(dest,\n\t\t\t\"Usage : %s [-h | --help] FILE [-s | --standard | -i | --inverted] [KEYFILE]\\nOptions :\\n  -h --help :\\t\\tfurther help\\n  -s --standard :\\tput the scrambler off\\n  -i --inverted :\\tinverts the coding/decoding process\\n  KEYFILE :\\t\\tpath to a keyfile that generates the scrambler instead of the password\\n\", progName);\n\t}\n\texit(status);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n\tFILE *dest = (status == 0) ? stdout : stderr;\n\n\tif(status == 0){\n\t\tfprintf(dest,\n\t\t\t\"%s(1)\\t\\t\\tcopyright <Pierre-Fran\u00e7ois Monville>\\t\\t\\t%s(1)\\n\\nNAME\\n\\t%s -- crypt or decrypt any data\\n\\nSYNOPSIS\\n\\t%s [-h | --help] FILE [-s | --standard | KEYFILE]\\n\\nDESCRIPTION\\n\\t(FR) permet de chiffrer et de d\u00e9chiffrer toutes les donn\u00e9es entr\u00e9es en param\u00e8tre le mot de passe demand\u00e9 au d\u00e9but est hash\u00e9 puis sert de graine pour le PRNG le PRNG permet de fournir une cl\u00e9 unique \u00e9gale \u00e0 la longueur du fichier \u00e0 coder. La cl\u00e9 unique subit un xor avec le mot de passe (le mot de passe est r\u00e9p\u00e9t\u00e9 autant de fois que n\u00e9c\u00e9ssaire). Le fichier subit un xor avec cette cl\u00e9 Puis un brouilleur est utilis\u00e9, il m\u00e9lange la table des caract\u00e8res (ascii) en utilisant le PRNG ou en utilisant le keyFile fourni.\\n\\t(EN) Can crypt and decrypt any data given in argument. The password asked is hashed to be used as a seed for the PRNG. The PRNG gives a unique key which has the same length as the source file. The key is xored with the password (the password is repeated as long as necessary). The file is then xored with this new key, then a scrambler is used. It scrambles the ascii table using the PRNG or the keyFile given\\n\\nOPTIONS\\n\\tthe options are as follows:\\n\\n\\t-h | --help\\tfurther help.\\n\\n\\t-s | --standard\\tput the scrambler on off.\\n\\n\\t-i | --inverted\\tinverts the coding/decoding process, first it xors then it scrambles.\\n\\n\\tKEYFILE    \\tthe path to a file which will be used to scramble the substitution's tables and choose in which order they will be used instead of the PRNG only (starting at 2.5 ko for the keyfile is great, however not interesting to be too heavy) \\n\\nEXIT STATUS\\n\\tthe %s program exits 0 on success, and anything else if an error occurs.\\n\\nEXAMPLES\\n\\tthe command:\\t%s file1\\n\\n\\tlets you choose between crypting or decrypting then it will prompt for a password that crypt/decrypt file1 as xfile1 in the same folder, file1 is not modified.\\n\\n\\tthe command:\\t%s file2 keyfile1\\n\\n\\tlets you choose between crypting or decrypting, will prompt for the password that crypt/decrypt file2, uses keyfile1 to generate the scrambler then crypt/decrypt file2 as file2x in the same folder, file2 is not modified.\\n\\n\\tthe command:\\t%s file3 -s\\n\\n\\tlets you choose between crypting or decrypting, will prompt for a password that crypt/decrypt the file without using the scrambler, resulting in using the unique key only.\\n\", progName, progName, progName, progName, progName, progName, progName, progName);\n\t} else{\n\t\tfprintf(dest,\n\t\t\t\"Version : 2.3\\nUsage : %s [-h | --help] FILE [-s | --standard | -i | --inverted] [KEYFILE]\\nOptions :\\n  -h --help :\\t\\tfurther help\\n  -s --standard :\\tput the scrambler off\\n  -i --inverted :\\tinverts the coding/decoding process\\n  KEYFILE :\\t\\tpath to a keyfile that scrambles the substitution's tables and choose they order instead of the PRNG only\\n\", progName);\n\t}\n\texit(status);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "         hashTable[k / 8] |= (1 << (k % 8));\n      }\n   }\n\n   //Write the hash table to the ENC28J60 controller\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT0, hashTable[0]);\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT1, hashTable[1]);\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT2, hashTable[2]);\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT3, hashTable[3]);\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT4, hashTable[4]);\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT5, hashTable[5]);\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT6, hashTable[6]);\n   enc28j60WriteReg(interface, ENC28J60_REG_EHT7, hashTable[7]);\n\n   //Debug message\n   TRACE_DEBUG(\"  EHT0 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT0));\n   TRACE_DEBUG(\"  EHT1 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT1));\n   TRACE_DEBUG(\"  EHT2 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT2));\n   TRACE_DEBUG(\"  EHT3 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT3));\n   TRACE_DEBUG(\"  EHT0 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT4));\n   TRACE_DEBUG(\"  EHT1 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT5));\n   TRACE_DEBUG(\"  EHT2 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT6));\n   TRACE_DEBUG(\"  EHT3 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_REG_EHT7));\n\n   //Successful processing\n   return NO_ERROR;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "         hashTable[k / 8] |= (1 << (k % 8));\n      }\n   }\n\n   //Write the hash table to the ENC28J60 controller\n   enc28j60WriteReg(interface, ENC28J60_EHT0, hashTable[0]);\n   enc28j60WriteReg(interface, ENC28J60_EHT1, hashTable[1]);\n   enc28j60WriteReg(interface, ENC28J60_EHT2, hashTable[2]);\n   enc28j60WriteReg(interface, ENC28J60_EHT3, hashTable[3]);\n   enc28j60WriteReg(interface, ENC28J60_EHT4, hashTable[4]);\n   enc28j60WriteReg(interface, ENC28J60_EHT5, hashTable[5]);\n   enc28j60WriteReg(interface, ENC28J60_EHT6, hashTable[6]);\n   enc28j60WriteReg(interface, ENC28J60_EHT7, hashTable[7]);\n\n   //Debug message\n   TRACE_DEBUG(\"  EHT0 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT0));\n   TRACE_DEBUG(\"  EHT1 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT1));\n   TRACE_DEBUG(\"  EHT2 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT2));\n   TRACE_DEBUG(\"  EHT3 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT3));\n   TRACE_DEBUG(\"  EHT0 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT4));\n   TRACE_DEBUG(\"  EHT1 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT5));\n   TRACE_DEBUG(\"  EHT2 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT6));\n   TRACE_DEBUG(\"  EHT3 = %02\" PRIX8 \"\\r\\n\", enc28j60ReadReg(interface, ENC28J60_EHT7));\n\n   //Successful processing\n   return NO_ERROR;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "#define LOG0(t) log2fh(fh, t)\n#define LOG1(t,d) log2fh(fh, t,d)\n#define LOG2(t,d1,d2) log2fh(fh, t,d1,d2)\n#define LOG3(t,d1,d2,d3) log2fh(fh, t,d1,d2,d3)\n#define LOG4(t,d1,d2,d3,d4) log2fh(fh, t,d1,d2,d3,d4)\n\n  const pic_parameter_set* pps = ctx->get_pps(slice_pic_parameter_set_id);\n  assert(pps->pps_read); // TODO: error handling\n\n  const seq_parameter_set* sps = ctx->get_sps((int)pps->seq_parameter_set_id);\n  assert(sps->sps_read); // TODO: error handling\n\n\n  LOG0(\"----------------- SLICE -----------------\\n\");\n  LOG1(\"first_slice_segment_in_pic_flag      : %d\\n\", first_slice_segment_in_pic_flag);\n  if (ctx->get_nal_unit_type() >= NAL_UNIT_BLA_W_LP &&\n      ctx->get_nal_unit_type() <= NAL_UNIT_RESERVED_IRAP_VCL23) {\n    LOG1(\"no_output_of_prior_pics_flag         : %d\\n\", no_output_of_prior_pics_flag);\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "#define LOG1(t,d) log2fh(fh, t,d)\n#define LOG2(t,d1,d2) log2fh(fh, t,d1,d2)\n#define LOG3(t,d1,d2,d3) log2fh(fh, t,d1,d2,d3)\n#define LOG4(t,d1,d2,d3,d4) log2fh(fh, t,d1,d2,d3,d4)\n\n  LOG0(\"----------------- SLICE -----------------\\n\");\n\n  const pic_parameter_set* pps = ctx->get_pps(slice_pic_parameter_set_id);\n  if (!pps) {\n    LOG0(\"invalid PPS referenced\\n\");\n    return;\n  }\n  assert(pps->pps_read); // TODO: error handling\n\n  const seq_parameter_set* sps = ctx->get_sps((int)pps->seq_parameter_set_id);\n  if (!sps) {\n    LOG0(\"invalid SPS referenced\\n\");\n    return;\n  }\n  assert(sps->sps_read); // TODO: error handling\n\n\n  LOG1(\"first_slice_segment_in_pic_flag      : %d\\n\", first_slice_segment_in_pic_flag);\n  if (ctx->get_nal_unit_type() >= NAL_UNIT_BLA_W_LP &&\n      ctx->get_nal_unit_type() <= NAL_UNIT_RESERVED_IRAP_VCL23) {\n    LOG1(\"no_output_of_prior_pics_flag         : %d\\n\", no_output_of_prior_pics_flag);\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int rds_loop_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\t\t unsigned int hdr_off, unsigned int sg,\n\t\t\t unsigned int off)\n{\n\t/* Do not send cong updates to loopback */\n\tif (rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\treturn sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;\n\t}\n\n\tBUG_ON(hdr_off || sg || off);\n\n\trds_inc_init(&rm->m_inc, conn, conn->c_laddr);\n\n\trds_send_drop_acked(conn, be64_to_cpu(rm->m_inc.i_hdr.h_sequence),\n\t\t\t    NULL);\n\n\trds_inc_put(&rm->m_inc);\n\n\treturn sizeof(struct rds_header) + be32_to_cpu(rm->m_inc.i_hdr.h_len);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int rds_loop_xmit(struct rds_connection *conn, struct rds_message *rm,\n\t\t\t unsigned int hdr_off, unsigned int sg,\n\t\t\t unsigned int off)\n{\n\tstruct scatterlist *sgp = &rm->data.op_sg[sg];\n\tint ret = sizeof(struct rds_header) +\n\t\t\tbe32_to_cpu(rm->m_inc.i_hdr.h_len);\n\n\t/* Do not send cong updates to loopback */\n\tif (rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\tret = min_t(int, ret, sgp->length - conn->c_xmit_data_off);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(hdr_off || sg || off);\n\n\trds_inc_init(&rm->m_inc, conn, conn->c_laddr);\n\n\trds_send_drop_acked(conn, be64_to_cpu(rm->m_inc.i_hdr.h_sequence),\n\t\t\t    NULL);\n\n\trds_inc_put(&rm->m_inc);\nout:\n\treturn ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    for (int row = 0; row < nrows; ++row) {\n      T start = broadcast_starts ? starts(0) : starts(row);\n      T limit = broadcast_limits ? limits(0) : limits(row);\n      T delta = broadcast_deltas ? deltas(0) : deltas(row);\n      OP_REQUIRES(context, delta != 0, InvalidArgument(\"Requires delta != 0\"));\n      rt_nested_splits(row + 1) =\n          rt_nested_splits(row) + RangeSize(start, limit, delta);\n    }\n    SPLITS_TYPE nvals = rt_nested_splits(nrows);\n\n    // Construct the rt_dense_values tensor.\n    Tensor* rt_dense_values_out = nullptr;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    for (int row = 0; row < nrows; ++row) {\n      T start = broadcast_starts ? starts(0) : starts(row);\n      T limit = broadcast_limits ? limits(0) : limits(row);\n      T delta = broadcast_deltas ? deltas(0) : deltas(row);\n      OP_REQUIRES(context, delta != 0, InvalidArgument(\"Requires delta != 0\"));\n      int64_t size;  // The number of elements in the specified range.\n      if (((delta > 0) && (limit < start)) ||\n          ((delta < 0) && (limit > start))) {\n        size = 0;\n      } else if (std::is_integral<T>::value) {\n        // The following is copied from tensorflow::RangeOp::Compute().\n        size = Eigen::divup(Eigen::numext::abs(limit - start),\n                            Eigen::numext::abs(delta));\n      } else {\n        // The following is copied from tensorflow::RangeOp::Compute().\n        auto size_auto =\n            Eigen::numext::ceil(Eigen::numext::abs((limit - start) / delta));\n        OP_REQUIRES(\n            context, size_auto <= std::numeric_limits<int64_t>::max(),\n            errors::InvalidArgument(\"Requires ((limit - start) / delta) <= \",\n                                    std::numeric_limits<int64_t>::max()));\n        size = static_cast<int64_t>(size_auto);\n      }\n      rt_nested_splits(row + 1) = rt_nested_splits(row) + size;\n    }\n    SPLITS_TYPE nvals = rt_nested_splits(nrows);\n\n    // Construct the rt_dense_values tensor.\n    Tensor* rt_dense_values_out = nullptr;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, iconInfo->cbBitsMask);  /* cbBitsMask (2 bytes) */\n\tStream_Read_UINT16(s, iconInfo->cbBitsColor); /* cbBitsColor (2 bytes) */\n\n\tif (Stream_GetRemainingLength(s) < iconInfo->cbBitsMask + iconInfo->cbBitsColor)\n\t\treturn FALSE;\n\n\t/* bitsMask */\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\tif (!newBitMask)\n\t{\n\t\tfree(iconInfo->bitsMask);\n\t\ticonInfo->bitsMask = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsMask = newBitMask;\n\tStream_Read(s, iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\t/* colorTable */\n\tif (iconInfo->colorTable == NULL)\n\t{\n\t{\n\t\tfree(iconInfo->colorTable);\n\t\ticonInfo->colorTable = NULL;\n\t}\n\n\tif (iconInfo->colorTable)\n\t\tStream_Read(s, iconInfo->colorTable, iconInfo->cbColorTable);\n\n\t/* bitsColor */\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsColor, iconInfo->cbBitsColor);\n\n\tif (!newBitMask)\n\t\tfree(iconInfo->bitsColor);\n\t\ticonInfo->bitsColor = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsColor = newBitMask;\n\tStream_Read(s, iconInfo->bitsColor, iconInfo->cbBitsColor);\n\treturn TRUE;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (Stream_GetRemainingLength(s) < 4)\n\t\treturn FALSE;\n\n\tStream_Read_UINT16(s, iconInfo->cbBitsMask);  /* cbBitsMask (2 bytes) */\n\tStream_Read_UINT16(s, iconInfo->cbBitsColor); /* cbBitsColor (2 bytes) */\n\n\t/* bitsMask */\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\tif (!newBitMask)\n\t{\n\t\ticonInfo->bitsMask = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsMask = newBitMask;\n\tif (Stream_GetRemainingLength(s) < iconInfo->cbBitsMask)\n\t\treturn FALSE;\n\tStream_Read(s, iconInfo->bitsMask, iconInfo->cbBitsMask);\n\n\t/* colorTable */\n\tif (iconInfo->colorTable == NULL)\n\t{\n\t\tfree(iconInfo->colorTable);\n\t\ticonInfo->colorTable = NULL;\n\t}\n\n\tif (iconInfo->colorTable)\n\t{\n\t\tif (Stream_GetRemainingLength(s) < iconInfo->cbColorTable)\n\t\t\treturn FALSE;\n\t\tStream_Read(s, iconInfo->colorTable, iconInfo->cbColorTable);\n\t}\n\n\t/* bitsColor */\n\tnewBitMask = (BYTE*)realloc(iconInfo->bitsColor, iconInfo->cbBitsColor);\n\n\tif (!newBitMask)\n\t\ticonInfo->bitsColor = NULL;\n\t\treturn FALSE;\n\t}\n\n\ticonInfo->bitsColor = newBitMask;\n\tif (Stream_GetRemainingLength(s) < iconInfo->cbBitsColor)\n\t\treturn FALSE;\n\tStream_Read(s, iconInfo->bitsColor, iconInfo->cbBitsColor);\n\treturn TRUE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tint tileno;\n\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tdec->numtiles = dec->numhtiles * dec->numvtiles;\n\tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n\t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n\tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tjpc_dec_tile_t *tile;\n\tjpc_dec_tcomp_t *tcomp;\n\tint htileno;\n\tint vtileno;\n\tjpc_dec_cmpt_t *cmpt;\n\tsize_t size;\n\n\tdec->xstart = siz->xoff;\n\tdec->ystart = siz->yoff;\n\tdec->xend = siz->width;\n\tdec->yend = siz->height;\n\n\tdec->image = 0;\n\n\tdec->numhtiles = JPC_CEILDIV(dec->xend - dec->tilexoff, dec->tilewidth);\n\tdec->numvtiles = JPC_CEILDIV(dec->yend - dec->tileyoff, dec->tileheight);\n\tif (!jas_safe_size_mul(dec->numhtiles, dec->numvtiles, &size)) {\n\t\treturn -1;\n\t}\n\tdec->numtiles = size;\n\tJAS_DBGLOG(10, (\"numtiles = %d; numhtiles = %d; numvtiles = %d;\\n\",\n\t  dec->numtiles, dec->numhtiles, dec->numvtiles));\n\tif (!(dec->tiles = jas_alloc2(dec->numtiles, sizeof(jpc_dec_tile_t)))) {\n\t\treturn -1;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_8read_strings(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self, Py_ssize_t __pyx_v_n_items, PyObject *__pyx_v_encoding) {\n  PyObject *__pyx_v_items = NULL;\n  Py_ssize_t __pyx_v_i;\n  char *__pyx_v_buffer_ptr;\n  Py_ssize_t __pyx_v_right;\n  Py_ssize_t __pyx_v_size;\n  Py_ssize_t __pyx_v_shift;\n  Py_ssize_t __pyx_v_bytes_read;\n  unsigned char __pyx_v_b;\n  char *__pyx_v_c_string;\n  Py_ssize_t __pyx_v_c_string_size;\n  char *__pyx_v_c_encoding;\n  PyObject *__pyx_v_rv = 0;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  int __pyx_t_2;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  char *__pyx_t_5;\n  Py_ssize_t __pyx_t_6;\n  Py_ssize_t __pyx_t_7;\n  Py_ssize_t __pyx_t_8;\n  Py_ssize_t __pyx_t_9;\n  Py_ssize_t __pyx_t_10;\n  Py_ssize_t __pyx_t_11;\n  PyObject *__pyx_t_12 = NULL;\n  PyObject *__pyx_t_13 = NULL;\n  PyObject *__pyx_t_14 = NULL;\n  int __pyx_t_15;\n  PyObject *__pyx_t_16 = NULL;\n  __Pyx_RefNannySetupContext(\"read_strings\", 0);\n  __Pyx_INCREF(__pyx_v_encoding);\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":67\n *         We inline strings reading logic here to avoid this overhead.\n *         \"\"\"\n *         items = PyTuple_New(n_items)             # <<<<<<<<<<<<<<\n * \n *         cdef Py_ssize_t i\n */\n  __pyx_t_1 = PyTuple_New(__pyx_v_n_items); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 67, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_items = ((PyObject*)__pyx_t_1);\n  __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":71\n *         cdef Py_ssize_t i\n *         # Buffer vars\n *         cdef char* buffer_ptr = PyByteArray_AsString(self.buffer)             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t right\n *         # String length vars\n */\n  __pyx_t_1 = __pyx_v_self->buffer;\n  __Pyx_INCREF(__pyx_t_1);\n  __pyx_v_buffer_ptr = PyByteArray_AsString(__pyx_t_1);\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":78\n * \n *         # String for decode vars.\n *         cdef char *c_string = NULL             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t c_string_size = 1024\n *         cdef char *c_encoding = NULL\n */\n  __pyx_v_c_string = NULL;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":79\n *         # String for decode vars.\n *         cdef char *c_string = NULL\n *         cdef Py_ssize_t c_string_size = 1024             # <<<<<<<<<<<<<<\n *         cdef char *c_encoding = NULL\n *         if encoding:\n */\n  __pyx_v_c_string_size = 0x400;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":80\n *         cdef char *c_string = NULL\n *         cdef Py_ssize_t c_string_size = 1024\n *         cdef char *c_encoding = NULL             # <<<<<<<<<<<<<<\n *         if encoding:\n *             encoding = encoding.encode('utf-8')\n */\n  __pyx_v_c_encoding = NULL;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":81\n *         cdef Py_ssize_t c_string_size = 1024\n *         cdef char *c_encoding = NULL\n *         if encoding:             # <<<<<<<<<<<<<<\n *             encoding = encoding.encode('utf-8')\n *             c_encoding = encoding\n */\n        __Pyx_INCREF(__pyx_t_4);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_3, function);\n      }\n    }\n    __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_kp_u_utf_8) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_u_utf_8);\n    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 82, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __Pyx_DECREF_SET(__pyx_v_encoding, __pyx_t_1);\n */\n    __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_encoding); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 83, __pyx_L1_error)\n    __pyx_v_c_encoding = __pyx_t_5;\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":81\n *         cdef Py_ssize_t c_string_size = 1024\n *         cdef char *c_encoding = NULL\n *         if encoding:             # <<<<<<<<<<<<<<\n *             encoding = encoding.encode('utf-8')\n *             c_encoding = encoding\n */\n  goto __pyx_L0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":62\n *         return rv\n * \n *     def read_strings(self, Py_ssize_t n_items, encoding=None):             # <<<<<<<<<<<<<<\n *         \"\"\"\n *         Python has great overhead between function calls.\n */\n\n  /* function exit code */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static PyObject *__pyx_pf_17clickhouse_driver_14bufferedreader_14BufferedReader_8read_strings(struct __pyx_obj_17clickhouse_driver_14bufferedreader_BufferedReader *__pyx_v_self, unsigned PY_LONG_LONG __pyx_v_n_items, PyObject *__pyx_v_encoding) {\n  PyObject *__pyx_v_items = NULL;\n  unsigned PY_LONG_LONG __pyx_v_i;\n  char *__pyx_v_buffer_ptr;\n  unsigned PY_LONG_LONG __pyx_v_right;\n  unsigned PY_LONG_LONG __pyx_v_size;\n  unsigned PY_LONG_LONG __pyx_v_shift;\n  unsigned PY_LONG_LONG __pyx_v_bytes_read;\n  unsigned PY_LONG_LONG __pyx_v_b;\n  char *__pyx_v_c_string;\n  unsigned PY_LONG_LONG __pyx_v_c_string_size;\n  char *__pyx_v_c_encoding;\n  PyObject *__pyx_v_rv = 0;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  int __pyx_t_2;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  char *__pyx_t_5;\n  unsigned PY_LONG_LONG __pyx_t_6;\n  unsigned PY_LONG_LONG __pyx_t_7;\n  unsigned PY_LONG_LONG __pyx_t_8;\n  unsigned PY_LONG_LONG __pyx_t_9;\n  unsigned PY_LONG_LONG __pyx_t_10;\n  unsigned PY_LONG_LONG __pyx_t_11;\n  PyObject *__pyx_t_12 = NULL;\n  PyObject *__pyx_t_13 = NULL;\n  PyObject *__pyx_t_14 = NULL;\n  int __pyx_t_15;\n  PyObject *__pyx_t_16 = NULL;\n  int __pyx_lineno = 0;\n  const char *__pyx_filename = NULL;\n  int __pyx_clineno = 0;\n  __Pyx_RefNannySetupContext(\"read_strings\", 0);\n  __Pyx_INCREF(__pyx_v_encoding);\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":67\n *         We inline strings reading logic here to avoid this overhead.\n *         \"\"\"\n *         items = PyTuple_New(n_items)             # <<<<<<<<<<<<<<\n * \n *         cdef unsigned long long i\n */\n  __pyx_t_1 = PyTuple_New(__pyx_v_n_items); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 67, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_items = ((PyObject*)__pyx_t_1);\n  __pyx_t_1 = 0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":71\n *         cdef unsigned long long i\n *         # Buffer vars\n *         cdef char* buffer_ptr = PyByteArray_AsString(self.buffer)             # <<<<<<<<<<<<<<\n *         cdef unsigned long long right\n *         # String length vars\n */\n  __pyx_t_1 = __pyx_v_self->buffer;\n  __Pyx_INCREF(__pyx_t_1);\n  __pyx_v_buffer_ptr = PyByteArray_AsString(__pyx_t_1);\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":78\n * \n *         # String for decode vars.\n *         cdef char *c_string = NULL             # <<<<<<<<<<<<<<\n *         cdef unsigned long long c_string_size = 1024\n *         cdef char *c_encoding = NULL\n */\n  __pyx_v_c_string = NULL;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":79\n *         # String for decode vars.\n *         cdef char *c_string = NULL\n *         cdef unsigned long long c_string_size = 1024             # <<<<<<<<<<<<<<\n *         cdef char *c_encoding = NULL\n *         if encoding:\n */\n  __pyx_v_c_string_size = 0x400;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":80\n *         cdef char *c_string = NULL\n *         cdef unsigned long long c_string_size = 1024\n *         cdef char *c_encoding = NULL             # <<<<<<<<<<<<<<\n *         if encoding:\n *             encoding = encoding.encode('utf-8')\n */\n  __pyx_v_c_encoding = NULL;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":81\n *         cdef unsigned long long c_string_size = 1024\n *         cdef char *c_encoding = NULL\n *         if encoding:             # <<<<<<<<<<<<<<\n *             encoding = encoding.encode('utf-8')\n *             c_encoding = encoding\n */\n        __Pyx_INCREF(__pyx_t_4);\n        __Pyx_INCREF(function);\n        __Pyx_DECREF_SET(__pyx_t_3, function);\n      }\n    }\n    __pyx_t_1 = (__pyx_t_4) ? __Pyx_PyObject_Call2Args(__pyx_t_3, __pyx_t_4, __pyx_kp_s_utf_8) : __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_kp_s_utf_8);\n    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;\n    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 82, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;\n    __Pyx_DECREF_SET(__pyx_v_encoding, __pyx_t_1);\n */\n    __pyx_t_5 = __Pyx_PyObject_AsWritableString(__pyx_v_encoding); if (unlikely((!__pyx_t_5) && PyErr_Occurred())) __PYX_ERR(0, 83, __pyx_L1_error)\n    __pyx_v_c_encoding = __pyx_t_5;\n\n    /* \"clickhouse_driver/bufferedreader.pyx\":81\n *         cdef unsigned long long c_string_size = 1024\n *         cdef char *c_encoding = NULL\n *         if encoding:             # <<<<<<<<<<<<<<\n *             encoding = encoding.encode('utf-8')\n *             c_encoding = encoding\n */\n  goto __pyx_L0;\n\n  /* \"clickhouse_driver/bufferedreader.pyx\":62\n *         return rv\n * \n *     def read_strings(self, unsigned long long n_items, encoding=None):             # <<<<<<<<<<<<<<\n *         \"\"\"\n *         Python has great overhead between function calls.\n */\n\n  /* function exit code */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "l2tp_accm_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tuint16_t val_h, val_l;\n\n\tptr++;\t\t/* skip \"Reserved\" */\n\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"send=%08x \", (val_h<<16) + val_l));\n\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"recv=%08x \", (val_h<<16) + val_l));\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "l2tp_accm_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tuint16_t val_h, val_l;\n\n\tif (length < 2) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tptr++;\t\t/* skip \"Reserved\" */\n\tlength -= 2;\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tND_PRINT((ndo, \"send=%08x \", (val_h<<16) + val_l));\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"recv=%08x \", (val_h<<16) + val_l));\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "show_tree(tree_t *t,                    /* I - Parent node */\n          int    indent)                /* I - Indentation */\n{\n  while (t)\n  {\n    if (t->markup == MARKUP_NONE)\n      printf(\"%*s\\\"%s\\\"\\n\", indent, \"\", t->data);\n    else\n      printf(\"%*s%s\\n\", indent, \"\", _htmlMarkups[t->markup]);\n\n    if (t->child)\n      show_tree(t->child, indent + 2);\n\n    t = t->next;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "show_tree(tree_t *t,                    /* I - Parent node */\n          int    indent)                /* I - Indentation */\n{\n  static const char * const markups[] =\n  {\n    \"FILE\",\n    \"UNKNOWN\",\n    \"ERROR\"\n  };\n\n  while (t)\n  {\n    if (t->markup == MARKUP_NONE)\n      printf(\"%*s\\\"%s\\\"\\n\", indent, \"\", t->data);\n    else if (t->markup > MARKUP_NONE)\n      printf(\"%*s%s\\n\", indent, \"\", _htmlMarkups[t->markup]);\n    else\n      printf(\"%*s%s\\n\", indent, \"\", markups[t->markup - MARKUP_FILE]);\n\n    if (t->child)\n      show_tree(t->child, indent + 2);\n\n    t = t->next;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      const char *commit;\n      g_autoptr(GVariant) commit_data = NULL;\n      g_autoptr(GVariant) commit_metadata = NULL;\n      g_autoptr(GKeyFile) keyfile = NULL;\n      g_autoptr(GFile) metadata_file = NULL;\n      g_autofree char *metadata_contents = NULL;\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n\n      /* Add fields from commit metadata to deploy */\n      commit = flatpak_deploy_data_get_commit (deploy_data);\n      if (!ostree_repo_load_commit (repo, commit, &commit_data, NULL, error))\n\n      /* Add fields from metadata file to deploy */\n      keyfile = g_key_file_new ();\n      metadata_file = g_file_resolve_relative_path (deploy_dir, \"metadata\");\n      if (!g_file_load_contents (metadata_file, cancellable,\n                                 &metadata_contents, NULL, NULL, error))\n        return NULL;\n      if (!g_key_file_load_from_data (keyfile, metadata_contents, -1, 0, error))\n        return NULL;\n      add_metadata_to_deploy_data (&metadata_dict, keyfile);\n\n      /* Add fields from appdata to deploy, since appdata-content-rating wasn't\n       * added when upgrading from version 2 as it should have been",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      g_autoptr(GVariant) commit_data = NULL;\n      g_autoptr(GVariant) commit_metadata = NULL;\n      g_autoptr(GKeyFile) keyfile = NULL;\n      g_autoptr(GFile) metadata_file = NULL;\n      g_autofree char *metadata_contents = NULL;\n      gsize metadata_size = 0;\n      g_autofree char *id = flatpak_decomposed_dup_id (ref);\n\n      /* Add fields from commit metadata to deploy */\n      commit = flatpak_deploy_data_get_commit (deploy_data);\n      if (!ostree_repo_load_commit (repo, commit, &commit_data, NULL, error))\n\n      /* Add fields from metadata file to deploy */\n      keyfile = g_key_file_new ();\n      metadata_file = g_file_resolve_relative_path (deploy_dir, \"metadata\");\n      if (!g_file_load_contents (metadata_file, cancellable,\n                                 &metadata_contents, &metadata_size, NULL, error))\n        return NULL;\n      if (!g_key_file_load_from_data (keyfile, metadata_contents, metadata_size, 0, error))\n        return NULL;\n      add_metadata_to_deploy_data (&metadata_dict, keyfile);\n\n      /* Add fields from appdata to deploy, since appdata-content-rating wasn't\n       * added when upgrading from version 2 as it should have been",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "snmp_ber_encode_integer(unsigned char *out, uint32_t *out_len, uint32_t number)\n{\n  uint32_t original_out_len;\n\n  original_out_len = *out_len;\n  do {\n    (*out_len)++;\n    *out-- = (uint8_t)(number & 0xFF);\n    number >>= 8;\n  } while(number);\n\n  out = snmp_ber_encode_length(out, out_len, ((*out_len - original_out_len) & 0xFF));\n  out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_INTEGER);\n\n  return out;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "snmp_ber_encode_integer(snmp_packet_t *snmp_packet, uint32_t number)\n{\n  return snmp_ber_encode_unsigned_integer(snmp_packet, BER_DATA_TYPE_INTEGER, number);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    int\t\topt_flags)\t// OPT_LOCAL or 0 (both)\n{\n    int\t\topt_idx;\n    char_u\t*varp;\n    long_u\tflags;\n    static char\terrbuf[80];\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\n    {\n\tint key;\n\t    emsg(_(e_not_allowed_in_sandbox));\n\t    return NULL;\n\t}\n#endif\n\tif (flags & P_STRING)\n\t    return set_string_option(opt_idx, string, opt_flags, errbuf);\n\n\tvarp = get_varp_scope(&(options[opt_idx]), opt_flags);\n\tif (varp != NULL)\t// hidden option is not changed\n\t{\n\t    if (number == 0 && string != NULL)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    int\t\topt_flags)\t// OPT_LOCAL or 0 (both)\n{\n    int\t\topt_idx;\n    char_u\t*varp;\n    long_u\tflags;\n    static char\terrbuf[ERR_BUFLEN];\n    int\t\terrbuflen = ERR_BUFLEN;\n\n    opt_idx = findoption(name);\n    if (opt_idx < 0)\n    {\n\tint key;\n\t    emsg(_(e_not_allowed_in_sandbox));\n\t    return NULL;\n\t}\n#endif\n\tif (flags & P_STRING)\n\t    return set_string_option(opt_idx, string, opt_flags, errbuf, errbuflen);\n\n\tvarp = get_varp_scope(&(options[opt_idx]), opt_flags);\n\tif (varp != NULL)\t// hidden option is not changed\n\t{\n\t    if (number == 0 && string != NULL)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static inline Quantum GetPixelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[image->channel_map[channel].offset].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[channel].offset]);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static inline Quantum GetPixelChannel(const Image *magick_restrict image,\n  const PixelChannel channel,const Quantum *magick_restrict pixel)\n{\n  if (image->channel_map[channel].traits == UndefinedPixelTrait)\n    return((Quantum) 0);\n  return(pixel[image->channel_map[channel].offset]);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int utf8s_to_utf16s(const u8 *s, int len, wchar_t *pwcs)\n{\n\tu16 *op;\n\tint size;\n\tunicode_t u;\n\n\top = pwcs;\n\twhile (*s && len > 0) {\n\t\tif (*s & 0x80) {\n\t\t\tsize = utf8_to_utf32(s, len, &u);\n\t\t\tif (size < 0)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (u >= PLANE_SIZE) {\n\t\t\t\tu -= PLANE_SIZE;\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n\t\t\t\t\t\t((u >> 10) & SURROGATE_BITS));\n\t\t\t\t*op++ = (wchar_t) (SURROGATE_PAIR |\n\t\t\t\t\t\tSURROGATE_LOW |\n\t\t\t\t\t\t(u & SURROGATE_BITS));\n\t\t\t} else {\n\t\t\t\t*op++ = (wchar_t) u;\n\t\t\t}\n\t\t\ts += size;\n\t\t\tlen -= size;\n\t\t} else {\n\t\t\t*op++ = *s++;\n\t\t\tlen--;\n\t\t}\n\t}\n\treturn op - pwcs;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int utf8s_to_utf16s(const u8 *s, int len, enum utf16_endian endian,\n\t\twchar_t *pwcs, int maxlen)\n{\n\tu16 *op;\n\tint size;\n\tunicode_t u;\n\n\top = pwcs;\n\twhile (len > 0 && maxlen > 0 && *s) {\n\t\tif (*s & 0x80) {\n\t\t\tsize = utf8_to_utf32(s, len, &u);\n\t\t\tif (size < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\ts += size;\n\t\t\tlen -= size;\n\n\t\t\tif (u >= PLANE_SIZE) {\n\t\t\t\tif (maxlen < 2)\n\t\t\t\t\tbreak;\n\t\t\t\tu -= PLANE_SIZE;\n\t\t\t\tput_utf16(op++, SURROGATE_PAIR |\n\t\t\t\t\t\t((u >> 10) & SURROGATE_BITS),\n\t\t\t\t\t\tendian);\n\t\t\t\tput_utf16(op++, SURROGATE_PAIR |\n\t\t\t\t\t\tSURROGATE_LOW |\n\t\t\t\t\t\t(u & SURROGATE_BITS),\n\t\t\t\t\t\tendian);\n\t\t\t\tmaxlen -= 2;\n\t\t\t} else {\n\t\t\t\tput_utf16(op++, u, endian);\n\t\t\t\tmaxlen--;\n\t\t\t}\n\t\t} else {\n\t\t\tput_utf16(op++, *s++, endian);\n\t\t\tlen--;\n\t\t\tmaxlen--;\n\t\t}\n\t}\n\treturn op - pwcs;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t/*this is to cope with single MFString which shall appear as SF in XMT*/\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t} else if (sf_type==GF_SG_VRML_SFSTRING) {\n\t\t\tgf_fprintf(sdump->trace, \" value=\\'\");\n\t\t} else {\n\t\t\tStartAttribute(sdump, \"value\");\n\t\t}\n\t\tfor (i=0; mffield && (i<mffield->count); i++) {\n\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t/*this is to cope with single MFString which shall appear as SF in XMT*/\n\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, 1, parent);\n\t\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t/* position in x and y of tile*/\n\tp = tileno % p_cp->tw;\n\tq = tileno / p_cp->tw;\n\n\t/* here calculation of tx0, tx1, ty0, ty1, maxprec, l_dx and l_dy */\n\t*p_tx0 = opj_int_max((OPJ_INT32)(p_cp->tx0 + p * p_cp->tdx), (OPJ_INT32)p_image->x0);\n\t*p_tx1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + (p + 1) * p_cp->tdx), (OPJ_INT32)p_image->x1);\n\t*p_ty0 = opj_int_max((OPJ_INT32)(p_cp->ty0 + q * p_cp->tdy), (OPJ_INT32)p_image->y0);\n\t*p_ty1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + (q + 1) * p_cp->tdy), (OPJ_INT32)p_image->y1);\n\n\t/* max precision and resolution is 0 (can only grow)*/\n\t*p_max_prec = 0;\n\t*p_max_res = 0;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t/* position in x and y of tile*/\n\tp = tileno % p_cp->tw;\n\tq = tileno / p_cp->tw;\n\n\t/* here calculation of tx0, tx1, ty0, ty1, maxprec, l_dx and l_dy */\n\t*p_tx0 = (OPJ_INT32)opj_uint_max(p_cp->tx0 + p * p_cp->tdx, p_image->x0);\n\t*p_tx1 = (OPJ_INT32)opj_uint_min(p_cp->tx0 + (p + 1) * p_cp->tdx, p_image->x1);\n\t*p_ty0 = (OPJ_INT32)opj_uint_max(p_cp->ty0 + q * p_cp->tdy, p_image->y0);\n\t*p_ty1 = (OPJ_INT32)opj_uint_min(p_cp->ty0 + (q + 1) * p_cp->tdy, p_image->y1);\n\n\t/* max precision and resolution is 0 (can only grow)*/\n\t*p_max_prec = 0;\n\t*p_max_res = 0;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  uint32_t codec_limit_kb = 64;\n  max_request_headers_kb_ = codec_limit_kb;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  std::string key = \"big\";\n  uint32_t head_room = 77;\n  uint32_t long_string_length =\n      codec_limit_kb * 1024 - request_headers.byteSize() - key.length() - head_room;\n  std::string long_string = std::string(long_string_length, 'q');\n  request_headers.addCopy(key, long_string);\n\n  // The amount of data sent to the codec is not equivalent to the size of the\n  // request headers that Envoy computes, as the codec limits based on the\n  // entire http2 frame. The exact head room needed (76) was found through iteration.\n  ASSERT_EQ(request_headers.byteSize() + head_room, codec_limit_kb * 1024);\n\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _));\n  request_encoder_->encodeHeaders(request_headers, true);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  max_request_headers_kb_ = codec_limit_kb;\n  initialize();\n\n  TestHeaderMapImpl request_headers;\n  HttpTestUtility::addDefaultHeaders(request_headers);\n  // Refresh byte size after adding default inline headers by reference.\n  request_headers.refreshByteSize();\n  std::string key = \"big\";\n  uint32_t head_room = 77;\n  uint32_t long_string_length =\n      codec_limit_kb * 1024 - request_headers.byteSize().value() - key.length() - head_room;\n  std::string long_string = std::string(long_string_length, 'q');\n  request_headers.addCopy(key, long_string);\n\n  // The amount of data sent to the codec is not equivalent to the size of the\n  // request headers that Envoy computes, as the codec limits based on the\n  // entire http2 frame. The exact head room needed (76) was found through iteration.\n  ASSERT_EQ(request_headers.byteSize().value() + head_room, codec_limit_kb * 1024);\n\n  EXPECT_CALL(request_decoder_, decodeHeaders_(_, _));\n  request_encoder_->encodeHeaders(request_headers, true);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1 << i;\n\t\tdelta -= incr;\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1LL << i;\n\t\tdelta -= incr;\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tprintk(\"User FPU load/store unaligned unsupported.\\n\");\n\t\t\tgoto kill_user;\n\t\t}\n\n\t\taddr = compute_effective_address(regs, insn);\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, addr);\n\t\tswitch(dir) {\n\t\tcase load:\n\t\t\terr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),\n\t\t\t\t\t\t\t regs),\n\t\t\t\t\t  size, (unsigned long *) addr,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tprintk(\"User FPU load/store unaligned unsupported.\\n\");\n\t\t\tgoto kill_user;\n\t\t}\n\n\t\taddr = compute_effective_address(regs, insn);\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, addr);\n\t\tswitch(dir) {\n\t\tcase load:\n\t\t\terr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),\n\t\t\t\t\t\t\t regs),\n\t\t\t\t\t  size, (unsigned long *) addr,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->64 */\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t\tcoerce_reg_to_size(&src_reg, 4);\n\t}\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t\tdst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val > 63) {\n\t\t\t/* Shifts greater than 63 are undefined.  This includes\n\t\t\t * shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\t\tbreak;\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tstruct bpf_reg_state *regs = cur_regs(env);\n\tu8 opcode = BPF_OP(insn->code);\n\tbool src_known, dst_known;\n\ts64 smin_val, smax_val;\n\tu64 umin_val, umax_val;\n\tu64 insn_bitness = (BPF_CLASS(insn->code) == BPF_ALU64) ? 64 : 32;\n\n\tsmin_val = src_reg.smin_value;\n\tsmax_val = src_reg.smax_value;\n\tumin_val = src_reg.umin_value;\n\tumax_val = src_reg.umax_value;\n\tsrc_known = tnum_is_const(src_reg.var_off);\n\t\t}\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_LSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* We lose all sign bit information (except what we can pick\n\t\t\tdst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);\n\t\t/* We may learn something more from the var_off */\n\t\t__update_reg_bounds(dst_reg);\n\t\tbreak;\n\tcase BPF_RSH:\n\t\tif (umax_val >= insn_bitness) {\n\t\t\t/* Shifts greater than 31 or 63 are undefined.\n\t\t\t * This includes shifts by a negative number.\n\t\t\t */\n\t\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\t\tbreak;\n\t\t}\n\t\t/* BPF_RSH is an unsigned shift.  If the value in dst_reg might\n\tdefault:\n\t\tmark_reg_unknown(env, regs, insn->dst_reg);\n\t\tbreak;\n\t}\n\n\tif (BPF_CLASS(insn->code) != BPF_ALU64) {\n\t\t/* 32-bit ALU ops are (32,32)->32 */\n\t\tcoerce_reg_to_size(dst_reg, 4);\n\t\tcoerce_reg_to_size(&src_reg, 4);\n\t}\n\n\t__reg_deduce_bounds(dst_reg);\n\t__reg_bound_offset(dst_reg);\n\treturn 0;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tSET_NETDEV_DEV(dev, &vdev->dev);\n\n\t/* Do we support \"hardware\" checksums? */\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CSUM)) {\n\t\t/* This opens up the world of extra features. */\n\t\tdev->hw_features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;\n\t\tif (csum)\n\t\t\tdev->features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;\n\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_GSO)) {\n\t\t\tdev->hw_features |= NETIF_F_TSO | NETIF_F_UFO\n\t\t\t\t| NETIF_F_TSO_ECN | NETIF_F_TSO6;\n\t\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tSET_NETDEV_DEV(dev, &vdev->dev);\n\n\t/* Do we support \"hardware\" checksums? */\n\tif (virtio_has_feature(vdev, VIRTIO_NET_F_CSUM)) {\n\t\t/* This opens up the world of extra features. */\n\t\tdev->hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG;\n\t\tif (csum)\n\t\t\tdev->features |= NETIF_F_HW_CSUM | NETIF_F_SG;\n\n\t\tif (virtio_has_feature(vdev, VIRTIO_NET_F_GSO)) {\n\t\t\tdev->hw_features |= NETIF_F_TSO | NETIF_F_UFO\n\t\t\t\t| NETIF_F_TSO_ECN | NETIF_F_TSO6;\n\t\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n    avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);\n\n    ymax = FFMAX(0, s->ymax + 1);\n    // Zero out the end if ymax+1 is not h\n    for (i = 0; i < planes; i++) {\n        ptr = picture->data[i] + (ymax * picture->linesize[i]);\n        for (y = ymax; y < avctx->height; y++) {\n            memset(ptr, 0, out_line_size);\n            ptr += picture->linesize[i];\n        }\n    }\n\n    picture->pict_type = AV_PICTURE_TYPE_I;\n    *got_frame = 1;\n\n    return avpkt->size;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n    avctx->execute2(avctx, decode_block, s->thread_data, NULL, nb_blocks);\n\n    ymax = FFMAX(0, s->ymax + 1);\n    // Zero out the end if ymax+1 is not h\n    if (ymax < avctx->height)\n        for (i = 0; i < planes; i++) {\n            ptr = picture->data[i] + (ymax * picture->linesize[i]);\n            for (y = ymax; y < avctx->height; y++) {\n                memset(ptr, 0, out_line_size);\n                ptr += picture->linesize[i];\n            }\n        }\n\n    picture->pict_type = AV_PICTURE_TYPE_I;\n    *got_frame = 1;\n\n    return avpkt->size;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void lo_release(struct gendisk *disk, fmode_t mode)\n{\n\tstruct loop_device *lo = disk->private_data;\n\tint err;\n\n\tif (atomic_dec_return(&lo->lo_refcnt))\n\t\treturn;\n\n\tmutex_lock(&lo->lo_ctl_mutex);\n\tif (lo->lo_flags & LO_FLAGS_AUTOCLEAR) {\n\t\t/*\n\t\t * In autoclear mode, stop the loop thread\n\t\t * and remove configuration after last close.\n\t\t */\n\t\terr = loop_clr_fd(lo);\n\t\tif (!err)\n\t\t\treturn;\n\t} else if (lo->lo_state == Lo_bound) {\n\t\t/*\n\t\t * Otherwise keep thread (if running) and config,\n\t\t * but flush possible ongoing bios in thread.\n\t\t */\n\t\tblk_mq_freeze_queue(lo->lo_queue);\n\t\tblk_mq_unfreeze_queue(lo->lo_queue);\n\t}\n\n\tmutex_unlock(&lo->lo_ctl_mutex);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void lo_release(struct gendisk *disk, fmode_t mode)\n{\n\tmutex_lock(&loop_index_mutex);\n\t__lo_release(disk->private_data);\n\tmutex_unlock(&loop_index_mutex);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        // info is valid regardless status.\n        context->set_check_response_info(info);\n\n        // update consumer_project_id to service context\n        if (!info.consumer_project_id.empty()) {\n          context->request()->AddHeaderToBackend(kConsumerProjecId,\n                                                 info.consumer_project_id);\n        }\n\n        continuation(status);\n      });\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        // info is valid regardless status.\n        context->set_check_response_info(info);\n\n        // update consumer_project_id to service context\n        if (!info.consumer_project_id.empty()) {\n          context->request()->AddHeaderToBackend(\n              kConsumerProjecId, info.consumer_project_id, false);\n        }\n\n        continuation(status);\n      });\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tif (UEV_TIMER_TYPE == w->type)\n\t\t\tuev_timer_set(w, w->u.t.timeout, w->u.t.period);\n\t}\n\n\twhile (ctx->running && ctx->watchers) {\n\t\tstruct epoll_event ee[UEV_MAX_EVENTS];\n\t\tint i, nfds, rerun = 0;\n\n\t\t/* Handle special case: `application < file.txt` */\n\t\tif (ctx->workaround) {\n\t\t\t_UEV_FOREACH(w, ctx->watchers) {\n\t\t\t\tif (w->active != -1 || !w->cb)\n\n\t\tif (rerun)\n\t\t\tcontinue;\n\t\tctx->workaround = 0;\n\n\t\twhile ((nfds = epoll_wait(ctx->fd, ee, ctx->maxevents, timeout)) < 0) {\n\t\t\tif (!ctx->running)\n\t\t\t\tbreak;\n\n\t\t\tif (EINTR == errno)\n\t\t\t\tcontinue; /* Signalled, try again */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tuev_timer_set(w, w->u.t.timeout, w->u.t.period);\n\t}\n\n\twhile (ctx->running && ctx->watchers) {\n\t\tstruct epoll_event ee[UEV_MAX_EVENTS];\n\t\tint maxevents = ctx->maxevents;\n\t\tint i, nfds, rerun = 0;\n\n\t\tif (maxevents > UEV_MAX_EVENTS)\n\t\t\tmaxevents = UEV_MAX_EVENTS;\n\n\t\t/* Handle special case: `application < file.txt` */\n\t\tif (ctx->workaround) {\n\t\t\t_UEV_FOREACH(w, ctx->watchers) {\n\t\t\t\tif (w->active != -1 || !w->cb)\n\n\t\tif (rerun)\n\t\t\tcontinue;\n\t\tctx->workaround = 0;\n\n\t\twhile ((nfds = epoll_wait(ctx->fd, ee, maxevents, timeout)) < 0) {\n\t\t\tif (!ctx->running)\n\t\t\t\tbreak;\n\n\t\t\tif (EINTR == errno)\n\t\t\t\tcontinue; /* Signalled, try again */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t value;\n    int position, zeroes, i, j;\n    char bits[65];\n\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    zeroes = i = 0;\n    while (1) {\n        if (get_bits_left(gbc) < zeroes + 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (get_bits1(gbc)) {\n            bits[i++] = '1';\n            break;\n        } else {\n            bits[i++] = '0';\n            ++zeroes;\n        }\n    }\n\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        value = get_bits_long(gbc, zeroes);\n\n        for (j = 0; j < zeroes; j++)\n            bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';\n\n        value += (1 << zeroes) - 1;\n    }\n\n    if (ctx->trace_enable) {\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL,\n                                    bits, value);\n    }\n\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t zeroes, bits_value, value;\n    int position;\n\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    zeroes = 0;\n    while (1) {\n        if (get_bits_left(gbc) < 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (get_bits1(gbc))\n            break;\n        ++zeroes;\n    }\n\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        if (get_bits_left(gbc) < zeroes) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n\n        bits_value = get_bits_long(gbc, zeroes);\n        value = bits_value + (UINT32_C(1) << zeroes) - 1;\n    }\n\n    if (ctx->trace_enable) {\n        char bits[65];\n        int i, j, k;\n\n        if (zeroes >= 32) {\n            while (zeroes > 32) {\n                k = FFMIN(zeroes - 32, 32);\n                for (i = 0; i < k; i++)\n                    bits[i] = '0';\n                bits[i] = 0;\n                ff_cbs_trace_syntax_element(ctx, position, name,\n                                            NULL, bits, 0);\n                zeroes -= k;\n                position += k;\n            }\n        }\n\n        for (i = 0; i < zeroes; i++)\n            bits[i] = '0';\n        bits[i++] = '1';\n\n        if (zeroes < 32) {\n            for (j = 0; j < zeroes; j++)\n                bits[i++] = (bits_value >> (zeroes - j - 1) & 1) ? '1' : '0';\n        }\n\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name,\n                                    NULL, bits, value);\n    }\n\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  int error=1;\n  DBUG_ENTER(\"my_redel\");\n  DBUG_PRINT(\"my\",(\"org_name: '%s' tmp_name: '%s'  MyFlags: %d\",\n\t\t   org_name,tmp_name,MyFlags));\n\n  if (my_copystat(org_name,tmp_name,MyFlags) < 0)\n    goto end;\n  if (MyFlags & MY_REDEL_MAKE_BACKUP)\n  {\n    char name_buff[FN_REFLEN+20];    \n    char ext[20];\n    ext[0]='-';",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  int error=1;\n  DBUG_ENTER(\"my_redel\");\n  DBUG_PRINT(\"my\",(\"org_name: '%s' tmp_name: '%s'  MyFlags: %d\",\n\t\t   org_name,tmp_name,MyFlags));\n\n  if (!(MyFlags & MY_REDEL_NO_COPY_STAT))\n  {\n    if (my_copystat(org_name,tmp_name,MyFlags) < 0)\n      goto end;\n  }\n  if (MyFlags & MY_REDEL_MAKE_BACKUP)\n  {\n    char name_buff[FN_REFLEN+20];    \n    char ext[20];\n    ext[0]='-';",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tint i;\n\tchar **strs;\n\n\tnptrs = backtrace(buffer, 100);\n\tif (file_name) {\n\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n\t\tif (str)\n\t\t\tdprintf(fd, \"%s\\n\", str);\n\t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n\t\tif (write(fd, \"\\n\", 1) != 1) {\n\t\t\t/* We don't care, but this stops a warning on Ubuntu */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tint i;\n\tchar **strs;\n\n\tnptrs = backtrace(buffer, 100);\n\tif (file_name) {\n\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n\t\tif (str)\n\t\t\tdprintf(fd, \"%s\\n\", str);\n\t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n\t\tif (write(fd, \"\\n\", 1) != 1) {\n\t\t\t/* We don't care, but this stops a warning on Ubuntu */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  if (op->getType().isBigIntType()) {\n    UOI->setType(Type::createBigInt());\n    return true;\n  }\n\n  Type mayBeBigInt =\n      op->getType().canBeBigInt() ? Type::createBigInt() : Type::createNoType();\n\n  // - ?? => Number|?BigInt. BigInt is only possible if op.Type canBeBigInt.\n  UOI->setType(Type::unionTy(numberResultType, mayBeBigInt));\n  return true;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  if (op->getType().isBigIntType()) {\n    UOI->setType(Type::createBigInt());\n    return true;\n  }\n\n  Type mayBeBigInt = isBigIntOrObject(op->getType()) ? Type::createBigInt()\n                                                     : Type::createNoType();\n\n  // - ?? => Number|?BigInt. BigInt is only possible if op.Type is\n  // BigInt|Object.\n  UOI->setType(Type::unionTy(numberResultType, mayBeBigInt));\n  return true;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tdata.period\t= event->hw.last_period;\n\n\t\tif (!x86_perf_event_set_period(event))\n\t\t\tcontinue;\n\n\t\tif (perf_event_overflow(event, 1, &data, regs))\n\t\t\tx86_pmu_stop(event, 0);\n\t}\n\n\tif (handled)\n\t\tinc_irq_stat(apic_perf_irqs);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tdata.period\t= event->hw.last_period;\n\n\t\tif (!x86_perf_event_set_period(event))\n\t\t\tcontinue;\n\n\t\tif (perf_event_overflow(event, &data, regs))\n\t\t\tx86_pmu_stop(event, 0);\n\t}\n\n\tif (handled)\n\t\tinc_irq_stat(apic_perf_irqs);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (unlikely(!access_ok(VERIFY_WRITE, kiocb->ki_buf,\n\t\t\tkiocb->ki_left)))\n\t\t\tbreak;\n\t\tret = security_file_permission(file, MAY_READ);\n\t\tif (unlikely(ret))\n\t\t\tbreak;\n\t\tret = aio_setup_single_vector(kiocb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_read)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (unlikely(!access_ok(VERIFY_READ, kiocb->ki_buf,\n\t\t\tkiocb->ki_left)))\n\t\t\tbreak;\n\t\tret = security_file_permission(file, MAY_WRITE);\n\t\tif (unlikely(ret))\n\t\t\tbreak;\n\t\tret = aio_setup_single_vector(kiocb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_write)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PREADV:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_READ)))\n\t\t\tbreak;\n\t\tret = security_file_permission(file, MAY_READ);\n\t\tif (unlikely(ret))\n\t\t\tbreak;\n\t\tret = aio_setup_vectored_rw(READ, kiocb, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PWRITEV:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_WRITE)))\n\t\t\tbreak;\n\t\tret = security_file_permission(file, MAY_WRITE);\n\t\tif (unlikely(ret))\n\t\t\tbreak;\n\t\tret = aio_setup_vectored_rw(WRITE, kiocb, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (unlikely(!access_ok(VERIFY_WRITE, kiocb->ki_buf,\n\t\t\tkiocb->ki_left)))\n\t\t\tbreak;\n\t\tret = aio_setup_single_vector(READ, file, kiocb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_read)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (unlikely(!access_ok(VERIFY_READ, kiocb->ki_buf,\n\t\t\tkiocb->ki_left)))\n\t\t\tbreak;\n\t\tret = aio_setup_single_vector(WRITE, file, kiocb);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_write)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PREADV:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_READ)))\n\t\t\tbreak;\n\t\tret = aio_setup_vectored_rw(READ, kiocb, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;\n\t\tif (file->f_op->aio_read)\n\t\t\tkiocb->ki_retry = aio_rw_vect_retry;\n\t\tbreak;\n\tcase IOCB_CMD_PWRITEV:\n\t\tret = -EBADF;\n\t\tif (unlikely(!(file->f_mode & FMODE_WRITE)))\n\t\t\tbreak;\n\t\tret = aio_setup_vectored_rw(WRITE, kiocb, compat);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = -EINVAL;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\t  !!vma->memory, vma->refd, vma->mapref,\n\t\t\t\t  addr, size, vma->addr, (u64)vma->size);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (vma->addr != addr) {\n\t\t\tconst u64 tail = vma->size + vma->addr - addr;\n\t\t\tif (ret = -ENOMEM, !(vma = nvkm_vma_tail(vma, tail)))\n\t\t\t\tgoto fail;\n\t\t\tvma->part = true;\n\t\t\tnvkm_vmm_node_insert(vmm, vma);\n\t\t}\n\n\t\tif (vma->size != size) {\n\t\t\tconst u64 tail = vma->size - size;\n\t\t\tstruct nvkm_vma *tmp;\n\t\t\tif (ret = -ENOMEM, !(tmp = nvkm_vma_tail(vma, tail))) {\n\t\t\t\tnvkm_vmm_unmap_region(vmm, vma);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\ttmp->part = true;\n\t\t\tnvkm_vmm_node_insert(vmm, tmp);\n\t\t}\n\t}\n\tvma->busy = true;\n\tmutex_unlock(&vmm->mutex);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\t  !!vma->memory, vma->refd, vma->mapref,\n\t\t\t\t  addr, size, vma->addr, (u64)vma->size);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tvma = nvkm_vmm_node_split(vmm, vma, addr, size);\n\t\tif (!vma) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tvma->busy = true;\n\tmutex_unlock(&vmm->mutex);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void _luac_build_info(LuaProto *proto, LuacBinInfo *info) {\n\t/* process proto header info */\n\tchar *section_name;\n\tchar *symbol_name;\n\tchar *proto_name;\n\tRzListIter *iter;\n\n\tut64 current_offset;\n\tut64 current_size;\n\n\tint i = 0; // iter\n\n\t// 0. check if stripped (proto name is lost)\n\tif (proto->name_size == 0 || proto->proto_name == NULL) {\n\t\t// replace name with current offset\n\t\tproto_name = rz_str_newf(\"fcn.%08llx\", proto->offset);\n\t\t\tlocal_var_entry->offset,\n\t\t\tlocal_var_entry->varname_len);\n\t}\n\n\t// 2.2 parse debug_upvalues\n\tchar **upvalue_names;\n\tint real_upvalue_cnt;\n\tLuaDbgUpvalueEntry *debug_upv_entry;\n\treal_upvalue_cnt = rz_list_length(proto->upvalue_entries);\n\tupvalue_names = RZ_NEWS0(char *, real_upvalue_cnt);\n\tif (!upvalue_names) {\n\t\treturn;\n\t}\n\trz_list_foreach (proto->dbg_upvalue_entries, iter, debug_upv_entry) {\n\t\tupvalue_names[i] = (char *)debug_upv_entry->upvalue_name;\n\t\tluac_add_string(\n\t\t\tinfo->string_list,\n\t\t\tupvalue_names[i],\n\t\t\tdebug_upv_entry->offset,\n\t\t\tdebug_upv_entry->name_len);\n\t}\n\n\t// 3.1 construct constant symbols\n\tLuaConstEntry *const_entry;\n\trz_list_foreach (proto->const_entries, iter, const_entry) {\n\tLuaProto *sub_proto;\n\trz_list_foreach (proto->proto_entries, iter, sub_proto) {\n\t\t_luac_build_info(sub_proto, info);\n\t}\n\n\tRZ_FREE(proto_name);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void _luac_build_info(LuaProto *proto, LuacBinInfo *info) {\n\t/* process proto header info */\n\tchar *section_name;\n\tchar *symbol_name;\n\tchar *proto_name;\n\tchar **upvalue_names = NULL;\n\tRzListIter *iter;\n\tint i = 0; // iter\n\n\tut64 current_offset;\n\tut64 current_size;\n\n\t// 0. check if stripped (proto name is lost)\n\tif (proto->name_size == 0 || proto->proto_name == NULL) {\n\t\t// replace name with current offset\n\t\tproto_name = rz_str_newf(\"fcn.%08llx\", proto->offset);\n\t\t\tlocal_var_entry->offset,\n\t\t\tlocal_var_entry->varname_len);\n\t}\n\n\t// 2.2 parse debug_upvalues\n\tsize_t real_upvalue_cnt = rz_list_length(proto->upvalue_entries);\n\tif (real_upvalue_cnt > 0) {\n\t\tLuaDbgUpvalueEntry *debug_upv_entry;\n\t\tupvalue_names = RZ_NEWS0(char *, real_upvalue_cnt);\n\t\tif (!upvalue_names) {\n\t\t\tfree(proto_name);\n\t\t\treturn;\n\t\t}\n\n\t\ti = 0;\n\t\trz_list_foreach (proto->dbg_upvalue_entries, iter, debug_upv_entry) {\n\t\t\tupvalue_names[i] = (char *)debug_upv_entry->upvalue_name;\n\t\t\tluac_add_string(\n\t\t\t\tinfo->string_list,\n\t\t\t\tupvalue_names[i],\n\t\t\t\tdebug_upv_entry->offset,\n\t\t\t\tdebug_upv_entry->name_len);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t// 3.1 construct constant symbols\n\tLuaConstEntry *const_entry;\n\trz_list_foreach (proto->const_entries, iter, const_entry) {\n\tLuaProto *sub_proto;\n\trz_list_foreach (proto->proto_entries, iter, sub_proto) {\n\t\t_luac_build_info(sub_proto, info);\n\t}\n\n\tfree(upvalue_names);\n\tfree(proto_name);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int verify_cb(int preverify_ok, X509_STORE_CTX *x509_ctx)\n{\n    pj_ssl_sock_t *ssock;\n    SSL *ossl_ssl;\n    int err;\n\n    /* Get SSL instance */\n    ossl_ssl = X509_STORE_CTX_get_ex_data(x509_ctx, \n\t\t\t\t    SSL_get_ex_data_X509_STORE_CTX_idx());\n    pj_assert(ossl_ssl);\n\n    /* Get SSL socket instance */\n    ssock = SSL_get_ex_data(ossl_ssl, sslsock_idx);\n    pj_assert(ssock);\n\n    /* Store verification status */\n    err = X509_STORE_CTX_get_error(x509_ctx);\n    switch (err) {\n    case X509_V_OK:\n    /* When verification is not requested just return ok here, however\n     * application can still get the verification status.\n     */\n    if (PJ_FALSE == ssock->param.verify_peer)\n\tpreverify_ok = 1;\n\n    return preverify_ok;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int verify_cb(int preverify_ok, X509_STORE_CTX *x509_ctx)\n{\n    pj_ssl_sock_t *ssock = NULL;\n    SSL *ossl_ssl = NULL;\n    int err;\n\n    /* Get SSL instance */\n    ossl_ssl = X509_STORE_CTX_get_ex_data(x509_ctx, \n\t\t\t\t    SSL_get_ex_data_X509_STORE_CTX_idx());\n    if (!ossl_ssl) {\n\tPJ_LOG(1,(THIS_FILE,\n\t\t  \"SSL verification callback failed to get SSL instance\"));\n\tgoto on_return;\n    }\n\n    /* Get SSL socket instance */\n    ssock = SSL_get_ex_data(ossl_ssl, sslsock_idx);\n    if (!ssock) {\n\t/* SSL socket may have been destroyed */\n\tPJ_LOG(1,(THIS_FILE,\n\t\t  \"SSL verification callback failed to get SSL socket \"\n\t\t  \"instance (sslsock_idx=%d).\", sslsock_idx));\n\tgoto on_return;\n    }\n\n    /* Store verification status */\n    err = X509_STORE_CTX_get_error(x509_ctx);\n    switch (err) {\n    case X509_V_OK:\n     * application can still get the verification status.\n     */\n    if (PJ_FALSE == ssock->param.verify_peer)\n\tpreverify_ok = 1;\n\non_return:\n    return preverify_ok;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  {\n    dprint (1, (debugfile, \"Invalid response from server: %s\\n\", ibuf));\n    goto bail;\n  }\n\n  if ((len = mutt_from_base64 (obuf, idata->buf + 2)) == -1)\n  {\n    dprint (1, (debugfile, \"Error decoding base64 response.\\n\"));\n    goto bail;\n  }\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  {\n    dprint (1, (debugfile, \"Invalid response from server: %s\\n\", ibuf));\n    goto bail;\n  }\n\n  if ((len = mutt_from_base64 (obuf, idata->buf + 2, sizeof(obuf) - 1)) == -1)\n  {\n    dprint (1, (debugfile, \"Error decoding base64 response.\\n\"));\n    goto bail;\n  }\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        GError** error)\n{\n    g_autoptr(GString) network = NULL;\n    g_autoptr(GString) link = NULL;\n    GString* s = NULL;\n    mode_t orig_umask;\n\n    SET_OPT_OUT_PTR(has_been_written, FALSE);\n\n    if (def->type == NETPLAN_DEF_TYPE_VLAN && def->sriov_vlan_filter) {\n        g_debug(\"%s is defined as a hardware SR-IOV filtered VLAN, postponing creation\", def->id);\n        if (link->len > 0)\n            g_string_append_printf(s, \"\\n[Link]\\n%s\", link->str);\n        if (network->len > 0)\n            g_string_append_printf(s, \"\\n[Network]\\n%s\", network->str);\n\n        /* these do not contain secrets and need to be readable by\n         * systemd-networkd - LP: #1736965 */\n        orig_umask = umask(022);\n        _netplan_g_string_free_to_file(s, rootdir, path, \".network\");\n        umask(orig_umask);\n    }\n\n    SET_OPT_OUT_PTR(has_been_written, TRUE);\n    return TRUE;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        gboolean* has_been_written,\n        GError** error)\n{\n    g_autoptr(GString) network = NULL;\n    g_autoptr(GString) link = NULL;\n    GString* s = NULL;\n\n    SET_OPT_OUT_PTR(has_been_written, FALSE);\n\n    if (def->type == NETPLAN_DEF_TYPE_VLAN && def->sriov_vlan_filter) {\n        g_debug(\"%s is defined as a hardware SR-IOV filtered VLAN, postponing creation\", def->id);\n        if (link->len > 0)\n            g_string_append_printf(s, \"\\n[Link]\\n%s\", link->str);\n        if (network->len > 0)\n            g_string_append_printf(s, \"\\n[Network]\\n%s\", network->str);\n\n        _netplan_g_string_free_to_file_with_permissions(s, rootdir, path, \".network\", \"root\", NETWORKD_GROUP, 0640);\n    }\n\n    SET_OPT_OUT_PTR(has_been_written, TRUE);\n    return TRUE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void ep2_mul_slide(ep2_t r, const ep2_t p, const bn_t k) {\n\tep2_t t[1 << (EP_WIDTH - 1)], q;\n\tint i, j, l;\n\tuint8_t win[RLC_FP_BITS + 1];\n\n\tep2_null(q);\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n\t\t\tep2_null(t[i]);\n\t\t\tep2_new(t[i]);\n\t\t}\n\n\t\tep2_new(q);\n#if defined(EP_MIXED)\n\t\tep2_norm(q, q);\n#endif\n\n\t\t/* Create table. */\n\t\tfor (i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep2_add(t[i], t[i - 1], q);\n\t\t}\n\n#if defined(EP_MIXED)\n\t\tep2_norm_sim(t + 1, t + 1, (1 << (EP_WIDTH - 1)) - 1);\n#endif\n\n\t\tep2_set_infty(q);\n\t\tl = RLC_FP_BITS + 1;\n\t\tbn_rec_slw(win, &l, k, EP_WIDTH);\n\t\tfor (i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\tep2_dbl(q, q);\n\t\t\t} else {\n\t\t\t\tfor (j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\tep2_dbl(q, q);\n\t\t\t\t}\n\t\t\t\tep2_add(q, q, t[win[i] >> 1]);\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep2_free(t[i]);\n\t\t}\n\t\tep2_free(q);\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void ep2_mul_slide(ep2_t r, const ep2_t p, const bn_t k) {\n\tep2_t t[1 << (EP_WIDTH - 1)], q;\n\tuint8_t win[RLC_FP_BITS + 1];\n\tsize_t l;\n\n\tep2_null(q);\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\tep2_set_infty(r);\n\t\treturn;\n\t}\n\n\tRLC_TRY {\n\t\tfor (int i = 0; i < (1 << (EP_WIDTH - 1)); i ++) {\n\t\t\tep2_null(t[i]);\n\t\t\tep2_new(t[i]);\n\t\t}\n\n\t\tep2_new(q);\n#if defined(EP_MIXED)\n\t\tep2_norm(q, q);\n#endif\n\n\t\t/* Create table. */\n\t\tfor (size_t i = 1; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep2_add(t[i], t[i - 1], q);\n\t\t}\n\n#if defined(EP_MIXED)\n\t\tep2_norm_sim(t + 1, t + 1, (1 << (EP_WIDTH - 1)) - 1);\n#endif\n\n\t\tep2_set_infty(q);\n\t\tl = RLC_FP_BITS + 1;\n\t\tbn_rec_slw(win, &l, k, EP_WIDTH);\n\t\tfor (size_t i = 0; i < l; i++) {\n\t\t\tif (win[i] == 0) {\n\t\t\t\tep2_dbl(q, q);\n\t\t\t} else {\n\t\t\t\tfor (size_t j = 0; j < util_bits_dig(win[i]); j++) {\n\t\t\t\t\tep2_dbl(q, q);\n\t\t\t\t}\n\t\t\t\tep2_add(q, q, t[win[i] >> 1]);\n\t\t\t}\n\t\t}\n\t}\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\tfor (size_t i = 0; i < (1 << (EP_WIDTH - 1)); i++) {\n\t\t\tep2_free(t[i]);\n\t\t}\n\t\tep2_free(q);\n\t}\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\tdiscovery_remove(client);\n\t\tupdate_discovery_filter(adapter);\n\t\treturn 0;\n\t}\n\n\tif (adapter->discovery_discoverable)\n\t\tset_discovery_discoverable(adapter, false);\n\n\t/*\n\t * In the idle phase of a discovery, there is no need to stop it\n\t * and so it is enough to send out the signal and just return.\n\t */",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\tdiscovery_remove(client);\n\t\tupdate_discovery_filter(adapter);\n\t\treturn 0;\n\t}\n\n\tset_discovery_discoverable(adapter, false);\n\n\t/*\n\t * In the idle phase of a discovery, there is no need to stop it\n\t * and so it is enough to send out the signal and just return.\n\t */",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  parser->m_processor = epilogProcessor;\n  parser->m_eventPtr = s;\n  for (;;) {\n    const char *next = NULL;\n    int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  parser->m_processor = epilogProcessor;\n  parser->m_eventPtr = s;\n  for (;;) {\n    const char *next = NULL;\n    int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n#if defined(XML_DTD) || XML_GE == 1\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void rose_start_heartbeat(struct sock *sk)\n{\n\tdel_timer(&sk->sk_timer);\n\n\tsk->sk_timer.function = rose_heartbeat_expiry;\n\tsk->sk_timer.expires  = jiffies + 5 * HZ;\n\n\tadd_timer(&sk->sk_timer);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void rose_start_heartbeat(struct sock *sk)\n{\n\tsk_stop_timer(sk, &sk->sk_timer);\n\n\tsk->sk_timer.function = rose_heartbeat_expiry;\n\tsk->sk_timer.expires  = jiffies + 5 * HZ;\n\n\tsk_reset_timer(sk, &sk->sk_timer, sk->sk_timer.expires);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "bool ExtractSymlink(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName)\n{\n#if defined(SAVE_LINKS) && defined(_UNIX)\n  // For RAR 3.x archives we process links even in test mode to skip link data.\n  if (Arc.Format==RARFMT15)\n    return ExtractUnixLink30(Cmd,DataIO,Arc,LinkName);\n  if (Arc.Format==RARFMT50)\n    return ExtractUnixLink50(Cmd,LinkName,&Arc.FileHead);\n#elif defined _WIN_ALL\n  // RAR 5.0 archives store link information in file header, so there is\n  // no need to additionally test it if we do not create a file.\n  if (Arc.Format==RARFMT50)\n    return CreateReparsePoint(Cmd,LinkName,&Arc.FileHead);\n#endif",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "bool ExtractSymlink(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName,bool &UpLink)\n{\n  // Returning true in Uplink indicates that link target might include \"..\"\n  // and enables additional checks. It is ok to falsely return true here,\n  // as it implies only the minor performance penalty. But we shall always\n  // return true for links with \"..\" in target for security reason.\n\n  UpLink=true; // Assume the target might include potentially unsafe \"..\".\n#if defined(SAVE_LINKS) && defined(_UNIX) || defined(_WIN_ALL)\n  if (Arc.Format==RARFMT50) // For RAR5 archives we can check RedirName for both Unix and Windows.\n    UpLink=wcsstr(Arc.FileHead.RedirName,L\"..\")!=NULL;\n#endif\n\n#if defined(SAVE_LINKS) && defined(_UNIX)\n  // For RAR 3.x archives we process links even in test mode to skip link data.\n  if (Arc.Format==RARFMT15)\n    return ExtractUnixLink30(Cmd,DataIO,Arc,LinkName,UpLink);\n  if (Arc.Format==RARFMT50)\n    return ExtractUnixLink50(Cmd,LinkName,&Arc.FileHead);\n#elif defined(_WIN_ALL)\n  // RAR 5.0 archives store link information in file header, so there is\n  // no need to additionally test it if we do not create a file.\n  if (Arc.Format==RARFMT50)\n    return CreateReparsePoint(Cmd,LinkName,&Arc.FileHead);\n#endif",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int bson_check_field_name( bson *b, const char *string,\n                           const int length ) {\n\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 1, 1 );\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int bson_check_field_name( bson *b, const char *string,\n                           const size_t length ) {\n\n    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 1, 1 );\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n\tnewinet->inet_daddr\t= ireq->rmt_addr;\n\tnewinet->inet_rcv_saddr = ireq->loc_addr;\n\tnewinet->inet_saddr\t= ireq->loc_addr;\n\tnewinet->opt\t   = ireq->opt;\n\tireq->opt\t   = NULL;\n\tnewinet->mc_index  = inet_iif(skb);\n\tnewinet->mc_ttl\t   = ip_hdr(skb)->ttl;\n\tnewinet->inet_id   = jiffies;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tnewinet\t\t   = inet_sk(newsk);\n\tireq\t\t   = inet_rsk(req);\n\tnewinet->inet_daddr\t= ireq->rmt_addr;\n\tnewinet->inet_rcv_saddr = ireq->loc_addr;\n\tnewinet->inet_saddr\t= ireq->loc_addr;\n\tnewinet->inet_opt\t= ireq->opt;\n\tireq->opt\t   = NULL;\n\tnewinet->mc_index  = inet_iif(skb);\n\tnewinet->mc_ttl\t   = ip_hdr(skb)->ttl;\n\tnewinet->inet_id   = jiffies;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tif (dump_udta_type) dump_isom_udta(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_udta_type, dump_udta_track);\n\n\tif (dump_iod) {\n\t\tGF_InitialObjectDescriptor *iod = (GF_InitialObjectDescriptor *)gf_isom_get_root_od(file);\n\t\tif (!iod) {\n\t\t\tfprintf(stderr, \"File %s has no IOD\", inName);\n\t\t} else {\n\t\t\tchar szName[GF_MAX_PATH+10];\n\t\t\tFILE *iodf;\n\t\t\tsprintf(szName, \"%s.iod\", outfile);\n\t\t\tiodf = gf_fopen(szName, \"wb\");",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tif (dump_udta_type) dump_isom_udta(file, dump_std ? NULL : (outName ? outName : outfile), outName ? GF_TRUE : GF_FALSE, dump_udta_type, dump_udta_track);\n\n\tif (dump_iod) {\n\t\tGF_InitialObjectDescriptor *iod = (GF_InitialObjectDescriptor *)gf_isom_get_root_od(file);\n\t\tif (!iod) {\n\t\t\tfprintf(stderr, \"File %s has no IOD\\n\", inName);\n\t\t} else {\n\t\t\tchar szName[GF_MAX_PATH+10];\n\t\t\tFILE *iodf;\n\t\t\tsprintf(szName, \"%s.iod\", outfile);\n\t\t\tiodf = gf_fopen(szName, \"wb\");",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void bn_srt(bn_t c, bn_t a) {\n\tbn_t h, l, m, t;\n\tint bits, cmp;\n\n\tif (bn_sign(a) == RLC_NEG) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t}\n\n\tRLC_TRY {\n\t\tbn_new(h);\n\t\tbn_new(l);\n\t\tbn_new(m);\n\t\tbn_new(t);\n\n\t\tbn_set_2b(h, bits >> 1);\n\t\tbn_set_2b(l, (bits >> 1) - 1);\n\n\t\t/* Trivial binary search approach. */\n\t\tdo {\n\t\t\tbn_add(m, h, l);\n\t\t\tbn_hlv(m, m);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void bn_srt(bn_t c, bn_t a) {\n\tbn_t h, l, m, t;\n\tsize_t bits;\n\tint cmp;\n\n\tif (bn_sign(a) == RLC_NEG) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t}\n\n\t\tbn_new(h);\n\t\tbn_new(l);\n\t\tbn_new(m);\n\t\tbn_new(t);\n\n\t\tbn_zero(l);\n\t\tbn_set_2b(h, bits >> 1);\n\t\tif (bits >= 2) {\n\t\t\tbn_set_2b(l, (bits >> 1) - 1);\n\t\t}\n\n\t\t/* Trivial binary search approach. */\n\t\tdo {\n\t\t\tbn_add(m, h, l);\n\t\t\tbn_hlv(m, m);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tset_intr_gate_ist(X86_TRAP_DF, &double_fault, DOUBLEFAULT_STACK);\n#endif\n\tset_intr_gate(X86_TRAP_OLD_MF, coprocessor_segment_overrun);\n\tset_intr_gate(X86_TRAP_TS, invalid_TSS);\n\tset_intr_gate(X86_TRAP_NP, segment_not_present);\n\tset_intr_gate_ist(X86_TRAP_SS, &stack_segment, STACKFAULT_STACK);\n\tset_intr_gate(X86_TRAP_GP, general_protection);\n\tset_intr_gate(X86_TRAP_SPURIOUS, spurious_interrupt_bug);\n\tset_intr_gate(X86_TRAP_MF, coprocessor_error);\n\tset_intr_gate(X86_TRAP_AC, alignment_check);\n#ifdef CONFIG_X86_MCE",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tset_intr_gate_ist(X86_TRAP_DF, &double_fault, DOUBLEFAULT_STACK);\n#endif\n\tset_intr_gate(X86_TRAP_OLD_MF, coprocessor_segment_overrun);\n\tset_intr_gate(X86_TRAP_TS, invalid_TSS);\n\tset_intr_gate(X86_TRAP_NP, segment_not_present);\n\tset_intr_gate(X86_TRAP_SS, stack_segment);\n\tset_intr_gate(X86_TRAP_GP, general_protection);\n\tset_intr_gate(X86_TRAP_SPURIOUS, spurious_interrupt_bug);\n\tset_intr_gate(X86_TRAP_MF, coprocessor_error);\n\tset_intr_gate(X86_TRAP_AC, alignment_check);\n#ifdef CONFIG_X86_MCE",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tStream_Read_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Read_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Read_UINT32(s, new_len);            /* length (4 bytes) */\n\n\tif (Stream_GetRemainingLength(s) < new_len)\n\t\tgoto fail;\n\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\n\tif (!new_data)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tStream_Read_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Read_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Read_UINT32(s, new_len);            /* length (4 bytes) */\n\n\tif ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len))\n\t\tgoto fail;\n\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\n\tif (!new_data)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  if (op_info.inputs_size() < 3) {\n    return errors::InvalidArgument(\"MaxPoolGrad op has invalid inputs: \",\n                                   op_info.ShortDebugString());\n  }\n\n  ConvolutionDimensions dims = OpDimensionsFromInputs(\n      op_info.inputs(0).shape(), op_info, &found_unknown_shapes);\n\n  int64_t ops = 0;\n  if (dims.kx == 1 && dims.ky == 1) {\n    // 1x1 window. No need to know which input was max.\n    ops = dims.batch * dims.ix * dims.iy * dims.iz;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  if (op_info.inputs_size() < 3) {\n    return errors::InvalidArgument(\"MaxPoolGrad op has invalid inputs: \",\n                                   op_info.ShortDebugString());\n  }\n\n  TF_ASSIGN_OR_RETURN(ConvolutionDimensions dims,\n                      OpDimensionsFromInputs(op_info.inputs(0).shape(), op_info,\n                                             &found_unknown_shapes));\n\n  int64_t ops = 0;\n  if (dims.kx == 1 && dims.ky == 1) {\n    // 1x1 window. No need to know which input was max.\n    ops = dims.batch * dims.ix * dims.iy * dims.iz;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tint i, j, offset;\n\tuint8_t type;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct genericPartitionMap *gpm;\n\tuint16_t ident;\n\tstruct buffer_head *bh;\n\tint ret = 0;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn 1;\n\tBUG_ON(ident != TAG_IDENT_LVD);\n\tlvd = (struct logicalVolDesc *)bh->b_data;\n\n\tret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));\n\tif (ret)\n\t\tgoto out_bh;\n\n\tfor (i = 0, offset = 0;\n\t     i < sbi->s_partitions && offset < le32_to_cpu(lvd->mapTableLength);\n\t     i++, offset += gpm->partitionMapLength) {\n\t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n\t\tgpm = (struct genericPartitionMap *)\n\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\ttype = gpm->partitionMapType;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tuint8_t type;\n\tstruct udf_sb_info *sbi = UDF_SB(sb);\n\tstruct genericPartitionMap *gpm;\n\tuint16_t ident;\n\tstruct buffer_head *bh;\n\tunsigned int table_len;\n\tint ret = 0;\n\n\tbh = udf_read_tagged(sb, block, block, &ident);\n\tif (!bh)\n\t\treturn 1;\n\tBUG_ON(ident != TAG_IDENT_LVD);\n\tlvd = (struct logicalVolDesc *)bh->b_data;\n\ttable_len = le32_to_cpu(lvd->mapTableLength);\n\tif (sizeof(*lvd) + table_len > sb->s_blocksize) {\n\t\tudf_err(sb, \"error loading logical volume descriptor: \"\n\t\t\t\"Partition table too long (%u > %lu)\\n\", table_len,\n\t\t\tsb->s_blocksize - sizeof(*lvd));\n\t\tgoto out_bh;\n\t}\n\n\tret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));\n\tif (ret)\n\t\tgoto out_bh;\n\n\tfor (i = 0, offset = 0;\n\t     i < sbi->s_partitions && offset < table_len;\n\t     i++, offset += gpm->partitionMapLength) {\n\t\tstruct udf_part_map *map = &sbi->s_partmaps[i];\n\t\tgpm = (struct genericPartitionMap *)\n\t\t\t\t&(lvd->partitionMaps[offset]);\n\t\ttype = gpm->partitionMapType;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tint n;\n\t/* Packet we should build:\nIEEE 802.3 Ethernet \n    Destination: Bay-Networks-(Synoptics)-autodiscovery (01:00:81:00:01:00)\n    Source: 5e:10:8e:e7:84:ad (5e:10:8e:e7:84:ad)\n    Length: 22\nLogical-Link Control\n    DSAP: SNAP (0xaa)\n    IG Bit: Individual\n    SSAP: SNAP (0xaa)\n    CR Bit: Command\n    Number of links: 1\n\nIEEE 802.3 Ethernet \n    Destination: Bay-Networks-(Synoptics)-autodiscovery (01:00:81:00:01:01)\n    Source: 5e:10:8e:e7:84:ad (5e:10:8e:e7:84:ad)\n    Length: 22\nLogical-Link Control\n    DSAP: SNAP (0xaa)\n    IG Bit: Individual\n    SSAP: SNAP (0xaa)\n    CR Bit: Command\n    NMM state: New (3)\n    Number of links: 1\n\t*/\n\tchar pkt1[] = {\n\t\t0x01, 0x00, 0x81, 0x00, 0x01, 0x00, 0x5e, 0x10,\n\t\t0x8e, 0xe7, 0x84, 0xad, 0x00, 0x16, 0xaa, 0xaa,\n\t\t0x03, 0x00, 0x00, 0x81, 0x01, 0xa2, 0xac, 0x11,\n\t\t0x8e, 0x25, 0x00, 0x00, 0x04, 0x01, 0x0c, 0x03,\n\t\t0x01 };\n\tchar pkt2[] = {\n\t\t0x01, 0x00, 0x81, 0x00, 0x01, 0x01, 0x5e, 0x10,\n\t\t0x8e, 0xe7, 0x84, 0xad, 0x00, 0x16, 0xaa, 0xaa,\n\t\t0x03, 0x00, 0x00, 0x81, 0x01, 0xa1, 0xac, 0x11,\n\t\t0x8e, 0x25, 0x00, 0x00, 0x04, 0x01, 0x0c, 0x03,\n\t\t0x01 };\n\tstruct packet *pkt;\n\tin_addr_t addr;\t\n\tchassis.c_id_subtype = LLDP_CHASSISID_SUBTYPE_LLADDR;\n\tchassis.c_id = macaddress;\n\tchassis.c_id_len = ETHER_ADDR_LEN;\n\tTAILQ_INIT(&chassis.c_mgmt);\n\taddr = inet_addr(\"172.17.142.37\");\n\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4, \n\t\t\t\t&addr, sizeof(in_addr_t), 0);\n\tif (mgmt == NULL)\n\t\tck_abort();\n\tTAILQ_INSERT_TAIL(&chassis.c_mgmt, mgmt, m_entries);\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tint n;\n\t/* Packet we should build:\nIEEE 802.3 Ethernet \n    Destination: Bay-Networks-(Synoptics)-autodiscovery (01:00:81:00:01:00)\n    Source: 5e:10:8e:e7:84:ad (5e:10:8e:e7:84:ad)\n    Length: 19\nLogical-Link Control\n    DSAP: SNAP (0xaa)\n    IG Bit: Individual\n    SSAP: SNAP (0xaa)\n    CR Bit: Command\n    Number of links: 1\n\nIEEE 802.3 Ethernet \n    Destination: Bay-Networks-(Synoptics)-autodiscovery (01:00:81:00:01:01)\n    Source: 5e:10:8e:e7:84:ad (5e:10:8e:e7:84:ad)\n    Length: 19\nLogical-Link Control\n    DSAP: SNAP (0xaa)\n    IG Bit: Individual\n    SSAP: SNAP (0xaa)\n    CR Bit: Command\n    NMM state: New (3)\n    Number of links: 1\n\t*/\n\tchar pkt1[] = {\n\t\t0x01, 0x00, 0x81, 0x00, 0x01, 0x00, 0x5e, 0x10,\n\t\t0x8e, 0xe7, 0x84, 0xad, 0x00, 0x13, 0xaa, 0xaa,\n\t\t0x03, 0x00, 0x00, 0x81, 0x01, 0xa2, 0xac, 0x11,\n\t\t0x8e, 0x25, 0x00, 0x00, 0x04, 0x01, 0x0c, 0x03,\n\t\t0x01 };\n\tchar pkt2[] = {\n\t\t0x01, 0x00, 0x81, 0x00, 0x01, 0x01, 0x5e, 0x10,\n\t\t0x8e, 0xe7, 0x84, 0xad, 0x00, 0x13, 0xaa, 0xaa,\n\t\t0x03, 0x00, 0x00, 0x81, 0x01, 0xa1, 0xac, 0x11,\n\t\t0x8e, 0x25, 0x00, 0x00, 0x04, 0x01, 0x0c, 0x03,\n\t\t0x01 };\n\tstruct packet *pkt;\n\tin_addr_t addr;\t\n\tchassis.c_id_subtype = LLDP_CHASSISID_SUBTYPE_LLADDR;\n\tchassis.c_id = macaddress;\n\tchassis.c_id_len = ETHER_ADDR_LEN;\n\tTAILQ_INIT(&chassis.c_mgmt);\n\taddr = inet_addr(\"172.17.142.37\");\n\tmgmt = lldpd_alloc_mgmt(LLDPD_AF_IPV4,\n\t\t\t\t&addr, sizeof(in_addr_t), 0);\n\tif (mgmt == NULL)\n\t\tck_abort();\n\tTAILQ_INSERT_TAIL(&chassis.c_mgmt, mgmt, m_entries);\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct skcipher_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(private));\n\n\tINIT_LIST_HEAD(&ctx->tsgl);\n\tctx->len = len;\n\tctx->used = 0;\n\tctx->more = 0;\n\tatomic_set(&ctx->inflight, 0);\n\taf_alg_init_completion(&ctx->completion);\n\n\task->private = ctx;\n\n\tskcipher_request_set_tfm(&ctx->req, private);\n\tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      af_alg_complete, &ctx->completion);\n\n\tsk->sk_destruct = skcipher_sock_destruct;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int skcipher_accept_parent(void *private, struct sock *sk)\n{\n\tstruct skcipher_ctx *ctx;\n\tstruct alg_sock *ask = alg_sk(sk);\n\tstruct skcipher_tfm *tfm = private;\n\tstruct crypto_skcipher *skcipher = tfm->skcipher;\n\tunsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);\n\n\tif (!tfm->has_key)\n\t\treturn -ENOKEY;\n\n\tctx = sock_kmalloc(sk, len, GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),\n\t\t\t       GFP_KERNEL);\n\tif (!ctx->iv) {\n\t\tsock_kfree_s(sk, ctx, len);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ctx->iv, 0, crypto_skcipher_ivsize(skcipher));\n\n\tINIT_LIST_HEAD(&ctx->tsgl);\n\tctx->len = len;\n\tctx->used = 0;\n\tctx->more = 0;\n\tatomic_set(&ctx->inflight, 0);\n\taf_alg_init_completion(&ctx->completion);\n\n\task->private = ctx;\n\n\tskcipher_request_set_tfm(&ctx->req, skcipher);\n\tskcipher_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\n\t\t\t\t      af_alg_complete, &ctx->completion);\n\n\tsk->sk_destruct = skcipher_sock_destruct;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "PyInit__ast3(void)\n{\n    PyObject *m, *d;\n    if (!init_types()) return NULL;\n    m = PyModule_Create(&_astmodule3);\n    if (!m) return NULL;\n    d = PyModule_GetDict(m);\n    if (PyDict_SetItemString(d, \"AST\", (PyObject*)&AST_type) < 0) return NULL;\n    if (PyModule_AddIntMacro(m, PyCF_ONLY_AST) < 0)\n        return NULL;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "PyInit__ast3(void)\n{\n    PyObject *m, *d;\n    if (!init_types()) return NULL;\n    m = PyModule_Create(&_astmodule);\n    if (!m) return NULL;\n    d = PyModule_GetDict(m);\n    if (PyDict_SetItemString(d, \"AST\", (PyObject*)&AST_type) < 0) return NULL;\n    if (PyModule_AddIntMacro(m, PyCF_ONLY_AST) < 0)\n        return NULL;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": " */\nprivate int\nmconvert(struct magic_set *ms, struct magic *m, int flip)\n{\n\tunion VALUETYPE *p = &ms->ms_value;\n\n\tswitch (cvt_flip(m->type, flip)) {\n\tcase FILE_BYTE:\n\t\tcvt_8(p, m);\n\t\treturn 1;\n\tcase FILE_SHORT:\n\t\tcvt_16(p, m);\n\tcase FILE_BELONG:\n\tcase FILE_BEDATE:\n\tcase FILE_BELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_BEQUAD:\n\tcase FILE_BEQDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_BEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));\n\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_LESHORT:\n\t\tp->h = (short)((p->hs[1]<<8)|(p->hs[0]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LELONG:\n\tcase FILE_LEDATE:\n\tcase FILE_LELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_LEQUAD:\n\tcase FILE_LEQDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_LEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));\n\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_MELONG:\n\tcase FILE_MEDATE:\n\tcase FILE_MELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));\n\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_FLOAT:\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_BEFLOAT:",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": " */\nprivate int\nmconvert(struct magic_set *ms, struct magic *m, int flip)\n{\n\tunion VALUETYPE *p = &ms->ms_value;\n\tuint8_t type;\n\n\tswitch (type = cvt_flip(m->type, flip)) {\n\tcase FILE_BYTE:\n\t\tcvt_8(p, m);\n\t\treturn 1;\n\tcase FILE_SHORT:\n\t\tcvt_16(p, m);\n\tcase FILE_BELONG:\n\tcase FILE_BEDATE:\n\tcase FILE_BELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[0]<<24)|(p->hl[1]<<16)|(p->hl[2]<<8)|(p->hl[3]));\n\t\tif (type == FILE_BELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_BEQUAD:\n\tcase FILE_BEQDATE:\n\tcase FILE_BEQLDATE:\n\tcase FILE_BEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[0]<<56)|((uint64_t)p->hq[1]<<48)|\n\t\t     ((uint64_t)p->hq[2]<<40)|((uint64_t)p->hq[3]<<32)|\n\t\t     ((uint64_t)p->hq[4]<<24)|((uint64_t)p->hq[5]<<16)|\n\t\t     ((uint64_t)p->hq[6]<<8)|((uint64_t)p->hq[7]));\n\t\tif (type == FILE_BEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_LESHORT:\n\t\tp->h = (short)((p->hs[1]<<8)|(p->hs[0]));\n\t\tcvt_16(p, m);\n\t\treturn 1;\n\tcase FILE_LELONG:\n\tcase FILE_LEDATE:\n\tcase FILE_LELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[3]<<24)|(p->hl[2]<<16)|(p->hl[1]<<8)|(p->hl[0]));\n\t\tif (type == FILE_LELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_LEQUAD:\n\tcase FILE_LEQDATE:\n\tcase FILE_LEQLDATE:\n\tcase FILE_LEQWDATE:\n\t\tp->q = (uint64_t)\n\t\t    (((uint64_t)p->hq[7]<<56)|((uint64_t)p->hq[6]<<48)|\n\t\t     ((uint64_t)p->hq[5]<<40)|((uint64_t)p->hq[4]<<32)|\n\t\t     ((uint64_t)p->hq[3]<<24)|((uint64_t)p->hq[2]<<16)|\n\t\t     ((uint64_t)p->hq[1]<<8)|((uint64_t)p->hq[0]));\n\t\tif (type == FILE_LEQUAD)\n\t\t\tcvt_64(p, m);\n\t\treturn 1;\n\tcase FILE_MELONG:\n\tcase FILE_MEDATE:\n\tcase FILE_MELDATE:\n\t\tp->l = (int32_t)\n\t\t    ((p->hl[1]<<24)|(p->hl[0]<<16)|(p->hl[3]<<8)|(p->hl[2]));\n\t\tif (type == FILE_MELONG)\n\t\t\tcvt_32(p, m);\n\t\treturn 1;\n\tcase FILE_FLOAT:\n\t\tcvt_float(p, m);\n\t\treturn 1;\n\tcase FILE_BEFLOAT:",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tint size = mmap_event->event_id.header.size;\n\tint ret;\n\n\tperf_event_header__init_id(&mmap_event->event_id.header, &sample, event);\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tmmap_event->event_id.header.size, 0, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tmmap_event->event_id.pid = perf_event_pid(event, current);\n\tmmap_event->event_id.tid = perf_event_tid(event, current);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tint size = mmap_event->event_id.header.size;\n\tint ret;\n\n\tperf_event_header__init_id(&mmap_event->event_id.header, &sample, event);\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tmmap_event->event_id.header.size, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tmmap_event->event_id.pid = perf_event_pid(event, current);\n\tmmap_event->event_id.tid = perf_event_tid(event, current);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "              fprintf (stderr, \"%s%s\\n\", strsignal (WTERMSIG (status)),\n                       WCOREDUMP (status) ? _(\" (core dumped)\") : \"\");\n              status = WTERMSIG (status) + 128;\n            }\n          else\n            status = WEXITSTATUS (status);\n        }\n      else if (caught_signal)\n        status = caught_signal + 128;\n      else\n        status = 1;\n    }\n  else\n    status = 1;\n\n  if (caught_signal)\n    {\n      fprintf (stderr, _(\"\\nSession terminated, killing shell...\"));\n      kill (child, SIGTERM);\n    }\n\n  cleanup_pam (PAM_SUCCESS);\n\n  if (caught_signal)\n    {\n      sleep (2);\n      kill (child, SIGKILL);\n      fprintf (stderr, _(\" ...killed.\\n\"));\n\n      /* Let's terminate itself with the received signal.\n       *\n       * It seems that shells use WIFSIGNALED() rather than our exit status\n       * value to detect situations when is necessary to cleanup (reset)",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                       WCOREDUMP (status) ? _(\" (core dumped)\") : \"\");\n              status = WTERMSIG (status) + 128;\n            }\n          else\n            status = WEXITSTATUS (status);\n\n\t  /* child is gone, don't use the PID anymore */\n\t  child = (pid_t) -1;\n        }\n      else if (caught_signal)\n        status = caught_signal + 128;\n      else\n        status = 1;\n    }\n  else\n    status = 1;\n\n  if (caught_signal && child != (pid_t)-1)\n    {\n      fprintf (stderr, _(\"\\nSession terminated, killing shell...\"));\n      kill (child, SIGTERM);\n    }\n\n  cleanup_pam (PAM_SUCCESS);\n\n  if (caught_signal)\n    {\n      if (child != (pid_t)-1)\n\t{\n\t  sleep (2);\n\t  kill (child, SIGKILL);\n\t  fprintf (stderr, _(\" ...killed.\\n\"));\n\t}\n\n      /* Let's terminate itself with the received signal.\n       *\n       * It seems that shells use WIFSIGNALED() rather than our exit status\n       * value to detect situations when is necessary to cleanup (reset)",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "   if(!acceptable)\n   {\n      //Debug message\n      TRACE_WARNING(\"Sequence number is not acceptable!\\r\\n\");\n\n      //If an incoming segment is not acceptable, an acknowledgment\n      //should be sent in reply (unless the RST bit is set)\n      if(!(segment->flags & TCP_FLAG_RST))\n         tcpSendSegment(socket, TCP_FLAG_ACK, socket->sndNxt, socket->rcvNxt, 0, FALSE);\n\n      //Return status code\n      return ERROR_FAILURE;\n   }\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "   if(!acceptable)\n   {\n      //Debug message\n      TRACE_WARNING(\"Sequence number is not acceptable!\\r\\n\");\n\n      //If an incoming segment is not acceptable, an acknowledgment should\n      //be sent in reply (unless the RST bit is set)\n      if(!(segment->flags & TCP_FLAG_RST))\n      {\n         tcpSendSegment(socket, TCP_FLAG_ACK, socket->sndNxt, socket->rcvNxt,\n            0, FALSE);\n      }\n\n      //Return status code\n      return ERROR_FAILURE;\n   }\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,\n                                   OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n    OPJ_UINT32 x, y;\n    OPJ_UINT8 *pix;\n    const OPJ_UINT8 *beyond;\n\n    beyond = pData + stride * height;\n    pix = pData;\n\n    x = y = 0U;\n    while (y < height) {\n        int c = getc(IN);\n        if (c == EOF) {\n            return OPJ_FALSE;\n        }\n            }\n            c1 = (OPJ_UINT8)c1_int;\n\n            for (j = 0; (j < c) && (x < width) &&\n                    ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                *pix = c1;\n            }\n        } else {\n            c = getc(IN);\n            if (c == EOF) {\n                return OPJ_FALSE;\n                    c1_int = getc(IN);\n                    if (c1_int == EOF) {\n                        return OPJ_FALSE;\n                    }\n                    c1 = (OPJ_UINT8)c1_int;\n                    *pix = c1;\n                }\n                if ((OPJ_UINT32)c & 1U) { /* skip padding byte */\n                    c = getc(IN);\n                    if (c == EOF) {\n                        return OPJ_FALSE;\n                    }\n                }\n            }\n        }\n    }/* while() */\n    return OPJ_TRUE;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData,\n                                   OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)\n{\n    OPJ_UINT32 x, y, written;\n    OPJ_UINT8 *pix;\n    const OPJ_UINT8 *beyond;\n\n    beyond = pData + stride * height;\n    pix = pData;\n\n    x = y = written = 0U;\n    while (y < height) {\n        int c = getc(IN);\n        if (c == EOF) {\n            return OPJ_FALSE;\n        }\n            c1 = (OPJ_UINT8)c1_int;\n\n            for (j = 0; (j < c) && (x < width) &&\n                    ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {\n                *pix = c1;\n                written++;\n            }\n        } else {\n            c = getc(IN);\n            if (c == EOF) {\n                return OPJ_FALSE;\n                    if (c1_int == EOF) {\n                        return OPJ_FALSE;\n                    }\n                    c1 = (OPJ_UINT8)c1_int;\n                    *pix = c1;\n                    written++;\n                }\n                if ((OPJ_UINT32)c & 1U) { /* skip padding byte */\n                    c = getc(IN);\n                    if (c == EOF) {\n                        return OPJ_FALSE;\n                    }\n                }\n            }\n        }\n    }/* while() */\n\n    if (written != width * height) {\n        fprintf(stderr, \"warning, image's actual size does not match advertized one\\n\");\n        return OPJ_FALSE;\n    }\n\n    return OPJ_TRUE;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\n\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\n\tplane_bytes = dbuf_getu32be(f, pos+24);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tbi->cmpcount = dbuf_getu16be(f, pos+20);\n\tbi->cmpsize = dbuf_getu16be(f, pos+22);\n\tde_dbg(c, \"pixel type=%d, bits/pixel=%d, components/pixel=%d, bits/comp=%d\",\n\t\t(int)bi->pixeltype, (int)bi->pixelsize, (int)bi->cmpcount, (int)bi->cmpsize);\n\n\tif(bi->pixelsize>0) {\n\t\tbi->pdwidth = (bi->rowbytes*8)/bi->pixelsize;\n\t}\n\tif(bi->pdwidth < bi->npwidth) {\n\t\tbi->pdwidth = bi->npwidth;\n\t}\n\n\tplane_bytes = dbuf_getu32be(f, pos+24);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    case '1': case '2': case '3': case '4': case '5': case '6': case '7':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n        PUNFETCH;\n        prev = p;\n        num = scan_unsigned_octal_number(&p, end, 3, enc);\n        if (num < 0) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 8;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    case '1': case '2': case '3': case '4': case '5': case '6': case '7':\n      if (IS_SYNTAX_OP(syn, ONIG_SYN_OP_ESC_OCTAL3)) {\n        PUNFETCH;\n        prev = p;\n        num = scan_unsigned_octal_number(&p, end, 3, enc);\n        if (num < 0 || num >= 256) return ONIGERR_TOO_BIG_NUMBER;\n        if (p == prev) {  /* can't read nothing. */\n          num = 0; /* but, it's not error */\n        }\n        tok->type = TK_RAW_BYTE;\n        tok->base = 8;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "ast_for_async_funcdef(struct compiling *c, const node *n, asdl_seq *decorator_seq)\n{\n    /* async_funcdef: ASYNC funcdef */\n    REQ(n, async_funcdef);\n    REQ(CHILD(n, 0), ASYNC);\n    REQ(CHILD(n, 1), funcdef);\n\n    return ast_for_funcdef_impl(c, CHILD(n, 1), decorator_seq,\n                                1 /* is_async */);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "ast_for_async_funcdef(struct compiling *c, const node *n, asdl_seq *decorator_seq)\n{\n    /* async_funcdef: 'async' funcdef */\n    REQ(n, async_funcdef);\n    REQ(CHILD(n, 0), NAME);\n    assert(strcmp(STR(CHILD(n, 0)), \"async\") == 0);\n    REQ(CHILD(n, 1), funcdef);\n\n    return ast_for_funcdef_impl(c, n, decorator_seq,\n                                true /* is_async */);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    }\n    if (ret_val.second.empty()) {\n      return InvalidArgument(\"Function '\", func.signature().name(),\n                             \"' has empty result name\");\n    }\n    ret_vals[position->second] =\n        value_manager.GetValueOrCreatePlaceholder(ret_val.second);\n  }\n  for (const auto& ret_val : func.control_ret()) {\n    auto position = control_output_to_position.find(ret_val.first);\n    if (position == control_output_to_position.end()) {\n      return InvalidArgument(\n    }\n    if (ret_val.second.empty()) {\n      return InvalidArgument(\"Function '\", func.signature().name(),\n                             \"' has empty control result name\");\n    }\n    Value result = value_manager.GetValueOrCreatePlaceholder(\n        (Twine(\"^\") + ret_val.second).str());\n    if (!result.getType().isa<ControlType>())\n      return InvalidArgument(\"failed to map returned value \", ret_val.second,\n                             \", isn't a control output\");\n    ret_vals[func.ret_size() + position->second] = result;\n  }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    }\n    if (ret_val.second.empty()) {\n      return InvalidArgument(\"Function '\", func.signature().name(),\n                             \"' has empty result name\");\n    }\n    TF_ASSIGN_OR_RETURN(\n        ret_vals[position->second],\n        value_manager.GetValueOrCreatePlaceholder(ret_val.second));\n  }\n  for (const auto& ret_val : func.control_ret()) {\n    auto position = control_output_to_position.find(ret_val.first);\n    if (position == control_output_to_position.end()) {\n      return InvalidArgument(\n    }\n    if (ret_val.second.empty()) {\n      return InvalidArgument(\"Function '\", func.signature().name(),\n                             \"' has empty control result name\");\n    }\n    TF_ASSIGN_OR_RETURN(Value result, value_manager.GetValueOrCreatePlaceholder(\n                                          (Twine(\"^\") + ret_val.second).str()));\n    if (!result.getType().isa<ControlType>())\n      return InvalidArgument(\"failed to map returned value \", ret_val.second,\n                             \", isn't a control output\");\n    ret_vals[func.ret_size() + position->second] = result;\n  }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteStatus GenericPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (!is_supported_type(input->type)) {\n    TF_LITE_UNSUPPORTED_TYPE(context, input->type, op_name);\n  }\n  return context->ResizeTensor(context, output,",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteStatus GenericPrepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n  if (!is_supported_type(input->type)) {\n    TF_LITE_UNSUPPORTED_TYPE(context, input->type, op_name);\n  }\n  return context->ResizeTensor(context, output,",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tASSERT(retval == 0);\n\t}\n\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\treturn retval;\n\t} else if (retval == -EEXIST) {\n\t\tif (args->flags & ATTR_CREATE)\n\t\t\treturn retval;\n\t\tretval = xfs_attr_shortform_remove(args);\n\t\tif (retval)\n\t\t\treturn retval;\n\t\t/*\n\t\t * Since we have removed the old attr, clear ATTR_REPLACE so\n\t\t * that the leaf format add routine won't trip over the attr\n\t\t * not being around.\n\t\t */\n\t\targs->flags &= ~ATTR_REPLACE;\n\t}\n\n\tif (args->namelen >= XFS_ATTR_SF_ENTSIZE_MAX ||\n\t    args->valuelen >= XFS_ATTR_SF_ENTSIZE_MAX)\n\t\treturn -ENOSPC;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tcase BGPTYPE_AIGP:\n\t{\n\t\tuint8_t type;\n\t\tuint16_t length;\n\n\t\tND_TCHECK2(tptr[0], 3);\n\n\t\ttlen = len;\n\n\t\twhile (tlen >= 3) {\n\n\t\t    type = *tptr;\n\t\t    length = EXTRACT_16BITS(tptr+1);\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s TLV (%u), length %u\",\n\t\t\t      tok2str(bgp_aigp_values, \"Unknown\", type),\n\t\t\t      type, length));\n\n\t\t    /*\n\t\t     * Check if we can read the TLV data.\n\t\t     */\n\t\t    ND_TCHECK2(tptr[3], length - 3);\n\n\t\t    switch (type) {\n\n\t\t    case BGP_AIGP_TLV:\n\t\t        ND_TCHECK2(tptr[3], 8);\n\t\t\tND_PRINT((ndo, \", metric %\" PRIu64,\n\t\t\t\t  EXTRACT_64BITS(tptr+3)));\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\t    print_unknown_data(ndo, tptr+3,\"\\n\\t      \", length-3);\n\t\t\t}\n\t\t    }\n\n\t\t    tptr += length;\n\t\t    tlen -= length;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        }\n\tcase BGPTYPE_AIGP:\n\t{\n\t\tuint8_t type;\n\t\tuint16_t length;\n\n\t\ttlen = len;\n\n\t\twhile (tlen >= 3) {\n\n\t\t    ND_TCHECK2(tptr[0], 3);\n\n\t\t    type = *tptr;\n\t\t    length = EXTRACT_16BITS(tptr+1);\n\t\t    tptr += 3;\n\t\t    tlen -= 3;\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s TLV (%u), length %u\",\n\t\t\t      tok2str(bgp_aigp_values, \"Unknown\", type),\n\t\t\t      type, length));\n\n\t\t    if (length < 3)\n\t\t\tgoto trunc;\n\t\t    length -= 3;\n\n\t\t    /*\n\t\t     * Check if we can read the TLV data.\n\t\t     */\n\t\t    ND_TCHECK2(tptr[3], length);\n\n\t\t    switch (type) {\n\n\t\t    case BGP_AIGP_TLV:\n\t\t        if (length < 8)\n\t\t            goto trunc;\n\t\t\tND_PRINT((ndo, \", metric %\" PRIu64,\n\t\t\t\t  EXTRACT_64BITS(tptr)));\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\t    print_unknown_data(ndo, tptr,\"\\n\\t      \", length);\n\t\t\t}\n\t\t    }\n\n\t\t    tptr += length;\n\t\t    tlen -= length;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "create_principal3_2_svc(cprinc3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name, service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "create_principal3_2_svc(cprinc3_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret          ret;\n    char                        *prime_arg;\n    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    restriction_t               *rp;\n    const char                  *errmsg = NULL;\n\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t     xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret, *dst;\n    const xmlChar *src;\n    xmlAttributePtr attrDecl = NULL;\n    int extsubset = 0;\n\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n\treturn(NULL);\n\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    src = value;\n    dst = ret;\n    while (*src == 0x20) src++;\n    while (*src != 0) {\n\tif (*src == 0x20) {\n\t    while (*src == 0x20) src++;\n\t    if (*src != 0)\n\t\t*dst++ = 0x20;\n\t} else {\n\t    *dst++ = *src++;\n\t}\n    }\n    *dst = 0;\n    if ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) {\n\txmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,\n\"standalone: %s on %s value had to be normalized based on external subset declaration\\n\",\n\t       name, elem->name, NULL);\n\tctxt->valid = 0;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt, xmlDocPtr doc,\n\t     xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {\n    xmlChar *ret;\n    xmlAttributePtr attrDecl = NULL;\n    int extsubset = 0;\n\n    if (doc == NULL) return(NULL);\n    if (elem == NULL) return(NULL);\n\treturn(NULL);\n\n    ret = xmlStrdup(value);\n    if (ret == NULL)\n\treturn(NULL);\n    xmlValidNormalizeString(ret);\n    if ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) {\n\txmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,\n\"standalone: %s on %s value had to be normalized based on external subset declaration\\n\",\n\t       name, elem->name, NULL);\n\tctxt->valid = 0;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[1024];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = gf_fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \\0 after a \\n*/\n\tif (unicode_type==3) gf_fgetc(txt_in);\n\treturn sOK;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[2048];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = gf_fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = (u32) gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \\0 after a \\n*/\n\tif (unicode_type==3) gf_fgetc(txt_in);\n\treturn sOK;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tEvRenderContext *rc)\n{\n\tGdkPixbuf       *pixbuf;\n\tcairo_surface_t *surface;\n\n\tpixbuf = comics_document_render_pixbuf (document, rc);\n\tsurface = ev_document_misc_surface_from_pixbuf (pixbuf);\n\tg_object_unref (pixbuf);\n\t\n\treturn surface;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "{\n\tGdkPixbuf       *pixbuf;\n\tcairo_surface_t *surface;\n\n\tpixbuf = comics_document_render_pixbuf (document, rc);\n\tif (!pixbuf)\n\t\treturn NULL;\n\tsurface = ev_document_misc_surface_from_pixbuf (pixbuf);\n\tg_clear_object (&pixbuf);\n\n\treturn surface;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "FunctionDef(identifier name, arguments_ty args, asdl_seq * body, asdl_seq *\n            decorator_list, expr_ty returns, int lineno, int col_offset, int\n            end_lineno, int end_col_offset, PyArena *arena)\n{\n    stmt_ty p;\n    if (!name) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field name is required for FunctionDef\");\n    p->kind = FunctionDef_kind;\n    p->v.FunctionDef.name = name;\n    p->v.FunctionDef.args = args;\n    p->v.FunctionDef.body = body;\n    p->v.FunctionDef.decorator_list = decorator_list;\n    p->v.FunctionDef.returns = returns;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "FunctionDef(identifier name, arguments_ty args, asdl_seq * body, asdl_seq *\n            decorator_list, expr_ty returns, string type_comment, int lineno,\n            int col_offset, int end_lineno, int end_col_offset, PyArena *arena)\n{\n    stmt_ty p;\n    if (!name) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field name is required for FunctionDef\");\n    p->v.FunctionDef.name = name;\n    p->v.FunctionDef.args = args;\n    p->v.FunctionDef.body = body;\n    p->v.FunctionDef.decorator_list = decorator_list;\n    p->v.FunctionDef.returns = returns;\n    p->v.FunctionDef.type_comment = type_comment;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "int mi_repair(MI_CHECK *param, register MI_INFO *info,\n\t      char * name, int rep_quick)\n{\n  int error,got_error;\n  ha_rows start_records,new_header_length;\n  my_off_t del;\n  File new_file;\nerr:\n  if (!got_error)\n  {\n    /* Replace the actual file with the temporary file */\n    if (new_file >= 0)\n    {\n      mysql_file_close(new_file, MYF(0));\n      info->dfile=new_file= -1;\n      /*\n        On Windows, the old data file cannot be deleted if it is either\n        open, or memory mapped. Closing the file won't remove the memory\n        (void) my_munmap((char*) info->s->file_map,\n                         (size_t) info->s->mmaped_length);\n        info->s->file_map= NULL;\n      }\n      if (change_to_newfile(share->data_file_name, MI_NAME_DEXT, DATA_TMP_EXT,\n\t\t\t    (param->testflag & T_BACKUP_DATA ?\n\t\t\t     MYF(MY_REDEL_MAKE_BACKUP): MYF(0))) ||\n\t  mi_open_datafile(info,share,name,-1))\n\tgot_error=1;\n\n      param->retry_repair= 0;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "int mi_repair(MI_CHECK *param, register MI_INFO *info,\n\t      char * name, int rep_quick, my_bool no_copy_stat)\n{\n  int error,got_error;\n  ha_rows start_records,new_header_length;\n  my_off_t del;\n  File new_file;\n  if (!got_error)\n  {\n    /* Replace the actual file with the temporary file */\n    if (new_file >= 0)\n    {\n      myf flags= 0;\n      if (param->testflag & T_BACKUP_DATA)\n        flags |= MY_REDEL_MAKE_BACKUP;\n      if (no_copy_stat)\n        flags |= MY_REDEL_NO_COPY_STAT;\n      mysql_file_close(new_file, MYF(0));\n      info->dfile=new_file= -1;\n      /*\n        On Windows, the old data file cannot be deleted if it is either\n        open, or memory mapped. Closing the file won't remove the memory\n        (void) my_munmap((char*) info->s->file_map,\n                         (size_t) info->s->mmaped_length);\n        info->s->file_map= NULL;\n      }\n      if (change_to_newfile(share->data_file_name, MI_NAME_DEXT, DATA_TMP_EXT,\n                            flags) ||\n\t  mi_open_datafile(info,share,name,-1))\n\tgot_error=1;\n\n      param->retry_repair= 0;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static CONSTBUFFER_HANDLE CONSTBUFFER_Create_Internal(const unsigned char* source, size_t size)\n{\n    CONSTBUFFER_HANDLE result;\n    /*Codes_SRS_CONSTBUFFER_02_005: [The non-NULL handle returned by CONSTBUFFER_Create shall have its ref count set to \"1\".]*/\n    /*Codes_SRS_CONSTBUFFER_02_010: [The non-NULL handle returned by CONSTBUFFER_CreateFromBuffer shall have its ref count set to \"1\".]*/\n    result = (CONSTBUFFER_HANDLE)calloc(1, (sizeof(CONSTBUFFER_HANDLE_DATA) + size));\n    if (result == NULL)\n    {\n        /*Codes_SRS_CONSTBUFFER_02_003: [If creating the copy fails then CONSTBUFFER_Create shall return NULL.]*/\n        /*Codes_SRS_CONSTBUFFER_02_008: [If copying the content fails, then CONSTBUFFER_CreateFromBuffer shall fail and return NULL.] */\n        LogError(\"unable to malloc\");",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static CONSTBUFFER_HANDLE CONSTBUFFER_Create_Internal(const unsigned char* source, size_t size)\n{\n    CONSTBUFFER_HANDLE result;\n    /*Codes_SRS_CONSTBUFFER_02_005: [The non-NULL handle returned by CONSTBUFFER_Create shall have its ref count set to \"1\".]*/\n    /*Codes_SRS_CONSTBUFFER_02_010: [The non-NULL handle returned by CONSTBUFFER_CreateFromBuffer shall have its ref count set to \"1\".]*/\n    size_t malloc_size = sizeof(CONSTBUFFER_HANDLE_DATA) + size;\n    if (malloc_size < size)\n    {\n        result = NULL;\n        LogError(\"invalid size parameter\");\n        /*return as is*/\n    }\n    else\n    {\n        result = (CONSTBUFFER_HANDLE)calloc(1, malloc_size);\n    }\n\n    if (result == NULL)\n    {\n        /*Codes_SRS_CONSTBUFFER_02_003: [If creating the copy fails then CONSTBUFFER_Create shall return NULL.]*/\n        /*Codes_SRS_CONSTBUFFER_02_008: [If copying the content fails, then CONSTBUFFER_CreateFromBuffer shall fail and return NULL.] */\n        LogError(\"unable to malloc\");",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "find_entry_internal(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int\t\t\tlock,\n\tback_txn *txn,\n\tint flags\n)\n{\n\t/* check if we should search based on uniqueid or dn */\n\tif (addr->uniqueid!=NULL)\n\t{\n\t\tstruct backentry *entry = NULL;\n\n\t\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> find_entry_internal (dn=%s) lock %d\\n\",\n\t\t           slapi_sdn_get_dn(addr->sdn), lock, 0 );\n\t\tif (addr->sdn) {\n\t\t\tentry = find_entry_internal_dn (pb, be, addr->sdn, \n\t\t\t                                lock, txn, flags);\n\t\t} else {\n\t\t\tLDAPDebug0Args( LDAP_DEBUG_ANY,\n\t\t\t                \"find_entry_internal: Null target dn\\n\" );\n\t\t}\n\n\t\tLDAPDebug0Args( LDAP_DEBUG_TRACE, \"<= find_entry_internal\\n\" );\n\t\treturn entry;\n\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "find_entry_internal(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int\t\t\tlock,\n    back_txn *txn,\n    int flags,\n    int *rc\n)\n{\n\t/* check if we should search based on uniqueid or dn */\n\tif (addr->uniqueid!=NULL)\n\t{\n\t\tstruct backentry *entry = NULL;\n\n\t\tLDAPDebug( LDAP_DEBUG_TRACE, \"=> find_entry_internal (dn=%s) lock %d\\n\",\n\t\t           slapi_sdn_get_dn(addr->sdn), lock, 0 );\n\t\tif (addr->sdn) {\n\t\t\tentry = find_entry_internal_dn (pb, be, addr->sdn, lock, txn, flags, rc);\n\t\t} else {\n\t\t\tLDAPDebug0Args( LDAP_DEBUG_ANY, \"find_entry_internal: Null target dn\\n\" );\n\t\t}\n\n\t\tLDAPDebug0Args( LDAP_DEBUG_TRACE, \"<= find_entry_internal\\n\" );\n\t\treturn entry;\n\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\n\tref->ref++;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static bool buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\n\tif (ref->ref > INT_MAX/2)\n\t\treturn false;\n\n\tref->ref++;\n\treturn true;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static char *get_header(FILE *fp)\n{\n    long start;\n\n    /* First 1024 bytes of doc must be header (1.7 spec pg 1102) */\n    char *header;\n\n    header = calloc(1, 1024);\n    \n    start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    \n    return header;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static char *get_header(FILE *fp)\n{\n    /* First 1024 bytes of doc must be header (1.7 spec pg 1102) */\n    char *header = safe_calloc(1024);\n    long start = ftell(fp);\n    fseek(fp, 0, SEEK_SET);\n    SAFE_E(fread(header, 1, 1023, fp), 1023, \"Failed to load PDF header.\\n\");\n    fseek(fp, start, SEEK_SET);\n    return header;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n          case 16: /* tokens  */\n#line 94 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1023 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 17: /* token_sequence  */\n#line 95 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1029 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 18: /* token_or_range  */\n#line 96 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1035 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 19: /* token  */\n#line 97 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1041 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 21: /* range  */\n#line 100 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1047 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 22: /* alternatives  */\n#line 99 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1053 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 23: /* byte  */\n#line 98 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1059 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n\n      default:\n        break;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN\n  switch (yytype)\n    {\n          case 16: /* tokens  */\n#line 101 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1030 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 17: /* token_sequence  */\n#line 102 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1036 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 18: /* token_or_range  */\n#line 103 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1042 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 19: /* token  */\n#line 104 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1048 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 21: /* range  */\n#line 107 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1054 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 22: /* alternatives  */\n#line 106 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1060 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n    case 23: /* byte  */\n#line 105 \"hex_grammar.y\" /* yacc.c:1257  */\n      { yr_re_node_destroy(((*yyvaluep).re_node)); }\n#line 1066 \"hex_grammar.c\" /* yacc.c:1257  */\n        break;\n\n\n      default:\n        break;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "void imap_quote_string (char *dest, size_t dlen, const char *src)\n{\n  static const char quote[] = \"\\\"\\\\\";\n  char *pt;\n  const char *s;\n\n  pt = dest;\n  s  = src;\n\n  *pt++ = '\"';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr (quote, *s))\n    {\n      dlen -= 2;\n      if (!dlen)\n\tbreak;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = 0;\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "void imap_quote_string (char *dest, size_t dlen, const char *src)\n{\n  _imap_quote_string (dest, dlen, src, \"\\\"\\\\\");\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "#endif\n    \n    test_arm();\n    printf(\"==========================\\n\");\n    test_thumb();\n\n    // dynamically free shared library\n#ifdef DYNLOAD\n    uc_dyn_free();\n#endif\n    ",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "#endif\n    \n    test_arm();\n    printf(\"==========================\\n\");\n    test_thumb();\n    printf(\"==========================\\n\");\n    test_thumb_ite();\n    // dynamically free shared library\n#ifdef DYNLOAD\n    uc_dyn_free();\n#endif\n    ",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "        POSIX_CALL(setpgid(0, pgid_to_set));\n    }\n#endif\n\n#ifdef HAVE_SETGROUPS\n    if (extra_group_size > 0)\n        POSIX_CALL(setgroups(extra_group_size, extra_groups));\n#endif /* HAVE_SETGROUPS */\n\n#ifdef HAVE_SETREGID\n    if (gid != (gid_t)-1)\n        POSIX_CALL(setregid(gid, gid));",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "        POSIX_CALL(setpgid(0, pgid_to_set));\n    }\n#endif\n\n#ifdef HAVE_SETGROUPS\n    if (extra_group_size >= 0) {\n        assert((extra_group_size == 0) == (extra_groups == NULL));\n        POSIX_CALL(setgroups(extra_group_size, extra_groups));\n    }\n#endif /* HAVE_SETGROUPS */\n\n#ifdef HAVE_SETREGID\n    if (gid != (gid_t)-1)\n        POSIX_CALL(setregid(gid, gid));",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n        r = sd_bus_message_rewind(q->request, true);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_enqeue_for_read(sd_bus_message_get_bus(q->request), q->request);\n        if (r < 0)\n                goto fail;\n\n        return 1;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n        r = sd_bus_message_rewind(q->request, true);\n        if (r < 0)\n                goto fail;\n\n        r = sd_bus_enqueue_for_read(sd_bus_message_get_bus(q->request), q->request);\n        if (r < 0)\n                goto fail;\n\n        return 1;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tmm = tsk->mm;\n\n\t/* Not an IO address, so reenable interrupts */\n\tlocal_irq_enable();\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n\n\t/*\n\t * If we're in an interrupt or have no user\n\t * context, we must not take the fault..\n\t */\n\t\tBUG();\n\t}\n\n\tif (fault & VM_FAULT_MAJOR) {\n\t\ttsk->maj_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n\t\t\t\t     regs, address);\n\t} else {\n\t\ttsk->min_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n\t\t\t\t     regs, address);\n\t}\n\n\t/* If we get here, the page fault has been handled.  Do the TLB refill\n\t   now from the newly-setup PTE, to avoid having to fault again right",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tmm = tsk->mm;\n\n\t/* Not an IO address, so reenable interrupts */\n\tlocal_irq_enable();\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n\n\t/*\n\t * If we're in an interrupt or have no user\n\t * context, we must not take the fault..\n\t */\n\t\tBUG();\n\t}\n\n\tif (fault & VM_FAULT_MAJOR) {\n\t\ttsk->maj_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,\n\t\t\t\t     regs, address);\n\t} else {\n\t\ttsk->min_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,\n\t\t\t\t     regs, address);\n\t}\n\n\t/* If we get here, the page fault has been handled.  Do the TLB refill\n\t   now from the newly-setup PTE, to avoid having to fault again right",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPOFFSETS))\n\t\t\t{\n\t\t\t\tif (!isTiled(tif))\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\n\t\t\t\t\t\tgoto bad;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\n\t\t\t\t\t\tgoto bad;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t}\n\t\t\tif (TIFFFieldSet(tif,FIELD_STRIPOFFSETS))\n\t\t\t{\n\t\t\t\tif (!isTiled(tif))\n\t\t\t\t{\n                    /* td_stripoffset might be NULL in an odd OJPEG case. See\n                     *  tif_dirread.c around line 3634.\n                     * XXX: OJPEG hack.\n                     * If a) compression is OJPEG, b) it's not a tiled TIFF,\n                     * and c) the number of strips is 1,\n                     * then we tolerate the absence of stripoffsets tag,\n                     * because, presumably, all required data is in the\n                     * JpegInterchangeFormat stream.\n                     * We can get here when using tiffset on such a file.\n                     * See http://bugzilla.maptools.org/show_bug.cgi?id=2500\n                    */\n                    if (tif->tif_dir.td_stripoffset != NULL &&\n                        !TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_STRIPOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\n                        goto bad;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!TIFFWriteDirectoryTagLongLong8Array(tif,&ndir,dir,TIFFTAG_TILEOFFSETS,tif->tif_dir.td_nstrips,tif->tif_dir.td_stripoffset))\n\t\t\t\t\t\tgoto bad;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\tgoto error;\n\t}\n\n\t// Mark the box data as never having been constructed\n\t// so that we will not errantly attempt to destroy it later.\n\tbox->ops = &jp2_boxinfo_unk.ops;\n\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tbool dataflag;\n\n\tbox = 0;\n\ttmpstream = 0;\n\n\tif (!(box = jp2_box_create0())) {\n\t\tgoto error;\n\t}\n\tif (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {\n\t\tgoto error;\n\t}\n\tboxinfo = jp2_boxinfolookup(box->type);\n\tbox->info = boxinfo;\n\tbox->len = len;\n\tJAS_DBGLOG(10, (\n\t  \"preliminary processing of JP2 box: \"\n\t  \"type=%c%s%c (0x%08x); length=%\"PRIuFAST32\"\\n\",\n\t  '\"', boxinfo->name, '\"', box->type, box->len\n\t  ));\n\tif (box->len == 1) {\n\t\tJAS_DBGLOG(10, (\"big length\\n\"));\n\t\tif (jp2_getuint64(in, &extlen)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (extlen > 0xffffffffUL) {\n\t\t\tjas_eprintf(\"warning: cannot handle large 64-bit box length\\n\");",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      if (target_class->flags & MRB_FL_CLASS_IS_PREPENDED) {\n        target_class = mrb_vm_ci_target_class(ci);\n      }\n      else if (target_class->tt == MRB_TT_MODULE) {\n        target_class = mrb_vm_ci_target_class(ci);\n        if (!target_class || target_class->tt != MRB_TT_ICLASS) {\n          goto super_typeerror;\n        }\n      }\n      recv = regs[0];\n      if (!mrb_obj_is_kind_of(mrb, recv, target_class)) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    AVPacket *pkt;\n    int i, err = 0;\n    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */\n    uint32_t vsize;\n    uint16_t asize;\n    uint16_t auxsize;\n\n    if (nsv->ahead[0].data || nsv->ahead[1].data)\n        return 0; //-1; /* hey! eat what you've in your plate first! */\n\nnull_chunk_retry:\n        st[s->streams[1]->id] = s->streams[1];\n\n    if (vsize && st[NSV_ST_VIDEO]) {\n        nst = st[NSV_ST_VIDEO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_VIDEO];\n        av_get_packet(pb, pkt, vsize);\n        pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;\n        pkt->dts = nst->frame_offset;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        for (i = 0; i < FFMIN(8, vsize); i++)\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02\"PRIx8\"\\n\",\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                       bps, channels, samplerate);\n            }\n        }\n        av_get_packet(pb, pkt, asize);\n        pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n            /* on a nsvs frame we have new information on a/v sync */\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    int i, err = 0;\n    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */\n    uint32_t vsize;\n    uint16_t asize;\n    uint16_t auxsize;\n    int ret;\n\n    if (nsv->ahead[0].data || nsv->ahead[1].data)\n        return 0; //-1; /* hey! eat what you've in your plate first! */\n\nnull_chunk_retry:\n        st[s->streams[1]->id] = s->streams[1];\n\n    if (vsize && st[NSV_ST_VIDEO]) {\n        nst = st[NSV_ST_VIDEO]->priv_data;\n        pkt = &nsv->ahead[NSV_ST_VIDEO];\n        if ((ret = av_get_packet(pb, pkt, vsize)) < 0)\n            return ret;\n        pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;\n        pkt->dts = nst->frame_offset;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        for (i = 0; i < FFMIN(8, vsize); i++)\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02\"PRIx8\"\\n\",\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n                       bps, channels, samplerate);\n            }\n        }\n        if ((ret = av_get_packet(pb, pkt, asize)) < 0)\n            return ret;\n        pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n        if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n            /* on a nsvs frame we have new information on a/v sync */\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "          ctx_(ctx),\n          cond_(cond),\n          then_handle_(then_handle),\n          else_handle_(else_handle),\n          done_(std::move(done)),\n          lib_(CHECK_NOTNULL(ctx_->function_library())) {\n      SetRunOptions(ctx_, &opts_, true /* always_collect_stats */);\n      for (int i = 1; i < ctx_->num_inputs(); ++i) {\n        args_.push_back(ctx_->input(i));\n      }\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "          ctx_(ctx),\n          cond_(cond),\n          then_handle_(then_handle),\n          else_handle_(else_handle),\n          done_(std::move(done)),\n          lib_(CHECK_NOTNULL(ctx_->function_library())),\n          opts_(ctx->step_id()) {\n      SetRunOptions(ctx_, &opts_, true /* always_collect_stats */);\n      for (int i = 1; i < ctx_->num_inputs(); ++i) {\n        args_.push_back(ctx_->input(i));\n      }\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\tbreak;\n  }\n\n  *bufptr = '\\0';\n\n  PDFIO_DEBUG(\"_pdfioTokenRead: Read '%s'.\\n\", buffer);\n\n  return (bufptr > buffer);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\tbreak;\n  }\n\n  *bufptr = '\\0';\n\n//  PDFIO_DEBUG(\"_pdfioTokenRead: Read '%s'.\\n\", buffer);\n\n  return (bufptr > buffer);\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static int simulate_llsc(struct pt_regs *regs, unsigned int opcode)\n{\n\tif ((opcode & OPCODE) == LL) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, 0, regs, 0);\n\t\treturn simulate_ll(regs, opcode);\n\t}\n\tif ((opcode & OPCODE) == SC) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, 0, regs, 0);\n\t\treturn simulate_sc(regs, opcode);\n\t}\n\n\treturn -1;\t\t\t/* Must be something else ... */\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static int simulate_llsc(struct pt_regs *regs, unsigned int opcode)\n{\n\tif ((opcode & OPCODE) == LL) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, regs, 0);\n\t\treturn simulate_ll(regs, opcode);\n\t}\n\tif ((opcode & OPCODE) == SC) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, regs, 0);\n\t\treturn simulate_sc(regs, opcode);\n\t}\n\n\treturn -1;\t\t\t/* Must be something else ... */\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "      JpegInput( String filename ) : filename_( std::move( filename )) {\n         infile_ = std::fopen( filename_.c_str(), \"rb\" );\n         if( infile_ == nullptr ) {\n            if( !FileHasExtension( filename_ )) {\n               filename_ = FileAddExtension( filename_, \"jpg\" ); // Try with \"jpg\" extension\n               infile_ = std::fopen( filename_.c_str(), \"rb\" );\n            DIP_THROW_RUNTIME( \"Could not open the specified JPEG file\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         if( setjmp( jerr_.setjmp_buffer )) {\n            // If we get here, the JPEG code has signaled an error.\n            DIP_THROW_RUNTIME( \"Error reading JPEG file.\" );\n         }\n         jpeg_create_decompress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_src( &cinfo_, infile_ );\n         jpeg_read_header( &cinfo_, TRUE );\n      }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "      JpegInput( String filename, std::jmp_buf const& setjmp_buffer ) : filename_( std::move( filename )) {\n         infile_ = std::fopen( filename_.c_str(), \"rb\" );\n         if( infile_ == nullptr ) {\n            if( !FileHasExtension( filename_ )) {\n               filename_ = FileAddExtension( filename_, \"jpg\" ); // Try with \"jpg\" extension\n               infile_ = std::fopen( filename_.c_str(), \"rb\" );\n            DIP_THROW_RUNTIME( \"Could not open the specified JPEG file\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         std::memcpy( jerr_.setjmp_buffer, setjmp_buffer, sizeof( setjmp_buffer ));\n         jpeg_create_decompress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_src( &cinfo_, infile_ );\n         jpeg_read_header( &cinfo_, TRUE );\n      }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\n\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps; ++pi->compno,\n\t  ++pi->picomp) {\n\t\tpirlvl = pi->picomp->pirlvls;\n\t\tpi->xstep = pi->picomp->hsamp * (1 << (pirlvl->prcwidthexpn +\n\t\t  pi->picomp->numrlvls - 1));\n\t\tpi->ystep = pi->picomp->vsamp * (1 << (pirlvl->prcheightexpn +\n\t\t  pi->picomp->numrlvls - 1));\n\t\tfor (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];\n\t\t  rlvlno < pi->picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp * (1 <<\n\t\t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls -\n\t\t\t  rlvlno - 1)));\n\t\t\tpi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp * (1 <<\n\t\t\t  (pirlvl->prcheightexpn + pi->picomp->numrlvls -\n\t\t\t  rlvlno - 1)));\n\t\t}\n\t\tfor (pi->y = pi->ystart; pi->y < pi->yend;\n\t\t  pi->y += pi->ystep - (pi->y % pi->ystep)) {\n\t\t\tfor (pi->x = pi->xstart; pi->x < pi->xend;\n\t\t\t  pi->x += pi->xstep - (pi->x % pi->xstep)) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tfor (pi->compno = pchg->compnostart, pi->picomp =\n\t  &pi->picomps[pi->compno]; pi->compno < JAS_CAST(int, pchg->compnoend) && pi->compno < pi->numcomps; ++pi->compno,\n\t  ++pi->picomp) {\n\t\tpirlvl = pi->picomp->pirlvls;\n\t\tpi->xstep = pi->picomp->hsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcwidthexpn + pi->picomp->numrlvls - 1));\n\t\tpi->ystep = pi->picomp->vsamp * (JAS_CAST(uint_fast32_t, 1) <<\n\t\t  (pirlvl->prcheightexpn + pi->picomp->numrlvls - 1));\n\t\tfor (rlvlno = 1, pirlvl = &pi->picomp->pirlvls[1];\n\t\t  rlvlno < pi->picomp->numrlvls; ++rlvlno, ++pirlvl) {\n\t\t\tpi->xstep = JAS_MIN(pi->xstep, pi->picomp->hsamp *\n\t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcwidthexpn +\n\t\t\t  pi->picomp->numrlvls - rlvlno - 1)));\n\t\t\tpi->ystep = JAS_MIN(pi->ystep, pi->picomp->vsamp *\n\t\t\t  (JAS_CAST(uint_fast32_t, 1) << (pirlvl->prcheightexpn +\n\t\t\t  pi->picomp->numrlvls - rlvlno - 1)));\n\t\t}\n\t\tfor (pi->y = pi->ystart; pi->y < pi->yend;\n\t\t  pi->y += pi->ystep - (pi->y % pi->ystep)) {\n\t\t\tfor (pi->x = pi->xstart; pi->x < pi->xend;\n\t\t\t  pi->x += pi->xstep - (pi->x % pi->xstep)) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\n\tunsigned char* cp = (unsigned char*) cp0;\n\tassert((cc%stride)==0);\n\tif (cc > stride) {\n\t\t/*\n\t\t * Pipeline the most common cases.\n\t\t */\n\t\tif (stride == 3)  {\n\t\t\t\tREPEAT4(stride, cp[stride] =\n\t\t\t\t\t(unsigned char) ((cp[stride] + *cp) & 0xff); cp++)\n\t\t\t\tcc -= stride;\n\t\t\t} while (cc>0);\n\t\t}\n\t}\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc)\n{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\n\tunsigned char* cp = (unsigned char*) cp0;\n    if((cc%stride)!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"horAcc8\",\n                     \"%s\", \"(cc%stride)!=0\");\n        return 0;\n    }\n\n\tif (cc > stride) {\n\t\t/*\n\t\t * Pipeline the most common cases.\n\t\t */\n\t\tif (stride == 3)  {\n\t\t\t\t\t(unsigned char) ((cp[stride] + *cp) & 0xff); cp++)\n\t\t\t\tcc -= stride;\n\t\t\t} while (cc>0);\n\t\t}\n\t}\n\treturn 1;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\t\t\t      LELEM(ISAKMP_NEXT_CERT))) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"%smessage ignored because it contains a payload type (%s) unexpected by state %s\",\n\t\t\t\t\t\texcuse,\n\t\t\t\t\t\tenum_show(&ikev1_payload_names, np),\n\t\t\t\t\t\tst->st_state->name);\n\t\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\t\tSEND_NOTIFICATION(INVALID_PAYLOAD_TYPE);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\t\t\t      LELEM(ISAKMP_NEXT_CERT))) {\n\t\t\t\t\tloglog(RC_LOG_SERIOUS,\n\t\t\t\t\t\t\"%smessage ignored because it contains a payload type (%s) unexpected by state %s\",\n\t\t\t\t\t\texcuse,\n\t\t\t\t\t\tenum_show(&ikev1_payload_names, np),\n\t\t\t\t\t\tfinite_states[smc->state]->name);\n\t\t\t\t\tif (!md->encrypted) {\n\t\t\t\t\t\tSEND_NOTIFICATION(INVALID_PAYLOAD_TYPE);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; /* the name */\n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n                break;\n            case TYPE_COMMENT:\n                /* arg will be equal to the last argument processed */\n                arg->type_comment = NEW_TYPE_COMMENT(ch);",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                          c->c_arena);\n                if (!arg)\n                    goto error;\n                asdl_seq_SET(kwonlyargs, j++, arg);\n                i += 1; /* the name */\n                if (TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; /* the comma, if present */\n                break;\n            case TYPE_COMMENT:\n                /* arg will be equal to the last argument processed */\n                arg->type_comment = NEW_TYPE_COMMENT(ch);",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "  guint sandbox_flags = 0;\n  gboolean sandboxed;\n  gboolean expose_pids;\n  gboolean share_pids;\n  gboolean notify_start;\n  gboolean devel;\n\n  child_setup_data.instance_id_fd = -1;\n\n  if (fd_list != NULL)\n    fds = g_unix_fd_list_peek_fds (fd_list, &fds_len);\n\n  app_info = g_object_get_data (G_OBJECT (invocation), \"app-info\");\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--a11y-bus\"));\n    }\n  else\n    {\n      for (i = 0; extra_args != NULL && extra_args[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));\n    }\n\n  expose_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0;\n  share_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS) != 0;\n",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "  gboolean sandboxed;\n  gboolean expose_pids;\n  gboolean share_pids;\n  gboolean notify_start;\n  gboolean devel;\n  g_autoptr(GString) env_string = g_string_new (\"\");\n\n  child_setup_data.instance_id_fd = -1;\n  child_setup_data.env_fd = -1;\n\n  if (fd_list != NULL)\n    fds = g_unix_fd_list_peek_fds (fd_list, &fds_len);\n\n  app_info = g_object_get_data (G_OBJECT (invocation), \"app-info\");\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--a11y-bus\"));\n    }\n  else\n    {\n      for (i = 0; extra_args != NULL && extra_args[i] != NULL; i++)\n        {\n          if (g_str_has_prefix (extra_args[i], \"--env=\"))\n            {\n              const char *var_val = extra_args[i] + strlen (\"--env=\");\n\n              if (var_val[0] == '\\0' || var_val[0] == '=')\n                {\n                  g_warning (\"Environment variable in extra-args has empty name\");\n                  continue;\n                }\n\n              if (strchr (var_val, '=') == NULL)\n                {\n                  g_warning (\"Environment variable in extra-args has no value\");\n                  continue;\n                }\n\n              g_string_append (env_string, var_val);\n              g_string_append_c (env_string, '\\0');\n            }\n          else\n            {\n              g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));\n            }\n        }\n    }\n\n  if (env_string->len > 0)\n    {\n      g_auto(GLnxTmpfile) env_tmpf  = { 0, };\n\n      if (!flatpak_buffer_to_sealed_memfd_or_tmpfile (&env_tmpf, \"environ\",\n                                                      env_string->str,\n                                                      env_string->len, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      child_setup_data.env_fd = glnx_steal_fd (&env_tmpf.fd);\n      g_ptr_array_add (flatpak_argv,\n                       g_strdup_printf (\"--env-fd=%d\",\n                                        child_setup_data.env_fd));\n    }\n\n  expose_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0;\n  share_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS) != 0;\n",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* dims = GetInput(context, node, kDimsTensor);\n  const TfLiteTensor* value = GetInput(context, node, kValueTensor);\n\n  // Make sure the 1st input tensor is 1-D.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(dims), 1);\n\n  // Make sure the 1st input tensor is int32 or int64.\n  TF_LITE_ENSURE(context, dtype == kTfLiteInt32 || dtype == kTfLiteInt64);\n\n  // Make sure the 2nd input tensor is a scalar.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(value), 0);\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  output->type = value->type;\n\n  if (IsConstantTensor(dims)) {\n    TF_LITE_ENSURE_OK(context, ResizeOutput(context, dims, output));\n  } else {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* dims;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kDimsTensor, &dims));\n  const TfLiteTensor* value;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kValueTensor, &value));\n\n  // Make sure the 1st input tensor is 1-D.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(dims), 1);\n\n  // Make sure the 1st input tensor is int32 or int64.\n  TF_LITE_ENSURE(context, dtype == kTfLiteInt32 || dtype == kTfLiteInt64);\n\n  // Make sure the 2nd input tensor is a scalar.\n  TF_LITE_ENSURE_EQ(context, NumDimensions(value), 0);\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  output->type = value->type;\n\n  if (IsConstantTensor(dims)) {\n    TF_LITE_ENSURE_OK(context, ResizeOutput(context, dims, output));\n  } else {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "    size_t out_size;\n    void *out_buf;\n    z_stream strm;\n    mz_ulong crc;\n\n    out_size = in_len + 32;\n    out_buf = flb_malloc(out_size);\n    if (!out_buf) {\n        flb_errno();\n        flb_error(\"[gzip] could not allocate outgoing buffer\");\n        return -1;\n    }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "    size_t out_size;\n    void *out_buf;\n    z_stream strm;\n    mz_ulong crc;\n\n\n    /*\n     * GZIP relies on an algorithm with worst-case expansion\n     * of 5 bytes per 32KB data. This means we need to create a variable\n     * length output, that depends on the input length.\n     * See RFC 1951 for details.\n     */\n    int max_input_expansion = ((int)(in_len / 32000) + 1) * 5;\n\n    /*\n     * Max compressed size is equal to sum of:\n     *   10 byte header\n     *   8 byte foot\n     *   max input expansion\n     *   size of input\n     */\n    out_size = 10 + 8 + max_input_expansion + in_len;\n    out_buf = flb_malloc(out_size);\n\n    if (!out_buf) {\n        flb_errno();\n        flb_error(\"[gzip] could not allocate outgoing buffer\");\n        return -1;\n    }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "header_seek (SF_PRIVATE *psf, sf_count_t position, int whence)\n{\n\tswitch (whence)\n\t{\tcase SEEK_SET :\n\t\t\tif (position > SIGNED_SIZEOF (psf->header))\n\t\t\t{\t/* Too much header to cache so just seek instead. */\n\t\t\t\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\t\t\tif (position > psf->headend)\n\t\t\t\tpsf->headend += psf_fread (psf->header + psf->headend, 1, position - psf->headend, psf) ;\n\t\t\tpsf->headindex = position ;\n\t\t\tbreak ;\n\n\t\tcase SEEK_CUR :\n\t\t\tif (psf->headindex + position < 0)\n\t\t\t\tbreak ;\n\n\t\t\tif (psf->headindex >= SIGNED_SIZEOF (psf->header))\n\t\t\t{\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->headindex + position <= psf->headend)\n\t\t\t{\tpsf->headindex += position ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->headindex + position > SIGNED_SIZEOF (psf->header))\n\t\t\t{\t/* Need to jump this without caching it. */\n\t\t\t\tpsf->headindex = psf->headend ;\n\t\t\t\tpsf_fseek (psf, position, SEEK_CUR) ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\n\t\t\tpsf->headend += psf_fread (psf->header + psf->headend, 1, position - (psf->headend - psf->headindex), psf) ;\n\t\t\tpsf->headindex = psf->headend ;\n\t\t\tbreak ;\n\n\t\tcase SEEK_END :\n\t\tdefault :\n\t\t\tpsf_log_printf (psf, \"Bad whence param in header_seek().\\n\") ;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "header_seek (SF_PRIVATE *psf, sf_count_t position, int whence)\n{\n\tswitch (whence)\n\t{\tcase SEEK_SET :\n\t\t\tif (psf->header.indx + position >= psf->header.len)\n\t\t\t\tpsf_bump_header_allocation (psf, position) ;\n\t\t\tif (position > psf->header.len)\n\t\t\t{\t/* Too much header to cache so just seek instead. */\n\t\t\t\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\t\t\tif (position > psf->header.end)\n\t\t\t\tpsf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, position - psf->header.end, psf) ;\n\t\t\tpsf->header.indx = position ;\n\t\t\tbreak ;\n\n\t\tcase SEEK_CUR :\n\t\t\tif (psf->header.indx + position >= psf->header.len)\n\t\t\t\tpsf_bump_header_allocation (psf, position) ;\n\n\t\t\tif (psf->header.indx + position < 0)\n\t\t\t\tbreak ;\n\n\t\t\tif (psf->header.indx >= psf->header.len)\n\t\t\t{\tpsf_fseek (psf, position, whence) ;\n\t\t\t\treturn ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->header.indx + position <= psf->header.end)\n\t\t\t{\tpsf->header.indx += position ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\n\t\t\tif (psf->header.indx + position > psf->header.len)\n\t\t\t{\t/* Need to jump this without caching it. */\n\t\t\t\tpsf->header.indx = psf->header.end ;\n\t\t\t\tpsf_fseek (psf, position, SEEK_CUR) ;\n\t\t\t\tbreak ;\n\t\t\t\t} ;\n\n\t\t\tpsf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, position - (psf->header.end - psf->header.indx), psf) ;\n\t\t\tpsf->header.indx = psf->header.end ;\n\t\t\tbreak ;\n\n\t\tcase SEEK_END :\n\t\tdefault :\n\t\t\tpsf_log_printf (psf, \"Bad whence param in header_seek().\\n\") ;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->tread_sem);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\ttu = kzalloc(sizeof(*tu), GFP_KERNEL);\n\tif (tu == NULL)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&tu->qlock);\n\tinit_waitqueue_head(&tu->qchange_sleep);\n\tmutex_init(&tu->ioctl_lock);\n\ttu->ticks = 1;\n\ttu->queue_size = 128;\n\ttu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),\n\t\t\t    GFP_KERNEL);\n\tif (tu->queue == NULL) {",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tcontext.nbbit = i->imgbits + 1;\n\t\t\tcontext.max = clr + clr - 1; /* (1 << context.nbbit) - 1 */\n\t\t\tact_code = GetGifWord(i, &context);\n\t\t\tcasspecial = (u8)act_code;\n\t\t\told_code = act_code;\n\t\t\tWritePixel(i, &context, casspecial); npix--;\n\t\t} else {\n\t\t\tread_byt = act_code;\n\t\t\tif(act_code >= free) {\t/* code pas encore dans alphabet */\n/*\t\t\t\tprintf(\"Code pas dans alphabet : %d>=%d push %d\\n\", act_code, free, casspecial); */\n\t\t\t\t*(--stackp) = casspecial; /* dernier debut de chaine ! */\n\t\t\t\tact_code = ab_prfx[act_code];\t/* prefixe */\n\t\t\t}\n\t\t\t/* act_code est concret */\n\t\t\tcasspecial = (u8)act_code;\t/* dernier debut de chaine ! */\n\t\t\t*(--stackp) = casspecial;\t/* push on stack */\n\t\t\tWritePixels(i, &context, stackp, stack_top - stackp);\t/* unstack all pixels at once */\n\t\t\tnpix -= (stack_top - stackp);\n\t\t\tstackp = stack_top;\n/*\t\t\tputchar('\\n'); */\n\t\t\tif(free < 4096) { /* la taille du dico est 4096 max ! */\n\t\t\t\tab_prfx[free] = old_code;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tcontext.nbbit = i->imgbits + 1;\n\t\t\tcontext.max = clr + clr - 1; /* (1 << context.nbbit) - 1 */\n\t\t\tact_code = GetGifWord(i, &context);\n\t\t\tcasspecial = (u8)act_code;\n\t\t\told_code = act_code;\n\t\t\tif(npix > 0) WritePixel(i, &context, casspecial);\n\t\t\tnpix--;\n\t\t} else {\n\t\t\tread_byt = act_code;\n\t\t\tif(act_code >= free) {\t/* code pas encore dans alphabet */\n/*\t\t\t\tprintf(\"Code pas dans alphabet : %d>=%d push %d\\n\", act_code, free, casspecial); */\n\t\t\t\t*(--stackp) = casspecial; /* dernier debut de chaine ! */\n\t\t\t\tact_code = ab_prfx[act_code];\t/* prefixe */\n\t\t\t}\n\t\t\t/* act_code est concret */\n\t\t\tcasspecial = (u8)act_code;\t/* dernier debut de chaine ! */\n\t\t\t*(--stackp) = casspecial;\t/* push on stack */\n\t\t\tif(npix >= (stack_top - stackp)) {\n\t\t\t\tWritePixels(i, &context, stackp, stack_top - stackp);\t/* unstack all pixels at once */\n\t\t\t} else if(npix > 0) {\t/* \"pixel overflow\" */\n\t\t\t\tWritePixels(i, &context, stackp, npix);\n\t\t\t}\n\t\t\tnpix -= (stack_top - stackp);\n\t\t\tstackp = stack_top;\n/*\t\t\tputchar('\\n'); */\n\t\t\tif(free < 4096) { /* la taille du dico est 4096 max ! */\n\t\t\t\tab_prfx[free] = old_code;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\treturn false;\n\n\tmemcpy(&head,&from.head,sizeof(BITMAPINFOHEADER));\n\tmemcpy(&info,&from.info,sizeof(CXIMAGEINFO));\n\n\tpDib = from.pDib;\n\tpSelection = from.pSelection;\n\tpAlpha = from.pAlpha;\n\tppLayers = from.ppLayers;\n\n\tmemset(&from.head,0,sizeof(BITMAPINFOHEADER));\n\tmemset(&from.info,0,sizeof(CXIMAGEINFO));\n\tfrom.pDib = from.pSelection = from.pAlpha = NULL;\n\tfrom.ppLayers = NULL;\n\n\tif (bTransferFrames){\n\t\tDestroyFrames();\n\t\tppFrames = from.ppFrames;",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\n\tmemcpy(&head,&from.head,sizeof(BITMAPINFOHEADER));\n\tmemcpy(&info,&from.info,sizeof(CXIMAGEINFO));\n\n\tpDib = from.pDib;\n    pDib = from.pDibLimit;\n\tpSelection = from.pSelection;\n\tpAlpha = from.pAlpha;\n\tppLayers = from.ppLayers;\n\n\tmemset(&from.head,0,sizeof(BITMAPINFOHEADER));\n\tmemset(&from.info,0,sizeof(CXIMAGEINFO));\n    from.pDib = from.pDibLimit = from.pSelection = from.pAlpha = NULL;\n\tfrom.ppLayers = NULL;\n\n\tif (bTransferFrames){\n\t\tDestroyFrames();\n\t\tppFrames = from.ppFrames;",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "static void cil_reset_classperms_set(struct cil_classperms_set *cp_set)\n{\n\tcil_reset_classpermission(cp_set->set);\n}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "static void cil_reset_classperms_set(struct cil_classperms_set *cp_set)\n{\n\tif (cp_set == NULL) {\n\t\treturn;\n\t}\n\n\tcp_set->set = NULL;\n}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "\t\t\tmax_value  = MAX_NO_PRIVATE;\n\t\t}\n\n\t\t/* Multiple variant values as variant0, variant1 ,variant2 */\n\t\tisFirstSubtag = 0;\n\t\tfor( i=0 ; i< max_value; i++ ){  \n\t\t\tsnprintf( cur_key_name , 30, \"%s%d\", key_name , i);\t\n\t\t\tif( zend_hash_find( hash_arr , cur_key_name , strlen(cur_key_name) + 1,(void **)&ele_value ) == SUCCESS ){\n\t\t\t\tif( Z_TYPE_PP(ele_value)!= IS_STRING ){\n\t\t\t\t\t/* variant is not a string */\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "\t\t\tmax_value  = MAX_NO_PRIVATE;\n\t\t}\n\n\t\t/* Multiple variant values as variant0, variant1 ,variant2 */\n\t\tisFirstSubtag = 0;\n\t\tfor( i=0 ; i< max_value; i++ ){\n\t\t\tsnprintf( cur_key_name , 30, \"%s%d\", key_name , i);\n\t\t\tif( zend_hash_find( hash_arr , cur_key_name , strlen(cur_key_name) + 1,(void **)&ele_value ) == SUCCESS ){\n\t\t\t\tif( Z_TYPE_PP(ele_value)!= IS_STRING ){\n\t\t\t\t\t/* variant is not a string */\n\t\t\t\t\treturn FAILURE;\n\t\t\t\t}",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  },
  {
    "input": "                       time_clean(prline.u_str, im->gdes[i].format);\n                    } else {\n                        strftime(prline.u_str,\n                                 FMT_LEG_LEN, im->gdes[i].format, &tmvdef);\n                    }\n                } else if (bad_format(im->gdes[i].format)) {\n                    rrd_set_error\n                        (\"bad format for PRINT in '%s'\", im->gdes[i].format);\n                    return -1;\n                } else {\n                    prline.u_str =\n                        sprintf_alloc(im->gdes[i].format, printval, si_symb);\n                }\n                    } else {\n                        strftime(im->gdes[i].legend,\n                                 FMT_LEG_LEN, im->gdes[i].format, &tmvdef);\n                    }\n                } else {\n                    if (bad_format(im->gdes[i].format)) {\n                        rrd_set_error\n                            (\"bad format for GPRINT in '%s'\",\n                             im->gdes[i].format);\n                        return -1;\n                    }\n                    snprintf(im->gdes[i].legend,\n                             FMT_LEG_LEN - 2,\n                             im->gdes[i].format, printval, si_symb);\n                }",
    "output": 1,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 4
  },
  {
    "input": "                       time_clean(prline.u_str, im->gdes[i].format);\n                    } else {\n                        strftime(prline.u_str,\n                                 FMT_LEG_LEN, im->gdes[i].format, &tmvdef);\n                    }\n                } else if (bad_format_print(im->gdes[i].format)) {\n                    return -1;\n                } else {\n                    prline.u_str =\n                        sprintf_alloc(im->gdes[i].format, printval, si_symb);\n                }\n                    } else {\n                        strftime(im->gdes[i].legend,\n                                 FMT_LEG_LEN, im->gdes[i].format, &tmvdef);\n                    }\n                } else {\n                    if (bad_format_print(im->gdes[i].format)) {\n                       return -1;\n                    }\n                    snprintf(im->gdes[i].legend,\n                             FMT_LEG_LEN - 2,\n                             im->gdes[i].format, printval, si_symb);\n                }",
    "output": 0,
    "instruction": "Detect whether the following code contains vulnerabilities.",
    "idx": 5
  }
]