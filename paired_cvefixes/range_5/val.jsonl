{"func_before":"            CUDNN_CONVOLUTION_BWD_FILTER_ALGO_WINOGRAD_NONFUSED &&\n        perf_results[r].memory <= mem_limit) {\n      return perf_results[r].algo;\n    }\n  }\n  return tsl::Status(port::error::INTERNAL,\n                     \"cudnnGetConvolutionBackwardFilterAlgorithm_v7 returned \"\n                     \"no suitable algorithms. This could be a cudnn bug.\");\n#else\n  cudnnConvolutionBwdFilterPreference_t preference =\n      specify_workspace_limit","target":1,"flaw_line_index":0,"hash":"db5c598c-7943-4d07-8cec-46129ac049ae","idx":"b81b060a-214f-4c3e-8e94-698f37b8fb20"}
{"func_before":"            CUDNN_CONVOLUTION_BWD_FILTER_ALGO_WINOGRAD_NONFUSED &&\n        perf_results[r].memory <= mem_limit) {\n      return perf_results[r].algo;\n    }\n  }\n  return tsl::Status(tsl::error::INTERNAL,\n                     \"cudnnGetConvolutionBackwardFilterAlgorithm_v7 returned \"\n                     \"no suitable algorithms. This could be a cudnn bug.\");\n#else\n  cudnnConvolutionBwdFilterPreference_t preference =\n      specify_workspace_limit","target":0,"flaw_line_index":0,"hash":"3ddaa590-c623-455d-a294-29aec9ad4d0a","idx":"89ce1ac3-731f-4851-8dfd-743a947fecc4"}
{"func_before":"\t}\n\n\tswitch (data) {\n\n\tcase SUNKBD_RET_RESET:\n\t\tschedule_work(&sunkbd->tq);\n\t\tsunkbd->reset = -1;\n\t\tbreak;\n\n\tcase SUNKBD_RET_LAYOUT:\n\t\tsunkbd->layout = -1;","target":1,"flaw_line_index":0,"hash":"29663199-d413-4e16-8bbd-a356efb22ddb","idx":"c0f86f4b-848c-4c55-be0b-0b04e3a11f71"}
{"func_before":"\t}\n\n\tswitch (data) {\n\n\tcase SUNKBD_RET_RESET:\n\t\tif (sunkbd->enabled)\n\t\t\tschedule_work(&sunkbd->tq);\n\t\tsunkbd->reset = -1;\n\t\tbreak;\n\n\tcase SUNKBD_RET_LAYOUT:\n\t\tsunkbd->layout = -1;","target":0,"flaw_line_index":0,"hash":"239570dd-a882-4037-a505-b83fb6814563","idx":"11b86571-2c1d-4647-a0ec-2406f5148447"}
{"func_before":"void track_set_index(Track *track, int i, long ind)\n{\n\tif (i > MAXINDEX) {\n\t\tfprintf(stderr, \"too many indexes\\n\");\n                return;\n        }\n\n\ttrack->index[i] = ind;","target":1,"flaw_line_index":0,"hash":"8b6637cd-c8a5-461e-8456-a83aa3cbc007","idx":"1f64684d-f82c-4edb-b323-92841a5ec421"}
{"func_before":"void track_set_index(Track *track, int i, long ind)\n{\n\tif (i < 0 || i > MAXINDEX) {\n\t\tfprintf(stderr, \"too many indexes\\n\");\n                return;\n        }\n\n\ttrack->index[i] = ind;","target":0,"flaw_line_index":0,"hash":"72215d49-bdd7-4567-a64a-8f9dfd5c8e59","idx":"6d5dac7a-4d20-4a97-a31a-3b3ca69bdd80"}
{"func_before":"  if (IsConstantTensor(op_context.input) && op_data->float_input_initialized) {\n    return kTfLiteOk;\n  }\n\n  \/\/ Dequantize the input\n  TfLiteTensor* dequantized = GetTemporary(context, node, \/*index=*\/0);\n  auto status = builtin::dequantize::DequantizeImpl<kernel_type>(\n      context, node, op_context.input, dequantized);\n  if (status != kTfLiteOk) {\n    return status;\n  }","target":1,"flaw_line_index":0,"hash":"b7358470-ad92-40c6-874d-10dd14511808","idx":"d48b0b58-eb8f-4091-a4dd-9ee3a1cbc015"}
{"func_before":"  if (IsConstantTensor(op_context.input) && op_data->float_input_initialized) {\n    return kTfLiteOk;\n  }\n\n  \/\/ Dequantize the input\n  TfLiteTensor* dequantized;\n  TF_LITE_ENSURE_OK(context,\n                    GetTemporarySafe(context, node, \/*index=*\/0, &dequantized));\n  auto status = builtin::dequantize::DequantizeImpl<kernel_type>(\n      context, node, op_context.input, dequantized);\n  if (status != kTfLiteOk) {\n    return status;\n  }","target":0,"flaw_line_index":0,"hash":"5b47c8fd-a396-4acb-8ff9-535ee5fa027d","idx":"7fa5068e-fc0f-4da7-b7e0-b6acaa87c0d9"}
{"func_before":"  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  switch (input->type) {  \/\/ Already know in\/out types are same.\n    case kTfLiteFloat32:\n      AverageEvalFloat<kernel_type>(context, node, params, data, input, output);\n      break;\n    case kTfLiteUInt8:\n      AverageEvalQuantizedUint8<kernel_type>(context, node, params, data, input,\n                                             output);\n      break;\n    case kTfLiteInt8:\n      AverageEvalQuantizedInt8<kernel_type>(context, node, params, data, input,\n                                            output);\n      break;\n    case kTfLiteInt16:\n      AverageEvalQuantizedInt16<kernel_type>(context, node, params, data, input,\n                                             output);\n      break;\n    default:\n      TF_LITE_KERNEL_LOG(context, \"Type %s not currently supported.\",\n                         TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }","target":1,"flaw_line_index":0,"hash":"dd8d36c6-d3c7-485e-b9e1-75e156475e9b","idx":"8437f029-f172-458c-a5c2-079671a2a597"}
{"func_before":"  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  switch (input->type) {  \/\/ Already know in\/out types are same.\n    case kTfLiteFloat32:\n      return AverageEvalFloat<kernel_type>(context, node, params, data, input,\n                                           output);\n    case kTfLiteUInt8:\n      return AverageEvalQuantizedUint8<kernel_type>(context, node, params, data,\n                                                    input, output);\n    case kTfLiteInt8:\n      return AverageEvalQuantizedInt8<kernel_type>(context, node, params, data,\n                                                   input, output);\n    case kTfLiteInt16:\n      return AverageEvalQuantizedInt16<kernel_type>(context, node, params, data,\n                                                    input, output);\n    default:\n      TF_LITE_KERNEL_LOG(context, \"Type %s not currently supported.\",\n                         TfLiteTypeGetName(input->type));\n      return kTfLiteError;\n  }","target":0,"flaw_line_index":0,"hash":"30475008-7b1e-47b3-bbeb-d81bb333d4b8","idx":"1794b9d3-19ed-490b-979f-7d0da195aeac"}
{"func_before":"      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n  \/\/ TODO(ebrevdo): add shape checks between values, indices,\n  \/\/ dense_shape.  Also add check that dense rank > 0.\n\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),","target":1,"flaw_line_index":0,"hash":"47e34ea2-857e-4281-a7df-20e1706d8250","idx":"bd710ceb-00c1-4b86-a944-80be0de24d60"}
{"func_before":"      context, TensorShapeUtils::IsScalar(default_value_t.shape()),\n      errors::InvalidArgument(\"default_value must be a scalar, saw: \",\n                              default_value_t.shape().DebugString()),\n      done);\n  \/\/ TODO(ebrevdo): add shape checks between values, indices,\n  \/\/ Also add check that dense rank > 0.\n  OP_REQUIRES_ASYNC(context, dense_shape_t.NumElements() != 0,\n                    errors::InvalidArgument(\"Dense shape cannot be empty.\"),\n                    done);\n\n  using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>;\n  OP_REQUIRES_OK_ASYNC(context,\n                       FunctorType()(context, default_value_t, indices_t,\n                                     values_t, dense_shape_t, done),","target":0,"flaw_line_index":0,"hash":"9e013eaf-4973-44f2-bc40-552a33382995","idx":"e2845fd2-a101-4f2e-b88e-7438493f40ce"}
{"func_before":"struct lib_t* MACH0_(get_libs)(struct MACH0_(obj_t)* bin) {\n\tstruct lib_t *libs;\n\tint i;\n\n\tif (!bin->nlibs)\n\t\treturn NULL;\n\tif (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t))))\n\t\treturn NULL;\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tstrncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH);\n\t\tlibs[i].name[R_BIN_MACH0_STRING_LENGTH-1] = '\\0';\n\t\tlibs[i].last = 0;\n\t}","target":1,"flaw_line_index":0,"hash":"aadc7078-9bb9-42e9-b92b-ea2608e13c0b","idx":"245c844f-89dd-4b6e-8439-b452444e509d"}
{"func_before":"struct lib_t* MACH0_(get_libs)(struct MACH0_(obj_t)* bin) {\n\tstruct lib_t *libs;\n\tint i;\n\n\tif (!bin->nlibs) {\n\t\treturn NULL;\n\t}\n\tif (!(libs = calloc ((bin->nlibs + 1), sizeof(struct lib_t)))) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < bin->nlibs; i++) {\n\t\tstrncpy (libs[i].name, bin->libs[i], R_BIN_MACH0_STRING_LENGTH);\n\t\tlibs[i].name[R_BIN_MACH0_STRING_LENGTH-1] = '\\0';\n\t\tlibs[i].last = 0;\n\t}","target":0,"flaw_line_index":0,"hash":"a1070ff9-a96a-4de5-8273-d90c3c4a6638","idx":"6c99a260-23ac-4238-b384-4b9fdc72efe6"}
{"func_before":"    size_t bytes_read;\n    unsigned char buffer[64], buffer2[32];\n    unsigned char *head, *tail;\n    unsigned char ipad[64], opad[64];\n    int reached_eof = 0;\n    \n    \/* Read the file header *\/\n    if ((bytes_read = fread(&aeshdr, 1, sizeof(aeshdr), infp)) !=\n         sizeof(aescrypt_hdr))\n    {\n        if (feof(infp))\n        {\n            fprintf(stderr, \"Error: Input file is too short.\\n\");\n        }\n        else\n        {\n            perror(\"Error reading the file header:\");\n        }\n    }\n\n    if (!(aeshdr.aes[0] == 'A' && aeshdr.aes[1] == 'E' &&\n          aeshdr.aes[2] == 'S'))\n    {\n        fprintf(stderr, \"Error: Bad file header (not aescrypt file or is corrupted? [%x, %x, %x])\\n\", aeshdr.aes[0], aeshdr.aes[1], aeshdr.aes[2]);\n        return -1;\n    }\n\n    \/* Validate the version number and take any version-specific actions *\/\n    if (aeshdr.version == 0)\n        {\n            if ((bytes_read = fread(buffer, 1, 2, infp)) != 2)\n            {\n                if (feof(infp))\n                {\n                    fprintf(stderr, \"Error: Input file is too short.\\n\");\n                }\n                else\n                {\n                    perror(\"Error reading the file extensions:\");\n                }\n            {\n                if ((bytes_read = fread(buffer, 1, 1, infp)) != 1)\n                {\n                    if (feof(infp))\n                    {\n                        fprintf(stderr, \"Error: Input file is too short.\\n\");\n                    }\n                    else\n                    {\n                        perror(\"Error reading the file extensions:\");\n                    }\n    \/* Read the initialization vector from the file *\/\n    if ((bytes_read = fread(IV, 1, 16, infp)) != 16)\n    {\n        if (feof(infp))\n        {\n            fprintf(stderr, \"Error: Input file is too short.\\n\");\n        }\n        else\n        {\n            perror(\"Error reading the initialization vector:\");\n        }\n    }\n\n    \/* Hash the IV and password 8192 times *\/\n    memset(digest, 0, 32);\n    memcpy(digest, IV, 16);\n    for(i=0; i<8192; i++)\n    {\n        sha256_starts(  &sha_ctx);\n        sha256_update(  &sha_ctx, digest, 32);\n        sha256_update(  &sha_ctx,\n                        passwd,\n                        passlen);\n        sha256_finish(  &sha_ctx,\n                        digest);\n    }\n\n    \/* Set the AES encryption key *\/\n    aes_set_key(&aes_ctx, digest, 256);\n\n     *   H(K XOR opad, H(K XOR ipad, text))\n     *\/\n    memset(ipad, 0x36, 64);\n    memset(opad, 0x5C, 64);\n\n    for(i=0; i<32; i++)\n    {\n        ipad[i] ^= digest[i];\n        opad[i] ^= digest[i];\n    }\n\n    \/* If this is a version 1 or later file, then read the IV and key\n     * for decrypting the bulk of the file.\n     *\/\n    if (aeshdr.version >= 0x01)\n    {\n        for(i=0; i<48; i+=16)\n        {\n            if ((bytes_read = fread(buffer, 1, 16, infp)) != 16)\n            {\n                if (feof(infp))\n                {\n                    fprintf(stderr, \"Error: Input file is too short.\\n\");\n                }\n                else\n                {\n                    perror(\"Error reading input file IV and key:\");\n                }\n\n            \/*\n             * XOR plain text block with previous encrypted\n             * output (i.e., use CBC)\n             *\/\n            for(j=0; j<16; j++)\n            {\n                iv_key[i+j] = (buffer[j] ^ IV[j]);\n            }\n\n            \/* Update the IV (CBC mode) *\/\n            memcpy(IV, buffer2, 16);\n        }\n\n        if ((bytes_read = fread(buffer, 1, 32, infp)) != 32)\n        {\n            if (feof(infp))\n            {\n                fprintf(stderr, \"Error: Input file is too short.\\n\");\n            }\n            else\n            {\n                perror(\"Error reading input file digest:\");\n            }\n            return -1;\n        }\n\n        if (memcmp(digest, buffer, 32))\n        {\n            fprintf(stderr, \"Error: Message has been altered or password is incorrect\\n\");\n            return -1;\n        }\n\n        \/*\n         * Re-load the IV and encryption key with the IV and\n         *   H(K XOR opad, H(K XOR ipad, text))\n         *\/\n        memset(ipad, 0x36, 64);\n        memset(opad, 0x5C, 64);\n\n        for(i=0; i<32; i++)\n        {\n            ipad[i] ^= iv_key[i+16];\n            opad[i] ^= iv_key[i+16];\n        }\n\n        \/* Wipe the IV and encryption key from memory *\/\n        memset_secure(iv_key, 0, 48);\n\n        sha256_starts(&sha_ctx);\n        sha256_update(&sha_ctx, ipad, 64);\n    }\n    \n    \/*\n     * Decrypt the balance of the file\n     *\n     * Attempt to initialize the ring buffer with contents from the file.\n     * Attempt to read 48 octets of the file into the ring buffer.\n        else\n        {\n            \/*\n             * If there are less than 48 octets, the only valid count\n             * is 32 for version 0 (HMAC) and 33 for version 1 or\n             * greater files ( file size modulo + HMAC)\n             *\/\n            if ((aeshdr.version == 0x00 && bytes_read != 32) ||\n                (aeshdr.version >= 0x01 && bytes_read != 33))\n            {\n                fprintf(stderr, \"Error: Input file is corrupt (1:%u).\\n\",\n                        (unsigned) bytes_read);\n                return -1;\n            }\n            else\n            {\n                 * If this initial read indicates there is no encrypted\n                 * data, then there should be 0 in the last_block_size field\n                 *\/\n                if (aeshdr.last_block_size != 0)\n                {\n                    fprintf(stderr, \"Error: Input file is corrupt (2).\\n\");\n                    return -1;\n                }\n            }\n            reached_eof = 1;\n        }\n            {\n                \/* The last block for v0 must be 16 and for v1 it must be 1 *\/\n                if ((aeshdr.version == 0x00 && bytes_read > 0) ||\n                    (aeshdr.version >= 0x01 && bytes_read != 1))\n                {\n                    fprintf(stderr, \"Error: Input file is corrupt (3:%u).\\n\",\n                            (unsigned) bytes_read);\n                    return -1;\n                }\n\n                \/*\n\n            \/*\n             * XOR plain text block with previous encrypted\n             * output (i.e., use CBC)\n             *\/\n            for(i=0; i<16; i++)\n            {\n                tail[i] ^= IV[i];\n            }\n\n            \/* Update the IV (CBC mode) *\/\n            if ((i = fwrite(tail, 1, n, outfp)) != n)\n            {\n                perror(\"Error writing decrypted block:\");\n                return -1;\n            }\n            \n            \/* Move the tail of the ring buffer forward *\/\n            tail += 16;\n            if (tail == (buffer+64))\n            {\n                tail = buffer;\n\n    if (memcmp(digest, buffer2, 32))\n    {\n        if (aeshdr.version == 0x00)\n        {\n            fprintf(stderr, \"Error: Message has been altered or password is incorrect\\n\");\n        }\n        else\n        {\n            fprintf(stderr, \"Error: Message has been altered and should not be trusted\\n\");\n        }\n\n        return -1;\n    }\n","target":1,"flaw_line_index":0,"hash":"e2ec9ca6-1f49-4247-8c76-9d526a8005dd","idx":"c88f6535-373b-4c80-9bff-5d188cd25cdd"}
{"func_before":"    size_t bytes_read;\n    unsigned char buffer[64], buffer2[32];\n    unsigned char *head, *tail;\n    unsigned char ipad[64], opad[64];\n    int reached_eof = 0;\n\n    \/* Read the file header *\/\n    if ((bytes_read = fread(&aeshdr, 1, sizeof(aeshdr), infp)) !=\n         sizeof(aescrypt_hdr))\n    {\n        if (feof(infp))\n        {\n            fprintf(stderr, \"Error: Input file is too short\\n\");\n        }\n        else\n        {\n            perror(\"Error reading the file header:\");\n        }\n    }\n\n    if (!(aeshdr.aes[0] == 'A' && aeshdr.aes[1] == 'E' &&\n          aeshdr.aes[2] == 'S'))\n    {\n        fprintf(stderr,\n                \"Error: Bad file header (not aescrypt file or is corrupted? \"\n                \"[%x, %x, %x])\\n\",\n                aeshdr.aes[0],\n                aeshdr.aes[1],\n                aeshdr.aes[2]);\n        return -1;\n    }\n\n    \/* Validate the version number and take any version-specific actions *\/\n    if (aeshdr.version == 0)\n        {\n            if ((bytes_read = fread(buffer, 1, 2, infp)) != 2)\n            {\n                if (feof(infp))\n                {\n                    fprintf(stderr, \"Error: Input file is too short\\n\");\n                }\n                else\n                {\n                    perror(\"Error reading the file extensions:\");\n                }\n            {\n                if ((bytes_read = fread(buffer, 1, 1, infp)) != 1)\n                {\n                    if (feof(infp))\n                    {\n                        fprintf(stderr, \"Error: Input file is too short\\n\");\n                    }\n                    else\n                    {\n                        perror(\"Error reading the file extensions:\");\n                    }\n    \/* Read the initialization vector from the file *\/\n    if ((bytes_read = fread(IV, 1, 16, infp)) != 16)\n    {\n        if (feof(infp))\n        {\n            fprintf(stderr, \"Error: Input file is too short\\n\");\n        }\n        else\n        {\n            perror(\"Error reading the initialization vector:\");\n        }\n    }\n\n    \/* Hash the IV and password 8192 times *\/\n    memset(digest, 0, 32);\n    memcpy(digest, IV, 16);\n    for (i = 0; i < 8192; i++)\n    {\n        sha256_starts(&sha_ctx);\n        sha256_update(&sha_ctx, digest, 32);\n        sha256_update(&sha_ctx, passwd, passlen);\n        sha256_finish(&sha_ctx, digest);\n    }\n\n    \/* Set the AES encryption key *\/\n    aes_set_key(&aes_ctx, digest, 256);\n\n     *   H(K XOR opad, H(K XOR ipad, text))\n     *\/\n    memset(ipad, 0x36, 64);\n    memset(opad, 0x5C, 64);\n\n    for (i = 0; i < 32; i++)\n    {\n        ipad[i] ^= digest[i];\n        opad[i] ^= digest[i];\n    }\n\n    \/* If this is a version 1 or later file, then read the IV and key\n     * for decrypting the bulk of the file.\n     *\/\n    if (aeshdr.version >= 0x01)\n    {\n        for (i = 0; i < 48; i += 16)\n        {\n            if ((bytes_read = fread(buffer, 1, 16, infp)) != 16)\n            {\n                if (feof(infp))\n                {\n                    fprintf(stderr, \"Error: Input file is too short\\n\");\n                }\n                else\n                {\n                    perror(\"Error reading input file IV and key:\");\n                }\n\n            \/*\n             * XOR plain text block with previous encrypted\n             * output (i.e., use CBC)\n             *\/\n            for (j = 0; j < 16; j++)\n            {\n                iv_key[i + j] = (buffer[j] ^ IV[j]);\n            }\n\n            \/* Update the IV (CBC mode) *\/\n            memcpy(IV, buffer2, 16);\n        }\n\n        if ((bytes_read = fread(buffer, 1, 32, infp)) != 32)\n        {\n            if (feof(infp))\n            {\n                fprintf(stderr, \"Error: Input file is too short\\n\");\n            }\n            else\n            {\n                perror(\"Error reading input file digest:\");\n            }\n            return -1;\n        }\n\n        if (memcmp(digest, buffer, 32))\n        {\n            fprintf(stderr,\n                    \"Error: Message has been altered or password is \"\n                    \"incorrect\\n\");\n            return -1;\n        }\n\n        \/*\n         * Re-load the IV and encryption key with the IV and\n         *   H(K XOR opad, H(K XOR ipad, text))\n         *\/\n        memset(ipad, 0x36, 64);\n        memset(opad, 0x5C, 64);\n\n        for (i = 0; i < 32; i++)\n        {\n            ipad[i] ^= iv_key[i + 16];\n            opad[i] ^= iv_key[i + 16];\n        }\n\n        \/* Wipe the IV and encryption key from memory *\/\n        memset_secure(iv_key, 0, 48);\n\n        sha256_starts(&sha_ctx);\n        sha256_update(&sha_ctx, ipad, 64);\n    }\n\n    \/*\n     * Decrypt the balance of the file\n     *\n     * Attempt to initialize the ring buffer with contents from the file.\n     * Attempt to read 48 octets of the file into the ring buffer.\n        else\n        {\n            \/*\n             * If there are less than 48 octets, the only valid count\n             * is 32 for version 0 (HMAC) and 33 for version 1 or\n             * greater files (file size modulo + HMAC)\n             *\/\n            if ((aeshdr.version == 0x00 && bytes_read != 32) ||\n                (aeshdr.version >= 0x01 && bytes_read != 33))\n            {\n                fprintf(stderr, \"Error: Input file is corrupt (1:%u)\\n\",\n                        (unsigned) bytes_read);\n                return -1;\n            }\n            else\n            {\n                 * If this initial read indicates there is no encrypted\n                 * data, then there should be 0 in the last_block_size field\n                 *\/\n                if (aeshdr.last_block_size != 0)\n                {\n                    fprintf(stderr, \"Error: Input file is corrupt (2)\\n\");\n                    return -1;\n                }\n            }\n            reached_eof = 1;\n        }\n            {\n                \/* The last block for v0 must be 16 and for v1 it must be 1 *\/\n                if ((aeshdr.version == 0x00 && bytes_read > 0) ||\n                    (aeshdr.version >= 0x01 && bytes_read != 1))\n                {\n                    fprintf(stderr, \"Error: Input file is corrupt (3:%u)\\n\",\n                            (unsigned) bytes_read);\n                    return -1;\n                }\n\n                \/*\n\n            \/*\n             * XOR plain text block with previous encrypted\n             * output (i.e., use CBC)\n             *\/\n            for (i = 0; i < 16; i++)\n            {\n                tail[i] ^= IV[i];\n            }\n\n            \/* Update the IV (CBC mode) *\/\n            if ((i = fwrite(tail, 1, n, outfp)) != n)\n            {\n                perror(\"Error writing decrypted block:\");\n                return -1;\n            }\n\n            \/* Move the tail of the ring buffer forward *\/\n            tail += 16;\n            if (tail == (buffer+64))\n            {\n                tail = buffer;\n\n    if (memcmp(digest, buffer2, 32))\n    {\n        if (aeshdr.version == 0x00)\n        {\n            fprintf(stderr,\n                    \"Error: Message has been altered or password is \"\n                    \"incorrect\\n\");\n        }\n        else\n        {\n            fprintf(stderr,\n                    \"Error: Message has been altered and should not be \"\n                    \"trusted\\n\");\n        }\n\n        return -1;\n    }\n","target":0,"flaw_line_index":0,"hash":"f2c91761-545a-4dd5-992e-f58c5b887318","idx":"f3d6714e-d549-4684-aa6d-09a6f53c194a"}
{"func_before":"static void fanout_release(struct sock *sk)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_fanout *f;\n\n\tf = po->fanout;\n\tif (!f)\n\t\treturn;\n\n\tmutex_lock(&fanout_mutex);\n\tpo->fanout = NULL;\n\n\tif (atomic_dec_and_test(&f->sk_ref)) {\n\t\tlist_del(&f->list);\n\t\tdev_remove_pack(&f->prot_hook);\n\t\tfanout_release_data(f);\n\t\tkfree(f);\n\t}\n\tmutex_unlock(&fanout_mutex);\n\n\tif (po->rollover)\n\t\tkfree_rcu(po->rollover, rcu);\n}","target":1,"flaw_line_index":0,"hash":"7975b530-7ddf-45f6-b8ed-d184ec962f52","idx":"86e6e476-2b44-4264-90cb-f3d081217e47"}
{"func_before":"static void fanout_release(struct sock *sk)\n{\n\tstruct packet_sock *po = pkt_sk(sk);\n\tstruct packet_fanout *f;\n\n\tmutex_lock(&fanout_mutex);\n\tf = po->fanout;\n\tif (f) {\n\t\tpo->fanout = NULL;\n\n\t\tif (atomic_dec_and_test(&f->sk_ref)) {\n\t\t\tlist_del(&f->list);\n\t\t\tdev_remove_pack(&f->prot_hook);\n\t\t\tfanout_release_data(f);\n\t\t\tkfree(f);\n\t\t}\n\n\t\tif (po->rollover)\n\t\t\tkfree_rcu(po->rollover, rcu);\n\t}\n\tmutex_unlock(&fanout_mutex);\n}","target":0,"flaw_line_index":0,"hash":"95de5b3a-fa2c-4b6d-b3ef-a3d8f6319be7","idx":"e3245981-a2b3-4f60-bb3d-ee214d2d1f9b"}
{"func_before":"void fb_write_bin(uint8_t *bin, int len, const fb_t a) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tif (len != RLC_FB_BYTES) {","target":1,"flaw_line_index":0,"hash":"419e58c3-c736-4faa-9585-8899ff8c28a8","idx":"51bb5b34-d804-4fb0-9181-d7c82b0c014e"}
{"func_before":"void fb_write_bin(uint8_t *bin, size_t len, const fb_t a) {\n\tbn_t t;\n\n\tbn_null(t);\n\n\tif (len != RLC_FB_BYTES) {","target":0,"flaw_line_index":0,"hash":"559f5694-fe5c-4192-ad3f-eef35cb1f9f3","idx":"4e5ac49c-f108-41fb-af84-23a53cd4d981"}
{"func_before":"MONGO_EXPORT int bson_append_symbol_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_SYMBOL );\n}","target":1,"flaw_line_index":0,"hash":"021758c3-306d-4513-8526-3d59ce719d4b","idx":"e2c1e2b1-7049-4546-b8fb-44ec14fb30bf"}
{"func_before":"MONGO_EXPORT int bson_append_symbol_n( bson *b, const char *name, const char *value, size_t len ) {\n    return bson_append_string_base( b, name, value, len, BSON_SYMBOL );\n}","target":0,"flaw_line_index":0,"hash":"5e2f3112-9fe9-49ba-a1f8-59f3581ab3e8","idx":"a6e4ad9b-70d1-4215-96b0-f14ed07e7fcf"}
{"func_before":"{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n\n    clear(); \/\/ clear response\n\n    sessionInitialize();\n    if (!sessionActive() && !isAuthNeeded())\n        sessionStart();\n","target":1,"flaw_line_index":0,"hash":"6b1a9cb0-e717-450f-ab97-a068cf327fa0","idx":"0b9dbdc5-fcad-4176-850b-085db8913c8c"}
{"func_before":"{\n    session_ = 0;\n    request_ = request;\n    env_ = env;\n\n    \/\/ clear response\n    clear();\n\n    \/\/ avoid clickjacking attacks\n    header(Http::HEADER_X_FRAME_OPTIONS, \"SAMEORIGIN\");\n\n    sessionInitialize();\n    if (!sessionActive() && !isAuthNeeded())\n        sessionStart();\n","target":0,"flaw_line_index":0,"hash":"1b9ec232-8170-44dd-acc5-22b1db0a2169","idx":"904eb9ba-11a7-4a82-a008-d26411478376"}
{"func_before":"int fb_bits(const fb_t a) {\n\tint i = RLC_FB_DIGS - 1;\n\n\twhile (i >= 0 && a[i] == 0) {\n\t\ti--;\n\t}\n\n\tif (i > 0) {\n\t\treturn (i << RLC_DIG_LOG) + util_bits_dig(a[i]);\n\t} else {\n\t\treturn util_bits_dig(a[0]);\n\t}\n}","target":1,"flaw_line_index":0,"hash":"de3ccb77-bf29-4da2-9f3d-d0a6ecd39daf","idx":"6cdbc341-ed9f-4a85-a671-8d0dcee3d158"}
{"func_before":"size_t fb_bits(const fb_t a) {\n\tint i = RLC_FB_DIGS - 1;\n\n\twhile (i >= 0 && a[i] == 0) {\n\t\ti--;\n\t}\n\n\tif (i > 0) {\n\t\treturn (i << RLC_DIG_LOG) + util_bits_dig(a[i]);\n\t} else {\n\t\treturn util_bits_dig(a[0]);\n\t}\n}","target":0,"flaw_line_index":0,"hash":"3071fff3-22f4-440e-8b2a-007637ca683d","idx":"a619ca68-10ae-4a61-8813-f57498a74ab1"}
{"func_before":"\n    bool has_location = false;\n    for (const StringStringEntryProto& entry : tensor.external_data()) {\n      if (entry.has_key() && entry.has_value() && entry.key() == \"location\") {\n        has_location = true;\n#ifdef _WIN32\n        auto file_path = std::filesystem::path(utf8str_to_wstring(entry.value()));\n        if (file_path.is_absolute()) {\n          fail_check(\n              \"Location of external TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be a relative path, but it is an absolute path: \",\n              entry.value());\n        }\n        auto relative_path = file_path.lexically_normal().make_preferred().wstring();\n        \/\/ Check that normalized relative path contains \"..\" on Windows.\n        if (relative_path.find(L\"..\", 0) != std::string::npos) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be file inside the \",\n              ctx.get_model_dir(),\n              \", but the '\",\n              entry.value(),\n              \"' points outside the directory\");\n        }\n        std::wstring data_path = path_join(utf8str_to_wstring(ctx.get_model_dir()), relative_path);\n        struct _stat64 buff;\n        if (data_path.empty() || (data_path[0] != '#' && _wstat64(data_path.c_str(), &buff) != 0)) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be stored in \",\n              entry.value(),\n              \", but it doesn't exist or is not accessible.\");\n        }\n#else \/\/ POSIX\n        if (entry.value().empty()) {\n          fail_check(\"Location of external TensorProto ( tensor name: \", tensor.name(), \") should not be empty.\");\n        } else if (entry.value()[0] == '\/') {\n          fail_check(\n              \"Location of external TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be a relative path, but it is an absolute path: \",\n              entry.value());\n        }\n        std::string relative_path = clean_relative_path(entry.value());\n        \/\/ Check that normalized relative path contains \"..\" on POSIX\n        if (relative_path.find(\"..\", 0) != std::string::npos) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be file inside the \",\n              ctx.get_model_dir(),\n              \", but the '\",\n              entry.value(),\n              \"' points outside the directory\");\n        }\n        std::string data_path = path_join(ctx.get_model_dir(), relative_path);\n        \/\/ use stat64 to check whether the file exists\n#if defined(__APPLE__) || defined(__wasm__) || !defined(__GLIBC__)\n        struct stat buffer; \/\/ APPLE, wasm and non-glic stdlibs do not have stat64\n        if (data_path.empty() || (data_path[0] != '#' && stat((data_path).c_str(), &buffer) != 0)) {\n#else\n        struct stat64 buffer; \/\/ All POSIX under glibc except APPLE and wasm have stat64\n        if (data_path.empty() || (data_path[0] != '#' && stat64((data_path).c_str(), &buffer) != 0)) {\n#endif\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be stored in \",\n              data_path,\n              \", but it doesn't exist or is not accessible.\");\n        }\n        \/\/ Do not allow symlinks or directories.\n        if (data_path.empty() || (data_path[0] != '#' && !S_ISREG(buffer.st_mode))) {\n          fail_check(\n              \"Data of TensorProto ( tensor name: \",\n              tensor.name(),\n              \") should be stored in \",\n              data_path,\n              \", but it is not regular file.\");\n        }\n#endif\n      }\n    }\n    if (!has_location) {\n      fail_check(\"TensorProto ( tensor name: \", tensor.name(), \") is stored externally but doesn't have a location.\");\n    }\n    }\n  }\n\n#undef check_field\n}\n\nvoid check_sequence(const SequenceProto& sequence, const CheckerContext& ctx) {\n  enforce_has_field(sequence, elem_type);\n  if (sequence.elem_type() == SequenceProto::TENSOR) {\n    for (const TensorProto& tensor : sequence.tensor_values()) {\n      check_tensor(tensor, ctx);\n    }\n  } else if (sequence.elem_type() == SequenceProto::SPARSE_TENSOR) {\n    for (const SparseTensorProto& sparse_tensor : sequence.sparse_tensor_values()) {\n      check_sparse_tensor(sparse_tensor, ctx);\n    }\n  } else if (sequence.elem_type() == SequenceProto::SEQUENCE) {\n    for (const SequenceProto& seq : sequence.sequence_values()) {\n      check_sequence(seq, ctx);\n    }\n  } else if (sequence.elem_type() == SequenceProto::MAP) {\n    for (const MapProto& map : sequence.map_values()) {\n      check_map(map, ctx);\n    }\n  } else {\n    fail_check(\n        \"Sequence ( Structure name: \",\n        sequence.name(),\n        \", elem_type: \",\n        sequence.elem_type(),\n        \") is not have a valid element type.\");\n  }\n}\n\nvoid check_optional(const OptionalProto& optional, const CheckerContext& ctx) {\n  enforce_has_field(optional, elem_type);\n  if (optional.elem_type() == OptionalProto::UNDEFINED) {\n    return;\n  } else if (optional.elem_type() == OptionalProto::TENSOR) {\n    if (optional.has_tensor_value())\n      check_tensor(optional.tensor_value(), ctx);\n  } else if (optional.elem_type() == OptionalProto::SPARSE_TENSOR) {\n    if (optional.has_sparse_tensor_value())\n      check_sparse_tensor(optional.sparse_tensor_value(), ctx);\n  } else if (optional.elem_type() == OptionalProto::SEQUENCE) {\n    if (optional.has_sequence_value())\n      check_sequence(optional.sequence_value(), ctx);\n  } else if (optional.elem_type() == OptionalProto::MAP) {\n    if (optional.has_map_value())\n      check_map(optional.map_value(), ctx);\n  } else {\n    fail_check(\n        \"Optional ( Structure name: \",\n        optional.name(),\n        \", elem_type: \",\n        optional.elem_type(),\n        \") is not have a valid element type.\");\n  }\n}\n\nvoid check_map(const MapProto& map, const CheckerContext& ctx) {\n  enforce_has_field(map, key_type);\n  if (map.key_type() == TensorProto::UNDEFINED) {\n    fail_check(\"setting key_type field (map name: \", map.name(), \") to UNDEFINED is not allowed\");\n  }\n  \/\/ Check if key is a valid type, specifically INT8, INT16, INT32, INT64,\n  \/\/ UINT8, UINT16, UINT32, UINT64, or STRING.\n  if ((map.key_type() == TensorProto::FLOAT) || (map.key_type() == TensorProto::BOOL) ||\n      (map.key_type() == TensorProto::FLOAT16) || (map.key_type() == TensorProto::COMPLEX64) ||\n      (map.key_type() == TensorProto::COMPLEX128)) {\n    fail_check(\n        \"setting key_type field (map name: \",\n        map.name(),\n        \") to invalid TensorProto key_type \",\n        map.key_type(),\n        \" is not allowed\");\n  }\n\n  \/\/ MapProto will use either keys or string_keys, so only one should be > 0.\n  if ((map.keys_size() > 0) && (map.string_keys_size() > 0)) {\n    fail_check(\"Map (name: \", map.name(), \") should not contain more than one keys field.\");\n  }\n\n  int num_keys = map.keys_size() + map.string_keys_size();\n  int num_values = 0;\n\n  enforce_has_field(map, values);\n  check_sequence(map.values(), ctx);\n\n  if (map.values().elem_type() == SequenceProto::TENSOR) {\n    num_values = map.values().tensor_values_size();\n  } else if (map.values().elem_type() == SequenceProto::SPARSE_TENSOR) {\n    num_values = map.values().sparse_tensor_values_size();\n  } else if (map.values().elem_type() == SequenceProto::SEQUENCE) {\n    num_values = map.values().sequence_values_size();\n  } else if (map.values().elem_type() == SequenceProto::MAP) {\n    num_values = map.values().map_values_size();\n  }\n\n  if (num_keys != num_values) {\n    fail_check(\"Length of map keys and map values are not the same (map name: \", map.name(), \")\");\n  }\n}\n\n\/\/ Check that the index data stored in a SparseTensorProto is valid.\n\/\/ indices: a 1-dimensional tensor; indices[i] represents the\n\/\/ linearized index value for the i-th nonzero value.\nvoid check_sparse_tensor_indices_1(\n    const TensorProto& indices,\n    const SparseTensorProto& sparse_tensor_proto,\n    size_t nnz) {\n  int dense_rank = sparse_tensor_proto.dims_size();\n  int64_t dense_size = 1;\n  for (int i = 0; i < dense_rank; ++i)\n    dense_size *= sparse_tensor_proto.dims(i);\n  if (static_cast<size_t>(indices.dims(0)) != nnz) {\n    fail_check(\"Sparse tensor indices (\", indices.name(), \") has \", indices.dims(0), \" values, but NNZ is \", nnz);\n  }\n\n  \/\/ Check if indices appear in ascending order, and if they have valid\n  \/\/ values. The i-th value in index_data is the linear index of the i-th\n  \/\/ non-zero value.\n  const std::vector<int64_t> index_data = ParseData<int64_t>(&indices);\n\n  int64_t prev_index = -1;\n  for (size_t i = 0; i < nnz; ++i) {\n    int64_t curr_index = index_data[i]; \/\/ linearized index of i-th value\n    if (curr_index < 0 || curr_index >= dense_size) {\n      fail_check(\n          \"Sparse tensor (\",\n          indices.name(),\n          \") index value at position [\",\n          i,\n          \"] out of range [0, \",\n          dense_size - 1,\n          \"]\");\n    }\n    if (curr_index <= prev_index) {\n      fail_check(\"Sparse tensor (\", indices.name(), \") index value at position [\", i, \"] not in sorted order.\");\n    }\n    prev_index = curr_index;\n  }\n}\n\n\/\/ Check that the index data stored in a SparseTensorProto is valid.\n\/\/ indices: a 2-dimensional tensor; indices[i,j] represents the j-th\n\/\/ index value for the i-th nonzero value.\nvoid check_sparse_tensor_indices_2(\n    const TensorProto& indices,\n    const SparseTensorProto& sparse_tensor_proto,\n    size_t nnz) {\n  int dense_rank = sparse_tensor_proto.dims_size();\n  if (static_cast<size_t>(indices.dims(0)) != nnz) {\n    fail_check(\"Sparse tensor indices (\", indices.name(), \") first dimension size does not equal NNZ.\");\n  }\n  if (indices.dims(1) != dense_rank) {\n    fail_check(\"Sparse tensor indices (\", indices.name(), \") second dimension size does not match rank of tensor.\");\n  }\n\n  \/\/ Check if indices appear in ascending order, and if they have valid\n  \/\/ values.\n  const std::vector<int64_t> index_data = ParseData<int64_t>(&indices);\n  int64_t prev_index = -1;\n  for (size_t i = 0; i < nnz; ++i) {\n    int64_t curr_index = 0; \/\/ linearized index of i-th value\n    for (int j = 0; j < dense_rank; ++j) {\n      auto index_ij = index_data[i * dense_rank + j];\n      if ((index_ij < 0) || (index_ij >= sparse_tensor_proto.dims(j))) {\n        fail_check(\"Sparse tensor (\", indices.name(), \") index value at position [\", i, \",\", j, \"] out of range.\");\n      }\n      curr_index = curr_index * sparse_tensor_proto.dims(j) + index_ij;\n    }\n    if (curr_index <= prev_index) {\n      fail_check(\n          \"Sparse tensor (\", indices.name(), \") index value at position [\", i, \"] not in lexicographic sorted order.\");\n    }\n    prev_index = curr_index;\n  }\n}\n\nvoid check_sparse_tensor(const SparseTensorProto& sparse_tensor_proto, const CheckerContext& ctx) {\n  enforce_has_field(sparse_tensor_proto, values);\n\n  const TensorProto& values = sparse_tensor_proto.values();\n  check_tensor(values, ctx);\n\n  \/\/ values must be a tensor of shape [NNZ]\n  \/\/ Currently we restrict the value associated with a particular index-tuple\n  \/\/ to be a single value. In the future, if there is a requirement,\n  \/\/ we may extend this to permit the value to be a \"sub-tensor\", in which\n  \/\/ case values will have dimension > 1.\n  if (values.dims_size() != 1) {\n    fail_check(\"Sparse tensor values (\", values.name(), \") must have rank 1.\");\n  }\n  size_t nnz = static_cast<size_t>(values.dims(0));\n  int dense_rank = sparse_tensor_proto.dims_size();\n  if (dense_rank == 0) {\n    fail_check(\"Sparse tensor (\", values.name(), \") must have a dense-rank > 0\");\n  }\n  for (int i = 0; i < dense_rank; ++i) {\n    if (sparse_tensor_proto.dims(i) <= 0) {\n      fail_check(\"Sparse tensor (\", values.name(), \") dimensions are not positive.\");\n    }\n  }\n\n  if (sparse_tensor_proto.has_indices()) {\n    const TensorProto& indices = sparse_tensor_proto.indices();\n    check_tensor(indices, ctx);\n    if (indices.data_type() != TensorProto::INT64) {\n      fail_check(\"Sparse tensor indices (\", indices.name(), \") must have INT64 type.\");\n    }\n    switch (indices.dims().size()) {\n      case 1:\n        \/\/ Indices in linearized format\n        check_sparse_tensor_indices_1(indices, sparse_tensor_proto, nnz);\n        return;\n      case 2:\n        \/\/ Check COO-style index. E.g., an index for a 3D tensor is a 3-tuple.\n        check_sparse_tensor_indices_2(indices, sparse_tensor_proto, nnz);\n        return;\n      default:\n        fail_check(\"Sparse tensor indices (\", indices.name(), \") must have rank 1 or 2.\");\n    }\n  } else if (nnz != 0) {\n    fail_check(\"Sparse tensor (\", values.name(), \") has no index values.\");\n  }\n}\n\n\/\/ NB: This is a generic \"attribute well-formedness\" check, it doesn't\n\/\/ actually test if an attribute is valid per a schema\nvoid check_attribute(const AttributeProto& attr, const CheckerContext& ctx, const LexicalScopeContext& lex_ctx) {\n  enforce_non_empty_field(attr, name);\n\n  if (ctx.get_ir_version() >= 0x00000002) {\n    enforce_has_field(attr, type);\n  }\n\n  int used_fields = 0;\n\n#define check_type(expected_type)                                                     \\\n  if (attr.has_type() && attr.type() != expected_type) {                              \\\n    fail_check(\"type field and data field mismatch in attribute \", attr.name(), \".\"); \\\n  }\n\n#define check_singular_field(field, type) \\\n  if (attr.has_##field()) {               \\\n    ++used_fields;                        \\\n    check_type(type);                     \\\n  }\n\n#define check_repeated_field(field, type) \\\n  if (attr.field##_size() > 0) {          \\\n    ++used_fields;                        \\\n    check_type(type);                     \\\n  }\n\n  check_singular_field(f, AttributeProto::FLOAT);\n  check_singular_field(i, AttributeProto::INT);\n  check_singular_field(s, AttributeProto::STRING);\n  check_singular_field(t, AttributeProto::TENSOR);\n  check_singular_field(g, AttributeProto::GRAPH);\n  check_singular_field(tp, AttributeProto::TYPE_PROTO);\n  check_singular_field(sparse_tensor, AttributeProto::SPARSE_TENSOR);\n  check_repeated_field(floats, AttributeProto::FLOATS);\n  check_repeated_field(ints, AttributeProto::INTS);\n  check_repeated_field(strings, AttributeProto::STRINGS);\n  check_repeated_field(tensors, AttributeProto::TENSORS);\n  check_repeated_field(graphs, AttributeProto::GRAPHS);\n  check_repeated_field(sparse_tensors, AttributeProto::SPARSE_TENSORS);\n  check_repeated_field(type_protos, AttributeProto::TYPE_PROTOS);\n\n#undef check_type\n#undef check_singular_field\n#undef check_repeated_field\n\n  \/\/ Normally, used_fields is expected to be 1.\n  \/\/ In proto3, when the value to be set is type default value (say 0 for\n  \/\/ int), used_fields may be 0.\n  if (used_fields > 1) {\n    fail_check(\"Attribute (name: \", attr.name(), \") should not contain more than one value field.\");\n  }\n\n  if (!ctx.is_main_graph()) {\n    \/\/ It's an attribute of a node in function body.\n    if (attr.has_ref_attr_name() && used_fields != 0) {\n      \/\/ The attribute proto is supposed to refer to data outside and does not\n      \/\/ have its own value field set.\n      fail_check(\"Attribute (name: \", attr.name(), \") should refer to attribute in parent node.\");\n    }\n  }\n\n  if (attr.has_t()) {\n    check_tensor(attr.t(), ctx);\n  }\n\n  if (attr.has_sparse_tensor()) {\n    check_sparse_tensor(attr.sparse_tensor(), ctx);\n  }\n\n  if (attr.has_g()) {\n    CheckerContext subgraph_ctx(ctx);\n    subgraph_ctx.set_is_main_graph(false);\n    check_graph(attr.g(), subgraph_ctx, lex_ctx);\n  }\n\n  for (const auto& tensor : attr.tensors()) {\n    check_tensor(tensor, ctx);\n  }\n  for (const auto& sparse_tensor : attr.sparse_tensors()) {\n    check_sparse_tensor(sparse_tensor, ctx);\n  }\n  if (attr.graphs().size() > 0) {\n    CheckerContext subgraph_ctx(ctx);\n    subgraph_ctx.set_is_main_graph(false);\n    for (const auto& graph : attr.graphs()) {\n      check_graph(graph, subgraph_ctx, lex_ctx);\n    }\n  }\n}\n\nvoid print_warning_if_has_experimental(const std::unordered_set<std::string>& used_experimental_ops) {\n  if (!used_experimental_ops.empty()) {\n    std::string all_experimental_ops;\n    for (const auto& op : used_experimental_ops) {\n      all_experimental_ops += \" \" + op + \",\";\n    }\n    \/\/ Remove the last comma which is unnecessary\n    all_experimental_ops.pop_back();\n    std::cout << \"Warning: Model contains experimental ops:\" + all_experimental_ops << std::endl;\n  }\n}\n\nvoid check_node(const NodeProto& node, const CheckerContext& ctx, const LexicalScopeContext& lex_ctx) {\n  enforce_non_empty_field(node, op_type);\n\n  if (node.input().empty() && node.output().empty()) {\n    fail_check(\"NodeProto (name: \", node.name(), \", type: \", node.op_type(), \") has zero input and zero output.\");\n  }\n\n  \/\/ Resolve domain for node\n  const auto& opset_imports = ctx.get_opset_imports();\n  auto dit = opset_imports.find(node.domain());\n  if (dit == opset_imports.end()) {\n    fail_check(\"No opset import for domain '\" + node.domain() + \"'\");\n  }\n  auto domain_version = dit->second;\n\n  \/\/ for ops referencing local functions, there is no schema to verify it.\n  \/\/ will add a check to verify consistency between these ops and local functions.\n  std::unordered_set<std::string> seen_attr_names{};\n  for (const auto& attr : node.attribute()) {\n    if (!seen_attr_names.insert(attr.name()).second) {\n      fail_check(\"Attribute '\", attr.name(), \"' appeared multiple times.\");\n    };\n\n    check_attribute(attr, ctx, lex_ctx);\n  }\n\n  \/\/ This issue will be caught by check_graph instead\n  if (check_is_experimental_op(node)) {\n    return;\n  }\n\n  const auto* schema = ctx.get_schema_registry()->GetSchema(node.op_type(), domain_version, node.domain());\n  if (!schema) {\n    if (node.domain() == ONNX_DOMAIN || node.domain() == AI_ONNX_ML_DOMAIN || node.domain() == \"ai.onnx\" ||\n        node.domain() == AI_ONNX_TRAINING_DOMAIN) {\n      \/\/ fail the checker if op in built-in domains has no schema\n      fail_check(\n          \"No Op registered for \" + node.op_type() + \" with domain_version of \" +\n          ONNX_NAMESPACE::to_string(domain_version));\n    } else {\n      \/\/ TODO: expose the registration of the op schemas appropriately in\n      \/\/ python, so we can load and register operators in other domains\n      \/\/\n      \/\/ before we complete the above todo, let's skip the schema check for\n      \/\/ now\n    }\n  } else if (schema->Deprecated()) {\n    fail_check(\n        \"Op registered for \" + node.op_type() + \" is deprecated in domain_version of \" +\n        ONNX_NAMESPACE::to_string(domain_version));\n  } else {\n    schema->Verify(node);\n  }\n}\n\nvoid check_graph(const GraphProto& graph, const CheckerContext& ctx, const LexicalScopeContext& parent_lex) {\n  enforce_non_empty_field(graph, name);\n\n  for (const auto& value_info : graph.input()) {\n    check_value_info(value_info, ctx);\n  }\n  for (const auto& value_info : graph.output()) {\n    check_value_info(value_info, ctx);\n  }\n\n  \/\/ Inherit values available in outer scope\n  \/\/ Note that we do not allow shadowing, so the presence of an already-defined\n  \/\/ name is always an error.\n  LexicalScopeContext lex_ctx{parent_lex};\n\n  for (const auto& value_info : graph.input()) {\n    \/\/ TODO: If shadowing isn't allowed, this should maybe use\n    \/\/ this_or_ancestor_graph_has\n    if (lex_ctx.this_graph_has(value_info.name())) {\n      fail_check(\n          \"Graph must be in single static assignment (SSA) form, however '\",\n          value_info.name(),\n          \"' has been used as graph input names multiple times.\");\n    }\n    lex_ctx.add(value_info.name());\n  }\n\n  std::unordered_set<std::reference_wrapper<const std::string>, std::hash<std::string>, std::equal_to<std::string>>\n      initializer_name_checker;\n\n  for (const auto& init : graph.initializer()) {\n    enforce_has_field(init, name);\n    const auto& name = init.name();\n    if (name.empty()) {\n      fail_check(\"Tensor initializers must have a non-empty name\");\n    }\n\n    if (!initializer_name_checker.insert(std::cref(name)).second) {\n      fail_check(name + \" initializer name is not unique\");\n    }\n\n    check_tensor(init, ctx);\n\n    if (ctx.get_ir_version() <= 0x00000003) {\n      \/\/ Initializers are a subset of graph inputs for IR_VERSION <= 3\n      if (!lex_ctx.this_graph_has(name)) {\n        fail_check(name + \" in initializer but not in graph input\");\n      }\n    } else {\n      \/\/ An initializer is allowed to have the same name as an input,\n      \/\/ but is not required to (for IR_VERSION >= 4)\n      lex_ctx.add(name);\n    }\n  }\n\n  for (const auto& sparse_init : graph.sparse_initializer()) {\n    const auto& values = sparse_init.values();\n    enforce_has_field(values, name);\n    const auto& name = values.name();\n    if (name.empty()) {\n      fail_check(\"Sparse tensor initializers must have a non-empty name\");\n    }\n    if (!initializer_name_checker.insert(std::cref(name)).second) {\n      fail_check(name + \" sparse initializer name is not unique across initializers and sparse_initializers\");\n    }\n    check_sparse_tensor(sparse_init, ctx);\n    lex_ctx.add(name);\n  }\n  std::unordered_set<std::string> used_experimental_ops;\n  for (const auto& node : graph.node()) {\n    \/\/ nodes must be in topologically sorted order\n    for (const auto& input : node.input()) {\n      \/\/ explicit optional input\n      if (input.empty()) {\n        continue;\n      }\n      if (!lex_ctx.this_or_ancestor_graph_has(input)) {\n        fail_check(\n            \"Nodes in a graph must be topologically sorted, however input '\",\n            input,\n            \"' of node: \\n\",\n            \"name: \",\n            node.name(),\n            \" OpType: \",\n            node.op_type(),\n            \"\\n is not output of any previous nodes.\");\n      }\n    }\n\n    if (check_is_experimental_op(node)) {\n      used_experimental_ops.insert(node.op_type());\n    }\n\n    \/\/ This needs to happen before SSA check since we don't want to recurse and\n    \/\/ find that outputs from control flow ops are colliding with names in the\n    \/\/ inner block\n\n    ONNX_TRY {\n      check_node(node, ctx, lex_ctx);\n    }\n    ONNX_CATCH(ValidationError & ex) {\n      ONNX_HANDLE_EXCEPTION([&]() {\n        ex.AppendContext(\"Bad node spec for node. Name: \" + node.name() + \" OpType: \" + node.op_type());\n        ONNX_THROW_EX(ex);\n      });\n    }\n    \/\/ check for SSA form\n    for (const auto& output : node.output()) {\n      \/\/ optional output\n      if (output.empty()) {\n        continue;\n      }\n\n      if (lex_ctx.this_or_ancestor_graph_has(output)) {\n        fail_check(\n            \"Graph must be in single static assignment (SSA) form, however '\",\n            output,\n            \"' has been used as output names multiple times.\");\n      }\n      lex_ctx.add(output);\n    }\n  }\n  print_warning_if_has_experimental(used_experimental_ops);\n}\n\n\/\/ Utilify function to get the imported version of domain from opset imports\n\/\/ Returns -1 if requested domain is not found in the opset_imports\nint get_version_for_domain(const std::string& domain, const std::unordered_map<std::string, int>& opset_imports) {\n  auto it = opset_imports.find(domain);\n  if (it == opset_imports.end()) {\n    return -1;\n  }\n\n  return it->second;\n}\n\nvoid check_opset_compatibility(\n    const NodeProto& node,\n    const CheckerContext& ctx,\n    const std::unordered_map<std::string, int>& func_opset_imports,\n    const std::unordered_map<std::string, int>& model_opset_imports) {\n  auto func_opset_version = get_version_for_domain(node.domain(), func_opset_imports);\n  auto model_opset_version = get_version_for_domain(node.domain(), model_opset_imports);\n\n  if (func_opset_version == -1) {\n    fail_check(\"No Opset registered for domain \" + node.domain());\n  }\n\n  if (model_opset_version == -1) {\n    \/\/ model does not include opset import for a node present in function body.\n    \/\/ This is ok as along as the opset import is present in function level opset imports.\n    return;\n  }\n\n  if (func_opset_version == model_opset_version) {\n    \/\/ both versions are same, no need to verify schema.\n    return;\n  }\n\n  const auto* schema_for_model_import =\n      ctx.get_schema_registry()->GetSchema(node.op_type(), model_opset_version, node.domain());\n\n  const auto* schema_for_function_import =\n      ctx.get_schema_registry()->GetSchema(node.op_type(), func_opset_version, node.domain());\n\n  if (!schema_for_model_import && !schema_for_function_import) {\n    \/\/ the op belongs to a custom domain so we cannot verify schema\n    return;\n  }\n\n  \/\/ if schema is present for 1 but not other or the schema since versions do not match then raise an error\n  if (!schema_for_model_import || !schema_for_function_import ||\n      schema_for_function_import->since_version() != schema_for_model_import->since_version()) {\n    fail_check(\n        \"Opset import for domain \" + node.domain() + \" in function op \" + node.op_type() +\n        \"is not compatible with the version imported by model. FunctionOp imports version \" +\n        ONNX_NAMESPACE::to_string(func_opset_version) + \" whereas model imports version \" +\n        ONNX_NAMESPACE::to_string(model_opset_version));\n  }\n}\n\nvoid check_model_local_functions(\n    const ModelProto& model,\n    const CheckerContext& ctx,\n    const LexicalScopeContext& parent_lex) {\n  \/\/ make a copy of model opset imports to maintain a main copy of opset imports across the model and\n  \/\/ all model local functions to verify opset compatibility\n  std::unordered_map<std::string, int> model_opset_imports(ctx.get_opset_imports());\n\n  \/\/ merge the opset imports from every function in model_opset_imports\n  \/\/ only add the opset import if an entry for it does not exist in model_opset_imports\n  \/\/ if there is an entry then the compatibility will be checked later on in check_opset_compatibility\n  \/\/ called by check_function.\n  for (const auto& function_proto : model.functions()) {\n    for (const auto& opset_import : function_proto.opset_import()) {\n      if (get_version_for_domain(opset_import.domain(), model_opset_imports) == -1) {\n        model_opset_imports[opset_import.domain()] = opset_import.version();\n      }\n    }\n  }\n\n  CheckerContext ctx_copy = ctx;\n  ctx_copy.set_opset_imports(model_opset_imports);\n\n  for (const auto& function_proto : model.functions()) {\n    check_function(function_proto, ctx_copy, parent_lex);\n  }\n}\n\nvoid check_function(const FunctionProto& function, const CheckerContext& ctx, const LexicalScopeContext& parent_lex) {\n  enforce_non_empty_field(function, name);\n\n  if (ctx.get_ir_version() >= 0x00000008) {\n    enforce_has_field(function, domain);\n  }\n\n  const auto& model_opset_imports = ctx.get_opset_imports();\n  CheckerContext ctx_copy = ctx;\n\n  std::unordered_map<std::string, int> func_opset_imports;\n  for (auto& relied_opset : function.opset_import()) {\n    func_opset_imports[relied_opset.domain()] = static_cast<int>(relied_opset.version());\n  }\n\n  ctx_copy.set_opset_imports(func_opset_imports);\n\n  LexicalScopeContext lex_ctx{parent_lex};\n\n  for (const auto& input : function.input()) {\n    \/\/ TODO: If shadowing isn't allowed, this should maybe use\n    \/\/ this_or_ancestor_graph_has\n    if (lex_ctx.this_graph_has(input)) {\n      fail_check(\n          \"Graph must be in single static assignment (SSA) form, however '\", input, \"' has been used multiple times.\");\n    }\n    lex_ctx.add(input);\n  }\n\n  std::unordered_set<std::string> outputs;\n  for (const auto& output : function.output()) {\n    auto result = outputs.insert(output);\n    if (!result.second) {\n      fail_check(\"function (\", function.name(), \") should not have duplicate outputs specified.\");\n    }\n  }\n\n  std::unordered_set<std::string> attrs;\n  for (const auto& attr : function.attribute()) {\n    auto result = attrs.insert(attr);\n    if (!result.second) {\n      fail_check(\"function (\", function.name(), \") should not have duplicate attributes specified.\");\n    }\n  }\n  std::unordered_set<std::string> used_experimental_ops;\n  for (const auto& node : function.node()) {\n    \/\/ nodes must be in topologically sorted order\n    for (const auto& input : node.input()) {\n      \/\/ explicit optional input\n      if (input.empty()) {\n        continue;\n      }\n      if (!lex_ctx.this_graph_has(input)) {\n        fail_check(\n            \"Nodes in a function must be topologically sorted, however input '\",\n            input,\n            \"' of node: \\n\",\n            \"Name: \",\n            node.name(),\n            \" OpType: \",\n            node.op_type(),\n            \"\\n is neither output of any previous nodes nor input of the function.\");\n      }\n    }\n\n    \/\/ check whether the opset version imported for a domain by function and model are\n    \/\/ compatible\n    if (!ctx_copy.skip_opset_compatibility_check())\n      check_opset_compatibility(node, ctx_copy, func_opset_imports, model_opset_imports);\n    if (check_is_experimental_op(node)) {\n      used_experimental_ops.insert(node.op_type());\n    }\n    check_node(node, ctx_copy, lex_ctx);\n\n    \/\/ check for SSA form\n    for (const auto& output : node.output()) {\n      \/\/ optional output\n      if (output.empty()) {\n        continue;\n      }\n      if (lex_ctx.this_or_ancestor_graph_has(output)) {\n        fail_check(\n            \"Function must be in single static assignment (SSA) form, however '\",\n            output,\n            \"' has been used as output names multiple times.\");\n      }\n      lex_ctx.add(output);\n    }\n  }\n  print_warning_if_has_experimental(used_experimental_ops);\n}\n\nvoid check_model(const ModelProto& model, CheckerContext& ctx) {\n  if (!model.ir_version()) {\n    fail_check(\"The model does not have an ir_version set properly.\");\n  }\n  if (model.ir_version() > IR_VERSION) {\n    fail_check(\"Your model ir_version \", model.ir_version(), \" is higher than the checker's (\", IR_VERSION, \").\");\n  }\n  if (model.metadata_props_size() > 1) {\n    std::unordered_set<std::string> keys;\n    for (const StringStringEntryProto& entry : model.metadata_props()) {\n      auto i = keys.insert(entry.key());\n      if (!i.second) {\n        fail_check(\"Your model has duplicate keys in metadata_props.\");\n      }\n    }\n  }\n  std::unordered_map<std::string, int> versions;\n  ctx.set_ir_version(static_cast<int>(model.ir_version()));\n  std::unordered_map<std::string, int> opset_imports;\n  for (const auto& opset_import : model.opset_import()) {\n    opset_imports[opset_import.domain()] = static_cast<int>(opset_import.version());\n  }\n  if (model.ir_version() >= 3) {\n    if (opset_imports.empty()) {\n      fail_check(\"model with IR version >= 3 must specify opset_import for ONNX\");\n    }\n  } else {\n    if (opset_imports.empty())\n      opset_imports[ONNX_DOMAIN] = 1;\n    else {\n      fail_check(\"model with IR version < 3 cannot have opset_import specified\");\n    }\n  }\n  ctx.set_opset_imports(opset_imports);\n  LexicalScopeContext lex_ctx;\n  check_graph(model.graph(), ctx, lex_ctx);\n\n  if (ctx.get_ir_version() >= 0x00000008) {\n    check_model_local_functions(model, ctx, lex_ctx);\n    \/\/ TODO: check consistency between local functions and ops referencing it.\n  }\n}\n\nvoid check_model(const std::string& model_path, bool full_check, bool skip_opset_compatibility_check) {\n  ModelProto model;\n  LoadProtoFromPath(model_path, model);\n\n  CheckerContext ctx;\n  std::string model_dir;\n  size_t pos = model_path.find_last_of(\"\\\\\/\");\n  if (pos != std::string::npos) {\n    model_dir = model_path.substr(0, pos + 1);\n  }\n  ctx.set_model_dir(model_dir);\n  ctx.set_skip_opset_compatibility_check(skip_opset_compatibility_check);\n  check_model(model, ctx);\n\n  if (full_check) {\n    ShapeInferenceOptions options{true, 1, false};\n    ONNX_NAMESPACE::shape_inference::InferShapes(model, ctx.get_schema_registry(), options);\n  }\n}\n\nvoid check_model(const ModelProto& model, bool full_check, bool skip_opset_compatibility_check) {\n  CheckerContext ctx;\n  ctx.set_skip_opset_compatibility_check(skip_opset_compatibility_check);\n  check_model(model, ctx);\n  if (full_check) {\n    ShapeInferenceOptions options{true, 1, false};\n    \/\/ Do not update the model in place by the check from shape inference\n    \/\/ because checker should not modify the original model\n    ModelProto copy = model;\n    ONNX_NAMESPACE::shape_inference::InferShapes(copy, ctx.get_schema_registry(), options);\n  }\n}\n\nstd::set<std::string> experimental_ops = {\n    \"ATen\",\n    \"Affine\",\n    \"ConstantFill\",\n    \"Crop\",\n    \"DynamicSlice\",\n    \"GRUUnit\",\n    \"GivenTensorFill\",\n    \"ImageScaler\",\n    \"ParametricSoftplus\",\n    \"Scale\",\n    \"ScaledTanh\"};\n\nbool check_is_experimental_op(const NodeProto& node) {\n  return (node.domain() == ONNX_DOMAIN || node.domain() == \"ai.onnx\") && experimental_ops.count(node.op_type());\n}\n\n#undef enforce_has_field\n#undef enforce_non_empty_field\n\n} \/\/ namespace checker","target":1,"flaw_line_index":0,"hash":"05844799-2017-415b-b87f-1400a4c774db","idx":"a5a8f07e-e043-47af-a1e4-1938ec8bafc4"}
{"func_before":"\n    bool has_location = false;\n    for (const StringStringEntryProto& entry : tensor.external_data()) {\n      if (entry.has_key() && entry.has_value() && entry.key() == \"location\") {\n        has_location = true;\n        resolve_external_data_location(ctx.get_model_dir(), entry.value(), tensor.name());\n      }\n    }\n    if (!has_location) {\n      fail_check(\"TensorProto ( tensor name: \", tensor.name(), \") is stored externally but doesn't have a location.\");\n    }\n        fail_check(\"Unrecognized data_type (tensor name: \", tensor.name(), \"): \", tensor.data_type());\n    }\n  }\n\n#undef check_field\n}","target":0,"flaw_line_index":0,"hash":"106880e0-13fa-4ebf-a4f4-e48947a50005","idx":"1e30c216-d6bc-4e63-9014-e17675d3ddbb"}
{"func_before":"\tpopulate_cache_maps (cache);\n\tif (!cache->maps) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps);\n\tcache->bins = create_cache_bins (bf, cache);\n\tif (!cache->bins) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}","target":1,"flaw_line_index":0,"hash":"3fcd1eb4-0c65-432d-9f1e-70509774f0f9","idx":"7b8fba36-9a50-46ee-8cfd-b66417ce5a02"}
{"func_before":"\tpopulate_cache_maps (cache);\n\tif (!cache->maps) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}\n\tcache->accel = read_cache_accel (cache->buf, cache->hdr, cache->maps, cache->n_maps);\n\tcache->bins = create_cache_bins (bf, cache);\n\tif (!cache->bins) {\n\t\tr_dyldcache_free (cache);\n\t\treturn false;\n\t}","target":0,"flaw_line_index":0,"hash":"4b613370-2aea-4285-8a60-4c3621bbadf3","idx":"ada0a989-35e6-4cca-bbb4-43b7ead092cd"}
{"func_before":"  DeletionConfirmationDlg(QWidget *parent, const int &size, const QString &name, bool defaultDeleteFiles): QDialog(parent) {\n    setupUi(this);\n    if (size == 1)\n      label->setText(tr(\"Are you sure you want to delete '%1' from the transfer list?\", \"Are you sure you want to delete 'ubuntu-linux-iso' from the transfer list?\").arg(name));\n    else\n      label->setText(tr(\"Are you sure you want to delete these %1 torrents from the transfer list?\", \"Are you sure you want to delete these 5 torrents from the transfer list?\").arg(QString::number(size)));\n    \/\/ Icons\n    lbl_warn->setPixmap(GuiIconProvider::instance()->getIcon(\"dialog-warning\").pixmap(lbl_warn->height()));\n    lbl_warn->setFixedWidth(lbl_warn->height());","target":1,"flaw_line_index":0,"hash":"1a689153-5249-4749-874e-a37ffb08c0b5","idx":"afbfe3bd-151b-412b-975e-567e29e15956"}
{"func_before":"  DeletionConfirmationDlg(QWidget *parent, const int &size, const QString &name, bool defaultDeleteFiles): QDialog(parent) {\n    setupUi(this);\n    if (size == 1)\n      label->setText(tr(\"Are you sure you want to delete '%1' from the transfer list?\", \"Are you sure you want to delete 'ubuntu-linux-iso' from the transfer list?\").arg(Utils::String::toHtmlEscaped(name)));\n    else\n      label->setText(tr(\"Are you sure you want to delete these %1 torrents from the transfer list?\", \"Are you sure you want to delete these 5 torrents from the transfer list?\").arg(QString::number(size)));\n    \/\/ Icons\n    lbl_warn->setPixmap(GuiIconProvider::instance()->getIcon(\"dialog-warning\").pixmap(lbl_warn->height()));\n    lbl_warn->setFixedWidth(lbl_warn->height());","target":0,"flaw_line_index":0,"hash":"17fb01a0-d07e-49c9-9bc1-3843afcffc6a","idx":"e0ff0031-d660-4e72-bead-55b7fe5a1949"}
{"func_before":"void trustedEnclaveInit(uint32_t _logLevel) {\n    CALL_ONCE\n    LOG_INFO(__FUNCTION__);\n\n    globalLogLevel_ = _logLevel;\n","target":1,"flaw_line_index":0,"hash":"54be79ff-92c7-48a7-a665-01eba283b003","idx":"8a643764-1008-4d6a-83bd-40c5d6fda4f5"}
{"func_before":"void trustedEnclaveInit(uint64_t _logLevel) {\n    CALL_ONCE\n    LOG_INFO(__FUNCTION__);\n\n    globalLogLevel_ = _logLevel;\n","target":0,"flaw_line_index":0,"hash":"8389923e-3618-4cba-a6d6-9022dc285f00","idx":"d5ae4d81-782d-467d-9530-4c76541b0254"}
{"func_before":"inline typename V::VectorType FBUnserializer<V>::unserializeList() {\n  p_ += CODE_SIZE;\n\n  \/\/ the list size is written so we can reserve it in the vector\n  \/\/ in future. Skip past it for now.\n  unserializeInt64();\n\n  typename V::VectorType ret = V::createVector();\n\n  size_t code = nextCode();\n  while (code != FB_SERIALIZE_STOP) {\n    V::vectorAppend(ret, unserializeThing());\n    code = nextCode();\n  }\n  p_ += CODE_SIZE;\n  return ret;\n}","target":1,"flaw_line_index":0,"hash":"dc88954c-a7d4-4549-af8d-70f4edde0850","idx":"51cca2e0-8d4a-4d94-a2e3-2ba5507ce1e2"}
{"func_before":"inline typename V::VectorType FBUnserializer<V>::unserializeList(size_t depth) {\n  p_ += CODE_SIZE;\n\n  \/\/ the list size is written so we can reserve it in the vector\n  \/\/ in future. Skip past it for now.\n  unserializeInt64();\n\n  typename V::VectorType ret = V::createVector();\n\n  size_t code = nextCode();\n  while (code != FB_SERIALIZE_STOP) {\n    V::vectorAppend(ret, unserializeThing(depth + 1));\n    code = nextCode();\n  }\n  p_ += CODE_SIZE;\n  return ret;\n}","target":0,"flaw_line_index":0,"hash":"33c42bf1-a611-4cc6-ac47-4b23b354670d","idx":"00bf5036-c0d4-4bce-8bd4-a551281616df"}
{"func_before":"  if (doc_root_.empty()) {\n    LOG_INFO(\"The doc root was not specified\");\n    return {};\n  }\n\n  fs::path path = doc_root_ \/ request->url().path();\n\n  try {\n    \/\/ NOTE: FileBody might throw Error::kFileError.\n    auto body = std::make_shared<FileBody>(path, file_chunk_size_);\n","target":1,"flaw_line_index":0,"hash":"5e92b885-d2cb-4147-ace2-f4d4e292d987","idx":"be370722-0751-45b7-99e6-7bc8c05917e5"}
{"func_before":"  if (doc_root_.empty()) {\n    LOG_INFO(\"The doc root was not specified\");\n    return {};\n  }\n\n  std::string url_path = Url::DecodeUnsafe(request->url().path());\n  fs::path sub_path = utility::TranslatePath(url_path);\n  fs::path path = doc_root_ \/ sub_path;\n\n  try {\n    \/\/ NOTE: FileBody might throw Error::kFileError.\n    auto body = std::make_shared<FileBody>(path, file_chunk_size_);\n","target":0,"flaw_line_index":0,"hash":"bfed81ad-3038-4ae8-a752-80a8873e9315","idx":"b38b268c-30d4-45b7-b7ce-34b054090380"}
{"func_before":"void dvb_usbv2_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *name = d->name;\n\tstruct device dev = d->udev->dev;\n\n\tdev_dbg(&d->udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\n\tif (d->props->exit)\n\t\td->props->exit(d);\n\n\tdvb_usbv2_exit(d);\n\n\tdev_info(&dev, \"%s: '%s' successfully deinitialized and disconnected\\n\",\n\t\t\tKBUILD_MODNAME, name);\n}","target":1,"flaw_line_index":0,"hash":"71993c95-f863-4c34-8e32-d550c722c010","idx":"26c79e9c-caa4-46fd-8d12-1cc12cfccff7"}
{"func_before":"void dvb_usbv2_disconnect(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *devname = kstrdup(dev_name(&d->udev->dev), GFP_KERNEL);\n\tconst char *drvname = d->name;\n\n\tdev_dbg(&d->udev->dev, \"%s: bInterfaceNumber=%d\\n\", __func__,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\n\tif (d->props->exit)\n\t\td->props->exit(d);\n\n\tdvb_usbv2_exit(d);\n\n\tpr_info(\"%s: '%s:%s' successfully deinitialized and disconnected\\n\",\n\t\tKBUILD_MODNAME, drvname, devname);\n\tkfree(devname);\n}","target":0,"flaw_line_index":0,"hash":"bd3d08e1-b48f-48ca-9363-15849852ae30","idx":"d2490277-a73b-4028-ad29-c3540641cef4"}
{"func_before":"\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\tset_acl_inode(inode, inode->i_mode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;","target":1,"flaw_line_index":0,"hash":"73c21c35-fd3a-4560-9f3e-01bdf6ba13b0","idx":"4c46cba6-25d8-4637-947a-1b69d6c9915c"}
{"func_before":"\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tset_acl_inode(inode, inode->i_mode);\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;","target":0,"flaw_line_index":0,"hash":"3b6b1b7e-d9fa-4edd-a1a7-dd5c4ae03739","idx":"7c86289c-4fc2-43d2-b5fb-d95a5b423fd8"}
{"func_before":"    inline int check(int itemSize, int nItems=1)\n    {\n      if (ptr + itemSize * nItems > end) {\n        if (ptr + itemSize > end)\n          return overrun(itemSize, nItems);\n\n        nItems = (end - ptr) \/ itemSize;\n      }\n      return nItems;\n    }","target":1,"flaw_line_index":0,"hash":"5ab3ffc8-2b8c-4d4d-a99b-75613c39596b","idx":"0cd46f3a-b5eb-478c-9deb-0890d552b145"}
{"func_before":"    inline size_t check(size_t itemSize, size_t nItems=1)\n    {\n      if (ptr + itemSize * nItems > end) {\n        if (ptr + itemSize > end)\n          return overrun(itemSize, nItems);\n\n        nItems = (end - ptr) \/ itemSize;\n      }\n      return nItems;\n    }","target":0,"flaw_line_index":0,"hash":"f14fee7a-1649-474b-af7a-551166dfb463","idx":"0c3e44bb-38e1-4d3c-a128-0d6b7599da09"}
{"func_before":"String UTF16BEDecoder::to_utf8(const StringView& input)\n{\n    StringBuilder builder(input.length() \/ 2);\n    for (size_t i = 0; i < input.length(); i += 2) {\n        u16 code_point = (input[i] << 8) | input[i + 1];\n        builder.append_code_point(code_point);\n    }\n    return builder.to_string();\n}","target":1,"flaw_line_index":0,"hash":"3b7d674c-b413-4337-b71d-e42ba38427b5","idx":"64dede4b-7bf7-44a3-8261-06ebb1448bfc"}
{"func_before":"String UTF16BEDecoder::to_utf8(const StringView& input)\n{\n    StringBuilder builder(input.length() \/ 2);\n    size_t utf16_length = input.length() - (input.length() % 2);\n    for (size_t i = 0; i < utf16_length; i += 2) {\n        u16 code_point = (input[i] << 8) | input[i + 1];\n        builder.append_code_point(code_point);\n    }\n    return builder.to_string();\n}","target":0,"flaw_line_index":0,"hash":"23ceb468-3d63-4916-a641-9672f256e559","idx":"04ef9038-1fe9-44d0-8be4-63726ea4ed45"}
{"func_before":"\n\tlen = 0;\n\ta = text;\n\te = text + strlen(text);\n\twhile (a <= e) {\n\t\tif (js_regexec(re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n\t\t\tbreak;\n\n\t\tb = m.sub[0].sp;\n\t\tc = m.sub[0].ep;\n","target":1,"flaw_line_index":0,"hash":"77a82ad7-e0fd-44c3-b6c1-b38839202bfe","idx":"e6b08ad9-ba69-4763-bf03-be9547057af4"}
{"func_before":"\n\tlen = 0;\n\ta = text;\n\te = text + strlen(text);\n\twhile (a <= e) {\n\t\tif (js_doregexec(J, re->prog, a, &m, a > text ? REG_NOTBOL : 0))\n\t\t\tbreak;\n\n\t\tb = m.sub[0].sp;\n\t\tc = m.sub[0].ep;\n","target":0,"flaw_line_index":0,"hash":"d0630f96-daca-473a-a11f-adb72b1e38b8","idx":"abe6fa3f-47ca-431c-963b-3538a11d6876"}
{"func_before":"\n\t\t\/* update expire time *\/\n\t\t(*stp)->expire = getuptime();\n\t\tif (src->state >= TCPS_FIN_WAIT_2 &&\n\t\t    dst->state >= TCPS_FIN_WAIT_2)\n\t\t\t(*stp)->timeout = PFTM_TCP_CLOSED;\n\t\telse if (src->state >= TCPS_CLOSING &&\n\t\t    dst->state >= TCPS_CLOSING)\n\t\t\t(*stp)->timeout = PFTM_TCP_FIN_WAIT;\n\t\telse if (src->state < TCPS_ESTABLISHED ||\n\t\t    dst->state < TCPS_ESTABLISHED)\n\t\t\t(*stp)->timeout = PFTM_TCP_OPENING;\n\t\telse if (src->state >= TCPS_CLOSING ||\n\t\t    dst->state >= TCPS_CLOSING)\n\t\t\t(*stp)->timeout = PFTM_TCP_CLOSING;\n\t\telse\n\t\t\t(*stp)->timeout = PFTM_TCP_ESTABLISHED;\n\n\t\t\/* Fall through to PASS packet *\/\n\t} else if ((dst->state < TCPS_SYN_SENT ||\n\t\tdst->state >= TCPS_FIN_WAIT_2 ||\n\t\tsrc->state >= TCPS_FIN_WAIT_2) &&","target":1,"flaw_line_index":0,"hash":"dade7df9-3ade-4779-829b-b254484967f4","idx":"a1034dfd-42ba-4900-b880-df4cd2911bbd"}
{"func_before":"\n\t\t\/* update expire time *\/\n\t\t(*stp)->expire = getuptime();\n\t\tif (src->state >= TCPS_FIN_WAIT_2 &&\n\t\t    dst->state >= TCPS_FIN_WAIT_2)\n\t\t\tpf_update_state_timeout(*stp, PFTM_TCP_CLOSED);\n\t\telse if (src->state >= TCPS_CLOSING &&\n\t\t    dst->state >= TCPS_CLOSING)\n\t\t\tpf_update_state_timeout(*stp, PFTM_TCP_FIN_WAIT);\n\t\telse if (src->state < TCPS_ESTABLISHED ||\n\t\t    dst->state < TCPS_ESTABLISHED)\n\t\t\tpf_update_state_timeout(*stp, PFTM_TCP_OPENING);\n\t\telse if (src->state >= TCPS_CLOSING ||\n\t\t    dst->state >= TCPS_CLOSING)\n\t\t\tpf_update_state_timeout(*stp, PFTM_TCP_CLOSING);\n\t\telse\n\t\t\tpf_update_state_timeout(*stp, PFTM_TCP_ESTABLISHED);\n\n\t\t\/* Fall through to PASS packet *\/\n\t} else if ((dst->state < TCPS_SYN_SENT ||\n\t\tdst->state >= TCPS_FIN_WAIT_2 ||\n\t\tsrc->state >= TCPS_FIN_WAIT_2) &&","target":0,"flaw_line_index":0,"hash":"a2a0b723-44ee-4510-ab1a-1788e1dd9b27","idx":"d09eff14-fcd5-4330-ac87-3f9fc9fb7fc1"}
{"func_before":"CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    CString sRet = CZNC::Get().GetZNCPath() + \"\/webskins\/\" + sSkinName;\n\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"\/webskins\/\" + sSkinName;\n\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"\/\" + sSkinName;\n        }\n    }\n\n    return sRet + \"\/\";\n}","target":1,"flaw_line_index":0,"hash":"9dea7e97-a0da-42bd-82bd-e71f4b2445ed","idx":"2f7b2b6d-9dc7-4ecb-8b24-43c02e1704bb"}
{"func_before":"CString CWebSock::GetSkinPath(const CString& sSkinName) {\n    const CString sSkin = sSkinName.Replace_n(\"\/\", \"_\").Replace_n(\".\", \"_\");\n\n    CString sRet = CZNC::Get().GetZNCPath() + \"\/webskins\/\" + sSkin;\n\n    if (!CFile::IsDir(sRet)) {\n        sRet = CZNC::Get().GetCurPath() + \"\/webskins\/\" + sSkin;\n\n        if (!CFile::IsDir(sRet)) {\n            sRet = CString(_SKINDIR_) + \"\/\" + sSkin;\n        }\n    }\n\n    return sRet + \"\/\";\n}","target":0,"flaw_line_index":0,"hash":"3c0a9c27-f407-496b-83ef-6c98614be533","idx":"19845b2a-ad6b-4124-820c-0194c6d34372"}
{"func_before":"static int16_t decodeSample(ms_adpcm_state &state,\n\tuint8_t code, const int16_t *coefficient)\n{\n\tint linearSample = (state.sample1 * coefficient[0] +\n\t\tstate.sample2 * coefficient[1]) >> 8;\n\n\tlinearSample += ((code & 0x08) ? (code - 0x10) : code) * state.delta;\n\n\tlinearSample = clamp(linearSample, MIN_INT16, MAX_INT16);\n\n\tint delta = (state.delta * adaptationTable[code]) >> 8;\n\tif (delta < 16)\n\t\tdelta = 16;\n\n\tstate.delta = delta;\n\tstate.sample2 = state.sample1;\n\tstate.sample1 = linearSample;\n\n\treturn static_cast<int16_t>(linearSample);\n}","target":1,"flaw_line_index":0,"hash":"d51de686-3f18-458c-9102-ec269df0b481","idx":"5f6932e9-b43a-411f-ad7e-db5d30ed7037"}
{"func_before":"static int16_t decodeSample(ms_adpcm_state &state,\n\tuint8_t code, const int16_t *coefficient, bool *ok=NULL)\n{\n\tint linearSample = (state.sample1 * coefficient[0] +\n\t\tstate.sample2 * coefficient[1]) >> 8;\n\tint delta;\n\n\tlinearSample += ((code & 0x08) ? (code - 0x10) : code) * state.delta;\n\n\tlinearSample = clamp(linearSample, MIN_INT16, MAX_INT16);\n\n\tif (multiplyCheckOverflow(state.delta, adaptationTable[code], &delta))\n\t{\n                if (ok) *ok=false;\n\t\t_af_error(AF_BAD_COMPRESSION, \"Error decoding sample\");\n\t\treturn 0;\n\t}\n\tdelta >>= 8;\n\tif (delta < 16)\n\t\tdelta = 16;\n\n\tstate.delta = delta;\n\tstate.sample2 = state.sample1;\n\tstate.sample1 = linearSample;\n\tif (ok) *ok=true;\n\n\treturn static_cast<int16_t>(linearSample);\n}","target":0,"flaw_line_index":0,"hash":"630b7aae-28b9-4017-b3fd-2514e1a1b4b4","idx":"1b0e397e-352f-4185-baa0-5803ce803890"}
{"func_before":"{\n    size_t i;\n\n    hashtable_do_clear(hashtable);\n\n    for(i = 0; i < num_buckets(hashtable); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n","target":1,"flaw_line_index":0,"hash":"8971797f-2d54-4472-ac90-3f319ff98e52","idx":"f11eeca8-78f8-49aa-828d-015144adb95e"}
{"func_before":"{\n    size_t i;\n\n    hashtable_do_clear(hashtable);\n\n    for(i = 0; i < hashsize(hashtable->order); i++)\n    {\n        hashtable->buckets[i].first = hashtable->buckets[i].last =\n            &hashtable->list;\n    }\n","target":0,"flaw_line_index":0,"hash":"a7e2ea0b-ea6a-4708-ab67-befb2dfba071","idx":"b168b1c9-7494-42a9-a519-0fb58348649b"}
{"func_before":"static CACHE_BRUSH_ORDER* update_read_cache_brush_order(rdpUpdate* update, wStream* s, UINT16 flags)\n{\n\tint i;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\tCACHE_BRUSH_ORDER* cache_brush = calloc(1, sizeof(CACHE_BRUSH_ORDER));\n\n\tif (!cache_brush)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_brush->index); \/* cacheEntry (1 byte) *\/\n\tStream_Read_UINT8(s, iBitmapFormat);      \/* iBitmapFormat (1 byte) *\/\n\n\tif (iBitmapFormat >= ARRAYSIZE(BMF_BPP))\n\t\tgoto fail;\n\n\tcache_brush->bpp = BMF_BPP[iBitmapFormat];\n\tStream_Read_UINT8(s, cache_brush->cx);     \/* cx (1 byte) *\/\n\tStream_Read_UINT8(s, cache_brush->cy);     \/* cy (1 byte) *\/\n\tStream_Read_UINT8(s, cache_brush->style);  \/* style (1 byte) *\/\n\tStream_Read_UINT8(s, cache_brush->length); \/* iBytes (1 byte) *\/\n","target":1,"flaw_line_index":0,"hash":"c9b93a3d-ea21-4377-bc6f-8fa5365e9044","idx":"9c2fb94a-5db6-4c2d-97a7-e0db5ba5dd6d"}
{"func_before":"static CACHE_BRUSH_ORDER* update_read_cache_brush_order(rdpUpdate* update, wStream* s, UINT16 flags)\n{\n\tint i;\n\tBOOL rc;\n\tBYTE iBitmapFormat;\n\tBOOL compressed = FALSE;\n\tCACHE_BRUSH_ORDER* cache_brush = calloc(1, sizeof(CACHE_BRUSH_ORDER));\n\n\tif (!cache_brush)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_brush->index); \/* cacheEntry (1 byte) *\/\n\tStream_Read_UINT8(s, iBitmapFormat);      \/* iBitmapFormat (1 byte) *\/\n\n\tcache_brush->bpp = get_bmf_bpp(iBitmapFormat, &rc);\n\tif (!rc)\n\t\tgoto fail;\n\n\tStream_Read_UINT8(s, cache_brush->cx);     \/* cx (1 byte) *\/\n\tStream_Read_UINT8(s, cache_brush->cy);     \/* cy (1 byte) *\/\n\tStream_Read_UINT8(s, cache_brush->style);  \/* style (1 byte) *\/\n\tStream_Read_UINT8(s, cache_brush->length); \/* iBytes (1 byte) *\/\n","target":0,"flaw_line_index":0,"hash":"328be17c-a32c-4d98-9640-dd2b8bbadb2f","idx":"f2f7b731-3f37-4f21-9a1c-9b26844b34cd"}
{"func_before":"u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (hmhd->type != GF_ISOM_BOX_TYPE_HMHD)\n\t\treturn 0;\n\t\t\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;","target":1,"flaw_line_index":0,"hash":"3f80f089-851c-4854-9a65-f7c79fd38d70","idx":"1a5f5f92-e368-4ea7-b1c7-4ee72bd843cb"}
{"func_before":"u32 GetHintFormat(GF_TrackBox *trak)\n{\n\tGF_HintMediaHeaderBox *hmhd = (GF_HintMediaHeaderBox *)trak->Media->information->InfoHeader;\n\tif (!hmhd || (hmhd->type != GF_ISOM_BOX_TYPE_HMHD))\n\t\treturn 0;\n\t\t\n\tif (!hmhd || !hmhd->subType) {\n\t\tGF_Box *a = (GF_Box *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, 0);\n\t\tif (!hmhd) return a ? a->type : 0;","target":0,"flaw_line_index":0,"hash":"e62c6ce3-c718-43fb-94e1-476f7d5887e4","idx":"17bf37be-cb40-495f-a8dc-c81d9e1cf6cc"}
{"func_before":"BGD_DECLARE(void *) gdImageJpegPtr(gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tgdImageJpegCtx(im, out, quality);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}","target":1,"flaw_line_index":0,"hash":"dbdf3012-0fa8-4a3d-8e2a-5d5edf17ff79","idx":"a09e5584-205d-41e4-8460-73baa63bf0a9"}
{"func_before":"BGD_DECLARE(void *) gdImageJpegPtr(gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) return NULL;\n\tif (!_gdImageJpegCtx(im, out, quality)) {\n\t\trv = gdDPExtractData(out, size);\n\t} else {\n\t\trv = NULL;\n\t}\n\tout->gd_free(out);\n\treturn rv;\n}","target":0,"flaw_line_index":0,"hash":"80581460-8770-4a95-9adf-b4e4ae2483f4","idx":"331f4ac7-9132-4c07-85c2-545bacc43fb8"}
{"func_before":"SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx, InitialState state,\n                     const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,\n                     Ssl::HandshakerFactoryCb handshaker_factory_cb)\n    : transport_socket_options_(transport_socket_options),\n      ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)),\n      info_(std::dynamic_pointer_cast<SslHandshakerImpl>(handshaker_factory_cb(\n          ctx_->newSsl(transport_socket_options_), ctx_->sslExtendedSocketInfoIndex(), this))) {\n  if (state == InitialState::Client) {\n    SSL_set_connect_state(rawSsl());\n  } else {\n    ASSERT(state == InitialState::Server);\n    SSL_set_accept_state(rawSsl());\n  }\n}","target":1,"flaw_line_index":0,"hash":"a60f38d2-590d-4a75-a365-1d847467c951","idx":"168a58c9-4220-447a-b28c-e91a6259e43a"}
{"func_before":"SslSocket::SslSocket(Envoy::Ssl::ContextSharedPtr ctx,\n                     const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options)\n    : transport_socket_options_(transport_socket_options),\n      ctx_(std::dynamic_pointer_cast<ContextImpl>(ctx)) {}","target":0,"flaw_line_index":0,"hash":"9c21a6b7-395b-481a-81b5-044f6eaca931","idx":"04918603-5ef4-4198-968f-4be66fc40028"}
{"func_before":"\t\/* check rm_so and rm_eo for consistency *\/\n\tif (sub.rm_so > sub.rm_eo || (sub.rm_so == -1 && sub.rm_eo != -1) ||\n\t\t\t\t(sub.rm_so != -1 && sub.rm_eo == -1) ||\n\t\t\t\t(sub.rm_so != -1 && sub.rm_so < 0) ||\n\t\t\t\t(sub.rm_eo != -1 && sub.rm_eo < 0) ) {\n\t\tsprintf(grump, \"start %ld end %ld\", (long)sub.rm_so,\n\t\t\t\t\t\t\t(long)sub.rm_eo);\n\t\treturn(grump);\n\t}\n\n\t\/* check for no match *\/\n\tif (sub.rm_so == -1)\n\t\treturn((char*) \"did not match\");\n\n\t\/* check for in range *\/\n\tif ((int) sub.rm_eo > (int) strlen(str)) {\n\t\tsprintf(grump, \"start %ld end %ld, past end of string\",\n\t\t\t\t\t(long)sub.rm_so, (long)sub.rm_eo);\n\t\treturn(grump);\n\t}\n\n\tlen = (int)(sub.rm_eo - sub.rm_so);\n\tshlen = (int)strlen(should);\n\tp = str + sub.rm_so;\n\n\t\/* check for not supposed to match *\/\n\tif (should == NULL) {\n\t\tsprintf(grump, \"matched `%.*s'\", len, p);\n\t\treturn(grump);\n\t}\n\n\t\/* check for wrong match *\/\n\tif (len != shlen || strncmp(p, should, (size_t)shlen) != 0) {\n\t\tsprintf(grump, \"matched `%.*s' instead\", len, p);\n\t\treturn(grump);\n\t}\n\tif (shlen > 0)\n\t\treturn(NULL);\n\n\t\treturn(NULL);\n\tshlen = strlen(at);\n\tif (shlen == 0)\n\t\tshlen = 1;\t\/* force check for end-of-string *\/\n\tif (strncmp(p, at, shlen) != 0) {\n\t\tsprintf(grump, \"matched null at `%.20s'\", p);\n\t\treturn(grump);\n\t}\n\treturn(NULL);\n}","target":1,"flaw_line_index":0,"hash":"88733448-a5e6-431c-9801-45d8c61a5d61","idx":"ee24d22e-9272-41c9-a119-726b98ce6f22"}
{"func_before":"\t\/* check rm_so and rm_eo for consistency *\/\n\tif (sub.rm_so > sub.rm_eo || (sub.rm_so == -1 && sub.rm_eo != -1) ||\n\t\t\t\t(sub.rm_so != -1 && sub.rm_eo == -1) ||\n\t\t\t\t(sub.rm_so != -1 && sub.rm_so < 0) ||\n\t\t\t\t(sub.rm_eo != -1 && sub.rm_eo < 0) ) {\n\t\tsnprintf(grump, sizeof(grump),\n\t\t\t \"start %ld end %ld\", (long)sub.rm_so,\n\t\t\t\t\t\t\t(long)sub.rm_eo);\n\t\treturn(grump);\n\t}\n\n\t\/* check for no match *\/\n\tif (sub.rm_so == -1)\n\t\treturn((char*) \"did not match\");\n\n\t\/* check for in range *\/\n\tif ((int) sub.rm_eo > (int) strlen(str)) {\n\t\tsnprintf(grump, sizeof(grump),\n\t\t\t \"start %ld end %ld, past end of string\",\n\t\t\t\t\t(long)sub.rm_so, (long)sub.rm_eo);\n\t\treturn(grump);\n\t}\n\n\tlen = (int)(sub.rm_eo - sub.rm_so);\n\tshlen = (int)strlen(should);\n\tp = str + sub.rm_so;\n\n\t\/* check for not supposed to match *\/\n\tif (should == NULL) {\n\t\tsnprintf(grump, sizeof(grump),\n\t\t\t \"matched `%.*s'\", len, p);\n\t\treturn(grump);\n\t}\n\n\t\/* check for wrong match *\/\n\tif (len != shlen || strncmp(p, should, (size_t)shlen) != 0) {\n\t\tsnprintf(grump, sizeof(grump),\n\t\t\t \"matched `%.*s' instead\", len, p);\n\t\treturn(grump);\n\t}\n\tif (shlen > 0)\n\t\treturn(NULL);\n\n\t\treturn(NULL);\n\tshlen = strlen(at);\n\tif (shlen == 0)\n\t\tshlen = 1;\t\/* force check for end-of-string *\/\n\tif (strncmp(p, at, shlen) != 0) {\n\t\tsnprintf(grump, sizeof(grump),\n\t\t\t \"matched null at `%.20s'\", p);\n\t\treturn(grump);\n\t}\n\treturn(NULL);\n}","target":0,"flaw_line_index":0,"hash":"14a91431-caf3-42d5-be0f-c542000f1b7d","idx":"ffe00392-e490-4791-abd8-7eb40b899b43"}
{"func_before":"  void CalculateOutputIndexValueRowID(\n      const RowPartitionTensor& value_rowids,\n      const vector<INDEX_TYPE>& parent_output_index,\n      INDEX_TYPE output_index_multiplier, INDEX_TYPE output_size,\n      vector<INDEX_TYPE>* result) {\n    const INDEX_TYPE index_size = value_rowids.size();\n    result->reserve(index_size);\n        DCHECK_LT(next_value_rowid, parent_output_index.size());\n        current_output_index = parent_output_index[next_value_rowid];\n      }\n      result->push_back(current_output_index);\n    }\n    DCHECK_EQ(result->size(), value_rowids.size());\n  }","target":1,"flaw_line_index":0,"hash":"40ce8eac-533e-4456-a7ae-52743f664da5","idx":"0dcdd0e4-8806-4456-9f8d-4eb8e0355c30"}
{"func_before":"  void CalculateOutputIndexValueRowID(\n      OpKernelContext* context, const RowPartitionTensor& value_rowids,\n      const vector<INDEX_TYPE>& parent_output_index,\n      INDEX_TYPE output_index_multiplier, INDEX_TYPE output_size,\n      vector<INDEX_TYPE>* result) {\n    const INDEX_TYPE index_size = value_rowids.size();\n    result->reserve(index_size);\n        DCHECK_LT(next_value_rowid, parent_output_index.size());\n        current_output_index = parent_output_index[next_value_rowid];\n      }\n      result->push_back(current_output_index);\n    }\n    OP_REQUIRES(context, result->size() == value_rowids.size(),\n                errors::InvalidArgument(\"Invalid row ids.\"));\n  }","target":0,"flaw_line_index":0,"hash":"804599a3-c6de-4aa6-96ee-373ab53b2ba5","idx":"b236d51f-ab91-4f73-81e2-7495a7149314"}
{"func_before":"                return error(\"DisconnectInputs() : UpdateTxIndex failed\");\n        }\n    }\n\n    \/\/ Remove transaction from index\n    if (!txdb.EraseTxIndex(*this))\n        return error(\"DisconnectInputs() : EraseTxPos failed\");\n\n    return true;\n}","target":1,"flaw_line_index":0,"hash":"5d66bdb7-9707-45e3-b887-d3d52307fe04","idx":"fdd262c3-f048-4db1-bed1-3ea02d187b78"}
{"func_before":"                return error(\"DisconnectInputs() : UpdateTxIndex failed\");\n        }\n    }\n\n    \/\/ Remove transaction from index\n    \/\/ This can fail if a duplicate of this transaction was in a chain that got\n    \/\/ reorganized away. This is only possible if this transaction was completely\n    \/\/ spent, so erasing it would be a no-op anway.\n    txdb.EraseTxIndex(*this);\n\n    return true;\n}","target":0,"flaw_line_index":0,"hash":"6c1ca866-5194-463a-8dd0-6d3941e7fb53","idx":"bb7454dc-ed69-4901-991a-271bc7d27411"}
{"func_before":"            break;\n        }\n        else {          \/\/ just copy unknown chunks to output file\n\n            int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;\n            char *buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);","target":1,"flaw_line_index":0,"hash":"8d5a8c91-8324-4b7e-aee4-e2cce2644ab7","idx":"560b8139-c22b-4d0c-a76e-efb2b1d3bcc6"}
{"func_before":"            break;\n        }\n        else {          \/\/ just copy unknown chunks to output file\n\n            int bytes_to_copy = (chunk_header.ckSize + 1) & ~1L;\n            char *buff;\n\n            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n                error_line (\"%s is not a valid .WAV file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);","target":0,"flaw_line_index":0,"hash":"9db0560a-dea8-49b7-98f9-719ed85d36d2","idx":"2d608bef-92cc-4b8f-815e-6dd642211abc"}
{"func_before":"static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tint result;\n\thandle_t *handle = NULL;\n\tstruct super_block *sb = file_inode(vma->vm_file)->i_sb;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\t\t\tEXT4_DATA_TRANS_BLOCKS(sb));\n\t}\n\n\tif (IS_ERR(handle))\n\t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_fault(vma, vmf, ext4_get_block_dax,\n\t\t\t\t\t\text4_end_io_unwritten);\n\n\tif (write) {\n\t\tif (!IS_ERR(handle))\n\t\t\text4_journal_stop(handle);\n\t\tsb_end_pagefault(sb);\n\t}\n\n\treturn result;\n}","target":1,"flaw_line_index":0,"hash":"4a253ec4-252c-4b49-8ec3-b2edb9d3c285","idx":"5dc68142-d179-438d-808d-28e0bcc3707a"}
{"func_before":"static int ext4_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tint result;\n\thandle_t *handle = NULL;\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tstruct super_block *sb = inode->i_sb;\n\tbool write = vmf->flags & FAULT_FLAG_WRITE;\n\n\tif (write) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\t\thandle = ext4_journal_start_sb(sb, EXT4_HT_WRITE_PAGE,\n\t\t\t\t\t\tEXT4_DATA_TRANS_BLOCKS(sb));\n\t} else\n\t\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\n\tif (IS_ERR(handle))\n\t\tresult = VM_FAULT_SIGBUS;\n\telse\n\t\tresult = __dax_fault(vma, vmf, ext4_get_block_dax,\n\t\t\t\t\t\text4_end_io_unwritten);\n\n\tif (write) {\n\t\tif (!IS_ERR(handle))\n\t\t\text4_journal_stop(handle);\n\t\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\t\tsb_end_pagefault(sb);\n\t} else\n\t\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\n\treturn result;\n}","target":0,"flaw_line_index":0,"hash":"ee2a2679-ddfb-42cf-9a8b-36df932b2520","idx":"652fe59b-ae89-499e-a6a5-122720e4651f"}
{"func_before":"\n    \/\/ recover all the data in the buffer minus one byte\n    ReadIndex = SizeIdx - 1;\n    memmove(&PossibleIdNSize[0], &PossibleIdNSize[1], ReadIndex);\n    UpperLevel = UpperLevel_original;\n  } while ( MaxDataSize > DataStream.getFilePointer() - SizeIdx + PossibleID_Length );\n\n  return NULL;\n}","target":1,"flaw_line_index":0,"hash":"38f7d4a7-0d5e-4b35-84f2-3e7eac616f1c","idx":"8177fc51-bde8-4a55-986e-e3e8638a69d2"}
{"func_before":"\n    \/\/ recover all the data in the buffer minus one byte\n    ReadIndex = SizeIdx - 1;\n    memmove(&PossibleIdNSize[0], &PossibleIdNSize[1], ReadIndex);\n    UpperLevel = UpperLevel_original;\n  } while ( MaxDataSize >= ReadSize );\n\n  return NULL;\n}","target":0,"flaw_line_index":0,"hash":"71c31d75-5ac6-4db1-a845-b24e0e0c2d71","idx":"3a10e4fa-38fa-42aa-a968-e38aac7a5b05"}
{"func_before":"static int http1_on_error(http1_parser_s *parser) {\n  FIO_LOG_DEBUG(\"HTTP parser error at HTTP\/1.1 buffer position %zu\/%zu\",\n                parser->state.next - parser2http(parser)->buf,\n                parser2http(parser)->buf_len);\n  fio_close(parser2http(parser)->p.uuid);\n  return -1;\n}","target":1,"flaw_line_index":0,"hash":"5a64dab0-1a15-4d2f-9e36-16e2a0f0fc90","idx":"0f825371-60d9-4ab5-988c-d95234138141"}
{"func_before":"static int http1_on_error(http1_parser_s *parser) {\n  if (parser2http(parser)->close)\n    return -1;\n  FIO_LOG_DEBUG(\"HTTP parser error.\");\n  fio_close(parser2http(parser)->p.uuid);\n  return -1;\n}","target":0,"flaw_line_index":0,"hash":"e9c1360b-6e44-4ae7-ba3a-eca3a97dcd2b","idx":"a9b56116-19ea-402d-8ac5-464d51c21a3a"}
{"func_before":"int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode)\n{\n\tint result = parse_rock_ridge_inode_internal(de, inode, 0);\n\n\t\/*\n\t * if rockridge flag was reset and we didn't look for attributes\n\t * behind eventual XA attributes, have a look there\n\t *\/\n\tif ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)\n\t    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {\n\t\tresult = parse_rock_ridge_inode_internal(de, inode, 14);\n\t}\n\treturn result;\n}","target":1,"flaw_line_index":0,"hash":"b6300d62-2bef-4490-8bc0-848bdc15cf9f","idx":"01545c7f-6ce6-4f3e-9e68-bf41750879a4"}
{"func_before":"int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode,\n\t\t\t   int relocated)\n{\n\tint flags = relocated ? RR_RELOC_DE : 0;\n\tint result = parse_rock_ridge_inode_internal(de, inode, flags);\n\n\t\/*\n\t * if rockridge flag was reset and we didn't look for attributes\n\t * behind eventual XA attributes, have a look there\n\t *\/\n\tif ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)\n\t    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {\n\t\tresult = parse_rock_ridge_inode_internal(de, inode,\n\t\t\t\t\t\t\t flags | RR_REGARD_XA);\n\t}\n\treturn result;\n}","target":0,"flaw_line_index":0,"hash":"84ebc01e-bb9c-47b6-a276-2f8e45ae179f","idx":"9c377346-a066-4a49-90c5-593cd4dfe37f"}
{"func_before":"         }\n         else if(c == ' ' || c == '\\t' || c == ',' || c == ';')\n         {\n            \/\/Discard whitespace and separator characters\n         }\n         else if(isalnum(c) || strchr(\"!#$%&'*+-.^_`|~\", c) || c >= 128)\n         {\n            \/\/Point to the first character of the parameter name\n            param->name = p + i;\n         }\n         else\n            \/\/The key\/value separator has been found\n            separatorFound = TRUE;\n            \/\/Save the length of the parameter name\n            param->nameLen = p + i - param->name;\n         }\n         else if(isalnum(c) || strchr(\"!#$%&'*+-.^_`|~\", c) || c >= 128)\n         {\n            \/\/Advance data pointer\n         }\n         else\n         {\n            \/\/Point to the first character that follows the parameter name\n            i = param->name + param->nameLen - p;\n            \/\/Successful processing\n            error = NO_ERROR;\n         }\n         else if(isalnum(c) || strchr(\"!#$%&'*+-.^_`|~\", c) || c >= 128)\n         {\n            \/\/Point to the first character that follows the parameter name\n            i = param->name + param->nameLen - p;\n            \/\/Successful processing\n            error = NO_ERROR;\n         {\n            \/\/A string of text is parsed as a single word if it is quoted\n            \/\/using double-quote marks (refer to RFC 7230, section 3.2.6)\n            param->value = p + i;\n         }\n         else if(isalnum(c) || strchr(\"!#$%&'*+-.^_`|~\", c) || c >= 128)\n         {\n            \/\/Point to the first character of the parameter value\n            param->value = p + i;\n         }\n         else\n               \/\/Save the length of the parameter value\n               param->valueLen = p + i - param->value;\n               \/\/Successful processing\n               error = NO_ERROR;\n            }\n            else if(isalnum(c) || strchr(\"!#$%&'*+-.^_`|~\", c) || c >= 128)\n            {\n               \/\/Advance data pointer\n            }\n            else\n            {","target":1,"flaw_line_index":0,"hash":"2c7d66ab-66fe-485f-b172-ceb4393bf0cd","idx":"bc50e5eb-cbfe-4f19-b3cc-737f35d0d1e5"}
{"func_before":"         }\n         else if(c == ' ' || c == '\\t' || c == ',' || c == ';')\n         {\n            \/\/Discard whitespace and separator characters\n         }\n         else if(isalnum(c) || osStrchr(\"!#$%&'*+-.^_`|~\", c) || c >= 128)\n         {\n            \/\/Point to the first character of the parameter name\n            param->name = p + i;\n         }\n         else\n            \/\/The key\/value separator has been found\n            separatorFound = TRUE;\n            \/\/Save the length of the parameter name\n            param->nameLen = p + i - param->name;\n         }\n         else if(isalnum(c) || osStrchr(\"!#$%&'*+-.^_`|~\", c) || c >= 128)\n         {\n            \/\/Advance data pointer\n         }\n         else\n         {\n            \/\/Point to the first character that follows the parameter name\n            i = param->name + param->nameLen - p;\n            \/\/Successful processing\n            error = NO_ERROR;\n         }\n         else if(isalnum(c) || osStrchr(\"!#$%&'*+-.^_`|~\", c) || c >= 128)\n         {\n            \/\/Point to the first character that follows the parameter name\n            i = param->name + param->nameLen - p;\n            \/\/Successful processing\n            error = NO_ERROR;\n         {\n            \/\/A string of text is parsed as a single word if it is quoted\n            \/\/using double-quote marks (refer to RFC 7230, section 3.2.6)\n            param->value = p + i;\n         }\n         else if(isalnum(c) || osStrchr(\"!#$%&'*+-.^_`|~\", c) || c >= 128)\n         {\n            \/\/Point to the first character of the parameter value\n            param->value = p + i;\n         }\n         else\n               \/\/Save the length of the parameter value\n               param->valueLen = p + i - param->value;\n               \/\/Successful processing\n               error = NO_ERROR;\n            }\n            else if(isalnum(c) || osStrchr(\"!#$%&'*+-.^_`|~\", c) || c >= 128)\n            {\n               \/\/Advance data pointer\n            }\n            else\n            {","target":0,"flaw_line_index":0,"hash":"f59775db-6153-4c16-b0ca-cce681c4c1e4","idx":"aff04ff7-d8ed-4e91-80bd-9fa8201b3851"}
{"func_before":"void md_map_sh512(uint8_t *hash, const uint8_t *msg, int len) {\n\tSHA512Context ctx;\n\n\tif (SHA512Reset(&ctx) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;","target":1,"flaw_line_index":0,"hash":"ba879a0e-7dc3-4323-810c-6117c9c516cc","idx":"8b543b1c-4b52-43a8-8e79-65c5b68699d7"}
{"func_before":"void md_map_sh512(uint8_t *hash, const uint8_t *msg, size_t len) {\n\tSHA512Context ctx;\n\n\tif (SHA512Reset(&ctx) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;","target":0,"flaw_line_index":0,"hash":"94d612c8-9cbd-4a24-bd44-45137663e3b4","idx":"4f18dc24-0540-4ba9-bd97-eeac90f49150"}
{"func_before":"void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val = data;\n\n    if (addr > (vdev->config_len - sizeof(val)))\n        return;\n\n    stb_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);","target":1,"flaw_line_index":0,"hash":"766f7ccf-5a4b-44e2-ab6c-2c1be395577b","idx":"3a68f6c8-f1b1-4b77-8483-d6aed91de497"}
{"func_before":"void virtio_config_writeb(VirtIODevice *vdev, uint32_t addr, uint32_t data)\n{\n    VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev);\n    uint8_t val = data;\n\n    if (addr + sizeof(val) > vdev->config_len) {\n        return;\n    }\n\n    stb_p(vdev->config + addr, val);\n\n    if (k->set_config) {\n        k->set_config(vdev, vdev->config);","target":0,"flaw_line_index":0,"hash":"321d5c98-bebe-4ea8-9e37-0a7577311d78","idx":"2de419a9-2bdc-42b2-bb2a-3fe0e2568d4d"}
{"func_before":"                return (NULL);\n            }\n        }\n        *identical = 0;\n    }\n    map = (Uint8 *) SDL_malloc(src->ncolors);\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < src->ncolors; ++i) {","target":1,"flaw_line_index":0,"hash":"8f39676f-d879-40fc-a0bd-c5ffa0fbac09","idx":"d772a1a4-81e6-4e78-b5d0-90e6ca3b6958"}
{"func_before":"                return (NULL);\n            }\n        }\n        *identical = 0;\n    }\n    map = (Uint8 *) SDL_calloc(256, sizeof(Uint8));\n    if (map == NULL) {\n        SDL_OutOfMemory();\n        return (NULL);\n    }\n    for (i = 0; i < src->ncolors; ++i) {","target":0,"flaw_line_index":0,"hash":"c512ec98-e184-4607-ad85-f0bec723a569","idx":"fd3778a3-0d82-4ff9-8113-65abdb9020f0"}
{"func_before":"      continue;\n\n    chapter_outstarts[c] = num_outpages;\n\n    for (i = chapter_starts[c], j = 0, nup = -1, page = pages + i;\n         i <= chapter_ends[c];\n\t i ++, page ++)\n    {\n      if (nup != page->nup)\n      {\n        if (j)","target":1,"flaw_line_index":0,"hash":"a8233095-d036-4f7f-b8da-9a0dd3d9408e","idx":"3cb68054-048c-44d7-948b-3ad355b5770a"}
{"func_before":"      continue;\n\n    chapter_outstarts[c] = num_outpages;\n\n    for (i = chapter_starts[c], j = 0, nup = -1, page = pages + i;\n         i <= chapter_ends[c] && num_outpages < num_pages;\n\t i ++, page ++)\n    {\n      if (nup != page->nup)\n      {\n        if (j)","target":0,"flaw_line_index":0,"hash":"8ca1879f-9ea3-44bc-afdd-9e7fd7c467e9","idx":"3f8e3bd9-ee68-420b-b993-01af6a34be3b"}
{"func_before":"    {\n\tcout << \"Testing Huffman encoder\" << endl;\n\n\tIMATH_NAMESPACE::Rand48 rand48 (0);\n\n\tconst int N = 1000000;\n\tArray <unsigned short> raw (N);\n\n\tfill1 (raw, N, 1, rand48);\t  \/\/ test various symbol distributions\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill1 (raw, N, 10, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill1 (raw, N, 100, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill1 (raw, N, 1000, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tfill2 (raw, N, 1, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill2 (raw, N, 10, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill2 (raw, N, 100, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill2 (raw, N, 1000, rand48);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tfill3 (raw, N, 0);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill3 (raw, N, 1);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill3 (raw, N, USHRT_MAX - 1);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\tfill3 (raw, N, USHRT_MAX);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tfill4 (raw, USHRT_MAX + 1);\n        compressVerify(raw, USHRT_MAX + 1, HUF_COMPRESS_DEK_HASH_FOR_FILL4_USHRT_MAX_PLUS_ONE);\n\tcompressUncompress (raw, USHRT_MAX + 1);\n\tcompressUncompressSubset (raw, USHRT_MAX + 1);\n\tfill4 (raw, N);\n        compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL4_N);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tfill4 (raw, 0);\n\tcompressUncompress (raw, 0);\t\/\/ test small input data sets\n\tfill4 (raw, 1);\n\tcompressUncompress (raw, 1);\n\tfill4 (raw, 2);\n\tcompressUncompress (raw, 2);\n\tfill4 (raw, 3);\n\tcompressUncompress (raw, 3);\n\n\tfill5 (raw, N);\t\t\t\/\/ test run-length coding of code table\n        compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL5_N);\n\tcompressUncompress (raw, N);\n\tcompressUncompressSubset (raw, N);\n\n\tcout << \"ok\\n\" << endl;\n    }\n    catch (const std::exception &e)\n    {","target":1,"flaw_line_index":0,"hash":"707974d0-63d4-48fe-ae52-70db1e29b8fb","idx":"27f88515-a587-470d-b861-755e2a1bd2e3"}
{"func_before":"    {\n\tcout << \"Testing Huffman encoder\" << endl;\n\n\tIMATH_NAMESPACE::Rand48 rand48 (0);\n\n        \/\/\n        \/\/ FastHufDecoder is used for more than 128 bits, so first test with fewer than 128 bits,\n        \/\/ then test FastHufDecoder\n        \/\/\n        for (int pass = 0 ; pass < 2 ; ++pass)\n        {\n\n            int N = pass==0 ? 12 : 1000000;\n            Array <unsigned short> raw (N);\n\n            fill1 (raw, N, 1, rand48);\t  \/\/ test various symbol distributions\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill1 (raw, N, 10, rand48);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill1 (raw, N, 100, rand48);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill1 (raw, N, 1000, rand48);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n\n            fill2 (raw, N, 1, rand48);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill2 (raw, N, 10, rand48);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill2 (raw, N, 100, rand48);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill2 (raw, N, 1000, rand48);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n\n            fill3 (raw, N, 0);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill3 (raw, N, 1);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill3 (raw, N, USHRT_MAX - 1);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n            fill3 (raw, N, USHRT_MAX);\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n\n            if (pass==1)\n            {\n                fill4 (raw, USHRT_MAX + 1);\n                compressVerify(raw, USHRT_MAX + 1, HUF_COMPRESS_DEK_HASH_FOR_FILL4_USHRT_MAX_PLUS_ONE);\n\n                compressUncompress (raw, USHRT_MAX + 1);\n                compressUncompressSubset (raw, USHRT_MAX + 1);\n                fill4 (raw, N);\n                compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL4_N);\n            }\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n\n            fill4 (raw, 0);\n            compressUncompress (raw, 0);\t\/\/ test small input data sets\n            fill4 (raw, 1);\n            compressUncompress (raw, 1);\n            fill4 (raw, 2);\n            compressUncompress (raw, 2);\n            fill4 (raw, 3);\n            compressUncompress (raw, 3);\n\n            fill5 (raw, N);\t\t\t\/\/ test run-length coding of code table\n            if (pass==1)\n            {\n                compressVerify(raw, N, HUF_COMPRESS_DEK_HASH_FOR_FILL5_N);\n            }\n            compressUncompress (raw, N);\n            compressUncompressSubset (raw, N);\n\n        }\n\n\tcout << \"ok\\n\" << endl;\n    }\n    catch (const std::exception &e)\n    {","target":0,"flaw_line_index":0,"hash":"6d7b666c-73a8-4e9d-b569-01b2ff074497","idx":"d8690c2a-ecf8-4105-b9ef-516102c2af5d"}
{"func_before":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteUnpackParams* data =\n      reinterpret_cast<TfLiteUnpackParams*>(node->builtin_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  switch (input->type) {\n    case kTfLiteFloat32: {\n      UnpackImpl<float>(context, node, input, data->num, data->axis);\n      break;\n    }","target":1,"flaw_line_index":0,"hash":"9ec50119-806d-477b-a6d6-efa28f945862","idx":"98f4d101-4b0b-42ef-9e6b-61d6947562ac"}
{"func_before":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteUnpackParams* data =\n      reinterpret_cast<TfLiteUnpackParams*>(node->builtin_data);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  switch (input->type) {\n    case kTfLiteFloat32: {\n      UnpackImpl<float>(context, node, input, data->num, data->axis);\n      break;\n    }","target":0,"flaw_line_index":0,"hash":"ff933249-19b6-4a25-95f8-fa28a98d096f","idx":"06c9e61d-14b6-4a27-b8d7-159ed42b6294"}
{"func_before":"                assert(TYPE(ch) == tfpdef || TYPE(ch) == vfpdef);\n                kwarg = ast_for_arg(c, ch);\n                if (!kwarg)\n                    return NULL;\n                i += 2; \/* the double star and the name *\/\n                if (TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \/* the comma, if present *\/\n                break;\n            case TYPE_COMMENT:\n                assert(i);\n","target":1,"flaw_line_index":0,"hash":"ce00d104-fc73-4c64-8774-09e216d75caa","idx":"bca44b99-46b2-426a-a9de-dc3fbad9db60"}
{"func_before":"                assert(TYPE(ch) == tfpdef || TYPE(ch) == vfpdef);\n                kwarg = ast_for_arg(c, ch);\n                if (!kwarg)\n                    return NULL;\n                i += 2; \/* the double star and the name *\/\n                if (i < NCH(n) && TYPE(CHILD(n, i)) == COMMA)\n                    i += 1; \/* the comma, if present *\/\n                break;\n            case TYPE_COMMENT:\n                assert(i);\n","target":0,"flaw_line_index":0,"hash":"d2868e18-816d-469f-b52c-8af5f4dc0758","idx":"768a3f2d-32d0-4ba8-b87c-8c1c0d5af16c"}
{"func_before":"static enum try_read_result try_read_network(conn *c) {\n    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;\n    int res;\n\n    assert(c != NULL);\n\n    if (c->rcurr != c->rbuf) {\n        if (c->rbytes != 0) \/* otherwise there's nothing to copy *\/\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n        c->rcurr = c->rbuf;\n    }\n\n    while (1) {\n        if (c->rbytes >= c->rsize) {\n            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);\n            if (!new_rbuf) {\n                if (settings.verbose > 0)\n                    fprintf(stderr, \"Couldn't realloc input buffer\\n\");\n                c->rbytes = 0; \/* ignore what we read *\/","target":1,"flaw_line_index":0,"hash":"963e2740-291d-4aef-8831-17edfe444a00","idx":"0106b41c-78b8-44cc-ba3c-2fb83f09f258"}
{"func_before":"static enum try_read_result try_read_network(conn *c) {\n    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;\n    int res;\n    int num_allocs = 0;\n    assert(c != NULL);\n\n    if (c->rcurr != c->rbuf) {\n        if (c->rbytes != 0) \/* otherwise there's nothing to copy *\/\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n        c->rcurr = c->rbuf;\n    }\n\n    while (1) {\n        if (c->rbytes >= c->rsize) {\n            if (num_allocs == 4) {\n                return gotdata;\n            }\n            ++num_allocs;\n            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);\n            if (!new_rbuf) {\n                if (settings.verbose > 0)\n                    fprintf(stderr, \"Couldn't realloc input buffer\\n\");\n                c->rbytes = 0; \/* ignore what we read *\/","target":0,"flaw_line_index":0,"hash":"952a60c0-0cc7-433c-8020-927edff80512","idx":"35118162-90b6-4fdc-93ac-1444292ed4fb"}
{"func_before":"QPDFObjectHandle::parseInternal(PointerHolder<InputSource> input,\n                                std::string const& object_description,\n                                QPDFTokenizer& tokenizer, bool& empty,\n                                StringDecrypter* decrypter, QPDF* context,\n                                bool in_array, bool in_dictionary,\n                                bool content_stream)\n{\n    \/\/ This method must take care not to resolve any objects. Don't\n    \/\/ check the type of any object without first ensuring that it is\n    \/\/ a direct object. Otherwise, doing so may have the side effect\n    \/\/ of reading the object and changing the file pointer.\n\n    empty = false;\n    if (in_dictionary && in_array)\n    {\n\t\/\/ Although dictionaries and arrays arbitrarily nest, these\n\t\/\/ variables indicate what is at the top of the stack right\n\t\/\/ now, so they can, by definition, never both be true.\n\tthrow std::logic_error(\n\t    \"INTERNAL ERROR: parseInternal: in_dict && in_array\");\n    }\n\n    QPDFObjectHandle object;\n\n    qpdf_offset_t offset = input->tell();\n    std::vector<QPDFObjectHandle> olist;\n    bool done = false;\n    while (! done)\n    {\n\tobject = QPDFObjectHandle();\n\n\tQPDFTokenizer::Token token =\n            tokenizer.readToken(input, object_description);\n\n\tswitch (token.getType())\n\t{\n          case QPDFTokenizer::tt_eof:\n            if (content_stream)\n            {\n                \/\/ Return uninitialized object to indicate EOF\n                return object;\n            }\n            else\n            {\n                \/\/ When not in content stream mode, EOF is tt_bad and\n                \/\/ throws an exception before we get here.\n                         \"treating unexpected brace token as null\"));\n            object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_close:\n\t    if (in_array)\n\t    {\n\t\tdone = true;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad array close\");\n                warn(context,\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_dict_close:\n\t    if (in_dictionary)\n\t    {\n\t\tdone = true;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad dictionary close\");\n                warn(context,\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_open:\n\t    object = parseInternal(\n\t\tinput, object_description, tokenizer, empty,\n                decrypter, context, true, false, content_stream);\n\t    break;\n\n\t  case QPDFTokenizer::tt_dict_open:\n\t    object = parseInternal(\n\t\tinput, object_description, tokenizer, empty,\n                decrypter, context, false, true, content_stream);\n\t    break;\n\n\t  case QPDFTokenizer::tt_bool:\n\t    object = newBool((token.getValue() == \"true\"));\n\t    break;\n\t\tstd::string const& value = token.getValue();\n                if (content_stream)\n                {\n                    object = QPDFObjectHandle::newOperator(value);\n                }\n\t\telse if ((value == \"R\") && (in_array || in_dictionary) &&\n\t\t    (olist.size() >= 2) &&\n                    (! olist.at(olist.size() - 1).isIndirect()) &&\n\t\t    (olist.at(olist.size() - 1).isInteger()) &&\n                    (! olist.at(olist.size() - 2).isIndirect()) &&\n\t\t    (olist.at(olist.size() - 2).isInteger()))\n\t\t{\n                    if (context == 0)\n                    {\n                        QTC::TC(\"qpdf\", \"QPDFObjectHandle indirect without context\");\n                        throw std::logic_error(\n\t\t\tolist.at(olist.size() - 2).getIntValue(),\n\t\t\tolist.at(olist.size() - 1).getIntValue());\n\t\t    olist.pop_back();\n\t\t    olist.pop_back();\n\t\t}\n\t\telse if ((value == \"endobj\") &&\n\t\t\t (! (in_array || in_dictionary)))\n\t\t{\n\t\t    \/\/ We just saw endobj without having read\n\t\t    \/\/ anything.  Treat this as a null and do not move\n\t\t    \/\/ the input source's offset.\n\t\t    object = newNull();\n                         \"reading object\"));\n            object = newNull();\n\t    break;\n\t}\n\n\tif (in_dictionary || in_array)\n\t{\n\t    if (! done)\n\t    {\n\t\tolist.push_back(object);\n\t    }\n\t}\n\telse if (! object.isInitialized())\n\t{\n            warn(context,\n                 QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                         object_description,\n                         input->getLastOffset(),\n                         \"parse error while reading object\"));\n            object = newNull();\n\t}\n\telse\n\t{\n\t    done = true;\n\t}\n    }\n\n    if (in_array)\n    {\n\tobject = newArray(olist);\n    }\n    else if (in_dictionary)\n    {\n        \/\/ Convert list to map. Alternating elements are keys. Attempt\n        \/\/ to recover more or less gracefully from invalid\n        \/\/ dictionaries.\n        std::set<std::string> names;\n        for (std::vector<QPDFObjectHandle>::iterator iter = olist.begin();\n             iter != olist.end(); ++iter)\n        {\n            if ((! (*iter).isIndirect()) && (*iter).isName())\n            {\n                names.insert((*iter).getName());\n            }\n        }\n\n        std::map<std::string, QPDFObjectHandle> dict;\n        int next_fake_key = 1;\n        for (unsigned int i = 0; i < olist.size(); ++i)\n        {\n            QPDFObjectHandle key_obj = olist.at(i);\n            QPDFObjectHandle val;\n            if (key_obj.isIndirect() || (! key_obj.isName()))\n            {\n                bool found_fake = false;\n                std::string candidate;\n                while (! found_fake)\n                {\n                    candidate =\n                        \"\/QPDFFake\" + QUtil::int_to_string(next_fake_key++);\n                    found_fake = (names.count(candidate) == 0);\n                    QTC::TC(\"qpdf\", \"QPDFObjectHandle found fake\",\n                            (found_fake ? 0 : 1));\n                }\n                warn(context,\n                     QPDFExc(\n                         qpdf_e_damaged_pdf,\n                         input->getName(), object_description, offset,\n                         \"expected dictionary key but found\"\n                         \" non-name object; inserting key \" +\n                         candidate));\n                val = key_obj;\n                key_obj = newName(candidate);\n            }\n            else if (i + 1 >= olist.size())\n            {\n                QTC::TC(\"qpdf\", \"QPDFObjectHandle no val for last key\");\n                warn(context,\n                     QPDFExc(\n                         qpdf_e_damaged_pdf,\n                         input->getName(), object_description, offset,\n                         \"dictionary ended prematurely; using null as value\"\n                         \" for last key\"));\n                val = newNull();\n            }\n            else\n            {\n                val = olist.at(++i);\n            }\n            dict[key_obj.getName()] = val;\n        }\n        object = newDictionary(dict);\n    }\n\n    return object;\n}","target":1,"flaw_line_index":0,"hash":"8012cec5-425f-4d2a-9ed7-5efad28114ff","idx":"4c709c3f-c8ee-48f9-8972-ebb989aa5a04"}
{"func_before":"QPDFObjectHandle::parseInternal(PointerHolder<InputSource> input,\n                                std::string const& object_description,\n                                QPDFTokenizer& tokenizer, bool& empty,\n                                StringDecrypter* decrypter, QPDF* context,\n                                bool content_stream)\n{\n    \/\/ This method must take care not to resolve any objects. Don't\n    \/\/ check the type of any object without first ensuring that it is\n    \/\/ a direct object. Otherwise, doing so may have the side effect\n    \/\/ of reading the object and changing the file pointer.\n\n    empty = false;\n\n    QPDFObjectHandle object;\n\n    std::vector<std::vector<QPDFObjectHandle> > olist_stack;\n    olist_stack.push_back(std::vector<QPDFObjectHandle>());\n    enum state_e { st_top, st_start, st_stop, st_eof, st_dictionary, st_array };\n    std::vector<state_e> state_stack;\n    state_stack.push_back(st_top);\n    std::vector<qpdf_offset_t> offset_stack;\n    offset_stack.push_back(input->tell());\n    bool done = false;\n    while (! done)\n    {\n        std::vector<QPDFObjectHandle>& olist = olist_stack.back();\n        state_e state = state_stack.back();\n        qpdf_offset_t offset = offset_stack.back();\n\n\tobject = QPDFObjectHandle();\n\n\tQPDFTokenizer::Token token =\n            tokenizer.readToken(input, object_description);\n\n\tswitch (token.getType())\n\t{\n          case QPDFTokenizer::tt_eof:\n            if (content_stream)\n            {\n                state = st_eof;\n            }\n            else\n            {\n                \/\/ When not in content stream mode, EOF is tt_bad and\n                \/\/ throws an exception before we get here.\n                         \"treating unexpected brace token as null\"));\n            object = newNull();\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_close:\n\t    if (state == st_array)\n\t    {\n                state = st_stop;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad array close\");\n                warn(context,\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_dict_close:\n\t    if (state == st_dictionary)\n\t    {\n                state = st_stop;\n\t    }\n\t    else\n\t    {\n\t\tQTC::TC(\"qpdf\", \"QPDFObjectHandle bad dictionary close\");\n                warn(context,\n                             \"unexpected dictionary close token\"));\n                object = newNull();\n\t    }\n\t    break;\n\n\t  case QPDFTokenizer::tt_array_open:\n\t  case QPDFTokenizer::tt_dict_open:\n            olist_stack.push_back(std::vector<QPDFObjectHandle>());\n            state = st_start;\n            offset_stack.push_back(input->tell());\n            state_stack.push_back(\n                (token.getType() == QPDFTokenizer::tt_array_open) ?\n                st_array : st_dictionary);\n\t    break;\n\n\t  case QPDFTokenizer::tt_bool:\n\t    object = newBool((token.getValue() == \"true\"));\n\t    break;\n\t\tstd::string const& value = token.getValue();\n                if (content_stream)\n                {\n                    object = QPDFObjectHandle::newOperator(value);\n                }\n\t\telse if ((value == \"R\") && (state != st_top) &&\n                         (olist.size() >= 2) &&\n                         (! olist.at(olist.size() - 1).isIndirect()) &&\n                         (olist.at(olist.size() - 1).isInteger()) &&\n                         (! olist.at(olist.size() - 2).isIndirect()) &&\n                         (olist.at(olist.size() - 2).isInteger()))\n\t\t{\n                    if (context == 0)\n                    {\n                        QTC::TC(\"qpdf\", \"QPDFObjectHandle indirect without context\");\n                        throw std::logic_error(\n\t\t\tolist.at(olist.size() - 2).getIntValue(),\n\t\t\tolist.at(olist.size() - 1).getIntValue());\n\t\t    olist.pop_back();\n\t\t    olist.pop_back();\n\t\t}\n\t\telse if ((value == \"endobj\") && (state == st_top))\n\t\t{\n\t\t    \/\/ We just saw endobj without having read\n\t\t    \/\/ anything.  Treat this as a null and do not move\n\t\t    \/\/ the input source's offset.\n\t\t    object = newNull();\n                         \"reading object\"));\n            object = newNull();\n\t    break;\n\t}\n\n        if ((! object.isInitialized()) &&\n            (! ((state == st_start) ||\n                (state == st_stop) ||\n                (state == st_eof))))\n        {\n            throw std::logic_error(\n                \"QPDFObjectHandle::parseInternal: \"\n                \"unexpected uninitialized object\");\n            object = newNull();\n        }\n\n        switch (state)\n        {\n          case st_eof:\n            if (state_stack.size() > 1)\n            {\n                warn(context,\n                     QPDFExc(qpdf_e_damaged_pdf, input->getName(),\n                             object_description,\n                             input->getLastOffset(),\n                             \"parse error while reading object\"));\n            }\n            done = true;\n            \/\/ Leave object uninitialized to indicate EOF\n            break;\n\n          case st_dictionary:\n          case st_array:\n            olist.push_back(object);\n            break;\n\n          case st_top:\n            done = true;\n            break;\n\n          case st_start:\n            break;\n\n          case st_stop:\n            if ((state_stack.size() < 2) || (olist_stack.size() < 2))\n            {\n                throw std::logic_error(\n                    \"QPDFObjectHandle::parseInternal: st_stop encountered\"\n                    \" with insufficient elements in stack\");\n            }\n            state_e old_state = state_stack.back();\n            state_stack.pop_back();\n            if (old_state == st_array)\n            {\n                object = newArray(olist);\n            }\n            else if (old_state == st_dictionary)\n            {\n                \/\/ Convert list to map. Alternating elements are keys.\n                \/\/ Attempt to recover more or less gracefully from\n                \/\/ invalid dictionaries.\n                std::set<std::string> names;\n                for (std::vector<QPDFObjectHandle>::iterator iter =\n                         olist.begin();\n                     iter != olist.end(); ++iter)\n                {\n                    if ((! (*iter).isIndirect()) && (*iter).isName())\n                    {\n                        names.insert((*iter).getName());\n                    }\n                }\n\n                std::map<std::string, QPDFObjectHandle> dict;\n                int next_fake_key = 1;\n                for (unsigned int i = 0; i < olist.size(); ++i)\n                {\n                    QPDFObjectHandle key_obj = olist.at(i);\n                    QPDFObjectHandle val;\n                    if (key_obj.isIndirect() || (! key_obj.isName()))\n                    {\n                        bool found_fake = false;\n                        std::string candidate;\n                        while (! found_fake)\n                        {\n                            candidate =\n                                \"\/QPDFFake\" +\n                                QUtil::int_to_string(next_fake_key++);\n                            found_fake = (names.count(candidate) == 0);\n                            QTC::TC(\"qpdf\", \"QPDFObjectHandle found fake\",\n                                    (found_fake ? 0 : 1));\n                        }\n                        warn(context,\n                             QPDFExc(\n                                 qpdf_e_damaged_pdf,\n                                 input->getName(), object_description, offset,\n                                 \"expected dictionary key but found\"\n                                 \" non-name object; inserting key \" +\n                                 candidate));\n                        val = key_obj;\n                        key_obj = newName(candidate);\n                    }\n                    else if (i + 1 >= olist.size())\n                    {\n                        QTC::TC(\"qpdf\", \"QPDFObjectHandle no val for last key\");\n                        warn(context,\n                             QPDFExc(\n                                 qpdf_e_damaged_pdf,\n                                 input->getName(), object_description, offset,\n                                 \"dictionary ended prematurely; \"\n                                 \"using null as value for last key\"));\n                        val = newNull();\n                    }\n                    else\n                    {\n                        val = olist.at(++i);\n                    }\n                    dict[key_obj.getName()] = val;\n                }\n                object = newDictionary(dict);\n            }\n            olist_stack.pop_back();\n            offset_stack.pop_back();\n            if (state_stack.back() == st_top)\n            {\n                done = true;\n            }\n            else\n            {\n                olist_stack.back().push_back(object);\n            }\n        }\n    }\n\n    return object;\n}","target":0,"flaw_line_index":0,"hash":"914f56a1-e551-4b63-a519-94fd47553abd","idx":"6992c3d9-87c5-49f0-8f98-88e883e39f7c"}
{"func_before":"\t\t}\n\t}\n#endif\n\n\twhile (count > 0) {\n\t\tunsigned long remaining;\n\n\t\tsz = size_inside_page(p, count);\n\n\t\tif (!range_is_allowed(p >> PAGE_SHIFT, count))\n\t\t\treturn -EPERM;\n\n\t\t\/*\n\t\t * On ia64 if a page has been mapped somewhere as uncached, then\n\t\t * it must also be accessed uncached by the kernel or data\n\t\t * corruption may occur.\n\t\t *\/\n\t\tptr = xlate_dev_mem_ptr(p);\n\t\tif (!ptr)\n\t\t\treturn -EFAULT;\n\n\t\tremaining = copy_to_user(buf, ptr, sz);\n\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\tif (remaining)\n\t\t\treturn -EFAULT;\n\n\t\tbuf += sz;\n\t\tp += sz;","target":1,"flaw_line_index":0,"hash":"707bce6e-e3a2-4513-b342-7fd341440458","idx":"636a039e-c77b-42d1-b354-99d953bd2c64"}
{"func_before":"\t}\n#endif\n\n\twhile (count > 0) {\n\t\tunsigned long remaining;\n\t\tint allowed;\n\n\t\tsz = size_inside_page(p, count);\n\n\t\tallowed = page_is_allowed(p >> PAGE_SHIFT);\n\t\tif (!allowed)\n\t\t\treturn -EPERM;\n\t\tif (allowed == 2) {\n\t\t\t\/* Show zeros for restricted memory. *\/\n\t\t\tremaining = clear_user(buf, sz);\n\t\t} else {\n\t\t\t\/*\n\t\t\t * On ia64 if a page has been mapped somewhere as\n\t\t\t * uncached, then it must also be accessed uncached\n\t\t\t * by the kernel or data corruption may occur.\n\t\t\t *\/\n\t\t\tptr = xlate_dev_mem_ptr(p);\n\t\t\tif (!ptr)\n\t\t\t\treturn -EFAULT;\n\n\t\t\tremaining = copy_to_user(buf, ptr, sz);\n\n\t\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\t}\n\n\t\tif (remaining)\n\t\t\treturn -EFAULT;\n\n\t\tbuf += sz;\n\t\tp += sz;","target":0,"flaw_line_index":0,"hash":"69b5ba46-d8e9-4013-90f0-fc78312d20bf","idx":"5b1814a7-6ad6-47c6-8ae9-fe7a8e7157c8"}
{"func_before":"cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tassert((size_t)CDF_SHORT_SEC_SIZE(h) == len);\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + CDF_SHORT_SEC_POS(h, id), len);\n\treturn len;\n}","target":1,"flaw_line_index":0,"hash":"9caf077a-2bda-41b8-85b4-08276c8fd0d9","idx":"0c855b67-0964-40e9-8826-3fdbefc34ad3"}
{"func_before":"cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n    size_t len, const cdf_header_t *h, cdf_secid_t id)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h);\n\tsize_t pos = CDF_SHORT_SEC_POS(h, id);\n\tassert(ss == len);\n\tif (sst->sst_len < (size_t)id) {\n\t\tDPRINTF((\"bad sector id %d > %d\\n\", id, sst->sst_len));\n\t\treturn -1;\n\t}\n\t(void)memcpy(((char *)buf) + offs,\n\t    ((const char *)sst->sst_tab) + pos, len);\n\treturn len;\n}","target":0,"flaw_line_index":0,"hash":"db22a0e8-0ca3-4d08-b039-4f548ba27715","idx":"3ff6bb84-9a64-443a-a937-e555ab3a03c3"}
{"func_before":"        serverLog(LL_WARNING, \"Killed by PID: %ld, UID: %d\", (long) info->si_pid, info->si_uid);\n    }\n\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n    void *eip = getMcontextEip(uc);\n    if (eip != NULL) {\n        serverLog(LL_WARNING,\n        \"Crashed running the instruction at: %p\", eip);\n    }\n\n    logStackTrace(getMcontextEip(uc), 1);\n\n    logRegisters(uc);\n#endif\n\n    printCrashReport();","target":1,"flaw_line_index":0,"hash":"90b7ab52-3794-4d7d-9377-af485206c076","idx":"232f1a79-2ef0-46ef-9a1f-bb956fc301f8"}
{"func_before":"        serverLog(LL_WARNING, \"Killed by PID: %ld, UID: %d\", (long) info->si_pid, info->si_uid);\n    }\n\n#ifdef HAVE_BACKTRACE\n    ucontext_t *uc = (ucontext_t*) secret;\n    void *eip = getAndSetMcontextEip(uc, NULL);\n    if (eip != NULL) {\n        serverLog(LL_WARNING,\n        \"Crashed running the instruction at: %p\", eip);\n    }\n\n    if (eip == info->si_addr) {\n        \/* When eip matches the bad address, it's an indication that we crashed when calling a non-mapped\n         * function pointer. In that case the call to backtrace will crash trying to access that address and we\n         * won't get a crash report logged. Set it to a valid point to avoid that crash. *\/\n\n        \/* This trick allow to avoid compiler warning *\/\n        void *ptr;\n        invalidFunctionWasCalledType *ptr_ptr = (invalidFunctionWasCalledType*)&ptr;\n        *ptr_ptr = invalidFunctionWasCalled;\n        getAndSetMcontextEip(uc, ptr);\n    }\n\n    logStackTrace(eip, 1);\n\n    if (eip == info->si_addr) {\n        \/* Restore old eip *\/\n        getAndSetMcontextEip(uc, eip);\n    }\n\n    logRegisters(uc);\n#endif\n\n    printCrashReport();","target":0,"flaw_line_index":0,"hash":"7f769000-3989-47f4-9b14-0bb8d2ba7afe","idx":"b389d23d-a866-4d8d-b876-371d12a2cbf3"}
{"func_before":"\n\tswitch (optname) {\n\tcase IP_OPTIONS:\n\t{\n\t\tunsigned char optbuf[sizeof(struct ip_options)+40];\n\t\tstruct ip_options * opt = (struct ip_options *)optbuf;\n\t\topt->optlen = 0;\n\t\tif (inet->opt)\n\t\t\tmemcpy(optbuf, inet->opt,\n\t\t\t       sizeof(struct ip_options)+\n\t\t\t       inet->opt->optlen);\n\t\trelease_sock(sk);\n\n\t\tif (opt->optlen == 0)\n\t\t\treturn put_user(0, optlen);\n","target":1,"flaw_line_index":0,"hash":"32971114-61e6-4148-865f-8ffed894493a","idx":"e1fe2a3e-0014-476f-b399-26047715eba0"}
{"func_before":"\n\tswitch (optname) {\n\tcase IP_OPTIONS:\n\t{\n\t\tunsigned char optbuf[sizeof(struct ip_options)+40];\n\t\tstruct ip_options *opt = (struct ip_options *)optbuf;\n\t\tstruct ip_options_rcu *inet_opt;\n\n\t\tinet_opt = rcu_dereference_protected(inet->inet_opt,\n\t\t\t\t\t\t     sock_owned_by_user(sk));\n\t\topt->optlen = 0;\n\t\tif (inet_opt)\n\t\t\tmemcpy(optbuf, &inet_opt->opt,\n\t\t\t       sizeof(struct ip_options) +\n\t\t\t       inet_opt->opt.optlen);\n\t\trelease_sock(sk);\n\n\t\tif (opt->optlen == 0)\n\t\t\treturn put_user(0, optlen);\n","target":0,"flaw_line_index":0,"hash":"7a33eb6b-231e-44af-afa8-c11dd0b6376d","idx":"e10eeeea-ad4b-4eea-8029-3ec79223fcb0"}
{"func_before":"void PrivateThreadPoolDatasetOp::MakeDatasetFromOptions(OpKernelContext* ctx,\n                                                        DatasetBase* input,\n                                                        int32_t num_threads,\n                                                        DatasetBase** output) {\n  OP_REQUIRES(ctx, num_threads >= 0,\n              errors::InvalidArgument(\"`num_threads` must be >= 0\"));\n  *output = new Dataset(ctx,\n                        DatasetContext(DatasetContext::Params(\n                            {PrivateThreadPoolDatasetOp::kDatasetType,\n                             PrivateThreadPoolDatasetOp::kDatasetOp})),\n                        input, num_threads);","target":1,"flaw_line_index":0,"hash":"b78185a2-faea-4aba-ad99-a44d72f4e3d8","idx":"53d6f2df-5c3b-4371-aeb2-de08023455ce"}
{"func_before":"void PrivateThreadPoolDatasetOp::MakeDatasetFromOptions(OpKernelContext* ctx,\n                                                        DatasetBase* input,\n                                                        int32_t num_threads,\n                                                        DatasetBase** output) {\n  OP_REQUIRES_OK(ctx, ValidateNumThreads(num_threads));\n  *output = new Dataset(ctx,\n                        DatasetContext(DatasetContext::Params(\n                            {PrivateThreadPoolDatasetOp::kDatasetType,\n                             PrivateThreadPoolDatasetOp::kDatasetOp})),\n                        input, num_threads);","target":0,"flaw_line_index":0,"hash":"851c94da-c1fe-439c-9de3-d667cda408cd","idx":"0562f755-a387-463e-93ef-f1b9947502d0"}
{"func_before":"\t}\n\titem->type = type;\n\titem->subtype = subtype;\n\titem->space = space;\n\tfree (item->str);\n\titem->str = str ? strdup (str) : NULL;\n\tif (str && !item->str) {\n\t\tif (!node) { \/\/ If we just created this\n\t\t\tfree (item);\n\t\t}\n\t\treturn false;\n\t}\n\tR_DIRTY (a);\n\tif (!node) {\n\t\tr_interval_tree_insert (&a->meta, from, to, item);\n\t} else if (node->end != to) {","target":1,"flaw_line_index":0,"hash":"80756cdc-6335-427f-91fb-2fcb22015f6d","idx":"73fe718b-04fb-4827-a303-0b1f341b4a24"}
{"func_before":"\t}\n\titem->type = type;\n\titem->subtype = subtype;\n\titem->space = space;\n\tfree (item->str);\n\tif (R_STR_ISNOTEMPTY (str)) {\n\t\titem->str = strdup (str);\n\t\t\/\/ this breaks the `ecHw` command\n\t\t\/\/ (highlights word in current instruction, which uses ansi\n\t\t\/\/ r_str_ansi_strip (item->str);\n\t} else {\n\t\titem->str = NULL;\n\t}\n\tR_DIRTY (a);\n\tif (!node) {\n\t\tr_interval_tree_insert (&a->meta, from, to, item);\n\t} else if (node->end != to) {","target":0,"flaw_line_index":0,"hash":"158a48b2-30d6-4f6e-829d-b2c8e26b0207","idx":"6c922e43-28f8-48cb-960e-758729923451"}
{"func_before":"sysServices_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}","target":1,"flaw_line_index":0,"hash":"a33aad3f-b5ae-4c7f-a2b3-78d105869ba6","idx":"98bed057-7094-4fc4-8b63-4f83bdb4631b"}
{"func_before":"sysServices_handler(snmp_varbind_t *varbind, snmp_oid_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}","target":0,"flaw_line_index":0,"hash":"502e8c47-2a3c-487d-9bc6-c1a128b62cb0","idx":"0f5085da-5f6b-4848-8caf-11d90723ebd3"}
{"func_before":"TEST_F(NoAuthTest, calculate_checksum) {\n  auto unk = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::UNKNOWN);\n  EXPECT_TRUE(unk.empty());\n\n  auto md5 = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::MD5);\n  EXPECT_EQ(md5.size(), 32);\n  EXPECT_STRCASEEQ(md5.c_str(), \"A31557B1E39554C88C69AAE1DFAAF314\");\n\n  auto sha1 = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::SHA1);\n  EXPECT_EQ(sha1.size(), 40);\n  EXPECT_STRCASEEQ(sha1.c_str(), \"2B316F0552972605D509321F31F4274533C93161\");\n\n  auto sha256 = uthenticode::calculate_checksum(pe, uthenticode::checksum_kind::SHA256);\n  EXPECT_EQ(sha256.size(), 64);\n  EXPECT_STRCASEEQ(sha256.c_str(),\n                   \"6B7FA3E8298F33BC47F4ABB9C845930B1EACC0DAD96503CFA52D4EA18DDC89F0\");\n}","target":1,"flaw_line_index":0,"hash":"64e17270-0289-4807-9900-2855d314a81c","idx":"a6a6d32f-5b5a-491a-bb82-110285bd3463"}
{"func_before":"TEST_F(StuffingTest, verify) {\n  EXPECT_FALSE(uthenticode::verify(pe));\n}","target":0,"flaw_line_index":0,"hash":"4a6f3a27-2c6f-46d2-979e-8bcb9a1e51b7","idx":"51bd9ac8-5ae9-482e-bf6a-5e8867a6381d"}
{"func_before":"int ndlz4_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                     uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n\n  uint8_t *ip = (uint8_t *) input;\n  uint8_t *ip_limit = ip + input_len;\n  uint8_t *op = (uint8_t *) output;\n  uint8_t ndim;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 3) \/ 4) * 4;\n  eshape[1] = ((blockshape[1] + 3) \/ 4) * 4;\n\n  if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int32_t) (blockshape[0] * blockshape[1]))) {\n    return 0;\n  }\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  uint32_t i_stop[2];","target":1,"flaw_line_index":0,"hash":"5e3ca1e9-03be-4365-987c-6ca5679764eb","idx":"9dd7e197-dd3c-4e50-b25e-2f0c38d6283f"}
{"func_before":"int ndlz4_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len,\n                     uint8_t meta, blosc2_dparams *dparams) {\n  BLOSC_UNUSED_PARAM(meta);\n  BLOSC_UNUSED_PARAM(dparams);\n  BLOSC_ERROR_NULL(input, BLOSC2_ERROR_NULL_POINTER);\n  BLOSC_ERROR_NULL(output, BLOSC2_ERROR_NULL_POINTER);\n\n  uint8_t *ip = (uint8_t *) input;\n  uint8_t *ip_limit = ip + input_len;\n  uint8_t *op = (uint8_t *) output;\n  uint8_t ndim;\n  memcpy(&blockshape[1], ip, 4);\n  ip += 4;\n  eshape[0] = ((blockshape[0] + 3) \/ 4) * 4;\n  eshape[1] = ((blockshape[1] + 3) \/ 4) * 4;\n\n  if (NDLZ_UNEXPECT_CONDITIONAL((int64_t)output_len < (int64_t)blockshape[0] * (int64_t)blockshape[1])) {\n    return 0;\n  }\n  memset(op, 0, blockshape[0] * blockshape[1]);\n\n  uint32_t i_stop[2];","target":0,"flaw_line_index":0,"hash":"70a7f76f-afba-4acd-a754-6bf3e4d5ee57","idx":"25aaedd9-9fde-41de-bd7d-8356fa2cb91a"}
{"func_before":"{\n    struct z_packet z;\n    const char *parse = (const char *) cp;\n    int parselen = length;\n    const char *s;\n    int lose = 0;\n\n    \/* squelch compiler warnings *\/\n\n    z.kind = 0;\n    z.class = 0;\n    z.inst = 0;\n    z.opcode = 0;\n    z.sender = 0;\n    z.recipient = 0;\n\n#define PARSE_STRING\t\t\t\t\\\n\ts = parse_field(ndo, &parse, &parselen);\t\\\n\tif (!s) lose = 1;\n\n#define PARSE_FIELD_INT(field)\t\t\t\\\n\tPARSE_STRING\t\t\t\t\\\n\tif (!lose) field = strtol(s, 0, 16);\n    PARSE_FIELD_STR(z.format);\n    PARSE_FIELD_INT(z.cksum);\n    PARSE_FIELD_INT(z.multi);\n    PARSE_FIELD_STR(z.multi_uid);\n\n    if (lose) {\n\tND_PRINT((ndo, \" [|zephyr] (%d)\", length));\n\treturn;\n    }\n\n    ND_PRINT((ndo, \" zephyr\"));\n    if (strncmp(z.version+4, \"0.2\", 3)) {\n\tND_PRINT((ndo, \" v%s\", z.version+4));\n\treturn;\n    if (!*z.recipient)\n\tz.recipient = \"*\";\n\n    ND_PRINT((ndo, \" to %s\", z_triple(z.class, z.inst, z.recipient)));\n    if (*z.opcode)\n\tND_PRINT((ndo, \" op %s\", z.opcode));\n}","target":1,"flaw_line_index":0,"hash":"ea483b3d-40b1-4dd6-a716-eff59e457099","idx":"d052e1a6-6cd9-44f9-944a-29b58397c3f6"}
{"func_before":"    struct z_packet z;\n    const char *parse = (const char *) cp;\n    int parselen = length;\n    const char *s;\n    int lose = 0;\n    int truncated = 0;\n\n    \/* squelch compiler warnings *\/\n\n    z.kind = 0;\n    z.class = 0;\n    z.inst = 0;\n    z.opcode = 0;\n    z.sender = 0;\n    z.recipient = 0;\n\n#define PARSE_STRING\t\t\t\t\t\t\\\n\ts = parse_field(ndo, &parse, &parselen, &truncated);\t\\\n\tif (truncated) goto trunc;\t\t\t\t\\\n\tif (!s) lose = 1;\n\n#define PARSE_FIELD_INT(field)\t\t\t\\\n\tPARSE_STRING\t\t\t\t\\\n\tif (!lose) field = strtol(s, 0, 16);\n    PARSE_FIELD_STR(z.format);\n    PARSE_FIELD_INT(z.cksum);\n    PARSE_FIELD_INT(z.multi);\n    PARSE_FIELD_STR(z.multi_uid);\n\n    if (lose)\n        goto trunc;\n\n    ND_PRINT((ndo, \" zephyr\"));\n    if (strncmp(z.version+4, \"0.2\", 3)) {\n\tND_PRINT((ndo, \" v%s\", z.version+4));\n\treturn;\n\tz.recipient = \"*\";\n\n    ND_PRINT((ndo, \" to %s\", z_triple(z.class, z.inst, z.recipient)));\n    if (*z.opcode)\n\tND_PRINT((ndo, \" op %s\", z.opcode));\n    return;\n\ntrunc:\n    ND_PRINT((ndo, \" [|zephyr] (%d)\", length));\n    return;\n}","target":0,"flaw_line_index":0,"hash":"233f0d7a-1de0-4e0b-9dae-2bd6ec5a0b35","idx":"0c9df5c1-0d57-4732-9be8-e1f304e97136"}
{"func_before":"l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat)\n{\n\tND_PRINT((ndo, \"%u.%u\", (EXTRACT_16BITS(dat) >> 8),\n\t    (EXTRACT_16BITS(dat) & 0xff)));\n}","target":1,"flaw_line_index":0,"hash":"72c70d3d-cb33-48fa-9206-547c638a8912","idx":"496a726e-6776-4c27-98b3-d2cc205700b1"}
{"func_before":"l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat, u_int length)\n{\n\tif (length < 2) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tND_PRINT((ndo, \"%u.%u\", (EXTRACT_16BITS(dat) >> 8),\n\t    (EXTRACT_16BITS(dat) & 0xff)));\n}","target":0,"flaw_line_index":0,"hash":"ebd38287-1129-4097-b644-509955c20887","idx":"5359ae0a-30ce-40b7-b449-557f310fe7a6"}
{"func_before":"  \/\/ check parameters\n  if (!(input_h_desc.num_layers() ==\n            model_dims.num_layers * model_dims.dir_count &&\n        input_h_desc.batch_size() == model_dims.batch_size &&\n        input_h_desc.data_size() == model_dims.hidden_size)) {\n    return tsl::Status(port::error::INVALID_ARGUMENT, \"Invalid input_h shape\");\n  }\n  \/\/ The LSTM projection will be used if input_h_desc.data_size() <\n  \/\/ input_c_desc.data_size()\n  if (!(input_h_desc.num_layers() == input_c_desc.num_layers() &&\n        input_h_desc.batch_size() == input_c_desc.batch_size() &&\n        input_h_desc.data_size() <= input_c_desc.data_size())) {\n    return tsl::Status(port::error::INVALID_ARGUMENT, \"Invalid input_c shape\");\n  }\n  if (!(output_desc.max_seq_length() == model_dims.max_seq_length &&\n        output_desc.batch_size() == model_dims.batch_size &&\n        output_desc.data_size() ==\n            model_dims.hidden_size * model_dims.dir_count)) {\n    return tsl::Status(port::error::INVALID_ARGUMENT, \"Invalid output shape\");\n  }\n  if (!(input_h_desc.num_layers() == output_h_desc.num_layers() &&\n        input_h_desc.batch_size() == output_h_desc.batch_size() &&\n        input_h_desc.data_size() == output_h_desc.data_size())) {\n    return tsl::Status(port::error::INVALID_ARGUMENT, \"Invalid output_h shape\");\n  }\n  if (!(input_h_desc.num_layers() == output_c_desc.num_layers() &&\n        input_h_desc.batch_size() == output_c_desc.batch_size() &&\n        input_h_desc.data_size() <= output_c_desc.data_size())) {\n    return tsl::Status(port::error::INVALID_ARGUMENT, \"Invalid output_c shape\");\n  }\n\n  return model_dims;\n}","target":1,"flaw_line_index":0,"hash":"31811ee6-f912-4927-af85-f7bc18c55140","idx":"37b4b013-abf2-4131-bafc-ada8851d3829"}
{"func_before":"  \/\/ check parameters\n  if (!(input_h_desc.num_layers() ==\n            model_dims.num_layers * model_dims.dir_count &&\n        input_h_desc.batch_size() == model_dims.batch_size &&\n        input_h_desc.data_size() == model_dims.hidden_size)) {\n    return tsl::Status(tsl::error::INVALID_ARGUMENT, \"Invalid input_h shape\");\n  }\n  \/\/ The LSTM projection will be used if input_h_desc.data_size() <\n  \/\/ input_c_desc.data_size()\n  if (!(input_h_desc.num_layers() == input_c_desc.num_layers() &&\n        input_h_desc.batch_size() == input_c_desc.batch_size() &&\n        input_h_desc.data_size() <= input_c_desc.data_size())) {\n    return tsl::Status(tsl::error::INVALID_ARGUMENT, \"Invalid input_c shape\");\n  }\n  if (!(output_desc.max_seq_length() == model_dims.max_seq_length &&\n        output_desc.batch_size() == model_dims.batch_size &&\n        output_desc.data_size() ==\n            model_dims.hidden_size * model_dims.dir_count)) {\n    return tsl::Status(tsl::error::INVALID_ARGUMENT, \"Invalid output shape\");\n  }\n  if (!(input_h_desc.num_layers() == output_h_desc.num_layers() &&\n        input_h_desc.batch_size() == output_h_desc.batch_size() &&\n        input_h_desc.data_size() == output_h_desc.data_size())) {\n    return tsl::Status(tsl::error::INVALID_ARGUMENT, \"Invalid output_h shape\");\n  }\n  if (!(input_h_desc.num_layers() == output_c_desc.num_layers() &&\n        input_h_desc.batch_size() == output_c_desc.batch_size() &&\n        input_h_desc.data_size() <= output_c_desc.data_size())) {\n    return tsl::Status(tsl::error::INVALID_ARGUMENT, \"Invalid output_c shape\");\n  }\n\n  return model_dims;\n}","target":0,"flaw_line_index":0,"hash":"803846bb-cb62-41e9-9788-beeaaf99e9b8","idx":"06433889-91f7-4e05-8ee5-874400d7060d"}
{"func_before":"\t}\n\n\t\/\/rewrite OD frames\n\tif (traf->trex->track->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\t\/\/this may fail if dependencies are not well done ...\n\t\tMedia_ParseODFrame(traf->trex->track->Media, sample, &od_sample);\n\t\tsample = od_sample;\n\t}\n\n\tent.size = sample->dataLength;\n\ttrun->samples[trun->nb_samples] = ent;","target":1,"flaw_line_index":0,"hash":"4f7be1b3-4b2c-4bc1-91a3-4a9109c4c4a4","idx":"7d8f553d-2b47-4c3d-b3a8-1a1c87065fa2"}
{"func_before":"\t}\n\n\t\/\/rewrite OD frames\n\tif (traf->trex->track->Media->handler->handlerType == GF_ISOM_MEDIA_OD) {\n\t\t\/\/this may fail if dependencies are not well done ...\n\t\tGF_Err e = Media_ParseODFrame(traf->trex->track->Media, sample, &od_sample);\n\t\tif (!od_sample) return e;\n\t\tsample = od_sample;\n\t}\n\n\tent.size = sample->dataLength;\n\ttrun->samples[trun->nb_samples] = ent;","target":0,"flaw_line_index":0,"hash":"c3a8fb6f-3008-4075-aa2c-6c6641049a88","idx":"cbb4665f-e38d-4546-99aa-5726acc6e33d"}
{"func_before":"static void op_attr_bignum_free(void *attr)\n{\n\tstruct bignum **bn = attr;\n\n\tcrypto_bignum_free(*bn);\n\t*bn = NULL;\n}","target":1,"flaw_line_index":0,"hash":"1401137e-5c66-4160-b835-04dc73361086","idx":"b68a23a8-f22f-4b36-a875-fc3abe5a1f9e"}
{"func_before":"static void op_attr_bignum_free(void *attr)\n{\n\tstruct bignum **bn = attr;\n\n\tcrypto_bignum_free(bn);\n}","target":0,"flaw_line_index":0,"hash":"49c39a5c-bed9-4893-9035-f5b8222c275d","idx":"dc6a1903-5baf-4faa-bb32-6aa5a21aeb0f"}
{"func_before":"{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\t__be32 spi;\n\n\tspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, spi);\n}","target":1,"flaw_line_index":0,"hash":"aaf93280-186a-410e-beca-e36907001f50","idx":"13a28558-0b82-40c8-9c04-30d81a8f6555"}
{"func_before":"{\n\tstruct ipv6hdr *iph = ipv6_hdr(skb);\n\t__be32 spi;\n\n\tspi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);\n\treturn xfrm6_rcv_spi(skb, spi) > 0 ? : 0;\n}","target":0,"flaw_line_index":0,"hash":"2dd94a3d-6365-4621-84ca-4efde4d26529","idx":"d10a1000-a8b6-4209-8d59-bf95808279d1"}
{"func_before":"StreamExecutor::createRnnSequenceTensorDescriptor(int max_seq_length,\n                                                  int batch_size, int data_size,\n                                                  dnn::DataType data_type) {\n  dnn::DnnSupport* dnn_support = AsDnn();\n  if (!dnn_support) {\n    return tsl::Status(port::error::UNKNOWN,\n                       \"Fail to find the dnn implementation.\");\n  }\n  return dnn_support->createRnnSequenceTensorDescriptor(\n      max_seq_length, batch_size, data_size, data_type);\n}","target":1,"flaw_line_index":0,"hash":"96486834-4473-432b-acd9-7285031cfd7d","idx":"dedda19d-3540-4342-9f79-4cef3097f53f"}
{"func_before":"StreamExecutor::createRnnSequenceTensorDescriptor(int max_seq_length,\n                                                  int batch_size, int data_size,\n                                                  dnn::DataType data_type) {\n  dnn::DnnSupport* dnn_support = AsDnn();\n  if (!dnn_support) {\n    return tsl::Status(tsl::error::UNKNOWN,\n                       \"Fail to find the dnn implementation.\");\n  }\n  return dnn_support->createRnnSequenceTensorDescriptor(\n      max_seq_length, batch_size, data_size, data_type);\n}","target":0,"flaw_line_index":0,"hash":"4a213022-09af-4a21-8d84-9860f817a372","idx":"4d63f211-f1e0-4a2e-938b-825bfc50bf97"}
{"func_before":"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_pli(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length)\n{\n    pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf;\n\n    PJ_ASSERT_RETURN(buf, PJ_EINVAL);\n\n    if (length < 12)\n    \treturn PJ_ETOOSMALL;\n\n    \/* PLI uses pt==RTCP_PSFB and FMT==1 *\/\n    if (hdr->pt != RTCP_PSFB || hdr->count != 1)\n\treturn PJ_ENOTFOUND;\n\n    return PJ_SUCCESS;\n}","target":1,"flaw_line_index":0,"hash":"ba9fe390-0a98-4e36-9d55-ced0e2490571","idx":"f08bd5ae-dc0c-4004-b7b6-7e5ec1c9e3e0"}
{"func_before":"PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_pli(\n\t\t\t\t\tconst void *buf,\n\t\t\t\t\tpj_size_t length)\n{\n    pjmedia_rtcp_fb_common *hdr = (pjmedia_rtcp_fb_common*) buf;\n\n    PJ_ASSERT_RETURN(buf, PJ_EINVAL);\n\n    if (length < 12)\n    \treturn PJ_ETOOSMALL;\n\n    \/* PLI uses pt==RTCP_PSFB and FMT==1 *\/\n    if (hdr->rtcp_common.pt != RTCP_PSFB || hdr->rtcp_common.count != 1)\n\treturn PJ_ENOTFOUND;\n\n    return PJ_SUCCESS;\n}","target":0,"flaw_line_index":0,"hash":"3c6299d1-c4f1-4865-88d5-f9d0dc4fdd4a","idx":"e6a1d15d-d883-4340-910d-131de5ffa4f2"}
{"func_before":"static int64_t HHVM_FUNCTION(bccomp, const String& left, const String& right,\n                             int64_t scale \/* = -1 *\/) {\n  if (scale < 0) scale = BCG(bc_precision);\n  bc_num first, second;\n  bc_init_num(&first);\n  bc_init_num(&second);\n  bc_str2num(&first, (char*)left.data(), scale);\n  bc_str2num(&second, (char*)right.data(), scale);","target":1,"flaw_line_index":0,"hash":"522b13da-a7db-4db4-94d4-d23a46d2a87c","idx":"c0fd3451-f9d1-4e4f-94cc-8b8e8ce3aae7"}
{"func_before":"static int64_t HHVM_FUNCTION(bccomp, const String& left, const String& right,\n                             int64_t scale \/* = -1 *\/) {\n  scale = adjust_scale(scale);\n  bc_num first, second;\n  bc_init_num(&first);\n  bc_init_num(&second);\n  bc_str2num(&first, (char*)left.data(), scale);\n  bc_str2num(&second, (char*)right.data(), scale);","target":0,"flaw_line_index":0,"hash":"91e025b1-3dd3-4747-a0df-992be4a96c81","idx":"bb572b49-f505-4698-b1f0-5a208abadeba"}
{"func_before":"trustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint32_t *enc_len, size_t _t) {\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_dkg_secret);\n\n\n    int status = gen_dkg_poly(dkg_secret, _t);\n\n    CHECK_STATUS(\"gen_dkg_poly failed\")\n\n    status = AES_encrypt(dkg_secret, encrypted_dkg_secret, 3 * BUF_LEN);\n\n    CHECK_STATUS(\"SGX AES encrypt DKG poly failed\");\n\n    *enc_len = strlen(dkg_secret) + SGX_AESGCM_MAC_SIZE + SGX_AESGCM_IV_SIZE;\n\n    SAFE_CHAR_BUF(decr_dkg_secret, DKG_BUFER_LENGTH);\n\n    status = AES_decrypt(encrypted_dkg_secret, *enc_len, decr_dkg_secret,\n                         DKG_BUFER_LENGTH);","target":1,"flaw_line_index":0,"hash":"14bcfb45-6798-44ee-a56b-e98bbf83416b","idx":"d369c704-39eb-4370-bd1c-550d9cc80a29"}
{"func_before":"trustedGenDkgSecretAES(int *errStatus, char *errString, uint8_t *encrypted_dkg_secret, uint64_t *enc_len, size_t _t) {\n    LOG_INFO(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encrypted_dkg_secret);\n\n\n    int status = gen_dkg_poly(dkg_secret, _t);\n\n    CHECK_STATUS(\"gen_dkg_poly failed\")\n\n    status = AES_encrypt(dkg_secret, encrypted_dkg_secret, 3 * BUF_LEN,\n                         DKG, DECRYPTABLE, enc_len);\n\n    CHECK_STATUS(\"SGX AES encrypt DKG poly failed\");\n\n\n\n    SAFE_CHAR_BUF(decr_dkg_secret, DKG_BUFER_LENGTH);\n\n    status = AES_decrypt(encrypted_dkg_secret, *enc_len, decr_dkg_secret,\n                         DKG_BUFER_LENGTH);","target":0,"flaw_line_index":0,"hash":"838713f4-eafe-476a-b0b4-74dc1554906e","idx":"f20941f8-d7e8-47c1-9465-c027d45d054e"}
{"func_before":"  };\n\n  auto splits_or =\n      GetTensorSplits(input_dimensions, output_dimensions, element_type);\n  if (!splits_or.ok()) {\n    return tsl::Status(port::error::INTERNAL, \"Cudnn pooling failed to split\");\n  }\n  auto splits = std::move(splits_or.value());\n\n  dnn::BatchDescriptor input_split = input_dimensions;\n  dnn::BatchDescriptor output_split = output_dimensions;","target":1,"flaw_line_index":0,"hash":"2965f306-07aa-4b3a-ab31-1e3ddcaba827","idx":"708a0bbc-01f2-4252-9375-2f428cd333a1"}
{"func_before":"  };\n\n  auto splits_or =\n      GetTensorSplits(input_dimensions, output_dimensions, element_type);\n  if (!splits_or.ok()) {\n    return tsl::Status(tsl::error::INTERNAL, \"Cudnn pooling failed to split\");\n  }\n  auto splits = std::move(splits_or.value());\n\n  dnn::BatchDescriptor input_split = input_dimensions;\n  dnn::BatchDescriptor output_split = output_dimensions;","target":0,"flaw_line_index":0,"hash":"46dd082b-b82b-4c90-bde6-4ce0adc0386d","idx":"1aba9888-bee1-4dad-86c5-b2785748c98e"}
{"func_before":"static int hns_xgmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS)\n\t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"54350d9b-39b4-4e1b-bb78-d45f9022b9af","idx":"8b8993e3-0a54-4f56-9d00-0ffd9487675a"}
{"func_before":"static int hns_xgmac_get_sset_count(int stringset)\n{\n\tif (stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS)\n\t\treturn ARRAY_SIZE(g_xgmac_stats_string);\n\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"4d261126-5730-46b0-a990-03457c0a88ed","idx":"06f7ebe6-a89e-4de7-b4ea-c9560d401425"}
{"func_before":"static void sycc420_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;\n\tconst int *y, *cb, *cr, *ny;\n\tunsigned int maxw, maxh, max;\n\tint offset, upb;\n\tunsigned int i, j;\n\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\n\tmaxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;\n\tmax = maxw * maxh;\n\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\n\td0 = r = (int*)malloc(sizeof(int) * (size_t)max);\n\td1 = g = (int*)malloc(sizeof(int) * (size_t)max);\n\td2 = b = (int*)malloc(sizeof(int) * (size_t)max);\n\n\tif(r == NULL || g == NULL || b == NULL) goto fails;\n\n\tfor(i=0U; i < (maxh & ~(unsigned int)1U); i += 2U)\n\t{\n\t\tny = y + maxw;\n\t\tnr = r + maxw; ng = g + maxw; nb = b + maxw;\n\n\t\tfor(j=0; j < (maxw & ~(unsigned int)1U); j += 2U)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb;\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n\t\t}\n\t\tif(j < maxw)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n\t\t}\n\t\ty += maxw; r += maxw; g += maxw; b += maxw;\n\t}\n\tif(i < maxh)\n\t{\n\t\tfor(j=0U; j < (maxw & ~(unsigned int)1U); j += 2U)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n\t\t\t++y; ++r; ++g; ++b;\n\n\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\n#if defined(USE_JPWL) || defined(USE_MJ2)\n\timg->comps[1].w = maxw; img->comps[1].h = maxh;\n\timg->comps[2].w = maxw; img->comps[2].h = maxh;\n#else\n\timg->comps[1].w = (OPJ_UINT32)maxw; img->comps[1].h = (OPJ_UINT32)maxh;\n\timg->comps[2].w = (OPJ_UINT32)maxw; img->comps[2].h = (OPJ_UINT32)maxh;\n#endif\n\timg->comps[1].dx = img->comps[0].dx;\n\timg->comps[2].dx = img->comps[0].dx;\n\timg->comps[1].dy = img->comps[0].dy;\n\timg->comps[2].dy = img->comps[0].dy;\n\treturn;\n\nfails:\n\tif(r) free(r);\n\tif(g) free(g);\n\tif(b) free(b);\n\n}\/* sycc420_to_rgb() *\/","target":1,"flaw_line_index":0,"hash":"c901647a-7f0f-462b-adfa-8cfb2c847f8d","idx":"f4c90d9f-9fd6-4ea5-b09e-7ddda6311888"}
{"func_before":"static void sycc420_to_rgb(opj_image_t *img)\n{\n\tint *d0, *d1, *d2, *r, *g, *b, *nr, *ng, *nb;\n\tconst int *y, *cb, *cr, *ny;\n\tsize_t maxw, maxh, max, offx, loopmaxw, offy, loopmaxh;\n\tint offset, upb;\n\tsize_t i;\n\n\tupb = (int)img->comps[0].prec;\n\toffset = 1<<(upb - 1); upb = (1<<upb)-1;\n\n\tmaxw = (size_t)img->comps[0].w; maxh = (size_t)img->comps[0].h;\n\tmax = maxw * maxh;\n\n\ty = img->comps[0].data;\n\tcb = img->comps[1].data;\n\tcr = img->comps[2].data;\n\n\td0 = r = (int*)malloc(sizeof(int) * max);\n\td1 = g = (int*)malloc(sizeof(int) * max);\n\td2 = b = (int*)malloc(sizeof(int) * max);\n\t\n\tif (r == NULL || g == NULL || b == NULL) goto fails;\n\t\n\t\/* if img->x0 is odd, then first column shall use Cb\/Cr = 0 *\/\n\toffx = img->x0 & 1U;\n\tloopmaxw = maxw - offx;\n\t\/* if img->y0 is odd, then first line shall use Cb\/Cr = 0 *\/\n\toffy = img->y0 & 1U;\n\tloopmaxh = maxh - offy;\n\t\n\tif (offy > 0U) {\n\t\tsize_t j;\n\t\t\n\t\tfor(j=0; j < maxw; ++j)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t}\n\t}\n\n\tfor(i=0U; i < (loopmaxh & ~(size_t)1U); i += 2U)\n\t{\n\t\tsize_t j;\n\t\t\n\t\tny = y + maxw;\n\t\tnr = r + maxw; ng = g + maxw; nb = b + maxw;\n\t\t\n\t\tif (offx > 0U) {\n\t\t\tsycc_to_rgb(offset, upb, *y, 0, 0, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb;\n\t\t}\n\n\t\tfor(j=0; j < (loopmaxw & ~(size_t)1U); j += 2U)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb;\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n\t\t}\n\t\tif(j < loopmaxw)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\t\t\t++y; ++r; ++g; ++b;\n\n\t\t\tsycc_to_rgb(offset, upb, *ny, *cb, *cr, nr, ng, nb);\n\t\t\t++ny; ++nr; ++ng; ++nb; ++cb; ++cr;\n\t\t}\n\t\ty += maxw; r += maxw; g += maxw; b += maxw;\n\t}\n\tif(i < loopmaxh)\n\t{\n\t\tsize_t j;\n\t\t\n\t\tfor(j=0U; j < (maxw & ~(size_t)1U); j += 2U)\n\t\t{\n\t\t\tsycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);\n\n\t\t\t++y; ++r; ++g; ++b;\n\n\n\tfree(img->comps[0].data); img->comps[0].data = d0;\n\tfree(img->comps[1].data); img->comps[1].data = d1;\n\tfree(img->comps[2].data); img->comps[2].data = d2;\n\n\timg->comps[1].w = img->comps[2].w = img->comps[0].w;\n\timg->comps[1].h = img->comps[2].h = img->comps[0].h;\n\timg->comps[1].dx = img->comps[2].dx = img->comps[0].dx;\n\timg->comps[1].dy = img->comps[2].dy = img->comps[0].dy;\n\timg->color_space = OPJ_CLRSPC_SRGB;\n\treturn;\n\nfails:\n\tfree(r);\n\tfree(g);\n\tfree(b);\n}\/* sycc420_to_rgb() *\/","target":0,"flaw_line_index":0,"hash":"40239ad8-d92b-4d0c-9cf1-80ee37c24eda","idx":"cb5a05c0-52fa-437c-b5b2-876c9d0695d4"}
{"func_before":"\t\t\t\t  server_realm);\n    if(ret){\n\tkrb5_warn(context, ret,\n\t\t  \"Decoding transited encoding\");\n\treturn ret;\n    }\n    if(strcmp(client_realm, tgt_realm) && strcmp(server_realm, tgt_realm)) {\n\t\/* not us, so add the previous realm to transited set *\/\n\tif (num_realms + 1 > UINT_MAX\/sizeof(*realms)) {\n\t    ret = ERANGE;\n\t    goto free_realms;\n\t}\n\ttmp = realloc(realms, (num_realms + 1) * sizeof(*realms));","target":1,"flaw_line_index":0,"hash":"4c148956-ec41-41c6-b385-01fcb748a655","idx":"5abdf9f5-c1b5-4716-85f8-9fed1a9e696e"}
{"func_before":"    if(ret){\n\tkrb5_warn(context, ret,\n\t\t  \"Decoding transited encoding\");\n\treturn ret;\n    }\n\n    \/*\n     * If the realm of the presented tgt is neither the client nor the server\n     * realm, it is a transit realm and must be added to transited set.\n     *\/\n    if(strcmp(client_realm, tgt_realm) && strcmp(server_realm, tgt_realm)) {\n\tif (num_realms + 1 > UINT_MAX\/sizeof(*realms)) {\n\t    ret = ERANGE;\n\t    goto free_realms;\n\t}\n\ttmp = realloc(realms, (num_realms + 1) * sizeof(*realms));","target":0,"flaw_line_index":0,"hash":"bbbe993b-f3e2-44ee-9ce9-b0963c8dd3f8","idx":"e3b0a947-f1b8-4b6e-a0bd-7f2e4aa24108"}
{"func_before":"int bn_gen_prime_factor(bn_t a, bn_t b, int abits, int bbits) {\n\tbn_t t;\n\tint result = RLC_OK;\n\n    if (! (bbits>abits) ) {\n\t\treturn RLC_ERR;","target":1,"flaw_line_index":0,"hash":"2a4d0bb0-bd5e-4dd2-bf8e-a0ddb815f7da","idx":"3dee29ba-8163-4a69-92b1-412d2ad4a191"}
{"func_before":"int bn_gen_prime_factor(bn_t a, bn_t b, size_t abits, size_t bbits) {\n\tbn_t t;\n\tint result = RLC_OK;\n\n    if (! (bbits>abits) ) {\n\t\treturn RLC_ERR;","target":0,"flaw_line_index":0,"hash":"62118cfa-d3ee-4f2f-a226-da45789e4caf","idx":"28148130-85b5-4c22-923a-eba8a2c24b67"}
{"func_before":"\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\n\tif (msg->msg_namelen != 0) {\n\t\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\t\tax25_digi digi;\n\t\tax25_address src;\n\t\tconst unsigned char *mac = skb_mac_header(skb);\n\n\t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n\t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\n\t\t\t\t&digi, NULL, NULL);\n\t\tsax->sax25_family = AF_AX25;","target":1,"flaw_line_index":0,"hash":"ff60a799-63ae-4093-a464-541e85a3cc19","idx":"4b22bffd-c899-4d0b-aea7-a08d2aa7552b"}
{"func_before":"\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\n\tif (msg->msg_name) {\n\t\tax25_digi digi;\n\t\tax25_address src;\n\t\tconst unsigned char *mac = skb_mac_header(skb);\n\t\tstruct sockaddr_ax25 *sax = msg->msg_name;\n\n\t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n\t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\n\t\t\t\t&digi, NULL, NULL);\n\t\tsax->sax25_family = AF_AX25;","target":0,"flaw_line_index":0,"hash":"a9c65b13-e17f-4f99-b910-e49ff1fff8f0","idx":"964e5665-0301-48c1-9d6f-121e4adb9ab8"}
{"func_before":"\tfit_base_uname_config = NULL;\n\tprop_name = fit_get_image_type_property(image_type);\n\tprintf(\"## Loading %s from FIT Image at %08lx ...\\n\", prop_name, addr);\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT);\n\tif (fit_check_format(fit, IMAGE_SIZE_INVAL)) {\n\t\tprintf(\"Bad FIT %s image format!\\n\", prop_name);\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_FORMAT);\n\t\treturn -ENOEXEC;\n\t}\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT_OK);\n\tif (fit_uname) {\n\t\t\/* get FIT component image node offset *\/\n\t\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_UNIT_NAME);","target":1,"flaw_line_index":0,"hash":"149cd1ad-beea-43ac-9ee1-34e28e6fdd7c","idx":"685594f4-6a95-4200-8459-1fbaf49e4975"}
{"func_before":"\tfit_base_uname_config = NULL;\n\tprop_name = fit_get_image_type_property(image_type);\n\tprintf(\"## Loading %s from FIT Image at %08lx ...\\n\", prop_name, addr);\n\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT);\n\tret = fit_check_format(fit, IMAGE_SIZE_INVAL);\n\tif (ret) {\n\t\tprintf(\"Bad FIT %s image format! (err=%d)\\n\", prop_name, ret);\n\t\tif (CONFIG_IS_ENABLED(FIT_SIGNATURE) && ret == -EADDRNOTAVAIL)\n\t\t\tprintf(\"Signature checking prevents use of unit addresses (@) in nodes\\n\");\n\t\tbootstage_error(bootstage_id + BOOTSTAGE_SUB_FORMAT);\n\t\treturn ret;\n\t}\n\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_FORMAT_OK);\n\tif (fit_uname) {\n\t\t\/* get FIT component image node offset *\/\n\t\tbootstage_mark(bootstage_id + BOOTSTAGE_SUB_UNIT_NAME);","target":0,"flaw_line_index":0,"hash":"54ac0f94-021d-450e-b9ca-25e56d77ad4e","idx":"a9771ace-4a6a-4ffd-9924-e9d55da1e3a0"}
{"func_before":"\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ID, &PROP_UINT(esd ? esd->ESID : item_id));\n\t}\n\n\tif (read->itemid)\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ITEM_ID, &PROP_UINT(item_id));\n\t\t\n\tif ((item_codecid==GF_CODECID_HEVC) && gf_isom_meta_item_has_ref(read->mov, GF_TRUE, 0, item_id, GF_ISOM_REF_TBAS)) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TILE_BASE, &PROP_BOOL(GF_TRUE));\n\t}\n\n","target":1,"flaw_line_index":0,"hash":"5a4783e9-3b45-4207-99b6-b242abcec00c","idx":"cb192434-100e-4acd-8cb5-5637b8593b5e"}
{"func_before":"\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ID, &PROP_UINT(esd ? esd->ESID : item_id));\n\t}\n\n\tif (read->itemid)\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_ITEM_ID, &PROP_UINT(item_id));\n\n\tif ((item_codecid==GF_CODECID_HEVC) && gf_isom_meta_item_has_ref(read->mov, GF_TRUE, 0, item_id, GF_ISOM_REF_TBAS)) {\n\t\tgf_filter_pid_set_property(pid, GF_PROP_PID_TILE_BASE, &PROP_BOOL(GF_TRUE));\n\t}\n\n","target":0,"flaw_line_index":0,"hash":"f4e1da9e-7623-4e86-877c-cd820d18f6bc","idx":"4e03692f-763b-47b7-8ebf-9200bb159474"}
{"func_before":" *\/\nint re_yyget_lineno  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    \n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    \n    return yylineno;","target":1,"flaw_line_index":0,"hash":"1e2ddf48-3af7-4039-a99c-1730e13a2ffe","idx":"e65dfd32-41f4-40e3-b35a-df98a46df637"}
{"func_before":" *\/\nint re_yyget_lineno  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    \n    return yylineno;","target":0,"flaw_line_index":0,"hash":"e2dd3492-8181-4a46-98ca-0619006274ee","idx":"f48df486-07fb-4ecd-9c88-094f0937a482"}
{"func_before":"iakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t output_token)\n{\n    OM_uint32 major_status = GSS_S_COMPLETE;\n\n    if (output_token != GSS_C_NO_BUFFER) {\n        output_token->length = 0;\n        output_token->value = NULL;\n    }\n\n    *minor_status = 0;\n\n    if (*context_handle != GSS_C_NO_CONTEXT) {\n        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n\n        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {\n            iakerb_release_context(iakerb_ctx);\n            *context_handle = GSS_C_NO_CONTEXT;\n        } else {\n            assert(iakerb_ctx->magic == KG_CONTEXT);\n\n            major_status = krb5_gss_delete_sec_context(minor_status,\n                                                       context_handle,\n                                                       output_token);\n        }\n    }\n\n    return major_status;\n}","target":1,"flaw_line_index":0,"hash":"cfd9c1ce-4520-4056-9182-50c641e657f5","idx":"7b7fd84d-7aad-4500-b355-14ac95a340ab"}
{"func_before":"iakerb_gss_delete_sec_context(OM_uint32 *minor_status,\n                              gss_ctx_id_t *context_handle,\n                              gss_buffer_t output_token)\n{\n    iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;\n\n    if (output_token != GSS_C_NO_BUFFER) {\n        output_token->length = 0;\n        output_token->value = NULL;\n    }\n\n    *minor_status = 0;\n    *context_handle = GSS_C_NO_CONTEXT;\n    iakerb_release_context(iakerb_ctx);\n\n    return GSS_S_COMPLETE;\n}","target":0,"flaw_line_index":0,"hash":"8269ae71-d9c3-4d5e-aa67-5ed8a9a08f4a","idx":"508bb0b3-bad5-401d-89f6-90e04b6d58eb"}
{"func_before":"\t\tshadow->dataLength = 0;\n\t\tgf_isom_sample_del(&shadow);\n\t}\n\tif (static_sample && ! (*sample)->alloc_size )\n\t\t (*sample)->alloc_size =  (*sample)->dataLength;\n\t\t \n\treturn GF_OK;\n}","target":1,"flaw_line_index":0,"hash":"d668e51b-b163-4510-863e-7638092545e4","idx":"316625c3-63da-4e9e-b86b-04f574c69fe8"}
{"func_before":"\t\tshadow->dataLength = 0;\n\t\tgf_isom_sample_del(&shadow);\n\t}\n\tif (static_sample && ! (*sample)->alloc_size )\n\t\t (*sample)->alloc_size =  (*sample)->dataLength;\n\n\treturn GF_OK;\n}","target":0,"flaw_line_index":0,"hash":"14439613-d245-4080-aaf4-e533b01ce48a","idx":"98a0c2e7-1e50-45a7-90ad-1a1a53e6ae0e"}
{"func_before":"\tdefault:\n\t\txml = NULL;\n\t\tl = 0;\n\t}\n\tobj->buffersize = 1024;\n\tobj->buffer = malloc(obj->buffersize);\n\tif(!obj->buffer) {\n\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\n\t\tif(xml) {\n\t\t\tfree(xml);\n\t\t}\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n\t                       obj->sub->uuid, obj->sub->seq,\n\t                       l, xml);\n\tif(xml) {\n\t\tfree(xml);\n\t\txml = NULL;\n\t}\n\tobj->state = ESending;","target":1,"flaw_line_index":0,"hash":"69710656-e30a-4609-a364-835e447e6c71","idx":"ce78acab-3d92-470f-be9d-885a6b6de16f"}
{"func_before":"\tdefault:\n\t\txml = NULL;\n\t\tl = 0;\n\t}\n\tobj->buffersize = 1024;\n\tfor (;;) {\n\t\tobj->buffer = malloc(obj->buffersize);\n\t\tif(!obj->buffer) {\n\t\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\n\t\t\tif(xml) {\n\t\t\t\tfree(xml);\n\t\t\t}\n\t\t\tobj->state = EError;\n\t\t\treturn;\n\t\t}\n\t\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n\t\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n\t\t                       obj->sub->uuid, obj->sub->seq,\n\t\t                       l, xml);\n\t\tif (obj->tosend < 0) {\n\t\t\tsyslog(LOG_ERR, \"%s: snprintf() failed\", \"upnp_event_prepare\");\n\t\t\tif(xml) {\n\t\t\t\tfree(xml);\n\t\t\t}\n\t\t\tobj->state = EError;\n\t\t\treturn;\n\t\t} else if (obj->tosend < obj->buffersize) {\n\t\t\tbreak; \/* the buffer was large enough *\/\n\t\t}\n\t\t\/* Try again with a buffer big enough *\/\n\t\tfree(obj->buffer);\n\t\tobj->buffersize = obj->tosend + 1;\t\/* reserve space for the final 0 *\/\n\t}\n\tif(xml) {\n\t\tfree(xml);\n\t\txml = NULL;\n\t}\n\tobj->state = ESending;","target":0,"flaw_line_index":0,"hash":"fb157b43-5ce6-443d-917f-c18e79543c93","idx":"4f2473eb-cf12-47df-a518-360997431acf"}
{"func_before":"    cstack_T\t*cstack = eap->cstack;\n\n    if (cmdmod_error(FALSE))\n\treturn;\n\n    if (cstack->cs_trylevel <= 0 || cstack->cs_idx < 0)\n\teap->errmsg = _(e_endtry_without_try);\n    else\n    {\n\t\/*\n\t * Don't do something after an error, interrupt or throw in the try\n\t * block, catch clause, or finally clause preceding this \":endtry\" or\n\t * when an error or interrupt occurred after a \":continue\", \":break\",\n\t * \":return\", or \":finish\" in a try block or catch clause preceding this\n\t * \":endtry\" or when the try block never got active (because of an\n\t * inactive surrounding conditional or after an error or interrupt or\n\t * throw) or when there is a surrounding conditional and it has been\n\t * made inactive by a \":continue\", \":break\", \":return\", or \":finish\" in\n\t * the finally clause.  The latter case need not be tested since then\n\t * anything pending has already been discarded. *\/\n\tskip = did_emsg || got_int || did_throw\n\t\t\t     || !(cstack->cs_flags[cstack->cs_idx] & CSF_TRUE);\n\n\tif (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n\t{\n\t    eap->errmsg = get_end_emsg(cstack);\n\n\t    \/\/ Find the matching \":try\" and report what's missing.\n\t    idx = cstack->cs_idx;\n\t    do\n\t\t--idx;\n\t    while (idx > 0 && !(cstack->cs_flags[idx] & CSF_TRY));\n\t    rewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,\n\t\t\t\t\t\t       &cstack->cs_looplevel);\n\t    skip = TRUE;\n\n\t    \/*\n\t     * If an exception is being thrown, discard it to prevent it from\n\t     * being rethrown at the end of this function.  It would be\n\t     * discarded by the error message, anyway.  Resets did_throw.\n\t     * This does not affect the script termination due to the error\n\t     * since \"trylevel\" is decremented after emsg() has been called.\n\t     *\/\n\t    if (did_throw)\n\t\tdiscard_current_exception();\n\n\t    \/\/ report eap->errmsg, also when there already was an error\n\t    did_emsg = FALSE;\n\t}\n\telse\n\t{\n\t    idx = cstack->cs_idx;\n\n\t    \/\/ Check the flags only when not in a skipped block.\n\t    if (!skip && in_vim9script()\n\t\t     && (cstack->cs_flags[idx] & (CSF_CATCH|CSF_FINALLY)) == 0)\n\t    {\n\t\t\/\/ try\/endtry without any catch or finally: give an error and\n\t\t\/\/ continue.\n\t\teap->errmsg = _(e_missing_catch_or_finally);\n\t    }\n\n\t    \/*\n\t     * If we stopped with the exception currently being thrown at this\n\t     * try conditional since we didn't know that it doesn't have\n\t     * a finally clause, we need to rethrow it after closing the try\n\t     * conditional.\n\t     *\/\n\t    if (did_throw && (cstack->cs_flags[idx] & CSF_TRUE)\n\t\t    && !(cstack->cs_flags[idx] & CSF_FINALLY))\n\t\trethrow = TRUE;\n\t}\n\n\t\/\/ If there was no finally clause, show the user when debugging or\n\t\/\/ a breakpoint was encountered that the end of the try conditional has\n\t\/\/ been reached: display the debug prompt (if not already done).  Do\n\t\/\/ this on normal control flow or when an exception was thrown, but not\n\t\/\/ on an interrupt or error not converted to an exception or when\n\t\/\/ a \":break\", \":continue\", \":return\", or \":finish\" is pending.  These\n\t\/\/ actions are carried out immediately.\n\tif ((rethrow || (!skip\n\t\t\t&& !(cstack->cs_flags[idx] & CSF_FINALLY)\n\t\t\t&& !cstack->cs_pending[idx]))\n\t\t&& dbg_check_skipped(eap))\n\t{\n\t    \/\/ Handle a \">quit\" debug command as if an interrupt had occurred\n\t    \/\/ before the \":endtry\".  That is, throw an interrupt exception and\n\t    \/\/ set \"skip\" and \"rethrow\".\n\t    if (got_int)\n\t    {\n\t\tskip = TRUE;\n\t\t(void)do_intthrow(cstack);\n\t\t\/\/ The do_intthrow() call may have reset did_throw or\n\t\t\/\/ cstack->cs_pending[idx].\n\t\trethrow = FALSE;\n\t\tif (did_throw && !(cstack->cs_flags[idx] & CSF_FINALLY))\n\t\t    rethrow = TRUE;\n\t    }\n\t}\n\n\t\/*\n\t * If a \":return\" is pending, we need to resume it after closing the\n\t * try conditional; remember the return value.  If there was a finally\n\t * clause making an exception pending, we need to rethrow it.  Make it\n\t * the exception currently being thrown.\n\t *\/\n\tif (!skip)\n\t{\n\t    pending = cstack->cs_pending[idx];\n\t    cstack->cs_pending[idx] = CSTP_NONE;\n\t    if (pending == CSTP_RETURN)\n\t\trettv = cstack->cs_rettv[idx];\n\t    else if (pending & CSTP_THROW)\n\t\tcurrent_exception = cstack->cs_exception[idx];\n\t}\n\n\t\/*\n\t * Discard anything pending on an error, interrupt, or throw in the\n\t * finally clause.  If there was no \":finally\", discard a pending\n\t * \":continue\", \":break\", \":return\", or \":finish\" if an error or\n\t * interrupt occurred afterwards, but before the \":endtry\" was reached.\n\t * If an exception was caught by the last of the catch clauses and there\n\t * was no finally clause, finish the exception now.  This happens also\n\t * after errors except when this \":endtry\" is not within a \":try\".\n\t * Restore \"emsg_silent\" if it has been reset by this try conditional.\n\t *\/\n\t(void)cleanup_conditionals(cstack, CSF_TRY | CSF_SILENT, TRUE);\n\n\tif (cstack->cs_idx >= 0\n\t\t\t       && (cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n\t    leave_block(cstack);\n\t--cstack->cs_trylevel;\n\n\tif (!skip)\n\t{\n\t    report_resume_pending(pending,\n\t\t    (pending == CSTP_RETURN) ? rettv :\n\t\t    (pending & CSTP_THROW) ? (void *)current_exception : NULL);\n\t    switch (pending)\n\t    {\n\t\tcase CSTP_NONE:\n\t\t    break;\n\n\t\t\/\/ Reactivate a pending \":continue\", \":break\", \":return\",\n\t\t\/\/ \":finish\" from the try block or a catch clause of this try\n\t\t\/\/ conditional.  This is skipped, if there was an error in an\n\t\t\/\/ (unskipped) conditional command or an interrupt afterwards\n\t\t\/\/ or if the finally clause is present and executed a new error,\n\t\t\/\/ interrupt, throw, \":continue\", \":break\", \":return\", or\n\t\t\/\/ \":finish\".\n\t\tcase CSTP_CONTINUE:\n\t\t    ex_continue(eap);\n\t\t    break;\n\t\tcase CSTP_BREAK:\n\t\t    ex_break(eap);\n\t\t    break;\n\t\tcase CSTP_RETURN:\n\t\t    do_return(eap, FALSE, FALSE, rettv);\n\t\t    break;\n\t\tcase CSTP_FINISH:\n\t\t    do_finish(eap, FALSE);\n\t\t    break;\n\n\t\t\/\/ When the finally clause was entered due to an error,\n\t\t\/\/ interrupt or throw (as opposed to a \":continue\", \":break\",\n\t\t\/\/ \":return\", or \":finish\"), restore the pending values of\n\t\t\/\/ did_emsg, got_int, and did_throw.  This is skipped, if there\n\t\t\/\/ was a new error, interrupt, throw, \":continue\", \":break\",\n\t\t\/\/ \":return\", or \":finish\".  in the finally clause.\n\t\tdefault:\n\t\t    if (pending & CSTP_ERROR)\n\t\t\tdid_emsg = TRUE;\n\t\t    if (pending & CSTP_INTERRUPT)\n\t\t\tgot_int = TRUE;\n\t\t    if (pending & CSTP_THROW)\n\t\t\trethrow = TRUE;\n\t\t    break;\n\t    }\n\t}\n\n\tif (rethrow)\n\t    \/\/ Rethrow the current exception (within this cstack).\n\t    do_throw(cstack);\n    }\n}","target":1,"flaw_line_index":0,"hash":"fe05f49d-c40e-4ce4-8099-8e1036b3e575","idx":"ded14d33-e01c-465f-bfa8-672902d5c85c"}
{"func_before":"    cstack_T\t*cstack = eap->cstack;\n\n    if (cmdmod_error(FALSE))\n\treturn;\n\n    for (idx = cstack->cs_idx; idx >= 0; --idx)\n\tif (cstack->cs_flags[idx] & CSF_TRY)\n\t    break;\n    if (cstack->cs_trylevel <= 0 || idx < 0)\n    {\n\teap->errmsg = _(e_endtry_without_try);\n\treturn;\n    }\n\n    \/*\n     * Don't do something after an error, interrupt or throw in the try\n     * block, catch clause, or finally clause preceding this \":endtry\" or\n     * when an error or interrupt occurred after a \":continue\", \":break\",\n     * \":return\", or \":finish\" in a try block or catch clause preceding this\n     * \":endtry\" or when the try block never got active (because of an\n     * inactive surrounding conditional or after an error or interrupt or\n     * throw) or when there is a surrounding conditional and it has been\n     * made inactive by a \":continue\", \":break\", \":return\", or \":finish\" in\n     * the finally clause.  The latter case need not be tested since then\n     * anything pending has already been discarded. *\/\n    skip = did_emsg || got_int || did_throw\n\t\t\t     || !(cstack->cs_flags[cstack->cs_idx] & CSF_TRUE);\n\n    if (!(cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n    {\n\teap->errmsg = get_end_emsg(cstack);\n\n\t\/\/ Find the matching \":try\" and report what's missing.\n\trewind_conditionals(cstack, idx, CSF_WHILE | CSF_FOR,\n\t\t\t\t\t\t\t&cstack->cs_looplevel);\n\tskip = TRUE;\n\n\t\/*\n\t * If an exception is being thrown, discard it to prevent it from\n\t * being rethrown at the end of this function.  It would be\n\t * discarded by the error message, anyway.  Resets did_throw.\n\t * This does not affect the script termination due to the error\n\t * since \"trylevel\" is decremented after emsg() has been called.\n\t *\/\n\tif (did_throw)\n\t    discard_current_exception();\n\n\t\/\/ report eap->errmsg, also when there already was an error\n\tdid_emsg = FALSE;\n    }\n    else\n    {\n\tidx = cstack->cs_idx;\n\n\t\/\/ Check the flags only when not in a skipped block.\n\tif (!skip && in_vim9script()\n\t\t     && (cstack->cs_flags[idx] & (CSF_CATCH|CSF_FINALLY)) == 0)\n\t{\n\t    \/\/ try\/endtry without any catch or finally: give an error and\n\t    \/\/ continue.\n\t    eap->errmsg = _(e_missing_catch_or_finally);\n\t}\n\n\t\/*\n\t * If we stopped with the exception currently being thrown at this\n\t * try conditional since we didn't know that it doesn't have\n\t * a finally clause, we need to rethrow it after closing the try\n\t * conditional.\n\t *\/\n\tif (did_throw && (cstack->cs_flags[idx] & CSF_TRUE)\n\t\t&& !(cstack->cs_flags[idx] & CSF_FINALLY))\n\t    rethrow = TRUE;\n    }\n\n    \/\/ If there was no finally clause, show the user when debugging or\n    \/\/ a breakpoint was encountered that the end of the try conditional has\n    \/\/ been reached: display the debug prompt (if not already done).  Do\n    \/\/ this on normal control flow or when an exception was thrown, but not\n    \/\/ on an interrupt or error not converted to an exception or when\n    \/\/ a \":break\", \":continue\", \":return\", or \":finish\" is pending.  These\n    \/\/ actions are carried out immediately.\n    if ((rethrow || (!skip && !(cstack->cs_flags[idx] & CSF_FINALLY)\n\t\t    && !cstack->cs_pending[idx]))\n\t    && dbg_check_skipped(eap))\n    {\n\t\/\/ Handle a \">quit\" debug command as if an interrupt had occurred\n\t\/\/ before the \":endtry\".  That is, throw an interrupt exception and\n\t\/\/ set \"skip\" and \"rethrow\".\n\tif (got_int)\n\t{\n\t    skip = TRUE;\n\t    (void)do_intthrow(cstack);\n\t    \/\/ The do_intthrow() call may have reset did_throw or\n\t    \/\/ cstack->cs_pending[idx].\n\t    rethrow = FALSE;\n\t    if (did_throw && !(cstack->cs_flags[idx] & CSF_FINALLY))\n\t\trethrow = TRUE;\n\t}\n    }\n\n    \/*\n     * If a \":return\" is pending, we need to resume it after closing the\n     * try conditional; remember the return value.  If there was a finally\n     * clause making an exception pending, we need to rethrow it.  Make it\n     * the exception currently being thrown.\n     *\/\n    if (!skip)\n    {\n\tpending = cstack->cs_pending[idx];\n\tcstack->cs_pending[idx] = CSTP_NONE;\n\tif (pending == CSTP_RETURN)\n\t    rettv = cstack->cs_rettv[idx];\n\telse if (pending & CSTP_THROW)\n\t    current_exception = cstack->cs_exception[idx];\n    }\n\n    \/*\n     * Discard anything pending on an error, interrupt, or throw in the\n     * finally clause.  If there was no \":finally\", discard a pending\n     * \":continue\", \":break\", \":return\", or \":finish\" if an error or\n     * interrupt occurred afterwards, but before the \":endtry\" was reached.\n     * If an exception was caught by the last of the catch clauses and there\n     * was no finally clause, finish the exception now.  This happens also\n     * after errors except when this \":endtry\" is not within a \":try\".\n     * Restore \"emsg_silent\" if it has been reset by this try conditional.\n     *\/\n    (void)cleanup_conditionals(cstack, CSF_TRY | CSF_SILENT, TRUE);\n\n    if (cstack->cs_idx >= 0 && (cstack->cs_flags[cstack->cs_idx] & CSF_TRY))\n\tleave_block(cstack);\n    --cstack->cs_trylevel;\n\n    if (!skip)\n    {\n\treport_resume_pending(pending,\n\t\t    (pending == CSTP_RETURN) ? rettv :\n\t\t    (pending & CSTP_THROW) ? (void *)current_exception : NULL);\n\tswitch (pending)\n\t{\n\t    case CSTP_NONE:\n\t\tbreak;\n\n\t    \/\/ Reactivate a pending \":continue\", \":break\", \":return\",\n\t    \/\/ \":finish\" from the try block or a catch clause of this try\n\t    \/\/ conditional.  This is skipped, if there was an error in an\n\t    \/\/ (unskipped) conditional command or an interrupt afterwards\n\t    \/\/ or if the finally clause is present and executed a new error,\n\t    \/\/ interrupt, throw, \":continue\", \":break\", \":return\", or\n\t    \/\/ \":finish\".\n\t    case CSTP_CONTINUE:\n\t\tex_continue(eap);\n\t\tbreak;\n\t    case CSTP_BREAK:\n\t\tex_break(eap);\n\t\tbreak;\n\t    case CSTP_RETURN:\n\t\tdo_return(eap, FALSE, FALSE, rettv);\n\t\tbreak;\n\t    case CSTP_FINISH:\n\t\tdo_finish(eap, FALSE);\n\t\tbreak;\n\n\t    \/\/ When the finally clause was entered due to an error,\n\t    \/\/ interrupt or throw (as opposed to a \":continue\", \":break\",\n\t    \/\/ \":return\", or \":finish\"), restore the pending values of\n\t    \/\/ did_emsg, got_int, and did_throw.  This is skipped, if there\n\t    \/\/ was a new error, interrupt, throw, \":continue\", \":break\",\n\t    \/\/ \":return\", or \":finish\".  in the finally clause.\n\t    default:\n\t\tif (pending & CSTP_ERROR)\n\t\t    did_emsg = TRUE;\n\t\tif (pending & CSTP_INTERRUPT)\n\t\t    got_int = TRUE;\n\t\tif (pending & CSTP_THROW)\n\t\t    rethrow = TRUE;\n\t\tbreak;\n\t}\n    }\n\n    if (rethrow)\n\t\/\/ Rethrow the current exception (within this cstack).\n\tdo_throw(cstack);\n}","target":0,"flaw_line_index":0,"hash":"e11307b9-8916-4858-991b-e941fb446d0d","idx":"5ffb7946-cac6-402d-a3fb-bfd90eb967dc"}
{"func_before":"\t *\/\n\tif (!ptr_is_dst_reg) {\n\t\ttmp = *dst_reg;\n\t\t*dst_reg = *ptr_reg;\n\t}\n\tret = push_stack(env, env->insn_idx + 1, env->insn_idx, true);\n\tif (!ptr_is_dst_reg && ret)\n\t\t*dst_reg = tmp;\n\treturn !ret ? REASON_STACK : 0;\n}","target":1,"flaw_line_index":0,"hash":"e386bd26-0762-4519-97c9-796e5410513b","idx":"f7892b8e-8a66-47fe-bda9-47eb830003da"}
{"func_before":"\t *\/\n\tif (!ptr_is_dst_reg) {\n\t\ttmp = *dst_reg;\n\t\t*dst_reg = *ptr_reg;\n\t}\n\tret = sanitize_speculative_path(env, NULL, env->insn_idx + 1,\n\t\t\t\t\tenv->insn_idx);\n\tif (!ptr_is_dst_reg && ret)\n\t\t*dst_reg = tmp;\n\treturn !ret ? REASON_STACK : 0;\n}","target":0,"flaw_line_index":0,"hash":"58ab1106-a21a-4b84-91f0-6b64e3750ceb","idx":"5cff0fa6-dc34-4ab5-9503-5b1dd4a79974"}
{"func_before":"                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, void *parm)\n{\n  YYFPRINTF (yyo, \"%s %s (\",\n             yykind < YYNTOKENS ? \"token\" : \"nterm\", yysymbol_name (yykind));\n\n  YY_LOCATION_PRINT (yyo, *yylocationp);\n  YYFPRINTF (yyo, \": \");\n  yy_symbol_value_print (yyo, yykind, yyvaluep, yylocationp, parm);\n  YYFPRINTF (yyo, \")\");\n}","target":1,"flaw_line_index":0,"hash":"27b42716-402a-4e71-877b-43a4f2078ed2","idx":"36af6266-2ea4-4292-a71e-8361b23c74da"}
{"func_before":"                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, void *parm)\n{\n  YYFPRINTF (yyo, \"%s %s (\",\n             yykind < YYNTOKENS ? \"token\" : \"nterm\", yysymbol_name (yykind));\n\n  YYLOCATION_PRINT (yyo, yylocationp);\n  YYFPRINTF (yyo, \": \");\n  yy_symbol_value_print (yyo, yykind, yyvaluep, yylocationp, parm);\n  YYFPRINTF (yyo, \")\");\n}","target":0,"flaw_line_index":0,"hash":"54fa261e-b0f4-495d-be57-02b920a56f1b","idx":"aea47bf8-4c69-4cad-934c-69e8ef351ab1"}
{"func_before":"\t\t\t\t\t\"        %s\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    <\/script>\\n\", jmethod, json,\n\t\t\t\t\tlocation ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \"window.location='%s';\\n\",\n\t\t\t\t\t\t\t\t\tlocation) :\n\t\t\t\t\t\t\t\t\t\"\");\n\tif (location == NULL) {\n\t\tif (javascript_method)\n\t\t\t*javascript_method = apr_pstrdup(r->pool, jmethod);\n\t\tif (javascript)","target":1,"flaw_line_index":0,"hash":"c12f8cda-026f-4393-a61d-589a1b4c1e4f","idx":"95a499ea-a88d-414a-9bde-e78c5caa450c"}
{"func_before":"\t\t\t\t\t\"        %s\"\n\t\t\t\t\t\"      }\\n\"\n\t\t\t\t\t\"    <\/script>\\n\", jmethod, json,\n\t\t\t\t\tlocation ?\n\t\t\t\t\t\t\tapr_psprintf(r->pool, \"window.location='%s';\\n\",\n\t\t\t\t\t\t\t\t\toidc_util_javascript_escape(r->pool, location)) :\n\t\t\t\t\t\t\t\t\t\"\");\n\tif (location == NULL) {\n\t\tif (javascript_method)\n\t\t\t*javascript_method = apr_pstrdup(r->pool, jmethod);\n\t\tif (javascript)","target":0,"flaw_line_index":0,"hash":"d0792930-17af-4817-88a9-0b77daaa9d51","idx":"01bb6823-72b9-49a2-83d5-8a496318b8a1"}
{"func_before":"\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getacl(xdr, rqstp, &res->acl_len);\n\nout:\n\treturn status;\n}","target":1,"flaw_line_index":0,"hash":"eb8c2745-8dbd-440e-b835-45715ebceef5","idx":"1fdeb2d4-133e-4ca0-8154-4e0cd0049340"}
{"func_before":"\tif (status)\n\t\tgoto out;\n\tstatus = decode_putfh(xdr);\n\tif (status)\n\t\tgoto out;\n\tstatus = decode_getacl(xdr, rqstp, res);\n\nout:\n\treturn status;\n}","target":0,"flaw_line_index":0,"hash":"1b56c06c-61a7-4d79-a7d9-85705a562a4d","idx":"7dcb6bf8-adb3-4cbd-9891-418acd37f491"}
{"func_before":"struct key *find_keyring_by_name(const char *name, bool skip_perm_check)\n{\n\tstruct key *keyring;\n\tint bucket;\n\n\tif (!name)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (!skip_perm_check &&\n\t\t\t    key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\tcontinue;\n\n\t\t\t\/* we've got a match but we might end up racing with\n\t\t\t * key_cleanup() if the keyring is currently 'dead'\n\t\t\t * (ie. it has a zero usage count) *\/\n\t\t\tif (!refcount_inc_not_zero(&keyring->usage))","target":1,"flaw_line_index":0,"hash":"cf00ddbe-2a72-44be-8b81-5ad5644e8379","idx":"046a89d6-0f11-4279-a537-f79da1f1a9cb"}
{"func_before":"struct key *find_keyring_by_name(const char *name, bool uid_keyring)\n{\n\tstruct key *keyring;\n\tint bucket;\n\n\tif (!name)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (uid_keyring) {\n\t\t\t\tif (!test_bit(KEY_FLAG_UID_KEYRING,\n\t\t\t\t\t      &keyring->flags))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t\/* we've got a match but we might end up racing with\n\t\t\t * key_cleanup() if the keyring is currently 'dead'\n\t\t\t * (ie. it has a zero usage count) *\/\n\t\t\tif (!refcount_inc_not_zero(&keyring->usage))","target":0,"flaw_line_index":0,"hash":"8bfd744d-226a-4f9d-b1e7-5b03a8f50f04","idx":"eb4a7b80-6a2f-4782-8c6a-06e647b864de"}
{"func_before":"static int dev_get_valid_name(struct net *net,\n\t\t\t      struct net_device *dev,\n\t\t\t      const char *name)\n{\n\tBUG_ON(!net);\n\n\tif (!dev_valid_name(name))\n\t\treturn -EINVAL;\n\n\tif (strchr(name, '%'))\n\t\treturn dev_alloc_name_ns(net, dev, name);\n\telse if (__dev_get_by_name(net, name))\n\t\treturn -EEXIST;\n\telse if (dev->name != name)\n\t\tstrlcpy(dev->name, name, IFNAMSIZ);\n\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"084be92d-0c28-45ab-bcf7-87016e53ff52","idx":"5a8f5066-14fa-46a7-aef2-00bd09048d2d"}
{"func_before":"int dev_get_valid_name(struct net *net, struct net_device *dev,\n\t\t       const char *name)\n{\n\tBUG_ON(!net);\n\n\tif (!dev_valid_name(name))\n\t\treturn -EINVAL;\n\n\tif (strchr(name, '%'))\n\t\treturn dev_alloc_name_ns(net, dev, name);\n\telse if (__dev_get_by_name(net, name))\n\t\treturn -EEXIST;\n\telse if (dev->name != name)\n\t\tstrlcpy(dev->name, name, IFNAMSIZ);\n\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"926684e3-c496-4eff-9c5a-a2d0b72f97b3","idx":"b111d475-769e-40e7-ad95-804e9aa2615a"}
{"func_before":"          \/* the relative offset from type after common_entity_data *\/\n          \/\/ obj->common_size = bit_position(dat) - restartpos;\n          \/\/ LOG_HANDLE(\"common_size: %lu\\n\", obj->common_size); \/\/ needed for\n          \/\/ unknown\n          bit_set_position (dat, restartpos);\n\n          \/\/ obj->unknown_off = obj->unknown_pos - restartpos;\n          \/\/ LOG_TRACE(\"Unknown pos %lu, offset %lu\\n\", obj->unknown_pos,\n          \/\/ obj->unknown_off);\n\n          if (i >= 0 && i < (int)dwg->num_classes)\n            {\n              klass = &dwg->dwg_class[i];\n              is_entity = dwg_class_is_entity (klass);\n              else\n                {\n                  LOG_ERROR (\"Invalid class index %d >%d\", i,\n                             (int)dwg->num_classes);\n                }\n              obj->supertype = DWG_SUPERTYPE_UNKNOWN;\n              obj->type = 0;\n              *dat = abs_dat;\n              return error | DWG_ERR_VALUEOUTOFBOUNDS;\n            }\n          \/\/ properly dwg_decode_object\/_entity for eed, reactors, xdic\n          if (klass && !is_entity)\n            {\n              int err = dwg_decode_UNKNOWN_OBJ (dat, obj);\n              error |= err;\n              obj->supertype = DWG_SUPERTYPE_UNKNOWN;\n              if (!dat)\n                return error;\n              if (err >= DWG_ERR_CRITICAL)\n                *dat = abs_dat;\n            }\n          else if (klass) \/\/ is_entity\n            {\n              int err;\n#if 0 && !defined(IS_RELEASE)\n              if (strEQc(klass->dxfname, \"MULTILEADER\")) { \/\/debug CED\n                char *mleader = bit_read_TF(dat, obj->size);\n                LOG_INSANE_TF(mleader, (int)obj->size)\n                bit_set_position(dat, restartpos);\n                free (mleader);\n              }\n#endif\n              err = dwg_decode_UNKNOWN_ENT (dat, obj);\n              error |= err;\n              obj->supertype = DWG_SUPERTYPE_UNKNOWN;\n              if (!dat)\n                return error;\n              if (err >= DWG_ERR_CRITICAL)\n                *dat = abs_dat;\n            }\n          else \/\/ not a class\n            {\n              LOG_WARN (\"Unknown object, skipping eed\/reactors\/xdic\");\n              SINCE (R_2000)\n              {\n                obj->bitsize = bit_read_RL (dat);\n                LOG_TRACE (\"bitsize: \" FORMAT_RL \" [RL] @%lu.%u\\n\",\n                           obj->bitsize, dat->byte-2, dat->bit);\n                if (obj->bitsize > obj->size * 8)\n                  {\n                    LOG_ERROR (\"Invalid bitsize \" FORMAT_RL \" => \" FORMAT_RL,\n                               obj->bitsize, obj->size * 8);\n                    obj->bitsize = obj->size * 8;\n                    error |= DWG_ERR_VALUEOUTOFBOUNDS;\n                  }\n              }\n              if (!bit_read_H (dat, &obj->handle))\n                {\n                  LOG_TRACE (\"handle: \" FORMAT_H \" [H 5]\\n\",\n                             ARGS_H (obj->handle));\n                }\n              restartpos = dat->byte;\n              obj->supertype = DWG_SUPERTYPE_UNKNOWN;\n              obj->tio.unknown = bit_read_TF (dat, obj->size);\n              dat->byte = restartpos;\n            }\n        }\n    }\n\n  if (obj->handle.value)\n    { \/\/ empty only with UNKNOWN","target":1,"flaw_line_index":0,"hash":"d4c2ca02-0e2b-4050-86ef-77e18141c877","idx":"49c3422e-eda3-436b-94f5-77e03b0d7651"}
{"func_before":"          \/* the relative offset from type after common_entity_data *\/\n          \/\/ obj->common_size = bit_position(dat) - restartpos;\n          \/\/ LOG_HANDLE(\"common_size: %lu\\n\", obj->common_size); \/\/ needed for\n          \/\/ unknown\n          bit_set_position (dat, restartpos);\n          obj->supertype = DWG_SUPERTYPE_UNKNOWN;\n\n          if (i >= 0 && i < (int)dwg->num_classes)\n            {\n              klass = &dwg->dwg_class[i];\n              is_entity = dwg_class_is_entity (klass);\n                }\n              else\n                {\n                  LOG_ERROR (\"Invalid class index %d >%d\", i,\n                             (int)dwg->num_classes);\n                }\n              obj->type = 0;\n              *dat = abs_dat;\n              return error | DWG_ERR_VALUEOUTOFBOUNDS;\n            }\n          \/\/ properly dwg_decode_object\/_entity for eed, reactors, xdic\n          if (is_entity)\n              error |= dwg_decode_UNKNOWN_ENT (dat, obj);\n          else\n              error |= dwg_decode_UNKNOWN_OBJ (dat, obj);\n\n          if (!dat)\n            return error;\n          if (error >= DWG_ERR_CRITICAL)\n            *dat = abs_dat;\n        }\n    }\n\n  if (obj->handle.value)\n    { \/\/ empty only with UNKNOWN","target":0,"flaw_line_index":0,"hash":"7f708c49-0d69-4d23-a89b-fc7b85dbacb5","idx":"5f1f3b22-a1ee-4701-b175-a30b013313f6"}
{"func_before":"\tif (!ND_TTEST(pgm->pgm_dport)) {\n\t\tif (ip6) {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_dst)));\n\t\t\treturn;\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tipaddr_string(ndo, &ip->ip_src),\n\t\t\t\tipaddr_string(ndo, &ip->ip_dst)));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tsport = EXTRACT_16BITS(&pgm->pgm_sport);\n\tdport = EXTRACT_16BITS(&pgm->pgm_dport);\n\n\n\t    \/*\n\t     * Skip past the group, saving info along the way\n\t     * and stopping if we don't have enough.\n\t     *\/\n\t    bp += (2 * sizeof(uint16_t));\n\t    switch (EXTRACT_16BITS(bp)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in_addr);","target":1,"flaw_line_index":0,"hash":"4fbef86d-b1aa-4804-aaf9-ab191857b3b0","idx":"0d1fa726-0718-46ac-ac58-3e337170e086"}
{"func_before":"\tch = '\\0';\n\tif (!ND_TTEST(pgm->pgm_dport)) {\n\t\tif (ip6) {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_src),\n\t\t\t\tip6addr_string(ndo, &ip6->ip6_dst)));\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"%s > %s: [|pgm]\",\n\t\t\t\tipaddr_string(ndo, &ip->ip_src),\n\t\t\t\tipaddr_string(ndo, &ip->ip_dst)));\n\t\t}\n\t\treturn;\n\t}\n\n\tsport = EXTRACT_16BITS(&pgm->pgm_sport);\n\tdport = EXTRACT_16BITS(&pgm->pgm_dport);\n\n\t    \/*\n\t     * Skip past the group, saving info along the way\n\t     * and stopping if we don't have enough.\n\t     *\/\n\t    bp += (2 * sizeof(uint16_t));\n\t    ND_TCHECK_16BITS(bp);\n\t    switch (EXTRACT_16BITS(bp)) {\n\t    case AFNUM_INET:\n\t\tND_TCHECK2(*bp, sizeof(struct in_addr));\n\t\taddrtostr(bp, group_buf, sizeof(group_buf));\n\t\tbp += sizeof(struct in_addr);","target":0,"flaw_line_index":0,"hash":"2dd77cf9-947a-486b-b227-744e817a231c","idx":"ae136baf-6017-418f-a581-72977cafe277"}
{"func_before":"tTcpIpPacketParsingResult ParaNdis_CheckSumVerifyFlat(\n                                                PVOID pBuffer,\n                                                ULONG ulDataLength,\n                                                ULONG flags,\n                                                LPCSTR caller)\n{\n    tCompletePhysicalAddress SGBuffer;\n    SGBuffer.Virtual = pBuffer;\n    SGBuffer.size = ulDataLength;\n    return ParaNdis_CheckSumVerify(&SGBuffer, ulDataLength, 0, flags, caller);\n}","target":1,"flaw_line_index":0,"hash":"3df96f22-a1d3-400b-bb04-cb7e3170d11d","idx":"5d19faa5-3d89-4638-912f-dc9578f2b571"}
{"func_before":"tTcpIpPacketParsingResult ParaNdis_CheckSumVerifyFlat(\n                                                PVOID pBuffer,\n                                                ULONG ulDataLength,\n                                                ULONG flags,\n                                                BOOLEAN verifyLength,\n                                                LPCSTR caller)\n{\n    tCompletePhysicalAddress SGBuffer;\n    SGBuffer.Virtual = pBuffer;\n    SGBuffer.size = ulDataLength;\n    return ParaNdis_CheckSumVerify(&SGBuffer, ulDataLength, 0, flags, verifyLength, caller);\n}","target":0,"flaw_line_index":0,"hash":"c2d8f044-9fce-4153-ae28-b6959b06e7e3","idx":"5a8efec0-8651-4058-946b-d7e4231ce889"}
{"func_before":"\t\tunsigned long addr, *reg_addr;\n\t\tint err;\n\n\t\taddr = compute_effective_address(regs, insn,\n\t\t\t\t\t\t ((insn >> 25) & 0x1f));\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, addr);\n\t\tswitch (asi) {\n\t\tcase ASI_NL:\n\t\tcase ASI_AIUPL:\n\t\tcase ASI_AIUSL:\n\t\tcase ASI_PL:","target":1,"flaw_line_index":0,"hash":"3e5c3b7d-3207-4d92-a569-5708236f3ca8","idx":"439ddf85-0736-4993-928c-9169ff1ccaa7"}
{"func_before":"\t\tunsigned long addr, *reg_addr;\n\t\tint err;\n\n\t\taddr = compute_effective_address(regs, insn,\n\t\t\t\t\t\t ((insn >> 25) & 0x1f));\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, addr);\n\t\tswitch (asi) {\n\t\tcase ASI_NL:\n\t\tcase ASI_AIUPL:\n\t\tcase ASI_AIUSL:\n\t\tcase ASI_PL:","target":0,"flaw_line_index":0,"hash":"377a179c-29d5-4bab-9d89-a6435412d303","idx":"f877a1a6-0065-4c11-bbe7-f630d4e1aeb2"}
{"func_before":"\t\tDeleteRunner(ReferenceHandle& that, Local<Value> key_handle) :\n\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference} {\n\t\t\tthat.CheckDisposed();\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}","target":1,"flaw_line_index":0,"hash":"8a49c3aa-af38-4621-8a4b-b9821dbe7ce8","idx":"558d1680-a6f6-4888-a485-c6b4d467d614"}
{"func_before":"\t\tDeleteRunner(ReferenceHandle& that, Local<Value> key_handle) :\n\t\tAccessorRunner{that, key_handle} {}","target":0,"flaw_line_index":0,"hash":"9cd5104c-a613-40d0-a5d7-c7f3d5808283","idx":"caf3f469-ab99-41fc-92b9-b5f31417cfe3"}
{"func_before":"\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMTIMEOUT);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMFAILS);\n\n\tif ((qp->q.last_in & INET_FRAG_FIRST_IN) && qp->q.fragments != NULL) {\n\t\tstruct sk_buff *head = qp->q.fragments;\n\n\t\trcu_read_lock();\n\t\thead->dev = dev_get_by_index_rcu(net, qp->iif);\n\t\tif (!head->dev)\n\t\t\tgoto out_rcu_unlock;\n\n\t\t\/*\n\t\t * Only search router table for the head fragment,\n\t\t * when defraging timeout at PRE_ROUTING HOOK.\n\t\t *\/\n\t\tif (qp->user == IP_DEFRAG_CONNTRACK_IN && !skb_dst(head)) {\n\t\t\tconst struct iphdr *iph = ip_hdr(head);\n\t\t\tint err = ip_route_input(head, iph->daddr, iph->saddr,\n\t\t\t\t\t\t iph->tos, head->dev);\n\t\t\tif (unlikely(err))\n\t\t\t\tgoto out_rcu_unlock;\n\n\t\t\t\/*\n\t\t\t * Only an end host needs to send an ICMP\n\t\t\t * \"Fragment Reassembly Timeout\" message, per RFC792.\n\t\t\t *\/\n\t\t\tif (skb_rtable(head)->rt_type != RTN_LOCAL)\n\t\t\t\tgoto out_rcu_unlock;\n\n\t\t}\n\n\t\t\/* Send an ICMP \"Fragment Reassembly Timeout\" message. *\/\n\t\ticmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);\nout_rcu_unlock:\n\t\trcu_read_unlock();","target":1,"flaw_line_index":0,"hash":"317f22de-2157-483a-991d-ca1e08f4c905","idx":"ec6dbbba-423e-4f1e-938c-b45e542b58d4"}
{"func_before":"\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMTIMEOUT);\n\tIP_INC_STATS_BH(net, IPSTATS_MIB_REASMFAILS);\n\n\tif ((qp->q.last_in & INET_FRAG_FIRST_IN) && qp->q.fragments != NULL) {\n\t\tstruct sk_buff *head = qp->q.fragments;\n\t\tconst struct iphdr *iph;\n\t\tint err;\n\n\t\trcu_read_lock();\n\t\thead->dev = dev_get_by_index_rcu(net, qp->iif);\n\t\tif (!head->dev)\n\t\t\tgoto out_rcu_unlock;\n\n\t\t\/* skb dst is stale, drop it, and perform route lookup again *\/\n\t\tskb_dst_drop(head);\n\t\tiph = ip_hdr(head);\n\t\terr = ip_route_input_noref(head, iph->daddr, iph->saddr,\n\t\t\t\t\t   iph->tos, head->dev);\n\t\tif (err)\n\t\t\tgoto out_rcu_unlock;\n\n\t\t\/*\n\t\t * Only an end host needs to send an ICMP\n\t\t * \"Fragment Reassembly Timeout\" message, per RFC792.\n\t\t *\/\n\t\tif (qp->user == IP_DEFRAG_CONNTRACK_IN &&\n\t\t    skb_rtable(head)->rt_type != RTN_LOCAL)\n\t\t\tgoto out_rcu_unlock;\n\n\n\t\t\/* Send an ICMP \"Fragment Reassembly Timeout\" message. *\/\n\t\ticmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);\nout_rcu_unlock:\n\t\trcu_read_unlock();","target":0,"flaw_line_index":0,"hash":"e9942698-5ece-4c50-b0f5-c7d9af18e2a1","idx":"f4823023-1a4a-40bb-b09c-056c80622f95"}
{"func_before":"static int getnum (const char **fmt, int df) {\n  if (!isdigit(**fmt))  \/* no number? *\/\n    return df;  \/* return default value *\/\n  else {\n    int a = 0;\n    do {\n      a = a*10 + *((*fmt)++) - '0';\n    } while (isdigit(**fmt));\n    return a;\n  }\n}","target":1,"flaw_line_index":0,"hash":"383fe6fd-d181-4550-82f7-b622c4da3286","idx":"681aabbf-0641-4217-b1f8-94269c4d8f76"}
{"func_before":"static int getnum (lua_State *L, const char **fmt, int df) {\n  if (!isdigit(**fmt))  \/* no number? *\/\n    return df;  \/* return default value *\/\n  else {\n    int a = 0;\n    do {\n      if (a > (INT_MAX \/ 10) || a * 10 > (INT_MAX - (**fmt - '0')))\n        luaL_error(L, \"integral size overflow\");\n      a = a*10 + *((*fmt)++) - '0';\n    } while (isdigit(**fmt));\n    return a;\n  }\n}","target":0,"flaw_line_index":0,"hash":"8644d7d0-bd41-4215-b10f-387b7c7bfcb0","idx":"9e71aed6-7d79-44c7-8582-b1699f8edb60"}
{"func_before":"int mi_repair_by_sort(MI_CHECK *param, register MI_INFO *info,\n\t\t      const char * name, int rep_quick)\n{\n  int got_error;\n  uint i;\n  ulong length;\n  ha_rows start_records;\n  (void) end_io_cache(&info->rec_cache);\n  if (!got_error)\n  {\n    \/* Replace the actual file with the temporary file *\/\n    if (new_file >= 0)\n    {\n      mysql_file_close(new_file, MYF(0));\n      info->dfile=new_file= -1;\n      if (change_to_newfile(share->data_file_name,MI_NAME_DEXT, DATA_TMP_EXT,\n\t\t\t    (param->testflag & T_BACKUP_DATA ?\n\t\t\t     MYF(MY_REDEL_MAKE_BACKUP): MYF(0))) ||\n\t  mi_open_datafile(info,share,name,-1))\n\tgot_error=1;\n    }\n  }\n  if (got_error)","target":1,"flaw_line_index":0,"hash":"98964f9c-a8b9-476a-8914-1230a321abc4","idx":"fd3d66d1-275b-4ab7-8043-e4e178a17d54"}
{"func_before":"int mi_repair_by_sort(MI_CHECK *param, register MI_INFO *info,\n\t\t      const char * name, int rep_quick, my_bool no_copy_stat)\n{\n  int got_error;\n  uint i;\n  ulong length;\n  ha_rows start_records;\n  if (!got_error)\n  {\n    \/* Replace the actual file with the temporary file *\/\n    if (new_file >= 0)\n    {\n      myf flags= 0;\n      if (param->testflag & T_BACKUP_DATA)\n        flags |= MY_REDEL_MAKE_BACKUP;\n      if (no_copy_stat)\n        flags |= MY_REDEL_NO_COPY_STAT;\n      mysql_file_close(new_file, MYF(0));\n      info->dfile=new_file= -1;\n      if (change_to_newfile(share->data_file_name,MI_NAME_DEXT, DATA_TMP_EXT,\n                            flags) ||\n\t  mi_open_datafile(info,share,name,-1))\n\tgot_error=1;\n    }\n  }\n  if (got_error)","target":0,"flaw_line_index":0,"hash":"3a48002b-25e2-40e0-a11c-a022f6ac9559","idx":"a18ad2f4-ee1b-4b7f-9eef-64a712a4583d"}
{"func_before":"    \/\/ Parse default for 'clipboard'\n    (void)check_clipboard_option();\n#endif\n#ifdef FEAT_VARTABS\n    vim_free(curbuf->b_p_vsts_array);\n    tabstop_set(curbuf->b_p_vsts, &curbuf->b_p_vsts_array);\n    vim_free(curbuf->b_p_vts_array);\n    tabstop_set(curbuf->b_p_vts,  &curbuf->b_p_vts_array);\n#endif\n}","target":1,"flaw_line_index":0,"hash":"136e5843-191f-48c1-b132-4e6b45506bfa","idx":"5f565759-6708-4cc9-a60a-ca364c8d8627"}
{"func_before":"    \/\/ Parse default for 'clipboard'\n    (void)check_clipboard_option();\n#endif\n#ifdef FEAT_VARTABS\n    vim_free(curbuf->b_p_vsts_array);\n    (void)tabstop_set(curbuf->b_p_vsts, &curbuf->b_p_vsts_array);\n    vim_free(curbuf->b_p_vts_array);\n    (void)tabstop_set(curbuf->b_p_vts,  &curbuf->b_p_vts_array);\n#endif\n}","target":0,"flaw_line_index":0,"hash":"694d22c9-77d6-4377-bab5-673acc1889e3","idx":"f068c645-a15b-4ac7-9967-4ea048fdd5e1"}
{"func_before":"\tif (buf) {\n\t\tret = -ERANGE;\n\t\tif (acl_len > buflen)\n\t\t\tgoto out_free;\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n\t\t\t\tres.acl_len);\n\t}\n\tret = acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])","target":1,"flaw_line_index":0,"hash":"6240ea82-cc27-4f0a-99ea-59b40d638d73","idx":"3e264b9a-b884-4dd5-a8a3-2e2ce553d4f3"}
{"func_before":"\tif (buf) {\n\t\tret = -ERANGE;\n\t\tif (acl_len > buflen)\n\t\t\tgoto out_free;\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n\t\t\t\tacl_len);\n\t}\n\tret = acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])","target":0,"flaw_line_index":0,"hash":"3bac1221-0d1e-4e1c-9492-015b805532a4","idx":"088cb843-cc8b-45b6-b492-c2cf281145de"}
{"func_before":"check_restricted(void)\n{\n    if (restricted)\n    {\n\temsg(_(\"E145: Shell commands not allowed in rvim\"));\n\treturn TRUE;\n    }\n    return FALSE;\n}","target":1,"flaw_line_index":0,"hash":"230a811c-91fc-490c-a413-136203ee5229","idx":"744b8806-340b-41ba-9b10-46407710d5b5"}
{"func_before":"check_restricted(void)\n{\n    if (restricted)\n    {\n\temsg(_(\"E145: Shell commands and some functionality not allowed in rvim\"));\n\treturn TRUE;\n    }\n    return FALSE;\n}","target":0,"flaw_line_index":0,"hash":"c221a12d-8a89-4577-92a6-144862fa97a5","idx":"2cffb491-da6d-4077-b82b-85663b185154"}
{"func_before":"static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n}","target":1,"flaw_line_index":0,"hash":"a72afb7b-2c96-4a27-9734-ce0812b22c63","idx":"319e5489-8288-4b25-8da7-4c90515203a3"}
{"func_before":"static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n}","target":0,"flaw_line_index":0,"hash":"d5ec85f9-994d-4b30-a091-08efd6c9cdb0","idx":"42b49682-f045-487a-90cc-a7f8bdfb080e"}
{"func_before":"\t\/* memory allocation for include *\/\n\t\/* prevent an integer overflow issue *\/\n\tl_current_pi->include = 00;\n\tif (l_step_l <= (SIZE_MAX \/ (l_tcp->numlayers + 1U)))\n\t{\n\t\tl_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16));\n\t}\n\n\tif\n\t\t(!l_current_pi->include)\n\t{","target":1,"flaw_line_index":0,"hash":"1dd67a92-1342-406a-b399-b6650817cd88","idx":"a773429b-5349-4da2-a7da-aeef69d6255b"}
{"func_before":"\t\/* memory allocation for include *\/\n\t\/* prevent an integer overflow issue *\/\n\tl_current_pi->include = 00;\n\tif (l_step_l <= (SIZE_MAX \/ (l_tcp->numlayers + 1U)))\n\t{\n\t\tl_current_pi->include = (OPJ_INT16*) opj_calloc((size_t)(l_tcp->numlayers + 1U) * l_step_l, sizeof(OPJ_INT16));\n\t}\n\n\tif\n\t\t(!l_current_pi->include)\n\t{","target":0,"flaw_line_index":0,"hash":"78dc8872-ccb2-41c4-8ba6-06cb78df8354","idx":"cbf9707e-c109-4aad-8073-720ff3e83883"}
{"func_before":"          *strip_pixels;\n\n        \/*\n          Convert stripped TIFF image.\n        *\/\n        extent=4*MagickMax(image->columns*(samples_per_pixel+extra_samples)*\n          (image->depth+7)\/8,(size_t) TIFFStripSize(tiff));\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));","target":1,"flaw_line_index":0,"hash":"176e09f8-5ade-4392-b0c9-ff27706b34f3","idx":"ddfbbf04-9ee6-4e90-85ab-4ba301ba7cc9"}
{"func_before":"          *strip_pixels;\n\n        \/*\n          Convert stripped TIFF image.\n        *\/\n        extent=MagickMax(sizeof(uint32),(samples_per_pixel+extra_samples)*\n          (image->depth+7)\/8)*image->columns*rows_per_strip;\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));","target":0,"flaw_line_index":0,"hash":"42c5ffc6-0833-4855-b35c-4f62a216cf66","idx":"4bdf0bff-0fa4-4591-b206-93f0c4e5004b"}
{"func_before":"int ras_validate(jas_stream_t *in)\n{\n\tuchar buf[RAS_MAGICLEN];\n\tint i;\n\tint n;\n\tuint_fast32_t magic;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= RAS_MAGICLEN);","target":1,"flaw_line_index":0,"hash":"766c06d3-5b02-4638-a148-07c64ac2a4ef","idx":"99550a40-82b7-41ab-b823-de086582e0bf"}
{"func_before":"int ras_validate(jas_stream_t *in)\n{\n\tjas_uchar buf[RAS_MAGICLEN];\n\tint i;\n\tint n;\n\tuint_fast32_t magic;\n\n\tassert(JAS_STREAM_MAXPUTBACK >= RAS_MAGICLEN);","target":0,"flaw_line_index":0,"hash":"6587b954-0234-4344-913e-30663d15618f","idx":"321d2dec-2b1b-4b41-9940-4a319fe4c84c"}
{"func_before":"                  mBuffer = newBuffer;\n                  mBufferPos = 0;\n                  mBufferSize = size;\n                  \n                  DebugLog (<< \"Extra bytes after message: \" << overHang);\n                  DebugLog (<< Data(mBuffer, overHang));\n                  \n                  bytesRead = overHang;\n               }\n\n               \/\/ The message body is complete.\n            \/\/.jacob. Shouldn't the state also be set here?\n            return false;\n         }\n\n         mBufferPos += bytesRead;\n         if (mBufferPos == contentLength)\n         {\n            mMessage->addBuffer(mBuffer);\n            mMessage->setBody(mBuffer, (UInt32)contentLength);\n            mBuffer=0;\n            \/\/ .bwc. basicCheck takes up substantial CPU. Don't bother doing it\n            \/\/ if we're overloaded.\n            CongestionManager::RejectionBehavior b=mTransport->getRejectionBehaviorForIncoming();\n            if (b==CongestionManager::REJECTING_NON_ESSENTIAL\n                  || (b==CongestionManager::REJECTING_NEW_WORK\n               Transport::stampReceived(mMessage);\n               resip_assert( mTransport );\n               mTransport->pushRxMsgUp(mMessage);\n               mMessage = 0;\n            }\n            mConnState = NewMessage;\n         }\n         else if (mBufferPos == mBufferSize)\n         {\n            \/\/ .bwc. We've filled our buffer; go ahead and make more room.\n            size_t newSize = resipMin(mBufferSize*3\/2, contentLength);\n            char* newBuffer = 0;\n            try\n            {\n               newBuffer=new char[newSize];","target":1,"flaw_line_index":0,"hash":"050012e6-e9e3-4aa9-af65-7fba61c4ae72","idx":"27052836-659e-46bb-b1d0-dcce85ebb017"}
{"func_before":"                  mBuffer = newBuffer;\n                  mBufferPos = 0;\n                  mBufferSize = size;\n                  \n                  DebugLog (<< \"Extra bytes after message: \" << overHang);\n                  \/\/DebugLog (<< Data(mBuffer, overHang));\n                  \n                  bytesRead = overHang;\n               }\n\n               \/\/ The message body is complete.\n            \/\/.jacob. Shouldn't the state also be set here?\n            return false;\n         }\n\n         mBufferPos += bytesRead;\n         if (mBufferPos >= contentLength)\n         {\n            int overHang = mBufferPos - (int)contentLength;\n            char *overHangStart = mBuffer + contentLength;\n\n            mMessage->addBuffer(mBuffer);\n            mMessage->setBody(mBuffer, (UInt32)contentLength);\n            mConnState = NewMessage;\n            mBuffer = 0;\n\n            if (overHang > 0)\n            {\n                \/\/ The next message has been partially read.\n                size_t size = overHang * 3 \/ 2;\n                if (size < ConnectionBase::ChunkSize)\n                {\n                    size = ConnectionBase::ChunkSize;\n                }\n                char* newBuffer = MsgHeaderScanner::allocateBuffer((int)size);\n                memcpy(newBuffer, overHangStart, overHang);\n                mBuffer = newBuffer;\n                mBufferPos = 0;\n                mBufferSize = size;\n\n                DebugLog(<< \"Extra bytes after message: \" << overHang);\n                \/\/DebugLog(<< Data(mBuffer, overHang));\n\n                bytesRead = overHang;\n            }\n\n            \/\/ .bwc. basicCheck takes up substantial CPU. Don't bother doing it\n            \/\/ if we're overloaded.\n            CongestionManager::RejectionBehavior b=mTransport->getRejectionBehaviorForIncoming();\n            if (b==CongestionManager::REJECTING_NON_ESSENTIAL\n                  || (b==CongestionManager::REJECTING_NEW_WORK\n               Transport::stampReceived(mMessage);\n               resip_assert( mTransport );\n               mTransport->pushRxMsgUp(mMessage);\n               mMessage = 0;\n            }\n            \n            if (overHang > 0) \n            {\n               goto start;\n            }\n         }\n         else if (mBufferPos == mBufferSize)\n         {\n            \/\/ .bwc. We've filled our buffer and haven't read contentLength bytes yet; go ahead and make more room.\n            assert(contentLength >= mBufferSize);\n            size_t newSize = resipMin(mBufferSize*3\/2, contentLength);\n            char* newBuffer = 0;\n            try\n            {\n               newBuffer=new char[newSize];","target":0,"flaw_line_index":0,"hash":"9f1debde-c878-4d7a-bde0-6abca5dd424a","idx":"b39511ef-fd75-44b2-8cdd-c0a19e03ec97"}
{"func_before":"void fp4_write_bin(uint8_t *bin, int len, const fp4_t a) {\n\tif (len != 4 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp2_write_bin(bin, 2 * RLC_FP_BYTES, a[0], 0);","target":1,"flaw_line_index":0,"hash":"9ff8b4df-91ca-4176-934d-08e388cf411f","idx":"a9b3fb3e-8606-41b7-9206-d37f21a90b30"}
{"func_before":"void fp4_write_bin(uint8_t *bin, size_t len, const fp4_t a) {\n\tif (len != 4 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp2_write_bin(bin, 2 * RLC_FP_BYTES, a[0], 0);","target":0,"flaw_line_index":0,"hash":"6efbe572-5f1d-444d-98e6-48cebb9dae85","idx":"3fb94a2a-f91f-405c-b92e-2cbaf61216c2"}
{"func_before":"static int draw_legend(AVFilterContext *ctx, int samples)\n{\n    ShowSpectrumContext *s = ctx->priv;\n    AVFilterLink *inlink = ctx->inputs[0];\n    AVFilterLink *outlink = ctx->outputs[0];\n    int ch, y, x = 0, sz = s->orientation == VERTICAL ? s->w : s->h;","target":1,"flaw_line_index":0,"hash":"b82ca450-625f-4120-a327-c3edf6df409d","idx":"ace31796-7416-4aa1-a29e-298f02326473"}
{"func_before":"static int draw_legend(AVFilterContext *ctx, uint64_t samples)\n{\n    ShowSpectrumContext *s = ctx->priv;\n    AVFilterLink *inlink = ctx->inputs[0];\n    AVFilterLink *outlink = ctx->outputs[0];\n    int ch, y, x = 0, sz = s->orientation == VERTICAL ? s->w : s->h;","target":0,"flaw_line_index":0,"hash":"5d04c375-a9d0-4240-8494-230d84b94b1b","idx":"7db47f8e-42df-43df-a2d2-6e4ce61943c9"}
{"func_before":"void pdf_get_version(FILE *fp, pdf_t *pdf)\n{\n    char *header, *c;\n\n    header = get_header(fp);\n\n    \/* Locate version string start and make sure we dont go past header *\/\n    if ((c = strstr(header, \"%PDF-\")) && \n        (c + strlen(\"%PDF-M.m\") + 2))\n    {\n        pdf->pdf_major_version = atoi(c + strlen(\"%PDF-\"));\n        pdf->pdf_minor_version = atoi(c + strlen(\"%PDF-M.\"));\n    }\n","target":1,"flaw_line_index":0,"hash":"0b521b58-3c85-4b3e-a10b-a8bb036d2c42","idx":"b074c0b8-33f8-416c-b2b9-9d4982d42673"}
{"func_before":"void pdf_get_version(FILE *fp, pdf_t *pdf)\n{\n    char *header = get_header(fp);\n\n    \/* Locate version string start and make sure we dont go past header\n     * The format is %PDF-M.m, where 'M' is the major number and 'm' minor.\n     *\/\n    const char *c;\n    if ((c = strstr(header, \"%PDF-\")) && \n        ((c + 6)[0] == '.') && \/\/ Separator\n        isdigit((c + 5)[0]) && \/\/ Major number\n        isdigit((c + 7)[0]))   \/\/ Minor number\n    {\n        pdf->pdf_major_version = atoi(c + strlen(\"%PDF-\"));\n        pdf->pdf_minor_version = atoi(c + strlen(\"%PDF-M.\"));\n    }\n","target":0,"flaw_line_index":0,"hash":"95a37f2a-8426-4344-bf44-90b45299a0e9","idx":"44c1be8d-9c71-4d61-b3c0-8a8e0f186b29"}
{"func_before":"\tok = true;\n    }\n    else\n    {\n\tif (( parser.repeatNames () && value->isList ()) ||\n\t    (!parser.repeatNames () &&  (value->isString () || value->isInteger())) ||\n\t    path->component_str(0) == \"all\"\n\t    )\n\t    {\n\t\tok = true;\n\t\tif (parser.inifile.Write (path, value, parser.HaveRewrites ()))","target":1,"flaw_line_index":0,"hash":"e107c2c9-5bb0-4b27-84df-495c6e9aeae5","idx":"3b39b2b3-ba15-4646-98d5-71bfeeb66336"}
{"func_before":"\tok = true;\n    }\n    else\n    {\n\tif (( parser.repeatNames () && value->isList ()) ||\n\t    (!parser.repeatNames () &&  (value->isString () || value->isBoolean() || value->isInteger())) ||\n\t    path->component_str(0) == \"all\"\n\t    )\n\t    {\n\t\tok = true;\n\t\tif (parser.inifile.Write (path, value, parser.HaveRewrites ()))","target":0,"flaw_line_index":0,"hash":"33f5dbbc-f7da-4c42-a9f1-c5294c7c301f","idx":"96ef812d-fc01-4933-bde9-02c7dffc3cd2"}
{"func_before":"\tint n;\n\tconst struct pgstate *ps;\n\tconst u_char *ep = ndo->ndo_snapend;\n\n\tND_PRINT((ndo, \" wb-prep:\"));\n\tif (len < sizeof(*prep)) {\n\t\treturn (-1);\n\t}\n\tn = EXTRACT_32BITS(&prep->pp_n);\n\tps = (const struct pgstate *)(prep + 1);\n\twhile (--n >= 0 && ND_TTEST(*ps)) {\n\t\tconst struct id_off *io, *ie;\n\t\tchar c = '<';","target":1,"flaw_line_index":0,"hash":"2daf0e37-fa09-416a-a0df-6f3280a3468a","idx":"58a4820e-5565-4fcf-8f13-f662f735a88a"}
{"func_before":"\tint n;\n\tconst struct pgstate *ps;\n\tconst u_char *ep = ndo->ndo_snapend;\n\n\tND_PRINT((ndo, \" wb-prep:\"));\n\tif (len < sizeof(*prep) || !ND_TTEST(*prep))\n\t\treturn (-1);\n\tn = EXTRACT_32BITS(&prep->pp_n);\n\tps = (const struct pgstate *)(prep + 1);\n\twhile (--n >= 0 && ND_TTEST(*ps)) {\n\t\tconst struct id_off *io, *ie;\n\t\tchar c = '<';","target":0,"flaw_line_index":0,"hash":"04e319f5-939b-4a37-a477-bafbb9d74702","idx":"50a7c033-e56a-4821-a628-4e91b77474bb"}
{"func_before":"x509stack_peek_level(struct cert_stack *stack)\n{\n\tstruct repo_level_node *repo = SLIST_FIRST(&stack->levels);\n\treturn (repo != NULL) ? repo->level : 0;\n}","target":1,"flaw_line_index":0,"hash":"15c69a5a-a84b-4b09-a3a9-23cb085d8703","idx":"49f39ea6-76e0-456e-87e1-81fac1d37335"}
{"func_before":"x509stack_peek_level(struct cert_stack *stack)\n{\n\tstruct metadata_node *meta = SLIST_FIRST(&stack->metas);\n\treturn (meta != NULL) ? meta->level : 0;\n}","target":0,"flaw_line_index":0,"hash":"cb27e112-0ddd-4265-9620-1f083cba7c21","idx":"ed6ce240-6f81-49bd-911d-00c44135c341"}
{"func_before":"mptctl_getiocinfo (unsigned long arg, unsigned int data_size)\n{\n\tstruct mpt_ioctl_iocinfo __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_iocinfo *karg;\n\tMPT_ADAPTER\t\t*ioc;\n\tstruct pci_dev\t\t*pdev;\n\tint\t\t\tiocnum;\n\tunsigned int\t\tport;\n\tint\t\t\tcim_rev;\n\tstruct scsi_device \t*sdev;\n\tVirtDevice\t\t*vdevice;\n\n\tkarg = memdup_user(uarg, data_size);\n\tif (IS_ERR(karg)) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mpt_ioctl_iocinfo() - memdup_user returned error [%ld]\\n\",\n\t\t\t\t__FILE__, __LINE__, PTR_ERR(karg));\n\t\treturn PTR_ERR(karg);\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg->hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_getiocinfo() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\tkfree(karg);\n\t\treturn -ENODEV;\n\t}\n\n\t\/* Verify the data transfer size is correct. *\/\n\tif (karg->hdr.maxDataSize != data_size) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_getiocinfo - \"","target":1,"flaw_line_index":0,"hash":"3c73935d-bd9a-46a6-ac6b-a5c9d7f5469c","idx":"a22b53a0-35c1-4220-9836-baf17a4a0633"}
{"func_before":"mptctl_getiocinfo (MPT_ADAPTER *ioc, unsigned long arg, unsigned int data_size)\n{\n\tstruct mpt_ioctl_iocinfo __user *uarg = (void __user *) arg;\n\tstruct mpt_ioctl_iocinfo *karg;\n\tstruct pci_dev\t\t*pdev;\n\tunsigned int\t\tport;\n\tint\t\t\tcim_rev;\n\tstruct scsi_device \t*sdev;\n\tVirtDevice\t\t*vdevice;\n\n\n\tkarg = memdup_user(uarg, data_size);\n\tif (IS_ERR(karg)) {\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mpt_ioctl_iocinfo() - memdup_user returned error [%ld]\\n\",\n\t\t\t\t__FILE__, __LINE__, PTR_ERR(karg));\n\t\treturn PTR_ERR(karg);\n\t}\n\n\t\/* Verify the data transfer size is correct. *\/\n\tif (karg->hdr.maxDataSize != data_size) {\n\t\tprintk(MYIOC_s_ERR_FMT \"%s@%d::mptctl_getiocinfo - \"","target":0,"flaw_line_index":0,"hash":"5fbbfe22-8a84-4ad3-bb74-0a09f646df00","idx":"f8975688-c60c-4342-a6b1-f46658977e9e"}
{"func_before":"\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain == 0) {\n\t\t\t\/* 2.0.34: EOF is incorrect. We use 0 for\n\t\t\t * errors and EOF, just like fileGetbuf,\n\t\t\t * which is a simple fread() wrapper.\n\t\t\t * TBB. Original bug report: Daniel Cowgill. *\/\n\t\t\treturn 0; \/* NOT EOF *\/","target":1,"flaw_line_index":0,"hash":"ef4a47dd-462c-4295-9714-ff07c66a055c","idx":"9b609cc3-5fa7-42ea-afe8-e81762076a0a"}
{"func_before":"\n\tremain = dp->logicalSize - dp->pos;\n\tif(remain >= len) {\n\t\trlen = len;\n\t} else {\n\t\tif(remain <= 0) {\n\t\t\t\/* 2.0.34: EOF is incorrect. We use 0 for\n\t\t\t * errors and EOF, just like fileGetbuf,\n\t\t\t * which is a simple fread() wrapper.\n\t\t\t * TBB. Original bug report: Daniel Cowgill. *\/\n\t\t\treturn 0; \/* NOT EOF *\/","target":0,"flaw_line_index":0,"hash":"156b509e-0927-4fea-839b-f98dc44dc353","idx":"d68b666b-2edc-44fe-9051-6cca77cec428"}
{"func_before":"asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tstruct oabi_flock64 user;\n\tstruct flock64 kernel;\n\tmm_segment_t fs = USER_DS; \/* initialized to kill a warning *\/\n\tunsigned long local_arg = arg;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase F_OFD_GETLK:\n\tcase F_OFD_SETLK:\n\tcase F_OFD_SETLKW:\n\tcase F_GETLK64:\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\tif (copy_from_user(&user, (struct oabi_flock64 __user *)arg,\n\t\t\t\t   sizeof(user)))\n\t\t\treturn -EFAULT;\n\t\tkernel.l_type\t= user.l_type;\n\t\tkernel.l_whence\t= user.l_whence;\n\t\tkernel.l_start\t= user.l_start;\n\t\tkernel.l_len\t= user.l_len;\n\t\tkernel.l_pid\t= user.l_pid;\n\t\tlocal_arg = (unsigned long)&kernel;\n\t\tfs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t}\n\n\tret = sys_fcntl64(fd, cmd, local_arg);\n\n\tswitch (cmd) {\n\tcase F_GETLK64:\n\t\tif (!ret) {\n\t\t\tuser.l_type\t= kernel.l_type;\n\t\t\tuser.l_whence\t= kernel.l_whence;\n\t\t\tuser.l_start\t= kernel.l_start;\n\t\t\tuser.l_len\t= kernel.l_len;\n\t\t\tuser.l_pid\t= kernel.l_pid;\n\t\t\tif (copy_to_user((struct oabi_flock64 __user *)arg,\n\t\t\t\t\t &user, sizeof(user)))\n\t\t\t\tret = -EFAULT;\n\t\t}\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\tset_fs(fs);\n\t}\n\n\treturn ret;\n}","target":1,"flaw_line_index":0,"hash":"b86ea2e9-298e-4243-b8e1-444ab6aed074","idx":"997bd2a2-a746-4007-b5d2-c5a3c4c3acc3"}
{"func_before":"asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,\n\t\t\t\t unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase F_OFD_GETLK:\n\tcase F_OFD_SETLK:\n\tcase F_OFD_SETLKW:\n\tcase F_GETLK64:\n\tcase F_SETLK64:\n\tcase F_SETLKW64:\n\t\treturn do_locks(fd, cmd, arg);\n\n\tdefault:\n\t\treturn sys_fcntl64(fd, cmd, arg);\n\t}\n}","target":0,"flaw_line_index":0,"hash":"f5e00a70-bf1d-469e-907d-3127e1485444","idx":"9015f9c4-c65a-45bc-8d4a-01f7ccbbabbd"}
{"func_before":"\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\tTAILQ_FOREACH_REVERSE(m, &a->members, member_list, entries) {\n\t\t    matched = cmnd_matches_all(parse_tree, m, runchroot, info);\n\t\t    if (matched != UNSPEC) {\n\t\t\tif (negated)\n\t\t\t    matched = matched == ALLOW ? DENY : ALLOW;\n\t\t\tbreak;\n\t\t    }\n\t\t}","target":1,"flaw_line_index":0,"hash":"3f5f1be3-6715-4a55-aba0-9b6a3f255af8","idx":"dda009bb-ef8f-488e-94d9-b49777646c08"}
{"func_before":"\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\tTAILQ_FOREACH_REVERSE(m, &a->members, member_list, entries) {\n\t\t    matched = cmnd_matches_all(parse_tree, m, runchroot, info);\n\t\t    if (SPECIFIED(matched)) {\n\t\t\tif (negated)\n\t\t\t    matched = matched == ALLOW ? DENY : ALLOW;\n\t\t\tbreak;\n\t\t    }\n\t\t}","target":0,"flaw_line_index":0,"hash":"1debb5de-66dd-40d8-b16a-91ed2f026623","idx":"e8757070-1005-45f2-af47-0e908dcfdf72"}
{"func_before":"R_API int r_socket_ready(RSocket *s, int secs, int usecs) {\n#if __UNIX__\n\t\/\/int msecs = (1000 * secs) + (usecs \/ 1000);\n\tint msecs = (usecs \/ 1000);\n\tstruct pollfd fds[1];\n\tfds[0].fd = s->fd;\n\tfds[0].events = POLLIN | POLLPRI;\n\tfds[0].revents = POLLNVAL | POLLHUP | POLLERR;\n\treturn poll ((struct pollfd *)&fds, 1, msecs);\n#elif __WINDOWS__\n\tfd_set rfds;\n\tstruct timeval tv;\n\tif (s->fd == R_INVALID_SOCKET) {\n\t\treturn -1;\n\t}\n\tFD_ZERO (&rfds);\n\tFD_SET (s->fd, &rfds);\n\ttv.tv_sec = secs;\n\ttv.tv_usec = usecs;\n\treturn select (s->fd + 1, &rfds, NULL, NULL, &tv);\n#else\n\treturn true; \/* always ready if unknown *\/\n#endif\n}","target":1,"flaw_line_index":0,"hash":"e15acc46-3e58-4a8c-b0d0-aba834779fba","idx":"1c06e710-8b9f-47ad-bfd2-f5e8f8061147"}
{"func_before":"R_API int r_socket_ready(RSocket *s, int secs, int usecs) {\n\tfd_set rfds;\n\tstruct timeval tv = {secs, usecs};\n\tif (s->fd == R_INVALID_SOCKET) {\n\t\treturn -1;\n\t}\n\tFD_ZERO (&rfds);\n\tFD_SET (s->fd, &rfds);\n\treturn select (s->fd + 1, &rfds, NULL, NULL, &tv);\n}","target":0,"flaw_line_index":0,"hash":"2a83dc10-a4e7-4e18-ae71-38f746c907f8","idx":"048baad6-9103-475d-9da9-f538c828cef4"}
{"func_before":"void rose_start_hbtimer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tdel_timer(&rose->timer);\n\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->hb;\n\n\tadd_timer(&rose->timer);\n}","target":1,"flaw_line_index":0,"hash":"b85ca512-61ee-48a6-8090-cdd9bdd59903","idx":"6fe0ae73-52d1-4d5b-968b-1580dca48cff"}
{"func_before":"void rose_start_hbtimer(struct sock *sk)\n{\n\tstruct rose_sock *rose = rose_sk(sk);\n\n\tsk_stop_timer(sk, &rose->timer);\n\n\trose->timer.function = rose_timer_expiry;\n\trose->timer.expires  = jiffies + rose->hb;\n\n\tsk_reset_timer(sk, &rose->timer, rose->timer.expires);\n}","target":0,"flaw_line_index":0,"hash":"4e0dba68-4891-4391-8e36-d84307562e5b","idx":"89fcb288-6c0b-411b-98b0-eee11369f3dd"}
{"func_before":"    unsigned char index, idx;\n    unsigned short ta, tb;\n    unsigned short *pixels = (unsigned short *)s->frame.data[0];\n\n    int row_ptr = 0;\n    int pixel_ptr = 0;\n    int block_ptr;\n    int pixel_x, pixel_y;\n    int total_blocks;\n\n    \/* First byte is always 0xe1. Warn if it's different *\/\n\n        \/* Fill blocks with one color *\/\n        case 0xa0:\n            colorA = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n            while (n_blocks--) {\n                block_ptr = row_ptr + pixel_ptr;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        pixels[block_ptr] = colorA;\n                        block_ptr++;\n                    }\n                    block_ptr += row_inc;\n                }\n                ADVANCE_BLOCK();\n            }\n            break;\n\n        \/* Fill blocks with 4 colors *\/\n        case 0xc0:\n            color4[1] |= ((11 * ta + 21 * tb) >> 5);\n            color4[2] |= ((21 * ta + 11 * tb) >> 5);\n\n            if (s->size - stream_ptr < n_blocks * 4)\n                return;\n            while (n_blocks--) {\n                block_ptr = row_ptr + pixel_ptr;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    index = s->buf[stream_ptr++];\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        idx = (index >> (2 * (3 - pixel_x))) & 0x03;\n                        pixels[block_ptr] = color4[idx];\n                        block_ptr++;\n                    }\n                    block_ptr += row_inc;\n                }\n                ADVANCE_BLOCK();\n            }\n            break;\n\n        \/* Fill block with 16 colors *\/\n        case 0x00:\n            if (s->size - stream_ptr < 16)\n                return;\n            block_ptr = row_ptr + pixel_ptr;\n            for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                    \/* We already have color of upper left pixel *\/\n                    if ((pixel_y != 0) || (pixel_x !=0)) {\n                    pixels[block_ptr] = colorA;\n                    block_ptr++;\n                }\n                block_ptr += row_inc;\n            }\n            ADVANCE_BLOCK();\n            break;\n\n        \/* Unknown opcode *\/\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Unknown opcode %d in rpza chunk.\"","target":1,"flaw_line_index":0,"hash":"2cd66ad7-08ff-44f6-9563-006a2b50b4a0","idx":"27a8e8f9-6721-4272-a62b-de12893f3557"}
{"func_before":"    unsigned char index, idx;\n    unsigned short ta, tb;\n    unsigned short *pixels = (unsigned short *)s->frame.data[0];\n\n    int row_ptr = 0;\n    int pixel_ptr = -4;\n    int block_ptr;\n    int pixel_x, pixel_y;\n    int total_blocks;\n\n    \/* First byte is always 0xe1. Warn if it's different *\/\n        \/* Fill blocks with one color *\/\n        case 0xa0:\n            colorA = AV_RB16 (&s->buf[stream_ptr]);\n            stream_ptr += 2;\n            while (n_blocks--) {\n                ADVANCE_BLOCK()\n                block_ptr = row_ptr + pixel_ptr;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        pixels[block_ptr] = colorA;\n                        block_ptr++;\n                    }\n                    block_ptr += row_inc;\n                }\n            }\n            break;\n\n        \/* Fill blocks with 4 colors *\/\n        case 0xc0:\n            color4[2] |= ((21 * ta + 11 * tb) >> 5);\n\n            if (s->size - stream_ptr < n_blocks * 4)\n                return;\n            while (n_blocks--) {\n                ADVANCE_BLOCK();\n                block_ptr = row_ptr + pixel_ptr;\n                for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                    index = s->buf[stream_ptr++];\n                    for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                        idx = (index >> (2 * (3 - pixel_x))) & 0x03;\n                        pixels[block_ptr] = color4[idx];\n                        block_ptr++;\n                    }\n                    block_ptr += row_inc;\n                }\n            }\n            break;\n\n        \/* Fill block with 16 colors *\/\n        case 0x00:\n            if (s->size - stream_ptr < 16)\n                return;\n            ADVANCE_BLOCK();\n            block_ptr = row_ptr + pixel_ptr;\n            for (pixel_y = 0; pixel_y < 4; pixel_y++) {\n                for (pixel_x = 0; pixel_x < 4; pixel_x++){\n                    \/* We already have color of upper left pixel *\/\n                    if ((pixel_y != 0) || (pixel_x !=0)) {\n                    }\n                    pixels[block_ptr] = colorA;\n                    block_ptr++;\n                }\n                block_ptr += row_inc;\n            }\n            break;\n\n        \/* Unknown opcode *\/\n        default:\n            av_log(s->avctx, AV_LOG_ERROR, \"Unknown opcode %d in rpza chunk.\"","target":0,"flaw_line_index":0,"hash":"42e4dafe-cda5-4cc4-b45b-c1e7d3989ce4","idx":"7a4091d7-1c3b-46e6-92b4-764e302dd6d2"}
{"func_before":"\n\t\/* Do not send cong updates to IB loopback *\/\n\tif (conn->c_loopback\n\t    && rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\treturn sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;\n\t}\n\n\t\/* FIXME we may overallocate here *\/\n\tif (be32_to_cpu(rm->m_inc.i_hdr.h_len) == 0)\n\t\ti = 1;","target":1,"flaw_line_index":0,"hash":"aad16952-576d-4f23-b7cd-7d634a906e0a","idx":"c02a2b49-e7ab-48c2-b794-d1e55d428882"}
{"func_before":"\n\t\/* Do not send cong updates to IB loopback *\/\n\tif (conn->c_loopback\n\t    && rm->m_inc.i_hdr.h_flags & RDS_FLAG_CONG_BITMAP) {\n\t\trds_cong_map_updated(conn->c_fcong, ~(u64) 0);\n\t\tscat = &rm->data.op_sg[sg];\n\t\tret = sizeof(struct rds_header) + RDS_CONG_MAP_BYTES;\n\t\tret = min_t(int, ret, scat->length - conn->c_xmit_data_off);\n\t\treturn ret;\n\t}\n\n\t\/* FIXME we may overallocate here *\/\n\tif (be32_to_cpu(rm->m_inc.i_hdr.h_len) == 0)\n\t\ti = 1;","target":0,"flaw_line_index":0,"hash":"95dac32e-60de-4b5f-a20f-393c97038980","idx":"1100f170-48b9-4ee3-90d5-21a023450ada"}
{"func_before":"\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\trc = cmndlist_matches(parse_tree, &a->members, runchroot, info);\n\t\tif (rc != UNSPEC) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }","target":1,"flaw_line_index":0,"hash":"72aa2c8a-dbce-4413-8cf0-96b7f413d8bb","idx":"87c00332-065c-4c76-8529-8b6e98b83667"}
{"func_before":"\t    break;\n\tcase ALIAS:\n\t    a = alias_get(parse_tree, m->name, CMNDALIAS);\n\t    if (a != NULL) {\n\t\trc = cmndlist_matches(parse_tree, &a->members, runchroot, info);\n\t\tif (SPECIFIED(rc)) {\n\t\t    if (m->negated) {\n\t\t\tmatched = rc == ALLOW ? DENY : ALLOW;\n\t\t    } else {\n\t\t\tmatched = rc;\n\t\t    }","target":0,"flaw_line_index":0,"hash":"15456516-53eb-4fe5-9415-b7ddc291ea4c","idx":"3c1493d8-9029-408e-a60b-70b6a2e0d13f"}
{"func_before":"escapes(cp, tp)\nconst char\t*cp;\nchar *tp;\n{\n    while (*cp) {\n\tint\tcval = 0, meta = 0;\n\n\tif (*cp == '\\\\' && cp[1] && index(\"mM\", cp[1]) && cp[2]) {\n\t\tmeta = 1;\n\t\tcp += 2;\n\t}\n\tif (*cp == '\\\\' && cp[1] && index(\"0123456789xXoO\", cp[1]) && cp[2]) {\n\t    NEARDATA const char hex[] = \"00112233445566778899aAbBcCdDeEfF\";\n\t    const char *dp;\n\t    int dcount = 0;\n\n\t    cp++;\n\t    if (*cp == 'x' || *cp == 'X')\n\t\tfor (++cp; *cp && (dp = index(hex, *cp)) && (dcount++ < 2); cp++)\n\t\t    cval = (cval * 16) + ((int)(dp - hex) \/ 2);\n\t    else if (*cp == 'o' || *cp == 'O')\n\t\tfor (++cp; *cp && (index(\"01234567\",*cp)) && (dcount++ < 3); cp++)\n\t\t    cval = (cval * 8) + (*cp - '0');\n\t    else\n\t\tfor (; *cp && (index(\"0123456789\",*cp)) && (dcount++ < 3); cp++)\n\t\t    cval = (cval * 10) + (*cp - '0');\n\t} else if (*cp == '\\\\' && cp[1]) {\t\/* C-style character escapes *\/\n\t    switch (*++cp) {\n\t    case '\\\\': cval = '\\\\'; break;\n\t    case 'n': cval = '\\n'; break;\n\t    case 't': cval = '\\t'; break;\n\t    case 'b': cval = '\\b'; break;\n\t    case 'r': cval = '\\r'; break;\n\t    default: cval = *cp;\n\t    }\n\t    cp++;\n\t} else if (*cp == '^' && cp[1]) { \/* expand control-character syntax *\/\n\t    cval = (*++cp & 0x1f);\n\t    cp++;\n\t} else\n\t    cval = *cp++;\n\n\tif (meta)\n\t    cval |= 0x80;\n\t*tp++ = cval;\n    }\n    *tp = '\\0';\n}","target":1,"flaw_line_index":0,"hash":"c162d5f9-ef1b-42a5-b416-e34e03a202c4","idx":"63e26d31-95a0-4a8d-a84e-bfb2fd0c4c98"}
{"func_before":"escapes(cp, tp)\nconst char\t*cp;\nchar *tp;\n{\n    static NEARDATA const char\n\toct[] = \"01234567\", dec[] = \"0123456789\",\n\thex[] = \"00112233445566778899aAbBcCdDeEfF\";\n    const char *dp;\n    int cval, meta, dcount;\n\n    while (*cp) {\n\t\/* \\M has to be followed by something to do meta conversion,\n\t   otherwise it will just be \\M which ultimately yields 'M' *\/\n\tmeta = (*cp == '\\\\' && (cp[1] == 'm' || cp[1] == 'M') && cp[2]);\n\tif (meta) cp += 2;\n\n\tcval = dcount = 0; \/* for decimal, octal, hexadecimal cases *\/\n\tif ((*cp != '\\\\' && *cp != '^') || !cp[1]) {\n\t    \/* simple character, or nothing left for \\ or ^ to escape *\/\n\t    cval = *cp++;\n\t} else if (*cp == '^') {\t\/* expand control-character syntax *\/\n\t    cval = (*++cp & 0x1f);\n\t    ++cp;\n\t\/* remaining cases are all for backslash and we know cp[1] is not \\0 *\/\n\t} else if (index(dec, cp[1])) {\n\t    ++cp;\t\/* move past backslash to first digit *\/\n\t    do {\n\t\tcval = (cval * 10) + (*cp - '0');\n\t    } while (*++cp && index(dec, *cp) && ++dcount < 3);\n\t} else if ((cp[1] == 'o' || cp[1] == 'O') &&\n\t\tcp[2] && index(oct, cp[2])) {\n\t    cp += 2;\t\/* move past backslash and 'O' *\/\n\t    do {\n\t\tcval = (cval * 8) + (*cp - '0');\n\t    } while (*++cp && index(oct, *cp) && ++dcount < 3);\n\t} else if ((cp[1] == 'x' || cp[1] == 'X') &&\n\t\tcp[2] && (dp = index(hex, cp[2])) != 0) {\n\t    cp += 2;\t\/* move past backslash and 'X' *\/\n\t    do {\n\t\tcval = (cval * 16) + ((int)(dp - hex) \/ 2);\n\t    } while (*++cp && (dp = index(hex, *cp)) != 0 && ++dcount < 2);\n\t} else {\t\t\t\/* C-style character escapes *\/\n\t    switch (*++cp) {\n\t    case '\\\\': cval = '\\\\'; break;\n\t    case 'n': cval = '\\n'; break;\n\t    case 't': cval = '\\t'; break;\n\t    case 'b': cval = '\\b'; break;\n\t    case 'r': cval = '\\r'; break;\n\t    default: cval = *cp;\n\t    }\n\t    ++cp;\n\t}\n\n\tif (meta)\n\t    cval |= 0x80;\n\t*tp++ = (char)cval;\n    }\n    *tp = '\\0';\n}","target":0,"flaw_line_index":0,"hash":"f3ea4ed1-43b1-4417-b649-cc25df89eda7","idx":"50cc330c-99e2-45d9-935a-549074ddc625"}
{"func_before":"static BOOL update_recv_primary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBOOL rc = FALSE;\n\trdpContext* context = update->context;\n\trdpPrimaryUpdate* primary = update->primary;\n\tORDER_INFO* orderInfo = &(primary->order_info);\n\trdpSettings* settings = context->settings;\n\torderName = primary_order_string(orderInfo->orderType);\n\n\tif (!check_primary_order_supported(update->log, settings, orderInfo->orderType, orderName))\n\t\treturn FALSE;\n\n\tif (!update_read_field_flags(s, &(orderInfo->fieldFlags), flags,\n\t                             PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"update_read_field_flags() failed\");\n\t\treturn FALSE;\n\t}\n","target":1,"flaw_line_index":0,"hash":"1a20e241-a278-4dae-9a0a-df68fd907739","idx":"13e04076-6ad4-4895-8a2f-f3899df00c07"}
{"func_before":"static BOOL update_recv_primary_order(rdpUpdate* update, wStream* s, BYTE flags)\n{\n\tBYTE field;\n\tBOOL rc = FALSE;\n\trdpContext* context = update->context;\n\trdpPrimaryUpdate* primary = update->primary;\n\tORDER_INFO* orderInfo = &(primary->order_info);\n\trdpSettings* settings = context->settings;\n\torderName = primary_order_string(orderInfo->orderType);\n\n\tif (!check_primary_order_supported(update->log, settings, orderInfo->orderType, orderName))\n\t\treturn FALSE;\n\n\tfield = get_primary_drawing_order_field_bytes(orderInfo->orderType, &rc);\n\tif (!rc)\n\t\treturn FALSE;\n\n\tif (!update_read_field_flags(s, &(orderInfo->fieldFlags), flags, field))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"update_read_field_flags() failed\");\n\t\treturn FALSE;\n\t}\n","target":0,"flaw_line_index":0,"hash":"ffa64a6d-92e1-4b21-b409-b2e4a8d6799a","idx":"becadb12-2e75-4552-b207-230c641c4c8a"}
{"func_before":"      else\n        SAFE_E(fseek(fp, --pos, SEEK_SET), 0, \"Failed seek to xref \/Size.\\n\");\n\n    SAFE_E(fread(buf, 1, 21, fp), 21, \"Failed to load entry Size string.\\n\");\n    xref->n_entries = atoi(buf + strlen(\"ize \"));\n    xref->entries = calloc(1, xref->n_entries * sizeof(struct _xref_entry));\n\n    \/* Load entry data *\/\n    obj_id = 0;\n    fseek(fp, xref->start + strlen(\"xref\"), SEEK_SET);\n    added_entries = 0;","target":1,"flaw_line_index":0,"hash":"d1fca0d6-ea16-4376-9a6c-60dc95d0126a","idx":"1eb97455-4bf8-4a62-bd0c-31b93d32f2f7"}
{"func_before":"      else\n        SAFE_E(fseek(fp, --pos, SEEK_SET), 0, \"Failed seek to xref \/Size.\\n\");\n\n    SAFE_E(fread(buf, 1, 21, fp), 21, \"Failed to load entry Size string.\\n\");\n    xref->n_entries = atoi(buf + strlen(\"ize \"));\n    xref->entries = safe_calloc(xref->n_entries * sizeof(struct _xref_entry));\n\n    \/* Load entry data *\/\n    obj_id = 0;\n    fseek(fp, xref->start + strlen(\"xref\"), SEEK_SET);\n    added_entries = 0;","target":0,"flaw_line_index":0,"hash":"47030b5d-39e6-4d78-9f55-b97ed23cae37","idx":"a4daa580-55a9-4835-8573-5b73aa27b538"}
{"func_before":"    struct oe_sockaddr* addr,\n    oe_socklen_t* addrlen)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    oe_socklen_t addrlen_in = 0;\n\n    oe_errno = 0;\n\n    if (!sock)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (addrlen)\n        addrlen_in = *addrlen;\n\n    if (oe_syscall_getsockname_ocall(\n            &ret,\n            sock->host_fd,\n            (struct oe_sockaddr*)addr,\n            addrlen_in,\n            addrlen) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n\n    return ret;\n}","target":1,"flaw_line_index":0,"hash":"41610a00-0255-4c68-aa3a-abf280a760a3","idx":"210eeecb-5553-4b7e-a0c3-73e9b36af5aa"}
{"func_before":"    oe_socklen_t* addrlen)\n{\n    int ret = -1;\n    sock_t* sock = _cast_sock(sock_);\n    oe_socklen_t addrlen_in = 0;\n    oe_socklen_t addrlen_out = 0;\n\n    oe_errno = 0;\n\n    if (!sock || !addr || !addrlen)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    addrlen_in = *addrlen;\n    if (addrlen_in < 0)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_getsockname_ocall(\n            &ret, sock->host_fd, addr, addrlen_in, &addrlen_out) != OE_OK)\n    {\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\n    \/*\n     * Error out the case if the addrlen_out is greater than the size\n     * of sockaddr_storage.\n     *\/\n    if (addrlen_out > sizeof(struct oe_sockaddr_storage))\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    \/*\n     * Note that the returned value can still exceed the supplied one, which\n     * indicates a truncation. Refer to\n     * https:\/\/pubs.opengroup.org\/onlinepubs\/9699919799\/functions\/getsockname.html\n     * for more detail.\n     *\/\n    if (addrlen_in >= addrlen_out)\n        *addrlen = addrlen_out;\n\ndone:\n\n    return ret;\n}","target":0,"flaw_line_index":0,"hash":"35b6bce6-1634-4894-9a26-ffd34d3bccc7","idx":"61f22a62-2bb5-4fe6-b461-44cd445bcd69"}
{"func_before":"                        const u_char *tptr, u_int tlv_len)\n{\n    int subtype, hexdump = FALSE;\n    u_int sublen;\n    u_int tval;\n    uint8_t i;\n\n    if (tlv_len < 4) {\n        return hexdump;\n    }\n    subtype = *(tptr+3);\n        }\n        i=0;\n        ND_PRINT((ndo, \"\\n\\t    Application Priority Table\"));\n        while(i<sublen) {\n        \ttval=*(tptr+i+5);\n        \tND_PRINT((ndo, \"\\n\\t      Priority: %d, RES: %d, Sel: %d\",\n        \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07)));\n        \tND_PRINT((ndo, \"Protocol ID: %d\", EXTRACT_16BITS(tptr + i + 5)));\n        \ti=i+3;\n        }\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_EVB:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH){","target":1,"flaw_line_index":0,"hash":"6ea6f437-4a09-4e8f-8c3d-69b9f523b8a8","idx":"e50657f4-84dd-4fae-827f-edc94cb2d829"}
{"func_before":"                        const u_char *tptr, u_int tlv_len)\n{\n    int subtype, hexdump = FALSE;\n    u_int sublen;\n    u_int tval;\n    u_int i;\n\n    if (tlv_len < 4) {\n        return hexdump;\n    }\n    subtype = *(tptr+3);\n        }\n        i=0;\n        ND_PRINT((ndo, \"\\n\\t    Application Priority Table\"));\n        while(i<sublen) {\n        \ttval=*(tptr+i+5);\n        \tND_PRINT((ndo, \"\\n\\t      Priority: %u, RES: %u, Sel: %u, Protocol ID: %u\",\n        \t\t tval >> 5, (tval >> 3) & 0x03, (tval & 0x07),\n        \t\t EXTRACT_16BITS(tptr + i + 5)));\n        \ti=i+3;\n        }\n        break;\n    case LLDP_PRIVATE_8021_SUBTYPE_EVB:\n        if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH){","target":0,"flaw_line_index":0,"hash":"9836d1d0-30b2-4e71-a4ed-277281a03584","idx":"c93f1310-0b0a-426b-a346-7d29558be58f"}
{"func_before":"void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->MaxLen < 1)\n\t\tfields->MaxLen = fields->Len;\n\n\tStream_Write_UINT16(s, fields->Len); \/* Len (2 bytes) *\/\n\tStream_Write_UINT16(s, fields->MaxLen); \/* MaxLen (2 bytes) *\/\n\tStream_Write_UINT32(s, fields->BufferOffset); \/* BufferOffset (4 bytes) *\/\n}","target":1,"flaw_line_index":0,"hash":"4c038799-4fba-4c3d-88ed-046497d8750a","idx":"68f6abdc-9a1c-4737-acf4-0ae90a91dce0"}
{"func_before":"static void ntlm_write_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (fields->MaxLen < 1)\n\t\tfields->MaxLen = fields->Len;\n\n\tStream_Write_UINT16(s, fields->Len); \/* Len (2 bytes) *\/\n\tStream_Write_UINT16(s, fields->MaxLen); \/* MaxLen (2 bytes) *\/\n\tStream_Write_UINT32(s, fields->BufferOffset); \/* BufferOffset (4 bytes) *\/\n}","target":0,"flaw_line_index":0,"hash":"cf8a179c-e61e-48f2-925f-1935ac4a9f78","idx":"3ef50baa-722a-4cca-9bed-cc4203989113"}
{"func_before":"\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tconst int keyRequiredChars = worstCase * keyLen;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tconst int valueRequiredChars = worstCase * valueLen;\n\n\t\tif (dest == NULL) {\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);","target":1,"flaw_line_index":0,"hash":"7a2e8b9e-495c-484f-bc4f-d6ec8c3a0ff5","idx":"061d4740-78a1-4c4c-8aeb-5e92a432e6fc"}
{"func_before":"\twhile (queryList != NULL) {\n\t\tconst URI_CHAR * const key = queryList->key;\n\t\tconst URI_CHAR * const value = queryList->value;\n\t\tconst int worstCase = (normalizeBreaks == URI_TRUE ? 6 : 3);\n\t\tconst int keyLen = (key == NULL) ? 0 : (int)URI_STRLEN(key);\n\t\tint keyRequiredChars;\n\t\tconst int valueLen = (value == NULL) ? 0 : (int)URI_STRLEN(value);\n\t\tint valueRequiredChars;\n\n\t\tif ((keyLen >= INT_MAX \/ worstCase) || (valueLen >= INT_MAX \/ worstCase)) {\n\t\t\treturn URI_ERROR_OUTPUT_TOO_LARGE;\n\t\t}\n\t\tkeyRequiredChars = worstCase * keyLen;\n\t\tvalueRequiredChars = worstCase * valueLen;\n\n\t\tif (dest == NULL) {\n\t\t\t(*charsRequired) += ampersandLen + keyRequiredChars + ((value == NULL)\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: 1 + valueRequiredChars);","target":0,"flaw_line_index":0,"hash":"cd1e2c1d-2490-4d40-a74d-0ff0af7d2d96","idx":"a3d928cb-bd4c-4a9f-847b-a5e3d7ee166c"}
{"func_before":"    TF_RETURN_IF_ERROR(\n        context->allocate_temp(DT_BOOL, TensorShape({N_full}), &visited_t));\n    auto visited = visited_t.vec<bool>();\n    visited.device(device) = visited.constant(false);\n\n    TF_RETURN_IF_ERROR(wrap_kernel_call(\n        GatherOriginalGradValuesKernel<T, Tindex>, \/*device=*\/device,\n        \/*size=*\/N, reverse_index_map, grad_values, d_values, visited));\n\n    \/\/ Now we mask out the visited values and sum the remaining ones (which\n    \/\/ correspond to the empty rows in the forward input) to compute\n    \/\/ d_default_value.\n","target":1,"flaw_line_index":0,"hash":"b13c4e54-1718-4470-bd30-c36cb11bdff9","idx":"d17366f5-be4d-4b23-82ba-8836845fc3d3"}
{"func_before":"    TF_RETURN_IF_ERROR(\n        context->allocate_temp(DT_BOOL, TensorShape({N_full}), &visited_t));\n    auto visited = visited_t.vec<bool>();\n    visited.device(device) = visited.constant(false);\n\n    if (N > 0) {\n      TF_RETURN_IF_ERROR(wrap_kernel_call(\n          GatherOriginalGradValuesKernel<T, Tindex>, \/*device=*\/device,\n          \/*size=*\/N, reverse_index_map, grad_values, d_values, visited));\n    }\n\n    \/\/ Now we mask out the visited values and sum the remaining ones (which\n    \/\/ correspond to the empty rows in the forward input) to compute\n    \/\/ d_default_value.\n","target":0,"flaw_line_index":0,"hash":"3a6ec191-9a77-40ab-bc97-11f4d25e7906","idx":"682429cd-e4da-461c-9610-38448b2c1c70"}
{"func_before":"\t}\n\n\tif (rt)\n\t\trt6_set_expires(rt, jiffies + (HZ * lifetime));\n\tif (ra_msg->icmph.icmp6_hop_limit) {\n\t\tin6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit;\n\t\tif (rt)\n\t\t\tdst_metric_set(&rt->dst, RTAX_HOPLIMIT,\n\t\t\t\t       ra_msg->icmph.icmp6_hop_limit);\n\t}\n","target":1,"flaw_line_index":0,"hash":"23a8fe2d-31df-4b1c-8fd7-528ee1f05e72","idx":"5de76e5c-bcc7-407e-ad26-fa543c439751"}
{"func_before":"\t}\n\n\tif (rt)\n\t\trt6_set_expires(rt, jiffies + (HZ * lifetime));\n\tif (ra_msg->icmph.icmp6_hop_limit) {\n\t\t\/* Only set hop_limit on the interface if it is higher than\n\t\t * the current hop_limit.\n\t\t *\/\n\t\tif (in6_dev->cnf.hop_limit < ra_msg->icmph.icmp6_hop_limit) {\n\t\t\tin6_dev->cnf.hop_limit = ra_msg->icmph.icmp6_hop_limit;\n\t\t} else {\n\t\t\tND_PRINTK(2, warn, \"RA: Got route advertisement with lower hop_limit than current\\n\");\n\t\t}\n\t\tif (rt)\n\t\t\tdst_metric_set(&rt->dst, RTAX_HOPLIMIT,\n\t\t\t\t       ra_msg->icmph.icmp6_hop_limit);\n\t}\n","target":0,"flaw_line_index":0,"hash":"a8e199f4-cb14-4991-b3b3-d109532516e3","idx":"08c50f8a-9f17-444a-b4bf-c38ed25f7842"}
{"func_before":"\tpid_t init_pid, pid, attached_pid, expected;\n\tstruct lxc_proc_context_info *init_ctx;\n\tchar* cwd;\n\tchar* new_cwd;\n\tint ipc_sockets[2];\n\tint procfd;\n\tsigned long personality;\n\n\tif (!options)\n\t\toptions = &attach_static_default_options;\n\n\t *                          then exit\n\t *    send 0 ------------------------------------>    X\n\t *                                              [do initialization]\n\t *        X  <------------------------------------  send 1\n\t *   [add to cgroup, ...]\n\t *    send 2 ------------------------------------>    X\n\t *   close socket                                 close socket\n\t *                                                run program\n\t *\/\n\tret = socketpair(PF_LOCAL, SOCK_STREAM | SOCK_CLOEXEC, 0, ipc_sockets);\n\tif (ret < 0) {\n\t\tfree(cwd);\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\n\tif (pid) {\n\t\tpid_t to_cleanup_pid = pid;\n\n\t\t\/* initial thread, we close the socket that is for the\n\t\t * subprocesses\n\t\t *\/\n\t\t\/* attach to cgroup, if requested *\/\n\t\tif (options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) {\n\t\t\tif (!cgroup_attach(name, lxcpath, pid))\n\t\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t\/* Let the child process know to go ahead *\/\n\t\tstatus = 0;\n\t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"error using IPC to notify attached process for initialization (0)\");\n\t\t\/* wait for the attached process to finish initializing *\/\n\t\texpected = 1;\n\t\tret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);\n\t\tif (ret <= 0) {\n\t\t\tif (ret != 0)\n\t\t\t\tERROR(\"error using IPC to receive notification from attached process (1)\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t\/* tell attached process we're done *\/\n\t\tstatus = 2;\n\t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"error using IPC to notify attached process for initialization (2)\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t\/* now shut down communication with child, we're done *\/\n\t\tshutdown(ipc_sockets[0], SHUT_RDWR);\n\t\tclose(ipc_sockets[0]);\n\t\treturn 0;\n\n\tcleanup_error:\n\t\t\/* first shut down the socket, then wait for the pid,\n\t\t * otherwise the pid we're waiting for may never exit\n\t\t *\/\n\t\tshutdown(ipc_sockets[0], SHUT_RDWR);\n\t\tclose(ipc_sockets[0]);\n\t\tif (to_cleanup_pid)\n\t\t\t(void) wait_for_pid(to_cleanup_pid);\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\trexit(-1);\n\t}\n\n\tif ((options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) && cgns_supported())\n\t\toptions->namespaces |= CLONE_NEWCGROUP;\n\n\tprocfd = open(\"\/proc\", O_DIRECTORY | O_RDONLY);\n\tif (procfd < 0) {\n\t\tSYSERROR(\"Unable to open \/proc\");\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\t\/* attach now, create another subprocess later, since pid namespaces\n\t * only really affect the children of the current process\n\t *\/\n\tret = lxc_attach_to_ns(init_pid, options->namespaces);\n\t\t\t.ipc_socket = ipc_sockets[1],\n\t\t\t.options = options,\n\t\t\t.init_ctx = init_ctx,\n\t\t\t.exec_function = exec_function,\n\t\t\t.exec_payload = exec_payload,\n\t\t\t.procfd = procfd\n\t\t};\n\t\t\/* We use clone_parent here to make this subprocess a direct child of\n\t\t * the initial process. Then this intermediate process can exit and\n\t\t * the parent can directly track the attached process.\n\t\t *\/","target":1,"flaw_line_index":0,"hash":"471911da-7bc4-4574-b71e-5559b5aff5d9","idx":"4d92d596-a6aa-4986-98da-e470aebcc5e1"}
{"func_before":"\tint ret, status;\n\tpid_t init_pid, pid, attached_pid, expected;\n\tstruct lxc_proc_context_info *init_ctx;\n\tchar* cwd;\n\tchar* new_cwd;\n\tint ipc_sockets[2];\n\tsigned long personality;\n\n\tif (!options)\n\t\toptions = &attach_static_default_options;\n\n\t *    send 0 ------------------------------------>    X\n\t *                                              [do initialization]\n\t *        X  <------------------------------------  send 1\n\t *   [add to cgroup, ...]\n\t *    send 2 ------------------------------------>    X\n\t *\t\t\t\t\t\t[set LXC_ATTACH_NO_NEW_PRIVS]\n\t *        X  <------------------------------------  send 3\n\t *   [open LSM label fd]\n\t *    send 4 ------------------------------------>    X\n\t *   \t\t\t\t\t\t[set LSM label]\n\t *   close socket                                 close socket\n\t *                                                run program\n\t *\/\n\tret = socketpair(PF_LOCAL, SOCK_STREAM | SOCK_CLOEXEC, 0, ipc_sockets);\n\tif (ret < 0) {\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\treturn -1;\n\t}\n\n\tif (pid) {\n\t\tint procfd = -1;\n\t\tpid_t to_cleanup_pid = pid;\n\n\t\t\/* initial thread, we close the socket that is for the\n\t\t * subprocesses\n\t\t *\/\n\t\tif (options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) {\n\t\t\tif (!cgroup_attach(name, lxcpath, pid))\n\t\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t\/* Open \/proc before setns() to the containers namespace so we\n\t\t * don't rely on any information from inside the container.\n\t\t *\/\n\t\tprocfd = open(\"\/proc\", O_DIRECTORY | O_RDONLY | O_CLOEXEC);\n\t\tif (procfd < 0) {\n\t\t\tSYSERROR(\"Unable to open \/proc.\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t\/* Let the child process know to go ahead *\/\n\t\tstatus = 0;\n\t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"error using IPC to notify attached process for initialization (0)\");\n\t\t\/* wait for the attached process to finish initializing *\/\n\t\texpected = 1;\n\t\tret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);\n\t\tif (ret <= 0) {\n\t\t\tif (ret != 0)\n\t\t\t\tERROR(\"error using IPC to receive notification \"\n\t\t\t\t      \"from attached process (1)\");\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t\/* tell attached process we're done *\/\n\t\tstatus = 2;\n\t\tret = lxc_write_nointr(ipc_sockets[0], &status, sizeof(status));\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"Error using IPC to notify attached process for \"\n\t\t\t      \"initialization (2): %s.\", strerror(errno));\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t\/* Wait for the (grand)child to tell us that it's ready to set\n\t\t * up its LSM labels.\n\t\t *\/\n\t\texpected = 3;\n\t\tret = lxc_read_nointr_expect(ipc_sockets[0], &status, sizeof(status), &expected);\n\t\tif (ret <= 0) {\n\t\t\tERROR(\"Error using IPC for the child to tell us to open LSM fd (3): %s.\",\n\t\t\t      strerror(errno));\n\t\t\tgoto cleanup_error;\n\t\t}\n\n\t\t\/* Open LSM fd and send it to child. *\/\n\t\tif ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {\n\t\t\tint on_exec, labelfd;\n\t\t\ton_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;\n\t\t\t\/* Open fd for the LSM security module. *\/\n\t\t\tlabelfd = lsm_openat(procfd, attached_pid, on_exec);\n\t\t\tif (labelfd < 0)\n\t\t\t\tgoto cleanup_error;\n\n\t\t\t\/* Send child fd of the LSM security module to write to. *\/\n\t\t\tret = lxc_abstract_unix_send_fd(ipc_sockets[0], labelfd, NULL, 0);\n\t\t\tif (ret <= 0) {\n\t\t\t\tERROR(\"Error using IPC to send child LSM fd (4): %s.\",\n\t\t\t\t\t\tstrerror(errno));\n\t\t\t\tgoto cleanup_error;\n\t\t\t}\n\t\t}\n\n\t\t\/* now shut down communication with child, we're done *\/\n\t\tshutdown(ipc_sockets[0], SHUT_RDWR);\n\t\tclose(ipc_sockets[0]);\n\n\tcleanup_error:\n\t\t\/* first shut down the socket, then wait for the pid,\n\t\t * otherwise the pid we're waiting for may never exit\n\t\t *\/\n\t\tif (procfd >= 0)\n\t\t\tclose(procfd);\n\t\tshutdown(ipc_sockets[0], SHUT_RDWR);\n\t\tclose(ipc_sockets[0]);\n\t\tif (to_cleanup_pid)\n\t\t\t(void) wait_for_pid(to_cleanup_pid);\n\t\tlxc_proc_put_context_info(init_ctx);\n\t\tshutdown(ipc_sockets[1], SHUT_RDWR);\n\t\trexit(-1);\n\t}\n\n\tif ((options->attach_flags & LXC_ATTACH_MOVE_TO_CGROUP) && cgns_supported())\n\t\toptions->namespaces |= CLONE_NEWCGROUP;\n\n\t\/* attach now, create another subprocess later, since pid namespaces\n\t * only really affect the children of the current process\n\t *\/\n\tret = lxc_attach_to_ns(init_pid, options->namespaces);\n\t\tstruct attach_clone_payload payload = {\n\t\t\t.ipc_socket = ipc_sockets[1],\n\t\t\t.options = options,\n\t\t\t.init_ctx = init_ctx,\n\t\t\t.exec_function = exec_function,\n\t\t\t.exec_payload = exec_payload,\n\t\t};\n\t\t\/* We use clone_parent here to make this subprocess a direct child of\n\t\t * the initial process. Then this intermediate process can exit and\n\t\t * the parent can directly track the attached process.\n\t\t *\/","target":0,"flaw_line_index":0,"hash":"859a3de3-41ea-4590-a215-59f88021ddc1","idx":"15927127-61dd-4fdb-97e5-4faec05bb810"}
{"func_before":"\n    \/* Call cleanup routines. *\/\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->cleanup && !IS_DISABLED(auth)) {\n\t    int status = (auth->cleanup)(ctx, pw, auth, force);\n\t    if (status == AUTH_ERROR) {\n\t\t\/* Assume error msg already printed. *\/\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }","target":1,"flaw_line_index":0,"hash":"42c203d8-6fa2-4b99-b62f-c4b7d13399da","idx":"d060e166-565c-4b9b-b0ee-b7864b0797ff"}
{"func_before":"\n    \/* Call cleanup routines. *\/\n    for (auth = auth_switch; auth->name; auth++) {\n\tif (auth->cleanup && !IS_DISABLED(auth)) {\n\t    int status = (auth->cleanup)(ctx, pw, auth, force);\n\t    if (status != AUTH_SUCCESS) {\n\t\t\/* Assume error msg already printed. *\/\n\t\tdebug_return_int(-1);\n\t    }\n\t}\n    }","target":0,"flaw_line_index":0,"hash":"277fad50-1a17-4a00-9688-3d2863d44931","idx":"61b0cf53-47dc-4e81-830c-d1b112e06d55"}
{"func_before":"\tif (c->interfaces_offset > 0 &&\n\t    bin->header.data_offset < c->interfaces_offset &&\n\t    c->interfaces_offset <\n\t\t    bin->header.data_offset + bin->header.data_size) {\n\t\tp = r_buf_get_at (binfile->buf, c->interfaces_offset, NULL);\n\t\tint types_list_size = r_read_le32(p);\n\t\tif (types_list_size < 0 || types_list_size >= bin->header.types_size ) {\n\t\t\treturn;\n\t\t}\n\t\tfor (z = 0; z < types_list_size; z++) {\n\t\t\tint t = r_read_le16 (p + 4 + z * 2);","target":1,"flaw_line_index":0,"hash":"4cc5e607-401f-4914-aefd-b2ede44200ff","idx":"402ed4f7-f0a1-48dd-b2e0-8362a60fc5ac"}
{"func_before":"\tif (c->interfaces_offset > 0 &&\n\t    bin->header.data_offset < c->interfaces_offset &&\n\t    c->interfaces_offset <\n\t\t    bin->header.data_offset + bin->header.data_size) {\n\t\tp = r_buf_get_at (binfile->buf, c->interfaces_offset, NULL);\n\t\tint types_list_size = r_read_le32 (p);\n\t\tif (types_list_size < 0 || types_list_size >= bin->header.types_size ) {\n\t\t\treturn;\n\t\t}\n\t\tfor (z = 0; z < types_list_size; z++) {\n\t\t\tint t = r_read_le16 (p + 4 + z * 2);","target":0,"flaw_line_index":0,"hash":"8c485b36-8d9c-46d0-b3ed-6a21efe94646","idx":"71a6e7ce-f0d5-4a22-9a3c-f1d18bf9b07a"}
{"func_before":"\n\tif (thread)\n\t\tCloseHandle (thread);\n\n\tif (this->synch_cs) {\n\t\tDeleteCriticalSection (this->synch_cs);\n\t\tg_free (this->synch_cs);\n\t\tthis->synch_cs = NULL;\n\t}\n\n\tg_free (this->name);\n}","target":1,"flaw_line_index":0,"hash":"9a3e99a2-fb92-4dbe-8c4b-a192c59a0a90","idx":"b47ba17b-60b4-4f5c-a59a-213239ea05b1"}
{"func_before":"\n\tif (thread)\n\t\tCloseHandle (thread);\n\n\tif (this->synch_cs) {\n\t\tCRITICAL_SECTION *synch_cs = this->synch_cs;\n\t\tthis->synch_cs = NULL;\n\t\tDeleteCriticalSection (synch_cs);\n\t\tg_free (synch_cs);\n\t}\n\n\tif (this->name) {\n\t\tvoid *name = this->name;\n\t\tthis->name = NULL;\n\t\tg_free (name);\n\t}\n}","target":0,"flaw_line_index":0,"hash":"d4f1cf0e-5a7b-4315-87d8-2e71a9cdffab","idx":"52d86752-e9cd-4865-b240-7c9dc5c921d9"}
{"func_before":"static void record_and_restart(struct perf_event *event, unsigned long val,\n\t\t\t       struct pt_regs *regs, int nmi)\n{\n\tu64 period = event->hw.sample_period;\n\ts64 prev, delta, left;\n\tint record = 0;\n\n\t\tdata.period = event->hw.last_period;\n\n\t\tif (event->attr.sample_type & PERF_SAMPLE_ADDR)\n\t\t\tperf_get_data_addr(regs, &data.addr);\n\n\t\tif (perf_event_overflow(event, nmi, &data, regs))\n\t\t\tpower_pmu_stop(event, 0);\n\t}\n}","target":1,"flaw_line_index":0,"hash":"b26d585b-917d-4b6b-8caa-dddd768dc402","idx":"1d2fdae6-820c-4a2d-822e-4f1e09ab7ad6"}
{"func_before":"static void record_and_restart(struct perf_event *event, unsigned long val,\n\t\t\t       struct pt_regs *regs)\n{\n\tu64 period = event->hw.sample_period;\n\ts64 prev, delta, left;\n\tint record = 0;\n\n\t\tdata.period = event->hw.last_period;\n\n\t\tif (event->attr.sample_type & PERF_SAMPLE_ADDR)\n\t\t\tperf_get_data_addr(regs, &data.addr);\n\n\t\tif (perf_event_overflow(event, &data, regs))\n\t\t\tpower_pmu_stop(event, 0);\n\t}\n}","target":0,"flaw_line_index":0,"hash":"bbeae7eb-46e6-4c96-b22a-1f0937a2fab7","idx":"de3826ca-25c1-4a71-9f8e-5d0237f4f941"}
{"func_before":"    \/* Check if path contains invalid characters (prevent escaping the virtual filestore by using \"..\")\n     * TODO this may be platform dependent. Also depending of the platform there might be other evil\n     * characters.\n     *\/\n    if (strstr(filename, \"..\") != NULL) {\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILENAME_SYNTAX_ERROR);\n        return false;\n    }\n\n    return true;\n}","target":1,"flaw_line_index":0,"hash":"97c50158-31f7-4496-b8a4-abeb58c72174","idx":"6c7304f9-11ad-4313-b0a2-f990008daa33"}
{"func_before":"    \/* Check if path contains invalid characters (prevent escaping the virtual filestore by using \"..\")\n     * TODO this may be platform dependent. Also depending of the platform there might be other evil\n     * characters.\n     *\/\n    if (strstr(filename, \"..\") != NULL) {\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        return false;\n    }\n\n    return true;\n}","target":0,"flaw_line_index":0,"hash":"2dcf6c00-ac10-4516-ba6a-4889b2f9f9b7","idx":"8e68549f-524e-4a21-ac2a-5ffc605fb23c"}
{"func_before":"    }\n    \/* write optional elements *\/\n    if (mobi_is_dictionary(m)) {\n        if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n            if (m->mh && m->mh->dict_input_lang) {\n                opf->metadata->x_meta->dictionary_in_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n                uint32_t dict_lang_in = *m->mh->dict_input_lang;\n                opf->metadata->x_meta->dictionary_in_lang[0] = strdup(mobi_get_locale_string(dict_lang_in));\n            }\n        }\n        if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n            if (m->mh && m->mh->dict_output_lang) {\n                opf->metadata->x_meta->dictionary_out_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n                    debug_print(\"%s\\n\", \"Memory allocation failed\");\n                    return MOBI_MALLOC_FAILED;\n                }\n                uint32_t dict_lang_in = *m->mh->dict_output_lang;\n                opf->metadata->x_meta->dictionary_out_lang[0] = strdup(mobi_get_locale_string(dict_lang_in));\n            }\n        }\n        if (rawml->orth->orth_index_name) {\n            opf->metadata->x_meta->default_lookup_index = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n            if (opf->metadata->x_meta->default_lookup_index == NULL) {","target":1,"flaw_line_index":0,"hash":"5f064fb8-c601-4f48-84cc-cf348ea7ff08","idx":"3697131b-8277-4729-8959-a571aa713bf2"}
{"func_before":"    }\n    \/* write optional elements *\/\n    if (mobi_is_dictionary(m)) {\n        if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n            if (m->mh && m->mh->dict_input_lang) {\n                uint32_t dict_lang_in = *m->mh->dict_input_lang;\n                const char *lang = mobi_get_locale_string(dict_lang_in);\n                if (lang) {\n                    opf->metadata->x_meta->dictionary_in_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                    if (opf->metadata->x_meta->dictionary_in_lang == NULL) {\n                        debug_print(\"%s\\n\", \"Memory allocation failed\");\n                        return MOBI_MALLOC_FAILED;\n                    }\n                    opf->metadata->x_meta->dictionary_in_lang[0] = strdup(lang);\n                }\n            }\n        }\n        if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n            if (m->mh && m->mh->dict_output_lang) {\n                uint32_t dict_lang_out = *m->mh->dict_output_lang;\n                const char *lang = mobi_get_locale_string(dict_lang_out);\n                if (lang) {\n                    opf->metadata->x_meta->dictionary_out_lang = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n                    if (opf->metadata->x_meta->dictionary_out_lang == NULL) {\n                        debug_print(\"%s\\n\", \"Memory allocation failed\");\n                        return MOBI_MALLOC_FAILED;\n                    }\n                    opf->metadata->x_meta->dictionary_out_lang[0] = strdup(lang);\n                }\n            }\n        }\n        if (rawml->orth->orth_index_name) {\n            opf->metadata->x_meta->default_lookup_index = calloc(OPF_META_MAX_TAGS, sizeof(char*));\n            if (opf->metadata->x_meta->default_lookup_index == NULL) {","target":0,"flaw_line_index":0,"hash":"2bcf045c-967f-4fdb-96be-beab099c83e2","idx":"aab5c003-b39a-45ef-9695-14aa6a709ea3"}
{"func_before":"\t * peeled off association to the new socket's receive queue.\n\t *\/\n\tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n\t\tevent = sctp_skb2event(skb);\n\t\tif (event->asoc == assoc) {\n\t\t\tsctp_sock_rfree(skb);\n\t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n\t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r(skb, newsk);\n\t\t}\n\t}\n\n\t\/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t\t * need moved to the new socket.\n\t\t *\/\n\t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n\t\t\tevent = sctp_skb2event(skb);\n\t\t\tif (event->asoc == assoc) {\n\t\t\t\tsctp_sock_rfree(skb);\n\t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n\t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r(skb, newsk);\n\t\t\t}\n\t\t}\n\n\t\t\/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t *\/\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk);\n\n\t}\n\n\t\/* Set the type of socket to indicate that it is peeled off from the\n\t * original UDP-style socket or created with the accept() call on a\n\t * TCP-style socket..","target":1,"flaw_line_index":0,"hash":"ca24306a-e5da-4a57-a2b9-35b910d76941","idx":"c4a2834a-6ce7-41f1-aedd-b4ec6fe531a5"}
{"func_before":"\t * peeled off association to the new socket's receive queue.\n\t *\/\n\tsctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {\n\t\tevent = sctp_skb2event(skb);\n\t\tif (event->asoc == assoc) {\n\t\t\tsctp_sock_rfree_frag(skb);\n\t\t\t__skb_unlink(skb, &oldsk->sk_receive_queue);\n\t\t\t__skb_queue_tail(&newsk->sk_receive_queue, skb);\n\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t}\n\t}\n\n\t\/* Clean up any messages pending delivery due to partial\n\t * delivery.   Three cases:\n\t\t * need moved to the new socket.\n\t\t *\/\n\t\tsctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {\n\t\t\tevent = sctp_skb2event(skb);\n\t\t\tif (event->asoc == assoc) {\n\t\t\t\tsctp_sock_rfree_frag(skb);\n\t\t\t\t__skb_unlink(skb, &oldsp->pd_lobby);\n\t\t\t\t__skb_queue_tail(queue, skb);\n\t\t\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t\t\t}\n\t\t}\n\n\t\t\/* Clear up any skbs waiting for the partial\n\t\t * delivery to finish.\n\t\t *\/\n\t\tif (assoc->ulpq.pd_mode)\n\t\t\tsctp_clear_pd(oldsk);\n\n\t}\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.reasm, tmp) {\n\t\tsctp_sock_rfree_frag(skb);\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t}\n\n\tsctp_skb_for_each(skb, &assoc->ulpq.lobby, tmp) {\n\t\tsctp_sock_rfree_frag(skb);\n\t\tsctp_skb_set_owner_r_frag(skb, newsk);\n\t}\n\n\t\/* Set the type of socket to indicate that it is peeled off from the\n\t * original UDP-style socket or created with the accept() call on a\n\t * TCP-style socket..","target":0,"flaw_line_index":0,"hash":"1d1565b5-4209-4e00-b600-5ecdbbcb2c25","idx":"6d6a3c27-5919-4277-ace0-a2212b364a20"}
{"func_before":"\n\t\/* sanity check the cb pointer *\/\n\tucbnum = get_cb_number((void *)cb);\n\tif ((cb & (GRU_HANDLE_STRIDE - 1)) || ucbnum >= GRU_NUM_CB)\n\t\treturn -EINVAL;\n\n\tgts = gru_find_lock_gts(cb);\n\tif (!gts)\n\t\treturn -EINVAL;\n\tgru_dbg(grudev, \"address 0x%lx, gid %d, gts 0x%p\\n\", cb, gts->ts_gru ? gts->ts_gru->gs_gid : -1, gts);\n\n\tif (ucbnum >= gts->ts_cbr_au_count * GRU_CBR_AU_SIZE)\n\t\tgoto exit;\n\n\tgru_check_context_placement(gts);\n\n\t\/*\n\t * CCH may contain stale data if ts_force_cch_reload is set.\n\t *\/\n\tif (gts->ts_gru && gts->ts_force_cch_reload) {","target":1,"flaw_line_index":0,"hash":"64520d00-560b-40b2-b8cf-295173005e7b","idx":"51d9b328-b13f-48b6-93ae-a57c8b9159c6"}
{"func_before":"\t\/* sanity check the cb pointer *\/\n\tucbnum = get_cb_number((void *)cb);\n\tif ((cb & (GRU_HANDLE_STRIDE - 1)) || ucbnum >= GRU_NUM_CB)\n\t\treturn -EINVAL;\n\nagain:\n\tgts = gru_find_lock_gts(cb);\n\tif (!gts)\n\t\treturn -EINVAL;\n\tgru_dbg(grudev, \"address 0x%lx, gid %d, gts 0x%p\\n\", cb, gts->ts_gru ? gts->ts_gru->gs_gid : -1, gts);\n\n\tif (ucbnum >= gts->ts_cbr_au_count * GRU_CBR_AU_SIZE)\n\t\tgoto exit;\n\n\tif (gru_check_context_placement(gts)) {\n\t\tgru_unlock_gts(gts);\n\t\tgru_unload_context(gts, 1);\n\t\tgoto again;\n\t}\n\n\t\/*\n\t * CCH may contain stale data if ts_force_cch_reload is set.\n\t *\/\n\tif (gts->ts_gru && gts->ts_force_cch_reload) {","target":0,"flaw_line_index":0,"hash":"4c347690-594e-49ac-a12c-c527748d5072","idx":"f0428bf5-05bd-47f1-ba64-a9a3c4f4497b"}
{"func_before":"void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n{\n\tgdImagePtr pim = 0, tim = im;\n\tint interlace, BitsPerPixel;\n\tinterlace = im->interlace;\n\tif (im->trueColor) {\n\t\t\/* Expensive, but the only way that produces an\n\t\t\tacceptable result: mix down to a palette\n\t\t\tbased temporary image. *\/\n\t\tpim = gdImageCreatePaletteFromTrueColor(im, 1, 256);\n\t\tif (!pim) {\n\t\t\treturn;\n\t\t}\n\t\ttim = pim;\n\t}\n\tBitsPerPixel = colorstobpp(tim->colorsTotal);\n\t\/* All set, let's do it. *\/\n\tGIFEncode(\n\t\tout, tim->sx, tim->sy, tim->interlace, 0, tim->transparent, BitsPerPixel,\n\t\ttim->red, tim->green, tim->blue, tim);\n\tif (pim) {\n\t\t\/* Destroy palette based temporary image. *\/\n\t\tgdImageDestroy(\tpim);\n\t}\n}","target":1,"flaw_line_index":0,"hash":"070d46e4-f211-487d-b6e4-a15f920c56b9","idx":"9d36bf56-7ade-4574-a950-bbba6d8a0520"}
{"func_before":"void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)\n{\n\t_gdImageGifCtx(im, out);\n}","target":0,"flaw_line_index":0,"hash":"0f410db9-d00b-45ad-8924-b8c99b74113a","idx":"991594da-7488-4086-99cf-0ef5cf848b28"}
{"func_before":"\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\t*pagep = page;\n\n\tret = block_write_begin(file, mapping, pos, len, flags, pagep, fsdata,\n\t\t\t\text4_get_block);\n\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, NULL, do_journal_get_write_access);\n\t}","target":1,"flaw_line_index":0,"hash":"976fcd41-756e-4670-97b3-3b70a263d422","idx":"7f590894-2606-49c0-b6ab-97cfaebca45f"}
{"func_before":"\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\t*pagep = page;\n\n\tif (ext4_should_dioread_nolock(inode))\n\t\tret = block_write_begin(file, mapping, pos, len, flags, pagep,\n\t\t\t\tfsdata, ext4_get_block_write);\n\telse\n\t\tret = block_write_begin(file, mapping, pos, len, flags, pagep,\n\t\t\t\tfsdata, ext4_get_block);\n\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, NULL, do_journal_get_write_access);\n\t}","target":0,"flaw_line_index":0,"hash":"1e631c56-ab32-4cee-9850-80768a6ca2eb","idx":"2c83be2a-4bb1-44ff-908c-30df3d78124f"}
{"func_before":"\t    ga_concat(&ga, ((char_u **)sp->buflines.ga_data)[sp->buf_lnum]);\n\t    sp->buf_lnum++;\n\t    if (ga_grow(&ga, 1) == FAIL)\n\t\tbreak;\n\t    buf = (char_u *)ga.ga_data;\n\t    buf[ga.ga_len++] = NUL;\n\t}\n\telse\n\t{\n\t    buf = (char_u *)ga.ga_data;\n\t    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len,\n\t\t\tsp->fp) == NULL)\n\t\tbreak;\n\t}\n\tlen = ga.ga_len + (int)STRLEN(buf + ga.ga_len);\n#ifdef USE_CRNL\n\t\/\/ Ignore a trailing CTRL-Z, when in Dos mode.\tOnly recognize the\n\t\/\/ CTRL-Z by its own, or after a NL.\n\tif (\t   (len == 1 || (len >= 2 && buf[len - 2] == '\\n'))\n\t\t&& sp->fileformat == EOL_DOS","target":1,"flaw_line_index":0,"hash":"f29dd627-dcb7-4612-a2a1-7c6e1ac66748","idx":"8655a5b5-d39e-4d4d-95b8-28baf2a0cdb8"}
{"func_before":"\t    sp->buf_lnum++;\n\t    if (ga_grow(&ga, 1) == FAIL)\n\t\tbreak;\n\t    buf = (char_u *)ga.ga_data;\n\t    buf[ga.ga_len++] = NUL;\n\t    len = ga.ga_len;\n\t}\n\telse\n\t{\n\t    buf = (char_u *)ga.ga_data;\n\t    if (fgets((char *)buf + ga.ga_len, ga.ga_maxlen - ga.ga_len,\n\t\t\tsp->fp) == NULL)\n\t\tbreak;\n\t    len = ga.ga_len + (int)STRLEN(buf + ga.ga_len);\n\t}\n#ifdef USE_CRNL\n\t\/\/ Ignore a trailing CTRL-Z, when in Dos mode.\tOnly recognize the\n\t\/\/ CTRL-Z by its own, or after a NL.\n\tif (\t   (len == 1 || (len >= 2 && buf[len - 2] == '\\n'))\n\t\t&& sp->fileformat == EOL_DOS","target":0,"flaw_line_index":0,"hash":"7580f1e8-091c-4c58-9a4a-8672a05a045d","idx":"a849c176-b15d-4594-b3a7-976e99c03722"}
{"func_before":"  auto default_size = 32;\n  ret->ptr = static_cast<uint8_t *>(cabi_malloc(default_size, 4));\n  auto status = fastly::req_downstream_tls_protocol(reinterpret_cast<char *>(ret->ptr),\n                                                    default_size, &ret->len);\n  if (status == FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_BUFFER_LEN) {\n    cabi_realloc(ret->ptr, default_size, 4, ret->len);\n    status = fastly::req_downstream_tls_protocol(reinterpret_cast<char *>(ret->ptr), ret->len,\n                                                 &ret->len);\n  }\n  return convert_result(status, err);\n}","target":1,"flaw_line_index":0,"hash":"7826ebf8-e995-4d56-a5de-c343ae63c26e","idx":"f8ed5123-0936-425d-bfd0-3f4b4ee27192"}
{"func_before":"  auto default_size = 32;\n  ret->ptr = static_cast<uint8_t *>(cabi_malloc(default_size, 4));\n  auto status = fastly::req_downstream_tls_protocol(reinterpret_cast<char *>(ret->ptr),\n                                                    default_size, &ret->len);\n  if (status == FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_BUFFER_LEN) {\n    ret->ptr = static_cast<uint8_t *>(cabi_realloc(ret->ptr, default_size, 4, ret->len));\n    status = fastly::req_downstream_tls_protocol(reinterpret_cast<char *>(ret->ptr), ret->len,\n                                                 &ret->len);\n  }\n  return convert_result(status, err);\n}","target":0,"flaw_line_index":0,"hash":"6493103b-179b-4135-bf31-34155f6998de","idx":"e5e0ca2e-5a95-405a-9199-c30ebe04780e"}
{"func_before":"    STACK_OF(X509_OBJECT) *objs;\n    X509_OBJECT *obj;\n    int x509 = 0, crl = 0, ca = 0, i;\n\n    store = SSL_CTX_get_cert_store(self->ctx);\n    objs = X509_STORE_get0_objects(store);\n    for (i = 0; i < sk_X509_OBJECT_num(objs); i++) {\n        obj = sk_X509_OBJECT_value(objs, i);\n        switch (X509_OBJECT_get_type(obj)) {\n            case X509_LU_X509:\n                x509++;\n                break;\n            case X509_LU_CRL:\n                crl++;\n                break;\n            default:\n                \/* Ignore X509_LU_FAIL, X509_LU_RETRY, X509_LU_PKEY.\n                 * As far as I can tell they are internal states and never\n                 * stored in a cert store *\/\n                break;\n        }\n    }\n    return Py_BuildValue(\"{sisisi}\", \"x509\", x509, \"crl\", crl,\n        \"x509_ca\", ca);\n}","target":1,"flaw_line_index":0,"hash":"23393cc8-114b-4de4-970e-05a13448c4d0","idx":"a3b4bc02-9bdf-42a8-a0d4-b5ede0d27542"}
{"func_before":"    STACK_OF(X509_OBJECT) *objs;\n    X509_OBJECT *obj;\n    int x509 = 0, crl = 0, ca = 0, i;\n\n    store = SSL_CTX_get_cert_store(self->ctx);\n    objs = X509_STORE_get1_objects(store);\n    if (objs == NULL) {\n        PyErr_SetString(PyExc_MemoryError, \"failed to query cert store\");\n        return NULL;\n    }\n\n    for (i = 0; i < sk_X509_OBJECT_num(objs); i++) {\n        obj = sk_X509_OBJECT_value(objs, i);\n        switch (X509_OBJECT_get_type(obj)) {\n            case X509_LU_X509:\n                x509++;\n                break;\n            case X509_LU_CRL:\n                crl++;\n                break;\n            default:\n                \/* Ignore unrecognized types. *\/\n                break;\n        }\n    }\n    sk_X509_OBJECT_pop_free(objs, X509_OBJECT_free);\n    return Py_BuildValue(\"{sisisi}\", \"x509\", x509, \"crl\", crl,\n        \"x509_ca\", ca);\n}","target":0,"flaw_line_index":0,"hash":"677498fe-8205-4d78-bf91-c6fccdcf03f4","idx":"fec6d654-6f4a-4051-aab8-f67a7abe9c17"}
{"func_before":"\n  verbose_msg(\"-- Connecting to %s...\\n\", host ? host : \"localhost\");\n  mysql_init(&mysql_connection);\n  if (opt_compress)\n    mysql_options(&mysql_connection,MYSQL_OPT_COMPRESS,NullS);\n#ifdef HAVE_OPENSSL\n  if (opt_use_ssl)\n  {\n    mysql_ssl_set(&mysql_connection, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,\n                  opt_ssl_capath, opt_ssl_cipher);\n    mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRL, opt_ssl_crl);\n    mysql_options(&mysql_connection, MYSQL_OPT_SSL_CRLPATH, opt_ssl_crlpath);\n  }\n  mysql_options(&mysql_connection,MYSQL_OPT_SSL_VERIFY_SERVER_CERT,\n                (char*)&opt_ssl_verify_server_cert);\n#endif\n  if (opt_protocol)\n    mysql_options(&mysql_connection,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(&mysql_connection,MYSQL_OPT_BIND,opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)","target":1,"flaw_line_index":0,"hash":"dc4b3261-949b-4e5b-8a1d-c34085d942bd","idx":"215f1f1c-2037-4dd5-b4bd-ddf91d6301a3"}
{"func_before":"\n  verbose_msg(\"-- Connecting to %s...\\n\", host ? host : \"localhost\");\n  mysql_init(&mysql_connection);\n  if (opt_compress)\n    mysql_options(&mysql_connection,MYSQL_OPT_COMPRESS,NullS);\n  SSL_SET_OPTIONS(&mysql_connection);\n  if (opt_protocol)\n    mysql_options(&mysql_connection,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);\n  if (opt_bind_addr)\n    mysql_options(&mysql_connection,MYSQL_OPT_BIND,opt_bind_addr);\n#if defined (_WIN32) && !defined (EMBEDDED_LIBRARY)","target":0,"flaw_line_index":0,"hash":"8dc4b595-8f69-481f-bb62-63238a458f33","idx":"824c87ab-a2ce-455f-a14a-a4b34fbc8c12"}
{"func_before":"\tvFAIL(\"Missing braces on \\\\N{}\");\n    }\n\n    RExC_parse++;\t\/* Skip past the '{' *\/\n\n    endbrace = strchr(RExC_parse, '}');\n    if (! endbrace) { \/* no trailing brace *\/\n        vFAIL2(\"Missing right brace on \\\\%c{}\", 'N');\n    }\n    else if (!(   endbrace == RExC_parse\t\/* nothing between the {} *\/\n               || memBEGINs(RExC_parse,   \/* U+ (bad hex is checked below","target":1,"flaw_line_index":0,"hash":"e32e5199-8965-444a-aa2d-1ae76ef76196","idx":"3df1ad17-0835-4ddc-a508-a7c53e79b17c"}
{"func_before":"\tvFAIL(\"Missing braces on \\\\N{}\");\n    }\n\n    RExC_parse++;\t\/* Skip past the '{' *\/\n\n    endbrace = (char *) memchr(RExC_parse, '}', RExC_end - RExC_parse);\n    if (! endbrace) { \/* no trailing brace *\/\n        vFAIL2(\"Missing right brace on \\\\%c{}\", 'N');\n    }\n    else if (!(   endbrace == RExC_parse\t\/* nothing between the {} *\/\n               || memBEGINs(RExC_parse,   \/* U+ (bad hex is checked below","target":0,"flaw_line_index":0,"hash":"3320bb78-df58-405b-86b2-9e2586dbff1b","idx":"6631b2ee-e403-4a90-aa78-4297b937dd7b"}
{"func_before":"\tjpg_dest_t *dest_mgr = &dest_mgr_buf;\n\tJDIMENSION num_scanlines;\n\tjas_image_t *image;\n\tint ret;\n\tjpg_dec_importopts_t opts;\n\tsize_t size;\n\n\tif (jpg_dec_parseopts(optstr, &opts)) {\n\t\tgoto error;\n\t}\n\n\t}\n\tJAS_DBGLOG(10, (\n\t  \"header: image_width %d; image_height %d; num_components %d\\n\",\n\t  cinfo.image_width, cinfo.image_height, cinfo.num_components)\n\t  );\n\n\t\/* Start the decompressor. *\/\n\tJAS_DBGLOG(10, (\"jpeg_start_decompress(%p)\\n\", &cinfo));\n\tret = jpeg_start_decompress(&cinfo);\n\tJAS_DBGLOG(10, (\"jpeg_start_decompress return value %d\\n\", ret));\n\tJAS_DBGLOG(10, (\n\t  \"header: output_width %d; output_height %d; output_components %d\\n\",\n\t  cinfo.output_width, cinfo.output_height, cinfo.output_components)\n\t  );\n\n\tif (opts.max_size) {\n\t\tif (!jas_safe_size_mul(cinfo.output_width, cinfo.output_height,\n\t\t  &size) ||\n\t\t  !jas_safe_size_mul(size, cinfo.output_components, &size)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (size > opts.max_size) {\n\t\t\tjas_eprintf(\"image is too large\\n\");\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t\/* Create an image object to hold the decoded data. *\/\n\tif (!(image = jpg_mkimage(&cinfo))) {\n\t\tjas_eprintf(\"jpg_mkimage failed\\n\");\n\t\tgoto error;","target":1,"flaw_line_index":0,"hash":"f337477f-aa8a-41c8-a6b4-289f6499d899","idx":"4c61e5ab-845d-48b3-9b50-7a4a3898dd4e"}
{"func_before":"\tjpg_dest_t *dest_mgr = &dest_mgr_buf;\n\tJDIMENSION num_scanlines;\n\tjas_image_t *image;\n\tint ret;\n\tjpg_dec_importopts_t opts;\n\tsize_t num_samples;\n\n\tJAS_DBGLOG(100, (\"jpg_decode(%p, \\\"%s\\\")\\n\", in, optstr));\n\n\tif (jpg_dec_parseopts(optstr, &opts)) {\n\t\tgoto error;\n\t}\n\n\tJAS_DBGLOG(10, (\n\t  \"header: image_width %d; image_height %d; num_components %d\\n\",\n\t  cinfo.image_width, cinfo.image_height, cinfo.num_components)\n\t  );\n\n\tif (opts.max_samples > 0) {\n\t\tif (!jas_safe_size_mul3(cinfo.image_width, cinfo.image_height,\n\t\t  cinfo.num_components, &num_samples)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (num_samples > opts.max_samples) {\n\t\t\tjas_eprintf(\"image is too large (%zu > %zu)\\n\", num_samples,\n\t\t\t  opts.max_samples);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t\/* Start the decompressor. *\/\n\tJAS_DBGLOG(10, (\"jpeg_start_decompress(%p)\\n\", &cinfo));\n\tret = jpeg_start_decompress(&cinfo);\n\tJAS_DBGLOG(10, (\"jpeg_start_decompress return value %d\\n\", ret));\n\tJAS_DBGLOG(10, (\n\t  \"header: output_width %d; output_height %d; output_components %d\\n\",\n\t  cinfo.output_width, cinfo.output_height, cinfo.output_components)\n\t  );\n\n\t\/* Create an image object to hold the decoded data. *\/\n\tif (!(image = jpg_mkimage(&cinfo))) {\n\t\tjas_eprintf(\"jpg_mkimage failed\\n\");\n\t\tgoto error;","target":0,"flaw_line_index":0,"hash":"5bfb5f10-06cc-413c-ab54-98163225b647","idx":"c0933b6b-8dae-4135-ad7f-dbe31b3a3950"}
{"func_before":"int bad_format_imginfo(\n    char *fmt)\n{\n    char     *ptr;\n    int       n = 0;\n\n    ptr = fmt;\n    while (*ptr != '\\0')\n        if (*ptr++ == '%') {\n\n            \/* line cannot end with percent char *\/\n            if (*ptr == '\\0')\n                return 1;\n            \/* '%%' is allowed *\/\n            if (*ptr == '%')\n                ptr++;\n            \/* '%s', '%S' are allowed *\/\n            else if (*ptr == 's' || *ptr == 'S') {\n                n = 1;\n                ptr++;\n            }\n\n            \/* or else '% 4lu' and such are allowed *\/\n            else {\n                \/* optional padding character *\/\n                if (*ptr == ' ')\n                    ptr++;\n                \/* This should take care of 'm' *\/\n                while (*ptr >= '0' && *ptr <= '9')\n                    ptr++;\n                \/* 'lu' must follow here *\/\n                if (*ptr++ != 'l')\n                    return 1;\n                if (*ptr == 'u')\n                    ptr++;\n                else\n                    return 1;\n                n++;\n            }\n        }\n\n    return (n != 3);\n}","target":1,"flaw_line_index":0,"hash":"9648b402-5574-4cc1-a377-15b791286fc3","idx":"49f72c21-190e-4f95-9cc9-a8db5b30aab1"}
{"func_before":"int bad_format_imginfo(char *fmt){\n    return bad_format_check(\"^\" SAFE_STRING \"%s\" SAFE_STRING \"%lu\" SAFE_STRING \"%lu\" SAFE_STRING \"$\",fmt);\n}","target":0,"flaw_line_index":0,"hash":"37c15cbf-84b5-4b68-a0ac-ac2259eb649a","idx":"1cea8a82-5096-4351-82d5-4c10ae88ef6a"}
{"func_before":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* data = GetInput(context, node, kInputDataTensor);\n  const TfLiteTensor* segment_ids =\n      GetInput(context, node, kInputSegmentIdsTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE(context,\n                 data->type == kTfLiteInt32 || data->type == kTfLiteFloat32);\n  TF_LITE_ENSURE_EQ(context, segment_ids->type, kTfLiteInt32);\n\n  if (!IsConstantTensor(data) || !IsConstantTensor(segment_ids)) {","target":1,"flaw_line_index":0,"hash":"c7e1c82f-cf71-4d09-a122-77b880994ab3","idx":"63544d4e-5ef8-421a-83d3-41208d2e2895"}
{"func_before":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* data;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputDataTensor, &data));\n  const TfLiteTensor* segment_ids;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputSegmentIdsTensor,\n                                          &segment_ids));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE(context,\n                 data->type == kTfLiteInt32 || data->type == kTfLiteFloat32);\n  TF_LITE_ENSURE_EQ(context, segment_ids->type, kTfLiteInt32);\n\n  if (!IsConstantTensor(data) || !IsConstantTensor(segment_ids)) {","target":0,"flaw_line_index":0,"hash":"01025ff9-cf70-462b-9bce-9faff5777430","idx":"a9690b13-9d7e-4ef9-9131-1c57cbd14b2f"}
{"func_before":"void fp48_exp_cyc_sps(fp48_t c, const fp48_t a, const int *b, int len, int sign) {\n\tint i, j, k, w = len;\n    fp48_t t, *u = RLC_ALLOCA(fp48_t, w);\n\n\tif (len == 0) {\n\t\tRLC_FREE(u);\n\t\tfp48_set_dig(c, 1);","target":1,"flaw_line_index":0,"hash":"8b2da317-9d3e-4fa7-8296-94deed291486","idx":"459344ac-dc4f-46d7-a1af-27299521320b"}
{"func_before":"void fp48_exp_cyc_sps(fp48_t c, const fp48_t a, const int *b, size_t len,\n\t\tint sign) {\n\tsize_t i, j, k, w = len;\n    fp48_t t, *u = RLC_ALLOCA(fp48_t, w);\n\n\tif (len == 0) {\n\t\tRLC_FREE(u);\n\t\tfp48_set_dig(c, 1);","target":0,"flaw_line_index":0,"hash":"bb391318-dc10-47cd-8740-e652af1d3b6e","idx":"b4adec0b-47d6-4260-9f85-9b56a5d92cb4"}
{"func_before":"  int i;\n  struct log_info *loginfo;\n  int log_error;\n  FILE *file1;\n  FILE *file2;\n  int ismatch;\n\n  curfile = files;\n  \n  while (curfile) {\n    if (curfile->hasdupes) {\n    {\n      ismatch = 1;\n    }\n\n    if (ismatch) {\n      if (remove(dupelist[x]->d_name) == 0) {\n        printf(\"   [-] %s\\n\", dupelist[x]->d_name);\n\n        if (loginfo)\n          log_file_deleted(loginfo, dupelist[x]->d_name);\n      }\n      else {\n        printf(\"   [!] %s \", dupelist[x]->d_name);\n        printf(\"-- unable to delete file!\\n\");\n\n        if (loginfo)\n          log_file_remaining(loginfo, dupelist[x]->d_name);\n      }\n    }","target":1,"flaw_line_index":0,"hash":"c35df3c5-e824-4119-ac2f-4dbb5ac03637","idx":"38de9279-0094-4cbc-884a-1ee9632b2850"}
{"func_before":"  struct log_info *loginfo;\n  int log_error;\n  FILE *file1;\n  FILE *file2;\n  int ismatch;\n  char *errorstring;\n\n  curfile = files;\n  \n  while (curfile) {\n    if (curfile->hasdupes) {\n    {\n      ismatch = 1;\n    }\n\n    if (ismatch) {\n      if (removeifnotchanged(dupelist[x], &errorstring) == 0) {\n        printf(\"   [-] %s\\n\", dupelist[x]->d_name);\n\n        if (loginfo)\n          log_file_deleted(loginfo, dupelist[x]->d_name);\n      }\n      else {\n        printf(\"   [!] %s \", dupelist[x]->d_name);\n        printf(\"-- unable to delete file: %s!\\n\", errorstring);\n\n        if (loginfo)\n          log_file_remaining(loginfo, dupelist[x]->d_name);\n      }\n    }","target":0,"flaw_line_index":0,"hash":"3800f959-9964-4309-aa9a-2085fc2b2ac0","idx":"ce34c614-1090-4804-9589-ecec7616ee97"}
{"func_before":"\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\treturn -2;\n\n\t\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (ret == 0) {\t\t\/* EOF *\/\n\t\t\t\/* Failure to read ANY length just means we're done *\/\n\t\t\tif (len_buf_pos == 0)\n\t\t\t\/*\n\t\t\t * Otherwise, we got EOF mid-length, and that's\n\t\t\t * a protocol error.\n\t\t\t *\/\n\t\t\tLOG(LOG_INFO, (\"EOF reading packet len\"));\n\t\t\treturn -1;\n\t\t}\n\n\t\tlen_buf_pos += ret;\n\t}\n\n\t * slop in enc overhead, beyond the actual maximum number of\n\t * bytes of decrypted payload.\n\t *\/\n\tif (len > GSTD_MAXPACKETCONTENTS + 512) {\n\t\tLOG(LOG_ERR, (\"ridiculous length, %ld\", len));\n\t\treturn -1;\n\t}\n\n\tif (!tmpbuf) {\n\t\tif ((tmpbuf = malloc(len)) == NULL) {\n\t\t\tLOG(LOG_CRIT, (\"malloc failure, %ld bytes\", len));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);\n\tif (ret == -1) {\n\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\treturn -2;\n\n\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\treturn -1;\n\t}\n\n\tif (ret == 0) {\n\t\tLOG(LOG_ERR, (\"EOF while reading packet (len=%d)\", len));\n\t\treturn -1;\n\t}\n\n\ttmpbuf_pos += ret;\n\n\tif (tmpbuf_pos == len) {\n\n\t\tLOG(LOG_DEBUG, (\"read packet of length %d\", buf->length));\n\t\treturn 1;\n\t}\n\n\treturn -2;\n}","target":1,"flaw_line_index":0,"hash":"caefe272-f5a4-49a3-8e38-c2d3f458e37f","idx":"3c5987e2-4a06-4993-848d-142ef0cea207"}
{"func_before":"\t\tif (ret == -1) {\n\t\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\t\treturn -2;\n\n\t\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (ret == 0) {\t\t\/* EOF *\/\n\t\t\t\/* Failure to read ANY length just means we're done *\/\n\t\t\tif (len_buf_pos == 0)\n\t\t\t\/*\n\t\t\t * Otherwise, we got EOF mid-length, and that's\n\t\t\t * a protocol error.\n\t\t\t *\/\n\t\t\tLOG(LOG_INFO, (\"EOF reading packet len\"));\n\t\t\tgoto bail;\n\t\t}\n\n\t\tlen_buf_pos += ret;\n\t}\n\n\t * slop in enc overhead, beyond the actual maximum number of\n\t * bytes of decrypted payload.\n\t *\/\n\tif (len > GSTD_MAXPACKETCONTENTS + 512) {\n\t\tLOG(LOG_ERR, (\"ridiculous length, %ld\", len));\n\t\tgoto bail;\n\t}\n\n\tif (!tmpbuf) {\n\t\tif ((tmpbuf = malloc(len)) == NULL) {\n\t\t\tLOG(LOG_CRIT, (\"malloc failure, %ld bytes\", len));\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tret = timed_read(fd, tmpbuf + tmpbuf_pos, len - tmpbuf_pos, timeout);\n\tif (ret == -1) {\n\n\t\tif (errno == EINTR || errno == EAGAIN)\n\t\t\treturn -2;\n\n\t\tLOG(LOG_ERR, (\"%s\", strerror(errno)));\n\t\tgoto bail;\n\t}\n\n\tif (ret == 0) {\n\t\tLOG(LOG_ERR, (\"EOF while reading packet (len=%d)\", len));\n\t\tgoto bail;\n\t}\n\n\ttmpbuf_pos += ret;\n\n\tif (tmpbuf_pos == len) {\n\t\tLOG(LOG_DEBUG, (\"read packet of length %d\", buf->length));\n\t\treturn 1;\n\t}\n\n\treturn -2;\n\nbail:\n\tfree(tmpbuf);\n\ttmpbuf = NULL;\n\n\treturn -1;\n}","target":0,"flaw_line_index":0,"hash":"d4283108-468c-4549-b896-b5de32627b4a","idx":"137d88e5-3939-482a-ab1e-ffeae1c53916"}
{"func_before":"\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n\tint ret;\n\n\twhile (ptr) {\n\t\tret = copy_to_user(param, ptr, sizeof(*ptr));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&","target":1,"flaw_line_index":0,"hash":"80be0289-bd3b-4ec4-9a18-64a71c515981","idx":"b6a21714-a6a8-491a-84e5-9fb1cd6cf3e6"}
{"func_before":"\t\t\t\t  struct floppy_raw_cmd *ptr)\n{\n\tint ret;\n\n\twhile (ptr) {\n\t\tstruct floppy_raw_cmd cmd = *ptr;\n\t\tcmd.next = NULL;\n\t\tcmd.kernel_data = NULL;\n\t\tret = copy_to_user(param, &cmd, sizeof(cmd));\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t\tparam += sizeof(struct floppy_raw_cmd);\n\t\tif ((ptr->flags & FD_RAW_READ) && ptr->buffer_length) {\n\t\t\tif (ptr->length >= 0 &&","target":0,"flaw_line_index":0,"hash":"09adde84-fa0c-4eb2-9f08-084d026f732e","idx":"1183c5a4-f0f6-4a46-a75e-4fa519d58f17"}
{"func_before":"  }\n  if (request_headers.EnvoyOriginalPath() != nullptr) {\n    request_properties->set_original_path(\n        std::string(request_headers.EnvoyOriginalPath()->value().getStringView()));\n  }\n  request_properties->set_request_headers_bytes(request_headers.byteSize());\n  request_properties->set_request_body_bytes(stream_info.bytesReceived());\n  if (request_headers.Method() != nullptr) {\n    envoy::api::v2::core::RequestMethod method =\n        envoy::api::v2::core::RequestMethod::METHOD_UNSPECIFIED;\n    envoy::api::v2::core::RequestMethod_Parse(\n    response_properties->mutable_response_code()->set_value(stream_info.responseCode().value());\n  }\n  if (stream_info.responseCodeDetails()) {\n    response_properties->set_response_code_details(stream_info.responseCodeDetails().value());\n  }\n  response_properties->set_response_headers_bytes(response_headers.byteSize());\n  response_properties->set_response_body_bytes(stream_info.bytesSent());\n  if (!response_headers_to_log_.empty()) {\n    auto* logged_headers = response_properties->mutable_response_headers();\n\n    for (const auto& header : response_headers_to_log_) {","target":1,"flaw_line_index":0,"hash":"15c27689-877b-4f21-83fb-46540a95b275","idx":"d993f60d-d3c1-4787-9bf1-d97f94911821"}
{"func_before":"  }\n  if (request_headers.EnvoyOriginalPath() != nullptr) {\n    request_properties->set_original_path(\n        std::string(request_headers.EnvoyOriginalPath()->value().getStringView()));\n  }\n  request_properties->set_request_headers_bytes(request_headers.byteSize().value());\n  request_properties->set_request_body_bytes(stream_info.bytesReceived());\n  if (request_headers.Method() != nullptr) {\n    envoy::api::v2::core::RequestMethod method =\n        envoy::api::v2::core::RequestMethod::METHOD_UNSPECIFIED;\n    envoy::api::v2::core::RequestMethod_Parse(\n    response_properties->mutable_response_code()->set_value(stream_info.responseCode().value());\n  }\n  if (stream_info.responseCodeDetails()) {\n    response_properties->set_response_code_details(stream_info.responseCodeDetails().value());\n  }\n  response_properties->set_response_headers_bytes(response_headers.byteSize().value());\n  response_properties->set_response_body_bytes(stream_info.bytesSent());\n  if (!response_headers_to_log_.empty()) {\n    auto* logged_headers = response_properties->mutable_response_headers();\n\n    for (const auto& header : response_headers_to_log_) {","target":0,"flaw_line_index":0,"hash":"cef77faa-11c4-45f4-8c34-9e4527ff2971","idx":"650421dc-b953-4c73-bb5a-270c1b24bb42"}
{"func_before":"      timer.reset(new GpuTimer(parent_));\n      \/\/ The start and stop of the timer should be as close to the Cudnn call as\n      \/\/ possible. It is still possible for other threads to issue workload on\n      \/\/ to this stream. So it could take multiple profiling measurements.\n      if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n        return tsl::Status(port::error::INTERNAL, \"Failed to start timer\");\n      }\n    }\n\n    RETURN_IF_CUDNN_ERROR(cudnnRNNForward(\n        \/*handle=*\/cudnn.handle(), \/*rnnDesc=*\/rnn_desc.handle(),\n        \/*reserveSpaceSizeInBytes=*\/reserve_space.size(),\n        \/*reserveSpace=*\/reserve_space.opaque()));\n\n    if (is_profiling) {\n      if (!timer->Stop(AsGpuStream(stream))) {\n        return tsl::Status(port::error::INTERNAL, \"Failed to stop timer\");\n      }\n      auto algo_desc = *rnn_desc.algorithm_config().algorithm();\n      output_profile_result->set_algorithm(algo_desc);\n      output_profile_result->set_elapsed_time_in_ms(\n          timer->GetElapsedMilliseconds());\n    timer.reset(new GpuTimer(parent_));\n    \/\/ The start and stop of the timer should be as close to the Cudnn call as\n    \/\/ possible. It is still possible for other threads to issue workload on\n    \/\/ to this stream. So it could take multiple profiling measurements.\n    if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n      return tsl::Status(port::error::INTERNAL, \"Failed to start timer\");\n    }\n  }\n\n  if (!is_training) {\n    if (input_desc.is_var_seq_lengths()) {\n    }\n  }\n\n  if (is_profiling) {\n    if (!timer->Stop(AsGpuStream(stream))) {\n      return tsl::Status(port::error::INTERNAL, \"Failed to stop timer\");\n    }\n    auto algo_desc = *rnn_desc.algorithm_config().algorithm();\n    output_profile_result->set_algorithm(algo_desc);\n    output_profile_result->set_elapsed_time_in_ms(\n        timer->GetElapsedMilliseconds());","target":1,"flaw_line_index":0,"hash":"026bff89-a829-43ea-81cc-dd4f13472824","idx":"b46279b0-08e8-426d-aa53-79d421f0ecac"}
{"func_before":"      timer.reset(new GpuTimer(parent_));\n      \/\/ The start and stop of the timer should be as close to the Cudnn call as\n      \/\/ possible. It is still possible for other threads to issue workload on\n      \/\/ to this stream. So it could take multiple profiling measurements.\n      if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n        return tsl::Status(tsl::error::INTERNAL, \"Failed to start timer\");\n      }\n    }\n\n    RETURN_IF_CUDNN_ERROR(cudnnRNNForward(\n        \/*handle=*\/cudnn.handle(), \/*rnnDesc=*\/rnn_desc.handle(),\n        \/*reserveSpaceSizeInBytes=*\/reserve_space.size(),\n        \/*reserveSpace=*\/reserve_space.opaque()));\n\n    if (is_profiling) {\n      if (!timer->Stop(AsGpuStream(stream))) {\n        return tsl::Status(tsl::error::INTERNAL, \"Failed to stop timer\");\n      }\n      auto algo_desc = *rnn_desc.algorithm_config().algorithm();\n      output_profile_result->set_algorithm(algo_desc);\n      output_profile_result->set_elapsed_time_in_ms(\n          timer->GetElapsedMilliseconds());\n    timer.reset(new GpuTimer(parent_));\n    \/\/ The start and stop of the timer should be as close to the Cudnn call as\n    \/\/ possible. It is still possible for other threads to issue workload on\n    \/\/ to this stream. So it could take multiple profiling measurements.\n    if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n      return tsl::Status(tsl::error::INTERNAL, \"Failed to start timer\");\n    }\n  }\n\n  if (!is_training) {\n    if (input_desc.is_var_seq_lengths()) {\n    }\n  }\n\n  if (is_profiling) {\n    if (!timer->Stop(AsGpuStream(stream))) {\n      return tsl::Status(tsl::error::INTERNAL, \"Failed to stop timer\");\n    }\n    auto algo_desc = *rnn_desc.algorithm_config().algorithm();\n    output_profile_result->set_algorithm(algo_desc);\n    output_profile_result->set_elapsed_time_in_ms(\n        timer->GetElapsedMilliseconds());","target":0,"flaw_line_index":0,"hash":"81db66ec-b0e2-43f2-be42-ada8881b44a5","idx":"6e11347c-9ec6-4c9d-a3bf-6b128f3dc918"}
{"func_before":"\tchar const* parse_int(char const* start, char const* end, char delimiter, boost::int64_t& val)\n\t{\n\t\twhile (start < end && *start != delimiter)\n\t\t{\n\t\t\tif (!is_digit(*start)) { return 0; }\n\t\t\tval *= 10;\n\t\t\tval += *start - '0';\n\t\t\t++start;\n\t\t}\n\t\treturn start;\n\t}","target":1,"flaw_line_index":0,"hash":"7dca5875-0376-42db-9c55-953ceb0a5781","idx":"53631b9f-fd1b-4e8f-8130-4ee04e63b5f9"}
{"func_before":"\tchar const* parse_int(char const* start, char const* end, char delimiter\n\t\t, boost::int64_t& val, bdecode_errors::error_code_enum& ec)\n\t{\n\t\twhile (start < end && *start != delimiter)\n\t\t{\n\t\t\tif (!numeric(*start))\n\t\t\t{\n\t\t\t\tec = bdecode_errors::expected_string;\n\t\t\t\treturn start;\n\t\t\t}\n\t\t\tif (val > INT64_MAX \/ 10)\n\t\t\t{\n\t\t\t\tec = bdecode_errors::overflow;\n\t\t\t\treturn start;\n\t\t\t}\n\t\t\tval *= 10;\n\t\t\tint digit = *start - '0';\n\t\t\tif (val > INT64_MAX - digit)\n\t\t\t{\n\t\t\t\tec = bdecode_errors::overflow;\n\t\t\t\treturn start;\n\t\t\t}\n\t\t\tval += digit;\n\t\t\t++start;\n\t\t}\n\t\tif (*start != delimiter)\n\t\t\tec = bdecode_errors::expected_colon;\n\t\treturn start;\n\t}","target":0,"flaw_line_index":0,"hash":"f5aa5c17-80f6-46a2-85c4-46a235249bdd","idx":"53ff1f9f-1a8e-445b-9930-33c17e9fcfaf"}
{"func_before":"jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len)\n{\n\tjas_stream_t *in;\n\tjas_iccprof_t *prof;\n\tif (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))\n\t\tgoto error;","target":1,"flaw_line_index":0,"hash":"1e90b5bc-6eb5-4860-8436-121c938cb879","idx":"e2991b1f-e050-4049-984b-569930194461"}
{"func_before":"jas_iccprof_t *jas_iccprof_createfrombuf(jas_uchar *buf, int len)\n{\n\tjas_stream_t *in;\n\tjas_iccprof_t *prof;\n\tif (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))\n\t\tgoto error;","target":0,"flaw_line_index":0,"hash":"0cfc74f7-e6b3-4848-8850-b44eaa553013","idx":"ba330385-0485-4d60-b901-57571af4c4d1"}
{"func_before":"    ratt.endpoint.topicKind = WITH_KEY;\n    \/\/ change depending of backup mode\n    ratt.endpoint.durabilityKind = VOLATILE;\n    ratt.endpoint.reliabilityKind = BEST_EFFORT;\n\n    endpoints.stateless_listener.reset(new PDPSecurityInitiatorListener(this,\n            [this](const ParticipantProxyData& participant_data)\n            {\n                auto endpoints = static_cast<fastdds::rtps::DiscoveryServerPDPEndpoints*>(builtin_endpoints_.get());\n                std::lock_guard<fastrtps::RecursiveTimedMutex> wlock(endpoints->writer.writer_->getMutex());\n\n            }));\n\n    \/\/ Create PDP Reader\n    RTPSReader* reader = nullptr;\n    if (mp_RTPSParticipant->createReader(&reader, ratt, endpoints.stateless_reader.history_.get(),\n            endpoints.stateless_listener.get(), c_EntityId_SPDPReader, true, false))\n    {\n        endpoints.stateless_reader.reader_ = dynamic_cast<fastrtps::rtps::StatelessReader*>(reader);\n\n        \/\/ Enable unknown clients to reach this reader\n        reader->enableMessagesFromUnkownWriters(true);\n\n        mp_RTPSParticipant->set_endpoint_rtps_protection_supports(reader, false);\n    }\n    \/\/ Could not create PDP Reader, so return false\n    else\n    {\n        EPROSIMA_LOG_ERROR(RTPS_PDP_SERVER, \"PDPServer security initiation Reader creation failed\");\n\n        endpoints.stateless_listener.reset();\n        endpoints.stateless_reader.release();\n        return false;\n    }\n\n    return true;","target":1,"flaw_line_index":0,"hash":"79f23645-180f-4105-b2f6-fb5c21ca4c77","idx":"1ef53164-c569-4534-8836-bee56a8a8271"}
{"func_before":"    ratt.endpoint.topicKind = WITH_KEY;\n    \/\/ change depending of backup mode\n    ratt.endpoint.durabilityKind = VOLATILE;\n    ratt.endpoint.reliabilityKind = BEST_EFFORT;\n\n    endpoints.stateless_reader.listener_.reset(new PDPSecurityInitiatorListener(this,\n            [this](const ParticipantProxyData& participant_data)\n            {\n                auto endpoints = static_cast<fastdds::rtps::DiscoveryServerPDPEndpoints*>(builtin_endpoints_.get());\n                std::lock_guard<fastrtps::RecursiveTimedMutex> wlock(endpoints->writer.writer_->getMutex());\n\n            }));\n\n    \/\/ Create PDP Reader\n    RTPSReader* reader = nullptr;\n    if (mp_RTPSParticipant->createReader(&reader, ratt, endpoints.stateless_reader.history_.get(),\n            endpoints.stateless_reader.listener_.get(), c_EntityId_SPDPReader, true, false))\n    {\n        endpoints.stateless_reader.reader_ = dynamic_cast<fastrtps::rtps::StatelessReader*>(reader);\n        mp_RTPSParticipant->set_endpoint_rtps_protection_supports(reader, false);\n    }\n    \/\/ Could not create PDP Reader, so return false\n    else\n    {\n        EPROSIMA_LOG_ERROR(RTPS_PDP_SERVER, \"PDPServer security initiation Reader creation failed\");\n        endpoints.stateless_reader.release();\n        return false;\n    }\n\n    return true;","target":0,"flaw_line_index":0,"hash":"2197839c-45c3-49b6-8f5f-95da2f4d9af1","idx":"15582069-9441-47a6-82dd-24bfd80ff14a"}
{"func_before":"static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\trcu_read_lock();\n\t__ptrace_link(child, new_parent, __task_cred(new_parent));\n\trcu_read_unlock();\n}","target":1,"flaw_line_index":0,"hash":"bef09b8c-cc1c-4112-aea0-5fcc1a3e4347","idx":"c1758b22-d6ad-481c-8660-447c9b6bff44"}
{"func_before":"static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\t__ptrace_link(child, new_parent, current_cred());\n}","target":0,"flaw_line_index":0,"hash":"9a96dd74-d7b0-429c-9563-76cff7d856e3","idx":"a14d9485-82d5-4acf-a71d-34f0ba0e3d6f"}
{"func_before":"\terr = nfs_check_flags(openflags);\n\tif (err)\n\t\treturn err;\n\n\tif ((openflags & O_ACCMODE) == 3)\n\t\treturn nfs_open(inode, filp);\n\n\t\/* We can't create new files here *\/\n\topenflags &= ~(O_CREAT|O_EXCL);\n\n\tparent = dget_parent(dentry);","target":1,"flaw_line_index":0,"hash":"ab0bc023-9c39-4403-8263-a53d18b87f5b","idx":"923155b5-eaad-432f-9c98-6a17c56c18f0"}
{"func_before":"\terr = nfs_check_flags(openflags);\n\tif (err)\n\t\treturn err;\n\n\tif ((openflags & O_ACCMODE) == 3)\n\t\topenflags--;\n\n\t\/* We can't create new files here *\/\n\topenflags &= ~(O_CREAT|O_EXCL);\n\n\tparent = dget_parent(dentry);","target":0,"flaw_line_index":0,"hash":"dffde9b2-3a4b-497e-993e-dfee55ff8c73","idx":"1443a6e7-7f76-4f92-a420-05041613c32f"}
{"func_before":"static XMLSharedNodeList* find_impl(xmlXPathContext* ctxt, const string& xpath)\n{\n\txmlXPathObject* result = xmlXPathEval((const xmlChar*)xpath.c_str(), ctxt);\n\n\tif (!result) {\n\t\txmlXPathFreeContext(ctxt);\n\t\txmlFreeDoc(ctxt->doc);\n\n\t\tthrow XMLException(\"Invalid XPath: \" + xpath);\n\t}\n\n\tif (result->type != XPATH_NODESET) {\n\t\txmlXPathFreeObject(result);\n\t\txmlXPathFreeContext(ctxt);\n\t\txmlFreeDoc(ctxt->doc);\n\n\t\tthrow XMLException(\"Only nodeset result types are supported.\");\n\t}\n\n\txmlNodeSet* nodeset = result->nodesetval;","target":1,"flaw_line_index":0,"hash":"e2eb2ffd-9c5f-4aed-83b8-5108d1fcff67","idx":"4f3b7e3c-9234-49be-841f-8f2099b6943a"}
{"func_before":"static XMLSharedNodeList* find_impl(xmlXPathContext* ctxt, const string& xpath)\n{\n\txmlXPathObject* result = xmlXPathEval((const xmlChar*)xpath.c_str(), ctxt);\n\n\tif (!result) {\n\t\txmlFreeDoc(ctxt->doc);\n\t\txmlXPathFreeContext(ctxt);\n\n\t\tthrow XMLException(\"Invalid XPath: \" + xpath);\n\t}\n\n\tif (result->type != XPATH_NODESET) {\n\t\txmlXPathFreeObject(result);\n\t\txmlFreeDoc(ctxt->doc);\n\t\txmlXPathFreeContext(ctxt);\n\n\t\tthrow XMLException(\"Only nodeset result types are supported.\");\n\t}\n\n\txmlNodeSet* nodeset = result->nodesetval;","target":0,"flaw_line_index":0,"hash":"0f747db4-6907-4b10-86b5-f6b394d621bc","idx":"8bea3a75-df0f-43e7-bdf3-18791deb32d1"}
{"func_before":"int util_bits_dig(dig_t a) {\n    return RLC_DIG - arch_lzcnt(a);\n}","target":1,"flaw_line_index":0,"hash":"5b8fd528-4add-4c52-8536-2a9216e2abe0","idx":"a90a0f31-a9a8-4a48-aefd-91348c35f537"}
{"func_before":"size_t util_bits_dig(dig_t a) {\n    return RLC_DIG - arch_lzcnt(a);\n}","target":0,"flaw_line_index":0,"hash":"fa6dc527-f504-4aad-9864-26bd1f2fa2fc","idx":"83b25197-6187-4a2b-8c9c-2eaee573a756"}
{"func_before":"void bn_read_bin(bn_t a, const uint8_t *bin, int len) {\n\tint i, j;\n\tdig_t d = (RLC_DIG \/ 8);\n\tint digs = (len % d == 0 ? len \/ d : len \/ d + 1);\n\n\tbn_grow(a, digs);","target":1,"flaw_line_index":0,"hash":"5afc4057-6d33-4084-850b-b6857a9c4fb2","idx":"d550e8b6-3157-4562-bd01-52eadab626aa"}
{"func_before":"void bn_read_bin(bn_t a, const uint8_t *bin, size_t len) {\n\tint i, j;\n\tdig_t d = (RLC_DIG \/ 8);\n\tint digs = (len % d == 0 ? len \/ d : len \/ d + 1);\n\n\tbn_grow(a, digs);","target":0,"flaw_line_index":0,"hash":"74a068f3-cae0-48ac-991c-1b2760d4c928","idx":"89b5f0ee-b371-4220-b29f-edb81367fbe9"}
{"func_before":"                S.iwidth = S.width;\n                S.iheight= S.height;\n                IO.shrink = 0;\n\t\t\t\tS.raw_pitch = S.width*8;\n                \/\/ allocate image as temporary buffer, size \n                imgdata.rawdata.raw_alloc = calloc(S.iwidth*S.iheight,sizeof(*imgdata.image));\n                imgdata.image = (ushort (*)[4]) imgdata.rawdata.raw_alloc;\n              }\n            ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n\n\t\t\tunsigned m_save = C.maximum;\n\t\t\tif(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))\n\t\t\t\tC.maximum=65535;\n            (this->*load_raw)();\n\t\t\tif(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))\n\t\t\t\tC.maximum = m_save;\n          }\n\n        if(imgdata.rawdata.raw_image)\n          crop_masked_pixels(); \/\/ calculate black levels\n","target":1,"flaw_line_index":0,"hash":"37b29ba9-f9d0-433d-87ac-06551d5c01bd","idx":"95d1b0f1-fd65-4f3c-addb-15dd0a6cce92"}
{"func_before":"                S.iwidth = S.width;\n                S.iheight= S.height;\n                IO.shrink = 0;\n\t\t\t\tS.raw_pitch = S.width*8;\n                \/\/ allocate image as temporary buffer, size \n                imgdata.rawdata.raw_alloc = 0;\n                imgdata.image = (ushort (*)[4]) calloc(S.iwidth*S.iheight,sizeof(*imgdata.image));\n              }\n            ID.input->seek(libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\n\n\t\t\tunsigned m_save = C.maximum;\n\t\t\tif(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))\n\t\t\t\tC.maximum=65535;\n            (this->*load_raw)();\n\t\t\tif(load_raw == &LibRaw::unpacked_load_raw && !strcasecmp(imgdata.idata.make,\"Nikon\"))\n\t\t\t\tC.maximum = m_save;\n\t\t\tif (decoder_info.decoder_flags & LIBRAW_DECODER_LEGACY)\n\t\t\t{\n\t\t\t\t\/\/ successfully decoded legacy image, attach image to raw_alloc\n\t\t\t\timgdata.rawdata.raw_alloc = imgdata.image;\n\t\t\t\timgdata.image = 0; \n\t\t\t}\n          }\n\n        if(imgdata.rawdata.raw_image)\n          crop_masked_pixels(); \/\/ calculate black levels\n","target":0,"flaw_line_index":0,"hash":"9b80b3a6-1991-4174-86f9-db577dadcd8d","idx":"898a1435-6119-47de-b844-2def0f3a0175"}
{"func_before":"\tsize_t copied;\n\tint err;\n\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (addr_len)\n\t\t*addr_len=sizeof(*sin6);\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len);\n\n\tif (np->rxpmtu && np->rxopt.bits.rxpmtu)\n\t\tsin6->sin6_family = AF_INET6;\n\t\tsin6->sin6_port = 0;\n\t\tsin6->sin6_addr = ipv6_hdr(skb)->saddr;\n\t\tsin6->sin6_flowinfo = 0;\n\t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t\t  IP6CB(skb)->iif);\n\t}\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (np->rxopt.all)","target":1,"flaw_line_index":0,"hash":"b9bb0afe-605d-4359-a294-fcdecaeca7ec","idx":"cdad374d-5589-48ef-83e7-fd6386677524"}
{"func_before":"\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\n\tif (flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ipv6_recv_error(sk, msg, len);\n\n\tif (np->rxpmtu && np->rxopt.bits.rxpmtu)\n\t\tsin6->sin6_port = 0;\n\t\tsin6->sin6_addr = ipv6_hdr(skb)->saddr;\n\t\tsin6->sin6_flowinfo = 0;\n\t\tsin6->sin6_scope_id = ipv6_iface_scope_id(&sin6->sin6_addr,\n\t\t\t\t\t\t\t  IP6CB(skb)->iif);\n\t\t*addr_len = sizeof(*sin6);\n\t}\n\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (np->rxopt.all)","target":0,"flaw_line_index":0,"hash":"bbfa8d1f-6d3a-4b19-937e-04ef137838fc","idx":"213abb95-fe5a-411b-89af-fc6925a858af"}
{"func_before":"  CURLcode result;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  struct SessionHandle *data = conn->data;\n  struct pingpong *pp = &smtpc->pp;\n  const char *path = conn->data->state.path;\n  int len;\n  char localhost[HOSTNAME_MAX + 1];\n\n  *done = FALSE; \/* default to not done yet *\/\n\n  \/* If there already is a protocol-specific struct allocated for this\n    else\n      path = \"localhost\";\n  }\n\n  \/* url decode the path and use it as domain with EHLO *\/\n  smtpc->domain = curl_easy_unescape(conn->data, path, 0, &len);\n  if(!smtpc->domain)\n    return CURLE_OUT_OF_MEMORY;\n\n  \/* When we connect, we start in the state where we await the server greeting\n   *\/\n  state(conn, SMTP_SERVERGREET);\n","target":1,"flaw_line_index":0,"hash":"a1ace61b-65de-4f04-bad9-806214620237","idx":"e5434104-50e6-433e-9622-9b7fd6527e83"}
{"func_before":"{\n  CURLcode result;\n  struct smtp_conn *smtpc = &conn->proto.smtpc;\n  struct SessionHandle *data = conn->data;\n  struct pingpong *pp = &smtpc->pp;\n  const char *path = conn->data->state.path;\n  char localhost[HOSTNAME_MAX + 1];\n\n  *done = FALSE; \/* default to not done yet *\/\n\n  \/* If there already is a protocol-specific struct allocated for this\n    else\n      path = \"localhost\";\n  }\n\n  \/* url decode the path and use it as domain with EHLO *\/\n  result = Curl_urldecode(conn->data, path, 0, &smtpc->domain, NULL, TRUE);\n  if(result)\n    return result;\n\n  \/* When we connect, we start in the state where we await the server greeting\n   *\/\n  state(conn, SMTP_SERVERGREET);\n","target":0,"flaw_line_index":0,"hash":"0db837c7-b080-47d8-895c-05c6cc4d838e","idx":"09c033d3-9a5a-4235-97a7-39a7636495d7"}
{"func_before":"\t\t\t\t\trequired_rate = default_rtp_rate;\n\t\t\t\t}\n\t\t\t\t\/*systems streams*\/\n\t\t\t\telse if (gf_isom_has_sync_shadows(file, TrackNum) || gf_isom_has_sample_dependency(file, TrackNum)) {\n\t\t\t\t\tflags |= GP_RTP_PCK_SYSTEMS_CAROUSEL;\n\t\t\t\t}\n\t\t\t\tgf_odf_desc_del((GF_Descriptor*)esd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\thintType = GF_RTP_PAYT_H263;\n\t\t\trequired_rate = 90000;\n\t\t\tstreamType = GF_STREAM_VISUAL;","target":1,"flaw_line_index":0,"hash":"33e9f8b1-e3a1-4970-89ce-cd89fe7b7cde","idx":"2a81b65a-4c04-48eb-8dfe-fd8261f6944e"}
{"func_before":"\t\t\t\t}\n\t\t\t\t\/*systems streams*\/\n\t\t\t\telse if (gf_isom_has_sync_shadows(file, TrackNum) || gf_isom_has_sample_dependency(file, TrackNum)) {\n\t\t\t\t\tflags |= GP_RTP_PCK_SYSTEMS_CAROUSEL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (esd)\n\t\t\t\tgf_odf_desc_del((GF_Descriptor*)esd);\n\t\t\tbreak;\n\t\tcase GF_ISOM_SUBTYPE_3GP_H263:\n\t\t\thintType = GF_RTP_PAYT_H263;\n\t\t\trequired_rate = 90000;\n\t\t\tstreamType = GF_STREAM_VISUAL;","target":0,"flaw_line_index":0,"hash":"47231726-34d0-4f08-bb2d-78f29fe7b5f1","idx":"4c2b78c0-2896-407b-9487-c9d7736be9ba"}
{"func_before":"                diag_index_size, \" elements.\"));\n        if (diag_index_size > 1) {\n          upper_diag_index = diag_index.flat<int32>()(1);\n        }\n      }\n      padding_value = context->input(2).flat<T>()(0);\n    }\n    const TensorShape& input_shape = input.shape();\n\n    \/\/ Preliminary validation of sizes.\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrixOrHigher(input_shape),","target":1,"flaw_line_index":0,"hash":"20fd571f-6bb2-49a5-9005-0d8e4b62548a","idx":"b3050f8e-7b87-4a0e-b199-7877cf120da4"}
{"func_before":"                diag_index_size, \" elements.\"));\n        if (diag_index_size > 1) {\n          upper_diag_index = diag_index.flat<int32>()(1);\n        }\n      }\n      const Tensor& padding_in = context->input(2);\n      OP_REQUIRES(context, padding_in.NumElements() == 1,\n                  errors::InvalidArgument(\"Padding must be scalar.\"));\n      padding_value = padding_in.flat<T>()(0);\n    }\n    const TensorShape& input_shape = input.shape();\n\n    \/\/ Preliminary validation of sizes.\n    OP_REQUIRES(context, TensorShapeUtils::IsMatrixOrHigher(input_shape),","target":0,"flaw_line_index":0,"hash":"4185db2b-aeb4-44bd-8e38-dd59361bf530","idx":"85c1520e-1725-40ea-8345-0b47130aff0b"}
{"func_before":"static int sock_close(struct inode *inode, struct file *filp)\n{\n\tsock_release(SOCKET_I(inode));\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"d66a4987-da6e-4ed2-a1e4-71c25a6e9e4a","idx":"8df4d647-4e2f-4592-b159-5b4c9e790d26"}
{"func_before":"static int sock_close(struct inode *inode, struct file *filp)\n{\n\t__sock_release(SOCKET_I(inode), inode);\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"1e00acc6-5989-4a9b-8434-23bbf0534393","idx":"506f89dc-0604-4d1b-a998-1e44b54a4b3a"}
{"func_before":"\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tupdate_read_synchronize(update, s);\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;","target":1,"flaw_line_index":0,"hash":"fa0c28f8-39b9-4a50-b7fa-3044a2902011","idx":"876b4dfb-301a-4247-b8c8-1b14990c1c20"}
{"func_before":"\t\t\tfree_palette_update(context, palette_update);\n\t\t}\n\t\tbreak;\n\n\t\tcase UPDATE_TYPE_SYNCHRONIZE:\n\t\t\tif (!update_read_synchronize(update, s))\n\t\t\t\tgoto fail;\n\t\t\trc = IFCALLRESULT(TRUE, update->Synchronize, context);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;","target":0,"flaw_line_index":0,"hash":"fd918a94-2069-497d-8da4-dde910f6ee51","idx":"ddef9b42-ec97-4b33-b34a-8b7cda8061a8"}
{"func_before":"static int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct task_group *tg = cfs_rq->tg;\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg);\n\tu64 amount = 0, min_amount, expires;\n\tint expires_seq;\n\n\t\/* note: this is a positive sum as runtime_remaining <= 0 *\/\n\tmin_amount = sched_cfs_bandwidth_slice() - cfs_rq->runtime_remaining;\n\n\traw_spin_lock(&cfs_b->lock);\n\t\t\tamount = min(cfs_b->runtime, min_amount);\n\t\t\tcfs_b->runtime -= amount;\n\t\t\tcfs_b->idle = 0;\n\t\t}\n\t}\n\texpires_seq = cfs_b->expires_seq;\n\texpires = cfs_b->runtime_expires;\n\traw_spin_unlock(&cfs_b->lock);\n\n\tcfs_rq->runtime_remaining += amount;\n\t\/*\n\t * we may have advanced our local expiration to account for allowed\n\t * spread between our sched_clock and the one on which runtime was\n\t * issued.\n\t *\/\n\tif (cfs_rq->expires_seq != expires_seq) {\n\t\tcfs_rq->expires_seq = expires_seq;\n\t\tcfs_rq->runtime_expires = expires;\n\t}\n\n\treturn cfs_rq->runtime_remaining > 0;\n}","target":1,"flaw_line_index":0,"hash":"05a582d1-7c7d-4089-8619-01df2032fa94","idx":"1ab566f1-38f3-4cf6-aa5e-538de41fc525"}
{"func_before":"static int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tstruct task_group *tg = cfs_rq->tg;\n\tstruct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg);\n\tu64 amount = 0, min_amount;\n\n\t\/* note: this is a positive sum as runtime_remaining <= 0 *\/\n\tmin_amount = sched_cfs_bandwidth_slice() - cfs_rq->runtime_remaining;\n\n\traw_spin_lock(&cfs_b->lock);\n\t\tif (cfs_b->runtime > 0) {\n\t\t\tamount = min(cfs_b->runtime, min_amount);\n\t\t\tcfs_b->runtime -= amount;\n\t\t\tcfs_b->idle = 0;\n\t\t}\n\t}\n\traw_spin_unlock(&cfs_b->lock);\n\n\tcfs_rq->runtime_remaining += amount;\n\n\treturn cfs_rq->runtime_remaining > 0;\n}","target":0,"flaw_line_index":0,"hash":"77d27219-413e-4bd1-b764-21aacbaad398","idx":"45be028c-5d1e-49bb-b8d5-9f71f1d039c6"}
{"func_before":"void show_object_with_name(FILE *out, struct object *obj,\n\t\t\t   struct strbuf *path, const char *component)\n{\n\tchar *name = path_name(path, component);\n\tchar *p;\n\n\tfprintf(out, \"%s \", oid_to_hex(&obj->oid));\n\tfor (p = name; *p && *p != '\\n'; p++)\n\t\tfputc(*p, out);\n\tfputc('\\n', out);\n\n\tfree(name);\n}","target":1,"flaw_line_index":0,"hash":"10288ef7-852f-4a88-8f3f-d1c410d50978","idx":"b3d4548c-7e3d-447d-bba0-471770070b3b"}
{"func_before":"void show_object_with_name(FILE *out, struct object *obj, const char *name)\n{\n\tconst char *p;\n\n\tfprintf(out, \"%s \", oid_to_hex(&obj->oid));\n\tfor (p = name; *p && *p != '\\n'; p++)\n\t\tfputc(*p, out);\n\tfputc('\\n', out);\n}","target":0,"flaw_line_index":0,"hash":"004d4fbb-c444-4f95-a637-a93f3eab2782","idx":"74f10b13-1c68-4142-8f20-aed9064858fb"}
{"func_before":"                           OpData* data, const RuntimeShape& lhs_shape,\n                           const TfLiteTensor* lhs,\n                           const RuntimeShape& rhs_shape,\n                           const TfLiteTensor* rhs, TfLiteTensor* output) {\n  if (lhs->type == kTfLiteFloat32) {\n    TfLiteTensor* input_quantized = GetTemporary(context, node, \/*index=*\/2);\n    TfLiteTensor* scaling_factors = GetTemporary(context, node, \/*index=*\/3);\n    TfLiteTensor* accum_scratch = GetTemporary(context, node, \/*index=*\/4);\n    TfLiteTensor* input_offsets = GetTemporary(context, node, \/*index=*\/5);\n    TfLiteTensor* row_sums = GetTemporary(context, node, \/*index=*\/6);\n    return EvalHybrid<kernel_type>(\n        context, node, data, lhs_shape, lhs, rhs_shape, rhs, input_quantized,\n        scaling_factors, accum_scratch, row_sums, input_offsets, output);\n  } else if (lhs->type == kTfLiteInt8) {\n    return EvalInt8<kernel_type>(context, data, lhs_shape, lhs, rhs_shape, rhs,","target":1,"flaw_line_index":0,"hash":"b067c799-6825-48cc-90ef-00e5c16aabef","idx":"453eaa87-c2fc-4424-bdd7-abfcddec15a5"}
{"func_before":"                           OpData* data, const RuntimeShape& lhs_shape,\n                           const TfLiteTensor* lhs,\n                           const RuntimeShape& rhs_shape,\n                           const TfLiteTensor* rhs, TfLiteTensor* output) {\n  if (lhs->type == kTfLiteFloat32) {\n    TfLiteTensor* input_quantized;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, \/*index=*\/2,\n                                                &input_quantized));\n    TfLiteTensor* scaling_factors;\n    TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, \/*index=*\/3,\n                                                &scaling_factors));\n    TfLiteTensor* accum_scratch;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, \/*index=*\/4, &accum_scratch));\n    TfLiteTensor* input_offsets;\n    TF_LITE_ENSURE_OK(\n        context, GetTemporarySafe(context, node, \/*index=*\/5, &input_offsets));\n    TfLiteTensor* row_sums;\n    TF_LITE_ENSURE_OK(context,\n                      GetTemporarySafe(context, node, \/*index=*\/6, &row_sums));\n    return EvalHybrid<kernel_type>(\n        context, node, data, lhs_shape, lhs, rhs_shape, rhs, input_quantized,\n        scaling_factors, accum_scratch, row_sums, input_offsets, output);\n  } else if (lhs->type == kTfLiteInt8) {\n    return EvalInt8<kernel_type>(context, data, lhs_shape, lhs, rhs_shape, rhs,","target":0,"flaw_line_index":0,"hash":"d5a87b3d-1f68-45d0-81ab-dfffd8995862","idx":"0e2c30da-9869-418d-a716-51ee8a195439"}
{"func_before":"int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tint err = -EINVAL;\n\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t\tgoto error;\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < kcontrol->count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n\n error:\n\tsnd_ctl_free_one(kcontrol);","target":1,"flaw_line_index":0,"hash":"5482a348-5f0d-49bd-a0cf-1e1559e99c16","idx":"1c175589-7452-41aa-9b7f-4f3350d7893a"}
{"func_before":"int snd_ctl_add(struct snd_card *card, struct snd_kcontrol *kcontrol)\n{\n\tstruct snd_ctl_elem_id id;\n\tunsigned int idx;\n\tunsigned int count;\n\tint err = -EINVAL;\n\n\tif (! kcontrol)\n\t\treturn err;\n\tif (snd_BUG_ON(!card || !kcontrol->info))\n\t}\n\tlist_add_tail(&kcontrol->list, &card->controls);\n\tcard->controls_count += kcontrol->count;\n\tkcontrol->id.numid = card->last_numid + 1;\n\tcard->last_numid += kcontrol->count;\n\tcount = kcontrol->count;\n\tup_write(&card->controls_rwsem);\n\tfor (idx = 0; idx < count; idx++, id.index++, id.numid++)\n\t\tsnd_ctl_notify(card, SNDRV_CTL_EVENT_MASK_ADD, &id);\n\treturn 0;\n\n error:\n\tsnd_ctl_free_one(kcontrol);","target":0,"flaw_line_index":0,"hash":"46f9a860-ee98-42b6-8ef8-ec6dd55442c9","idx":"398b5584-ae86-4162-bf58-01eef556d04b"}
{"func_before":"  if (cpi->initial_width) {\n    int new_mi_size = 0;\n    vp9_set_mb_mi(cm, cm->width, cm->height);\n    new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n    if (cm->mi_alloc_size < new_mi_size) {\n      vp9_free_context_buffers(cm);\n      alloc_compressor_data(cpi);\n      realloc_segmentation_maps(cpi);\n      cpi->initial_width = cpi->initial_height = 0;\n      cpi->external_resize = 0;\n    } else if (cm->mi_alloc_size == new_mi_size &&\n  if (cm->current_video_frame == 0 || last_w != cpi->oxcf.width ||\n      last_h != cpi->oxcf.height)\n    update_frame_size(cpi);\n\n  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n    memset(cpi->consec_zero_mv, 0,\n           cm->mi_rows * cm->mi_cols * sizeof(*cpi->consec_zero_mv));\n    if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)\n      vp9_cyclic_refresh_reset_resize(cpi);\n    rc->rc_1_frame = 0;\n    rc->rc_2_frame = 0;\n  }","target":1,"flaw_line_index":0,"hash":"3b554546-96d0-4b5a-9838-d15a0255f508","idx":"577e2115-1e27-4b58-8103-6c0a59dedd5b"}
{"func_before":"    int new_mi_size = 0;\n    vp9_set_mb_mi(cm, cm->width, cm->height);\n    new_mi_size = cm->mi_stride * calc_mi_size(cm->mi_rows);\n    if (cm->mi_alloc_size < new_mi_size) {\n      vp9_free_context_buffers(cm);\n      vp9_free_pc_tree(&cpi->td);\n      vpx_free(cpi->mbmi_ext_base);\n      alloc_compressor_data(cpi);\n      realloc_segmentation_maps(cpi);\n      cpi->initial_width = cpi->initial_height = 0;\n      cpi->external_resize = 0;\n    } else if (cm->mi_alloc_size == new_mi_size &&\n  if (cm->current_video_frame == 0 || last_w != cpi->oxcf.width ||\n      last_h != cpi->oxcf.height)\n    update_frame_size(cpi);\n\n  if (last_w != cpi->oxcf.width || last_h != cpi->oxcf.height) {\n    vpx_free(cpi->consec_zero_mv);\n    CHECK_MEM_ERROR(\n        cm, cpi->consec_zero_mv,\n        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(*cpi->consec_zero_mv)));\n\n    vpx_free(cpi->skin_map);\n    CHECK_MEM_ERROR(\n        cm, cpi->skin_map,\n        vpx_calloc(cm->mi_rows * cm->mi_cols, sizeof(cpi->skin_map[0])));\n\n    free_copy_partition_data(cpi);\n    alloc_copy_partition_data(cpi);\n    if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)\n      vp9_cyclic_refresh_reset_resize(cpi);\n    rc->rc_1_frame = 0;\n    rc->rc_2_frame = 0;\n  }","target":0,"flaw_line_index":0,"hash":"eca9ff3e-2053-4b41-90ca-7f80f176fabc","idx":"81303f10-08fb-4b6c-92e5-1abf3b63f585"}
{"func_before":"\t\t *\/\n\t\tnewoff = (uint32_t) (offset - virtio_config_size);\n\t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize : 0x100000000;\n\t\tif ((newoff + ((unsigned) size)) > max)\n\t\t\tgoto bad;\n\t\terror = (*vc->vc_cfgread)(DEV_SOFTC(vs), ((int) newoff), size, &value);\n\t\tif (!error)\n\t\t\tgoto done;\n\t}\n\nbad:","target":1,"flaw_line_index":0,"hash":"c5349db8-885d-4d07-880c-3f4c0f1908f7","idx":"37828171-e1b5-4584-a179-2918fcce4844"}
{"func_before":"\t\t *\/\n\t\tnewoff = (uint32_t) (offset - virtio_config_size);\n\t\tmax = vc->vc_cfgsize ? vc->vc_cfgsize : 0x100000000;\n\t\tif ((newoff + ((unsigned) size)) > max)\n\t\t\tgoto bad;\n\t\tif (vc->vc_cfgread != NULL)\n\t\t\terror = (*vc->vc_cfgread)(DEV_SOFTC(vs), ((int) newoff), size, &value);\n\t\telse\n\t\t\terror = 0;\n\t\tif (!error)\n\t\t\tgoto done;\n\t}\n\nbad:","target":0,"flaw_line_index":0,"hash":"1cde6276-46e2-45d8-81d3-d053ed779067","idx":"f574a567-1ec6-416c-8dd0-886ad25bd84b"}
{"func_before":"\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tutils::run_interactively(cmdline, \"pb_controller::play_file\");\n}","target":1,"flaw_line_index":0,"hash":"816f7d0d-c659-48d3-afc8-b41f951e9b8e","idx":"eed001a4-093a-4961-88f7-3aa04774dc9e"}
{"func_before":"\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" '\");\n\tcmdline.append(utils::replace_all(file,\"'\", \"%27\"));\n\tcmdline.append(\"'\");\n\tstfl::reset();\n\tutils::run_interactively(cmdline, \"pb_controller::play_file\");\n}","target":0,"flaw_line_index":0,"hash":"01602d72-4ccd-46b3-97d3-8b37786b3e4d","idx":"c3349ac7-b226-4887-a042-2efc3f26e2e3"}
{"func_before":"compile_nested_function(exarg_T *eap, cctx_T *cctx)\n{\n    int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';\n    char_u\t*name_start = eap->arg;\n    char_u\t*name_end = to_name_end(eap->arg, TRUE);\n    char_u\t*lambda_name;\n    ufunc_T\t*ufunc;\n    int\t\tr = FAIL;\n    compiletype_T   compile_type;\n\n    eap->forceit = FALSE;\n    \/\/ We use the special <Lamba>99 name, but it's not really a lambda.\n    lambda_name = vim_strsave(get_lambda_name());\n    if (lambda_name == NULL)\n\treturn NULL;\n    ufunc = define_function(eap, lambda_name);\n\n    if (ufunc == NULL)\n    {\n\tr = eap->skip ? OK : FAIL;\n\tgoto theend;\n\tcompile_def_function(ufunc, FALSE, CT_NONE, cctx);\n#endif\n\n    if (is_global)\n    {\n\tchar_u *func_name = vim_strnsave(name_start + 2,\n\t\t\t\t\t\t    name_end - name_start - 2);\n\n\tif (func_name == NULL)\n\t    r = FAIL;\n\telse\n\t{\n\t    r = generate_NEWFUNC(cctx, lambda_name, func_name);\n\t    lambda_name = NULL;\n\t}\n    }\n    else\n    {\n\t\/\/ Define a local variable for the function reference.\n\tlvar_T\t*lvar = reserve_local(cctx, name_start, name_end - name_start,\n\t\t\t\t\t\t    TRUE, ufunc->uf_func_type);\n\n\tif (lvar == NULL)\n\t    goto theend;\n\tif (generate_FUNCREF(cctx, ufunc) == FAIL)\n\t    goto theend;\n\tr = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);\n    }\n\ntheend:\n    vim_free(lambda_name);\n    return r == FAIL ? NULL : (char_u *)\"\";\n}","target":1,"flaw_line_index":0,"hash":"5ac02857-f3cb-475f-96e2-9b713badc11e","idx":"8782ee24-bc4b-4f30-8460-333358c636b1"}
{"func_before":"compile_nested_function(exarg_T *eap, cctx_T *cctx, char_u **line_to_free)\n{\n    int\t\tis_global = *eap->arg == 'g' && eap->arg[1] == ':';\n    char_u\t*name_start = eap->arg;\n    char_u\t*name_end = to_name_end(eap->arg, TRUE);\n    int\t\toff;\n    char_u\t*func_name;\n    char_u\t*lambda_name;\n    ufunc_T\t*ufunc;\n    int\t\tr = FAIL;\n    compiletype_T   compile_type;\n\n    eap->forceit = FALSE;\n    \/\/ We use the special <Lamba>99 name, but it's not really a lambda.\n    lambda_name = vim_strsave(get_lambda_name());\n    if (lambda_name == NULL)\n\treturn NULL;\n\n    \/\/ This may free the current line, make a copy of the name.\n    off = is_global ? 2 : 0;\n    func_name = vim_strnsave(name_start + off, name_end - name_start - off);\n    if (func_name == NULL)\n    {\n\tr = FAIL;\n\tgoto theend;\n    }\n\n    ufunc = define_function(eap, lambda_name, line_to_free);\n\n    if (ufunc == NULL)\n    {\n\tr = eap->skip ? OK : FAIL;\n\tgoto theend;\n\tcompile_def_function(ufunc, FALSE, CT_NONE, cctx);\n#endif\n\n    if (is_global)\n    {\n\tr = generate_NEWFUNC(cctx, lambda_name, func_name);\n\tfunc_name = NULL;\n\tlambda_name = NULL;\n    }\n    else\n    {\n\t\/\/ Define a local variable for the function reference.\n\tlvar_T\t*lvar = reserve_local(cctx, func_name, name_end - name_start,\n\t\t\t\t\t\t    TRUE, ufunc->uf_func_type);\n\n\tif (lvar == NULL)\n\t    goto theend;\n\tif (generate_FUNCREF(cctx, ufunc) == FAIL)\n\tr = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);\n    }\n\ntheend:\n    vim_free(lambda_name);\n    vim_free(func_name);\n    return r == FAIL ? NULL : (char_u *)\"\";\n}","target":0,"flaw_line_index":0,"hash":"8847b571-1916-4588-96c4-a7a888a0a837","idx":"b4ac51ba-7612-43bc-b253-480eb9392d67"}
{"func_before":"        {\"CreationDate\", \"\"},\n        {\"ModDate\",      \"\"},\n        {\"Trapped\",      \"\"},\n    };\n\n    daddy = malloc(sizeof(creator_template));\n    memcpy(daddy, creator_template, sizeof(creator_template));\n\n    if (n_elements)\n      *n_elements = sizeof(creator_template) \/ sizeof(creator_template[0]);\n","target":1,"flaw_line_index":0,"hash":"e2dfd2f6-bfc8-43a7-b5f1-4dc20aa92ea8","idx":"1e0d34b2-3030-431f-96e4-8796b973b089"}
{"func_before":"        {\"CreationDate\", \"\"},\n        {\"ModDate\",      \"\"},\n        {\"Trapped\",      \"\"},\n    };\n\n    daddy = safe_calloc(sizeof(creator_template));\n    memcpy(daddy, creator_template, sizeof(creator_template));\n\n    if (n_elements)\n      *n_elements = sizeof(creator_template) \/ sizeof(creator_template[0]);\n","target":0,"flaw_line_index":0,"hash":"00af1b89-b44d-4314-a434-bc947936c6b9","idx":"b23a7789-fc3f-4889-bb71-93f33a1c41b0"}
{"func_before":"inline void AveragePool(const PoolParams& params,\n                        const RuntimeShape& input_shape, const int8* input_data,\n                        const RuntimeShape& output_shape, int8* output_data) {\n  ruy::profiler::ScopeLabel label(\"AveragePool\/8bitWith32bitAccumulator\");\n\n  \/\/ Here, and in other pooling ops, in order to maintain locality of reference,\n  \/\/ to minimize some recalculations, and to load into NEON vector registers, we\n  \/\/ use an inner loop down the depth. Since depths can be large and hence we\n  \/\/ would need arbitrarily large temporary storage, we divide the work up into\n  \/\/ depth tranches just within the batch loop.\n  static constexpr int kPoolingAccTrancheSize = 256;\n\n  TFLITE_DCHECK_LE(params.quantized_activation_min,\n                   params.quantized_activation_max);\n  TFLITE_DCHECK_EQ(input_shape.DimensionsCount(), 4);\n  TFLITE_DCHECK_EQ(output_shape.DimensionsCount(), 4);\n  const int batches = MatchingDim(input_shape, 0, output_shape, 0);\n  const int depth = MatchingDim(input_shape, 3, output_shape, 3);\n  const int input_height = input_shape.Dims(1);\n  const int input_width = input_shape.Dims(2);\n  const int output_height = output_shape.Dims(1);\n  const int output_width = output_shape.Dims(2);\n  const int stride_height = params.stride_height;\n  const int stride_width = params.stride_width;\n\n  int32 acc[kPoolingAccTrancheSize];\n  for (int batch = 0; batch < batches; ++batch) {\n    \/\/ We proceed through the depth in tranches (see comment above). The\n    \/\/ depth_base is the depth at the beginning of the tranche. The\n    \/\/ tranche_depth is the depth dimension of the tranche.\n    for (int depth_base = 0; depth_base < depth;\n         depth_base += kPoolingAccTrancheSize) {\n      const int tranche_depth =\n          std::min(depth - depth_base, kPoolingAccTrancheSize);\n      for (int out_y = 0; out_y < output_height; ++out_y) {\n        for (int out_x = 0; out_x < output_width; ++out_x) {\n          const int in_x_origin =\n              (out_x * stride_width) - params.padding_values.width;\n          const int in_y_origin =\n              (out_y * stride_height) - params.padding_values.height;\n          const int filter_x_start = std::max(0, -in_x_origin);\n          const int filter_x_end =\n              std::min(params.filter_width, input_width - in_x_origin);\n          const int filter_y_start = std::max(0, -in_y_origin);\n          const int filter_y_end =\n              std::min(params.filter_height, input_height - in_y_origin);\n          const int filter_count =\n              (filter_x_end - filter_x_start) * (filter_y_end - filter_y_start);\n          memset(acc, 0, tranche_depth * sizeof(acc[0]));\n          const int8* input_ptr =\n              input_data + depth_base +\n              depth * (in_x_origin +\n                       input_width * (in_y_origin + input_height * batch));\n          for (int fy = filter_y_start; fy < filter_y_end; fy++) {\n            const int8* input_row_ptr =\n                input_ptr + depth * (fy * input_width + filter_x_start);\n            for (int fx = filter_x_start; fx < filter_x_end; fx++) {\n              const int8* input_channel_ptr = input_row_ptr;\n              int channel = 0;\n#ifdef USE_NEON\n              for (; channel <= tranche_depth - 16; channel += 16) {\n                int16x4_t acc_reg[4];\n                int8x16_t input_reg = vld1q_s8(input_channel_ptr);\n                input_channel_ptr += 16;\n                acc_reg[0] = vget_low_s16(vmovl_s8(vget_low_s8(input_reg)));\n                acc_reg[1] = vget_high_s16(vmovl_s8(vget_low_s8(input_reg)));\n                acc_reg[2] = vget_low_s16(vmovl_s8(vget_high_s8(input_reg)));\n                acc_reg[3] = vget_high_s16(vmovl_s8(vget_high_s8(input_reg)));\n                for (int i = 0; i < 4; i++) {\n                  vst1q_s32(\n                      acc + channel + 4 * i,\n                      vaddw_s16(vld1q_s32(acc + channel + 4 * i), acc_reg[i]));\n                }\n              }\n              for (; channel <= tranche_depth - 8; channel += 8) {\n                int16x4_t acc_reg[2];\n                int16x8_t input_reg = vmovl_s8(vld1_s8(input_channel_ptr));\n                input_channel_ptr += 8;\n                acc_reg[0] = vget_low_s16(input_reg);\n                acc_reg[1] = vget_high_s16(input_reg);\n                for (int i = 0; i < 2; i++) {\n                  vst1q_s32(\n                      acc + channel + 4 * i,\n                      vaddw_s16(vld1q_s32(acc + channel + 4 * i), acc_reg[i]));\n                }\n              }\n#endif\n              for (; channel < tranche_depth; ++channel) {\n                acc[channel] += *input_channel_ptr++;\n              }\n              input_row_ptr += depth;\n            }\n          }\n          int8* output_ptr = output_data + Offset(output_shape, batch, out_y,\n                                                  out_x, depth_base);\n          int channel = 0;\n#ifdef USE_NEON\n          for (; channel <= tranche_depth - 8; channel += 8) {\n            int16 buf[8];\n            for (int i = 0; i < 8; i++) {\n              buf[i] =\n                  acc[channel + i] > 0\n                      ? (acc[channel + i] + filter_count \/ 2) \/ filter_count\n                      : (acc[channel + i] - filter_count \/ 2) \/ filter_count;\n            }\n            int8x8_t buf8 = vqmovn_s16(vld1q_s16(buf));\n            buf8 = vmin_s8(buf8, vdup_n_s8(params.quantized_activation_max));\n            buf8 = vmax_s8(buf8, vdup_n_s8(params.quantized_activation_min));\n            vst1_s8(output_ptr + channel, buf8);\n          }\n#endif\n          for (; channel < tranche_depth; ++channel) {\n            int16 a = acc[channel] > 0\n                          ? (acc[channel] + filter_count \/ 2) \/ filter_count\n                          : (acc[channel] - filter_count \/ 2) \/ filter_count;\n            a = std::max<int16>(a, params.quantized_activation_min);\n            a = std::min<int16>(a, params.quantized_activation_max);\n            output_ptr[channel] = static_cast<int8>(a);\n          }\n        }\n      }\n    }\n  }\n}","target":1,"flaw_line_index":0,"hash":"f07dc369-645b-45ed-9c68-6cdbfdba5e04","idx":"99c30bc6-4994-4710-bc70-a99ba2908842"}
{"func_before":"inline bool AveragePool(const PoolParams& params,\n                        const RuntimeShape& input_shape, const int8* input_data,\n                        const RuntimeShape& output_shape, int8* output_data) {\n  ruy::profiler::ScopeLabel label(\"AveragePool\/8bitWith32bitAccumulator\");\n\n  \/\/ Here, and in other pooling ops, in order to maintain locality of reference,\n  \/\/ to minimize some recalculations, and to load into NEON vector registers, we\n  \/\/ use an inner loop down the depth. Since depths can be large and hence we\n  \/\/ would need arbitrarily large temporary storage, we divide the work up into\n  \/\/ depth tranches just within the batch loop.\n  static constexpr int kPoolingAccTrancheSize = 256;\n\n  TFLITE_DCHECK_LE(params.quantized_activation_min,\n                   params.quantized_activation_max);\n  TFLITE_DCHECK_EQ(input_shape.DimensionsCount(), 4);\n  TFLITE_DCHECK_EQ(output_shape.DimensionsCount(), 4);\n  const int batches = MatchingDim(input_shape, 0, output_shape, 0);\n  const int depth = MatchingDim(input_shape, 3, output_shape, 3);\n  const int input_height = input_shape.Dims(1);\n  const int input_width = input_shape.Dims(2);\n  const int output_height = output_shape.Dims(1);\n  const int output_width = output_shape.Dims(2);\n  const int stride_height = params.stride_height;\n  const int stride_width = params.stride_width;\n\n  int32 acc[kPoolingAccTrancheSize];\n  for (int batch = 0; batch < batches; ++batch) {\n    \/\/ We proceed through the depth in tranches (see comment above). The\n    \/\/ depth_base is the depth at the beginning of the tranche. The\n    \/\/ tranche_depth is the depth dimension of the tranche.\n    for (int depth_base = 0; depth_base < depth;\n         depth_base += kPoolingAccTrancheSize) {\n      const int tranche_depth =\n          std::min(depth - depth_base, kPoolingAccTrancheSize);\n      for (int out_y = 0; out_y < output_height; ++out_y) {\n        for (int out_x = 0; out_x < output_width; ++out_x) {\n          const int in_x_origin =\n              (out_x * stride_width) - params.padding_values.width;\n          const int in_y_origin =\n              (out_y * stride_height) - params.padding_values.height;\n          const int filter_x_start = std::max(0, -in_x_origin);\n          const int filter_x_end =\n              std::min(params.filter_width, input_width - in_x_origin);\n          const int filter_y_start = std::max(0, -in_y_origin);\n          const int filter_y_end =\n              std::min(params.filter_height, input_height - in_y_origin);\n          const int filter_count =\n              (filter_x_end - filter_x_start) * (filter_y_end - filter_y_start);\n          if (filter_count == 0) return false;\n          memset(acc, 0, tranche_depth * sizeof(acc[0]));\n          const int8* input_ptr =\n              input_data + depth_base +\n              depth * (in_x_origin +\n                       input_width * (in_y_origin + input_height * batch));\n          for (int fy = filter_y_start; fy < filter_y_end; fy++) {\n            const int8* input_row_ptr =\n                input_ptr + depth * (fy * input_width + filter_x_start);\n            for (int fx = filter_x_start; fx < filter_x_end; fx++) {\n              const int8* input_channel_ptr = input_row_ptr;\n              int channel = 0;\n#ifdef USE_NEON\n              for (; channel <= tranche_depth - 16; channel += 16) {\n                int16x4_t acc_reg[4];\n                int8x16_t input_reg = vld1q_s8(input_channel_ptr);\n                input_channel_ptr += 16;\n                acc_reg[0] = vget_low_s16(vmovl_s8(vget_low_s8(input_reg)));\n                acc_reg[1] = vget_high_s16(vmovl_s8(vget_low_s8(input_reg)));\n                acc_reg[2] = vget_low_s16(vmovl_s8(vget_high_s8(input_reg)));\n                acc_reg[3] = vget_high_s16(vmovl_s8(vget_high_s8(input_reg)));\n                for (int i = 0; i < 4; i++) {\n                  vst1q_s32(\n                      acc + channel + 4 * i,\n                      vaddw_s16(vld1q_s32(acc + channel + 4 * i), acc_reg[i]));\n                }\n              }\n              for (; channel <= tranche_depth - 8; channel += 8) {\n                int16x4_t acc_reg[2];\n                int16x8_t input_reg = vmovl_s8(vld1_s8(input_channel_ptr));\n                input_channel_ptr += 8;\n                acc_reg[0] = vget_low_s16(input_reg);\n                acc_reg[1] = vget_high_s16(input_reg);\n                for (int i = 0; i < 2; i++) {\n                  vst1q_s32(\n                      acc + channel + 4 * i,\n                      vaddw_s16(vld1q_s32(acc + channel + 4 * i), acc_reg[i]));\n                }\n              }\n#endif\n              for (; channel < tranche_depth; ++channel) {\n                acc[channel] += *input_channel_ptr++;\n              }\n              input_row_ptr += depth;\n            }\n          }\n          int8* output_ptr = output_data + Offset(output_shape, batch, out_y,\n                                                  out_x, depth_base);\n          int channel = 0;\n#ifdef USE_NEON\n          for (; channel <= tranche_depth - 8; channel += 8) {\n            int16 buf[8];\n            for (int i = 0; i < 8; i++) {\n              buf[i] =\n                  acc[channel + i] > 0\n                      ? (acc[channel + i] + filter_count \/ 2) \/ filter_count\n                      : (acc[channel + i] - filter_count \/ 2) \/ filter_count;\n            }\n            int8x8_t buf8 = vqmovn_s16(vld1q_s16(buf));\n            buf8 = vmin_s8(buf8, vdup_n_s8(params.quantized_activation_max));\n            buf8 = vmax_s8(buf8, vdup_n_s8(params.quantized_activation_min));\n            vst1_s8(output_ptr + channel, buf8);\n          }\n#endif\n          for (; channel < tranche_depth; ++channel) {\n            int16 a = acc[channel] > 0\n                          ? (acc[channel] + filter_count \/ 2) \/ filter_count\n                          : (acc[channel] - filter_count \/ 2) \/ filter_count;\n            a = std::max<int16>(a, params.quantized_activation_min);\n            a = std::min<int16>(a, params.quantized_activation_max);\n            output_ptr[channel] = static_cast<int8>(a);\n          }\n        }\n      }\n    }\n  }\n  return true;\n}","target":0,"flaw_line_index":0,"hash":"4c097959-fe46-40d6-87ee-3bedf0af4f14","idx":"5b81d090-c209-435e-b2b3-93c2dd418826"}
{"func_before":"\t\treturn ERR_PTR(-EINVAL);\n\n\tport = args->args[0];\n\tidx = args->args[1];\n\n\tfor (i = 0; i <= SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n","target":1,"flaw_line_index":0,"hash":"4d2c8ea8-dff6-4bfb-8046-c1e49273e8ea","idx":"3506b3d1-4963-43a8-a33e-a5522d958ff8"}
{"func_before":"\t\treturn ERR_PTR(-EINVAL);\n\n\tport = args->args[0];\n\tidx = args->args[1];\n\n\tfor (i = 0; i < SERDES_MAX; i++) {\n\t\tstruct serdes_macro *macro = phy_get_drvdata(ctrl->phys[i]);\n\n\t\tif (idx != macro->idx)\n\t\t\tcontinue;\n","target":0,"flaw_line_index":0,"hash":"18c20435-324e-48cc-ad3e-6e64db3778a6","idx":"9b36140b-5e39-4078-b26c-3c127d9116d4"}
{"func_before":"    });\n\n    if(ext.sort_flag)\n    {\n        bool failed = true;\n        if(ext.sort_script.size())\n        {\n            std::string script = ext.sort_script;\n            if(startsWith(script, \"path:\"))\n                script = fileGet(script.substr(5), false);\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)","target":1,"flaw_line_index":0,"hash":"01697795-b12a-4173-9182-2b847e225f91","idx":"9b8af119-d23f-484a-9510-87f9deb26b58"}
{"func_before":"    });\n\n    if(ext.sort_flag)\n    {\n        bool failed = true;\n        if(ext.sort_script.size() && ext.authorized)\n        {\n            std::string script = ext.sort_script;\n            if(startsWith(script, \"path:\"))\n                script = fileGet(script.substr(5), false);\n            script_safe_runner(ext.js_runtime, ext.js_context, [&](qjs::Context &ctx)","target":0,"flaw_line_index":0,"hash":"0dd0e61f-1c4e-4aeb-a7a5-f0d710199fb0","idx":"8ab022d2-e0f1-4c51-a37a-2421827b0cbf"}
{"func_before":"\tpr_debug(\"sock=%p\\n\", sock);\n\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW)\n\t\tsock->ops = &rawsock_raw_ops;\n\telse\n\t\tsock->ops = &rawsock_ops;\n\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n","target":1,"flaw_line_index":0,"hash":"d115f359-30a0-470e-927e-67149a3dc496","idx":"97ee1bfd-959c-4b6e-a02c-ee799f18ef54"}
{"func_before":"\tpr_debug(\"sock=%p\\n\", sock);\n\n\tif ((sock->type != SOCK_SEQPACKET) && (sock->type != SOCK_RAW))\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW) {\n\t\tif (!capable(CAP_NET_RAW))\n\t\t\treturn -EPERM;\n\t\tsock->ops = &rawsock_raw_ops;\n\t} else {\n\t\tsock->ops = &rawsock_ops;\n\t}\n\n\tsk = sk_alloc(net, PF_NFC, GFP_ATOMIC, nfc_proto->proto, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n","target":0,"flaw_line_index":0,"hash":"3d3b64dd-643d-45e9-9dd6-53f77d17bded","idx":"f635b8b5-bf2a-45c7-a270-63270462917a"}
{"func_before":"                yyjson_mut_obj_iter_init(rhs, &iter);\n                lhs = (yyjson_mut_val *)lhs->uni.ptr;\n                while (len-- > 0) {\n                    rhs = yyjson_mut_obj_iter_getn(&iter, lhs->uni.str,\n                                                   unsafe_yyjson_get_len(lhs));\n                    if (!rhs || !unsafe_yyjson_mut_equals(lhs->next, rhs))\n                        return false;\n                    lhs = lhs->next->next;\n                }\n            }\n            \/* yyjson allows duplicate keys, so the check may be inaccurate *\/\n            return true;","target":1,"flaw_line_index":0,"hash":"3f2fb08d-9c38-4b69-8319-85db5cb605a6","idx":"1cdddc88-1413-41dd-bc7e-49b48837c0bf"}
{"func_before":"                yyjson_mut_obj_iter_init(rhs, &iter);\n                lhs = (yyjson_mut_val *)lhs->uni.ptr;\n                while (len-- > 0) {\n                    rhs = yyjson_mut_obj_iter_getn(&iter, lhs->uni.str,\n                                                   unsafe_yyjson_get_len(lhs));\n                    if (!rhs) return false;\n                    if (!unsafe_yyjson_mut_equals(lhs->next, rhs)) return false;\n                    lhs = lhs->next->next;\n                }\n            }\n            \/* yyjson allows duplicate keys, so the check may be inaccurate *\/\n            return true;","target":0,"flaw_line_index":0,"hash":"4a9fdbe5-ca02-4bd5-81a8-ca3f4034a675","idx":"9c08208a-623a-409d-91fa-f58d0a59efe7"}
{"func_before":"\t}\n\n\tif (!start)\n\t\treturn true;\n\n\t\/* Reject paths like \".git\\\" *\/\n\tif (path[start] == '\\\\')\n\t\treturn false;\n\n\t\/* Reject paths like '.git ' or '.git.' *\/\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')","target":1,"flaw_line_index":0,"hash":"49e0f7a1-be7f-42f0-9c0c-94ad41689c19","idx":"d4979165-cb71-4ce3-bf0d-41145928a9d7"}
{"func_before":"\t}\n\n\tif (!start)\n\t\treturn true;\n\n\t\/*\n\t * Reject paths that start with Windows-style directory separators\n\t * (\".git\\\") or NTFS alternate streams (\".git:\") and could be used\n\t * to write to the \".git\" directory on Windows platforms.\n\t *\/\n\tif (path[start] == '\\\\' || path[start] == ':')\n\t\treturn false;\n\n\t\/* Reject paths like '.git ' or '.git.' *\/\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')","target":0,"flaw_line_index":0,"hash":"608271b8-e4be-44ae-b1b3-efae193f4b52","idx":"923768a9-4727-49ce-9e75-5ef3ccb9da6c"}
{"func_before":"add_mibfile(const char* tmpstr, const char* d_name, FILE *ip )\n{\n    FILE           *fp;\n    char            token[MAXTOKEN], token2[MAXTOKEN];\n\n    \/*\n    \/*\n     * simple test for this being a MIB \n     *\/\n    if (get_token(fp, token2, MAXTOKEN) == DEFINITIONS) {\n        new_module(token, tmpstr);\n        if (ip)\n            fprintf(ip, \"%s %s\\n\", token, d_name);\n        fclose(fp);\n        return 0;\n    } else {\n        fclose(fp);\n        return 1;","target":1,"flaw_line_index":0,"hash":"4cde9636-777d-4c1d-a17e-b8633e81d2e9","idx":"e79e4362-78e4-41ec-9f31-e7207104a393"}
{"func_before":"add_mibfile(const char* tmpstr, const char* d_name)\n{\n    FILE           *fp;\n    char            token[MAXTOKEN], token2[MAXTOKEN];\n\n    \/*\n    }\n    \/*\n     * simple test for this being a MIB \n     *\/\n    if (get_token(fp, token2, MAXTOKEN) == DEFINITIONS) {\n        new_module(token, tmpstr);\n        fclose(fp);\n        return 0;\n    } else {\n        fclose(fp);\n        return 1;","target":0,"flaw_line_index":0,"hash":"4a10e106-0549-408b-b4db-e5286cfb1747","idx":"4897b7fd-4cfb-4cde-88d9-0d3fdfd7a59b"}
{"func_before":"static void ufs_mtk_init_va09_pwr_ctrl(struct ufs_hba *hba)\n{\n\tstruct ufs_mtk_host *host = ufshcd_get_variant(hba);\n\n\thost->reg_va09 = regulator_get(hba->dev, \"va09\");\n\tif (!host->reg_va09)\n\t\tdev_info(hba->dev, \"failed to get va09\");\n\telse\n\t\thost->caps |= UFS_MTK_CAP_VA09_PWR_CTRL;\n}","target":1,"flaw_line_index":0,"hash":"bd96fa67-81c2-4a67-b3d1-372717b77ae8","idx":"596def78-f0e4-4389-a7cc-b4575141cab7"}
{"func_before":"static void ufs_mtk_init_va09_pwr_ctrl(struct ufs_hba *hba)\n{\n\tstruct ufs_mtk_host *host = ufshcd_get_variant(hba);\n\n\thost->reg_va09 = regulator_get(hba->dev, \"va09\");\n\tif (IS_ERR(host->reg_va09))\n\t\tdev_info(hba->dev, \"failed to get va09\");\n\telse\n\t\thost->caps |= UFS_MTK_CAP_VA09_PWR_CTRL;\n}","target":0,"flaw_line_index":0,"hash":"f5f684c1-dcde-48c5-ac20-eac143af0c32","idx":"93b9a7b1-e18b-43ef-9a62-b883576055d8"}
{"func_before":"find_entry2modify_only_ext(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int flags,\n    back_txn *txn\n\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 1\/*lock*\/, txn, \n\t\t                         FE_REALLY_INTERNAL | flags ));\n}","target":1,"flaw_line_index":0,"hash":"137e6e6e-270d-4491-b421-63ed3f285aaa","idx":"9fcde88f-2319-46a1-8457-c6707f6496e0"}
{"func_before":"find_entry2modify_only_ext(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    int flags,\n    back_txn *txn,\n    int *rc\n)\n{\n\treturn(find_entry_internal(pb, be, addr, 1\/*lock*\/, txn, FE_REALLY_INTERNAL | flags, rc));\n}","target":0,"flaw_line_index":0,"hash":"0c81f1f4-6450-4089-84aa-a2ed683de3b2","idx":"d9f00173-da51-4392-ab5c-6644cb733c6e"}
{"func_before":"static void scsi_free_request(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    qemu_vfree(r->iov.iov_base);\n}","target":1,"flaw_line_index":0,"hash":"43f530ce-f137-42a7-b938-3507f3c6a012","idx":"c0efc0af-ff27-4e55-8e79-563968c2e287"}
{"func_before":"static void scsi_free_request(SCSIRequest *req)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n\n    if (r->iov.iov_base) {\n        qemu_vfree(r->iov.iov_base);\n    }\n}","target":0,"flaw_line_index":0,"hash":"18f9be71-0c70-48e7-ba4b-7d0ca1af55e5","idx":"a5cd1f09-e5ce-4e7c-80e6-0eaebe7fc8b2"}
{"func_before":"static int masq_inet_event(struct notifier_block *this,\n\t\t\t   unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct net_device *dev = ((struct in_ifaddr *)ptr)->ifa_dev->dev;\n\tstruct netdev_notifier_info info;\n\n\tnetdev_notifier_info_init(&info, dev);\n\treturn masq_device_event(this, event, &info);\n}","target":1,"flaw_line_index":0,"hash":"d8d4694a-b180-4559-b1cc-fc2d15c66128","idx":"e6d3ac97-f7aa-4ca3-a745-3182d8007e7e"}
{"func_before":"static int masq_inet_event(struct notifier_block *this,\n\t\t\t   unsigned long event,\n\t\t\t   void *ptr)\n{\n\tstruct in_device *idev = ((struct in_ifaddr *)ptr)->ifa_dev;\n\tstruct netdev_notifier_info info;\n\n\t\/* The masq_dev_notifier will catch the case of the device going\n\t * down.  So if the inetdev is dead and being destroyed we have\n\t * no work to do.  Otherwise this is an individual address removal\n\t * and we have to perform the flush.\n\t *\/\n\tif (idev->dead)\n\t\treturn NOTIFY_DONE;\n\n\tnetdev_notifier_info_init(&info, idev->dev);\n\treturn masq_device_event(this, event, &info);\n}","target":0,"flaw_line_index":0,"hash":"82032559-edb3-4e5e-ba77-6bb8bb86e61f","idx":"f47b17c5-bac5-45c6-b133-9e912d3a9b07"}
{"func_before":"{\n\tunsigned long flags;\n\tint i, retval;\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status) {\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\treturn;\n\t}\n\t\/* shut everything down *\/\n\tio->status = -ECONNRESET;\n\tspin_unlock_irqrestore(&io->lock, flags);\n\n\tfor (i = io->entries - 1; i >= 0; --i) {\n\t\tusb_block_urb(io->urbs[i]);\n\n\t\t    && retval != -ENODEV\n\t\t    && retval != -EBUSY\n\t\t    && retval != -EIDRM)\n\t\t\tdev_warn(&io->dev->dev, \"%s, unlink --> %d\\n\",\n\t\t\t\t __func__, retval);\n\t}\n}","target":1,"flaw_line_index":0,"hash":"a48292f8-7f23-40cc-89ad-25be3412b3aa","idx":"abfcff1a-adc1-4669-a14e-5aabdfa45389"}
{"func_before":"{\n\tunsigned long flags;\n\tint i, retval;\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status || io->count == 0) {\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\treturn;\n\t}\n\t\/* shut everything down *\/\n\tio->status = -ECONNRESET;\n\tio->count++;\t\t\/* Keep the request alive until we're done *\/\n\tspin_unlock_irqrestore(&io->lock, flags);\n\n\tfor (i = io->entries - 1; i >= 0; --i) {\n\t\tusb_block_urb(io->urbs[i]);\n\n\t\t    && retval != -EBUSY\n\t\t    && retval != -EIDRM)\n\t\t\tdev_warn(&io->dev->dev, \"%s, unlink --> %d\\n\",\n\t\t\t\t __func__, retval);\n\t}\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tio->count--;\n\tif (!io->count)\n\t\tcomplete(&io->complete);\n\tspin_unlock_irqrestore(&io->lock, flags);\n}","target":0,"flaw_line_index":0,"hash":"ae186854-204f-4da1-8bea-814f124479d6","idx":"77425ea8-8cf8-483c-9e56-f6b8c89bde4d"}
{"func_before":"    hatt.maximumReservedCaches = 5000;\n    participant_stateless_message_reader_history_ = new ReaderHistory(hatt);\n    ReaderAttributes ratt;\n    ratt.endpoint.topicKind = NO_KEY;\n    ratt.endpoint.reliabilityKind = BEST_EFFORT;\n    \/\/mp_listener = new PDPSimpleListener(this);\n\n    RTPSReader* rout = nullptr;\n    if(participant_->createReader(&rout, ratt, participant_stateless_message_reader_history_, nullptr, participant_stateless_message_reader_entity_id, true, false))\n    {\n        participant_stateless_message_reader_ = dynamic_cast<StatelessReader*>(rout);\n\n        return true;\n    }\n\n    logError(SECURITY,\"Participant Stateless Message Reader creation failed\");\n    delete(participant_stateless_message_reader_history_);\n    participant_stateless_message_reader_history_ = nullptr;\n    \/\/delete(mp_listener);\n    \/\/mp_listener = nullptr;\n    return false;\n}","target":1,"flaw_line_index":0,"hash":"d653b5df-fbd8-4e2c-9781-55808d2a5f85","idx":"f11509f3-374d-49fe-93ce-db08556be38f"}
{"func_before":"    hatt.initialReservedCaches = 250;\n    hatt.maximumReservedCaches = 5000;\n    participant_stateless_message_reader_history_ = new ReaderHistory(hatt);\n    ReaderAttributes ratt;\n    ratt.endpoint.topicKind = NO_KEY;\n    ratt.endpoint.reliabilityKind = BEST_EFFORT;\n\n    RTPSReader* rout = nullptr;\n    if(participant_->createReader(&rout, ratt, participant_stateless_message_reader_history_, &participant_stateless_message_listener_,\n                participant_stateless_message_reader_entity_id, true, false))\n    {\n        participant_stateless_message_reader_ = dynamic_cast<StatelessReader*>(rout);\n\n        return true;\n    }\n\n    logError(SECURITY,\"Participant Stateless Message Reader creation failed\");\n    delete(participant_stateless_message_reader_history_);\n    participant_stateless_message_reader_history_ = nullptr;\n    return false;\n}","target":0,"flaw_line_index":0,"hash":"11c27e47-1872-42f6-8ace-e4c955b4bccd","idx":"d1a0c1bc-f139-4ffe-820d-c39a2e4c173f"}
{"func_before":"\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tBUG_ON(path[depth].p_hdr == NULL);\n\n\t\/* try to insert block into found extent and return *\/\n\tif (ex && (flag != EXT4_GET_BLOCKS_PRE_IO)\n\t\t&& ext4_can_extents_be_merged(inode, ex, newext)) {\n\t\text_debug(\"append [%d]%d block to %d:[%d]%d (from %llu)\\n\",\n\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\tle32_to_cpu(ex->ee_block),\n\text4_ext_store_pblock(nearex, ext_pblock(newext));\n\tnearex->ee_len = newext->ee_len;\n\nmerge:\n\t\/* try to merge extents to the right *\/\n\tif (flag != EXT4_GET_BLOCKS_PRE_IO)\n\t\text4_ext_try_to_merge(inode, path, nearex);\n\n\t\/* try to merge extents to the left *\/\n\n\t\/* time to correct all indexes above *\/","target":1,"flaw_line_index":0,"hash":"d4d75b26-695e-4f7c-93a0-9915510381be","idx":"dde9df30-bca2-4e47-bbd3-78143caa29f7"}
{"func_before":"\tdepth = ext_depth(inode);\n\tex = path[depth].p_ext;\n\tBUG_ON(path[depth].p_hdr == NULL);\n\n\t\/* try to insert block into found extent and return *\/\n\tif (ex && !(flag & EXT4_GET_BLOCKS_PRE_IO)\n\t\t&& ext4_can_extents_be_merged(inode, ex, newext)) {\n\t\text_debug(\"append [%d]%d block to %d:[%d]%d (from %llu)\\n\",\n\t\t\t\text4_ext_is_uninitialized(newext),\n\t\t\t\text4_ext_get_actual_len(newext),\n\t\t\t\tle32_to_cpu(ex->ee_block),\n\text4_ext_store_pblock(nearex, ext_pblock(newext));\n\tnearex->ee_len = newext->ee_len;\n\nmerge:\n\t\/* try to merge extents to the right *\/\n\tif (!(flag & EXT4_GET_BLOCKS_PRE_IO))\n\t\text4_ext_try_to_merge(inode, path, nearex);\n\n\t\/* try to merge extents to the left *\/\n\n\t\/* time to correct all indexes above *\/","target":0,"flaw_line_index":0,"hash":"fe6e3ee0-1ed6-4b6c-bfb4-7867c60cc0f3","idx":"dfc62653-5e10-46c6-9522-f4d789c560b6"}
{"func_before":"        gen_move(s, cursp(), sp, 0);\n      }\n      if (val) {\n        gen_move(s, top, cursp(), 1);\n      }\n      if (n < 14) {\n        n++;\n      }\n      else {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), 1);\n      }","target":1,"flaw_line_index":0,"hash":"cf069322-b607-43de-9474-2ab02fc98767","idx":"f7944d14-a39d-4acf-87f1-d06f20a61101"}
{"func_before":"        gen_move(s, cursp(), sp, 0);\n      }\n      if (val) {\n        gen_move(s, top, cursp(), 1);\n      }\n      if (n < 15) {\n        n++;\n        if (n == 15) {\n          pop_n(14);\n          genop_2(s, OP_ARRAY, cursp(), 15);\n        }\n      }\n      else {\n        pop();\n        genop_2(s, OP_ARYPUSH, cursp(), 1);\n      }","target":0,"flaw_line_index":0,"hash":"80743fc2-972b-402b-97b1-4d75a6fdf9fc","idx":"d185034a-0953-4d5c-8509-7c9f97a967b7"}
{"func_before":"\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n\t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter > CIPSO_V4_TAG_MAXCNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n\t\t}\n\tif (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter] = CIPSO_V4_TAG_INVALID;\n\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"20d4b320-fdc4-46ec-840d-5dacbc4ad893","idx":"c57a1ce6-af68-4d4b-b0b3-f22ccca77bbe"}
{"func_before":"\t\t\t\tnetlbl_cipsov4_genl_policy) != 0)\n\t\treturn -EINVAL;\n\n\tnla_for_each_nested(nla, info->attrs[NLBL_CIPSOV4_A_TAGLST], nla_rem)\n\t\tif (nla->nla_type == NLBL_CIPSOV4_A_TAG) {\n\t\t\tif (iter >= CIPSO_V4_TAG_MAXCNT)\n\t\t\t\treturn -EINVAL;\n\t\t\tdoi_def->tags[iter++] = nla_get_u8(nla);\n\t\t}\n\twhile (iter < CIPSO_V4_TAG_MAXCNT)\n\t\tdoi_def->tags[iter++] = CIPSO_V4_TAG_INVALID;\n\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"d9f551c8-a9d5-4160-88fc-3c3767fb4086","idx":"c0e8d750-969b-4751-8577-073a37d61953"}
{"func_before":"  }\n\n  const int kOutputShapeTensor = 0;  \/\/ Only used for TransposeConv\n  const int kWeightTensor = 1;\n  const int kBiasTensor = 2;  \/\/ Only used for non-TransposeConv\n  const TfLiteTensor* weights = GetInput(context, node, kWeightTensor);\n  const int max_kernel_size = 16384;\n  if (!IsConstantTensor(weights)) {\n    return false;\n  }\n  if (weights->dims->data[1] > max_kernel_size ||","target":1,"flaw_line_index":0,"hash":"4b274736-5eac-4bc4-acb6-177439d4110b","idx":"47cab4fb-a3dd-45af-a934-47823955d135"}
{"func_before":"  }\n\n  const int kOutputShapeTensor = 0;  \/\/ Only used for TransposeConv\n  const int kWeightTensor = 1;\n  const int kBiasTensor = 2;  \/\/ Only used for non-TransposeConv\n  const TfLiteTensor* weights;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kWeightTensor, &weights));\n  const int max_kernel_size = 16384;\n  if (!IsConstantTensor(weights)) {\n    return false;\n  }\n  if (weights->dims->data[1] > max_kernel_size ||","target":0,"flaw_line_index":0,"hash":"f76ffd76-bc1c-4b31-ba7b-904f56dfc064","idx":"f4ef8d10-3fcc-435e-af21-fe0158c7217c"}
{"func_before":"\t\ttestFeatTable<FeatTableTestE>(testDataE, \"E\\n\");\n\n\t\t\/\/ test a bad settings offset stradling the end of the table\n\t\tFeatureMap testFeatureMap;\n\t\tdummyFace.replace_table(TtfUtil::Tag::Feat, &testBadOffset, sizeof testBadOffset);\n\t\tface = gr_make_face_with_ops(&dummyFace, &face_handle::ops, gr_face_dumbRendering);\n\t\tbool readStatus = testFeatureMap.readFeats(*face);\n\t\ttestAssert(\"fail gracefully on bad table\", !readStatus);\n\t}\n\tcatch (std::exception & e)\n\t{\n\t\tfprintf(stderr, \"%s: %s\\n\", argv[0], e.what());\n\t\tgr_face_destroy(face);","target":1,"flaw_line_index":0,"hash":"07933086-52c8-433b-a4b4-568e09930098","idx":"dd3b4a93-a3cc-454d-8630-2bf6dfe84d19"}
{"func_before":"\t\ttestFeatTable<FeatTableTestE>(testDataE, \"E\\n\");\n\n\t\t\/\/ test a bad settings offset stradling the end of the table\n\t\tFeatureMap testFeatureMap;\n\t\tdummyFace.replace_table(TtfUtil::Tag::Feat, &testBadOffset, sizeof testBadOffset);\n\t\tface = gr_make_face_with_ops(&dummyFace, &face_handle::ops, 0);\n\t\ttestAssert(\"fail gracefully on bad table\", !face);\n\t}\n\tcatch (std::exception & e)\n\t{\n\t\tfprintf(stderr, \"%s: %s\\n\", argv[0], e.what());\n\t\tgr_face_destroy(face);","target":0,"flaw_line_index":0,"hash":"8f74e0cd-2515-496f-bb5c-f11a8ae77dc9","idx":"0d8e2c77-6cd4-4a93-a350-59971a150b96"}
{"func_before":"void Context::onDone() {\n  if (wasm_->onDone_) {\n    wasm_->onDone_(this, id_);\n  }\n}","target":1,"flaw_line_index":0,"hash":"9775fd53-3350-42e7-9947-092068585922","idx":"07a4487b-2753-4e7c-b984-d042ea5e6796"}
{"func_before":"void Context::onDone() {\n  if (in_vm_context_created_ && wasm_->onDone_) {\n    wasm_->onDone_(this, id_);\n  }\n}","target":0,"flaw_line_index":0,"hash":"8f5a5044-0ec7-43b7-b956-75efd731b69c","idx":"21f7bdc8-6018-4dff-9a9d-ca4cdb4bc5a0"}
{"func_before":"static int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char buffer[3];\n\tint ret;\n\n\t\/* Get a couple of the ATMega Firmware values *\/\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\t\tdev_info(&usb_dev->dev,\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\n\treturn ret;\n}","target":1,"flaw_line_index":0,"hash":"79532671-7e31-4df7-8f93-24c1b33df1be","idx":"57438ba2-907d-411b-9bf6-652e5ef48f83"}
{"func_before":"static int atusb_get_and_show_revision(struct atusb *atusb)\n{\n\tstruct usb_device *usb_dev = atusb->usb_dev;\n\tunsigned char *buffer;\n\tint ret;\n\n\tbuffer = kmalloc(3, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\t\/* Get a couple of the ATMega Firmware values *\/\n\tret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t\tATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,\n\t\t\t\tbuffer, 3, 1000);\n\t\t\t \"Firmware version (%u.%u) predates our first public release.\",\n\t\t\t atusb->fw_ver_maj, atusb->fw_ver_min);\n\t\tdev_info(&usb_dev->dev, \"Please update to version 0.2 or newer\");\n\t}\n\n\tkfree(buffer);\n\treturn ret;\n}","target":0,"flaw_line_index":0,"hash":"6eb07927-d3f4-4d2a-ab50-d39d58ba10cd","idx":"cbb1648a-ea06-4a1e-95fc-c702f7e7cf3a"}
{"func_before":"ast_for_suite(struct compiling *c, const node *n)\n{\n    \/* suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT *\/\n    asdl_seq *seq;\n    stmt_ty s;\n    int i, total, num, end, pos = 0;\n    node *ch;\n\n    REQ(n, suite);\n\n    total = num_stmts(n);\n    seq = _Py_asdl_seq_new(total, c->c_arena);\n    if (!seq)\n        return NULL;\n                return NULL;\n            asdl_seq_SET(seq, pos++, s);\n        }\n    }\n    else {\n        for (i = 2; i < (NCH(n) - 1); i++) {\n            ch = CHILD(n, i);\n            REQ(ch, stmt);\n            num = num_stmts(ch);\n            if (num == 1) {\n                \/* small_stmt or compound_stmt with only one child *\/","target":1,"flaw_line_index":0,"hash":"a11ca289-574b-4cce-b9ff-6f33e587130d","idx":"836c05aa-677c-43bf-b871-dee714bee1e1"}
{"func_before":"ast_for_suite(struct compiling *c, const node *n)\n{\n    \/* suite: simple_stmt | NEWLINE [TYPE_COMMENT NEWLINE] INDENT stmt+ DEDENT *\/\n    asdl_seq *seq;\n    stmt_ty s;\n    int i, total, num, end, pos = 0;\n    node *ch;\n\n    if (TYPE(n) != func_body_suite) {\n        REQ(n, suite);\n    }\n\n    total = num_stmts(n);\n    seq = _Py_asdl_seq_new(total, c->c_arena);\n    if (!seq)\n        return NULL;\n                return NULL;\n            asdl_seq_SET(seq, pos++, s);\n        }\n    }\n    else {\n        i = 2;\n        if (TYPE(CHILD(n, 1)) == TYPE_COMMENT) {\n            i += 2;\n            REQ(CHILD(n, 2), NEWLINE);\n        }\n\n        for (; i < (NCH(n) - 1); i++) {\n            ch = CHILD(n, i);\n            REQ(ch, stmt);\n            num = num_stmts(ch);\n            if (num == 1) {\n                \/* small_stmt or compound_stmt with only one child *\/","target":0,"flaw_line_index":0,"hash":"82571fc4-e511-426b-8a2e-9df7e6edcac5","idx":"87db11f5-8db2-4530-bcb6-48acb98ac3fc"}
{"func_before":"static void ep4_mul_fix_ordin(ep4_t r, const ep4_t *table, const bn_t k) {\n\tint len, i, n;\n\tint8_t naf[2 * RLC_FP_BITS + 1], *t;\n\n\tif (bn_is_zero(k)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\tlen = 2 * RLC_FP_BITS + 1;\n\tbn_rec_naf(naf, &len, k, EP_DEPTH);\n\n\tt = naf + len - 1;\n\tep4_set_infty(r);\n\tfor (i = len - 1; i >= 0; i--, t--) {\n\t\tep4_dbl(r, r);\n\n\t\tn = *t;\n\t\tif (n > 0) {\n\t\t\tep4_add(r, r, table[n \/ 2]);","target":1,"flaw_line_index":0,"hash":"e2383e39-c234-42be-9ff5-8fc3e2bc6fce","idx":"9e6115d4-318a-4910-b065-dc699932ff17"}
{"func_before":"static void ep4_mul_fix_ordin(ep4_t r, const ep4_t *table, const bn_t k) {\n\tint8_t naf[2 * RLC_FP_BITS + 1], *t;\n\tsize_t len;\n\tint n;\n\n\tif (bn_is_zero(k)) {\n\t\tep4_set_infty(r);\n\t\treturn;\n\t}\n\tlen = 2 * RLC_FP_BITS + 1;\n\tbn_rec_naf(naf, &len, k, EP_DEPTH);\n\n\tt = naf + len - 1;\n\tep4_set_infty(r);\n\tfor (int i = len - 1; i >= 0; i--, t--) {\n\t\tep4_dbl(r, r);\n\n\t\tn = *t;\n\t\tif (n > 0) {\n\t\t\tep4_add(r, r, table[n \/ 2]);","target":0,"flaw_line_index":0,"hash":"9a620491-382b-4a50-8878-5aa892687d45","idx":"3becf1e0-be64-4e33-a0cd-10d16f60396b"}
{"func_before":"    SQLWCHAR *chr;\n    int len = 0;\n\n    if ( !in )\n    {\n        return in;\n    }\n    \n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;","target":1,"flaw_line_index":0,"hash":"c8262756-1921-456c-b291-94885619f3e5","idx":"126bd28c-e80b-401d-b0e1-a7578f673595"}
{"func_before":"    SQLWCHAR *chr;\n    int len = 0;\n\n    if ( !in )\n    {\n        return NULL;\n    }\n    \n    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )\n    {\n        len ++;","target":0,"flaw_line_index":0,"hash":"1d16dcda-6954-44c1-92aa-5826f1d652f0","idx":"8f0dce97-4b17-49c0-a714-5eeb3cc77ca2"}
{"func_before":"check_stl_option(char_u *s)\n{\n    int\t\tgroupdepth = 0;\n    static char errbuf[80];\n\n    while (*s)\n    {\n\t\/\/ Check for valid keys after % sequences\n\twhile (*s && *s != '%')\n\t    groupdepth++;\n\t    continue;\n\t}\n\tif (vim_strchr(STL_ALL, *s) == NULL)\n\t{\n\t    return illegal_char(errbuf, *s);\n\t}\n\tif (*s == '{')\n\t{\n\t    int reevaluate = (*++s == '%');\n\n\t    if (reevaluate && *++s == '}')\n\t\t\/\/ \"}\" is not allowed immediately after \"%{%\"\n\t\treturn illegal_char(errbuf, '}');\n\t    while ((*s != '}' || (reevaluate && s[-1] != '%')) && *s)\n\t\ts++;\n\t    if (*s != '}')\n\t\treturn e_unclosed_expression_sequence;\n\t}","target":1,"flaw_line_index":0,"hash":"c6ed49f6-c954-4a39-8479-7276a78e663a","idx":"3deefc3a-bab5-4769-98dc-89dbf00f88d4"}
{"func_before":"check_stl_option(char_u *s)\n{\n    int\t\tgroupdepth = 0;\n    static char errbuf[ERR_BUFLEN];\n    int\t\terrbuflen = ERR_BUFLEN;\n\n    while (*s)\n    {\n\t\/\/ Check for valid keys after % sequences\n\twhile (*s && *s != '%')\n\t    groupdepth++;\n\t    continue;\n\t}\n\tif (vim_strchr(STL_ALL, *s) == NULL)\n\t{\n\t    return illegal_char(errbuf, errbuflen, *s);\n\t}\n\tif (*s == '{')\n\t{\n\t    int reevaluate = (*++s == '%');\n\n\t    if (reevaluate && *++s == '}')\n\t\t\/\/ \"}\" is not allowed immediately after \"%{%\"\n\t\treturn illegal_char(errbuf, errbuflen, '}');\n\t    while ((*s != '}' || (reevaluate && s[-1] != '%')) && *s)\n\t\ts++;\n\t    if (*s != '}')\n\t\treturn e_unclosed_expression_sequence;\n\t}","target":0,"flaw_line_index":0,"hash":"861443cb-2ddb-4e3b-be57-6b8ec491f3f8","idx":"7c06ce80-5067-444a-ad92-71c86c38c8f6"}
{"func_before":"\t\t{\n\t\t    \/\/ Give a penalty when changing non-word char to word\n\t\t    \/\/ char, e.g., \"thes,\" -> \"these\".\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword, p);\n\t\t    if (!spell_iswordp(p, curwin))\n\t\t    {\n\t\t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p, curwin))\n\t\t\t    newscore += SCORE_NONWORD;","target":1,"flaw_line_index":0,"hash":"a05fa1a7-2442-432e-a35f-d3cc96eb4095","idx":"35ac7bb9-c2bb-4ed5-870e-38f3a3318dba"}
{"func_before":"\t\t{\n\t\t    \/\/ Give a penalty when changing non-word char to word\n\t\t    \/\/ char, e.g., \"thes,\" -> \"these\".\n\t\t    p = fword + sp->ts_fidx;\n\t\t    MB_PTR_BACK(fword, p);\n\t\t    if (!spell_iswordp(p, curwin) && *preword != NUL)\n\t\t    {\n\t\t\tp = preword + STRLEN(preword);\n\t\t\tMB_PTR_BACK(preword, p);\n\t\t\tif (spell_iswordp(p, curwin))\n\t\t\t    newscore += SCORE_NONWORD;","target":0,"flaw_line_index":0,"hash":"70fd3c3f-f837-424e-99c3-443ffc509311","idx":"530c0403-c431-4714-9e9d-3b8a17c9823e"}
{"func_before":"\tcert = SSL_get_peer_certificate(chan->ssl);\n\tif (cert == NULL) {\n\t\tg_warning(\"SSL server supplied no certificate\");\n\t\treturn -1;\n\t}\n\tret = !chan->verify || irssi_ssl_verify(chan->ssl, chan->ctx, cert);\n\tX509_free(cert);\n\treturn ret ? 0 : -1;\n}","target":1,"flaw_line_index":0,"hash":"869e38f5-0dd4-42f4-b728-0368a2b7abfd","idx":"09336a91-13dd-4e0c-8c35-af7296b09d36"}
{"func_before":"\tcert = SSL_get_peer_certificate(chan->ssl);\n\tif (cert == NULL) {\n\t\tg_warning(\"SSL server supplied no certificate\");\n\t\treturn -1;\n\t}\n\tret = !chan->verify || irssi_ssl_verify(chan->ssl, chan->ctx, chan->hostname, cert);\n\tX509_free(cert);\n\treturn ret ? 0 : -1;\n}","target":0,"flaw_line_index":0,"hash":"98f33b3e-9b35-4d3a-8f63-2946d7e862c6","idx":"57318514-7be3-4f0a-af62-59dd4e5d9ec5"}
{"func_before":"\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n  \tfor ( ; num; num--) {\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) == -1) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\toff += size;","target":1,"flaw_line_index":0,"hash":"e390b4ac-ad8c-4e4b-b9f2-90f57bc837c1","idx":"e758f244-ce4a-4ee2-acae-70648286bf23"}
{"func_before":"\t\t\treturn -1;\n\t\treturn 0;\n\t}\n\n  \tfor ( ; num; num--) {\n\t\tif (pread(fd, xph_addr, xph_sizeof, off) < (ssize_t)xph_sizeof) {\n\t\t\tfile_badread(ms);\n\t\t\treturn -1;\n\t\t}\n\n\t\toff += size;","target":0,"flaw_line_index":0,"hash":"702e92f9-483d-4e1d-84b8-e7f6f10bbae5","idx":"b0b08702-4c75-41f5-b9e2-0153a0f9b949"}
{"func_before":"int ncrush_decompress(NCRUSH_CONTEXT* ncrush, const BYTE* pSrcData, UINT32 SrcSize,\n                      const BYTE** ppDstData, UINT32* pDstSize, UINT32 flags)\n{\n\tUINT32 index;\n\tUINT32 bits;\n\tINT32 nbits;\n\tconst BYTE* SrcPtr;\n\tconst BYTE* SrcEnd;\n\tUINT16 Mask;\n\tBYTE Literal;\n\tUINT32 IndexLEC;\n\tUINT32 BitLength;\n\tUINT32 MaskedBits;\n\tUINT32 CopyOffset;\n\tUINT32 CopyLength;\n\tUINT32 OldCopyOffset;\n\tBYTE* CopyOffsetPtr;\n\tUINT32 LengthOfMatch;\n\tUINT32 CopyOffsetIndex;\n\tUINT32 OffsetCacheIndex;\n\tBYTE* HistoryPtr;\n\tBYTE* HistoryBuffer;\n\tBYTE* HistoryBufferEnd;\n\tUINT32 CopyOffsetBits;\n\tUINT32 CopyOffsetBase;\n\tUINT32 LengthOfMatchBits;\n\tUINT32 LengthOfMatchBase;\n\n\tWINPR_ASSERT(pDstSize);\n\n\tif (ncrush->HistoryEndOffset != 65535)\n\t\treturn -1001;\n\n\tHistoryBuffer = ncrush->HistoryBuffer;\n\tHistoryBufferEnd = &HistoryBuffer[ncrush->HistoryEndOffset];\n\n\tif (flags & PACKET_AT_FRONT)\n\t{\n\t\tif ((ncrush->HistoryPtr - 32768) <= HistoryBuffer)\n\t\t\treturn -1002;\n\t\tncrush->HistoryPtr = HistoryBuffer;\n\t\tZeroMemory(HistoryBuffer, sizeof(ncrush->HistoryBuffer));\n\t\tZeroMemory(&(ncrush->OffsetCache), sizeof(ncrush->OffsetCache));\n\t}\n\n\tHistoryPtr = ncrush->HistoryPtr;\n\n\tif (!(flags & PACKET_COMPRESSED))\n\t{\n\t\t*ppDstData = pSrcData;\n\t\t*pDstSize = SrcSize;\n\t\treturn 1;\n\t}\n\n\tSrcEnd = &pSrcData[SrcSize];\n\tnbits = 32;\n\tbits = get_dword(pSrcData);\n\tSrcPtr = pSrcData + 4;\n\n\twhile (1)\n\t{\n\t\twhile (1)\n\t\t{\n\t\t\tMask = get_word(&HuffTableMask[29]);\n\t\t\tMaskedBits = bits & Mask;\n\t\t\tIndexLEC = HuffTableLEC[MaskedBits] & 0xFFF;\n\t\t\tBitLength = HuffTableLEC[MaskedBits] >> 12;\n\t\t\tbits >>= BitLength;\n\t\t\tnbits -= BitLength;\n\n\n\t\t\tif (OffsetCacheIndex >= 4)\n\t\t\t\treturn -1004;\n\n\t\t\tCopyOffset = ncrush->OffsetCache[OffsetCacheIndex];\n\t\t\tMask = get_word(&HuffTableMask[21]);\n\t\t\tMaskedBits = bits & Mask;\n\t\t\tLengthOfMatch = HuffTableLOM[MaskedBits] & 0xFFF;\n\t\t\tBitLength = HuffTableLOM[MaskedBits] >> 12;\n\t\t\tbits >>= BitLength;\n\t\t\tnbits -= BitLength;\n\n\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))\n\t\t\t\treturn -1;\n\n\t\t\tLengthOfMatchBits = LOMBitsLUT[LengthOfMatch];\n\t\t\tLengthOfMatchBase = LOMBaseLUT[LengthOfMatch];\n\n\t\t\tif (LengthOfMatchBits)\n\t\t\t{\n\t\t\t\tMask = get_word(&HuffTableMask[(2 * LengthOfMatchBits) + 3]);\n\t\t\t\tMaskedBits = bits & Mask;\n\t\t\t\tbits >>= LengthOfMatchBits;\n\t\t\t\tnbits -= LengthOfMatchBits;\n\t\t\t\tLengthOfMatchBase += MaskedBits;\n\n\t\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))\n\t\t\tOldCopyOffset = ncrush->OffsetCache[OffsetCacheIndex];\n\t\t\tncrush->OffsetCache[OffsetCacheIndex] = ncrush->OffsetCache[0];\n\t\t\tncrush->OffsetCache[0] = OldCopyOffset;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tCopyOffsetBits = CopyOffsetBitsLUT[CopyOffsetIndex];\n\t\t\tCopyOffsetBase = CopyOffsetBaseLUT[CopyOffsetIndex];\n\t\t\tCopyOffset = CopyOffsetBase - 1;\n\n\t\t\tif (CopyOffsetBits)\n\t\t\t{\n\t\t\t\tMask = get_word(&HuffTableMask[(2 * CopyOffsetBits) + 3]);\n\t\t\t\tMaskedBits = bits & Mask;\n\t\t\t\tCopyOffset = CopyOffsetBase + MaskedBits - 1;\n\t\t\t\tbits >>= CopyOffsetBits;\n\t\t\t\tnbits -= CopyOffsetBits;\n\n\t\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tMask = get_word(&HuffTableMask[21]);\n\t\t\tMaskedBits = bits & Mask;\n\t\t\tLengthOfMatch = HuffTableLOM[MaskedBits] & 0xFFF;\n\t\t\tBitLength = HuffTableLOM[MaskedBits] >> 12;\n\t\t\tbits >>= BitLength;\n\t\t\tnbits -= BitLength;\n\n\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))\n\t\t\t\treturn -1;\n\n\t\t\tLengthOfMatchBits = LOMBitsLUT[LengthOfMatch];\n\t\t\tLengthOfMatchBase = LOMBaseLUT[LengthOfMatch];\n\n\t\t\tif (LengthOfMatchBits)\n\t\t\t{\n\t\t\t\tMask = get_word(&HuffTableMask[(2 * LengthOfMatchBits) + 3]);\n\t\t\t\tMaskedBits = bits & Mask;\n\t\t\t\tbits >>= LengthOfMatchBits;\n\t\t\t\tnbits -= LengthOfMatchBits;\n\t\t\t\tLengthOfMatchBase += MaskedBits;\n\n\t\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))","target":1,"flaw_line_index":0,"hash":"c60dd0e0-ca89-4ad0-bc59-3ff1f8389b5f","idx":"e6ef5a1b-5ed1-4805-8541-3a598e65f07d"}
{"func_before":"int ncrush_decompress(NCRUSH_CONTEXT* ncrush, const BYTE* pSrcData, UINT32 SrcSize,\n                      const BYTE** ppDstData, UINT32* pDstSize, UINT32 flags)\n{\n\tUINT32 index;\n\tBYTE Literal;\n\tUINT32 IndexLEC;\n\tUINT32 BitLength;\n\tUINT32 CopyOffset;\n\tUINT32 CopyLength;\n\tUINT32 OldCopyOffset;\n\tBYTE* CopyOffsetPtr;\n\tUINT32 LengthOfMatch;\n\tUINT32 CopyOffsetIndex;\n\tUINT32 OffsetCacheIndex;\n\tUINT32 CopyOffsetBits;\n\tUINT32 CopyOffsetBase;\n\tUINT32 LengthOfMatchBits;\n\tUINT32 LengthOfMatchBase;\n\n\tWINPR_ASSERT(pDstSize);\n\n\tif (ncrush->HistoryEndOffset != 65535)\n\t\treturn -1001;\n\n\tBYTE* HistoryBuffer = ncrush->HistoryBuffer;\n\tconst BYTE* HistoryBufferEnd = &HistoryBuffer[ncrush->HistoryEndOffset];\n\n\tif (flags & PACKET_AT_FRONT)\n\t{\n\t\tif ((ncrush->HistoryPtr - 32768) <= HistoryBuffer)\n\t\t\treturn -1002;\n\t\tncrush->HistoryPtr = HistoryBuffer;\n\t\tZeroMemory(HistoryBuffer, sizeof(ncrush->HistoryBuffer));\n\t\tZeroMemory(&(ncrush->OffsetCache), sizeof(ncrush->OffsetCache));\n\t}\n\n\tBYTE* HistoryPtr = ncrush->HistoryPtr;\n\n\tif (!(flags & PACKET_COMPRESSED))\n\t{\n\t\t*ppDstData = pSrcData;\n\t\t*pDstSize = SrcSize;\n\t\treturn 1;\n\t}\n\n\tconst BYTE* SrcEnd = &pSrcData[SrcSize];\n\tconst BYTE* SrcPtr = pSrcData + 4;\n\n\tINT32 nbits = 32;\n\tUINT32 bits = get_dword(pSrcData);\n\twhile (1)\n\t{\n\t\twhile (1)\n\t\t{\n\t\t\tconst UINT16 Mask = get_word(&HuffTableMask[29]);\n\t\t\tconst UINT32 MaskedBits = bits & Mask;\n\t\t\tif (MaskedBits >= ARRAYSIZE(HuffTableLEC))\n\t\t\t\treturn -1;\n\t\t\tIndexLEC = HuffTableLEC[MaskedBits] & 0xFFF;\n\t\t\tBitLength = HuffTableLEC[MaskedBits] >> 12;\n\t\t\tbits >>= BitLength;\n\t\t\tnbits -= BitLength;\n\n\n\t\t\tif (OffsetCacheIndex >= 4)\n\t\t\t\treturn -1004;\n\n\t\t\tCopyOffset = ncrush->OffsetCache[OffsetCacheIndex];\n\t\t\tconst UINT16 Mask = get_word(&HuffTableMask[21]);\n\t\t\tconst UINT32 MaskedBits = bits & Mask;\n\t\t\tif (MaskedBits > ARRAYSIZE(HuffTableLOM))\n\t\t\t\treturn -1;\n\t\t\tLengthOfMatch = HuffTableLOM[MaskedBits] & 0xFFF;\n\t\t\tBitLength = HuffTableLOM[MaskedBits] >> 12;\n\t\t\tbits >>= BitLength;\n\t\t\tnbits -= BitLength;\n\n\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))\n\t\t\t\treturn -1;\n\n\t\t\tif (LengthOfMatch >= ARRAYSIZE(LOMBitsLUT))\n\t\t\t\treturn -1;\n\n\t\t\tLengthOfMatchBits = LOMBitsLUT[LengthOfMatch];\n\n\t\t\tif (LengthOfMatch >= ARRAYSIZE(LOMBaseLUT))\n\t\t\t\treturn -1;\n\t\t\tLengthOfMatchBase = LOMBaseLUT[LengthOfMatch];\n\n\t\t\tif (LengthOfMatchBits)\n\t\t\t{\n\t\t\t\tconst size_t idx = (2ull * LengthOfMatchBits) + 3ull;\n\t\t\t\tif (idx >= ARRAYSIZE(HuffTableMask))\n\t\t\t\t\treturn -1;\n\n\t\t\t\tconst UINT16 Mask = get_word(&HuffTableMask[idx]);\n\t\t\t\tconst UINT32 MaskedBits = bits & Mask;\n\t\t\t\tbits >>= LengthOfMatchBits;\n\t\t\t\tnbits -= LengthOfMatchBits;\n\t\t\t\tLengthOfMatchBase += MaskedBits;\n\n\t\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))\n\t\t\tncrush->OffsetCache[OffsetCacheIndex] = ncrush->OffsetCache[0];\n\t\t\tncrush->OffsetCache[0] = OldCopyOffset;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (CopyOffsetIndex >= ARRAYSIZE(CopyOffsetBitsLUT))\n\t\t\t\treturn -1;\n\n\t\t\tCopyOffsetBits = CopyOffsetBitsLUT[CopyOffsetIndex];\n\n\t\t\tif (CopyOffsetIndex >= ARRAYSIZE(CopyOffsetBaseLUT))\n\t\t\t\treturn -1;\n\t\t\tCopyOffsetBase = CopyOffsetBaseLUT[CopyOffsetIndex];\n\t\t\tCopyOffset = CopyOffsetBase - 1;\n\n\t\t\tif (CopyOffsetBits)\n\t\t\t{\n\t\t\t\tconst size_t idx = (2ull * CopyOffsetBits) + 3ull;\n\t\t\t\tif (idx >= ARRAYSIZE(HuffTableMask))\n\t\t\t\t\treturn -1;\n\n\t\t\t\tconst UINT16 Mask = get_word(&HuffTableMask[idx]);\n\t\t\t\tconst UINT32 MaskedBits = bits & Mask;\n\t\t\t\tconst UINT32 tmp = CopyOffsetBase + MaskedBits;\n\t\t\t\tif (tmp < 1)\n\t\t\t\t\treturn -1;\n\t\t\t\tCopyOffset = tmp - 1;\n\t\t\t\tbits >>= CopyOffsetBits;\n\t\t\t\tnbits -= CopyOffsetBits;\n\n\t\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tconst UINT16 Mask = get_word(&HuffTableMask[21]);\n\t\t\tconst UINT32 MaskedBits = bits & Mask;\n\t\t\tif (MaskedBits >= ARRAYSIZE(HuffTableLOM))\n\t\t\t\treturn -1;\n\n\t\t\tLengthOfMatch = HuffTableLOM[MaskedBits] & 0xFFF;\n\t\t\tBitLength = HuffTableLOM[MaskedBits] >> 12;\n\t\t\tbits >>= BitLength;\n\t\t\tnbits -= BitLength;\n\n\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))\n\t\t\t\treturn -1;\n\n\t\t\tif (LengthOfMatch >= ARRAYSIZE(LOMBitsLUT))\n\t\t\t\treturn -1;\n\n\t\t\tLengthOfMatchBits = LOMBitsLUT[LengthOfMatch];\n\n\t\t\tif (LengthOfMatch >= ARRAYSIZE(LOMBaseLUT))\n\t\t\t\treturn -1;\n\t\t\tLengthOfMatchBase = LOMBaseLUT[LengthOfMatch];\n\n\t\t\tif (LengthOfMatchBits)\n\t\t\t{\n\t\t\t\tconst size_t idx = (2ull * LengthOfMatchBits) + 3ull;\n\t\t\t\tif (idx >= ARRAYSIZE(HuffTableMask))\n\t\t\t\t\treturn -1;\n\n\t\t\t\tconst UINT16 Mask = get_word(&HuffTableMask[idx]);\n\t\t\t\tconst UINT32 MaskedBits = bits & Mask;\n\t\t\t\tbits >>= LengthOfMatchBits;\n\t\t\t\tnbits -= LengthOfMatchBits;\n\t\t\t\tLengthOfMatchBase += MaskedBits;\n\n\t\t\t\tif (!NCrushFetchBits(&SrcPtr, &SrcEnd, &nbits, &bits))","target":0,"flaw_line_index":0,"hash":"de8c5354-d01a-4d0e-8b31-068e99849e27","idx":"62ca1a79-209e-4b69-a53f-eece8c51ade8"}
{"func_before":"static inline void sem_lock_and_putref(struct sem_array *sma)\n{\n\tipc_lock_by_ptr(&sma->sem_perm);\n\tipc_rcu_putref(sma);\n}","target":1,"flaw_line_index":0,"hash":"178d2046-f1f5-4107-9376-001ac05e2533","idx":"5d383c2f-2105-431c-94a9-3bb8b812a2a1"}
{"func_before":"static inline void sem_lock_and_putref(struct sem_array *sma)\n{\n\trcu_read_lock();\n\tsem_lock(sma, NULL, -1);\n\tipc_rcu_putref(sma);\n}","target":0,"flaw_line_index":0,"hash":"2cd9e5f8-e8a2-4640-bc49-76cabef1872e","idx":"26e8d56a-5f0c-4e5f-967a-d0388d22b2f6"}
{"func_before":"  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_ip_san_peer_certificate_.empty());\n    return cached_ip_san_peer_certificate_;\n  }\n  cached_ip_san_peer_certificate_ = Utility::getSubjectAltNames(*cert, GEN_IPADD);\n  return cached_ip_san_peer_certificate_;\n}","target":1,"flaw_line_index":0,"hash":"750e627d-b8c0-474c-890c-6c4fbdafbb4d","idx":"1e8785a8-9a4f-42f5-8793-507b399f5ae8"}
{"func_before":"  bssl::UniquePtr<X509> cert(SSL_get_peer_certificate(ssl()));\n  if (!cert) {\n    ASSERT(cached_ip_san_peer_certificate_.empty());\n    return cached_ip_san_peer_certificate_;\n  }\n  cached_ip_san_peer_certificate_ = Utility::getSubjectAltNames(*cert, GEN_IPADD, true);\n  return cached_ip_san_peer_certificate_;\n}","target":0,"flaw_line_index":0,"hash":"ea188a6a-0074-4b58-8b15-3ac48a7876f5","idx":"46358897-2f21-4e4c-956c-5f53a3e5bdb1"}
{"func_before":"Jsi_RC jsi_ArgTypeCheck(Jsi_Interp *interp, int typ,  Jsi_Value *arg, const char *p1,\n    const char *p2, int index, Jsi_Func *func, bool isdefault) {\n    Jsi_RC rc = JSI_OK;\n    char idxBuf[200];\n    idxBuf[0] = 0;\n    if (func && arg->vt == JSI_VT_UNDEF && !interp->typeCheck.noundef && index>0 && !isdefault && !(typ&JSI_TT_UNDEFINED)) {\n        snprintf(idxBuf, sizeof(idxBuf), \" arg %d\", index);\n        jsi_TypeMismatch(interp);\n       ","target":1,"flaw_line_index":0,"hash":"e4408988-c233-48e6-bc1c-6b2ccacb1d85","idx":"e6f0ff0c-25e6-4cd4-b256-3867ced6067d"}
{"func_before":"Jsi_RC jsi_ArgTypeCheck(Jsi_Interp *interp, int typ,  Jsi_Value *arg, const char *p1,\n    const char *p2, int index, Jsi_Func *func, bool isdefault) {\n    Jsi_RC rc = JSI_OK;\n    char idxBuf[JSI_MAX_NUMBER_STRING*2];\n    idxBuf[0] = 0;\n    if (func && arg->vt == JSI_VT_UNDEF && !interp->typeCheck.noundef && index>0 && !isdefault && !(typ&JSI_TT_UNDEFINED)) {\n        snprintf(idxBuf, sizeof(idxBuf), \" arg %d\", index);\n        jsi_TypeMismatch(interp);\n       ","target":0,"flaw_line_index":0,"hash":"9e138422-d455-4ffe-812b-80fbb9115984","idx":"c5404ac8-bd6d-4a8e-9a71-c0464132f8ac"}
{"func_before":"    const Tensor* seq_len_max_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"seq_len_max\", &seq_len_max_tensor));\n\n    const Tensor* x;\n    OP_REQUIRES_OK(ctx, ctx->input(\"x\", &x));\n    OP_REQUIRES(ctx, x->dims() == 3, errors::InvalidArgument(\"x must be 3D\"));\n    const int64_t timelen = x->dim_size(0);\n    const int64_t batch_size = x->dim_size(1);\n    const int64_t input_size = x->dim_size(2);\n\n    const Tensor* cs_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"cs_prev\", &cs_prev_tensor));\n\n    const Tensor* h_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"h_prev\", &h_prev_tensor));\n\n    const Tensor* w_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"w\", &w_tensor));\n    const int64_t cell_size = w_tensor->dim_size(1) \/ 4;\n    OP_REQUIRES(ctx, input_size + cell_size == w_tensor->dim_size(0),\n                errors::InvalidArgument(\n                    \"w matrix rows don't match: \", input_size + cell_size,\n                    \" vs. \", w_tensor->dim_size(0)));\n\n    const Tensor* wci_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wci\", &wci_tensor));\n\n    const Tensor* wcf_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wcf\", &wcf_tensor));\n\n    const Tensor* wco_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wco\", &wco_tensor));\n\n    const Tensor* b_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"b\", &b_tensor));\n    OP_REQUIRES(\n        ctx, cell_size == b_tensor->dim_size(0) \/ 4,\n        errors::InvalidArgument(\"w and b cell_size don't match: \", cell_size,\n                                \" vs. \", b_tensor->dim_size(0)));\n","target":1,"flaw_line_index":0,"hash":"4660a08b-5b72-494f-8fd5-0e906f842b84","idx":"814bf247-b50d-425e-aac5-eca5c33984b6"}
{"func_before":"    const Tensor* seq_len_max_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"seq_len_max\", &seq_len_max_tensor));\n\n    const Tensor* x;\n    OP_REQUIRES_OK(ctx, ctx->input(\"x\", &x));\n    OP_REQUIRES(\n        ctx, x->dims() == 3,\n        errors::InvalidArgument(\"x must be rank 3 but is rank \", x->dims()));\n    const int64_t timelen = x->dim_size(0);\n    const int64_t batch_size = x->dim_size(1);\n    const int64_t input_size = x->dim_size(2);\n\n    const Tensor* cs_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"cs_prev\", &cs_prev_tensor));\n    OP_REQUIRES(ctx, cs_prev_tensor->dims() == 2,\n                errors::InvalidArgument(\"cs_prev must be rank 2 but is rank \",\n                                        cs_prev_tensor->dims()));\n\n    const Tensor* h_prev_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"h_prev\", &h_prev_tensor));\n    OP_REQUIRES(ctx, h_prev_tensor->dims() == 2,\n                errors::InvalidArgument(\"h_prev must be rank 2 but is rank \",\n                                        h_prev_tensor->dims()));\n\n    const Tensor* w_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"w\", &w_tensor));\n    OP_REQUIRES(ctx, w_tensor->dims() == 2,\n                errors::InvalidArgument(\"w must be rank 2 but is rank \",\n                                        w_tensor->dims()));\n    const int64_t cell_size = w_tensor->dim_size(1) \/ 4;\n    OP_REQUIRES(ctx, input_size + cell_size == w_tensor->dim_size(0),\n                errors::InvalidArgument(\n                    \"w matrix rows don't match: \", input_size + cell_size,\n                    \" vs. \", w_tensor->dim_size(0)));\n\n    const Tensor* wci_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wci\", &wci_tensor));\n    OP_REQUIRES(ctx, wci_tensor->dims() == 1,\n                errors::InvalidArgument(\"wci must be rank 1 but is rank \",\n                                        wci_tensor->dims()));\n\n    const Tensor* wcf_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wcf\", &wcf_tensor));\n    OP_REQUIRES(ctx, wcf_tensor->dims() == 1,\n                errors::InvalidArgument(\"wcf must be rank 1 but is rank \",\n                                        wcf_tensor->dims()));\n\n    const Tensor* wco_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"wco\", &wco_tensor));\n    OP_REQUIRES(ctx, wco_tensor->dims() == 1,\n                errors::InvalidArgument(\"wco must be rank 1 but is rank \",\n                                        wco_tensor->dims()));\n\n    const Tensor* b_tensor = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->input(\"b\", &b_tensor));\n    OP_REQUIRES(ctx, b_tensor->dims() == 1,\n                errors::InvalidArgument(\"b must be rank 1 but is rank \",\n                                        b_tensor->dims()));\n    OP_REQUIRES(\n        ctx, cell_size == b_tensor->dim_size(0) \/ 4,\n        errors::InvalidArgument(\"w and b cell_size don't match: \", cell_size,\n                                \" vs. \", b_tensor->dim_size(0)));\n","target":0,"flaw_line_index":0,"hash":"3c7d928c-8cc2-45be-bfd4-95b8004ef866","idx":"6c9b1480-c98e-4a1c-b5e2-8e21473971f3"}
{"func_before":"\n\treturn true;\n\nbeach:\n\tr_buf_free (fbuf);\n\tobj->cache_buf = NULL;\n\tMACH0_(mach0_free) (main_mach0);\n\treturn false;\n}","target":1,"flaw_line_index":0,"hash":"177e81ec-fbcd-4d55-b230-bd0eb0bd5bcb","idx":"061aad1b-1e59-4908-a35a-f80d5c9713cf"}
{"func_before":"\n\treturn true;\n\nbeach:\n\tr_buf_free (fbuf);\n\tif (obj) {\n\t\tobj->cache_buf = NULL;\n\t}\n\tMACH0_(mach0_free) (main_mach0);\n\treturn false;\n}","target":0,"flaw_line_index":0,"hash":"e3fa79d6-23da-40ae-a224-7d3b26eefe50","idx":"a8cb1974-81f8-4f86-9be1-bd10d9b5c14d"}
{"func_before":"{\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -1;\n\tif (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)\n\t\treturn -1;\n\treturn evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];\n}","target":1,"flaw_line_index":0,"hash":"719e7173-d1d4-4b30-be70-5be318c50325","idx":"7dfaf320-55ed-4ea7-9e66-152f8289b393"}
{"func_before":"{\n\tif (evtchn >= xen_evtchn_max_channels())\n\t\treturn -1;\n\tif (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)\n\t\treturn -1;\n\treturn READ_ONCE(evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)]);\n}","target":0,"flaw_line_index":0,"hash":"e748895d-2a88-4f58-a490-eb0cc3243a5f","idx":"b93cf05e-268f-45e9-ac89-2306522e358b"}
{"func_before":"    zstream.next_in  = (unsigned char *)data;\n    zstream.avail_in = data_end - data;\n    av_bprint_init(bp, 0, -1);\n\n    while (zstream.avail_in > 0) {\n        av_bprint_get_buffer(bp, 1, &buf, &buf_size);\n        if (!buf_size) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n        zstream.next_out  = buf;\n        zstream.avail_out = buf_size;\n        ret = inflate(&zstream, Z_PARTIAL_FLUSH);\n        if (ret != Z_OK && ret != Z_STREAM_END) {\n            ret = AVERROR_EXTERNAL;\n            goto fail;\n        }","target":1,"flaw_line_index":0,"hash":"3c0f148f-e276-4216-a678-859362420db0","idx":"531864ee-a78c-4c81-a27d-355364b41a89"}
{"func_before":"    zstream.next_in  = (unsigned char *)data;\n    zstream.avail_in = data_end - data;\n    av_bprint_init(bp, 0, -1);\n\n    while (zstream.avail_in > 0) {\n        av_bprint_get_buffer(bp, 2, &buf, &buf_size);\n        if (buf_size < 2) {\n            ret = AVERROR(ENOMEM);\n            goto fail;\n        }\n        zstream.next_out  = buf;\n        zstream.avail_out = buf_size - 1;\n        ret = inflate(&zstream, Z_PARTIAL_FLUSH);\n        if (ret != Z_OK && ret != Z_STREAM_END) {\n            ret = AVERROR_EXTERNAL;\n            goto fail;\n        }","target":0,"flaw_line_index":0,"hash":"acb38b6e-a608-4a04-a2c5-7d75eace7f99","idx":"6c984df5-4ea7-4dde-b553-8ee638400207"}
{"func_before":"\telse\n\t\tND_PRINT((ndo,\" #%d id=%d \", t.t_no, t.t_id));\n\tcp = (const u_char *)(p + 1);\n\tep2 = (const u_char *)p + item_len;\n\twhile (cp < ep && cp < ep2) {\n\t\tif (map && nmap) {\n\t\t\tcp = ikev1_attrmap_print(ndo, cp, (ep < ep2) ? ep : ep2,\n\t\t\t\tmap, nmap);\n\t\t} else\n\t\t\tcp = ikev1_attr_print(ndo, cp, (ep < ep2) ? ep : ep2);\n\t}\n\tif (ep < ep2)\n\t\tND_PRINT((ndo,\"...\"));\n\treturn cp;\ntrunc:","target":1,"flaw_line_index":0,"hash":"f85e8135-bd4a-4d4a-b0bf-5652c32a66bd","idx":"7fc1da47-6159-4d23-9759-119c380f8d68"}
{"func_before":"\telse\n\t\tND_PRINT((ndo,\" #%d id=%d \", t.t_no, t.t_id));\n\tcp = (const u_char *)(p + 1);\n\tep2 = (const u_char *)p + item_len;\n\twhile (cp < ep && cp < ep2) {\n\t\tif (map && nmap)\n\t\t\tcp = ikev1_attrmap_print(ndo, cp, ep2, map, nmap);\n\t\telse\n\t\t\tcp = ikev1_attr_print(ndo, cp, ep2);\n\t\tif (cp == NULL)\n\t\t\tgoto trunc;\n\t}\n\tif (ep < ep2)\n\t\tND_PRINT((ndo,\"...\"));\n\treturn cp;\ntrunc:","target":0,"flaw_line_index":0,"hash":"af9dc4fa-f53b-4851-bbce-f6f8edde8aea","idx":"0b39b0e1-c044-467c-85e8-fd5a42b30d61"}
{"func_before":"\tjas_matrix_t *data[3];\n\n\/* Note: This function does not properly handle images with a colormap. *\/\n\t\/* Avoid compiler warnings about unused parameters. *\/\n\tcmap = 0;\n\n\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\tdata[i] = jas_matrix_create(1, jas_image_width(image));\n\t\tassert(data[i]);\n\t}\n\n\tpad = RAS_ROWSIZE(hdr) - (hdr->width * hdr->depth + 7) \/ 8;\n\n\tfor (y = 0; y < hdr->height; y++) {\n\t\tnz = 0;\n\t\tz = 0;\n\t\tfor (x = 0; x < hdr->width; x++) {\n\t\t\twhile (nz < hdr->depth) {\n\t\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tz = (z << 8) | c;\n\t\t\t\tnz += 8;\n\t\t\t}\n\n\t\t\t\tjas_matrix_setv(data[0], x, (v));\n\t\t\t}\n\t\t}\n\t\tif (pad) {\n\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\t\tif (jas_image_writecmpt(image, i, 0, y, hdr->width, 1,\n\t\t\t  data[i])) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\tjas_matrix_destroy(data[i]);\n\t}\n\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"afc42a4b-b15d-4d35-8a34-ba20d83b30d1","idx":"84de9433-4600-4423-bdf4-5e253c605148"}
{"func_before":"\n\/* Note: This function does not properly handle images with a colormap. *\/\n\t\/* Avoid compiler warnings about unused parameters. *\/\n\tcmap = 0;\n\n\tassert(jas_image_numcmpts(image) <= 3);\n\n\tfor (i = 0; i < 3; ++i) {\n\t\tdata[i] = 0;\n\t}\n\n\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\tif (!(data[i] = jas_matrix_create(1, jas_image_width(image)))) {\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tpad = RAS_ROWSIZE(hdr) - (hdr->width * hdr->depth + 7) \/ 8;\n\n\tfor (y = 0; y < hdr->height; y++) {\n\t\tnz = 0;\n\t\tz = 0;\n\t\tfor (x = 0; x < hdr->width; x++) {\n\t\t\twhile (nz < hdr->depth) {\n\t\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tz = (z << 8) | c;\n\t\t\t\tnz += 8;\n\t\t\t}\n\n\t\t\t\tjas_matrix_setv(data[0], x, (v));\n\t\t\t}\n\t\t}\n\t\tif (pad) {\n\t\t\tif ((c = jas_stream_getc(in)) == EOF) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\t\tif (jas_image_writecmpt(image, i, 0, y, hdr->width, 1,\n\t\t\t  data[i])) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < jas_image_numcmpts(image); ++i) {\n\t\tjas_matrix_destroy(data[i]);\n\t\tdata[i] = 0;\n\t}\n\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < 3; ++i) {\n\t\tif (data[i]) {\n\t\t\tjas_matrix_destroy(data[i]);\n\t\t}\n\t}\n\treturn -1;\n}","target":0,"flaw_line_index":0,"hash":"d15bc81b-4433-4eea-9aea-f3a9365ab448","idx":"6859f56d-700a-4fce-b26b-b2ebcd0f7390"}
{"func_before":"\t}\n\n\tstart = cursor;\n\n\n#line 585 \"ext\/standard\/var_unserializer.c\"\n{\n\tYYCTYPE yych;\n\tstatic const unsigned char yybm[] = {\n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t};\n\tif ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);\n\tyych = *YYCURSOR;\n\tswitch (yych) {\n\tcase 'C':\n\tcase 'O':\tgoto yy13;\n\tcase 'N':\tgoto yy5;\n\tcase 'R':\tgoto yy2;\n\tcase 'S':\tgoto yy10;\n\tcase 'a':\tgoto yy11;\n\tcase 'b':\tgoto yy6;\n\tcase 'd':\tgoto yy8;\n\tcase 'i':\tgoto yy7;\n\tcase 'o':\tgoto yy12;\n\tcase 'r':\tgoto yy4;\n\tcase 's':\tgoto yy9;\n\tcase '}':\tgoto yy14;\n\tdefault:\tgoto yy16;\n\t}\nyy2:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy95;\nyy3:\n#line 962 \"ext\/standard\/var_unserializer.re\"\n\t{ return 0; }\n#line 646 \"ext\/standard\/var_unserializer.c\"\nyy4:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy89;\n\tgoto yy3;\nyy5:\n\tyych = *++YYCURSOR;\n\tif (yych == ';') goto yy87;\n\tgoto yy3;\nyy6:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy83;\n\tgoto yy3;\nyy7:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy77;\n\tgoto yy3;\nyy8:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy53;\n\tgoto yy3;\nyy9:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy46;\n\tgoto yy3;\nyy10:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy39;\n\tgoto yy3;\nyy11:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy32;\n\tgoto yy3;\nyy12:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy25;\n\tgoto yy3;\nyy13:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy17;\n\tgoto yy3;\nyy14:\n\t++YYCURSOR;\n#line 956 \"ext\/standard\/var_unserializer.re\"\n\t{\n\t\/* this is the case where we have less data than planned *\/\n\tphp_error_docref(NULL, E_NOTICE, \"Unexpected end of serialized data\");\n\treturn 0; \/* not sure if it should be 0 or 1 here? *\/\n}\n#line 695 \"ext\/standard\/var_unserializer.c\"\nyy16:\n\tyych = *++YYCURSOR;\n\tgoto yy3;\nyy17:\n\tyych = *++YYCURSOR;\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy20;\n\t}\n\tif (yych == '+') goto yy19;\nyy18:\n\tYYCURSOR = YYMARKER;\n\tgoto yy3;\nyy19:\n\tyych = *++YYCURSOR;\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy20;\n\t}\n\tgoto yy18;\nyy20:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy20;\n\t}\n\tif (yych <= '\/') goto yy18;\n\tif (yych >= ';') goto yy18;\n\tyych = *++YYCURSOR;\n\tif (yych != '\"') goto yy18;\n\t++YYCURSOR;\n#line 804 \"ext\/standard\/var_unserializer.re\"\n\t{\n\tsize_t len, len2, len3, maxlen;\n\tzend_long elements;\n\tchar *str;\n\tzend_string *class_name;\n\t}\n\tzend_string_release(class_name);\n\n\treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n}\n#line 878 \"ext\/standard\/var_unserializer.c\"\nyy25:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy26;\n\t\tif (yych <= '\/') goto yy18;\n\t\tif (yych <= '9') goto yy27;\n\t\tgoto yy18;\n\t}\nyy26:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy27:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy27;\n\tif (yych >= ';') goto yy18;\n\tyych = *++YYCURSOR;\n\tif (yych != '\"') goto yy18;\n\t++YYCURSOR;\n#line 793 \"ext\/standard\/var_unserializer.re\"\n\t{\n\tzend_long elements;\n    if (!var_hash) return 0;\n\n\telements = object_common1(UNSERIALIZE_PASSTHRU, ZEND_STANDARD_CLASS_DEF_PTR);\n\tif (elements < 0 || elements >= HT_MAX_SIZE) {\n\t\treturn 0;\n\t}\n\treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n}\n#line 914 \"ext\/standard\/var_unserializer.c\"\nyy32:\n\tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy33;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy34;\n\tgoto yy18;\nyy33:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy34:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy34;\n\tif (yych >= ';') goto yy18;\n\tyych = *++YYCURSOR;\n\tif (yych != '{') goto yy18;\n\t++YYCURSOR;\n#line 769 \"ext\/standard\/var_unserializer.re\"\n\t{\n\tzend_long elements = parse_iv(start + 2);\n\t\/* use iv() not uiv() in order to check data range *\/\n\t*p = YYCURSOR;\n    if (!var_hash) return 0;\n\t\treturn 0;\n\t}\n\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n}\n#line 959 \"ext\/standard\/var_unserializer.c\"\nyy39:\n\tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy40;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy41;\n\tgoto yy18;\nyy40:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy41:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy41;\n\tif (yych >= ';') goto yy18;\n\tyych = *++YYCURSOR;\n\tif (yych != '\"') goto yy18;\n\t++YYCURSOR;\n#line 735 \"ext\/standard\/var_unserializer.re\"\n\t{\n\tsize_t len, maxlen;\n\tzend_string *str;\n\n\tlen = parse_uiv(start + 2);\n\tmaxlen = max - YYCURSOR;\n\tif (maxlen < len) {\n\t\t*p = start + 2;\n\t\treturn 0;\n\t}\n\n\tif ((str = unserialize_str(&YYCURSOR, len, maxlen)) == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (*(YYCURSOR) != '\"') {\n\t\tzend_string_free(str);\n\t\t*p = YYCURSOR;\n\t\treturn 0;\n\t}\n\n\tif (*(YYCURSOR + 1) != ';') {\n\t\tefree(str);\n\t\t*p = YYCURSOR + 1;\n\t\treturn 0;\n\t}\n\n\tYYCURSOR += 2;\n\t*p = YYCURSOR;\n\n\tZVAL_STR(rval, str);\n\treturn 1;\n}\n#line 1014 \"ext\/standard\/var_unserializer.c\"\nyy46:\n\tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy47;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy48;\n\tgoto yy18;\nyy47:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy48:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy48;\n\tif (yych >= ';') goto yy18;\n\tyych = *++YYCURSOR;\n\tif (yych != '\"') goto yy18;\n\t++YYCURSOR;\n#line 703 \"ext\/standard\/var_unserializer.re\"\n\t{\n\tsize_t len, maxlen;\n\tchar *str;\n\n\tlen = parse_uiv(start + 2);\n\tmaxlen = max - YYCURSOR;\n\tif (maxlen < len) {\n\t\t*p = start + 2;\n\t\treturn 0;\n\t}\n\n\tstr = (char*)YYCURSOR;\n\n\tYYCURSOR += len;\n\n\tif (*(YYCURSOR) != '\"') {\n\t\t*p = YYCURSOR;\n\t\treturn 0;\n\t}\n\n\tif (*(YYCURSOR + 1) != ';') {\n\t\t*p = YYCURSOR + 1;\n\t\treturn 0;\n\t}\n\n\tYYCURSOR += 2;\n\t*p = YYCURSOR;\n\n\tZVAL_STRINGL(rval, str, len);\n\treturn 1;\n}\n#line 1067 \"ext\/standard\/var_unserializer.c\"\nyy53:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') {\n\t\tif (yych <= ',') {\n\t\t\tif (yych == '+') goto yy57;\n\t\t\tgoto yy18;\n\t\t} else {\n\t\t\tif (yych <= '-') goto yy55;\n\t\t\tif (yych <= '.') goto yy60;\n\t\t\tgoto yy18;\n\t\t}\n\t} else {\n\t\tif (yych <= 'I') {\n\t\t\tif (yych <= '9') goto yy58;\n\t\t\tif (yych <= 'H') goto yy18;\n\t\t\tgoto yy56;\n\t\t} else {\n\t\t\tif (yych != 'N') goto yy18;\n\t\t}\n\t}\n\tyych = *++YYCURSOR;\n\tif (yych == 'A') goto yy76;\n\tgoto yy18;\nyy55:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') {\n\t\tif (yych == '.') goto yy60;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '9') goto yy58;\n\t\tif (yych != 'I') goto yy18;\n\t}\nyy56:\n\tyych = *++YYCURSOR;\n\tif (yych == 'N') goto yy72;\n\tgoto yy18;\nyy57:\n\tyych = *++YYCURSOR;\n\tif (yych == '.') goto yy60;\n\tif (yych <= '\/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy58:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n\tyych = *YYCURSOR;\n\tif (yych <= ':') {\n\t\tif (yych <= '.') {\n\t\t\tif (yych <= '-') goto yy18;\n\t\t\tgoto yy70;\n\t\t} else {\n\t\t\tif (yych <= '\/') goto yy18;\n\t\t\tif (yych <= '9') goto yy58;\n\t\t\tgoto yy18;\n\t\t}\n\t} else {\n\t\tif (yych <= 'E') {\n\t\t\tif (yych <= ';') goto yy63;\n\t\t\tif (yych <= 'D') goto yy18;\n\t\t\tgoto yy65;\n\t\t} else {\n\t\t\tif (yych == 'e') goto yy65;\n\t\t\tgoto yy18;\n\t\t}\n\t}\nyy60:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy61:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n\tyych = *YYCURSOR;\n\tif (yych <= ';') {\n\t\tif (yych <= '\/') goto yy18;\n\t\tif (yych <= '9') goto yy61;\n\t\tif (yych <= ':') goto yy18;\n\t} else {\n\t\tif (yych <= 'E') {\n\t\t\tif (yych <= 'D') goto yy18;\n\t\t\tgoto yy65;\n\t\t} else {\n\t\t\tif (yych == 'e') goto yy65;\n\t\t\tgoto yy18;\n\t\t}\n\t}\nyy63:\n\t++YYCURSOR;\n#line 694 \"ext\/standard\/var_unserializer.re\"\n\t{\n#if SIZEOF_ZEND_LONG == 4\nuse_double:\n#endif\n\t*p = YYCURSOR;\n\tZVAL_DOUBLE(rval, zend_strtod((const char *)start + 2, NULL));\n\treturn 1;\n}\n#line 1164 \"ext\/standard\/var_unserializer.c\"\nyy65:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy66;\n\t\tif (yych <= '\/') goto yy18;\n\t\tif (yych <= '9') goto yy67;\n\t\tgoto yy18;\n\t}\nyy66:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych == '+') goto yy69;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy69;\n\t\tif (yych <= '\/') goto yy18;\n\t\tif (yych >= ':') goto yy18;\n\t}\nyy67:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy67;\n\tif (yych == ';') goto yy63;\n\tgoto yy18;\nyy69:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy67;\n\tgoto yy18;\nyy70:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n\tyych = *YYCURSOR;\n\tif (yych <= ';') {\n\t\tif (yych <= '\/') goto yy18;\n\t\tif (yych <= '9') goto yy70;\n\t\tif (yych <= ':') goto yy18;\n\t\tgoto yy63;\n\t} else {\n\t\tif (yych <= 'E') {\n\t\t\tif (yych <= 'D') goto yy18;\n\t\t\tgoto yy65;\n\t\t} else {\n\t\t\tif (yych == 'e') goto yy65;\n\t\t\tgoto yy18;\n\t\t}\n\t}\nyy72:\n\tyych = *++YYCURSOR;\n\tif (yych != 'F') goto yy18;\nyy73:\n\tyych = *++YYCURSOR;\n\tif (yych != ';') goto yy18;\n\t++YYCURSOR;\n#line 678 \"ext\/standard\/var_unserializer.re\"\n\t{\n\t*p = YYCURSOR;\n\n\tif (!strncmp((char*)start + 2, \"NAN\", 3)) {\n\t\tZVAL_DOUBLE(rval, php_get_nan());\n\t\tZVAL_NULL(rval);\n\t}\n\n\treturn 1;\n}\n#line 1239 \"ext\/standard\/var_unserializer.c\"\nyy76:\n\tyych = *++YYCURSOR;\n\tif (yych == 'N') goto yy73;\n\tgoto yy18;\nyy77:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy78;\n\t\tif (yych <= '\/') goto yy18;\n\t\tif (yych <= '9') goto yy79;\n\t\tgoto yy18;\n\t}\nyy78:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy79:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy79;\n\tif (yych != ';') goto yy18;\n\t++YYCURSOR;\n#line 652 \"ext\/standard\/var_unserializer.re\"\n\t{\n#if SIZEOF_ZEND_LONG == 4\n\tint digits = YYCURSOR - start - 3;\n\n\tif (start[2] == '-' || start[2] == '+') {\n\t\tdigits--;\n\t}\n\n\t\/* Use double for large zend_long values that were serialized on a 64-bit system *\/\n\tif (digits >= MAX_LENGTH_OF_LONG - 1) {\n\t\tif (digits == MAX_LENGTH_OF_LONG - 1) {\n\t\t\tint cmp = strncmp((char*)YYCURSOR - MAX_LENGTH_OF_LONG, long_min_digits, MAX_LENGTH_OF_LONG - 1);\n\n\t\t\tif (!(cmp < 0 || (cmp == 0 && start[2] == '-'))) {\n\t\t\t\tgoto use_double;\n\t\t\t}\n\t\t} else {\n\t\t\tgoto use_double;\n\t\t}\n\t}\n#endif\n\t*p = YYCURSOR;\n\tZVAL_LONG(rval, parse_iv(start + 2));\n\treturn 1;\n}\n#line 1292 \"ext\/standard\/var_unserializer.c\"\nyy83:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych >= '2') goto yy18;\n\tyych = *++YYCURSOR;\n\tif (yych != ';') goto yy18;\n\t++YYCURSOR;\n#line 646 \"ext\/standard\/var_unserializer.re\"\n\t{\n\t*p = YYCURSOR;\n\tZVAL_BOOL(rval, parse_iv(start + 2));\n\treturn 1;\n}\n#line 1306 \"ext\/standard\/var_unserializer.c\"\nyy87:\n\t++YYCURSOR;\n#line 640 \"ext\/standard\/var_unserializer.re\"\n\t{\n\t*p = YYCURSOR;\n\tZVAL_NULL(rval);\n\treturn 1;\n}\n#line 1315 \"ext\/standard\/var_unserializer.c\"\nyy89:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy90;\n\t\tif (yych <= '\/') goto yy18;\n\t\tif (yych <= '9') goto yy91;\n\t\tgoto yy18;\n\t}\nyy90:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy91:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy91;\n\tif (yych != ';') goto yy18;\n\t++YYCURSOR;\n#line 615 \"ext\/standard\/var_unserializer.re\"\n\t{\n\tzend_long id;\n\n \t*p = YYCURSOR;\n\tif (!var_hash) return 0;\n\n\tid = parse_iv(start + 2) - 1;\n\tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (rval_ref == rval) {\n\t\treturn 0;\n\t}\n\n\tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {\n\t\tZVAL_UNDEF(rval);\n\t\treturn 1;\n\t}\n\n\tZVAL_COPY(rval, rval_ref);\n\n\treturn 1;\n}\n#line 1363 \"ext\/standard\/var_unserializer.c\"\nyy95:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych != '+') goto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy96;\n\t\tif (yych <= '\/') goto yy18;\n\t\tif (yych <= '9') goto yy97;\n\t\tgoto yy18;\n\t}\nyy96:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy97:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy97;\n\tif (yych != ';') goto yy18;\n\t++YYCURSOR;\n#line 589 \"ext\/standard\/var_unserializer.re\"\n\t{\n\tzend_long id;\n\n \t*p = YYCURSOR;\n\tif (!var_hash) return 0;\n\n\tid = parse_iv(start + 2) - 1;\n\tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {\n\t\treturn 0;\n\t}\n\n\tzval_ptr_dtor(rval);\n\tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {\n\t\tZVAL_UNDEF(rval);\n\t\treturn 1;\n\t}\n\tif (Z_ISREF_P(rval_ref)) {\n\t\tZVAL_COPY(rval, rval_ref);\n\t} else {\n\t\tZVAL_NEW_REF(rval_ref, rval_ref);\n\t\tZVAL_COPY(rval, rval_ref);\n\t}\n\n\treturn 1;\n}\n#line 1412 \"ext\/standard\/var_unserializer.c\"\n}\n#line 964 \"ext\/standard\/var_unserializer.re\"\n\n\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"318a46a8-a5bb-4493-bcc9-8bb45a313641","idx":"52a24760-43d4-41a0-929f-bc34cabbe4ce"}
{"func_before":"\t}\n\n\tstart = cursor;\n\n\n#line 576 \"ext\/standard\/var_unserializer.c\"\n{\n\tYYCTYPE yych;\n\tstatic const unsigned char yybm[] = {\n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t\t  0,   0,   0,   0,   0,   0,   0,   0, \n\t};\n\tif ((YYLIMIT - YYCURSOR) < 7) YYFILL(7);\n\tyych = *YYCURSOR;\n\tswitch (yych) {\n\tcase 'C':\n\tcase 'O':\tgoto yy4;\n\tcase 'N':\tgoto yy5;\n\tcase 'R':\tgoto yy6;\n\tcase 'S':\tgoto yy7;\n\tcase 'a':\tgoto yy8;\n\tcase 'b':\tgoto yy9;\n\tcase 'd':\tgoto yy10;\n\tcase 'i':\tgoto yy11;\n\tcase 'o':\tgoto yy12;\n\tcase 'r':\tgoto yy13;\n\tcase 's':\tgoto yy14;\n\tcase '}':\tgoto yy15;\n\tdefault:\tgoto yy2;\n\t}\nyy2:\n\t++YYCURSOR;\nyy3:\n#line 951 \"ext\/standard\/var_unserializer.re\"\n\t{ return 0; }\n#line 636 \"ext\/standard\/var_unserializer.c\"\nyy4:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy17;\n\tgoto yy3;\nyy5:\n\tyych = *++YYCURSOR;\n\tif (yych == ';') goto yy19;\n\tgoto yy3;\nyy6:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy21;\n\tgoto yy3;\nyy7:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy22;\n\tgoto yy3;\nyy8:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy23;\n\tgoto yy3;\nyy9:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy24;\n\tgoto yy3;\nyy10:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy25;\n\tgoto yy3;\nyy11:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy26;\n\tgoto yy3;\nyy12:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy27;\n\tgoto yy3;\nyy13:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy28;\n\tgoto yy3;\nyy14:\n\tyych = *(YYMARKER = ++YYCURSOR);\n\tif (yych == ':') goto yy29;\n\tgoto yy3;\nyy15:\n\t++YYCURSOR;\n#line 945 \"ext\/standard\/var_unserializer.re\"\n\t{\n\t\/* this is the case where we have less data than planned *\/\n\tphp_error_docref(NULL, E_NOTICE, \"Unexpected end of serialized data\");\n\treturn 0; \/* not sure if it should be 0 or 1 here? *\/\n}\n#line 689 \"ext\/standard\/var_unserializer.c\"\nyy17:\n\tyych = *++YYCURSOR;\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy31;\n\t}\n\tif (yych == '+') goto yy30;\nyy18:\n\tYYCURSOR = YYMARKER;\n\tgoto yy3;\nyy19:\n\t++YYCURSOR;\n#line 629 \"ext\/standard\/var_unserializer.re\"\n\t{\n\t*p = YYCURSOR;\n\tZVAL_NULL(rval);\n\treturn 1;\n}\n#line 707 \"ext\/standard\/var_unserializer.c\"\nyy21:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych == '+') goto yy33;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy33;\n\t\tif (yych <= '\/') goto yy18;\n\t\tif (yych <= '9') goto yy34;\n\t\tgoto yy18;\n\t}\nyy22:\n\tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy36;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy37;\n\tgoto yy18;\nyy23:\n\tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy39;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy40;\n\tgoto yy18;\nyy24:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '1') goto yy42;\n\tgoto yy18;\nyy25:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') {\n\t\tif (yych <= ',') {\n\t\t\tif (yych == '+') goto yy43;\n\t\t\tgoto yy18;\n\t\t} else {\n\t\t\tif (yych <= '-') goto yy44;\n\t\t\tif (yych <= '.') goto yy45;\n\t\t\tgoto yy18;\n\t\t}\n\t} else {\n\t\tif (yych <= 'I') {\n\t\t\tif (yych <= '9') goto yy46;\n\t\t\tif (yych <= 'H') goto yy18;\n\t\t\tgoto yy48;\n\t\t} else {\n\t\t\tif (yych == 'N') goto yy49;\n\t\t\tgoto yy18;\n\t\t}\n\t}\nyy26:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych == '+') goto yy50;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy50;\n\t\tif (yych <= '\/') goto yy18;\n\t\tif (yych <= '9') goto yy51;\n\t\tgoto yy18;\n\t}\nyy27:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych == '+') goto yy53;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy53;\n\t\tif (yych <= '\/') goto yy18;\n\t\tif (yych <= '9') goto yy54;\n\t\tgoto yy18;\n\t}\nyy28:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych == '+') goto yy56;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy56;\n\t\tif (yych <= '\/') goto yy18;\n\t\tif (yych <= '9') goto yy57;\n\t\tgoto yy18;\n\t}\nyy29:\n\tyych = *++YYCURSOR;\n\tif (yych == '+') goto yy59;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy60;\n\tgoto yy18;\nyy30:\n\tyych = *++YYCURSOR;\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy31;\n\t}\n\tgoto yy18;\nyy31:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yybm[0+yych] & 128) {\n\t\tgoto yy31;\n\t}\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= ':') goto yy62;\n\tgoto yy18;\nyy33:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy34:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy34;\n\tif (yych == ';') goto yy63;\n\tgoto yy18;\nyy36:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy37:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy37;\n\tif (yych <= ':') goto yy65;\n\tgoto yy18;\nyy39:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy40:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy40;\n\tif (yych <= ':') goto yy66;\n\tgoto yy18;\nyy42:\n\tyych = *++YYCURSOR;\n\tif (yych == ';') goto yy67;\n\tgoto yy18;\nyy43:\n\tyych = *++YYCURSOR;\n\tif (yych == '.') goto yy45;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy46;\n\tgoto yy18;\nyy44:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') {\n\t\tif (yych != '.') goto yy18;\n\t} else {\n\t\tif (yych <= '9') goto yy46;\n\t\tif (yych == 'I') goto yy48;\n\t\tgoto yy18;\n\t}\nyy45:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy69;\n\tgoto yy18;\nyy46:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n\tyych = *YYCURSOR;\n\tif (yych <= ':') {\n\t\tif (yych <= '.') {\n\t\t\tif (yych <= '-') goto yy18;\n\t\t\tgoto yy69;\n\t\t} else {\n\t\t\tif (yych <= '\/') goto yy18;\n\t\t\tif (yych <= '9') goto yy46;\n\t\t\tgoto yy18;\n\t\t}\n\t} else {\n\t\tif (yych <= 'E') {\n\t\t\tif (yych <= ';') goto yy71;\n\t\t\tif (yych <= 'D') goto yy18;\n\t\t\tgoto yy73;\n\t\t} else {\n\t\t\tif (yych == 'e') goto yy73;\n\t\t\tgoto yy18;\n\t\t}\n\t}\nyy48:\n\tyych = *++YYCURSOR;\n\tif (yych == 'N') goto yy74;\n\tgoto yy18;\nyy49:\n\tyych = *++YYCURSOR;\n\tif (yych == 'A') goto yy75;\n\tgoto yy18;\nyy50:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy51:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy51;\n\tif (yych == ';') goto yy76;\n\tgoto yy18;\nyy53:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy54:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy54;\n\tif (yych <= ':') goto yy78;\n\tgoto yy18;\nyy56:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy57:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy57;\n\tif (yych == ';') goto yy79;\n\tgoto yy18;\nyy59:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych >= ':') goto yy18;\nyy60:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);\n\tyych = *YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy60;\n\tif (yych <= ':') goto yy81;\n\tgoto yy18;\nyy62:\n\tyych = *++YYCURSOR;\n\tif (yych == '\"') goto yy82;\n\tgoto yy18;\nyy63:\n\t++YYCURSOR;\n#line 580 \"ext\/standard\/var_unserializer.re\"\n\t{\n\tzend_long id;\n\n \t*p = YYCURSOR;\n\tif (!var_hash) return 0;\n\n\tid = parse_iv(start + 2) - 1;\n\tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {\n\t\treturn 0;\n\t}\n\n\tif (Z_ISREF_P(rval_ref)) {\n\t\tZVAL_COPY(rval, rval_ref);\n\t} else {\n\t\tZVAL_NEW_REF(rval_ref, rval_ref);\n\t\tZVAL_COPY(rval, rval_ref);\n\t}\n\n\treturn 1;\n}\n#line 982 \"ext\/standard\/var_unserializer.c\"\nyy65:\n\tyych = *++YYCURSOR;\n\tif (yych == '\"') goto yy84;\n\tgoto yy18;\nyy66:\n\tyych = *++YYCURSOR;\n\tif (yych == '{') goto yy86;\n\tgoto yy18;\nyy67:\n\t++YYCURSOR;\n#line 635 \"ext\/standard\/var_unserializer.re\"\n\t{\n\t*p = YYCURSOR;\n\tZVAL_BOOL(rval, parse_iv(start + 2));\n\treturn 1;\n}\n#line 999 \"ext\/standard\/var_unserializer.c\"\nyy69:\n\t++YYCURSOR;\n\tif ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);\n\tyych = *YYCURSOR;\n\tif (yych <= ';') {\n\t\tif (yych <= '\/') goto yy18;\n\t\tif (yych <= '9') goto yy69;\n\t\tif (yych <= ':') goto yy18;\n\t} else {\n\t\tif (yych <= 'E') {\n\t\t\tif (yych <= 'D') goto yy18;\n\t\t\tgoto yy73;\n\t\t} else {\n\t\t\tif (yych == 'e') goto yy73;\n\t\t\tgoto yy18;\n\t\t}\n\t}\nyy71:\n\t++YYCURSOR;\n#line 683 \"ext\/standard\/var_unserializer.re\"\n\t{\n#if SIZEOF_ZEND_LONG == 4\nuse_double:\n#endif\n\t*p = YYCURSOR;\n\tZVAL_DOUBLE(rval, zend_strtod((const char *)start + 2, NULL));\n\treturn 1;\n}\n#line 1028 \"ext\/standard\/var_unserializer.c\"\nyy73:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych == '+') goto yy88;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy88;\n\t\tif (yych <= '\/') goto yy18;\n\t\tif (yych <= '9') goto yy89;\n\t\tgoto yy18;\n\t}\nyy74:\n\tyych = *++YYCURSOR;\n\tif (yych == 'F') goto yy91;\n\tgoto yy18;\nyy75:\n\tyych = *++YYCURSOR;\n\tif (yych == 'N') goto yy91;\n\tgoto yy18;\nyy76:\n\t++YYCURSOR;\n#line 641 \"ext\/standard\/var_unserializer.re\"\n\t{\n#if SIZEOF_ZEND_LONG == 4\n\tint digits = YYCURSOR - start - 3;\n\n\tif (start[2] == '-' || start[2] == '+') {\n\t\tdigits--;\n\t}\n\n\t\/* Use double for large zend_long values that were serialized on a 64-bit system *\/\n\tif (digits >= MAX_LENGTH_OF_LONG - 1) {\n\t\tif (digits == MAX_LENGTH_OF_LONG - 1) {\n\t\t\tint cmp = strncmp((char*)YYCURSOR - MAX_LENGTH_OF_LONG, long_min_digits, MAX_LENGTH_OF_LONG - 1);\n\n\t\t\tif (!(cmp < 0 || (cmp == 0 && start[2] == '-'))) {\n\t\t\t\tgoto use_double;\n\t\t\t}\n\t\t} else {\n\t\t\tgoto use_double;\n\t\t}\n\t}\n#endif\n\t*p = YYCURSOR;\n\tZVAL_LONG(rval, parse_iv(start + 2));\n\treturn 1;\n}\n#line 1076 \"ext\/standard\/var_unserializer.c\"\nyy78:\n\tyych = *++YYCURSOR;\n\tif (yych == '\"') goto yy92;\n\tgoto yy18;\nyy79:\n\t++YYCURSOR;\n#line 605 \"ext\/standard\/var_unserializer.re\"\n\t{\n\tzend_long id;\n\n \t*p = YYCURSOR;\n\tif (!var_hash) return 0;\n\n\tid = parse_iv(start + 2) - 1;\n\tif (id == -1 || (rval_ref = var_access(var_hash, id)) == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (rval_ref == rval) {\n\t\treturn 0;\n\t}\n\n\tif (Z_ISUNDEF_P(rval_ref) || (Z_ISREF_P(rval_ref) && Z_ISUNDEF_P(Z_REFVAL_P(rval_ref)))) {\n\t\treturn 0;\n\t}\n\n\tZVAL_COPY(rval, rval_ref);\n\n\treturn 1;\n}\n#line 1107 \"ext\/standard\/var_unserializer.c\"\nyy81:\n\tyych = *++YYCURSOR;\n\tif (yych == '\"') goto yy94;\n\tgoto yy18;\nyy82:\n\t++YYCURSOR;\n#line 793 \"ext\/standard\/var_unserializer.re\"\n\t{\n\tsize_t len, len2, len3, maxlen;\n\tzend_long elements;\n\tchar *str;\n\tzend_string *class_name;\n\t}\n\tzend_string_release(class_name);\n\n\treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n}\n#line 1266 \"ext\/standard\/var_unserializer.c\"\nyy84:\n\t++YYCURSOR;\n#line 724 \"ext\/standard\/var_unserializer.re\"\n\t{\n\tsize_t len, maxlen;\n\tzend_string *str;\n\n\tlen = parse_uiv(start + 2);\n\tmaxlen = max - YYCURSOR;\n\tif (maxlen < len) {\n\t\t*p = start + 2;\n\t\treturn 0;\n\t}\n\n\tif ((str = unserialize_str(&YYCURSOR, len, maxlen)) == NULL) {\n\t\treturn 0;\n\t}\n\n\tif (*(YYCURSOR) != '\"') {\n\t\tzend_string_free(str);\n\t\t*p = YYCURSOR;\n\t\treturn 0;\n\t}\n\n\tif (*(YYCURSOR + 1) != ';') {\n\t\tefree(str);\n\t\t*p = YYCURSOR + 1;\n\t\treturn 0;\n\t}\n\n\tYYCURSOR += 2;\n\t*p = YYCURSOR;\n\n\tZVAL_STR(rval, str);\n\treturn 1;\n}\n#line 1303 \"ext\/standard\/var_unserializer.c\"\nyy86:\n\t++YYCURSOR;\n#line 758 \"ext\/standard\/var_unserializer.re\"\n\t{\n\tzend_long elements = parse_iv(start + 2);\n\t\/* use iv() not uiv() in order to check data range *\/\n\t*p = YYCURSOR;\n    if (!var_hash) return 0;\n\t\treturn 0;\n\t}\n\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n}\n#line 1330 \"ext\/standard\/var_unserializer.c\"\nyy88:\n\tyych = *++YYCURSOR;\n\tif (yych <= ',') {\n\t\tif (yych == '+') goto yy96;\n\t\tgoto yy18;\n\t} else {\n\t\tif (yych <= '-') goto yy96;\n\t\tif (yych <= '\/') goto yy18;\n\t\tif (yych >= ':') goto yy18;\n\t}\nyy89:\n\t++YYCURSOR;\n\tif (YYLIMIT <= YYCURSOR) YYFILL(1);\n\tyych = *YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy89;\n\tif (yych == ';') goto yy71;\n\tgoto yy18;\nyy91:\n\tyych = *++YYCURSOR;\n\tif (yych == ';') goto yy97;\n\tgoto yy18;\nyy92:\n\t++YYCURSOR;\n#line 782 \"ext\/standard\/var_unserializer.re\"\n\t{\n\tzend_long elements;\n    if (!var_hash) return 0;\n\n\telements = object_common1(UNSERIALIZE_PASSTHRU, ZEND_STANDARD_CLASS_DEF_PTR);\n\tif (elements < 0 || elements >= HT_MAX_SIZE) {\n\t\treturn 0;\n\t}\n\treturn object_common2(UNSERIALIZE_PASSTHRU, elements);\n}\n#line 1366 \"ext\/standard\/var_unserializer.c\"\nyy94:\n\t++YYCURSOR;\n#line 692 \"ext\/standard\/var_unserializer.re\"\n\t{\n\tsize_t len, maxlen;\n\tchar *str;\n\n\tlen = parse_uiv(start + 2);\n\tmaxlen = max - YYCURSOR;\n\tif (maxlen < len) {\n\t\t*p = start + 2;\n\t\treturn 0;\n\t}\n\n\tstr = (char*)YYCURSOR;\n\n\tYYCURSOR += len;\n\n\tif (*(YYCURSOR) != '\"') {\n\t\t*p = YYCURSOR;\n\t\treturn 0;\n\t}\n\n\tif (*(YYCURSOR + 1) != ';') {\n\t\t*p = YYCURSOR + 1;\n\t\treturn 0;\n\t}\n\n\tYYCURSOR += 2;\n\t*p = YYCURSOR;\n\n\tZVAL_STRINGL(rval, str, len);\n\treturn 1;\n}\n#line 1401 \"ext\/standard\/var_unserializer.c\"\nyy96:\n\tyych = *++YYCURSOR;\n\tif (yych <= '\/') goto yy18;\n\tif (yych <= '9') goto yy89;\n\tgoto yy18;\nyy97:\n\t++YYCURSOR;\n#line 667 \"ext\/standard\/var_unserializer.re\"\n\t{\n\t*p = YYCURSOR;\n\n\tif (!strncmp((char*)start + 2, \"NAN\", 3)) {\n\t\tZVAL_DOUBLE(rval, php_get_nan());\n\t\tZVAL_NULL(rval);\n\t}\n\n\treturn 1;\n}\n#line 1425 \"ext\/standard\/var_unserializer.c\"\n}\n#line 953 \"ext\/standard\/var_unserializer.re\"\n\n\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"f1934b20-2ada-48bd-a4e3-c9115650bd31","idx":"c88e0a3c-fb08-4dd4-8948-292e47faa155"}
{"func_before":"    int\t\tused_max_fill_curwin = FALSE;\n    int\t\tn;\n\n    need_diff_redraw = FALSE;\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_p_diff)\n\t{\n\t    redraw_win_later(wp, SOME_VALID);\n\t    if (wp != curwin)\n\t\twp_other = wp;\n#ifdef FEAT_FOLDING","target":1,"flaw_line_index":0,"hash":"6a240600-85b6-4b0d-b9e3-fb18799dc71b","idx":"08737287-8b3b-47dc-b3c8-6c99377615ba"}
{"func_before":"    int\t\tused_max_fill_curwin = FALSE;\n    int\t\tn;\n\n    need_diff_redraw = FALSE;\n    FOR_ALL_WINDOWS(wp)\n\t\/\/ when closing windows or wiping buffers skip invalid window\n\tif (wp->w_p_diff && buf_valid(wp->w_buffer))\n\t{\n\t    redraw_win_later(wp, SOME_VALID);\n\t    if (wp != curwin)\n\t\twp_other = wp;\n#ifdef FEAT_FOLDING","target":0,"flaw_line_index":0,"hash":"446d477f-66cc-400b-b363-e51abfdb3d70","idx":"132e00a9-b896-48a5-890d-44ff10932c1f"}
{"func_before":"          g_object_unref (target_file);\n          break;\n        }\n\n      \/* update progress information *\/\n      exo_job_info_message (EXO_JOB (job), g_file_info_get_display_name (info));\n\nretry_copy:\n      \/* copy the item specified by this node (not recursively) *\/\n      real_target_file = thunar_transfer_job_copy_file (job, node->source_file, \n                                                        target_file, &err);","target":1,"flaw_line_index":0,"hash":"0cabe5ba-acbb-48b4-b3bb-462ee3c73b70","idx":"d7590b3f-c3fd-4104-b3d2-a87af766d3b8"}
{"func_before":"          g_object_unref (target_file);\n          break;\n        }\n\n      \/* update progress information *\/\n      exo_job_info_message (EXO_JOB (job), \"%s\", g_file_info_get_display_name (info));\n\nretry_copy:\n      \/* copy the item specified by this node (not recursively) *\/\n      real_target_file = thunar_transfer_job_copy_file (job, node->source_file, \n                                                        target_file, &err);","target":0,"flaw_line_index":0,"hash":"fb30c9ea-b9f6-46be-acb8-473c2d05f877","idx":"36a82310-b42f-48d4-a040-0c176a673480"}
{"func_before":"\t\t\t\tif (sdump->X3DDump) {\n\t\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t\t} else {\n\t\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t\t}\n\t\t\t\tif (mffield) {\n\t\t\t\t\tfor (i=0; i<mffield->count; i++) {\n\t\t\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_fprintf(sdump->trace, \"\\\"\/>\\n\");\n\t\t\t}\n\t\t}","target":1,"flaw_line_index":0,"hash":"6d50f60f-b3d2-410d-96ff-6b576306677b","idx":"56f81f88-6de7-42fa-b867-104f835d1ece"}
{"func_before":"\t\t\t\tif (sdump->X3DDump) {\n\t\t\t\t\tgf_fprintf(sdump->trace, \" value=\\\"\");\n\t\t\t\t} else {\n\t\t\t\t\tgf_fprintf(sdump->trace, \" %s=\\\"\", GetXMTFieldTypeValueName(field.fieldType));\n\t\t\t\t}\n\t\t\t\tfor (i=0; mffield && (i<mffield->count); i++) {\n\t\t\t\t\tif (i) gf_fprintf(sdump->trace, \" \");\n\t\t\t\t\tif (field.fieldType != GF_SG_VRML_MFNODE) {\n\t\t\t\t\t\tgf_sg_vrml_mf_get_item(field.far_ptr, field.fieldType, &slot_ptr, i);\n\t\t\t\t\t\tgf_dump_vrml_sffield(sdump, sf_type, slot_ptr, (mffield->count>1) ? 1 : 0, node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_fprintf(sdump->trace, \"\\\"\/>\\n\");\n\t\t\t}\n\t\t}","target":0,"flaw_line_index":0,"hash":"d5efeb4e-9bcd-4d3e-a09b-dcb34fee2a85","idx":"7d7b8990-74fd-4040-9d31-3a3bc607cfb5"}
{"func_before":"    unsigned int extract_errors = 0;\n#if HAVE_LIBXML2\n    int fd = -1;\n    struct xar_header hdr;\n    fmap_t *map = *ctx->fmap;\n    long length, offset, size, at;\n    int encoding;\n    z_stream strm;\n    char *toc, *tmpname;\n    xmlTextReaderPtr reader = NULL;\n    int a_hash, e_hash;\n    if (rc != Z_OK) {\n        cli_dbgmsg(\"cli_scanxar:inflateEnd error %i \\n\", rc);\n        rc = CL_EFORMAT;\n        goto exit_toc;\n    }\n\n    \/* cli_dbgmsg(\"cli_scanxar: TOC xml:\\n%s\\n\", toc); *\/\n    \/* printf(\"cli_scanxar: TOC xml:\\n%s\\n\", toc); *\/\n    \/* cli_dbgmsg(\"cli_scanxar: TOC end:\\n\"); *\/\n    \/* printf(\"cli_scanxar: TOC end:\\n\"); *\/\n\n        if ((rc = cli_gentempfd(ctx->engine->tmpdir, &tmpname, &fd)) != CL_SUCCESS) {\n            cli_dbgmsg(\"cli_scanxar: Can't generate temporary file.\\n\");\n            goto exit_reader;\n        }\n\n        cli_dbgmsg(\"cli_scanxar: decompress into temp file:\\n%s, size %li,\\n\"\n                   \"from xar heap offset %li length %li\\n\",\n                   tmpname, size, offset, length);\n\n\n        a_hash_ctx = xar_hash_init(a_hash, &a_sc, &a_mc);\n        e_hash_ctx = xar_hash_init(e_hash, &e_sc, &e_mc);\n#define CLI_LZMA_OBUF_SIZE 1024*1024\n#define CLI_LZMA_HDR_SIZE LZMA_PROPS_SIZE+8\n#define CLI_LZMA_IBUF_SIZE CLI_LZMA_OBUF_SIZE>>2 \/* estimated compression ratio 25% *\/\n            {\n                struct CLI_LZMA lz;\n                unsigned long in_remaining = length;\n                unsigned long out_size = 0;\n                unsigned char * buff = __lzma_wrap_alloc(NULL, CLI_LZMA_OBUF_SIZE);\n                int lret;\n                \n                memset(&lz, 0, sizeof(lz));\n                if (buff == NULL) {\n                    cli_dbgmsg(\"cli_scanxar: memory request for lzma decompression buffer fails.\\n\");\n                    rc = CL_EMEM;\n                    goto exit_tmpfile;\n\n                blockp = (void*)fmap_need_off_once(map, at, CLI_LZMA_HDR_SIZE);\n                if (blockp == NULL) {\n                    char errbuff[128];\n                    cli_strerror(errno, errbuff, sizeof(errbuff));\n                    cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno:%s.\\n\",\n                               length, at, errbuff);\n                    rc = CL_EREAD;\n                    __lzma_wrap_free(NULL, buff);\n                    goto exit_tmpfile;\n                }\n\n                    lz.next_in = next_in = (void*)fmap_need_off_once(map, at, lz.avail_in);\n                    if (lz.next_in == NULL) {\n                        char errbuff[128];\n                        cli_strerror(errno, errbuff, sizeof(errbuff));\n                        cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno: %s.\\n\",\n                                   length, at, errbuff);\n                        rc = CL_EREAD;\n                        __lzma_wrap_free(NULL, buff);\n                        cli_LzmaShutdown(&lz);\n                        goto exit_tmpfile;\n                    }\n        case CL_TYPE_BZ:\n        case CL_TYPE_XZ:\n            \/* for uncompressed, bzip2, xz, and unknown, just pull the file, cli_magic_scandesc does the rest *\/\n            do_extract_cksum = 0;\n            {\n                unsigned long write_len;\n                \n                if (ctx->engine->maxfilesize)\n                    write_len = MIN((size_t)(ctx->engine->maxfilesize), (size_t)length);\n                else\n                    write_len = length;\n                    \n                if (!(blockp = (void*)fmap_need_off_once(map, at, length))) {\n                    char errbuff[128];\n                    cli_strerror(errno, errbuff, sizeof(errbuff));\n                    cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno:%s.\\n\",\n                               length, at, errbuff);\n                    rc = CL_EREAD;\n                    goto exit_tmpfile;\n                }\n                \n                if (a_hash_ctx != NULL)\n                    xar_hash_update(a_hash_ctx, blockp, length, a_hash);\n                \n                if (cli_writen(fd, blockp, write_len) < 0) {\n                    cli_dbgmsg(\"cli_scanxar: cli_writen error %li bytes @ %li.\\n\", length, at);\n                    rc = CL_EWRITE;\n                    goto exit_tmpfile;\n                }\n                \/*break;*\/\n            }          \n        }\n\n        if (rc == CL_SUCCESS) {\n            if (a_hash_ctx != NULL) {\n                xar_hash_final(a_hash_ctx, result, a_hash);\n                a_hash_ctx = NULL;\n        rc = CL_SUCCESS;\n#else\n    cli_dbgmsg(\"cli_scanxar: can't scan xar files, need libxml2.\\n\");\n#endif\n    if (cksum_fails + extract_errors != 0) {\n        cli_warnmsg(\"cli_scanxar: %u checksum errors and %u extraction errors, use --debug for more info.\\n\",\n                    cksum_fails, extract_errors);\n    }\n\n    return rc;\n}","target":1,"flaw_line_index":0,"hash":"ca9e9acf-646a-4ef5-b5f1-b0c6fa63cc6c","idx":"ddef2e58-1b13-452d-ad17-20a7116cb028"}
{"func_before":"    unsigned int extract_errors = 0;\n#if HAVE_LIBXML2\n    int fd = -1;\n    struct xar_header hdr;\n    fmap_t *map = *ctx->fmap;\n    size_t length, offset, size, at;\n    int encoding;\n    z_stream strm;\n    char *toc, *tmpname;\n    xmlTextReaderPtr reader = NULL;\n    int a_hash, e_hash;\n        cli_dbgmsg(\"cli_scanxar:inflateEnd error %i \\n\", rc);\n        rc = CL_EFORMAT;\n        goto exit_toc;\n    }\n\n    if (hdr.toc_length_decompressed != strm.total_out) {\n        cli_dbgmsg(\"TOC decompress length %\" PRIu64 \" does not match amount decompressed %lu\\n\",\n                   hdr.toc_length_decompressed, strm.total_out);\n        toc[strm.total_out] = '\\0';\n        hdr.toc_length_decompressed = strm.total_out;\n    }\n\n    \/* cli_dbgmsg(\"cli_scanxar: TOC xml:\\n%s\\n\", toc); *\/\n    \/* printf(\"cli_scanxar: TOC xml:\\n%s\\n\", toc); *\/\n    \/* cli_dbgmsg(\"cli_scanxar: TOC end:\\n\"); *\/\n    \/* printf(\"cli_scanxar: TOC end:\\n\"); *\/\n\n        if ((rc = cli_gentempfd(ctx->engine->tmpdir, &tmpname, &fd)) != CL_SUCCESS) {\n            cli_dbgmsg(\"cli_scanxar: Can't generate temporary file.\\n\");\n            goto exit_reader;\n        }\n\n        cli_dbgmsg(\"cli_scanxar: decompress into temp file:\\n%s, size %zu,\\n\"\n                   \"from xar heap offset %zu length %zu\\n\",\n                   tmpname, size, offset, length);\n\n\n        a_hash_ctx = xar_hash_init(a_hash, &a_sc, &a_mc);\n        e_hash_ctx = xar_hash_init(e_hash, &e_sc, &e_mc);\n#define CLI_LZMA_OBUF_SIZE 1024*1024\n#define CLI_LZMA_HDR_SIZE LZMA_PROPS_SIZE+8\n#define CLI_LZMA_IBUF_SIZE CLI_LZMA_OBUF_SIZE>>2 \/* estimated compression ratio 25% *\/\n            {\n                struct CLI_LZMA lz;\n                unsigned long in_remaining = MIN(length, map->len - at);\n                unsigned long out_size = 0;\n                unsigned char * buff = __lzma_wrap_alloc(NULL, CLI_LZMA_OBUF_SIZE);\n                int lret;\n\n                if (length > in_remaining)\n                    length = in_remaining;\n\n                memset(&lz, 0, sizeof(lz));\n                if (buff == NULL) {\n                    cli_dbgmsg(\"cli_scanxar: memory request for lzma decompression buffer fails.\\n\");\n                    rc = CL_EMEM;\n                    goto exit_tmpfile;\n\n                blockp = (void*)fmap_need_off_once(map, at, CLI_LZMA_HDR_SIZE);\n                if (blockp == NULL) {\n                    char errbuff[128];\n                    cli_strerror(errno, errbuff, sizeof(errbuff));\n                    cli_dbgmsg(\"cli_scanxar: Can't read %i bytes @ %li, errno:%s.\\n\",\n                               CLI_LZMA_HDR_SIZE, at, errbuff);\n                    rc = CL_EREAD;\n                    __lzma_wrap_free(NULL, buff);\n                    goto exit_tmpfile;\n                }\n\n                    lz.next_in = next_in = (void*)fmap_need_off_once(map, at, lz.avail_in);\n                    if (lz.next_in == NULL) {\n                        char errbuff[128];\n                        cli_strerror(errno, errbuff, sizeof(errbuff));\n                        cli_dbgmsg(\"cli_scanxar: Can't read %li bytes @ %li, errno: %s.\\n\",\n                                   lz.avail_in, at, errbuff);\n                        rc = CL_EREAD;\n                        __lzma_wrap_free(NULL, buff);\n                        cli_LzmaShutdown(&lz);\n                        goto exit_tmpfile;\n                    }\n        case CL_TYPE_BZ:\n        case CL_TYPE_XZ:\n            \/* for uncompressed, bzip2, xz, and unknown, just pull the file, cli_magic_scandesc does the rest *\/\n            do_extract_cksum = 0;\n            {\n                size_t writelen = MIN(map->len - at, length);\n\n                if (ctx->engine->maxfilesize)\n                    writelen = MIN((size_t)(ctx->engine->maxfilesize), writelen);\n                    \n                if (!(blockp = (void*)fmap_need_off_once(map, at, writelen))) {\n                    char errbuff[128];\n                    cli_strerror(errno, errbuff, sizeof(errbuff));\n                    cli_dbgmsg(\"cli_scanxar: Can't read %zu bytes @ %zu, errno:%s.\\n\",\n                               writelen, at, errbuff);\n                    rc = CL_EREAD;\n                    goto exit_tmpfile;\n                }\n                \n                if (a_hash_ctx != NULL)\n                    xar_hash_update(a_hash_ctx, blockp, writelen, a_hash);\n                \n                if (cli_writen(fd, blockp, writelen) < 0) {\n                    cli_dbgmsg(\"cli_scanxar: cli_writen error %zu bytes @ %li.\\n\", writelen, at);\n                    rc = CL_EWRITE;\n                    goto exit_tmpfile;\n                }\n                \/*break;*\/\n            }          \n        } \/* end of switch *\/\n\n        if (rc == CL_SUCCESS) {\n            if (a_hash_ctx != NULL) {\n                xar_hash_final(a_hash_ctx, result, a_hash);\n                a_hash_ctx = NULL;\n        rc = CL_SUCCESS;\n#else\n    cli_dbgmsg(\"cli_scanxar: can't scan xar files, need libxml2.\\n\");\n#endif\n    if (cksum_fails + extract_errors != 0) {\n        cli_dbgmsg(\"cli_scanxar: %u checksum errors and %u extraction errors.\\n\",\n                    cksum_fails, extract_errors);\n    }\n\n    return rc;\n}","target":0,"flaw_line_index":0,"hash":"71737ab8-90e5-4b46-ae53-28d996a65462","idx":"5427df9e-c663-4c2f-a866-d2db9668a58c"}
{"func_before":"    type = tss->type();\n    shape = tss->shape();\n    slice = tss->Slices().begin()->second.slice;\n  }\n\n  std::unique_ptr<tensorflow::Tensor> t(new tensorflow::Tensor(type, shape));\n  bool success = false;\n\n#define READER_COPY(dt)                                                  \\\n  case dt:                                                               \\\n    success = CopySliceData(name, slice,                                 \\","target":1,"flaw_line_index":0,"hash":"c42f65dc-8e20-4190-98ca-a4848592678b","idx":"202406a0-30b1-4b0e-ab05-c4f7a56251c2"}
{"func_before":"    type = tss->type();\n    shape = tss->shape();\n    slice = tss->Slices().begin()->second.slice;\n  }\n\n  std::unique_ptr<tensorflow::Tensor> t(new tensorflow::Tensor);\n  Status s = tensorflow::Tensor::BuildTensor(type, shape, t.get());\n  if (!s.ok()) return s;\n  bool success = false;\n\n#define READER_COPY(dt)                                                  \\\n  case dt:                                                               \\\n    success = CopySliceData(name, slice,                                 \\","target":0,"flaw_line_index":0,"hash":"f913b467-24d6-4565-ab8c-a22a36ed2741","idx":"8ad22222-8b66-4c25-bff8-612888d97ac9"}
{"func_before":"\t\t} else {\n\t\t\t\/* case: R = imm\n\t\t\t * remember the value we stored into this reg\n\t\t\t *\/\n\t\t\tregs[insn->dst_reg].type = SCALAR_VALUE;\n\t\t\t__mark_reg_known(regs + insn->dst_reg, insn->imm);\n\t\t}\n\n\t} else if (opcode > BPF_END) {\n\t\tverbose(env, \"invalid BPF_ALU opcode %x\\n\", opcode);\n\t\treturn -EINVAL;","target":1,"flaw_line_index":0,"hash":"43d7e4c1-846f-427d-b064-623d70c7b51b","idx":"9bfec215-624d-4c93-bb3a-e3ec4d2ae93f"}
{"func_before":"\t\t} else {\n\t\t\t\/* case: R = imm\n\t\t\t * remember the value we stored into this reg\n\t\t\t *\/\n\t\t\tregs[insn->dst_reg].type = SCALAR_VALUE;\n\t\t\tif (BPF_CLASS(insn->code) == BPF_ALU64) {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t insn->imm);\n\t\t\t} else {\n\t\t\t\t__mark_reg_known(regs + insn->dst_reg,\n\t\t\t\t\t\t (u32)insn->imm);\n\t\t\t}\n\t\t}\n\n\t} else if (opcode > BPF_END) {\n\t\tverbose(env, \"invalid BPF_ALU opcode %x\\n\", opcode);\n\t\treturn -EINVAL;","target":0,"flaw_line_index":0,"hash":"96a394eb-9c3e-492e-a15f-090ba12e2974","idx":"9056751a-3a99-4898-94c0-42eddfe1ae78"}
{"func_before":"            sprintf(buf, \"Non-statement found: %d %d\",\n                    TYPE(n), NCH(n));\n            Py_FatalError(buf);\n        }\n    }\n    assert(0);\n    return 0;\n}","target":1,"flaw_line_index":0,"hash":"ad631103-e535-496e-975a-f0f4839bebdd","idx":"fa7c9192-c6e3-4100-ab37-faf5af2bc576"}
{"func_before":"            sprintf(buf, \"Non-statement found: %d %d\",\n                    TYPE(n), NCH(n));\n            Py_FatalError(buf);\n        }\n    }\n    abort();\n}","target":0,"flaw_line_index":0,"hash":"d8294e88-79b4-45b8-94af-550c089eda90","idx":"6814be9e-e658-4775-be37-dfd2a22e7778"}
{"func_before":"create_policy_2_svc(cpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name,\n        service_name;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n                 ((prime_arg == NULL) ? \"(null)\" : prime_arg), errmsg,\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","target":1,"flaw_line_index":0,"hash":"eba4402e-a7e4-4b14-8a86-9d6dfcd9bc8f","idx":"ea5900de-6603-42ad-936e-123d5740bee1"}
{"func_before":"create_policy_2_svc(cpol_arg *arg, struct svc_req *rqstp)\n{\n    static generic_ret              ret;\n    char                            *prime_arg;\n    gss_buffer_desc                 client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc                 service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                       minor_stat;\n    kadm5_server_handle_t           handle;\n    const char                      *errmsg = NULL;\n\n    xdr_free(xdr_generic_ret, &ret);\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","target":0,"flaw_line_index":0,"hash":"f7d18d35-b20b-4b82-b7ea-cc6ee76d54e4","idx":"96385df1-2289-4307-b568-1c4ca5421ab0"}
{"func_before":"\t\/* General sanity checks *\/\n\tif (mem->memory_size & (PAGE_SIZE - 1))\n\t\tgoto out;\n\tif (mem->guest_phys_addr & (PAGE_SIZE - 1))\n\t\tgoto out;\n\tif (user_alloc && (mem->userspace_addr & (PAGE_SIZE - 1)))\n\t\tgoto out;\n\tif (mem->slot >= KVM_MEMORY_SLOTS + KVM_PRIVATE_MEM_SLOTS)\n\t\tgoto out;\n\tif (mem->guest_phys_addr + mem->memory_size < mem->guest_phys_addr)\n\t\tgoto out;","target":1,"flaw_line_index":0,"hash":"a5b3809f-5611-4f57-9940-41275530b33a","idx":"00178ed2-2767-4cdb-ac39-9b56ffa675b0"}
{"func_before":"\t\/* General sanity checks *\/\n\tif (mem->memory_size & (PAGE_SIZE - 1))\n\t\tgoto out;\n\tif (mem->guest_phys_addr & (PAGE_SIZE - 1))\n\t\tgoto out;\n\t\/* We can read the guest memory with __xxx_user() later on. *\/\n\tif (user_alloc &&\n\t    ((mem->userspace_addr & (PAGE_SIZE - 1)) ||\n\t     !access_ok(VERIFY_WRITE, mem->userspace_addr, mem->memory_size)))\n\t\tgoto out;\n\tif (mem->slot >= KVM_MEMORY_SLOTS + KVM_PRIVATE_MEM_SLOTS)\n\t\tgoto out;\n\tif (mem->guest_phys_addr + mem->memory_size < mem->guest_phys_addr)\n\t\tgoto out;","target":0,"flaw_line_index":0,"hash":"ee9646fa-f197-4028-a772-2dc7b7a16a9c","idx":"7cff26d8-6db1-48ad-a7a6-040a79617c63"}
{"func_before":"bool ExtractUnixLink30(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,const wchar *LinkName)\n{\n  char Target[NM];\n  if (IsLink(Arc.FileHead.FileAttr))\n  {\n    size_t DataSize=(size_t)Arc.FileHead.PackSize;\n    if (DataSize>ASIZE(Target)-1)\n      return false;\n    if ((size_t)DataIO.UnpRead((byte *)Target,DataSize)!=DataSize)\n      return false;\n    Target[DataSize]=0;\n\n    DataIO.UnpHash.Init(Arc.FileHead.FileHash.Type,1);\n    DataIO.UnpHash.Update(Target,strlen(Target));\n    DataIO.UnpHash.Result(&Arc.FileHead.FileHash);\n\n    \/\/ Return true in case of bad checksum, so link will be processed further\n    \/\/ and extraction routine will report the checksum error.\n    if (!DataIO.UnpHash.Cmp(&Arc.FileHead.FileHash,Arc.FileHead.UseHashKey ? Arc.FileHead.HashKey:NULL))\n      return true;\n\n    wchar TargetW[NM];\n    if (!SafeCharToWide(Target,TargetW,ASIZE(TargetW)))\n      return false;\n    \/\/ Use Arc.FileHead.FileName instead of LinkName, since LinkName\n    \/\/ can include the destination path as a prefix, which can\n    \/\/ confuse IsRelativeSymlinkSafe algorithm.\n    if (!Cmd->AbsoluteLinks && (IsFullPath(TargetW) ||\n        !IsRelativeSymlinkSafe(Cmd,Arc.FileHead.FileName,LinkName,TargetW)))\n      return false;\n    return UnixSymlink(Cmd,Target,LinkName,&Arc.FileHead.mtime,&Arc.FileHead.atime);\n  }\n  return false;\n}","target":1,"flaw_line_index":0,"hash":"796220e7-80b2-442f-b8d0-179587a7a019","idx":"fa011e21-5642-4f8d-a194-c81628865ae6"}
{"func_before":"static bool ExtractUnixLink30(CommandData *Cmd,ComprDataIO &DataIO,Archive &Arc,\n                              const wchar *LinkName,bool &UpLink)\n{\n  char Target[NM];\n  if (IsLink(Arc.FileHead.FileAttr))\n  {\n    size_t DataSize=(size_t)Arc.FileHead.PackSize;\n    if (DataSize>ASIZE(Target)-1)\n      return false;\n    if ((size_t)DataIO.UnpRead((byte *)Target,DataSize)!=DataSize)\n      return false;\n    Target[DataSize]=0;\n\n    DataIO.UnpHash.Init(Arc.FileHead.FileHash.Type,1);\n    DataIO.UnpHash.Update(Target,strlen(Target));\n    DataIO.UnpHash.Result(&Arc.FileHead.FileHash);\n\n    \/\/ Return true in case of bad checksum, so link will be processed further\n    \/\/ and extraction routine will report the checksum error.\n    if (!DataIO.UnpHash.Cmp(&Arc.FileHead.FileHash,Arc.FileHead.UseHashKey ? Arc.FileHead.HashKey:NULL))\n      return true;\n\n    wchar TargetW[NM];\n    if (!SafeCharToWide(Target,TargetW,ASIZE(TargetW)))\n      return false;\n    \/\/ Use Arc.FileHead.FileName instead of LinkName, since LinkName\n    \/\/ can include the destination path as a prefix, which can\n    \/\/ confuse IsRelativeSymlinkSafe algorithm.\n    if (!Cmd->AbsoluteLinks && (IsFullPath(TargetW) ||\n        !IsRelativeSymlinkSafe(Cmd,Arc.FileHead.FileName,LinkName,TargetW)))\n      return false;\n    UpLink=strstr(Target,\"..\")!=NULL;\n    return UnixSymlink(Cmd,Target,LinkName,&Arc.FileHead.mtime,&Arc.FileHead.atime);\n  }\n  return false;\n}","target":0,"flaw_line_index":0,"hash":"a22f3d2e-91f7-4e68-9d32-f0ec85c1fc57","idx":"07ff4b29-3f78-404a-b169-516b57ef4fc1"}
{"func_before":"    if (dc == NULL)\n        goto end;\n\n    \/* Create a fragment that would extend past the max allowable size\n     * for an IPv4 packet. *\/\n    p = BuildTestPacket(1, 8183, 0, 'A', 71);\n    if (p == NULL)\n        goto end;\n\n    \/* We do not expect a packet returned. *\/\n    if (Defrag(NULL, NULL, p, NULL) != NULL)","target":1,"flaw_line_index":0,"hash":"dfc7fbdf-d602-45f8-a601-25d25824a6f5","idx":"a834a355-60e7-4b4f-98ad-d96bda4c83bf"}
{"func_before":"    if (dc == NULL)\n        goto end;\n\n    \/* Create a fragment that would extend past the max allowable size\n     * for an IPv4 packet. *\/\n    p = BuildTestPacket(IPPROTO_ICMP, 1, 8183, 0, 'A', 71);\n    if (p == NULL)\n        goto end;\n\n    \/* We do not expect a packet returned. *\/\n    if (Defrag(NULL, NULL, p, NULL) != NULL)","target":0,"flaw_line_index":0,"hash":"8bdce737-b0f6-4a81-b06f-ff608381bd83","idx":"81724abe-276a-4ed8-bb22-8793f01576b9"}
{"func_before":"static char *get_pid_environ_val(pid_t pid,char *val){\n  char temp[500];\n  int i=0;\n  int foundit=0;\n  FILE *fp;\n\n  sprintf(temp,\"\/proc\/%d\/environ\",pid);\n  fp=fopen(temp,\"r\");\n  if(fp==NULL)\n    return NULL;\n\n  \n  for(;;){\n    temp[i]=fgetc(fp);    \n\n    if(foundit==1 && (temp[i]==0 || temp[i]=='\\0' || temp[i]==EOF)){\n      char *ret;\n      temp[i]=0;","target":1,"flaw_line_index":0,"hash":"fb4d458c-db47-4ac9-b9d2-e599b51920ff","idx":"23a391ca-f211-4f9d-becd-3ecfbb77d5dc"}
{"func_before":"static char *get_pid_environ_val(pid_t pid,char *val){\n  int temp_size = 500;\n  char *temp = malloc(temp_size);\n  \n  int i=0;\n  int foundit=0;\n  FILE *fp;\n\n  sprintf(temp,\"\/proc\/%d\/environ\",pid);\n  if(fp==NULL)\n    return NULL;\n\n  \n  for(;;){\n    \n    if (i >= temp_size) {\n      temp_size *= 2;\n      temp = realloc(temp, temp_size);\n    }\n      \n    temp[i]=fgetc(fp);    \n\n    if(foundit==1 && (temp[i]==0 || temp[i]=='\\0' || temp[i]==EOF)){\n      char *ret;\n      temp[i]=0;","target":0,"flaw_line_index":0,"hash":"f0accd18-a09d-460d-a760-7c657eb0176f","idx":"49c79a78-9784-4089-b390-2d63bc731713"}
{"func_before":"            config->sample_rate = WaveHeader.SampleRate;\n            break;\n        }\n        else {          \/\/ just copy unknown chunks to output file\n            int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;\n            char *buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);","target":1,"flaw_line_index":0,"hash":"38c10cec-7667-459c-90b0-77a168b007f7","idx":"2e54b543-7ebe-45a2-9b48-d3441955f659"}
{"func_before":"            config->sample_rate = WaveHeader.SampleRate;\n            break;\n        }\n        else {          \/\/ just copy unknown chunks to output file\n            int bytes_to_copy = (chunk_header.ckSize + 7) & ~7L;\n            char *buff;\n\n            if (bytes_to_copy < 0 || bytes_to_copy > 4194304) {\n                error_line (\"%s is not a valid .W64 file!\", infilename);\n                return WAVPACK_SOFT_ERROR;\n            }\n\n            buff = malloc (bytes_to_copy);\n\n            if (debug_logging_mode)\n                error_line (\"extra unknown chunk \\\"%c%c%c%c\\\" of %d bytes\",\n                    chunk_header.ckID [0], chunk_header.ckID [1], chunk_header.ckID [2],\n                    chunk_header.ckID [3], chunk_header.ckSize);","target":0,"flaw_line_index":0,"hash":"5c67685b-e408-4b00-9d8b-49073390fb47","idx":"23fe0f94-2ed2-4e9d-9e79-5d0d075e84f1"}
{"func_before":"{\n    \/* Get any literal string. It ends when we hit an un-doubled left\n       brace (which isn't part of a unicode name escape such as\n       \"\\N{EULER CONSTANT}\"), or the end of the string. *\/\n\n    const char *literal_start = *str;\n    const char *literal_end;\n    int in_named_escape = 0;\n    int result = 0;\n\n    assert(*literal == NULL);\n    for (; *str < end; (*str)++) {\n        char ch = **str;\n        if (!in_named_escape && ch == '{' && (*str)-literal_start >= 2 &&\n            *(*str-2) == '\\\\' && *(*str-1) == 'N') {\n            in_named_escape = 1;\n        } else if (in_named_escape && ch == '}') {\n            in_named_escape = 0;\n        } else if (ch == '{' || ch == '}') {\n            \/* Check for doubled braces, but only at the top level. If\n               we checked at every level, then f'{0:{3}}' would fail\n               with the two closing braces. *\/\n            if (recurse_lvl == 0) {\n                if (*str+1 < end && *(*str+1) == ch) {\n                    \/* We're going to tell the caller that the literal ends\n                       here, but that they should continue scanning. But also\n                       skip over the second brace when we resume scanning. *\/\n                    literal_end = *str+1;\n                    *str += 2;\n                    result = 1;\n                    goto done;\n                }\n\n                \/* Where a single '{' is the start of a new expression, a\n                   single '}' is not allowed. *\/\n                if (ch == '}') {\n                    ast_error(c, n, \"f-string: single '}' is not allowed\");\n                    return -1;\n                }\n            }\n            \/* We're either at a '{', which means we're starting another\n               expression; or a '}', which means we're at the end of this\n               f-string (for a nested format_spec). *\/\n            break;\n        }\n    }\n    literal_end = *str;\n    assert(*str <= end);\n    assert(*str == end || **str == '{' || **str == '}');\ndone:\n    if (literal_start != literal_end) {\n        if (raw)\n            *literal = PyUnicode_DecodeUTF8Stateful(literal_start,\n                                                    literal_end-literal_start,\n                                                    NULL, NULL);\n        else\n            *literal = decode_unicode_with_escapes(c, n, literal_start,\n                                                   literal_end-literal_start);\n        if (!*literal)\n            return -1;\n    }\n    return result;\n}","target":1,"flaw_line_index":0,"hash":"a6c921c2-477d-469c-bca3-7d4339e31aa6","idx":"4aed6168-9a27-4b82-aee1-7bae4f843dde"}
{"func_before":"{\n    \/* Get any literal string. It ends when we hit an un-doubled left\n       brace (which isn't part of a unicode name escape such as\n       \"\\N{EULER CONSTANT}\"), or the end of the string. *\/\n\n    const char *s = *str;\n    const char *literal_start = s;\n    int result = 0;\n\n    assert(*literal == NULL);\n    while (s < end) {\n        char ch = *s++;\n        if (!raw && ch == '\\\\' && s < end) {\n            ch = *s++;\n            if (ch == 'N') {\n                if (s < end && *s++ == '{') {\n                    while (s < end && *s++ != '}') {\n                    }\n                    continue;\n                }\n                break;\n            }\n            if (ch == '{' && warn_invalid_escape_sequence(c, n, ch) < 0) {\n                return -1;\n            }\n        }\n        if (ch == '{' || ch == '}') {\n            \/* Check for doubled braces, but only at the top level. If\n               we checked at every level, then f'{0:{3}}' would fail\n               with the two closing braces. *\/\n            if (recurse_lvl == 0) {\n                if (s < end && *s == ch) {\n                    \/* We're going to tell the caller that the literal ends\n                       here, but that they should continue scanning. But also\n                       skip over the second brace when we resume scanning. *\/\n                    *str = s + 1;\n                    result = 1;\n                    goto done;\n                }\n\n                \/* Where a single '{' is the start of a new expression, a\n                   single '}' is not allowed. *\/\n                if (ch == '}') {\n                    *str = s - 1;\n                    ast_error(c, n, \"f-string: single '}' is not allowed\");\n                    return -1;\n                }\n            }\n            \/* We're either at a '{', which means we're starting another\n               expression; or a '}', which means we're at the end of this\n               f-string (for a nested format_spec). *\/\n            s--;\n            break;\n        }\n    }\n    *str = s;\n    assert(s <= end);\n    assert(s == end || *s == '{' || *s == '}');\ndone:\n    if (literal_start != s) {\n        if (raw)\n            *literal = PyUnicode_DecodeUTF8Stateful(literal_start,\n                                                    s - literal_start,\n                                                    NULL, NULL);\n        else\n            *literal = decode_unicode_with_escapes(c, n, literal_start,\n                                                   s - literal_start);\n        if (!*literal)\n            return -1;\n    }\n    return result;\n}","target":0,"flaw_line_index":0,"hash":"0bc5287e-679e-408e-aa32-dda8a094a879","idx":"672a7cb8-ac51-46d7-9929-561eae158688"}
{"func_before":"void luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  incXCcalls(L);\n  if (getCcalls(L) <= CSTACKERR)  \/* possible stack overflow? *\/\n    luaE_freeCI(L);\n  luaD_call(L, func, nResults);\n  decXCcalls(L);\n}","target":1,"flaw_line_index":0,"hash":"768d20d3-d99d-4e82-b2c0-c93efda2303d","idx":"587ec799-1029-42c7-922b-cf535607a5fb"}
{"func_before":"void luaD_callnoyield (lua_State *L, StkId func, int nResults) {\n  incXCcalls(L);\n  if (getCcalls(L) <= CSTACKERR) {  \/* possible C stack overflow? *\/\n    luaE_exitCcall(L);  \/* to compensate decrement in next call *\/\n    luaE_enterCcall(L);  \/* check properly *\/\n  }\n  luaD_call(L, func, nResults);\n  decXCcalls(L);\n}","target":0,"flaw_line_index":0,"hash":"5cc7c5d2-8b87-49ab-ad22-b30dfaff7ddc","idx":"73cda8cd-de0e-4c73-8683-4e871e52abdb"}
{"func_before":"    }\n  }\n\n  \/* Process NATURAL keywords, and ON and USING clauses of joins.\n  *\/\n  if( db->mallocFailed || sqliteProcessJoin(pParse, p) ){\n    return WRC_Abort;\n  }\n\n  \/* For every \"*\" that occurs in the column list, insert the names of\n  ** all columns in all tables.  And for every TABLE.* insert the names","target":1,"flaw_line_index":0,"hash":"3d552067-9fbe-41ef-bdbd-b74b30d23890","idx":"ca21213d-2c1f-48dd-bc3e-f64f2c0ee4db"}
{"func_before":"    }\n  }\n\n  \/* Process NATURAL keywords, and ON and USING clauses of joins.\n  *\/\n  if( pParse->nErr || db->mallocFailed || sqliteProcessJoin(pParse, p) ){\n    return WRC_Abort;\n  }\n\n  \/* For every \"*\" that occurs in the column list, insert the names of\n  ** all columns in all tables.  And for every TABLE.* insert the names","target":0,"flaw_line_index":0,"hash":"d02d7da4-8410-4545-9153-fac8637d5806","idx":"1b89cbfb-bcde-4f71-9a5d-63ca738ed20a"}
{"func_before":"static int http_enable_trace(mk_request_t *request, void *data, const char *input_name, msgpack_packer *mp_pck)\n{\n    char *buf = NULL;\n    size_t buf_size;\n    msgpack_unpacked result;\n    int ret = -1;\n    msgpack_object *key;\n    msgpack_object *val;\n    struct mk_list *props = NULL;\n    struct flb_chunk_trace_limit limit = { 0 };\n    struct flb_input_instance *input_instance;\n    \n\n    if (request->method == MK_METHOD_GET) {\n        ret = enable_trace_input(hs, input_name, \"trace.\", \"stdout\", NULL);\n        if (ret == 0) {\n                msgpack_pack_map(mp_pck, 1);\n                msgpack_pack_str_with_body(mp_pck, \"status\", strlen(\"status\"));\n                msgpack_pack_str_with_body(mp_pck, \"ok\", strlen(\"ok\"));\n                return 200;\n        }\n        else {\n            flb_error(\"unable to enable tracing for %s\", input_name);\n            goto input_error;\n        }\n    }\n\n    msgpack_unpacked_init(&result);\n    }\n\n    rc = msgpack_unpack_next(&result, buf, buf_size, &off);\n    if (rc != MSGPACK_UNPACK_SUCCESS) {\n        ret = 503;\n        flb_error(\"unable to unpack msgpack parameters for %s\", input_name);\n        goto unpack_error;\n    }\n\n    if (result.data.type == MSGPACK_OBJECT_MAP) {\n        for (i = 0; i < result.data.via.map.size; i++) {\n            key = &result.data.via.map.ptr[i].key;\n            val = &result.data.via.map.ptr[i].val;\n            \n            if (key->type != MSGPACK_OBJECT_STR) {\n                ret = 503;\n                flb_error(\"non string key in parameters\");\n                goto parse_error;\n            }\n\n        if (output_name == NULL) {\n            output_name = flb_sds_create(\"stdout\");\n        }\n\n        ret = enable_trace_input(hs, input_name, prefix, output_name, props);\n        if (ret != 0) {\n            flb_error(\"error when enabling tracing\");\n            goto parse_error;\n        }\n\n        if (limit.type != 0) {\n            input_instance = find_input(hs, input_name);\n            if (limit.type == FLB_CHUNK_TRACE_LIMIT_TIME) {\n                flb_chunk_trace_context_set_limit(input_instance->chunk_trace_ctxt, limit.type, limit.seconds);\n            }\n            else if (limit.type == FLB_CHUNK_TRACE_LIMIT_COUNT) {\n                flb_chunk_trace_context_set_limit(input_instance->chunk_trace_ctxt, limit.type, limit.count);\n            }\n        }\n    }\n\n    msgpack_pack_map(mp_pck, 1);\n    msgpack_pack_str_with_body(mp_pck, \"status\", strlen(\"status\"));\n    msgpack_pack_str_with_body(mp_pck, \"ok\", strlen(\"ok\"));\n\n    ret = 200;\nparse_error:\n    if (prefix) flb_sds_destroy(prefix);\n    if (output_name) flb_sds_destroy(output_name);","target":1,"flaw_line_index":0,"hash":"c83b44ae-aacd-40d2-b413-1530496c0f61","idx":"b4f92230-fb3d-419e-8577-d8412d21709b"}
{"func_before":"static int http_enable_trace(mk_request_t *request, void *data,\n                             const char *input_name, ssize_t input_nlen,\n                             msgpack_packer *mp_pck)\n{\n    char *buf = NULL;\n    size_t buf_size;\n    msgpack_unpacked result;\n    int ret = -1;\n    msgpack_object *key;\n    msgpack_object *val;\n    struct mk_list *props = NULL;\n    struct flb_chunk_trace_limit limit = { 0 };\n    struct flb_input_instance *input_instance;\n\n\n    if (request->method == MK_METHOD_GET) {\n        ret = enable_trace_input(hs, input_name, input_nlen, \"trace.\", \"stdout\", NULL);\n        if (ret == 0) {\n                msgpack_pack_map(mp_pck, 1);\n                msgpack_pack_str_with_body(mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n                msgpack_pack_str_with_body(mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n                return 200;\n        }\n        else {\n            flb_error(\"unable to enable tracing for %.*s\", (int)input_nlen, input_name);\n            goto input_error;\n        }\n    }\n\n    msgpack_unpacked_init(&result);\n    }\n\n    rc = msgpack_unpack_next(&result, buf, buf_size, &off);\n    if (rc != MSGPACK_UNPACK_SUCCESS) {\n        ret = 503;\n        flb_error(\"unable to unpack msgpack parameters for %.*s\", (int)input_nlen, input_name);\n        goto unpack_error;\n    }\n\n    if (result.data.type == MSGPACK_OBJECT_MAP) {\n        for (i = 0; i < result.data.via.map.size; i++) {\n            key = &result.data.via.map.ptr[i].key;\n            val = &result.data.via.map.ptr[i].val;\n\n            if (key->type != MSGPACK_OBJECT_STR) {\n                ret = 503;\n                flb_error(\"non string key in parameters\");\n                goto parse_error;\n            }\n\n        if (output_name == NULL) {\n            output_name = flb_sds_create(\"stdout\");\n        }\n\n        ret = enable_trace_input(hs, input_name, input_nlen, prefix, output_name, props);\n        if (ret != 0) {\n            flb_error(\"error when enabling tracing\");\n            goto parse_error;\n        }\n\n        if (limit.type != 0) {\n            input_instance = find_input(hs, input_name, input_nlen);\n            if (limit.type == FLB_CHUNK_TRACE_LIMIT_TIME) {\n                flb_chunk_trace_context_set_limit(input_instance->chunk_trace_ctxt, limit.type, limit.seconds);\n            }\n            else if (limit.type == FLB_CHUNK_TRACE_LIMIT_COUNT) {\n                flb_chunk_trace_context_set_limit(input_instance->chunk_trace_ctxt, limit.type, limit.count);\n            }\n        }\n    }\n\n    msgpack_pack_map(mp_pck, 1);\n    msgpack_pack_str_with_body(mp_pck, HTTP_FIELD_STATUS, HTTP_FIELD_STATUS_LEN);\n    msgpack_pack_str_with_body(mp_pck, HTTP_RESULT_OK, HTTP_RESULT_OK_LEN);\n\n    ret = 200;\nparse_error:\n    if (prefix) flb_sds_destroy(prefix);\n    if (output_name) flb_sds_destroy(output_name);","target":0,"flaw_line_index":0,"hash":"8c34ef1a-0cfb-4c00-bc4a-345f8ddaec68","idx":"83eda6d2-8f82-4f6a-a463-8ee27880ab6d"}
{"func_before":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n\n    switch (op_context.output->type) {\n      case kTfLiteFloat32:\n        TFLiteOperation<kernel_type, float, OpType>(context, node, op_context);\n        break;\n      case kTfLiteUInt8:\n        TFLiteOperation<kernel_type, uint8_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt8:\n        TFLiteOperation<kernel_type, int8_t, OpType>(context, node, op_context);\n        break;\n      case kTfLiteInt32:\n        TFLiteOperation<kernel_type, int32_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt64:\n        TFLiteOperation<kernel_type, int64_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      case kTfLiteInt16:\n        TFLiteOperation<kernel_type, int16_t, OpType>(context, node,\n                                                      op_context);\n        break;\n      default:\n        context->ReportError(context,\n                             \"Type %d is currently not supported by Maximum.\",\n                             op_context.output->type);\n        return kTfLiteError;\n    }\n  return kTfLiteOk;\n}","target":1,"flaw_line_index":0,"hash":"4e66e362-3911-4758-9693-a86ca0b1b3b8","idx":"a13ee033-d166-43e6-bec6-89125e513937"}
{"func_before":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  OpContext op_context(context, node);\n\n  \/\/ If inputs have no element, shortcircuit.\n  if (NumElements(op_context.input1) == 0 ||\n      NumElements(op_context.input2) == 0) {\n    return kTfLiteOk;\n  }\n\n  switch (op_context.output->type) {\n    case kTfLiteFloat32:\n      TFLiteOperation<kernel_type, float, OpType>(context, node, op_context);\n      break;\n    case kTfLiteUInt8:\n      TFLiteOperation<kernel_type, uint8_t, OpType>(context, node, op_context);\n      break;\n    case kTfLiteInt8:\n      TFLiteOperation<kernel_type, int8_t, OpType>(context, node, op_context);\n      break;\n    case kTfLiteInt32:\n      TFLiteOperation<kernel_type, int32_t, OpType>(context, node, op_context);\n      break;\n    case kTfLiteInt64:\n      TFLiteOperation<kernel_type, int64_t, OpType>(context, node, op_context);\n      break;\n    case kTfLiteInt16:\n      TFLiteOperation<kernel_type, int16_t, OpType>(context, node, op_context);\n      break;\n    default:\n      context->ReportError(context,\n                           \"Type %d is currently not supported by Maximum.\",\n                           op_context.output->type);\n      return kTfLiteError;\n  }\n  return kTfLiteOk;\n}","target":0,"flaw_line_index":0,"hash":"32bd4d47-c8b8-4ea0-9f48-91eb636858ce","idx":"78be82ee-a5dc-4d05-8d22-0729729747e2"}
{"func_before":"static int b_unpack (lua_State *L) {\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);\n  size_t ld;\n  const char *data = luaL_checklstring(L, 2, &ld);\n  size_t pos = luaL_optinteger(L, 3, 1) - 1;\n  defaultoptions(&h);\n  lua_settop(L, 2);\n  while (*fmt) {\n    int opt = *fmt++;\n    size_t size = optsize(L, opt, &fmt);\n    pos += gettoalign(pos, &h, opt, size);\n    luaL_argcheck(L, pos+size <= ld, 2, \"data string too short\");\n    luaL_checkstack(L, 1, \"too many results\");\n    switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i':  case 'I': {  \/* integer types *\/\n        int issigned = islower(opt);\n        lua_Number res = getinteger(data+pos, h.endian, issigned, size);\n        lua_pushnumber(L, res);\n        break;\n      }\n      case 'x': {\n        break;\n      }\n      case 'f': {\n        float f;\n        memcpy(&f, data+pos, size);\n        correctbytes((char *)&f, sizeof(f), h.endian);\n        lua_pushnumber(L, f);\n        break;\n      }\n      case 'd': {\n        double d;\n        memcpy(&d, data+pos, size);\n        correctbytes((char *)&d, sizeof(d), h.endian);\n        lua_pushnumber(L, d);\n        break;\n      }\n      case 'c': {\n        if (size == 0) {\n          if (!lua_isnumber(L, -1))\n            luaL_error(L, \"format `c0' needs a previous size\");\n          size = lua_tonumber(L, -1);\n          lua_pop(L, 1);\n          luaL_argcheck(L, pos+size <= ld, 2, \"data string too short\");\n        }\n        lua_pushlstring(L, data+pos, size);\n        break;\n      }\n      case 's': {\n        const char *e = (const char *)memchr(data+pos, '\\0', ld - pos);\n        if (e == NULL)\n          luaL_error(L, \"unfinished string in data\");\n        size = (e - (data+pos)) + 1;\n        lua_pushlstring(L, data+pos, size - 1);\n        break;\n      }\n      default: controloptions(L, opt, &fmt, &h);\n    }\n    pos += size;\n  }\n  lua_pushinteger(L, pos + 1);\n  return lua_gettop(L) - 2;\n}","target":1,"flaw_line_index":0,"hash":"e9773aa7-180f-4845-ad3e-78084579a947","idx":"045d3275-fe08-4e2e-9356-a94b21f16db2"}
{"func_before":"  Header h;\n  const char *fmt = luaL_checkstring(L, 1);\n  size_t ld;\n  const char *data = luaL_checklstring(L, 2, &ld);\n  size_t pos = luaL_optinteger(L, 3, 1) - 1;\n  int n = 0;  \/* number of results *\/\n  defaultoptions(&h);\n  while (*fmt) {\n    int opt = *fmt++;\n    size_t size = optsize(L, opt, &fmt);\n    pos += gettoalign(pos, &h, opt, size);\n    luaL_argcheck(L, pos+size <= ld, 2, \"data string too short\");\n    \/* stack space for item + next position *\/\n    luaL_checkstack(L, 2, \"too many results\");\n    switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i':  case 'I': {  \/* integer types *\/\n        int issigned = islower(opt);\n        lua_Number res = getinteger(data+pos, h.endian, issigned, size);\n        lua_pushnumber(L, res); n++;\n        break;\n      }\n      case 'x': {\n        break;\n      }\n      case 'f': {\n        float f;\n        memcpy(&f, data+pos, size);\n        correctbytes((char *)&f, sizeof(f), h.endian);\n        lua_pushnumber(L, f); n++;\n        break;\n      }\n      case 'd': {\n        double d;\n        memcpy(&d, data+pos, size);\n        correctbytes((char *)&d, sizeof(d), h.endian);\n        lua_pushnumber(L, d); n++;\n        break;\n      }\n      case 'c': {\n        if (size == 0) {\n          if (n == 0 || !lua_isnumber(L, -1))\n            luaL_error(L, \"format 'c0' needs a previous size\");\n          size = lua_tonumber(L, -1);\n          lua_pop(L, 1); n--;\n          luaL_argcheck(L, size <= ld && pos <= ld - size,\n                           2, \"data string too short\");\n        }\n        lua_pushlstring(L, data+pos, size); n++;\n        break;\n      }\n      case 's': {\n        const char *e = (const char *)memchr(data+pos, '\\0', ld - pos);\n        if (e == NULL)\n          luaL_error(L, \"unfinished string in data\");\n        size = (e - (data+pos)) + 1;\n        lua_pushlstring(L, data+pos, size - 1); n++;\n        break;\n      }\n      default: controloptions(L, opt, &fmt, &h);\n    }\n    pos += size;\n  }\n  lua_pushinteger(L, pos + 1);  \/* next position *\/\n  return n + 1;\n}","target":0,"flaw_line_index":0,"hash":"38372d00-2e75-4956-94b4-74aa65a192a8","idx":"e3d4186e-d833-46cb-b95b-9671c2f31079"}
{"func_before":"\tif ((SF_CONTAINER (sfinfo->format)) == SF_FORMAT_SD2)\n\t{\tsf_errno = SFE_SD2_FD_DISALLOWED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tif ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;","target":1,"flaw_line_index":0,"hash":"12f8f886-f770-40b1-815f-00ff896e0cbe","idx":"fd839fc4-99dc-4fe5-ac1d-9c042c218ce1"}
{"func_before":"\tif ((SF_CONTAINER (sfinfo->format)) == SF_FORMAT_SD2)\n\t{\tsf_errno = SFE_SD2_FD_DISALLOWED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tif ((psf = psf_allocate ()) == NULL)\n\t{\tsf_errno = SFE_MALLOC_FAILED ;\n\t\treturn\tNULL ;\n\t\t} ;\n\n\tpsf_init_files (psf) ;","target":0,"flaw_line_index":0,"hash":"5e3730d5-0e46-4d6a-8f6d-a0e4b6ff8fcb","idx":"32a0a013-e33e-4a91-802f-9319edd69a26"}
{"func_before":"static entity_table_opt determine_entity_table(int all, int doctype)\n{\n\tentity_table_opt retval = {NULL};\n\n\tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n\t\n\tif (all) {\n\t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n\t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n\t} else {\n\t\tretval.table = (doctype == ENT_HTML_DOC_HTML401) ?","target":1,"flaw_line_index":0,"hash":"a7e6a976-76ec-4b01-932d-52bebcafb242","idx":"e6b50516-b86f-4043-938e-131c77c5ec74"}
{"func_before":"static entity_table_opt determine_entity_table(int all, int doctype)\n{\n\tentity_table_opt retval = {NULL};\n\n\tassert(!(doctype == ENT_HTML_DOC_XML1 && all));\n\n\tif (all) {\n\t\tretval.ms_table = (doctype == ENT_HTML_DOC_HTML5) ?\n\t\t\tentity_ms_table_html5 : entity_ms_table_html4;\n\t} else {\n\t\tretval.table = (doctype == ENT_HTML_DOC_HTML401) ?","target":0,"flaw_line_index":0,"hash":"9dca7010-7424-4f23-a56e-d244733197b3","idx":"0db27990-bf2d-46e5-bf9a-57f040ff44e8"}
{"func_before":"\t\t\t\t\t\t attr, nfc_sdp_genl_policy,\n\t\t\t\t\t\t info->extack);\n\n\t\tif (rc != 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (!sdp_attrs[NFC_SDP_ATTR_URI])\n\t\t\tcontinue;\n\n\t\ttid = local->sdreq_next_tid++;\n\n\t\tsdreq = nfc_llcp_build_sdreq_tlv(tid, uri, uri_len);\n\t\tif (sdreq == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\n\t\ttlvs_len += sdreq->tlv_len;\n\n\t\thlist_add_head(&sdreq->node, &sdreq_list);\n\t}\n\n\tif (hlist_empty(&sdreq_list)) {\n\t\trc = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\trc = nfc_llcp_send_snl_sdreq(local, &sdreq_list, tlvs_len);\nexit:\n\tdevice_unlock(&dev->dev);\n\n\tnfc_put_device(dev);\n","target":1,"flaw_line_index":0,"hash":"ea110264-674c-47f8-9311-ebd3799d21e5","idx":"f31a8b55-1fd1-4eb2-b4aa-01701314b551"}
{"func_before":"\t\t\t\t\t\t attr, nfc_sdp_genl_policy,\n\t\t\t\t\t\t info->extack);\n\n\t\tif (rc != 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto put_local;\n\t\t}\n\n\t\tif (!sdp_attrs[NFC_SDP_ATTR_URI])\n\t\t\tcontinue;\n\n\t\ttid = local->sdreq_next_tid++;\n\n\t\tsdreq = nfc_llcp_build_sdreq_tlv(tid, uri, uri_len);\n\t\tif (sdreq == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto put_local;\n\t\t}\n\n\t\ttlvs_len += sdreq->tlv_len;\n\n\t\thlist_add_head(&sdreq->node, &sdreq_list);\n\t}\n\n\tif (hlist_empty(&sdreq_list)) {\n\t\trc = -EINVAL;\n\t\tgoto put_local;\n\t}\n\n\trc = nfc_llcp_send_snl_sdreq(local, &sdreq_list, tlvs_len);\n\nput_local:\n\tnfc_llcp_local_put(local);\n\nexit:\n\tdevice_unlock(&dev->dev);\n\n\tnfc_put_device(dev);\n","target":0,"flaw_line_index":0,"hash":"10f373ed-d9a7-4e1e-8868-aa49d3dbbf78","idx":"3518e382-744c-4f50-b1c8-284f0ff2bf5a"}
{"func_before":"TfLiteStatus LogSoftmaxPrepare(TfLiteContext* context, TfLiteNode* node) {\n  LogSoftmaxOpData* data = reinterpret_cast<LogSoftmaxOpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    TF_LITE_ENSURE_EQ(context, output->params.scale, 16.0 \/ 256);\n    static const double kBeta = 1.0;","target":1,"flaw_line_index":0,"hash":"5974cd65-32c5-4d8d-8bc7-45b9af790a1f","idx":"44813f17-3dc3-4a9f-8f92-d86ec7007d30"}
{"func_before":"TfLiteStatus LogSoftmaxPrepare(TfLiteContext* context, TfLiteNode* node) {\n  LogSoftmaxOpData* data = reinterpret_cast<LogSoftmaxOpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n    TF_LITE_ENSURE_EQ(context, output->params.scale, 16.0 \/ 256);\n    static const double kBeta = 1.0;","target":0,"flaw_line_index":0,"hash":"549995b6-d819-44a7-b272-73e32b4f4b4f","idx":"846b2b54-15a6-4c42-af01-eeb23137eaed"}
{"func_before":"\tif (max_blocks < lblk)\n\t\tmax_blocks = 0;\n\telse\n\t\tmax_blocks -= lblk;\n\n\tflags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT |\n\t\tEXT4_GET_BLOCKS_CONVERT_UNWRITTEN |\n\t\tEXT4_EX_NOCACHE;\n\tif (mode & FALLOC_FL_KEEP_SIZE)\n\t\tflags |= EXT4_GET_BLOCKS_KEEP_SIZE;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t\/*\n\t * Indirect files do not support unwritten extnets\n\t *\/\n\t     offset + len > i_size_read(inode)) {\n\t\tnew_size = offset + len;\n\t\tret = inode_newsize_ok(inode, new_size);\n\t\tif (ret)\n\t\t\tgoto out_mutex;\n\t\t\/*\n\t\t * If we have a partial block after EOF we have to allocate\n\t\t * the entire block.\n\t\t *\/\n\t\tif (partial_end)\n\t\t\tmax_blocks += 1;\n\t}\n\n\tif (max_blocks > 0) {\n\n\t\t\/* Now release the pages and zero block aligned part of pages*\/\n\t\ttruncate_pagecache_range(inode, start, end - 1);\n\t\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n","target":1,"flaw_line_index":0,"hash":"54009f65-22d5-4fe6-9260-954563cd4375","idx":"baa3da71-40d4-41fb-8797-3b443dc873f3"}
{"func_before":"\tmax_blocks = (end >> blkbits);\n\tif (max_blocks < lblk)\n\t\tmax_blocks = 0;\n\telse\n\t\tmax_blocks -= lblk;\n\n\tmutex_lock(&inode->i_mutex);\n\n\t\/*\n\t * Indirect files do not support unwritten extnets\n\t *\/\n\tif (!(mode & FALLOC_FL_KEEP_SIZE) &&\n\t     offset + len > i_size_read(inode)) {\n\t\tnew_size = offset + len;\n\t\tret = inode_newsize_ok(inode, new_size);\n\t\tif (ret)\n\t\t\tgoto out_mutex;\n\t}\n\n\tflags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT;\n\tif (mode & FALLOC_FL_KEEP_SIZE)\n\t\tflags |= EXT4_GET_BLOCKS_KEEP_SIZE;\n\n\t\/* Preallocate the range including the unaligned edges *\/\n\tif (partial_begin || partial_end) {\n\t\tret = ext4_alloc_file_blocks(file,\n\t\t\t\tround_down(offset, 1 << blkbits) >> blkbits,\n\t\t\t\t(round_up((offset + len), 1 << blkbits) -\n\t\t\t\t round_down(offset, 1 << blkbits)) >> blkbits,\n\t\t\t\tnew_size, flags, mode);\n\t\tif (ret)\n\t\t\tgoto out_mutex;\n\n\t}\n\n\t\/* Zero range excluding the unaligned edges *\/\n\tif (max_blocks > 0) {\n\t\tflags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |\n\t\t\t  EXT4_EX_NOCACHE);\n\n\t\t\/* Now release the pages and zero block aligned part of pages*\/\n\t\ttruncate_pagecache_range(inode, start, end - 1);\n\t\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n","target":0,"flaw_line_index":0,"hash":"f2c3a1c0-356a-4600-9125-711354f36747","idx":"56178afb-1bd0-411a-a5ed-881a050f032d"}
{"func_before":"\n\tget_trans_bufname(wp->w_buffer);\n\tp = NameBuff;\n\tlen = (int)STRLEN(p);\n\n\tif (bt_help(wp->w_buffer)\n#ifdef FEAT_QUICKFIX\n\t\t|| wp->w_p_pvw\n#endif\n\t\t|| bufIsChanged(wp->w_buffer)\n\t\t|| wp->w_buffer->b_p_ro)\n\t    *(p + len++) = ' ';\n\tif (bt_help(wp->w_buffer))\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Help]\"));\n\t    len += (int)STRLEN(p + len);","target":1,"flaw_line_index":0,"hash":"3a3ac711-00a9-404c-9341-e5be0b2e012e","idx":"ffe13865-adc4-44d6-90ea-59fe8fa62ac4"}
{"func_before":"\n\tget_trans_bufname(wp->w_buffer);\n\tp = NameBuff;\n\tlen = (int)STRLEN(p);\n\n\tif ((bt_help(wp->w_buffer)\n#ifdef FEAT_QUICKFIX\n\t\t    || wp->w_p_pvw\n#endif\n\t\t    || bufIsChanged(wp->w_buffer)\n\t\t    || wp->w_buffer->b_p_ro)\n\t\t&& len < MAXPATHL - 1)\n\t    *(p + len++) = ' ';\n\tif (bt_help(wp->w_buffer))\n\t{\n\t    vim_snprintf((char *)p + len, MAXPATHL - len, \"%s\", _(\"[Help]\"));\n\t    len += (int)STRLEN(p + len);","target":0,"flaw_line_index":0,"hash":"fa001599-d654-4fe5-ba03-cb0de05495e2","idx":"105e3d56-dbca-4f95-814b-0b9fcd509e1b"}
{"func_before":"void bn_rsh(bn_t c, const bn_t a, int bits) {\n\tint digits = 0;\n\n\tbn_copy(c, a);\n\n\tif (bits <= 0) {\n\t\treturn;\n\t}\n\n\tRLC_RIP(bits, digits, bits);\n\n\tif (digits > 0) {\n\t\tdv_rshd(c->dp, a->dp, a->used, digits);\n\t}\n\tc->used = a->used - digits;\n\tc->sign = a->sign;\n\n\tif (c->used > 0 && bits > 0) {\n\t\tif (digits == 0 && c != a) {\n\t\t\tbn_rshb_low(c->dp, a->dp + digits, a->used - digits, bits);","target":1,"flaw_line_index":0,"hash":"35451723-af93-4902-ad65-882708f8f4d8","idx":"2e275dd9-0312-4e70-bced-24fb12fc75fc"}
{"func_before":"void bn_rsh(bn_t c, const bn_t a, unsigned int bits) {\n\tint digits = 0;\n\n\tbn_copy(c, a);\n\n\tRLC_RIP(bits, digits, bits);\n\n\tif (digits > 0) {\n\t\tdv_rshd(c->dp, a->dp, a->used, digits);\n\t}\n\n\tif (a->used > digits) {\n\t\tc->used = a->used - digits;\n\t} else {\n\t\tc->used = 0;\n\t}\n\tc->sign = a->sign;\n\n\tif (c->used > 0 && bits > 0) {\n\t\tif (digits == 0 && c != a) {\n\t\t\tbn_rshb_low(c->dp, a->dp + digits, a->used - digits, bits);","target":0,"flaw_line_index":0,"hash":"da4ce029-5c04-4f26-bd81-f8c789a8460f","idx":"afbd7673-22e9-4dbb-b975-7999c99f2925"}
{"func_before":"TfLiteStatus NotEqualEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  bool requires_broadcast = !HaveSameShapes(input1, input2);\n  switch (input1->type) {\n    case kTfLiteBool:\n      Comparison<bool, reference_ops::NotEqualFn>(input1, input2, output,\n                                                  requires_broadcast);","target":1,"flaw_line_index":0,"hash":"6055be01-b548-4a43-862c-caf829dae1b8","idx":"102f4146-d0c5-4493-be4e-9d701a9387dc"}
{"func_before":"TfLiteStatus NotEqualEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  bool requires_broadcast = !HaveSameShapes(input1, input2);\n  switch (input1->type) {\n    case kTfLiteBool:\n      Comparison<bool, reference_ops::NotEqualFn>(input1, input2, output,\n                                                  requires_broadcast);","target":0,"flaw_line_index":0,"hash":"5bd0b56b-a299-4fe5-a0cd-f3e129654b25","idx":"04869da7-bf9d-4047-a8f9-ef5daefca79b"}
{"func_before":"static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tint ret;\n\n\tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n\t\t\t      indx, data, size, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\treturn ret;\n}","target":1,"flaw_line_index":0,"hash":"1267c5df-dd05-422b-b5f8-55adfcd8323a","idx":"b4a21ffb-87af-4ea7-84c0-a3577b3f032c"}
{"func_before":"static int get_registers(pegasus_t *pegasus, __u16 indx, __u16 size, void *data)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmalloc(size, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(pegasus->usb, usb_rcvctrlpipe(pegasus->usb, 0),\n\t\t\t      PEGASUS_REQ_GET_REGS, PEGASUS_REQT_READ, 0,\n\t\t\t      indx, buf, size, 1000);\n\tif (ret < 0)\n\t\tnetif_dbg(pegasus, drv, pegasus->net,\n\t\t\t  \"%s returned %d\\n\", __func__, ret);\n\telse if (ret <= size)\n\t\tmemcpy(data, buf, ret);\n\tkfree(buf);\n\treturn ret;\n}","target":0,"flaw_line_index":0,"hash":"e889c9c3-d35b-496d-a95e-66cea9c5717e","idx":"728b85f9-1d67-4392-88aa-1b78eacf08c4"}
{"func_before":"ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n\t      const struct isakmp_gen *ext, u_int item_len,\n\t      const u_char *ep, uint32_t phase, uint32_t doi0 _U_,\n\t      uint32_t proto0 _U_, int depth)\n{\n\tconst struct ikev1_pl_n *p;\n\tstruct ikev1_pl_n n;\n\tconst u_char *cp;\n\tconst u_char *ep2;\n\n\tcp = (const u_char *)(p + 1) + n.spi_size;\n\tep2 = (const u_char *)p + item_len;\n\n\tif (cp < ep) {\n\t\tND_PRINT((ndo,\" orig=(\"));\n\t\tswitch (ntohs(n.type)) {\n\t\tcase IPSECDOI_NTYPE_RESPONDER_LIFETIME:\n\t\t    {\n\t\t\tconst struct attrmap *map = oakley_t_map;\n\t\t\tsize_t nmap = sizeof(oakley_t_map)\/sizeof(oakley_t_map[0]);\n\t\t\twhile (cp < ep && cp < ep2) {\n\t\t\t\tcp = ikev1_attrmap_print(ndo, cp,\n\t\t\t\t\t(ep < ep2) ? ep : ep2, map, nmap);\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_NTYPE_REPLAY_STATUS:\n\t\t\tND_PRINT((ndo,\"replay detection %sabled\",\n\t\t\t\t  EXTRACT_32BITS(cp) ? \"en\" : \"dis\"));\n\t\t\tbreak;\n\t\tcase ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN:\n\t\t\tif (ikev1_sub_print(ndo, ISAKMP_NPTYPE_SA,\n\t\t\t\t\t    (const struct isakmp_gen *)cp, ep, phase, doi, proto,\n\t\t\t\t\t    depth) == NULL)\n\t\t\t\treturn NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t\/* NULL is dummy *\/\n\t\t\tisakmp_print(ndo, cp,\n\t\t\t\t     item_len - sizeof(*p) - n.spi_size,\n\t\t\t\t     NULL);\n\t\t}\n\t\tND_PRINT((ndo,\")\"));\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_N)));\n\treturn NULL;","target":1,"flaw_line_index":0,"hash":"436bc549-8dc6-4f85-8a79-2320e025e57f","idx":"1d7b6b15-466a-4d54-8838-7f2eeb34ffb0"}
{"func_before":"ikev1_n_print(netdissect_options *ndo, u_char tpay _U_,\n\t      const struct isakmp_gen *ext, u_int item_len,\n\t      const u_char *ep, uint32_t phase _U_, uint32_t doi0 _U_,\n\t      uint32_t proto0 _U_, int depth _U_)\n{\n\tconst struct ikev1_pl_n *p;\n\tstruct ikev1_pl_n n;\n\tconst u_char *cp;\n\tconst u_char *ep2;\n\t}\n\n\tcp = (const u_char *)(p + 1) + n.spi_size;\n\tep2 = (const u_char *)p + item_len;\n\n\tif (cp < ep) {\n\t\tswitch (ntohs(n.type)) {\n\t\tcase IPSECDOI_NTYPE_RESPONDER_LIFETIME:\n\t\t    {\n\t\t\tconst struct attrmap *map = oakley_t_map;\n\t\t\tsize_t nmap = sizeof(oakley_t_map)\/sizeof(oakley_t_map[0]);\n\t\t\tND_PRINT((ndo,\" attrs=(\"));\n\t\t\twhile (cp < ep && cp < ep2) {\n\t\t\t\tcp = ikev1_attrmap_print(ndo, cp,\n\t\t\t\t\t(ep < ep2) ? ep : ep2, map, nmap);\n\t\t\t}\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tbreak;\n\t\t    }\n\t\tcase IPSECDOI_NTYPE_REPLAY_STATUS:\n\t\t\tND_PRINT((ndo,\" status=(\"));\n\t\t\tND_PRINT((ndo,\"replay detection %sabled\",\n\t\t\t\t  EXTRACT_32BITS(cp) ? \"en\" : \"dis\"));\n\t\t\tND_PRINT((ndo,\")\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t\/*\n\t\t\t * XXX - fill in more types here; see, for example,\n\t\t\t * draft-ietf-ipsec-notifymsg-04.\n\t\t\t *\/\n\t\t\tif (ndo->ndo_vflag > 3) {\n\t\t\t\tND_PRINT((ndo,\" data=(\"));\n\t\t\t\tif (!rawprint(ndo, (const uint8_t *)(cp), ep - cp))\n\t\t\t\t\tgoto trunc;\n\t\t\t\tND_PRINT((ndo,\")\"));\n\t\t\t} else {\n\t\t\t\tif (!ike_show_somedata(ndo, cp, ep))\n\t\t\t\t\tgoto trunc;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (const u_char *)ext + item_len;\ntrunc:\n\tND_PRINT((ndo,\" [|%s]\", NPSTR(ISAKMP_NPTYPE_N)));\n\treturn NULL;","target":0,"flaw_line_index":0,"hash":"5225ab5a-eeaa-4554-b684-4d62543868ce","idx":"530d6def-0430-4ffe-bcc1-5f2eeec5186f"}
{"func_before":"\tdata_size = section->data_size;\n\n\tpmt->program->pcr_pid = ((data[0] & 0x1f) << 8) | data[1];\n\n\tinfo_length = ((data[2]&0xf)<<8) | data[3];\n\tif (info_length != 0) {\n\t\t\/* ...Read Descriptors ... *\/\n\t\tu8 tag, len;\n\t\tu32 first_loop_len = 0;\n\t\ttag = data[4];\n\t\tlen = data[5];\n\t\twhile (info_length > first_loop_len) {\n\t\t\tif (tag == GF_M2TS_MPEG4_IOD_DESCRIPTOR) {\n\t\t\t\tu32 size;\n\t\t\t\tGF_BitStream *iod_bs;\n\t\t\t\tiod_bs = gf_bs_new((char *)data+8, len-2, GF_BITSTREAM_READ);\n\t\t\t\tif (pmt->program->pmt_iod) gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);\n\t\t\t\te = gf_odf_parse_descriptor(iod_bs , (GF_Descriptor **) &pmt->program->pmt_iod, &size);\n\t\t\t\tgf_bs_del(iod_bs );\n\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t\/*remember program number for service\/program selection*\/\n\t\t\t\t\tif (pmt->program->pmt_iod) pmt->program->pmt_iod->ServiceID = pmt->program->number;\n\t\t\t\t\t\/*if empty IOD (freebox case), discard it and use dynamic declaration of object*\/\n\t\t\t\t\tif (!gf_list_count(pmt->program->pmt_iod->ESDescriptors)) {\n\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);\n\t\t\t\t\t\tpmt->program->pmt_iod = NULL;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (tag == GF_M2TS_METADATA_POINTER_DESCRIPTOR) {\n\t\t\t\tGF_BitStream *metadatapd_bs;\n\t\t\t\tGF_M2TS_MetadataPointerDescriptor *metapd;\n\t\t\t\tmetadatapd_bs = gf_bs_new((char *)data+6, len, GF_BITSTREAM_READ);","target":1,"flaw_line_index":0,"hash":"6df7d476-ca7d-41a8-9d4b-449d2e782c4a","idx":"786e4f1f-0a0a-4d2e-a4ef-1b505fcbd61b"}
{"func_before":"\tdata_size = section->data_size;\n\n\tpmt->program->pcr_pid = ((data[0] & 0x1f) << 8) | data[1];\n\n\tinfo_length = ((data[2]&0xf)<<8) | data[3];\n\tif (info_length + 4 > data_size) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Broken PMT first loop, %d bytes avail but first loop size %d\\n\", data_size, info_length));\n\t\treturn;\n\t} else if (info_length != 0) {\n\t\t\/* ...Read Descriptors ... *\/\n\t\tu8 tag, len;\n\t\tu32 first_loop_len = 0;\n\t\ttag = data[4];\n\t\tlen = data[5];\n\t\twhile (info_length > first_loop_len) {\n\t\t\tif (tag == GF_M2TS_MPEG4_IOD_DESCRIPTOR) {\n\t\t\t\tif ((len>2) && (len - 2 <= info_length)) {\n\t\t\t\t\tu32 size;\n\t\t\t\t\tGF_BitStream *iod_bs;\n\t\t\t\t\tiod_bs = gf_bs_new((char *)data+8, len-2, GF_BITSTREAM_READ);\n\t\t\t\t\tif (pmt->program->pmt_iod) gf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);\n\t\t\t\t\te = gf_odf_parse_descriptor(iod_bs , (GF_Descriptor **) &pmt->program->pmt_iod, &size);\n\t\t\t\t\tgf_bs_del(iod_bs );\n\t\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t\t\/*remember program number for service\/program selection*\/\n\t\t\t\t\t\tif (pmt->program->pmt_iod) pmt->program->pmt_iod->ServiceID = pmt->program->number;\n\t\t\t\t\t\t\/*if empty IOD (freebox case), discard it and use dynamic declaration of object*\/\n\t\t\t\t\t\tif (!gf_list_count(pmt->program->pmt_iod->ESDescriptors)) {\n\t\t\t\t\t\t\tgf_odf_desc_del((GF_Descriptor *)pmt->program->pmt_iod);\n\t\t\t\t\t\t\tpmt->program->pmt_iod = NULL;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"Broken IOD! len %d less than 2 bytes to declare IOD\\n\", len));\n\t\t\t\t}\n\t\t\t} else if (tag == GF_M2TS_METADATA_POINTER_DESCRIPTOR) {\n\t\t\t\tGF_BitStream *metadatapd_bs;\n\t\t\t\tGF_M2TS_MetadataPointerDescriptor *metapd;\n\t\t\t\tmetadatapd_bs = gf_bs_new((char *)data+6, len, GF_BITSTREAM_READ);","target":0,"flaw_line_index":0,"hash":"09db6574-08d9-43bd-bb70-33b38a51bd05","idx":"e94a1d81-c6ec-400a-93d3-9afb81d52924"}
{"func_before":"    auto zero = xla::Zero(ctx->builder(), dtype);\n    auto one = xla::One(ctx->builder(), dtype);\n    StatusOr<xla::Shape> input_shape_or = ctx->builder()->GetShape(input);\n    OP_REQUIRES_OK(ctx, input_shape_or.status());\n    auto input_shape = input_shape_or.value();\n    auto size = input_shape.dimensions(0);\n\n    if (!size) {\n      output = xla::Broadcast(zero, {output_size});\n      ctx->SetOutput(0, output);\n      return;\n    }\n    auto rank = input_shape.rank();\n\n    OP_REQUIRES(ctx, rank <= 2,\n                errors::InvalidArgument(\n                    \"Shape must be at most rank 2 but is rank \", rank));\n\n    xla::XlaOp weights = ctx->Input(2);\n    StatusOr<xla::Shape> weights_shape_or = ctx->builder()->GetShape(weights);\n    OP_REQUIRES_OK(ctx, weights_shape_or.status());\n\n    auto weights_shape = weights_shape_or.value();\n    OP_REQUIRES(ctx,\n                xla::ShapeUtil::CompatibleIgnoringElementType(weights_shape,\n                errors::InvalidArgument(\n                    \"`weights` must be the same shape as `arr` or a length-0 \"\n                    \"`Tensor`, in which case it acts as all weights equal to \"\n                    \"1. Received \",\n                    weights_shape.DebugString()));\n\n    auto weights_size = weights_shape.dimensions(0);\n    bool has_weights = false;\n    if (weights_size) {\n      has_weights = true;\n    }\n    xla::Shape output_shape = xla::ShapeUtil::MakeShape(dtype, {output_size});\n    xla::ScatterDimensionNumbers scatter_dnums;\n    scatter_dnums.set_index_vector_dim(1);\n    scatter_dnums.add_inserted_window_dims(0);\n    scatter_dnums.add_scatter_dims_to_operand_dims(0);","target":1,"flaw_line_index":0,"hash":"61e87187-081a-47aa-8f89-8e241990d9ab","idx":"f5b46d9d-851a-469c-b722-d49e8de5269b"}
{"func_before":"    xla::PrimitiveType dtype = ctx->InputXlaType(\"weights\");\n    auto zero = xla::Zero(ctx->builder(), dtype);\n    auto one = xla::One(ctx->builder(), dtype);\n    StatusOr<xla::Shape> input_shape_or = ctx->builder()->GetShape(input);\n    OP_REQUIRES_OK(ctx, input_shape_or.status());\n    auto input_shape = input_shape_or.value();\n\n    auto rank = input_shape.rank();\n\n    OP_REQUIRES(ctx, rank <= 2,\n                errors::InvalidArgument(\n                    \"Shape must be at most rank 2 but is rank \", rank));\n    xla::XlaOp weights = ctx->Input(2);\n    StatusOr<xla::Shape> weights_shape_or = ctx->builder()->GetShape(weights);\n\n    OP_REQUIRES_OK(ctx, weights_shape_or.status());\n\n    auto weights_shape = weights_shape_or.value();\n    OP_REQUIRES(ctx,\n                xla::ShapeUtil::CompatibleIgnoringElementType(weights_shape,\n                    \"`weights` must be the same shape as `arr` or a length-0 \"\n                    \"`Tensor`, in which case it acts as all weights equal to \"\n                    \"1. Received \",\n                    weights_shape.DebugString()));\n\n    auto size = input_shape.dimensions(0);\n\n    if (!size) {\n      output = xla::Broadcast(zero, {output_size});\n      ctx->SetOutput(0, output);\n      return;\n    }\n\n    auto weights_size = weights_shape.dimensions(0);\n    bool has_weights = false;\n    if (weights_size) {\n      has_weights = true;\n    }\n\n    xla::Shape output_shape = xla::ShapeUtil::MakeShape(dtype, {output_size});\n    xla::ScatterDimensionNumbers scatter_dnums;\n    scatter_dnums.set_index_vector_dim(1);\n    scatter_dnums.add_inserted_window_dims(0);\n    scatter_dnums.add_scatter_dims_to_operand_dims(0);","target":0,"flaw_line_index":0,"hash":"7ae304c8-7dc7-46da-b596-654378905ff1","idx":"1cd303ac-c3c4-49d7-90be-bfd2060435f9"}
{"func_before":"sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n\tconst char *name_1, *name_2;\n\tgchar *key_1, *key_2;\n\tgboolean sort_last_1, sort_last_2;\n\tint compare;\n\n\tname_1 = * (const char **) a;\n\tname_2 = * (const char **) b;\n\n\t#define SORT_LAST_CHAR1 '.'\n\t#define SORT_LAST_CHAR2 '#'\n\n\tsort_last_1 = name_1[0] == SORT_LAST_CHAR1 || name_1[0] == SORT_LAST_CHAR2;\n\tsort_last_2 = name_2[0] == SORT_LAST_CHAR1 || name_2[0] == SORT_LAST_CHAR2;\n\n\t#undef SORT_LAST_CHAR1\n\t#undef SORT_LAST_CHAR2\n\n\tif (sort_last_1 && !sort_last_2)\n\t{\n\t\tcompare = +1;\n\t}\n\telse if (!sort_last_1 && sort_last_2)\n\t{\n\t\tcompare = -1;\n\t} \n\telse\n\t{\n\t\tkey_1 = g_utf8_collate_key_for_filename (name_1, -1);\n\t\tkey_2 = g_utf8_collate_key_for_filename (name_2, -1);\n\n\t\tcompare = strcmp (key_1, key_2);\n\n\t\tg_free (key_1);\n\t\tg_free (key_2);\n\t}\n\n\treturn compare;\n}","target":1,"flaw_line_index":0,"hash":"b512efba-5322-428b-982c-e98092429fd4","idx":"875ed0a5-1cdb-47d1-9957-bdabf0cea7db"}
{"func_before":"sort_page_names (gconstpointer a,\n                 gconstpointer b)\n{\n  gchar *temp1, *temp2;\n  gint ret;\n\n  temp1 = g_utf8_collate_key_for_filename (* (const char **) a, -1);\n  temp2 = g_utf8_collate_key_for_filename (* (const char **) b, -1);\n\n  ret = strcmp (temp1, temp2);\n\n  g_free (temp1);\n  g_free (temp2);\n\n  return ret;\n}","target":0,"flaw_line_index":0,"hash":"bfa7d196-2da3-4719-8e88-dcc9c6b69576","idx":"4fb63ade-07ca-4b2a-aca1-536c4cf6c5bb"}
{"func_before":"\n\t\t\tif (cmd == HIDIOCGCOLLECTIONINDEX) {\n\t\t\t\tif (uref->usage_index >= field->maxusage)\n\t\t\t\t\tgoto inval;\n\t\t\t} else if (uref->usage_index >= field->report_count)\n\t\t\t\tgoto inval;\n\n\t\t\telse if ((cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) &&\n\t\t\t\t (uref_multi->num_values > HID_MAX_MULTI_USAGES ||\n\t\t\t\t  uref->usage_index + uref_multi->num_values > field->report_count))\n\t\t\t\tgoto inval;\n\t\t}\n\n\t\tswitch (cmd) {\n\t\tcase HIDIOCGUSAGE:\n\t\t\turef->value = field->value[uref->usage_index];\n\t\t\tif (copy_to_user(user_arg, uref, sizeof(*uref)))","target":1,"flaw_line_index":0,"hash":"f13fe31e-e62a-4a6a-abf9-998a7b013b47","idx":"6f2bc204-f04d-4249-808b-f85751d0d0c3"}
{"func_before":"\t\t\tif (cmd == HIDIOCGCOLLECTIONINDEX) {\n\t\t\t\tif (uref->usage_index >= field->maxusage)\n\t\t\t\t\tgoto inval;\n\t\t\t} else if (uref->usage_index >= field->report_count)\n\t\t\t\tgoto inval;\n\t\t}\n\n\t\tif ((cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES) &&\n\t\t    (uref_multi->num_values > HID_MAX_MULTI_USAGES ||\n\t\t     uref->usage_index + uref_multi->num_values > field->report_count))\n\t\t\tgoto inval;\n\n\t\tswitch (cmd) {\n\t\tcase HIDIOCGUSAGE:\n\t\t\turef->value = field->value[uref->usage_index];\n\t\t\tif (copy_to_user(user_arg, uref, sizeof(*uref)))","target":0,"flaw_line_index":0,"hash":"21ad19a4-b102-48d7-b567-77dbca67e87f","idx":"6adcc370-2f8c-4abe-8572-7d615795ce24"}
{"func_before":"struct import_t* MACH0_(get_imports)(struct MACH0_(obj_t)* bin) {\n\tstruct import_t *imports;\n\tint i, j, idx, stridx;\n\tconst char *symstr;\n\n\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)\n\t\treturn NULL;\n\tif (bin->dysymtab.nundefsym < 1 || bin->dysymtab.nundefsym > 0xfffff) {\n\t\treturn NULL;\n\t}\n\tif (!(imports = malloc ((bin->dysymtab.nundefsym + 1) * sizeof (struct import_t)))) {\n\t\treturn NULL;","target":1,"flaw_line_index":0,"hash":"bdb85c7a-4054-44fa-9fb1-7a6310e1bf49","idx":"ce8558ad-174a-459c-8954-775ac28c8f9d"}
{"func_before":"struct import_t* MACH0_(get_imports)(struct MACH0_(obj_t)* bin) {\n\tstruct import_t *imports;\n\tint i, j, idx, stridx;\n\tconst char *symstr;\n\n\tif (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms) {\n\t\treturn NULL;\n\t}\n\tif (bin->dysymtab.nundefsym < 1 || bin->dysymtab.nundefsym > 0xfffff) {\n\t\treturn NULL;\n\t}\n\tif (!(imports = malloc ((bin->dysymtab.nundefsym + 1) * sizeof (struct import_t)))) {\n\t\treturn NULL;","target":0,"flaw_line_index":0,"hash":"8a6d959f-8de2-44f3-88b7-940d51557f53","idx":"e5ab57c6-5b6a-4080-bf2d-0e3425d186b8"}
{"func_before":"snmp_ber_encode_null(unsigned char *out, uint32_t *out_len, uint8_t type)\n{\n  (*out_len)++;\n  *out-- = 0x00;\n  out = snmp_ber_encode_type(out, out_len, type);\n\n  return out;\n}","target":1,"flaw_line_index":0,"hash":"e7c28912-6233-499f-8fbf-2fafddcaf776","idx":"191f07f3-6245-4a80-9d4d-c2f74526fced"}
{"func_before":"snmp_ber_encode_null(snmp_packet_t *snmp_packet, uint8_t type)\n{\n\n  if(snmp_packet->used == snmp_packet->max) {\n    return 0;\n  }\n\n  *snmp_packet->out-- = 0x00;\n  snmp_packet->used++;\n\n  return snmp_ber_encode_type(snmp_packet, type);\n}","target":0,"flaw_line_index":0,"hash":"d1363cc2-a2e3-46d0-baab-c0da5cf4d8ac","idx":"2d345b11-df48-456f-beac-741db7ecd4c3"}
{"func_before":"NOEXPORT char *parse_global_option(CMD cmd, char *opt, char *arg) {\n    void *tmp;\n\n    if(cmd==CMD_PRINT_DEFAULTS || cmd==CMD_PRINT_HELP) {\n        s_log(LOG_NOTICE, \" \");\n        s_log(LOG_NOTICE, \"Global options:\");\n\n    \/* chroot *\/\n#ifdef HAVE_CHROOT\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.chroot_dir=NULL;\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        tmp=global_options.chroot_dir;\n        global_options.chroot_dir=NULL;\n        str_free(tmp);\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"chroot\"))\n            break;\n        new_global_options.chroot_dir=str_dup(arg);\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n\n    \/* compression *\/\n#ifndef OPENSSL_NO_COMP\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.compression=COMP_NONE;\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        break;\n         * with OpenSSL #1468 zlib memory leak fixed *\/\n        if(OpenSSL_version_num()<0x00908051L) \/* 0.9.8e-beta1 *\/\n            return \"Compression unsupported due to a memory leak\";\n#endif \/* OpenSSL version < 1.1.0 *\/\n        if(!strcasecmp(arg, \"deflate\"))\n            new_global_options.compression=COMP_DEFLATE;\n        else if(!strcasecmp(arg, \"zlib\"))\n            new_global_options.compression=COMP_ZLIB;\n        else\n            return \"Specified compression type is not available\";\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n\n    \/* EGD *\/\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n#ifdef EGD_SOCKET\n        new_global_options.egd_sock=EGD_SOCKET;\n#else\n        new_global_options.egd_sock=NULL;\n#endif\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        tmp=global_options.egd_sock;\n        global_options.egd_sock=NULL;\n        str_free(tmp);\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"EGD\"))\n            break;\n        new_global_options.egd_sock=str_dup(arg);\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n#ifdef EGD_SOCKET\n\n    \/* fips *\/\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n#ifdef USE_FIPS\n        new_global_options.option.fips=0;\n#endif \/* USE_FIPS *\/\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"fips\"))\n            break;\n#ifdef USE_FIPS\n        if(!strcasecmp(arg, \"yes\"))\n            new_global_options.option.fips=1;\n        else if(!strcasecmp(arg, \"no\"))\n            new_global_options.option.fips=0;\n        else\n            return \"The argument needs to be either 'yes' or 'no'\";\n#else\n        if(strcasecmp(arg, \"no\"))\n            return \"FIPS support is not available\";\n#endif \/* USE_FIPS *\/\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n#ifdef USE_FIPS\n        s_log(LOG_NOTICE, \"%-22s = yes|no FIPS 140-2 mode\",\n            \"fips\");\n\n    \/* foreground *\/\n#ifndef USE_WIN32\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.option.foreground=0;\n        new_global_options.option.log_stderr=0;\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"foreground\"))\n            break;\n        if(!strcasecmp(arg, \"yes\")) {\n            new_global_options.option.foreground=1;\n            new_global_options.option.log_stderr=1;\n        } else if(!strcasecmp(arg, \"quiet\")) {\n            new_global_options.option.foreground=1;\n            new_global_options.option.log_stderr=0;\n        } else if(!strcasecmp(arg, \"no\")) {\n            new_global_options.option.foreground=0;\n            new_global_options.option.log_stderr=0;\n        } else\n            return \"The argument needs to be either 'yes', 'quiet' or 'no'\";\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n#ifdef ICON_IMAGE\n\n    \/* iconActive *\/\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.icon[ICON_ACTIVE]=load_icon_default(ICON_ACTIVE);\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        \/* FIXME: investigate if we can free it *\/\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"iconActive\"))\n            break;\n        if(!(new_global_options.icon[ICON_ACTIVE]=load_icon_file(arg)))\n            return \"Failed to load the specified icon\";\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n    }\n\n    \/* iconError *\/\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.icon[ICON_ERROR]=load_icon_default(ICON_ERROR);\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        \/* FIXME: investigate if we can free it *\/\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"iconError\"))\n            break;\n        if(!(new_global_options.icon[ICON_ERROR]=load_icon_file(arg)))\n            return \"Failed to load the specified icon\";\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n    }\n\n    \/* iconIdle *\/\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.icon[ICON_IDLE]=load_icon_default(ICON_IDLE);\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        \/* FIXME: investigate if we can free it *\/\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"iconIdle\"))\n            break;\n        if(!(new_global_options.icon[ICON_IDLE]=load_icon_file(arg)))\n            return \"Failed to load the specified icon\";\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n#endif \/* ICON_IMAGE *\/\n\n    \/* log *\/\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.log_file_mode=FILE_MODE_APPEND;\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"log\"))\n            break;\n        if(!strcasecmp(arg, \"append\"))\n            new_global_options.log_file_mode=FILE_MODE_APPEND;\n        else if(!strcasecmp(arg, \"overwrite\"))\n            new_global_options.log_file_mode=FILE_MODE_OVERWRITE;\n        else\n            return \"The argument needs to be either 'append' or 'overwrite'\";\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n    }\n\n    \/* output *\/\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.output_file=NULL;\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        tmp=global_options.output_file;\n        global_options.output_file=NULL;\n        str_free(tmp);\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"output\"))\n            break;\n        new_global_options.output_file=str_dup(arg);\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n#ifndef USE_WIN32\n        if(!new_global_options.option.foreground \/* daemonize() used *\/ &&\n                new_global_options.output_file \/* log file enabled *\/ &&\n                new_global_options.output_file[0]!='\/' \/* relative path *\/)\n            return \"Log file must include full path name\";\n#endif\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n\n    \/* pid *\/\n#ifndef USE_WIN32\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.pidfile=NULL; \/* do not create a pid file *\/\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        tmp=global_options.pidfile;\n        global_options.pidfile=NULL;\n        str_free(tmp);\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"pid\"))\n            break;\n        if(arg[0]) \/* is argument not empty? *\/\n            new_global_options.pidfile=str_dup(arg);\n        else\n            new_global_options.pidfile=NULL; \/* empty -> do not create a pid file *\/\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        if(!new_global_options.option.foreground \/* daemonize() used *\/ &&\n                new_global_options.pidfile \/* pid file enabled *\/ &&\n                new_global_options.pidfile[0]!='\/' \/* relative path *\/)\n            return \"Pid file must include full path name\";\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n#endif\n\n    \/* RNDbytes *\/\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.random_bytes=RANDOM_BYTES;\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"RNDbytes\"))\n            break;\n        {\n            char *tmp_str;\n            new_global_options.random_bytes=(long)strtol(arg, &tmp_str, 10);\n            if(tmp_str==arg || *tmp_str) \/* not a number *\/\n                return \"Illegal number of bytes to read from random seed files\";\n        }\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n\n    \/* RNDfile *\/\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n#ifdef RANDOM_FILE\n        new_global_options.rand_file=str_dup(RANDOM_FILE);\n#else\n        new_global_options.rand_file=NULL;\n#endif\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        tmp=global_options.rand_file;\n        global_options.rand_file=NULL;\n        str_free(tmp);\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"RNDfile\"))\n            break;\n        new_global_options.rand_file=str_dup(arg);\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n#ifdef RANDOM_FILE\n    }\n\n    \/* RNDoverwrite *\/\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.option.rand_write=1;\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"RNDoverwrite\"))\n            break;\n        if(!strcasecmp(arg, \"yes\"))\n            new_global_options.option.rand_write=1;\n        else if(!strcasecmp(arg, \"no\"))\n            new_global_options.option.rand_write=0;\n        else\n            return \"The argument needs to be either 'yes' or 'no'\";\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n\n    \/* syslog *\/\n#ifndef USE_WIN32\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.option.log_syslog=1;\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"syslog\"))\n            break;\n        if(!strcasecmp(arg, \"yes\"))\n            new_global_options.option.log_syslog=1;\n        else if(!strcasecmp(arg, \"no\"))\n            new_global_options.option.log_syslog=0;\n        else\n            return \"The argument needs to be either 'yes' or 'no'\";\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n\n    \/* taskbar *\/\n#ifdef USE_WIN32\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        new_global_options.option.taskbar=1;\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"taskbar\"))\n            break;\n        if(!strcasecmp(arg, \"yes\"))\n            new_global_options.option.taskbar=1;\n        else if(!strcasecmp(arg, \"no\"))\n            new_global_options.option.taskbar=0;\n        else\n            return \"The argument needs to be either 'yes' or 'no'\";\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        break;\n    case CMD_SET_COPY:\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        return option_not_found;\n    case CMD_INITIALIZE:\n        \/* FIPS needs to be initialized as early as possible *\/\n        if(ssl_configure(&new_global_options)) \/* configure global TLS settings *\/\n            return \"Failed to initialize TLS\";\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        break;","target":1,"flaw_line_index":0,"hash":"03d19a9e-91e5-4bb9-9005-03eedbfb2266","idx":"511e5d43-3d4d-4328-b248-5f79b30ea413"}
{"func_before":"NOEXPORT char *parse_global_option(CMD cmd, GLOBAL_OPTIONS *options, char *opt, char *arg) {\n    void *tmp;\n\n    if(cmd==CMD_PRINT_DEFAULTS || cmd==CMD_PRINT_HELP) {\n        s_log(LOG_NOTICE, \" \");\n        s_log(LOG_NOTICE, \"Global options:\");\n\n    \/* chroot *\/\n#ifdef HAVE_CHROOT\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->chroot_dir=NULL;\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        tmp=options->chroot_dir;\n        options->chroot_dir=NULL;\n        str_free(tmp);\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"chroot\"))\n            break;\n        options->chroot_dir=str_dup(arg);\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n\n    \/* compression *\/\n#ifndef OPENSSL_NO_COMP\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->compression=COMP_NONE;\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        break;\n         * with OpenSSL #1468 zlib memory leak fixed *\/\n        if(OpenSSL_version_num()<0x00908051L) \/* 0.9.8e-beta1 *\/\n            return \"Compression unsupported due to a memory leak\";\n#endif \/* OpenSSL version < 1.1.0 *\/\n        if(!strcasecmp(arg, \"deflate\"))\n            options->compression=COMP_DEFLATE;\n        else if(!strcasecmp(arg, \"zlib\"))\n            options->compression=COMP_ZLIB;\n        else\n            return \"Specified compression type is not available\";\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n\n    \/* EGD *\/\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n#ifdef EGD_SOCKET\n        options->egd_sock=EGD_SOCKET;\n#else\n        options->egd_sock=NULL;\n#endif\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        tmp=options->egd_sock;\n        options->egd_sock=NULL;\n        str_free(tmp);\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"EGD\"))\n            break;\n        options->egd_sock=str_dup(arg);\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n#ifdef EGD_SOCKET\n\n    \/* fips *\/\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n#ifdef USE_FIPS\n        options->option.fips=FIPS_mode()?1:0;\n#endif \/* USE_FIPS *\/\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"fips\"))\n            break;\n        if(!strcasecmp(arg, \"yes\")) {\n#ifdef USE_FIPS\n            options->option.fips=1;\n#else\n            return \"FIPS support is not available\";\n#endif \/* USE_FIPS *\/\n        } else if(!strcasecmp(arg, \"no\")) {\n#ifdef USE_FIPS\n            if(FIPS_mode())\n                return \"Failed to override system-wide FIPS mode\";\n            options->option.fips=0;\n#endif \/* USE_FIPS *\/\n        } else {\n            return \"The argument needs to be either 'yes' or 'no'\";\n        }\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n#ifdef USE_FIPS\n        s_log(LOG_NOTICE, \"%-22s = %s\", \"fips\", FIPS_mode()?\"yes\":\"no\");\n#endif \/* USE_FIPS *\/\n        break;\n    case CMD_PRINT_HELP:\n#ifdef USE_FIPS\n        s_log(LOG_NOTICE, \"%-22s = yes|no FIPS 140-2 mode\",\n            \"fips\");\n\n    \/* foreground *\/\n#ifndef USE_WIN32\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->option.foreground=0;\n        options->option.log_stderr=0;\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"foreground\"))\n            break;\n        if(!strcasecmp(arg, \"yes\")) {\n            options->option.foreground=1;\n            options->option.log_stderr=1;\n        } else if(!strcasecmp(arg, \"quiet\")) {\n            options->option.foreground=1;\n            options->option.log_stderr=0;\n        } else if(!strcasecmp(arg, \"no\")) {\n            options->option.foreground=0;\n            options->option.log_stderr=0;\n        } else\n            return \"The argument needs to be either 'yes', 'quiet' or 'no'\";\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n#ifdef ICON_IMAGE\n\n    \/* iconActive *\/\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->icon[ICON_ACTIVE]=load_icon_default(ICON_ACTIVE);\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        \/* FIXME: investigate if we can free it *\/\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"iconActive\"))\n            break;\n        if(!(options->icon[ICON_ACTIVE]=load_icon_file(arg)))\n            return \"Failed to load the specified icon\";\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n    }\n\n    \/* iconError *\/\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->icon[ICON_ERROR]=load_icon_default(ICON_ERROR);\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        \/* FIXME: investigate if we can free it *\/\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"iconError\"))\n            break;\n        if(!(options->icon[ICON_ERROR]=load_icon_file(arg)))\n            return \"Failed to load the specified icon\";\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n    }\n\n    \/* iconIdle *\/\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->icon[ICON_IDLE]=load_icon_default(ICON_IDLE);\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        \/* FIXME: investigate if we can free it *\/\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"iconIdle\"))\n            break;\n        if(!(options->icon[ICON_IDLE]=load_icon_file(arg)))\n            return \"Failed to load the specified icon\";\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n#endif \/* ICON_IMAGE *\/\n\n    \/* log *\/\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->log_file_mode=FILE_MODE_APPEND;\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"log\"))\n            break;\n        if(!strcasecmp(arg, \"append\"))\n            options->log_file_mode=FILE_MODE_APPEND;\n        else if(!strcasecmp(arg, \"overwrite\"))\n            options->log_file_mode=FILE_MODE_OVERWRITE;\n        else\n            return \"The argument needs to be either 'append' or 'overwrite'\";\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n    }\n\n    \/* output *\/\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->output_file=NULL;\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        tmp=options->output_file;\n        options->output_file=NULL;\n        str_free(tmp);\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"output\"))\n            break;\n        options->output_file=str_dup(arg);\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n#ifndef USE_WIN32\n        if(!options->option.foreground \/* daemonize() used *\/ &&\n                options->output_file \/* log file enabled *\/ &&\n                options->output_file[0]!='\/' \/* relative path *\/)\n            return \"Log file must include full path name\";\n#endif\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n\n    \/* pid *\/\n#ifndef USE_WIN32\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->pidfile=NULL; \/* do not create a pid file *\/\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        tmp=options->pidfile;\n        options->pidfile=NULL;\n        str_free(tmp);\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"pid\"))\n            break;\n        if(arg[0]) \/* is argument not empty? *\/\n            options->pidfile=str_dup(arg);\n        else\n            options->pidfile=NULL; \/* empty -> do not create a pid file *\/\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        if(!options->option.foreground \/* daemonize() used *\/ &&\n                options->pidfile \/* pid file enabled *\/ &&\n                options->pidfile[0]!='\/' \/* relative path *\/)\n            return \"Pid file must include full path name\";\n        break;\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n#endif\n\n    \/* RNDbytes *\/\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->random_bytes=RANDOM_BYTES;\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"RNDbytes\"))\n            break;\n        {\n            char *tmp_str;\n            options->random_bytes=(long)strtol(arg, &tmp_str, 10);\n            if(tmp_str==arg || *tmp_str) \/* not a number *\/\n                return \"Illegal number of bytes to read from random seed files\";\n        }\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n\n    \/* RNDfile *\/\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n#ifdef RANDOM_FILE\n        options->rand_file=str_dup(RANDOM_FILE);\n#else\n        options->rand_file=NULL;\n#endif\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        tmp=options->rand_file;\n        options->rand_file=NULL;\n        str_free(tmp);\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"RNDfile\"))\n            break;\n        options->rand_file=str_dup(arg);\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n    case CMD_PRINT_DEFAULTS:\n#ifdef RANDOM_FILE\n    }\n\n    \/* RNDoverwrite *\/\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->option.rand_write=1;\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"RNDoverwrite\"))\n            break;\n        if(!strcasecmp(arg, \"yes\"))\n            options->option.rand_write=1;\n        else if(!strcasecmp(arg, \"no\"))\n            options->option.rand_write=0;\n        else\n            return \"The argument needs to be either 'yes' or 'no'\";\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n\n    \/* syslog *\/\n#ifndef USE_WIN32\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->option.log_syslog=1;\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"syslog\"))\n            break;\n        if(!strcasecmp(arg, \"yes\"))\n            options->option.log_syslog=1;\n        else if(!strcasecmp(arg, \"no\"))\n            options->option.log_syslog=0;\n        else\n            return \"The argument needs to be either 'yes' or 'no'\";\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n\n    \/* taskbar *\/\n#ifdef USE_WIN32\n    switch(cmd) {\n    case CMD_SET_DEFAULTS:\n        options->option.taskbar=1;\n        break;\n    case CMD_SET_COPY: \/* not used for global options *\/\n        break;\n    case CMD_FREE:\n        break;\n    case CMD_SET_VALUE:\n        if(strcasecmp(opt, \"taskbar\"))\n            break;\n        if(!strcasecmp(arg, \"yes\"))\n            options->option.taskbar=1;\n        else if(!strcasecmp(arg, \"no\"))\n            options->option.taskbar=0;\n        else\n            return \"The argument needs to be either 'yes' or 'no'\";\n        return NULL; \/* OK *\/\n    case CMD_INITIALIZE:\n        break;\n    case CMD_SET_DEFAULTS:\n        break;\n    case CMD_SET_COPY:\n        break;\n    case CMD_FREE:\n        memset(options, 0, sizeof(GLOBAL_OPTIONS));\n        break;\n    case CMD_SET_VALUE:\n        return option_not_found;\n    case CMD_INITIALIZE:\n        \/* FIPS needs to be initialized as early as possible *\/\n        if(ssl_configure(options)) \/* configure global TLS settings *\/\n            return \"Failed to initialize TLS\";\n    case CMD_PRINT_DEFAULTS:\n        break;\n    case CMD_PRINT_HELP:\n        break;","target":0,"flaw_line_index":0,"hash":"ad2158f6-48a1-467c-b4f2-5d289c5b909e","idx":"86aaf2ad-ded4-4b91-9c79-b51bf4ad6f12"}
{"func_before":"         * Unlike dirs, mere files are ignored by abrtd.\n         *\/\n        if (snprintf(path, sizeof(path), \"%s\/%s-coredump\", g_settings_dump_location, last_slash) >= sizeof(path))\n            error_msg_and_die(\"Error saving '%s': truncated long file path\", path);\n\n        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);\n        off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);\n        if (core_size < 0 || fsync(abrt_core_fd) != 0)\n        {\n            unlink(path);\n            \/* copyfd_eof logs the error including errno string,","target":1,"flaw_line_index":0,"hash":"0af35098-dca4-46aa-b9dc-e6d75e016ef6","idx":"23791984-822a-464b-9dc1-083cc103e4b0"}
{"func_before":"         * Unlike dirs, mere files are ignored by abrtd.\n         *\/\n        if (snprintf(path, sizeof(path), \"%s\/%s-coredump\", g_settings_dump_location, last_slash) >= sizeof(path))\n            error_msg_and_die(\"Error saving '%s': truncated long file path\", path);\n\n        unlink(path);\n        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);\n        off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);\n        if (core_size < 0 || fsync(abrt_core_fd) != 0)\n        {\n            unlink(path);\n            \/* copyfd_eof logs the error including errno string,","target":0,"flaw_line_index":0,"hash":"f7491c2b-0f87-4ac9-9fdc-295c7c315076","idx":"1a9f3cab-02b8-461e-b465-b03028b3ad3e"}
{"func_before":"static int ceph_x_proc_ticket_reply(struct ceph_auth_client *ac,\n\t\t\t\t    struct ceph_crypto_key *secret,\n\t\t\t\t    void *buf, void *end)\n{\n\tvoid *p = buf;\n\tchar *dbuf;\n\tchar *ticket_buf;\n\tu8 reply_struct_v;\n\tu32 num;\n\tint ret;\n\n\tdbuf = kmalloc(TEMP_TICKET_BUF_LEN, GFP_NOFS);\n\tif (!dbuf)\n\t\treturn -ENOMEM;\n\n\tret = -ENOMEM;\n\tticket_buf = kmalloc(TEMP_TICKET_BUF_LEN, GFP_NOFS);\n\tif (!ticket_buf)\n\t\tgoto out_dbuf;\n\n\tceph_decode_8_safe(&p, end, reply_struct_v, bad);\n\tif (reply_struct_v != 1)\n\t\treturn -EINVAL;\n\n\tceph_decode_32_safe(&p, end, num, bad);\n\tdout(\"%d tickets\\n\", num);\n\n\twhile (num--) {\n\t\tret = process_one_ticket(ac, secret, &p, end,\n\t\t\t\t\t dbuf, ticket_buf);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tkfree(ticket_buf);\nout_dbuf:\n\tkfree(dbuf);\n\treturn ret;\n\nbad:\n\tret = -EINVAL;\n\tgoto out;\n}","target":1,"flaw_line_index":0,"hash":"24c10494-17d0-487d-8175-3b9621066921","idx":"02690294-9da4-4550-9b37-38d3b0e0e30b"}
{"func_before":"static int ceph_x_proc_ticket_reply(struct ceph_auth_client *ac,\n\t\t\t\t    struct ceph_crypto_key *secret,\n\t\t\t\t    void *buf, void *end)\n{\n\tvoid *p = buf;\n\tu8 reply_struct_v;\n\tu32 num;\n\tint ret;\n\n\tceph_decode_8_safe(&p, end, reply_struct_v, bad);\n\tif (reply_struct_v != 1)\n\t\treturn -EINVAL;\n\n\tceph_decode_32_safe(&p, end, num, bad);\n\tdout(\"%d tickets\\n\", num);\n\n\twhile (num--) {\n\t\tret = process_one_ticket(ac, secret, &p, end);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n\nbad:\n\treturn -EINVAL;\n}","target":0,"flaw_line_index":0,"hash":"b5cd8a94-37ff-49c8-8e56-57fbdbe319c3","idx":"461f11b2-402c-4f3b-a917-644c8b80e9f8"}
{"func_before":"\t *\/\n\tentry = *pte;\n\tbarrier();\n\tif (!pte_present(entry)) {\n\t\tif (pte_none(entry)) {\n\t\t\tif (vma->vm_ops) {\n\t\t\t\tif (likely(vma->vm_ops->fault))\n\t\t\t\t\treturn do_fault(mm, vma, address, pte,\n\t\t\t\t\t\t\tpmd, flags, entry);\n\t\t\t}\n\t\t\treturn do_anonymous_page(mm, vma, address,\n\t\t\t\t\t\t pte, pmd, flags);\n\t\t}\n\t\treturn do_swap_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, flags, entry);\n\t}\n","target":1,"flaw_line_index":0,"hash":"32bbf97a-8b1c-4f71-b944-2fdcefc637b0","idx":"0a2d6446-262b-4a6d-8984-32125714e621"}
{"func_before":"\t *\/\n\tentry = *pte;\n\tbarrier();\n\tif (!pte_present(entry)) {\n\t\tif (pte_none(entry)) {\n\t\t\tif (vma->vm_ops)\n\t\t\t\treturn do_fault(mm, vma, address, pte, pmd,\n\t\t\t\t\t\tflags, entry);\n\n\t\t\treturn do_anonymous_page(mm, vma, address, pte, pmd,\n\t\t\t\t\tflags);\n\t\t}\n\t\treturn do_swap_page(mm, vma, address,\n\t\t\t\t\tpte, pmd, flags, entry);\n\t}\n","target":0,"flaw_line_index":0,"hash":"bf4ccd01-0e3f-4d05-a92b-5dee888950c7","idx":"64784852-abf7-4454-9b55-95e57e2e0976"}
{"func_before":"\t\t * TODO: Make sure that the EAPOL message is getting\n\t\t *       out before card disabled\n\t\t *\/\n\t\tif (param->value) {\n\t\t\tpriv->tkip_cm_active = 1;\n\t\t\tret = hermes_enable_port(hw, 0);\n\t\t} else {\n\t\t\tpriv->tkip_cm_active = 0;\n\t\t\tret = hermes_disable_port(hw, 0);\n\t\t}\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY)","target":1,"flaw_line_index":0,"hash":"624f0b6f-88c9-4513-bfea-29891efda062","idx":"9ee03c02-8759-4b66-98be-73116b4a3e7b"}
{"func_before":"\t\t * TODO: Make sure that the EAPOL message is getting\n\t\t *       out before card disabled\n\t\t *\/\n\t\tif (param->value) {\n\t\t\tpriv->tkip_cm_active = 1;\n\t\t\tret = hermes_disable_port(hw, 0);\n\t\t} else {\n\t\t\tpriv->tkip_cm_active = 0;\n\t\t\tret = hermes_enable_port(hw, 0);\n\t\t}\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY)","target":0,"flaw_line_index":0,"hash":"2694bc73-9e7d-4a66-916f-d06e3998798b","idx":"86a872be-5675-42c0-896d-520d1b5bae8f"}
{"func_before":"\tstruct snd_kcontrol_volatile *vd;\n\tunsigned int index_offset;\n\tstruct snd_ctl_elem_info info;\n\tconst u32 pattern = 0xdeadbeef;\n\tint ret;\n\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL)\n\t\treturn -ENOENT;\n\n\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\tvd = &kctl->vd[index_offset];\n\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_READ) || kctl->get == NULL)\n\t\treturn -EPERM;\n\n\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\n#ifdef CONFIG_SND_CTL_DEBUG\n\t\/* info is needed only for validation *\/\n\tmemset(&info, 0, sizeof(info));\n\tinfo.id = control->id;\n\tret = __snd_ctl_elem_info(card, kctl, &info, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n#endif\n\n\tif (!snd_ctl_skip_validation(&info))\n\t\tfill_remaining_elem_value(control, &info, pattern);\n\tret = snd_power_ref_and_wait(card);\n\tif (!ret)\n\t\tret = kctl->get(kctl, control);\n\tsnd_power_unref(card);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (!snd_ctl_skip_validation(&info) &&\n\t    sanity_check_elem_value(card, control, &info, pattern) < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"control %i:%i:%i:%s:%i: access overflow\\n\",\n\t\t\tcontrol->id.iface, control->id.device,\n\t\t\tcontrol->id.subdevice, control->id.name,\n\t\t\tcontrol->id.index);\n\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}","target":1,"flaw_line_index":0,"hash":"831b3966-8fc9-491d-a4c0-658025a364ca","idx":"9c2ee553-d99e-4883-894e-5acd515604ac"}
{"func_before":"\tunsigned int index_offset;\n\tstruct snd_ctl_elem_info info;\n\tconst u32 pattern = 0xdeadbeef;\n\tint ret;\n\n\tdown_read(&card->controls_rwsem);\n\tkctl = snd_ctl_find_id(card, &control->id);\n\tif (kctl == NULL) {\n\t\tret = -ENOENT;\n\t\tgoto unlock;\n\t}\n\n\tindex_offset = snd_ctl_get_ioff(kctl, &control->id);\n\tvd = &kctl->vd[index_offset];\n\tif (!(vd->access & SNDRV_CTL_ELEM_ACCESS_READ) || kctl->get == NULL) {\n\t\tret = -EPERM;\n\t\tgoto unlock;\n\t}\n\n\tsnd_ctl_build_ioff(&control->id, kctl, index_offset);\n\n#ifdef CONFIG_SND_CTL_DEBUG\n\t\/* info is needed only for validation *\/\n\tmemset(&info, 0, sizeof(info));\n\tinfo.id = control->id;\n\tret = __snd_ctl_elem_info(card, kctl, &info, NULL);\n\tif (ret < 0)\n\t\tgoto unlock;\n#endif\n\n\tif (!snd_ctl_skip_validation(&info))\n\t\tfill_remaining_elem_value(control, &info, pattern);\n\tret = snd_power_ref_and_wait(card);\n\tif (!ret)\n\t\tret = kctl->get(kctl, control);\n\tsnd_power_unref(card);\n\tif (ret < 0)\n\t\tgoto unlock;\n\tif (!snd_ctl_skip_validation(&info) &&\n\t    sanity_check_elem_value(card, control, &info, pattern) < 0) {\n\t\tdev_err(card->dev,\n\t\t\t\"control %i:%i:%i:%s:%i: access overflow\\n\",\n\t\t\tcontrol->id.iface, control->id.device,\n\t\t\tcontrol->id.subdevice, control->id.name,\n\t\t\tcontrol->id.index);\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\nunlock:\n\tup_read(&card->controls_rwsem);\n\treturn ret;\n}","target":0,"flaw_line_index":0,"hash":"bc05d5c1-7f32-44aa-87a6-7032e80e994f","idx":"e5de9062-30ac-4df1-b1b2-53e6f18464d9"}
{"func_before":"\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = nfc_llcp_local_get(local);\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\n\tnfc_llcp_sock_link(&local->raw_sockets, sk);\n\n\tsk->sk_state = LLCP_BOUND;","target":1,"flaw_line_index":0,"hash":"55fff428-76b9-4c20-ab26-bc1de40d7394","idx":"fe08e0b3-b45e-49af-b34a-d9bcc8880a18"}
{"func_before":"\t\tret = -ENODEV;\n\t\tgoto put_dev;\n\t}\n\n\tllcp_sock->dev = dev;\n\tllcp_sock->local = local;\n\tllcp_sock->nfc_protocol = llcp_addr.nfc_protocol;\n\n\tnfc_llcp_sock_link(&local->raw_sockets, sk);\n\n\tsk->sk_state = LLCP_BOUND;","target":0,"flaw_line_index":0,"hash":"8a60867c-cd4b-4bce-8a9c-816f33a85366","idx":"7bf2cdee-ec86-4212-95fd-8405cdd86363"}
{"func_before":"\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode = inode->i_mode;\n\t\terror = posix_acl_equiv_mode(acl, &mode);\n\n\t\tif (error <= 0) {\n\t\t\tacl = NULL;\n\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t}\n\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n","target":1,"flaw_line_index":0,"hash":"f01bce33-b7ca-4d81-8afd-4c3b2395ab36","idx":"859157b4-1221-4876-8076-61149e0e9d34"}
{"func_before":"\terror = -E2BIG;\n\tif (acl->a_count > XFS_ACL_MAX_ENTRIES(XFS_M(inode->i_sb)))\n\t\treturn error;\n\n\tif (type == ACL_TYPE_ACCESS) {\n\t\tumode_t mode;\n\n\t\terror = posix_acl_update_mode(inode, &mode, &acl);\n\t\tif (error)\n\t\t\treturn error;\n\t\terror = xfs_set_mode(inode, mode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n","target":0,"flaw_line_index":0,"hash":"920f06ea-6512-441a-a158-80943c2c02e9","idx":"992d8354-0810-4013-bb89-bb4a143facee"}
{"func_before":"R_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut64 offset = 0;\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\toffset += 6;\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR;\n\tattr->size = offset;\n\treturn attr;\n}","target":1,"flaw_line_index":0,"hash":"7c11feeb-9e3c-46df-b31a-7c03e7de7ca8","idx":"e12cd56f-c35c-4db9-8fa1-adc2ae7e3a62"}
{"func_before":"R_API RBinJavaAttrInfo *r_bin_java_synthetic_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tif (sz < 8) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->type = R_BIN_JAVA_ATTR_TYPE_SYNTHETIC_ATTR;\n\tattr->size = 6;\n\treturn attr;\n}","target":0,"flaw_line_index":0,"hash":"d05f3f7a-8fae-4cdf-86c8-089b8ceaaf6a","idx":"42ce26bb-37b4-4b17-8a03-3f54afa30166"}
{"func_before":"alloc_limit_failure (char *fn_name, size_t size)\n{\n    fprintf (stderr, \n             \"%s: Maximum allocation size exceeded \"\n             \"(maxsize = %lu; size = %lu).\\n\",\n             fn_name,\n             (unsigned long)alloc_limit, \n             (unsigned long)size);\n}","target":1,"flaw_line_index":0,"hash":"b5101733-ae51-4f05-a411-16d0c5ea62bb","idx":"2629596a-5d5e-4cca-8a32-6c24edc6f5e4"}
{"func_before":"alloc_limit_failure (char *fn_name, size_t size)\n{\n    fprintf (stderr,\n             \"%s: Maximum allocation size exceeded \"\n             \"(maxsize = %lu; size = %lu).\\n\",\n             fn_name,\n             (unsigned long)alloc_limit,\n             (unsigned long)size);\n}","target":0,"flaw_line_index":0,"hash":"ac85ef3c-ab58-430e-ab22-a24768423f5f","idx":"1d1ef318-4f7f-4529-a0d7-a36e990bad78"}
{"func_before":"void ntlm_populate_message_header(NTLM_MESSAGE_HEADER* header, UINT32 MessageType)\n{\n\tCopyMemory(header->Signature, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE));\n\theader->MessageType = MessageType;\n}","target":1,"flaw_line_index":0,"hash":"a62507bf-f76d-4045-b08c-5aeca543ca73","idx":"fb33bb87-73f5-4d30-a6b6-9bf70eaa321b"}
{"func_before":"static void ntlm_populate_message_header(NTLM_MESSAGE_HEADER* header, UINT32 MessageType)\n{\n\tCopyMemory(header->Signature, NTLM_SIGNATURE, sizeof(NTLM_SIGNATURE));\n\theader->MessageType = MessageType;\n}","target":0,"flaw_line_index":0,"hash":"b4dacc48-4e04-43cb-a922-b8b57ce90b73","idx":"eacd5c67-ea2b-4c5d-bdee-8342be8d21c4"}
{"func_before":"            }\n\n            if (sec_strndx) {\n                unsigned const sh_name = get_te32(&sec_strndx->sh_name);\n                if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n                || (u32_t)file_size <= sh_name  \/\/ FIXME: weak\n                || (sh_name\n                  && 0!=strcmp((char const *)\".shstrtab\", &shstrtab[sh_name]))\n                ) {\n                    throwCantPack(\"bad e_shstrndx\");\n                }\n            }\n        }\n\n        Elf32_Phdr const *pload_x0(0);  \/\/ first eXecutable PT_LOAD","target":1,"flaw_line_index":0,"hash":"17bc6efe-a4f8-41b0-9b43-431160a1fde8","idx":"1c910307-dde9-44f4-a66c-6a718c7c9707"}
{"func_before":"            }\n\n            if (sec_strndx) {\n                unsigned const sh_name = get_te32(&sec_strndx->sh_name);\n                if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n                || (u32_t)file_size <= (sizeof(\".shstrtab\")\n                    + sh_name + (shstrtab - (const char *)&file_image[0]))\n                || (sh_name\n                  && 0!=strcmp((char const *)\".shstrtab\", &shstrtab[sh_name]))\n                ) {\n                    throwCantPack(\"bad e_shstrtab\");\n                }\n            }\n        }\n\n        Elf32_Phdr const *pload_x0(0);  \/\/ first eXecutable PT_LOAD","target":0,"flaw_line_index":0,"hash":"b4d70af0-e2e0-4b36-9cb5-1df7905762b4","idx":"b17fbcaa-ed18-42ce-b728-ebd535898966"}
{"func_before":"void trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,\n                          uint32_t enc_len, char *key) {\n\n    LOG_DEBUG(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(key);\n\n    *errStatus = -9;\n\n    int status = AES_decrypt_DH(encryptedPrivateKey, enc_len, key, 3072);\n\n    if (status != 0) {\n        *errStatus = status;\n        snprintf(errString, BUF_LEN, \"aes decrypt failed with status %d\", status);\n        LOG_ERROR(errString);","target":1,"flaw_line_index":0,"hash":"2c2eb0cd-b3e4-4bd1-adb0-d4677402c935","idx":"fee3bf79-9113-447f-a08c-68bbeef1c002"}
{"func_before":"void trustedDecryptKeyAES(int *errStatus, char *errString, uint8_t *encryptedPrivateKey,\n                          uint64_t enc_len, char *key) {\n\n    LOG_DEBUG(__FUNCTION__);\n    INIT_ERROR_STATE\n\n    CHECK_STATE(encryptedPrivateKey);\n    CHECK_STATE(key);\n\n    *errStatus = -9;\n\n    int status = AES_decrypt(encryptedPrivateKey, enc_len, key, 3072);\n\n    if (status != 0) {\n        *errStatus = status;\n        snprintf(errString, BUF_LEN, \"aes decrypt failed with status %d\", status);\n        LOG_ERROR(errString);","target":0,"flaw_line_index":0,"hash":"f1a5b743-8d31-43e1-8ae4-19b856e0651c","idx":"6b8ed02d-32b9-43c4-9ebd-2ece4e13547a"}
{"func_before":"  char *to_r = nullptr;\n  int err = 0;\n  if (!to.empty()) {\n    int to_len = to.size();\n    if (to_len > 0) {\n      to_r = strndup(to.data(), to_len);\n      for (; to_len; to_len--) {\n        if (!isspace((unsigned char)to_r[to_len - 1])) {\n          break;\n        }\n        to_r[to_len - 1] = '\\0';\n\n  String cmd = string_escape_shell_cmd(extra_cmd.c_str());\n  bool ret = (!err && php_mail(to_r, encoded_subject.data(),\n                               encoded_message.data(),\n                               all_headers, cmd.data()));\n  mbfl_memory_device_clear(&device);\n  return ret;\n}","target":1,"flaw_line_index":0,"hash":"b96fe851-b0a4-4ed2-a98d-679f7fd6480a","idx":"d9249204-8bc1-4daa-b75f-5b62ac3a9b16"}
{"func_before":"  char *to_r = nullptr;\n  int err = 0;\n  if (!to.empty()) {\n    int to_len = to.size();\n    if (to_len > 0) {\n      to_r = req::strndup(to.data(), to_len);\n      for (; to_len; to_len--) {\n        if (!isspace((unsigned char)to_r[to_len - 1])) {\n          break;\n        }\n        to_r[to_len - 1] = '\\0';\n  String cmd = string_escape_shell_cmd(extra_cmd.c_str());\n  bool ret = (!err && php_mail(to_r, encoded_subject.data(),\n                               encoded_message.data(),\n                               all_headers, cmd.data()));\n  mbfl_memory_device_clear(&device);\n  if (to_r != to.data()) {\n    req::free(to_r);\n  }\n  return ret;\n}","target":0,"flaw_line_index":0,"hash":"465d79bf-1dd8-4b39-8dbc-ca7de4fa14ab","idx":"1d29bb6e-02d5-42fa-9371-afde8270e1ae"}
{"func_before":"vips_foreign_load_start( VipsImage *out, void *a, void *b )\n{\n\tVipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );\n\tVipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );\n\n\tif( !load->real ) {\n\t\tif( !(load->real = vips_foreign_load_temp( load )) )\n\t\t\treturn( NULL );\n\n\t\t * vips_foreign_load_invalidate() below.\n\t\t *\/\n\t\tg_object_set_qdata( G_OBJECT( load->real ), \n\t\t\tvips__foreign_load_operation, load ); \n\n\t\tif( class->load( load ) ||\n\t\t\tvips_image_pio_input( load->real ) ) \n\t\t\treturn( NULL );\n\n\t\t\/* ->header() read the header into @out, load has read the\n\t\t * image into @real. They must match exactly in size, bands,\n\t\t * format and coding for the copy to work.  \n\t\t *\n\t\t * Some versions of ImageMagick give different results between\n\t\t * Ping and Load for some formats, for example.\n\t\t *\/\n\t\tif( !vips_foreign_load_iscompat( load->real, out ) )\n\t\t\treturn( NULL );\n\n\t\t\/* We have to tell vips that out depends on real. We've set\n\t\t * the demand hint below, but not given an input there.\n\t\t *\/\n\t\tvips_image_pipelinev( load->out, load->out->dhint, ","target":1,"flaw_line_index":0,"hash":"68c852ce-b072-4ba8-97f9-3243a0828471","idx":"d3fffd09-b247-4edd-a447-15c9faa9c7d3"}
{"func_before":"vips_foreign_load_start( VipsImage *out, void *a, void *b )\n{\n\tVipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );\n\tVipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );\n\n\t\/* If this start has failed before in another thread, we can fail now.\n\t *\/\n\tif( load->error )\n\t\treturn( NULL );\n\n\tif( !load->real ) {\n\t\tif( !(load->real = vips_foreign_load_temp( load )) )\n\t\t\treturn( NULL );\n\n\t\t * vips_foreign_load_invalidate() below.\n\t\t *\/\n\t\tg_object_set_qdata( G_OBJECT( load->real ), \n\t\t\tvips__foreign_load_operation, load ); \n\n\t\t\/* Load the image and check the result.\n\t\t *\n\t\t * ->header() read the header into @out, load has read the\n\t\t * image into @real. They must match exactly in size, bands,\n\t\t * format and coding for the copy to work.  \n\t\t *\n\t\t * Some versions of ImageMagick give different results between\n\t\t * Ping and Load for some formats, for example.\n\t\t *\n\t\t * If the load fails, we need to stop\n\t\t *\/\n\t\tif( class->load( load ) ||\n\t\t\tvips_image_pio_input( load->real ) || \n\t\t\tvips_foreign_load_iscompat( load->real, out ) ) {\n\t\t\tvips_operation_invalidate( VIPS_OPERATION( load ) ); \n\t\t\tload->error = TRUE;\n\n\t\t\treturn( NULL );\n\t\t}\n\n\t\t\/* We have to tell vips that out depends on real. We've set\n\t\t * the demand hint below, but not given an input there.\n\t\t *\/\n\t\tvips_image_pipelinev( load->out, load->out->dhint, ","target":0,"flaw_line_index":0,"hash":"76ec216d-1c10-42d2-83c9-4f1e3e43c5a5","idx":"223cc809-9e7d-49c2-88b6-b94c1198c7c5"}
{"func_before":"    Jsi_Value *va;\n\n    obj = _this->d.obj;\n    \n    argc = Jsi_ValueGetLength(interp, args);\n    curlen = Jsi_ObjGetLength(interp, obj);\n    if (curlen < 0) {\n        Jsi_ObjSetLength(interp, obj, 0);\n    }\n    Jsi_ObjListifyArray(interp, obj);\n   \n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    nsiz = obj->arrMaxSize;\n    if (nsiz<=0) nsiz = 100;","target":1,"flaw_line_index":0,"hash":"773b1c8b-6bfa-474f-a710-ecdfac0da2fe","idx":"872c4cc4-17a9-487f-abc5-4c910b58f495"}
{"func_before":"    Jsi_Value *va;\n\n    obj = _this->d.obj;\n    \n    argc = Jsi_ValueGetLength(interp, args);\n    curlen = jsi_SizeOfArray(interp, obj);\n    Jsi_ObjListifyArray(interp, obj);\n   \n    nobj = Jsi_ObjNewType(interp, JSI_OT_ARRAY);\n    nsiz = obj->arrMaxSize;\n    if (nsiz<=0) nsiz = 100;","target":0,"flaw_line_index":0,"hash":"5e1d7fe2-9186-4266-9772-afca75d3f4eb","idx":"18b00869-e748-42d5-89fc-ff4912797df7"}
{"func_before":"void perf_event_enable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct task_struct *task = ctx->task;\n\n\tif (!task) {\n\t\t\/*\n\t\t * Enable the event on the cpu that it's on\n\t\t *\/\n\t\tcpu_function_call(event->cpu, __perf_event_enable, event);\n\t\treturn;\n\t}\n\n\traw_spin_lock_irq(&ctx->lock);\n\tif (event->state >= PERF_EVENT_STATE_INACTIVE)\n\t\tgoto out;\n\n\t\/*\n\t * If the event is in error state, clear that first.\n\t * That way, if we see the event in error state below, we\n\t * know that it has gone back into error state, as distinct\n\t * from the task having been scheduled away before the\n\t * cross-call arrived.\n\t *\/\n\tif (event->state == PERF_EVENT_STATE_ERROR)\n\t\tevent->state = PERF_EVENT_STATE_OFF;\n\nretry:\n\tif (!ctx->is_active) {\n\t\t__perf_event_mark_enabled(event);\n\t\tgoto out;\n\t}\n\n\traw_spin_unlock_irq(&ctx->lock);\n\n\tif (!task_function_call(task, __perf_event_enable, event))\n\t\treturn;\n\n\traw_spin_lock_irq(&ctx->lock);\n\n\t\/*\n\t * If the context is active and the event is still off,\n\t * we need to retry the cross-call.\n\t *\/\n\tif (ctx->is_active && event->state == PERF_EVENT_STATE_OFF) {\n\t\t\/*\n\t\t * task could have been flipped by a concurrent\n\t\t * perf_event_context_sched_out()\n\t\t *\/\n\t\ttask = ctx->task;\n\t\tgoto retry;\n\t}\n\nout:\n\traw_spin_unlock_irq(&ctx->lock);\n}","target":1,"flaw_line_index":0,"hash":"4aafff68-9a82-47d1-8349-c3f813e125f2","idx":"b19b4794-d17a-4c66-9398-cea244d9fb46"}
{"func_before":"void perf_event_enable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx;\n\n\tctx = perf_event_ctx_lock(event);\n\t_perf_event_enable(event);\n\tperf_event_ctx_unlock(event, ctx);\n}","target":0,"flaw_line_index":0,"hash":"cc716398-fe1e-4092-9ccd-d88cba4ed630","idx":"a3f83617-64e6-4e5d-bcae-8078a20ae61c"}
{"func_before":"\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);","target":1,"flaw_line_index":0,"hash":"f5da8b8b-c446-4dab-af24-981dd5002bf8","idx":"8ebd1f12-6241-4cf3-841a-01f84f63bf7f"}
{"func_before":"\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);","target":0,"flaw_line_index":0,"hash":"eeec76d4-54ba-4e38-969d-2e8d4239d412","idx":"69d31d08-a769-478e-ba40-3b159d4c3504"}
{"func_before":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  const TfLiteTensor* axis = GetInput(context, node, kAxis);\n  \/\/ Make sure the axis is only 1 dimension.\n  TF_LITE_ENSURE_EQ(context, NumElements(axis), 1);\n  \/\/ Make sure the axis is only either int32 or int64.\n  TF_LITE_ENSURE(context,\n                 axis->type == kTfLiteInt32 || axis->type == kTfLiteInt64);\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  auto* params = reinterpret_cast<TfLiteArgMaxParams*>(node->builtin_data);\n  switch (params->output_type) {\n    case kTfLiteInt32:\n      output->type = kTfLiteInt32;","target":1,"flaw_line_index":0,"hash":"aecac47e-50b9-4a8a-afa8-20045bb05ac7","idx":"77e3df5e-5b7f-482b-89c5-24b23b84da49"}
{"func_before":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  const TfLiteTensor* axis;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kAxis, &axis));\n  \/\/ Make sure the axis is only 1 dimension.\n  TF_LITE_ENSURE_EQ(context, NumElements(axis), 1);\n  \/\/ Make sure the axis is only either int32 or int64.\n  TF_LITE_ENSURE(context,\n                 axis->type == kTfLiteInt32 || axis->type == kTfLiteInt64);\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  auto* params = reinterpret_cast<TfLiteArgMaxParams*>(node->builtin_data);\n  switch (params->output_type) {\n    case kTfLiteInt32:\n      output->type = kTfLiteInt32;","target":0,"flaw_line_index":0,"hash":"ca6d79c1-4ab8-426b-b03c-89419e1740e9","idx":"62911fd8-daf1-460e-908f-7e86b495c052"}
{"func_before":"\t * context, we must not take the fault..\n\t *\/\n        if (in_atomic() || !mm)\n                goto no_context;\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n\n\tdown_read(&mm->mmap_sem);\n\n\t\/*\n\t * The kernel referencing a bad kernel pointer can lock up\n\t\t\tgoto do_sigbus;\n\t\tBUG();\n\t}\n\tif (fault & VM_FAULT_MAJOR) {\n\t\tcurrent->maj_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n\t\t\t      regs, address);\n\t} else {\n\t\tcurrent->min_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n\t\t\t      regs, address);\n\t}\n\tup_read(&mm->mmap_sem);\n\treturn;\n\n\t\/*","target":1,"flaw_line_index":0,"hash":"62858f39-240f-4d56-8c5f-47aa70651cb1","idx":"8034ae5c-6564-4d4d-8da3-656f5764fed5"}
{"func_before":"\t * context, we must not take the fault..\n\t *\/\n        if (in_atomic() || !mm)\n                goto no_context;\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n\n\tdown_read(&mm->mmap_sem);\n\n\t\/*\n\t * The kernel referencing a bad kernel pointer can lock up\n\t\t\tgoto do_sigbus;\n\t\tBUG();\n\t}\n\tif (fault & VM_FAULT_MAJOR) {\n\t\tcurrent->maj_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, regs, address);\n\t} else {\n\t\tcurrent->min_flt++;\n\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, regs, address);\n\t}\n\tup_read(&mm->mmap_sem);\n\treturn;\n\n\t\/*","target":0,"flaw_line_index":0,"hash":"ba87cdb5-820d-4a24-9b1a-6399815fdbe9","idx":"5ae9692b-a980-4186-b0f8-570d80ddec65"}
{"func_before":"\t\/*\n\t * For link and rename lock the source entry and check the link count\n\t * to see if it has been removed while it was unlocked.\n\t *\/\n\tif (op == DE_LINK || op == DE_RENAME) {\n\t\tif (tp != dir)\n\t\t\trw_enter(&tp->tn_rwlock, RW_WRITER);\n\t\tmutex_enter(&tp->tn_tlock);\n\t\tif (tp->tn_nlink == 0) {\n\t\t\tmutex_exit(&tp->tn_tlock);\n\t\t\tif (tp != dir)\n\t\t\t\trw_exit(&tp->tn_rwlock);","target":1,"flaw_line_index":0,"hash":"bef5e743-e0af-4eea-aacf-5768f0c19746","idx":"ba92e8c2-838c-49f8-b068-9f9e9137f374"}
{"func_before":"\t\/*\n\t * For link and rename lock the source entry and check the link count\n\t * to see if it has been removed while it was unlocked.\n\t *\/\n\tif (op == DE_LINK || op == DE_RENAME) {\n\t\tif (tp != dir) {\n\t\t\tunsigned int tries = 0;\n\n\t\t\t\/*\n\t\t\t * If we are acquiring tp->tn_rwlock (for SOURCE)\n\t\t\t * inside here, we must consider the following:\n\t\t\t *\n\t\t\t * - dir->tn_rwlock (TARGET) is already HELD (see\n\t\t\t * above ASSERT()).\n\t\t\t *\n\t\t\t * - It is possible our SOURCE is a parent of our\n\t\t\t * TARGET. Yes it's unusual, but it will return an\n\t\t\t * error below via tdircheckpath().\n\t\t\t *\n\t\t\t * - It is also possible that another thread,\n\t\t\t * concurrent to this one, is performing\n\t\t\t * rmdir(TARGET), which means it will first acquire\n\t\t\t * SOURCE's lock, THEN acquire TARGET's lock, which\n\t\t\t * could result in this thread holding TARGET and\n\t\t\t * trying for SOURCE, but the other thread holding\n\t\t\t * SOURCE and trying for TARGET.  This is deadlock,\n\t\t\t * and it's inducible.\n\t\t\t *\n\t\t\t * To prevent this, we borrow some techniques from UFS\n\t\t\t * and rw_tryenter(), delaying if we fail, and\n\t\t\t * if someone tweaks the number of backoff tries to be\n\t\t\t * nonzero, return EBUSY after that number of tries.\n\t\t\t *\/\n\t\t\twhile (!rw_tryenter(&tp->tn_rwlock, RW_WRITER)) {\n\t\t\t\t\/*\n\t\t\t\t * Sloppy, but this is a diagnostic so atomic\n\t\t\t\t * increment would be overkill.\n\t\t\t\t *\/\n\t\t\t\ttmpfs_rename_loops++;\n\n\t\t\t\tif (tmpfs_rename_backoff_tries != 0) {\n\t\t\t\t\tif (tries > tmpfs_rename_backoff_tries)\n\t\t\t\t\t\treturn (EBUSY);\n\t\t\t\t\ttries++;\n\t\t\t\t}\n\t\t\t\t\/*\n\t\t\t\t * NOTE: We're still holding dir->tn_rwlock,\n\t\t\t\t * so drop it over the delay, so any other\n\t\t\t\t * thread can get its business done.\n\t\t\t\t *\n\t\t\t\t * No state change or state inspection happens\n\t\t\t\t * prior to here, so it is not wholly dangerous\n\t\t\t\t * to release-and-reacquire dir->tn_rwlock.\n\t\t\t\t *\n\t\t\t\t * Hold the vnode of dir in case it gets\n\t\t\t\t * released by another thread, though.\n\t\t\t\t *\/\n\t\t\t\tVN_HOLD(TNTOV(dir));\n\t\t\t\trw_exit(&dir->tn_rwlock);\n\t\t\t\tdelay(tmpfs_rename_backoff_delay);\n\t\t\t\trw_enter(&dir->tn_rwlock, RW_WRITER);\n\t\t\t\tVN_RELE(TNTOV(dir));\n\t\t\t}\n\t\t}\n\t\tmutex_enter(&tp->tn_tlock);\n\t\tif (tp->tn_nlink == 0) {\n\t\t\tmutex_exit(&tp->tn_tlock);\n\t\t\tif (tp != dir)\n\t\t\t\trw_exit(&tp->tn_rwlock);","target":0,"flaw_line_index":0,"hash":"29860039-883e-4f9b-b050-ace6f2753ecd","idx":"9b4f72a0-2825-4f5b-a4b4-677693b3b5c5"}
{"func_before":"void fb_exp_basic(fb_t c, const fb_t a, const bn_t b) {\n\tint i, l;\n\tfb_t r;\n\n\tif (bn_is_zero(b)) {\n\t\tfb_set_dig(c, 1);\n\t\treturn;\n\n\t\tl = bn_bits(b);\n\n\t\tfb_copy(r, a);\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tfb_sqr(r, r);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfb_mul(r, r, a);\n\t\t\t}\n\t\t}","target":1,"flaw_line_index":0,"hash":"0de9c7f4-9019-489c-8d38-f03ccf174123","idx":"a199d747-b8b1-4b12-84ff-5a2fd4f896f4"}
{"func_before":"void fb_exp_basic(fb_t c, const fb_t a, const bn_t b) {\n\tsize_t l;\n\tfb_t r;\n\n\tif (bn_is_zero(b)) {\n\t\tfb_set_dig(c, 1);\n\t\treturn;\n\n\t\tl = bn_bits(b);\n\n\t\tfb_copy(r, a);\n\n\t\tfor (int i = l - 2; i >= 0; i--) {\n\t\t\tfb_sqr(r, r);\n\t\t\tif (bn_get_bit(b, i)) {\n\t\t\t\tfb_mul(r, r, a);\n\t\t\t}\n\t\t}","target":0,"flaw_line_index":0,"hash":"f69b8dad-2ea0-4492-b8b9-3e8c5cf11e57","idx":"cba0afa8-eede-4993-ad8c-35d32abfa6a1"}
{"func_before":"static int em_jmp_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned short sel, old_sel;\n\tstruct desc_struct old_desc, new_desc;\n\tconst struct x86_emulate_ops *ops = ctxt->ops;\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\n\t\/* Assignment of RIP may only fail in 64-bit mode *\/\n\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\tops->get_segment(ctxt, &old_sel, &old_desc, NULL,\n\t\t\t\t VCPU_SREG_CS);\n\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\n\trc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_CALL_JMP,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = assign_eip_far(ctxt, ctxt->src.val, &new_desc);\n\tif (rc != X86EMUL_CONTINUE) {\n\t\tWARN_ON(ctxt->mode != X86EMUL_MODE_PROT64);\n\t\t\/* assigning eip failed; restore the old cs *\/\n\t\tops->set_segment(ctxt, old_sel, &old_desc, 0, VCPU_SREG_CS);\n\t\treturn rc;\n\t}\n\treturn rc;\n}","target":1,"flaw_line_index":0,"hash":"c2b8ae51-7074-4d9f-89a8-e16ca7b38736","idx":"b9a4efc2-4d86-4d4f-a9bb-652673580024"}
{"func_before":"static int em_jmp_far(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tunsigned short sel;\n\tstruct desc_struct new_desc;\n\tu8 cpl = ctxt->ops->cpl(ctxt);\n\n\tmemcpy(&sel, ctxt->src.valptr + ctxt->op_bytes, 2);\n\n\trc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl,\n\t\t\t\t       X86_TRANSFER_CALL_JMP,\n\t\t\t\t       &new_desc);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\n\trc = assign_eip_far(ctxt, ctxt->src.val, &new_desc);\n\t\/* Error handling is not implemented. *\/\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn X86EMUL_UNHANDLEABLE;\n\n\treturn rc;\n}","target":0,"flaw_line_index":0,"hash":"c1809fa0-ebed-4713-995a-10b966b12b30","idx":"254be9fc-b78b-48a9-bc2a-ce2bbf0bbf00"}
{"func_before":"static char *stibp_state(void)\n{\n\tif (spectre_v2_in_ibrs_mode(spectre_v2_enabled))\n\t\treturn \"\";\n\n\tswitch (spectre_v2_user_stibp) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\treturn \", STIBP: disabled\";","target":1,"flaw_line_index":0,"hash":"4a059da1-e58a-4671-a03b-fbe1f50d6fce","idx":"3e3656f7-f638-44fc-81f1-aac2e5d8b4b3"}
{"func_before":"static char *stibp_state(void)\n{\n\tif (spectre_v2_in_eibrs_mode(spectre_v2_enabled))\n\t\treturn \"\";\n\n\tswitch (spectre_v2_user_stibp) {\n\tcase SPECTRE_V2_USER_NONE:\n\t\treturn \", STIBP: disabled\";","target":0,"flaw_line_index":0,"hash":"9f4c4b17-4342-4051-87a2-a93884de2bef","idx":"3ef37eb7-9f4f-49bf-a8c8-f75def91c946"}
{"func_before":"{\n\tint err;\n\n\tprintk(KERN_INFO \"IPv6 over IPv4 tunneling driver\\n\");\n\n\tif (xfrm4_tunnel_register(&sit_handler, AF_INET6) < 0) {\n\t\tprintk(KERN_INFO \"sit init: Can't add protocol\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\terr = register_pernet_device(&sit_net_ops);\n\tif (err < 0)\n\t\txfrm4_tunnel_deregister(&sit_handler, AF_INET6);\n\n\treturn err;\n}","target":1,"flaw_line_index":0,"hash":"0ef89ed0-2673-43af-a1e2-9ac75a333d12","idx":"9d517692-61d0-4d87-b06e-95cc8ceafdce"}
{"func_before":"static int __init sit_init(void)\n{\n\tint err;\n\n\tprintk(KERN_INFO \"IPv6 over IPv4 tunneling driver\\n\");\n\n\terr = register_pernet_device(&sit_net_ops);\n\tif (err < 0)\n\t\treturn err;\n\terr = xfrm4_tunnel_register(&sit_handler, AF_INET6);\n\tif (err < 0) {\n\t\tunregister_pernet_device(&sit_net_ops);\n\t\tprintk(KERN_INFO \"sit init: Can't add protocol\\n\");\n\t}\n\treturn err;\n}","target":0,"flaw_line_index":0,"hash":"816fbff6-9011-47a3-89b7-a5733787d04a","idx":"6da61907-7daf-42e1-a805-f269b1a46848"}
{"func_before":"\t}\n\twhile (TRUE);\n\n\tif (finalNbRects != nbRects)\n\t{\n\t\tint allocSize = sizeof(REGION16_DATA) + (finalNbRects * sizeof(RECTANGLE_16));\n\t\tregion->data = realloc(region->data, allocSize);\n\n\t\tif (!region->data)\n\t\t{\n\t\t\tregion->data = &empty_region;\n\t\t\treturn FALSE;","target":1,"flaw_line_index":0,"hash":"22ecba49-7815-4760-aca8-23316af702c9","idx":"5e123322-4c09-4d6c-a679-22115ec76402"}
{"func_before":"\t}\n\twhile (TRUE);\n\n\tif (finalNbRects != nbRects)\n\t{\n\t\tREGION16_DATA* data;\n\t\tsize_t allocSize = sizeof(REGION16_DATA) + (finalNbRects * sizeof(RECTANGLE_16));\n\t\tdata = realloc(region->data, allocSize);\n\t\tif (!data)\n\t\t\tfree(region->data);\n\t\tregion->data = data;\n\n\t\tif (!region->data)\n\t\t{\n\t\t\tregion->data = &empty_region;\n\t\t\treturn FALSE;","target":0,"flaw_line_index":0,"hash":"0693dc55-e851-427c-86f4-fe000428a3bb","idx":"07ebb752-84df-4b82-971f-58714c9da346"}
{"func_before":"    APEContext *s = avctx->priv_data;\n    uint8_t *sample8;\n    int16_t *sample16;\n    int32_t *sample24;\n    int i, ch, ret;\n    int blockstodecode;\n\n    \/* this should never be negative, but bad things will happen if it is, so\n       check it just to make sure. *\/\n    av_assert0(s->samples >= 0);\n\n                skip_bits_long(&s->gb, offset * 8);\n            else\n                skip_bits_long(&s->gb, offset);\n        }\n\n        if (!nblocks || nblocks > INT_MAX) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid sample count: %\"PRIu32\".\\n\",\n                   nblocks);\n            return AVERROR_INVALIDDATA;\n        }\n\n    \/\/ so we need to decode all of them at once\n    if (s->fileversion < 3930)\n        blockstodecode = s->samples;\n\n    \/* reallocate decoded sample buffer if needed *\/\n    av_fast_malloc(&s->decoded_buffer, &s->decoded_size,\n                   2 * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer));\n    if (!s->decoded_buffer)\n        return AVERROR(ENOMEM);\n    memset(s->decoded_buffer, 0, s->decoded_size);\n    s->decoded[0] = s->decoded_buffer;\n    s->decoded[1] = s->decoded_buffer + FFALIGN(blockstodecode, 8);","target":1,"flaw_line_index":0,"hash":"79ba4ad2-c259-4107-abb7-b315458ab7a2","idx":"64facb8b-edb9-477a-a815-1527725eaf42"}
{"func_before":"    uint8_t *sample8;\n    int16_t *sample16;\n    int32_t *sample24;\n    int i, ch, ret;\n    int blockstodecode;\n    uint64_t decoded_buffer_size;\n\n    \/* this should never be negative, but bad things will happen if it is, so\n       check it just to make sure. *\/\n    av_assert0(s->samples >= 0);\n\n                skip_bits_long(&s->gb, offset * 8);\n            else\n                skip_bits_long(&s->gb, offset);\n        }\n\n        if (!nblocks || nblocks > INT_MAX \/ 2 \/ sizeof(*s->decoded_buffer) - 8) {\n            av_log(avctx, AV_LOG_ERROR, \"Invalid sample count: %\"PRIu32\".\\n\",\n                   nblocks);\n            return AVERROR_INVALIDDATA;\n        }\n\n    \/\/ so we need to decode all of them at once\n    if (s->fileversion < 3930)\n        blockstodecode = s->samples;\n\n    \/* reallocate decoded sample buffer if needed *\/\n    decoded_buffer_size = 2LL * FFALIGN(blockstodecode, 8) * sizeof(*s->decoded_buffer);\n    av_assert0(decoded_buffer_size <= INT_MAX);\n    av_fast_malloc(&s->decoded_buffer, &s->decoded_size, decoded_buffer_size);\n    if (!s->decoded_buffer)\n        return AVERROR(ENOMEM);\n    memset(s->decoded_buffer, 0, s->decoded_size);\n    s->decoded[0] = s->decoded_buffer;\n    s->decoded[1] = s->decoded_buffer + FFALIGN(blockstodecode, 8);","target":0,"flaw_line_index":0,"hash":"ee0c1024-1c24-4dfe-bd4d-97d23737f476","idx":"c6aa4172-eb18-4a99-bb36-d8cba74c0c09"}
{"func_before":"static int hexagon_v6_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {\n\tHexInsn hi = {0};;\n\tut32 data = 0;\n\tdata = r_read_le32 (buf);\n\tint size = hexagon_disasm_instruction (data, &hi, (ut32) addr);\n\top->size = size;\n\tif (size <= 0) {\n\t\treturn size;","target":1,"flaw_line_index":0,"hash":"b43aa86f-93b0-449a-b99e-7e9886f04394","idx":"eae369c1-7738-44a3-815f-135ce8997316"}
{"func_before":"static int hexagon_v6_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {\n\tHexInsn hi = {0};\n\tut32 data = 0;\n\tif (len < 4) {\n\t\treturn 0;\n\t}\n\tdata = r_read_le32 (buf);\n\tint size = hexagon_disasm_instruction (data, &hi, (ut32) addr);\n\top->size = size;\n\tif (size <= 0) {\n\t\treturn size;","target":0,"flaw_line_index":0,"hash":"7c88f490-a942-498b-8f33-bb4d42583dc3","idx":"008c2e3f-3887-412c-977f-d24b90abd0a8"}
{"func_before":"static int simulate_sync(struct pt_regs *regs, unsigned int opcode)\n{\n\tif ((opcode & OPCODE) == SPEC0 && (opcode & FUNC) == SYNC) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, 0, regs, 0);\n\t\treturn 0;\n\t}\n\n\treturn -1;\t\t\t\/* Must be something else ... *\/\n}","target":1,"flaw_line_index":0,"hash":"37ef574e-ec87-4752-96f8-a0afb3c62f41","idx":"8066cfe3-4a05-4d0b-a55b-2676b929d69e"}
{"func_before":"static int simulate_sync(struct pt_regs *regs, unsigned int opcode)\n{\n\tif ((opcode & OPCODE) == SPEC0 && (opcode & FUNC) == SYNC) {\n\t\tperf_sw_event(PERF_COUNT_SW_EMULATION_FAULTS,\n\t\t\t\t1, regs, 0);\n\t\treturn 0;\n\t}\n\n\treturn -1;\t\t\t\/* Must be something else ... *\/\n}","target":0,"flaw_line_index":0,"hash":"4debf11b-991a-493e-a5fe-015d838a0695","idx":"f552ed7d-8398-4380-9b57-e06896d0ffb3"}
{"func_before":"\t\t\tbits %= (RLC_DIG);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"reading and writing a positive number are consistent\") {\n\t\t\tint len = RLC_CEIL(RLC_BN_BITS, 8);\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tfor (int j = 2; j <= 64; j++) {\n\t\t\t\tbits = bn_size_str(a, j);\n\t\t\t\tbn_write_str(str, bits, a, j);\n\t\t\t\tbn_read_str(b, str, bits, j);\n\t\t\tTEST_ASSERT(bn_size_raw(a) == a->used, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"reading and writing a negative number are consistent\") {\n\t\t\tint len = RLC_CEIL(RLC_BN_BITS, 8);\n\t\t\tbn_rand(a, RLC_NEG, RLC_BN_BITS);\n\t\t\tfor (int j = 2; j <= 64; j++) {\n\t\t\t\tbits = bn_size_str(a, j);\n\t\t\t\tbn_write_str(str, bits, a, j);\n\t\t\t\tbn_read_str(b, str, bits, j);","target":1,"flaw_line_index":0,"hash":"61829966-9bc7-47f8-aaf2-e5387415d2f7","idx":"d89a0f72-eb38-47bb-a7cc-cb39a7f3171d"}
{"func_before":"\t\t\tbits %= (RLC_DIG);\n\t\t\tTEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);\n\t\t} TEST_END;\n\n\t\tTEST_CASE(\"reading and writing a positive number are consistent\") {\n\t\t\tsize_t len = RLC_CEIL(RLC_BN_BITS, 8);\n\t\t\tbn_rand(a, RLC_POS, RLC_BN_BITS);\n\t\t\tfor (int j = 2; j <= 64; j++) {\n\t\t\t\tbits = bn_size_str(a, j);\n\t\t\t\tbn_write_str(str, bits, a, j);\n\t\t\t\tbn_read_str(b, str, bits, j);\n\t\t\tTEST_ASSERT(bn_size_raw(a) == a->used, end);\n\t\t}\n\t\tTEST_END;\n\n\t\tTEST_CASE(\"reading and writing a negative number are consistent\") {\n\t\t\tsize_t len = RLC_CEIL(RLC_BN_BITS, 8);\n\t\t\tbn_rand(a, RLC_NEG, RLC_BN_BITS);\n\t\t\tfor (int j = 2; j <= 64; j++) {\n\t\t\t\tbits = bn_size_str(a, j);\n\t\t\t\tbn_write_str(str, bits, a, j);\n\t\t\t\tbn_read_str(b, str, bits, j);","target":0,"flaw_line_index":0,"hash":"5ea4c8d3-ba98-4c9f-98f8-b39b23f3767a","idx":"9148c4a9-9f84-42c7-93a2-5abb6dae4ce2"}
{"func_before":"\t\t\t\tnew->size = needle - str_start;\n\t\t\t\tnew->ordinal = count++;\n\t\t\t\t\/\/ TODO: move into adjust_offset\n\t\t\t\tswitch (str_type) {\n\t\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst ut8 *p = buf  + str_start - 2;\n\t\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\t\tstr_start -= 2; \/\/ \\xff\\xfe\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst ut8 *p = buf  + str_start - 4;\n\t\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\t\tstr_start -= 4; \/\/ \\xff\\xfe\\x00\\x00\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;","target":1,"flaw_line_index":0,"hash":"fcd100c2-bdb5-4561-b854-4c1b3228d4b3","idx":"3c9daa6d-8fc5-48e5-9a3b-c2f881d97989"}
{"func_before":"\t\t\t\tnew->size = needle - str_start;\n\t\t\t\tnew->ordinal = count++;\n\t\t\t\t\/\/ TODO: move into adjust_offset\n\t\t\t\tswitch (str_type) {\n\t\t\t\tcase R_STRING_TYPE_WIDE:\n\t\t\t\t\tif (str_start > 1) {\n\t\t\t\t\t\tconst ut8 *p = buf + str_start - 2;\n\t\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\t\tstr_start -= 2; \/\/ \\xff\\xfe\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_STRING_TYPE_WIDE32:\n\t\t\t\t\tif (str_start > 3) {\n\t\t\t\t\t\tconst ut8 *p = buf + str_start - 4;\n\t\t\t\t\t\tif (p[0] == 0xff && p[1] == 0xfe) {\n\t\t\t\t\t\t\tstr_start -= 4; \/\/ \\xff\\xfe\\x00\\x00\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;","target":0,"flaw_line_index":0,"hash":"6e9fe304-3823-4b64-8311-00151bd0258b","idx":"a67b811b-f279-459b-b9dd-b94f1988a6b7"}
{"func_before":"FdInStream::FdInStream(int fd_, int timeoutms_, int bufSize_,\n                       bool closeWhenDone_)\n  : fd(fd_), closeWhenDone(closeWhenDone_),\n    timeoutms(timeoutms_), blockCallback(0),\n    timing(false), timeWaitedIn100us(5), timedKbits(0),\n    bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)","target":1,"flaw_line_index":0,"hash":"b10edf82-3630-4157-b7d7-6a40caaedc74","idx":"a60045b2-7380-4a06-97fd-aacc04dea6db"}
{"func_before":"FdInStream::FdInStream(int fd_, int timeoutms_, size_t bufSize_,\n                       bool closeWhenDone_)\n  : fd(fd_), closeWhenDone(closeWhenDone_),\n    timeoutms(timeoutms_), blockCallback(0),\n    timing(false), timeWaitedIn100us(5), timedKbits(0),\n    bufSize(bufSize_ ? bufSize_ : DEFAULT_BUF_SIZE), offset(0)","target":0,"flaw_line_index":0,"hash":"e95d9def-8cd0-4b60-974b-9f79a3d962a5","idx":"c2775120-925c-44bc-b245-9fc474f05066"}
{"func_before":"{\n\tunsigned int __user *pc;\n\tmm_segment_t seg;\n\n\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS,\n\t\t\t1, 0, regs, regs->cp0_badvaddr);\n\t\/*\n\t * Did we catch a fault trying to load an instruction?\n\t * Or are we running in MIPS16 mode?\n\t *\/\n\tif ((regs->cp0_badvaddr == regs->cp0_epc) || (regs->cp0_epc & 0x1))","target":1,"flaw_line_index":0,"hash":"af355e26-9fbf-41de-b8c9-599f60e9de2e","idx":"05900c59-bf30-48d6-beda-f55f10bbdfc0"}
{"func_before":"{\n\tunsigned int __user *pc;\n\tmm_segment_t seg;\n\n\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS,\n\t\t\t1, regs, regs->cp0_badvaddr);\n\t\/*\n\t * Did we catch a fault trying to load an instruction?\n\t * Or are we running in MIPS16 mode?\n\t *\/\n\tif ((regs->cp0_badvaddr == regs->cp0_epc) || (regs->cp0_epc & 0x1))","target":0,"flaw_line_index":0,"hash":"f449cdc0-888d-40af-b4f2-782f630a63de","idx":"a5978fc9-3e71-4aaa-95b5-242597e7a719"}
{"func_before":"    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"\/msg Buddy1\");\n    assert_true(prof_output_exact(\"unencrypted\"));\n\n    stbbr_send(\n        \"<message type='chat' to='stabber@localhost\/profanity' from='buddy1@localhost'>\"\n            \"<received xmlns='urn:xmpp:carbons:2'>\"\n                \"<forwarded xmlns='urn:xmpp:forward:0'>\"\n                    \"<message id='prof_msg_7' xmlns='jabber:client' type='chat' lang='en' to='stabber@localhost\/profanity' from='buddy1@localhost\/mobile'>\"\n                        \"<body>test carbon from recipient<\/body>\"\n                    \"<\/message>\"","target":1,"flaw_line_index":0,"hash":"d148f6ca-50d7-4eb0-8c95-8d89170b47d5","idx":"5e3d2aea-c638-4505-b4c2-a15be2dd4ac6"}
{"func_before":"    assert_true(prof_output_exact(\"Buddy1 (mobile) is online, \\\"On my mobile\\\"\"));\n    prof_input(\"\/msg Buddy1\");\n    assert_true(prof_output_exact(\"unencrypted\"));\n\n    stbbr_send(\n        \"<message type='chat' to='stabber@localhost\/profanity' from='stabber@localhost'>\"\n            \"<received xmlns='urn:xmpp:carbons:2'>\"\n                \"<forwarded xmlns='urn:xmpp:forward:0'>\"\n                    \"<message id='prof_msg_7' xmlns='jabber:client' type='chat' lang='en' to='stabber@localhost\/profanity' from='buddy1@localhost\/mobile'>\"\n                        \"<body>test carbon from recipient<\/body>\"\n                    \"<\/message>\"","target":0,"flaw_line_index":0,"hash":"8884cd5e-2ad1-4814-ac01-6edf6277977d","idx":"48a7aa48-a190-40ce-b17b-82f8b21237f3"}
{"func_before":"find_entry_only(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n\tback_txn *txn\n)\n{\n\treturn( find_entry_internal( pb, be, addr, 0\/*!lock*\/, txn, FE_REALLY_INTERNAL ) );\n}","target":1,"flaw_line_index":0,"hash":"75369b39-a744-418a-917a-22a79f52a141","idx":"7ac3619b-365a-496a-9122-3bb828c93a1b"}
{"func_before":"find_entry_only(\n    Slapi_PBlock\t\t*pb,\n    Slapi_Backend *be,\n    const entry_address *addr,\n    back_txn *txn,\n    int *rc\n)\n{\n\treturn(find_entry_internal(pb, be, addr, 0\/*!lock*\/, txn, FE_REALLY_INTERNAL, rc));\n}","target":0,"flaw_line_index":0,"hash":"9e2f3216-8815-4b7c-a4c8-cff7345dadd8","idx":"45e62518-f043-460d-9b00-7424799e6d01"}
{"func_before":"{\n    for (int64_t lengthSum = 0, i = 0; i < W_ARRAY_SIZE; i++)\n    {\n        if (wArray[i] < 0)\n        {\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef,\n                \"Negative field length in XRef stream\");\n        }\n        if (numeric_limits<int64_t>::max() - lengthSum < wArray[i])\n        {\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef,\n                \"Invalid entry length in XRef stream\");\n        }\n        else\n        {\n            lengthSum += wArray[i];\n\n    charbuff buffer;\n    this->GetOrCreateStream().CopyTo(buffer);\n\n    vector<int64_t>::const_iterator it = indices.begin();\n    char* cursor = buffer.data();\n    while (it != indices.end())\n    {\n        int64_t firstObj = *it++;\n        int64_t count = *it++;\n\n        m_entries->Enlarge(firstObj + count);\n        for (unsigned index = 0; index < (unsigned)count; index++)\n        {\n            if ((size_t)(cursor - buffer.data()) >= buffer.size())\n                PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, \"Invalid count in XRef stream\");\n\n            unsigned objIndex = (unsigned)firstObj + index;\n            auto& entry = (*m_entries)[objIndex];\n            if (objIndex < m_entries->GetSize() && !entry.Parsed)\n                readXRefStreamEntry(entry, cursor, wArray);\n\n            cursor += entryLen;\n        }\n    }\n}","target":1,"flaw_line_index":0,"hash":"f3500f23-d500-48c9-8fc0-08e53a345fd0","idx":"3659b947-2503-4edc-bcb0-772992f23282"}
{"func_before":"{\n    for (int64_t lengthSum = 0, i = 0; i < W_ARRAY_SIZE; i++)\n    {\n        if (wArray[i] < 0)\n        {\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream,\n                \"Negative field length in XRef stream\");\n        }\n        if (numeric_limits<int64_t>::max() - lengthSum < wArray[i])\n        {\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream,\n                \"Invalid entry length in XRef stream\");\n        }\n        else\n        {\n            lengthSum += wArray[i];\n\n    charbuff buffer;\n    this->GetOrCreateStream().CopyTo(buffer);\n\n    vector<int64_t>::const_iterator it = indices.begin();\n    size_t offset = 0;\n    while (it != indices.end())\n    {\n        int64_t firstObj = *it++;\n        int64_t count = *it++;\n\n        if ((offset + count * entryLen) > buffer.size())\n            PODOFO_RAISE_ERROR_INFO(PdfErrorCode::InvalidXRefStream, \"Invalid count in XRef stream\");\n\n        m_entries->Enlarge(firstObj + count);\n        for (unsigned index = 0; index < (unsigned)count; index++)\n        {\n            unsigned objIndex = (unsigned)firstObj + index;\n            auto& entry = (*m_entries)[objIndex];\n            if (objIndex < m_entries->GetSize() && !entry.Parsed)\n                readXRefStreamEntry(entry, buffer.data() + offset, wArray);\n\n            offset += entryLen;\n        }\n    }\n}","target":0,"flaw_line_index":0,"hash":"779d8ea2-baab-47c0-acd5-ddefbd75d4cf","idx":"3a884b0e-86fd-4eff-8ccb-83d39964a5f9"}
{"func_before":"\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (**pp == NUL)\n\t    *lenp = 0;\n\tif (has_mbyte && *lenp > 0)\n\t    \/\/ Correct the length to include all bytes of the last character.\n\t    *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}","target":1,"flaw_line_index":0,"hash":"d93cee71-3a43-4637-9082-c8dc2007da67","idx":"6137cb28-2b01-4249-b641-473664af74e9"}
{"func_before":"\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (**pp == NUL)\n\t    *lenp = 0;\n\tif (*lenp > 0)\n\t{\n\t    if (has_mbyte)\n\t\t\/\/ Correct the length to include all bytes of the last\n\t\t\/\/ character.\n\t\t*lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n\t    else if ((*pp)[*lenp - 1] == NUL)\n\t\t\/\/ Do not include a trailing NUL.\n\t\t*lenp -= 1;\n\t}\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}","target":0,"flaw_line_index":0,"hash":"40fb736c-783a-40e0-be6d-284cee42ea35","idx":"3154f98d-4c01-470c-89e9-70c9a7b69a84"}
{"func_before":"  case 'f': \/* --force     *\/\n  case 's':                                     \/* --upgrade-system-tables *\/\n  case OPT_WRITE_BINLOG:                        \/* --write-binlog *\/\n    add_option= FALSE;\n    break;\n\n  case 'h': \/* --host *\/\n  case 'W': \/* --pipe *\/\n  case 'P': \/* --port *\/\n  case 'S': \/* --socket *\/\n  case OPT_MYSQL_PROTOCOL: \/* --protocol *\/","target":1,"flaw_line_index":0,"hash":"d52ddd73-1eff-4608-aee7-4d44fc6937bd","idx":"a44e89b5-9d97-43fb-a9fe-29ce957d5fb7"}
{"func_before":"  case 'f': \/* --force     *\/\n  case 's':                                     \/* --upgrade-system-tables *\/\n  case OPT_WRITE_BINLOG:                        \/* --write-binlog *\/\n    add_option= FALSE;\n    break;\n#include <sslopt-case.h>\n  case 'h': \/* --host *\/\n  case 'W': \/* --pipe *\/\n  case 'P': \/* --port *\/\n  case 'S': \/* --socket *\/\n  case OPT_MYSQL_PROTOCOL: \/* --protocol *\/","target":0,"flaw_line_index":0,"hash":"2e023d95-2335-4c5f-b104-62b6ba085f4c","idx":"2d54592d-666e-4985-97c1-20dac45486f3"}
{"func_before":"\tcase SMB2_READ:\n\t\t*off = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_WRITE:\n\t\tif (((struct smb2_write_req *)hdr)->DataOffset) {\n\t\t\t*off = le16_to_cpu(((struct smb2_write_req *)hdr)->DataOffset);\n\t\t\t*len = le32_to_cpu(((struct smb2_write_req *)hdr)->Length);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoOffset);","target":1,"flaw_line_index":0,"hash":"57c2d332-ad4c-4851-9b44-bfab01b09f88","idx":"2a31641a-d09d-449a-99b4-8d1b4967fbeb"}
{"func_before":"\tcase SMB2_READ:\n\t\t*off = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoOffset);\n\t\t*len = le16_to_cpu(((struct smb2_read_req *)hdr)->ReadChannelInfoLength);\n\t\tbreak;\n\tcase SMB2_WRITE:\n\t\tif (((struct smb2_write_req *)hdr)->DataOffset ||\n\t\t    ((struct smb2_write_req *)hdr)->Length) {\n\t\t\t*off = max_t(unsigned int,\n\t\t\t\t     le16_to_cpu(((struct smb2_write_req *)hdr)->DataOffset),\n\t\t\t\t     offsetof(struct smb2_write_req, Buffer));\n\t\t\t*len = le32_to_cpu(((struct smb2_write_req *)hdr)->Length);\n\t\t\tbreak;\n\t\t}\n\n\t\t*off = le16_to_cpu(((struct smb2_write_req *)hdr)->WriteChannelInfoOffset);","target":0,"flaw_line_index":0,"hash":"2868825b-cae9-4e7b-96be-3502ed8b865f","idx":"cca2612c-15f1-4242-8eb1-13d6708d0769"}
{"func_before":"        }\n      }\n      result += prot.readListEnd();\n      return result;\n    }\n    default:\n      return 0;\n  }\n}","target":1,"flaw_line_index":0,"hash":"58e7c0ba-dd70-4ba7-bc4c-f4c6d8ad5bd0","idx":"d0034b08-6316-4456-b8e8-39010d8f94a7"}
{"func_before":"        }\n      }\n      result += prot.readListEnd();\n      return result;\n    }\n    default: {\n      TProtocolException::throwInvalidSkipType(arg_type);\n    }\n  }\n}","target":0,"flaw_line_index":0,"hash":"1cdebb1f-84b7-4ad2-919d-3139ee929b4c","idx":"576525bb-6bb5-4623-bb64-cd49b8d1a175"}
{"func_before":"      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n        \/* system file *\/\n        if (memcmp(&name[2], &content_name[2], 31L) == 0) {\n          if (memcmp(&name[33], &content_name[33], 8L) == 0) {\n            chm->sec1.content = fi;\n          }\n          else if (memcmp(&name[33], &control_name[33], 11L) == 0) {\n            chm->sec1.control = fi;\n          }\n          else if (memcmp(&name[33], &spaninfo_name[33], 8L) == 0) {\n            chm->sec1.spaninfo = fi;\n          }\n          else if (memcmp(&name[33], &rtable_name[33], 72L) == 0) {\n            chm->sec1.rtable = fi;\n          }\n        }\n        fi->next = chm->sysfiles;\n        chm->sysfiles = fi;\n      }\n      else {","target":1,"flaw_line_index":0,"hash":"dec9b045-54d0-4308-8178-d7479613bd08","idx":"c8f1be8c-06a4-489c-b884-140f653a73c1"}
{"func_before":"      sys->copy(name, fi->filename, (size_t) name_len);\n      fi->filename[name_len] = '\\0';\n\n      if (name[0] == ':' && name[1] == ':') {\n        \/* system file *\/\n        if (name_len == 40 && memcmp(name, content_name, 40) == 0) {\n          chm->sec1.content = fi;\n        }\n        else if (name_len == 44 && memcmp(name, control_name, 44) == 0) {\n          chm->sec1.control = fi;\n        }\n        else if (name_len == 41 && memcmp(name, spaninfo_name, 41) == 0) {\n          chm->sec1.spaninfo = fi;\n        }\n        else if (name_len == 105 && memcmp(name, rtable_name, 105) == 0) {\n          chm->sec1.rtable = fi;\n        }\n        fi->next = chm->sysfiles;\n        chm->sysfiles = fi;\n      }\n      else {","target":0,"flaw_line_index":0,"hash":"7c598171-c8a5-4bf8-8e30-c492f95a12d7","idx":"f473bd90-b842-4661-88f3-0ffee2843eab"}
{"func_before":"int bn_size_bin(const bn_t a) {\n\tdig_t d;\n\tint digits;\n\n\tdigits = (a->used - 1) * (RLC_DIG \/ 8);\n\td = a->dp[a->used - 1];\n\n\twhile (d != 0) {\n\t\td = d >> 8;\n\t\tdigits++;\n\t}\n\treturn digits;\n}","target":1,"flaw_line_index":0,"hash":"37df85f6-ceec-412a-b190-302041daf8b9","idx":"d67bf650-63cd-49d1-874b-b8c51c182686"}
{"func_before":"size_t bn_size_bin(const bn_t a) {\n\tdig_t d;\n\tint digits;\n\n\tdigits = (a->used - 1) * (RLC_DIG \/ 8);\n\td = a->dp[a->used - 1];\n\n\twhile (d != 0) {\n\t\td = d >> 8;\n\t\tdigits++;\n\t}\n\treturn digits;\n}","target":0,"flaw_line_index":0,"hash":"ab8c4953-a5e1-4a8e-81e9-effa094af32e","idx":"780b31c1-0fda-454d-8f71-ad4158f0300e"}
{"func_before":"DSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,\n                                  RandomNumberGenerator& rng)\n   {\n   const BigInt& q = m_group.get_q();\n\n   BigInt i(msg, msg_len, q.bits());\n\n   while(i >= q)\n      i -= q;\n\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n   BOTAN_UNUSED(rng);\n   const BigInt k = generate_rfc6979_nonce(m_x, q, i, m_rfc6979_hash);\n#else\n   const BigInt k = BigInt::random_integer(rng, 1, q);\n#endif\n\n   BigInt s = inverse_mod(k, q);\n   const BigInt r = m_mod_q.reduce(m_group.power_g_p(k));\n\n   s = m_mod_q.multiply(s, mul_add(m_x, r, i));\n\n   \/\/ With overwhelming probability, a bug rather than actual zero r\/s\n   if(r.is_zero() || s.is_zero())\n      throw Internal_Error(\"Computed zero r\/s during DSA signature\");\n","target":1,"flaw_line_index":0,"hash":"fa31969b-5db0-457b-bb1c-a9481db6e247","idx":"fb8e40a1-8a10-465d-8ec3-5c90e4c7bf95"}
{"func_before":"DSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,\n                                  RandomNumberGenerator& rng)\n   {\n   const BigInt& q = m_group.get_q();\n\n   BigInt m(msg, msg_len, q.bits());\n\n   while(m >= q)\n      m -= q;\n\n#if defined(BOTAN_HAS_RFC6979_GENERATOR)\n   BOTAN_UNUSED(rng);\n   const BigInt k = generate_rfc6979_nonce(m_x, q, m, m_rfc6979_hash);\n#else\n   const BigInt k = BigInt::random_integer(rng, 1, q);\n#endif\n\n   const BigInt k_inv = inverse_mod(k, q);\n\n   const BigInt r = m_mod_q.reduce(m_group.power_g_p(k));\n\n   \/*\n   * Blind the input message and compute x*r+m as (x*r*b + m*b)\/b\n   *\/\n   m_b = m_mod_q.square(m_b);\n   m_b_inv = m_mod_q.square(m_b_inv);\n\n   m = m_mod_q.multiply(m_b, m);\n   const BigInt xr = m_mod_q.multiply(m_mod_q.multiply(m_x, m_b), r);\n\n   const BigInt s = m_mod_q.multiply(m_b_inv, m_mod_q.multiply(k_inv, xr + m));\n\n   \/\/ With overwhelming probability, a bug rather than actual zero r\/s\n   if(r.is_zero() || s.is_zero())\n      throw Internal_Error(\"Computed zero r\/s during DSA signature\");\n","target":0,"flaw_line_index":0,"hash":"fbf55287-26d6-4e6b-9f5c-ff977f814c15","idx":"f822fe99-407a-474f-813e-0d01618a1596"}
{"func_before":"String string_chunk_split(const char *src, int srclen, const char *end,\n                          int endlen, int chunklen) {\n  int chunks = srclen \/ chunklen; \/\/ complete chunks!\n  int restlen = srclen - chunks * chunklen; \/* srclen % chunklen *\/\n\n  int out_len = (chunks + 1) * endlen + srclen;\n  String ret(out_len, ReserveString);\n  char *dest = ret.bufferSlice().ptr;\n\n  const char *p; char *q;\n  const char *pMax = src + srclen - chunklen + 1;\n  for (p = src, q = dest; p < pMax; ) {","target":1,"flaw_line_index":0,"hash":"7563e468-b457-4c01-9647-81569bbcdb22","idx":"494aacfc-435b-43e3-bebf-9287820639a2"}
{"func_before":"String string_chunk_split(const char *src, int srclen, const char *end,\n                          int endlen, int chunklen) {\n  int chunks = srclen \/ chunklen; \/\/ complete chunks!\n  int restlen = srclen - chunks * chunklen; \/* srclen % chunklen *\/\n\n  String ret(\n    safe_address(\n      chunks + 1,\n      endlen,\n      srclen\n    ),\n    ReserveString\n  );\n  char *dest = ret.bufferSlice().ptr;\n\n  const char *p; char *q;\n  const char *pMax = src + srclen - chunklen + 1;\n  for (p = src, q = dest; p < pMax; ) {","target":0,"flaw_line_index":0,"hash":"d436b5c0-c967-4ac5-a0d6-9e6d78722a4f","idx":"399f3c0f-1c99-4e0c-a099-47f85def22df"}
{"func_before":"void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\tif (sk_hashed(sk)) {\n\t\twrite_lock_bh(&ping_table.lock);\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsk_nulls_node_init(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t\twrite_unlock_bh(&ping_table.lock);\n\t}\n}","target":1,"flaw_line_index":0,"hash":"2297db15-eb7d-461b-bf61-a3333213c37c","idx":"61e44550-b84a-46ab-8e26-41ee08d12db7"}
{"func_before":"void ping_unhash(struct sock *sk)\n{\n\tstruct inet_sock *isk = inet_sk(sk);\n\n\tpr_debug(\"ping_unhash(isk=%p,isk->num=%u)\\n\", isk, isk->inet_num);\n\twrite_lock_bh(&ping_table.lock);\n\tif (sk_hashed(sk)) {\n\t\thlist_nulls_del(&sk->sk_nulls_node);\n\t\tsk_nulls_node_init(&sk->sk_nulls_node);\n\t\tsock_put(sk);\n\t\tisk->inet_num = 0;\n\t\tisk->inet_sport = 0;\n\t\tsock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);\n\t}\n\twrite_unlock_bh(&ping_table.lock);\n}","target":0,"flaw_line_index":0,"hash":"26f17b5e-df0f-497d-b6f1-bbff2c839045","idx":"4ca9fd34-fc8b-49fd-9258-5f908e454f0d"}
{"func_before":"l2tp_ppp_discon_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tND_PRINT((ndo, \"%04x, \", EXTRACT_16BITS(ptr))); ptr++;\t\/* Disconnect Code *\/\n\tND_PRINT((ndo, \"%04x \",  EXTRACT_16BITS(ptr))); ptr++;\t\/* Control Protocol Number *\/\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_cc_direction2str,\n\t\t\t     \"Direction-#%u\", *((const u_char *)ptr++))));\n\n\tif (length > 5) {\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, (const u_char *)ptr, length-5);\n\t}\n}","target":1,"flaw_line_index":0,"hash":"514b9d86-d5d1-48cc-a075-4efa79dae16e","idx":"3731cc59-c9c2-4dfa-a757-f65ee35b70d8"}
{"func_before":"l2tp_ppp_discon_cc_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tif (length < 5) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\t\/* Disconnect Code *\/\n\tND_PRINT((ndo, \"%04x, \", EXTRACT_16BITS(dat)));\n\tdat += 2;\n\tlength -= 2;\n\t\/* Control Protocol Number *\/\n\tND_PRINT((ndo, \"%04x \",  EXTRACT_16BITS(dat)));\n\tdat += 2;\n\tlength -= 2;\n\t\/* Direction *\/\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_cc_direction2str,\n\t\t\t     \"Direction-#%u\", EXTRACT_8BITS(ptr))));\n\tptr++;\n\tlength--;\n\n\tif (length != 0) {\n\t\tND_PRINT((ndo, \" \"));\n\t\tprint_string(ndo, (const u_char *)ptr, length);\n\t}\n}","target":0,"flaw_line_index":0,"hash":"3396b788-2a5f-4694-b6cb-aebff8e3d8f7","idx":"1bab4b09-ec51-4851-bd55-14ce2fae142f"}
{"func_before":"    \/\/\n\n    previewHeight = max (int (h \/ (w * a) * previewWidth + .5f), 1);\n    previewPixels.resizeErase (previewHeight, previewWidth);\n\n    float fx = (previewWidth  > 0)? (float (w - 1) \/ (previewWidth  - 1)): 1;\n    float fy = (previewHeight > 0)? (float (h - 1) \/ (previewHeight - 1)): 1;\n    float m  = Math<float>::pow (2.f, IMATH_NAMESPACE::clamp (exposure + 2.47393f, -20.f, 20.f));\n\n    for (int y = 0; y < previewHeight; ++y)\n    {\n\tfor (int x = 0; x < previewWidth; ++x)","target":1,"flaw_line_index":0,"hash":"767ec999-78fe-41ad-ab09-49d6239f68bc","idx":"b2c2a1c7-16f9-4b42-8cec-370897935ce1"}
{"func_before":"    \/\/\n\n    previewHeight = max (int (h \/ (w * a) * previewWidth + .5f), 1);\n    previewPixels.resizeErase (previewHeight, previewWidth);\n\n    float fx = (previewWidth  > 1)? (float (w - 1) \/ (previewWidth  - 1)): 1;\n    float fy = (previewHeight > 1)? (float (h - 1) \/ (previewHeight - 1)): 1;\n    float m  = Math<float>::pow (2.f, IMATH_NAMESPACE::clamp (exposure + 2.47393f, -20.f, 20.f));\n\n    for (int y = 0; y < previewHeight; ++y)\n    {\n\tfor (int x = 0; x < previewWidth; ++x)","target":0,"flaw_line_index":0,"hash":"0a3b160d-d669-4c51-aaca-e7f1fbd66cf1","idx":"bf5814b6-7f19-4fdc-b911-309ddd17edd4"}
{"func_before":"bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela, ++relnum) {\n        unsigned const symnum = get_te64(&rela->r_info) >> 32;\n        char const *const symnam = get_dynsym_name(symnum, relnum);","target":1,"flaw_line_index":0,"hash":"828ab349-bc13-4ca4-ae8c-5d5b4ca0fac2","idx":"28702a8c-d780-486b-bf5d-d68c85d9f21e"}
{"func_before":"bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)\n{\n    if (!dynsym || !dynstr || !rela) {\n        return false;\n    }\n    for (unsigned relnum= 0; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela, ++relnum) {\n        unsigned const symnum = get_te64(&rela->r_info) >> 32;\n        char const *const symnam = get_dynsym_name(symnum, relnum);","target":0,"flaw_line_index":0,"hash":"d32a716f-b28a-4aa4-8dbf-4a00ef37e39d","idx":"d1e2abb7-8750-4e09-9a11-5d245000f07d"}
{"func_before":"               tok2str(arpop_values, \"Unknown (%u)\", op)));\n\n\tswitch (op) {\n\n\tcase ARPOP_REQUEST:\n\t\tND_PRINT((ndo, \"who-has %s\", ipaddr_string(ndo, ATMTPA(ap))));\n\t\tif (ATMTHRD_LEN(ap) != 0) {\n\t\t\tND_PRINT((ndo, \" (\"));\n\t\t\tatmarp_addr_print(ndo, ATMTHA(ap), ATMTHRD_LEN(ap),\n\t\t\t    ATMTSA(ap), ATMTSLN(ap));\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t}\n\t\tND_PRINT((ndo, \"tell %s\", ipaddr_string(ndo, ATMSPA(ap))));\n\t\tbreak;\n\n\tcase ARPOP_REPLY:\n\t\tND_PRINT((ndo, \"%s is-at \", ipaddr_string(ndo, ATMSPA(ap))));\n\t\tatmarp_addr_print(ndo, ATMSHA(ap), ATMSHRD_LEN(ap), ATMSSA(ap),\n                                  ATMSSLN(ap));\n\t\tbreak;\n\n\tcase ARPOP_INVREQUEST:\n\t\tbreak;\n\n\tcase ARPOP_INVREPLY:\n\t\tatmarp_addr_print(ndo, ATMSHA(ap), ATMSHRD_LEN(ap), ATMSSA(ap),\n\t\t    ATMSSLN(ap));\n\t\tND_PRINT((ndo, \"at %s\", ipaddr_string(ndo, ATMSPA(ap))));\n\t\tbreak;\n\n\tcase ARPOP_NAK:\n\t\tND_PRINT((ndo, \"for %s\", ipaddr_string(ndo, ATMSPA(ap))));\n\t\tbreak;\n\n\tdefault:\n\t\tND_DEFAULTPRINT((const u_char *)ap, caplen);\n\t\treturn;","target":1,"flaw_line_index":0,"hash":"84431412-0205-4ed6-a279-ba92d89914d9","idx":"06f9f619-3c07-4167-98f0-3fa024011e47"}
{"func_before":"               tok2str(arpop_values, \"Unknown (%u)\", op)));\n\n\tswitch (op) {\n\n\tcase ARPOP_REQUEST:\n\t\tND_PRINT((ndo, \"who-has \"));\n\t\tatmarp_tpaddr_print(ndo, ap, pro);\n\t\tif (ATMTHRD_LEN(ap) != 0) {\n\t\t\tND_PRINT((ndo, \" (\"));\n\t\t\tatmarp_addr_print(ndo, ATMTHA(ap), ATMTHRD_LEN(ap),\n\t\t\t    ATMTSA(ap), ATMTSLN(ap));\n\t\t\tND_PRINT((ndo, \")\"));\n\t\t}\n\t\tND_PRINT((ndo, \" tell \"));\n\t\tatmarp_spaddr_print(ndo, ap, pro);\n\t\tbreak;\n\n\tcase ARPOP_REPLY:\n\t\tatmarp_spaddr_print(ndo, ap, pro);\n\t\tND_PRINT((ndo, \" is-at \"));\n\t\tatmarp_addr_print(ndo, ATMSHA(ap), ATMSHRD_LEN(ap), ATMSSA(ap),\n                                  ATMSSLN(ap));\n\t\tbreak;\n\n\tcase ARPOP_INVREQUEST:\n\t\tbreak;\n\n\tcase ARPOP_INVREPLY:\n\t\tatmarp_addr_print(ndo, ATMSHA(ap), ATMSHRD_LEN(ap), ATMSSA(ap),\n\t\t    ATMSSLN(ap));\n\t\tND_PRINT((ndo, \"at \"));\n\t\tatmarp_spaddr_print(ndo, ap, pro);\n\t\tbreak;\n\n\tcase ARPOP_NAK:\n\t\tND_PRINT((ndo, \"for \"));\n\t\tatmarp_spaddr_print(ndo, ap, pro);\n\t\tbreak;\n\n\tdefault:\n\t\tND_DEFAULTPRINT((const u_char *)ap, caplen);\n\t\treturn;","target":0,"flaw_line_index":0,"hash":"2f489256-05db-4f38-85c5-8aa76c47efe4","idx":"48a60478-c41a-48fe-b3db-0c43fe86de3e"}
{"func_before":"\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t} else if (strstr(url, \"\/\") != url) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"No hostname was parsed and it does not seem to be relative, i.e starting with '\/': %s\",\n\t\t\t\t\t\turl);","target":1,"flaw_line_index":0,"hash":"d4177fd9-2048-4fbe-a2e2-8a7eea0ba4a7","idx":"b52cbd63-21ae-4dcb-be5a-a213004c61ce"}
{"func_before":"\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"logout value \\\"%s\\\" does not match the hostname of the current request \\\"%s\\\"\",\n\t\t\t\t\t\tapr_uri_unparse(r->pool, &uri, 0), c_host);\n\t\toidc_error(r, \"%s: %s\", *err_str, *err_desc);\n\t\treturn FALSE;\n\t} else if ((uri.hostname == NULL) && (strstr(url, \"\/\") != url)) {\n\t\t*err_str = apr_pstrdup(r->pool, \"Malformed URL\");\n\t\t*err_desc =\n\t\t\t\tapr_psprintf(r->pool,\n\t\t\t\t\t\t\"No hostname was parsed and it does not seem to be relative, i.e starting with '\/': %s\",\n\t\t\t\t\t\turl);","target":0,"flaw_line_index":0,"hash":"19eca5bf-19f1-49ea-bf64-1d302b679234","idx":"e262d3ad-03d8-48c9-98ff-524fb0783e51"}
{"func_before":"    RangeCoder *const c = &f->slice_context[0]->c;\n\n    memset(state, 128, sizeof(state));\n\n    if (f->version < 2) {\n        int chroma_planes, chroma_h_shift, chroma_v_shift, transparency;\n        unsigned v= get_symbol(c, state, 0);\n        if (v >= 2) {\n            av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);\n            return AVERROR_INVALIDDATA;\n        }\n        if (f->ac > 1) {\n            for (i = 1; i < 256; i++)\n                f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];\n        }\n\n        f->colorspace = get_symbol(c, state, 0); \/\/YUV cs type\n\n        if (f->version > 0)\n            f->avctx->bits_per_raw_sample = get_symbol(c, state, 0);\n\n        chroma_planes  = get_rac(c, state);\n        chroma_h_shift = get_symbol(c, state, 0);\n        chroma_v_shift = get_symbol(c, state, 0);\n        transparency   = get_rac(c, state);\n\n        if (f->plane_count) {\n            if (   chroma_planes != f->chroma_planes\n                || chroma_h_shift!= f->chroma_h_shift\n                || chroma_v_shift!= f->chroma_v_shift\n                || transparency  != f->transparency) {\n                av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        f->chroma_planes  = chroma_planes;\n        f->chroma_h_shift = chroma_h_shift;\n        f->chroma_v_shift = chroma_v_shift;\n        f->transparency   = transparency;\n","target":1,"flaw_line_index":0,"hash":"d83deb8b-62ec-4aaf-bb9a-0788ea9215c9","idx":"081b8e19-ef96-45eb-befd-b190d60598eb"}
{"func_before":"    RangeCoder *const c = &f->slice_context[0]->c;\n\n    memset(state, 128, sizeof(state));\n\n    if (f->version < 2) {\n        int chroma_planes, chroma_h_shift, chroma_v_shift, transparency, colorspace, bits_per_raw_sample;\n        unsigned v= get_symbol(c, state, 0);\n        if (v >= 2) {\n            av_log(f->avctx, AV_LOG_ERROR, \"invalid version %d in ver01 header\\n\", v);\n            return AVERROR_INVALIDDATA;\n        }\n        if (f->ac > 1) {\n            for (i = 1; i < 256; i++)\n                f->state_transition[i] = get_symbol(c, state, 1) + c->one_state[i];\n        }\n\n        colorspace     = get_symbol(c, state, 0); \/\/YUV cs type\n        bits_per_raw_sample = f->version > 0 ? get_symbol(c, state, 0) : f->avctx->bits_per_raw_sample;\n        chroma_planes  = get_rac(c, state);\n        chroma_h_shift = get_symbol(c, state, 0);\n        chroma_v_shift = get_symbol(c, state, 0);\n        transparency   = get_rac(c, state);\n\n        if (f->plane_count) {\n            if (   colorspace    != f->colorspace\n                || bits_per_raw_sample != f->avctx->bits_per_raw_sample\n                || chroma_planes != f->chroma_planes\n                || chroma_h_shift!= f->chroma_h_shift\n                || chroma_v_shift!= f->chroma_v_shift\n                || transparency  != f->transparency) {\n                av_log(f->avctx, AV_LOG_ERROR, \"Invalid change of global parameters\\n\");\n                return AVERROR_INVALIDDATA;\n            }\n        }\n\n        f->colorspace     = colorspace;\n        f->avctx->bits_per_raw_sample = bits_per_raw_sample;\n        f->chroma_planes  = chroma_planes;\n        f->chroma_h_shift = chroma_h_shift;\n        f->chroma_v_shift = chroma_v_shift;\n        f->transparency   = transparency;\n","target":0,"flaw_line_index":0,"hash":"7bd3ba84-b9b2-49f0-9d78-90139865af5b","idx":"d2387770-a8ef-4b2f-8c1f-b55de7228f8e"}
{"func_before":"  \/\/ Set trace context header to backend.\n  Status status = request()->AddHeaderToBackend(\n      cloud_trace()->header_type() == HeaderType::CLOUD_TRACE_CONTEXT\n          ? kCloudTraceContextHeader\n          : kGRpcTraceContextHeader,\n      trace_context_header);\n  if (!status.ok()) {\n    service_context()->env()->LogError(\n        \"Failed to set trace context header to backend.\");\n  }\n}","target":1,"flaw_line_index":0,"hash":"34f66b77-a475-4622-b985-6855284bd319","idx":"67a92714-c36f-4855-a063-a3bc07ea10bc"}
{"func_before":"  \/\/ Set trace context header to backend.\n  Status status = request()->AddHeaderToBackend(\n      cloud_trace()->header_type() == HeaderType::CLOUD_TRACE_CONTEXT\n          ? kCloudTraceContextHeader\n          : kGRpcTraceContextHeader,\n      trace_context_header, false);\n  if (!status.ok()) {\n    service_context()->env()->LogError(\n        \"Failed to set trace context header to backend.\");\n  }\n}","target":0,"flaw_line_index":0,"hash":"e497b3fa-34b6-4bcd-b9d8-a3e8fe30cae5","idx":"932ea2cd-bcc0-4b6a-af93-9b0d4a7c1825"}
{"func_before":"void HTML_put_string(HTStructured * me, const char *s)\n{\n#ifdef USE_PRETTYSRC\n    char *translated_string = NULL;\n#endif\n\n    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))\n\n    case HTML_COMMENT:\n\tbreak;\t\t\t\/* Do Nothing *\/\n\n    case HTML_TITLE:\n\tHTChunkPuts(&me->title, s);\n\tbreak;\n\n    case HTML_STYLE:\n\tHTChunkPuts(&me->style_block, s);\n\tbreak;\n\n    case HTML_SCRIPT:\n\tHTChunkPuts(&me->script, s);\n\tbreak;\n\n    case HTML_PRE:\t\t\/* Formatted text *\/\n    case HTML_LISTING:\t\t\/* Literal text *\/\n    case HTML_XMP:\n\t *\/\n\tHText_appendText(me->text, s);\n\tbreak;\n\n    case HTML_OBJECT:\n\tHTChunkPuts(&me->object, s);\n\tbreak;\n\n    case HTML_TEXTAREA:\n\tHTChunkPuts(&me->textarea, s);\n\tbreak;\n\n    case HTML_SELECT:\n    case HTML_OPTION:\n\tHTChunkPuts(&me->option, s);\n\tbreak;\n\n    case HTML_MATH:\n\tHTChunkPuts(&me->math, s);\n\tbreak;\n\n    default:\t\t\t\/* Free format text? *\/\n\tif (!me->sp->style->freeFormat) {\n\t    \/*\n\t\t    HText_setLastChar(me->text, c);\n\t\t}\n\n\t    }\t\t\t\/* for *\/\n\t}\n    }\t\t\t\t\/* end switch *\/\n#ifdef USE_PRETTYSRC\n    if (psrc_convert_string) {\n\tpsrc_convert_string = FALSE;\n\tFREE(translated_string);\n    }","target":1,"flaw_line_index":0,"hash":"2505015a-f65c-4985-af35-e81d53e38b6e","idx":"5a8a18fd-7293-4930-a15b-8834c58e317f"}
{"func_before":"void HTML_put_string(HTStructured * me, const char *s)\n{\n    HTChunk *target = NULL;\n\n#ifdef USE_PRETTYSRC\n    char *translated_string = NULL;\n#endif\n\n    if (s == NULL || (LYMapsOnly && me->sp[0].tag_number != HTML_OBJECT))\n\n    case HTML_COMMENT:\n\tbreak;\t\t\t\/* Do Nothing *\/\n\n    case HTML_TITLE:\n\ttarget = &me->title;\n\tbreak;\n\n    case HTML_STYLE:\n\ttarget = &me->style_block;\n\tbreak;\n\n    case HTML_SCRIPT:\n\ttarget = &me->script;\n\tbreak;\n\n    case HTML_PRE:\t\t\/* Formatted text *\/\n    case HTML_LISTING:\t\t\/* Literal text *\/\n    case HTML_XMP:\n\t *\/\n\tHText_appendText(me->text, s);\n\tbreak;\n\n    case HTML_OBJECT:\n\ttarget = &me->object;\n\tbreak;\n\n    case HTML_TEXTAREA:\n\ttarget = &me->textarea;\n\tbreak;\n\n    case HTML_SELECT:\n    case HTML_OPTION:\n\ttarget = &me->option;\n\tbreak;\n\n    case HTML_MATH:\n\ttarget = &me->math;\n\tbreak;\n\n    default:\t\t\t\/* Free format text? *\/\n\tif (!me->sp->style->freeFormat) {\n\t    \/*\n\t\t}\n\n\t    }\t\t\t\/* for *\/\n\t}\n    }\t\t\t\t\/* end switch *\/\n\n    if (target != NULL) {\n\tif (target->data == s) {\n\t    CTRACE((tfp, \"BUG: appending chunk to itself: `%.*s'\\n\",\n\t\t    target->size, target->data));\n\t} else {\n\t    HTChunkPuts(target, s);\n\t}\n    }\n#ifdef USE_PRETTYSRC\n    if (psrc_convert_string) {\n\tpsrc_convert_string = FALSE;\n\tFREE(translated_string);\n    }","target":0,"flaw_line_index":0,"hash":"6dd1582f-888d-4df8-b6e2-5841e8a67584","idx":"3a1a04ac-6016-42f4-a341-43d3357186cb"}
{"func_before":"\tint hoplen;\n\tconst char *type;\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"[bad length %u]\", length));\n\t\treturn;\n\t}\n\tND_PRINT((ndo, \" TS{\"));\n\thoplen = ((cp[3]&0xF) != IPOPT_TS_TSONLY) ? 8 : 4;\n\tif ((length - 4) & (hoplen-1))\n\t\tND_PRINT((ndo, \"[bad length %u]\", length));\n\tptr = cp[2] - 1;\n\tlen = 0;\n\tif (ptr < 4 || ((ptr - 4) & (hoplen-1)) || ptr > length + 1)\n\t\tND_PRINT((ndo, \"[bad ptr %u]\", cp[2]));\n\tswitch (cp[3]&0xF) {\n\tcase IPOPT_TS_TSONLY:\n\t\tND_PRINT((ndo, \"TSONLY\"));\n\t\tbreak;\n\tcase IPOPT_TS_TSANDADDR:\n\t}\n\n\ttype = \" \";\n\tfor (len = 4; len < length; len += hoplen) {\n\t\tif (ptr == len)\n\t\t\ttype = \" ^ \";\n\t\tND_PRINT((ndo, \"%s%d@%s\", type, EXTRACT_32BITS(&cp[len+hoplen-4]),\n\t\t       hoplen!=8 ? \"\" : ipaddr_string(ndo, &cp[len])));\n\t\ttype = \" \";\n\t}\n\n\tND_PRINT((ndo, \"%s\", ptr == len ? \" ^ \" : \"\"));\n\n\tif (cp[3]>>4)\n\t\tND_PRINT((ndo, \" [%d hops not recorded]} \", cp[3]>>4));\n\telse\n\t\tND_PRINT((ndo, \"}\"));\n}","target":1,"flaw_line_index":0,"hash":"1ff28910-0041-4cf0-a95f-80f903f849b8","idx":"1b0b6a13-f3bd-407e-a36b-15d662be5bbb"}
{"func_before":"\tint hoplen;\n\tconst char *type;\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"[bad length %u]\", length));\n\t\treturn (0);\n\t}\n\tND_PRINT((ndo, \" TS{\"));\n\thoplen = ((cp[3]&0xF) != IPOPT_TS_TSONLY) ? 8 : 4;\n\tif ((length - 4) & (hoplen-1))\n\t\tND_PRINT((ndo, \"[bad length %u]\", length));\n\tND_TCHECK(cp[2]);\n\tptr = cp[2] - 1;\n\tlen = 0;\n\tif (ptr < 4 || ((ptr - 4) & (hoplen-1)) || ptr > length + 1)\n\t\tND_PRINT((ndo, \"[bad ptr %u]\", cp[2]));\n\tND_TCHECK(cp[3]);\n\tswitch (cp[3]&0xF) {\n\tcase IPOPT_TS_TSONLY:\n\t\tND_PRINT((ndo, \"TSONLY\"));\n\t\tbreak;\n\tcase IPOPT_TS_TSANDADDR:\n\n\ttype = \" \";\n\tfor (len = 4; len < length; len += hoplen) {\n\t\tif (ptr == len)\n\t\t\ttype = \" ^ \";\n\t\tND_TCHECK2(cp[len], hoplen);\n\t\tND_PRINT((ndo, \"%s%d@%s\", type, EXTRACT_32BITS(&cp[len+hoplen-4]),\n\t\t       hoplen!=8 ? \"\" : ipaddr_string(ndo, &cp[len])));\n\t\ttype = \" \";\n\t}\n\n\n\tif (cp[3]>>4)\n\t\tND_PRINT((ndo, \" [%d hops not recorded]} \", cp[3]>>4));\n\telse\n\t\tND_PRINT((ndo, \"}\"));\n\treturn (0);\n\ntrunc:\n\treturn (-1);\n}","target":0,"flaw_line_index":0,"hash":"65d8c434-4482-4ad4-b612-1b056e5d7a5e","idx":"38f56cd9-d2e0-4de8-a443-64bf2d8472e3"}
{"func_before":"void ion_free(struct ion_client *client, struct ion_handle *handle)\n{\n\tbool valid_handle;\n\n\tBUG_ON(client != handle->client);\n\n\tmutex_lock(&client->lock);\n\tvalid_handle = ion_handle_validate(client, handle);\n\n\tif (!valid_handle) {\n\t\tWARN(1, \"%s: invalid handle passed to free.\\n\", __func__);\n\t\tmutex_unlock(&client->lock);\n\t\treturn;\n\t}\n\tmutex_unlock(&client->lock);\n\tion_handle_put(handle);\n}","target":1,"flaw_line_index":0,"hash":"f5bce332-f884-49d4-9342-c03a780d89a1","idx":"d59a70f6-1d73-4978-8fe4-575dbc788dde"}
{"func_before":"void ion_free(struct ion_client *client, struct ion_handle *handle)\n{\n\tBUG_ON(client != handle->client);\n\n\tmutex_lock(&client->lock);\n\tion_free_nolock(client, handle);\n\tmutex_unlock(&client->lock);\n}","target":0,"flaw_line_index":0,"hash":"c8e52296-8ebb-431a-83c2-06817e87a459","idx":"8d0a1432-6412-4578-a2dc-134c2c4e16fb"}
{"func_before":"\t\t\t\t\telse if (ctx->avc_state->sei.pic_timing.pic_struct == 8)\n\t\t\t\t\t\tDeltaTfiDivisorIdx = 6;\n\t\t\t\t\telse\n\t\t\t\t\t\tDeltaTfiDivisorIdx = (ctx->avc_state->sei.pic_timing.pic_struct+1) \/ 2;\n\t\t\t\t}\n\t\t\t\tif (ctx->notime && sps->vui.time_scale && sps->vui.num_units_in_tick) {\n\t\t\t\t\tctx->cur_fps.num = 2 * sps->vui.time_scale;\n\t\t\t\t\tctx->cur_fps.den = 2 * sps->vui.num_units_in_tick * DeltaTfiDivisorIdx;\n\n\t\t\t\t\tif (!ctx->fps.num && ctx->dts==ctx->fps.den)\n\t\t\t\t\t\tctx->dts = ctx->cur_fps.den;\n\t\t\t\t}\n\t\t\t\tif (! sps->vui.fixed_frame_rate_flag)\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[%s] Possible Variable Frame Rate: VUI \\\"fixed_frame_rate_flag\\\" absent\\n\", ctx->log_name));","target":1,"flaw_line_index":0,"hash":"36f6440d-c37b-4b87-8834-3877897d2e12","idx":"67b49d1b-4b05-499f-9e54-b77e8aeeee6d"}
{"func_before":"\t\t\t\t\telse if (ctx->avc_state->sei.pic_timing.pic_struct == 8)\n\t\t\t\t\t\tDeltaTfiDivisorIdx = 6;\n\t\t\t\t\telse\n\t\t\t\t\t\tDeltaTfiDivisorIdx = (ctx->avc_state->sei.pic_timing.pic_struct+1) \/ 2;\n\t\t\t\t}\n\t\t\t\tif (ctx->notime) {\n\t\t\t\t\tu32 fps_num = 2 * sps->vui.time_scale;\n\t\t\t\t\tu32 fps_den = 2 * sps->vui.num_units_in_tick * DeltaTfiDivisorIdx;\n\t\t\t\t\tif (fps_num && fps_den) {\n\t\t\t\t\t\tctx->cur_fps.num = fps_num;\n\t\t\t\t\t\tctx->cur_fps.den = fps_den;\n\t\t\t\t\t}\n\t\t\t\t\tif (!ctx->fps.num && ctx->dts==ctx->fps.den)\n\t\t\t\t\t\tctx->dts = ctx->cur_fps.den;\n\t\t\t\t}\n\t\t\t\tif (! sps->vui.fixed_frame_rate_flag)\n\t\t\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (\"[%s] Possible Variable Frame Rate: VUI \\\"fixed_frame_rate_flag\\\" absent\\n\", ctx->log_name));","target":0,"flaw_line_index":0,"hash":"e2666aeb-843e-4fbb-86e7-26638a611bf9","idx":"148b01d5-39a6-4655-8bb3-2162f9e13f52"}
{"func_before":"FileInformation ImageReadJPEGInfo( String const& filename ) {\n   JpegInput jpeg( filename );\n   FileInformation info = GetJPEGInfo( jpeg );\n   return info;\n}","target":1,"flaw_line_index":0,"hash":"000c90a0-0a72-437d-9c6e-55bfa62a717c","idx":"8e73a0cd-c32d-4510-84e6-cc6e52d16e83"}
{"func_before":"FileInformation ImageReadJPEGInfo( String const& filename ) {\n   DIP__DECLARE_JPEG_EXIT( \"Error reading JPEG file\" );\n   JpegInput jpeg( filename, setjmp_buffer );\n   FileInformation info = GetJPEGInfo( jpeg );\n   return info;\n}","target":0,"flaw_line_index":0,"hash":"ca932b41-ffed-485e-87f1-5dc7d4882ec7","idx":"dbc2bb25-9d78-4c7e-b762-5e19fb1f380b"}
{"func_before":"  *outptr = NULL;\n  ulen = strlen(userp);\n  plen = strlen(passwdp);\n\n  \/* Compute binary message length. Check for overflows. *\/\n  if((ulen > SIZE_T_MAX\/2) || (plen > (SIZE_T_MAX\/2 - 2)))\n    return CURLE_OUT_OF_MEMORY;\n  plainlen = 2 * ulen + plen + 2;\n\n  plainauth = malloc(plainlen);\n  if(!plainauth)","target":1,"flaw_line_index":0,"hash":"4a315b7d-7950-46cb-b1e8-370772a1b2a2","idx":"14030fd0-f5c3-4bb3-9b18-c6d9acbb8107"}
{"func_before":"  *outptr = NULL;\n  ulen = strlen(userp);\n  plen = strlen(passwdp);\n\n  \/* Compute binary message length. Check for overflows. *\/\n  if((ulen > SIZE_T_MAX\/4) || (plen > (SIZE_T_MAX\/2 - 2)))\n    return CURLE_OUT_OF_MEMORY;\n  plainlen = 2 * ulen + plen + 2;\n\n  plainauth = malloc(plainlen);\n  if(!plainauth)","target":0,"flaw_line_index":0,"hash":"1091f53f-24f0-4f83-ad40-5d36f3d96124","idx":"5b15bc06-d603-4fda-8b5c-1dfb48769204"}
{"func_before":"int performRtspHandshake(void) {\n    int ret;\n\n    \/\/ HACK: In order to get GFE to respect our request for a lower audio bitrate, we must\n    \/\/ fake our target address so it doesn't match any of the PC's local interfaces. It seems\n    \/\/ that the only way to get it to give you \"low quality\" stereo audio nowadays is if it\n    \/\/ thinks you are remote (target address != any local address).\n    if (OriginalVideoBitrate >= HIGH_AUDIO_BITRATE_THRESHOLD &&\n            (AudioCallbacks.capabilities & CAPABILITY_SLOW_OPUS_DECODER) == 0) {\n        addrToUrlSafeString(&RemoteAddr, urlAddr);\n    }\n    else {\n        strcpy(urlAddr, \"0.0.0.0\");\n    }\n\n    LC_ASSERT(RtspPortNumber != 0);\n\n    \/\/ Initialize global state\n    useEnet = (AppVersionQuad[0] >= 5) && (AppVersionQuad[0] <= 7) && (AppVersionQuad[2] < 404);\n    sprintf(rtspTargetUrl, \"rtsp%s:\/\/%s:%u\", useEnet ? \"ru\" : \"\", urlAddr, RtspPortNumber);\n    currentSeqNumber = 1;\n    hasSessionId = false;\n    controlStreamId = APP_VERSION_AT_LEAST(7, 1, 431) ? \"streamid=control\/13\/0\" : \"streamid=control\/1\/0\";\n    AudioEncryptionEnabled = false;\n\n    switch (AppVersionQuad[0]) {\n        case 3:\n            rtspClientVersion = 10;\n            break;","target":1,"flaw_line_index":0,"hash":"65715fcc-401d-4597-ab93-0e64fc476b3f","idx":"eec2cca0-87b0-41c9-8ca7-66a9243de784"}
{"func_before":"int performRtspHandshake(PSERVER_INFORMATION serverInfo) {\n    int ret;\n\n    LC_ASSERT(RtspPortNumber != 0);\n\n    \/\/ Initialize global state\n    useEnet = (AppVersionQuad[0] >= 5) && (AppVersionQuad[0] <= 7) && (AppVersionQuad[2] < 404);\n    currentSeqNumber = 1;\n    hasSessionId = false;\n    controlStreamId = APP_VERSION_AT_LEAST(7, 1, 431) ? \"streamid=control\/13\/0\" : \"streamid=control\/1\/0\";\n    AudioEncryptionEnabled = false;\n\n    \/\/ HACK: In order to get GFE to respect our request for a lower audio bitrate, we must\n    \/\/ fake our target address so it doesn't match any of the PC's local interfaces. It seems\n    \/\/ that the only way to get it to give you \"low quality\" stereo audio nowadays is if it\n    \/\/ thinks you are remote (target address != any local address).\n    \/\/\n    \/\/ We will enable high quality audio if the following are all true:\n    \/\/ 1. Video bitrate is higher than 15 Mbps (to ensure most bandwidth is reserved for video)\n    \/\/ 2. The audio decoder has not declared that it is slow\n    \/\/ 3. The stream is either local or not surround sound (to prevent MTU issues over the Internet)\n    LC_ASSERT(StreamConfig.streamingRemotely != STREAM_CFG_AUTO);\n    if (OriginalVideoBitrate >= HIGH_AUDIO_BITRATE_THRESHOLD &&\n            (AudioCallbacks.capabilities & CAPABILITY_SLOW_OPUS_DECODER) == 0 &&\n            (StreamConfig.streamingRemotely != STREAM_CFG_REMOTE || CHANNEL_COUNT_FROM_AUDIO_CONFIGURATION(StreamConfig.audioConfiguration) <= 2)) {\n        \/\/ If we have an RTSP URL string and it was successfully parsed, use that string\n        if (serverInfo->rtspSessionUrl != NULL && parseUrlAddrFromRtspUrlString(serverInfo->rtspSessionUrl, urlAddr)) {\n            strcpy(rtspTargetUrl, serverInfo->rtspSessionUrl);\n        }\n        else {\n            \/\/ If an RTSP URL string was not provided or failed to parse, we will construct one now as best we can.\n            \/\/\n            \/\/ NB: If the remote address is not a LAN address, the host will likely not enable high quality\n            \/\/ audio since it only does that for local streaming normally. We can avoid this limitation,\n            \/\/ but only if the caller gave us the RTSP session URL that it received from the host during launch.\n            addrToUrlSafeString(&RemoteAddr, urlAddr);\n            sprintf(rtspTargetUrl, \"rtsp%s:\/\/%s:%u\", useEnet ? \"ru\" : \"\", urlAddr, RtspPortNumber);\n        }\n    }\n    else {\n        strcpy(urlAddr, \"0.0.0.0\");\n        sprintf(rtspTargetUrl, \"rtsp%s:\/\/%s:%u\", useEnet ? \"ru\" : \"\", urlAddr, RtspPortNumber);\n    }\n\n    switch (AppVersionQuad[0]) {\n        case 3:\n            rtspClientVersion = 10;\n            break;","target":0,"flaw_line_index":0,"hash":"51f7855c-8464-464f-940c-219175d5ab40","idx":"25f7f003-4982-43cc-a9e6-1e582ff429c2"}
{"func_before":"        if (key_bytes_len < 16) {\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n    }\n\n    if (key_bytes_len < GROUP_KEY_MIN_LEN || key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY)) {\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n\n    \/* Encrypted key is in the information element field of the EAPOL key packet *\/\n    key_data = (guint8 *)pEAPKey + sizeof(EAPOL_RSN_KEY);","target":1,"flaw_line_index":0,"hash":"d9a64c68-7d0d-4dcf-ac5a-8d9d2aa3c455","idx":"4847f365-7048-4611-b8a5-6936c0961b3e"}
{"func_before":"        if (key_bytes_len < 16) {\n            return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n        }\n    }\n\n    if ((key_bytes_len < GROUP_KEY_MIN_LEN) ||\n        (eapol_len < sizeof(EAPOL_RSN_KEY)) ||\n        (key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY))) {\n        return AIRPDCAP_RET_NO_VALID_HANDSHAKE;\n    }\n\n    \/* Encrypted key is in the information element field of the EAPOL key packet *\/\n    key_data = (guint8 *)pEAPKey + sizeof(EAPOL_RSN_KEY);","target":0,"flaw_line_index":0,"hash":"9c670a3c-9891-4c92-bc57-c83b2484fba6","idx":"a5617046-68f2-437a-a664-32a27adc0f2c"}
{"func_before":"          char *zErr;\n          int jmp2;\n          if( j==pTab->iPKey ) continue;\n          if( pTab->aCol[j].notNull==0 ) continue;\n          sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);\n          sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);\n          jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);\n          zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,\n                              pTab->aCol[j].zName);\n          sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);\n          integrityCheckResultRow(v);","target":1,"flaw_line_index":0,"hash":"10a2941e-8920-40e6-8649-2d9695fe1245","idx":"8e5bb40c-b78a-4cce-9156-85720b0dd521"}
{"func_before":"          char *zErr;\n          int jmp2;\n          if( j==pTab->iPKey ) continue;\n          if( pTab->aCol[j].notNull==0 ) continue;\n          sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);\n          if( sqlite3VdbeGetOp(v,-1)->opcode==OP_Column ){\n            sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);\n          }\n          jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);\n          zErr = sqlite3MPrintf(db, \"NULL value in %s.%s\", pTab->zName,\n                              pTab->aCol[j].zName);\n          sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);\n          integrityCheckResultRow(v);","target":0,"flaw_line_index":0,"hash":"ec5c4bf4-a34b-41d2-86e9-900d01d6a5a4","idx":"edc3add0-1587-425e-b0ce-070eaf0b89c2"}
{"func_before":"\t\t\t\tfscrypt_is_dot_dotdot(iname)) {\n\t\tfname->disk_name.name = (unsigned char *)iname->name;\n\t\tfname->disk_name.len = iname->len;\n\t\treturn 0;\n\t}\n\tret = fscrypt_get_crypt_info(dir);\n\tif (ret && ret != -EOPNOTSUPP)\n\t\treturn ret;\n\n\tif (dir->i_crypt_info) {\n\t\tret = fscrypt_fname_alloc_buffer(dir, iname->len,","target":1,"flaw_line_index":0,"hash":"4251b60c-c764-40dd-bf7a-fabdaf1c34b1","idx":"7e7f461f-b0f9-47ca-901d-d2ee143e7c6f"}
{"func_before":"\t\t\t\tfscrypt_is_dot_dotdot(iname)) {\n\t\tfname->disk_name.name = (unsigned char *)iname->name;\n\t\tfname->disk_name.len = iname->len;\n\t\treturn 0;\n\t}\n\tret = fscrypt_get_encryption_info(dir);\n\tif (ret && ret != -EOPNOTSUPP)\n\t\treturn ret;\n\n\tif (dir->i_crypt_info) {\n\t\tret = fscrypt_fname_alloc_buffer(dir, iname->len,","target":0,"flaw_line_index":0,"hash":"01096e0f-df18-4585-8f5e-35276114058c","idx":"f69163b3-92ea-43b3-8ba3-d94ebf9afa5b"}
{"func_before":"\n  if (smaller_width_larger_size_) {\n    if (frame < 30) {\n      return;\n    }\n    if (frame < 100) {\n      *w = initial_w * 7 \/ 10;\n      *h = initial_h * 16 \/ 10;\n      return;\n    }\n    return;\n  }\n  if (frame < 10) {\n    return;\n  }","target":1,"flaw_line_index":0,"hash":"3bd9f078-595b-4a6c-8dd2-5e1d10ea1f2a","idx":"3ca2208f-5caa-461a-a6b3-078c4619d029"}
{"func_before":"\n  if (smaller_width_larger_size_) {\n    if (frame < 30) {\n      return;\n    }\n    *w = initial_w * 7 \/ 10;\n    *h = initial_h * 16 \/ 10;\n    return;\n  }\n  if (frame < 10) {\n    return;\n  }","target":0,"flaw_line_index":0,"hash":"1c01bb2d-4c26-40a9-b1bf-04869ffef45c","idx":"c6f2ba25-04ed-47d4-98b6-482fee752cef"}
{"func_before":"                ++lIndex;\n            }\n            else if (0x00 == (byteMain & 0x20))\n            {\n                \/\/ 2 byte\n                int val = (int)(((byteMain & 0x1F) << 6) |\n                    (pBuffer[lIndex + 1] & 0x3F));\n                *pUnicodeString++ = (WCHAR)(val);\n                lIndex += 2;\n            }\n            else if (0x00 == (byteMain & 0x10))\n            {\n                \/\/ 3 byte\n                int val = (int)(((byteMain & 0x0F) << 12) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 2] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 3;\n            }\n            else if (0x00 == (byteMain & 0x0F))\n            {\n                \/\/ 4 byte\n                int val = (int)(((byteMain & 0x07) << 18) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 3] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x08))\n            {\n                \/\/ 4 byte\n                int val = (int)(((byteMain & 0x07) << 18) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 3] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x04))\n            {\n                \/\/ 5 byte\n                int val = (int)(((byteMain & 0x03) << 24) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 18) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 3] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 4] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 5;\n            }\n            else\n            {\n                \/\/ 6 byte\n                int val = (int)(((byteMain & 0x01) << 30) |\n                    ((pBuffer[lIndex + 1] & 0x3F) << 24) |\n                    ((pBuffer[lIndex + 2] & 0x3F) << 18) |\n                    ((pBuffer[lIndex + 3] & 0x3F) << 12) |\n                    ((pBuffer[lIndex + 4] & 0x3F) << 6) |\n                    (pBuffer[lIndex + 5] & 0x3F));\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 5;\n            }\n        }","target":1,"flaw_line_index":0,"hash":"1db3683a-03df-4e34-bf44-0e0fa6ba12bf","idx":"c4c4aca3-4c24-4a44-9f08-254101b0c70f"}
{"func_before":"                ++lIndex;\n            }\n            else if (0x00 == (byteMain & 0x20))\n            {\n                \/\/ 2 byte\n                int val = 0;\n                if ((lIndex + 1) < lCount)\n                {\n                    val = (int)(((byteMain & 0x1F) << 6) |\n                                (pBuffer[lIndex + 1] & 0x3F));\n                }\n\n                *pUnicodeString++ = (WCHAR)(val);\n                lIndex += 2;\n            }\n            else if (0x00 == (byteMain & 0x10))\n            {\n                \/\/ 3 byte\n                int val = 0;\n                if ((lIndex + 2) < lCount)\n                {\n                    val = (int)(((byteMain & 0x0F) << 12) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 2] & 0x3F));\n                }\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 3;\n            }\n            else if (0x00 == (byteMain & 0x0F))\n            {\n                \/\/ 4 byte\n                int val = 0;\n                if ((lIndex + 3) < lCount)\n                {\n                    val = (int)(((byteMain & 0x07) << 18) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 3] & 0x3F));\n                }\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x08))\n            {\n                \/\/ 4 byte\n                int val = 0;\n                if ((lIndex + 3) < lCount)\n                {\n                    val = (int)(((byteMain & 0x07) << 18) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 3] & 0x3F));\n                }\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 4;\n            }\n            else if (0x00 == (byteMain & 0x04))\n            {\n                \/\/ 5 byte\n                int val = 0;\n                if ((lIndex + 4) < lCount)\n                {\n                    val = (int)(((byteMain & 0x03) << 24) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 18) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 3] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 4] & 0x3F));\n                }\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 5;\n            }\n            else\n            {\n                \/\/ 6 byte\n                int val = 0;\n                if ((lIndex + 5) < lCount)\n                {\n                    val = (int)(((byteMain & 0x01) << 30) |\n                                ((pBuffer[lIndex + 1] & 0x3F) << 24) |\n                                ((pBuffer[lIndex + 2] & 0x3F) << 18) |\n                                ((pBuffer[lIndex + 3] & 0x3F) << 12) |\n                                ((pBuffer[lIndex + 4] & 0x3F) << 6) |\n                                (pBuffer[lIndex + 5] & 0x3F));\n                }\n\n                WriteUtf16_WCHAR(val, pUnicodeString);\n                lIndex += 5;\n            }\n        }","target":0,"flaw_line_index":0,"hash":"57bfb7d0-ed91-47bc-aac2-c2f63632c699","idx":"468b73de-9344-4ffb-9b0c-38e3854d19d9"}
{"func_before":"TfLiteStatus TanhPrepare(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, 0);\n  TfLiteTensor* output = GetOutput(context, node, 0);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  if (kernel_type == kFixedPointOptimized) {\n    if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n      static constexpr int kInputIntegerBits = 4;","target":1,"flaw_line_index":0,"hash":"989ec967-fb99-4e94-aeff-f84f0c92ac38","idx":"d99d2967-cf63-4b0c-9211-4ecd76a47be3"}
{"func_before":"TfLiteStatus TanhPrepare(TfLiteContext* context, TfLiteNode* node) {\n  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output));\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, output->type);\n\n  if (kernel_type == kFixedPointOptimized) {\n    if (input->type == kTfLiteUInt8 || input->type == kTfLiteInt8) {\n      static constexpr int kInputIntegerBits = 4;","target":0,"flaw_line_index":0,"hash":"08bc29bf-ef21-4e5d-bbdf-4791691de663","idx":"0ff85571-ac10-41a7-af63-2dfd1bfd41dc"}
{"func_before":"\tcase TIOCSPGRP:\n\t\treturn tiocspgrp(tty, real_tty, p);\n\tcase TIOCGSID:\n\t\treturn tiocgsid(tty, real_tty, p);\n\tcase TIOCGETD:\n\t\treturn put_user(tty->ldisc->ops->num, (int __user *)p);\n\tcase TIOCSETD:\n\t\treturn tiocsetd(tty, p);\n\tcase TIOCVHANGUP:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;","target":1,"flaw_line_index":0,"hash":"89b92866-446c-4c2d-9d68-5d7abd53ffc9","idx":"d38f9e5d-a89b-4f6f-91ab-4746e9183250"}
{"func_before":"\tcase TIOCSPGRP:\n\t\treturn tiocspgrp(tty, real_tty, p);\n\tcase TIOCGSID:\n\t\treturn tiocgsid(tty, real_tty, p);\n\tcase TIOCGETD:\n\t\treturn tiocgetd(tty, p);\n\tcase TIOCSETD:\n\t\treturn tiocsetd(tty, p);\n\tcase TIOCVHANGUP:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;","target":0,"flaw_line_index":0,"hash":"0ba93e22-48d0-4d0e-b768-675ba1cc0f71","idx":"237180cd-47da-49ab-9a79-ccd7a4fbf6fd"}
{"func_before":"    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->hash_is_enabled = HASH_DISABLED;\n        dcfg->hash_enforcement = HASH_DISABLED;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SecRuleEngine: %s\", p1);\n\n    return NULL;\n}","target":1,"flaw_line_index":0,"hash":"dcd55517-d946-4be5-a84b-616d706cb6a4","idx":"f3905aba-cc74-481f-9f91-f1f12408e5c6"}
{"func_before":"    }\n    else if (strcasecmp(p1, \"off\") == 0)    {\n        dcfg->hash_is_enabled = HASH_DISABLED;\n        dcfg->hash_enforcement = HASH_DISABLED;\n    }\n    else return apr_psprintf(cmd->pool, \"ModSecurity: Invalid value for SexHashEngine: %s\", p1);\n\n    return NULL;\n}","target":0,"flaw_line_index":0,"hash":"b86eb0bd-a145-4bd0-a996-0fcecb4d5601","idx":"58c82b31-852a-4dce-bc4c-1f969accfb75"}
{"func_before":"  \/* And, we must have the actual cached data in the summary *\/\n  if (!flatpak_remote_state_lookup_cache (state, flatpak_decomposed_get_ref (op->ref),\n                                          &download_size, &installed_size, &metadata, NULL))\n      return FALSE;\n\n  metadata_bytes = g_bytes_new (metadata, strlen (metadata) + 1);\n\n  if (flatpak_remote_state_lookup_ref (state, flatpak_decomposed_get_ref (op->ref),\n                                       NULL, NULL, &info, NULL, NULL))\n    op->summary_metadata = var_metadata_dup_to_gvariant (var_ref_info_get_metadata (info));\n","target":1,"flaw_line_index":0,"hash":"ff2fa8e6-d6ca-46c2-a8d4-ffb1952e362f","idx":"bfa1d2fb-c2e7-4611-ae4f-9491f11c2fe3"}
{"func_before":"  \/* And, we must have the actual cached data in the summary *\/\n  if (!flatpak_remote_state_lookup_cache (state, flatpak_decomposed_get_ref (op->ref),\n                                          &download_size, &installed_size, &metadata, NULL))\n      return FALSE;\n\n  metadata_bytes = g_bytes_new (metadata, strlen (metadata));\n\n  if (flatpak_remote_state_lookup_ref (state, flatpak_decomposed_get_ref (op->ref),\n                                       NULL, NULL, &info, NULL, NULL))\n    op->summary_metadata = var_metadata_dup_to_gvariant (var_ref_info_get_metadata (info));\n","target":0,"flaw_line_index":0,"hash":"3755964c-54d5-42e6-9cdc-99c0e04f822d","idx":"68a7a430-c398-4808-ae4e-46f4a6fa4d7c"}
{"func_before":"inline void StringData::setSize(int len) {\n  assertx(!isImmutable() && !hasMultipleRefs());\n  assertx(len >= 0 && len <= capacity());\n  mutableData()[len] = 0;\n  m_lenAndHash = len;\n  assertx(m_hash == 0);","target":1,"flaw_line_index":0,"hash":"2c7fe78c-7926-407f-98b4-d1859f45c029","idx":"388e2398-262f-401b-975d-efe54e2dd11b"}
{"func_before":"inline void StringData::setSize(int64_t len) {\n  assertx(!isImmutable() && !hasMultipleRefs());\n  assertx(len >= 0 && len <= capacity());\n  mutableData()[len] = 0;\n  m_lenAndHash = len;\n  assertx(m_hash == 0);","target":0,"flaw_line_index":0,"hash":"6e3f5246-eb85-4993-8fe5-aeda11f93aaa","idx":"a012adc5-65fc-4cc0-9bdb-ba2ed0027e1a"}
{"func_before":"  parser->m_useForeignDTD = XML_FALSE;\n  parser->m_paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;\n#endif\n  parser->m_hash_secret_salt = 0;\n\n#ifdef XML_DTD\n  memset(&parser->m_accounting, 0, sizeof(ACCOUNTING));\n  parser->m_accounting.debugLevel = getDebugLevel(\"EXPAT_ACCOUNTING_DEBUG\", 0u);\n  parser->m_accounting.maximumAmplificationFactor\n      = EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT;\n  parser->m_accounting.activationThresholdBytes","target":1,"flaw_line_index":0,"hash":"1125c1ef-6b50-4c7b-9e61-f7ca98e7a736","idx":"3b53db4f-6933-49e3-9fb2-dba1ae1a6e5b"}
{"func_before":"  parser->m_useForeignDTD = XML_FALSE;\n  parser->m_paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;\n#endif\n  parser->m_hash_secret_salt = 0;\n\n#if defined(XML_DTD) || XML_GE == 1\n  memset(&parser->m_accounting, 0, sizeof(ACCOUNTING));\n  parser->m_accounting.debugLevel = getDebugLevel(\"EXPAT_ACCOUNTING_DEBUG\", 0u);\n  parser->m_accounting.maximumAmplificationFactor\n      = EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT;\n  parser->m_accounting.activationThresholdBytes","target":0,"flaw_line_index":0,"hash":"8d40d882-98c7-46e2-8de5-d958c5ba43fc","idx":"2b456746-daef-480b-a7c3-f75528dec620"}
{"func_before":"  map_first = NULL;\n  pointer_to_map = &map_first;\n\n  num_segments = elf_elfheader (ibfd)->e_phnum;\n\n  \/* Returns the end address of the segment + 1.  *\/\n#define SEGMENT_END(segment, start)\t\t\t\t\t\\\n  (start + (segment->p_memsz > segment->p_filesz\t\t\t\\\n\t    ? segment->p_memsz : segment->p_filesz))\n\n#define SECTION_SIZE(section, segment)\t\t\t\t\t\\\n  (((section->flags & (SEC_HAS_CONTENTS | SEC_THREAD_LOCAL))\t\t\\\n    != SEC_THREAD_LOCAL || segment->p_type == PT_TLS)\t\t\t\\\n   ? section->size : 0)\n\n  \/* Returns TRUE if the given section is contained within\n     the given segment.  VMA addresses are compared.  *\/\n#define IS_CONTAINED_BY_VMA(section, segment, opb)\t\t\t\\\n  (section->vma * (opb) >= segment->p_vaddr\t\t\t\t\\\n   && (section->vma * (opb) + SECTION_SIZE (section, segment)\t\t\\\n       <= (SEGMENT_END (segment, segment->p_vaddr))))\n\n  \/* Returns TRUE if the given section is contained within\n     the given segment.  LMA addresses are compared.  *\/\n#define IS_CONTAINED_BY_LMA(section, segment, base, opb)\t\t\\\n  (section->lma * (opb) >= base\t\t\t\t\t\t\\\n   && (section->lma + SECTION_SIZE (section, segment) \/ (opb) >= section->lma) \\\n   && (section->lma * (opb) + SECTION_SIZE (section, segment)\t\t\\\n       <= SEGMENT_END (segment, base)))\n\n  \/* Handle PT_NOTE segment.  *\/\n#define IS_NOTE(p, s)\t\t\t\t\t\t\t\\\n  (p->p_type == PT_NOTE\t\t\t\t\t\t\t\\\n   && elf_section_type (s) == SHT_NOTE\t\t\t\t\t\\\n   && (bfd_vma) s->filepos >= p->p_offset\t\t\t\t\\\n   && ((bfd_vma) s->filepos + s->size\t\t\t\t\t\\\n       <= p->p_offset + p->p_filesz))\n\n  \/* Special case: corefile \"NOTE\" section containing regs, prpsinfo\n     etc.  *\/\n#define IS_COREFILE_NOTE(p, s)\t\t\t\t\t\t\\\n  (IS_NOTE (p, s)\t\t\t\t\t\t\t\\\n   && bfd_get_format (ibfd) == bfd_core\t\t\t\t\t\\\n   && s->vma == 0\t\t\t\t\t\t\t\\\n   && s->lma == 0)\n\n  \/* The complicated case when p_vaddr is 0 is to handle the Solaris\n     linker, which generates a PT_INTERP section with p_vaddr and\n     p_memsz set to 0.  *\/\n#define IS_SOLARIS_PT_INTERP(p, s)\t\t\t\t\t\\\n  (p->p_vaddr == 0\t\t\t\t\t\t\t\\\n       6. PT_TLS segment includes only SHF_TLS sections.\n       7. SHF_TLS sections are only in PT_TLS or PT_LOAD segments.\n       8. PT_DYNAMIC should not contain empty sections at the beginning\n\t  (with the possible exception of .dynamic).  *\/\n#define IS_SECTION_IN_INPUT_SEGMENT(section, segment, bed, opb)\t\t\\\n  ((((segment->p_paddr\t\t\t\t\t\t\t\\\n      ? IS_CONTAINED_BY_LMA (section, segment, segment->p_paddr, opb)\t\\\n      : IS_CONTAINED_BY_VMA (section, segment, opb))\t\t\t\\\n     && (section->flags & SEC_ALLOC) != 0)\t\t\t\t\\\n    || IS_NOTE (segment, section))\t\t\t\t\t\\\n   && segment->p_type != PT_GNU_STACK\t\t\t\t\t\\\n   && (segment->p_type != PT_TLS\t\t\t\t\t\\\n       || (section->flags & SEC_THREAD_LOCAL))\t\t\t\t\\\n   && (segment->p_type == PT_LOAD\t\t\t\t\t\\\n       || segment->p_type == PT_TLS\t\t\t\t\t\\\n       || (section->flags & SEC_THREAD_LOCAL) == 0)\t\t\t\\\n   && (segment->p_type != PT_DYNAMIC\t\t\t\t\t\\\n       || SECTION_SIZE (section, segment) > 0\t\t\t\t\\\n       || (segment->p_paddr\t\t\t\t\t\t\\\n\t   ? segment->p_paddr != section->lma * (opb)\t\t\t\\\n\t   : segment->p_vaddr != section->vma * (opb))\t\t\t\\\n       || (strcmp (bfd_section_name (section), \".dynamic\") == 0))\t\\\n   && (segment->p_type != PT_LOAD || !section->segment_mark))\n  (IS_SECTION_IN_INPUT_SEGMENT (section, segment, bed, opb)\t\t\\\n   && section->output_section != NULL)\n\n  \/* Returns TRUE iff seg1 starts after the end of seg2.  *\/\n#define SEGMENT_AFTER_SEGMENT(seg1, seg2, field)\t\t\t\\\n  (seg1->field >= SEGMENT_END (seg2, seg2->field))\n\n  \/* Returns TRUE iff seg1 and seg2 overlap. Segments overlap iff both\n     their VMA address ranges and their LMA address ranges overlap.\n     It is possible to have overlapping VMA ranges without overlapping LMA\n     ranges.  RedBoot images for example can have both .data and .bss mapped\n\t  \/* Merge the two segments together.  *\/\n\t  if (segment2->p_vaddr < segment->p_vaddr)\n\t    {\n\t      \/* Extend SEGMENT2 to include SEGMENT and then delete\n\t\t SEGMENT.  *\/\n\t      extra_length = (SEGMENT_END (segment, segment->p_vaddr)\n\t\t\t      - SEGMENT_END (segment2, segment2->p_vaddr));\n\n\t      if (extra_length > 0)\n\t\t{\n\t\t  segment2->p_memsz += extra_length;\n\t\t  segment2->p_filesz += extra_length;\n\t    }\n\t  else\n\t    {\n\t      \/* Extend SEGMENT to include SEGMENT2 and then delete\n\t\t SEGMENT2.  *\/\n\t      extra_length = (SEGMENT_END (segment2, segment2->p_vaddr)\n\t\t\t      - SEGMENT_END (segment, segment->p_vaddr));\n\n\t      if (extra_length > 0)\n\t\t{\n\t\t  segment->p_memsz += extra_length;\n\t\t  segment->p_filesz += extra_length;\n\t\t      == (output_section->vma * opb)))\n\t\tmap->p_paddr = segment->p_vaddr;\n\n\t      \/* Match up the physical address of the segment with the\n\t\t LMA address of the output section.  *\/\n\t      if (IS_CONTAINED_BY_LMA (output_section, segment, map->p_paddr,\n\t\t\t\t       opb)\n\t\t  || IS_COREFILE_NOTE (segment, section)\n\t\t  || (bed->want_p_paddr_set_to_zero\n\t\t      && IS_CONTAINED_BY_VMA (output_section, segment, opb)))\n\t\t{\n\t\t  if (matching_lma == NULL\n\t\t      || output_section->lma < matching_lma->lma)\n\t\t    matching_lma = output_section;\n\n\n\t      output_section = section->output_section;\n\n\t      BFD_ASSERT (output_section != NULL);\n\n\t      if (IS_CONTAINED_BY_LMA (output_section, segment, map->p_paddr,\n\t\t\t\t       opb)\n\t\t  || IS_COREFILE_NOTE (segment, section))\n\t\t{\n\t\t  if (map->count == 0)\n\t\t    {\n\t\t      \/* If the first section in a segment does not start at\n\t\t\t the beginning of the segment, then something is\n\t    map->p_paddr = phdr_adjust_seg->p_paddr + adjust;\n\t    break;\n\t  }\n    }\n\n#undef SEGMENT_END\n#undef SECTION_SIZE\n#undef IS_CONTAINED_BY_VMA\n#undef IS_CONTAINED_BY_LMA\n#undef IS_NOTE\n#undef IS_COREFILE_NOTE\n#undef IS_SOLARIS_PT_INTERP\n#undef IS_SECTION_IN_INPUT_SEGMENT\n#undef INCLUDE_SECTION_IN_SEGMENT\n#undef SEGMENT_AFTER_SEGMENT\n#undef SEGMENT_OVERLAPS","target":1,"flaw_line_index":0,"hash":"9ecbda9a-85db-4fa0-bfb0-d5670d1c1e5c","idx":"2e4fce4f-1060-4859-a382-0c51f18aac0c"}
{"func_before":"\n  map_first = NULL;\n  pointer_to_map = &map_first;\n\n  num_segments = elf_elfheader (ibfd)->e_phnum;\n\n  \/* The complicated case when p_vaddr is 0 is to handle the Solaris\n     linker, which generates a PT_INTERP section with p_vaddr and\n     p_memsz set to 0.  *\/\n#define IS_SOLARIS_PT_INTERP(p, s)\t\t\t\t\t\\\n  (p->p_vaddr == 0\t\t\t\t\t\t\t\\\n       6. PT_TLS segment includes only SHF_TLS sections.\n       7. SHF_TLS sections are only in PT_TLS or PT_LOAD segments.\n       8. PT_DYNAMIC should not contain empty sections at the beginning\n\t  (with the possible exception of .dynamic).  *\/\n#define IS_SECTION_IN_INPUT_SEGMENT(section, segment, bed, opb)\t\t\\\n  (((is_contained_by (section, segment, segment->p_paddr,\t\t\\\n\t\t      segment->p_vaddr, opb, bed)\t\t\t\\\n     && (section->flags & SEC_ALLOC) != 0)\t\t\t\t\\\n    || is_note (segment, section))\t\t\t\t\t\\\n   && segment->p_type != PT_GNU_STACK\t\t\t\t\t\\\n   && (segment->p_type != PT_TLS\t\t\t\t\t\\\n       || (section->flags & SEC_THREAD_LOCAL))\t\t\t\t\\\n   && (segment->p_type == PT_LOAD\t\t\t\t\t\\\n       || segment->p_type == PT_TLS\t\t\t\t\t\\\n       || (section->flags & SEC_THREAD_LOCAL) == 0)\t\t\t\\\n   && (segment->p_type != PT_DYNAMIC\t\t\t\t\t\\\n       || section_size (section, segment) > 0\t\t\t\t\\\n       || (segment->p_paddr\t\t\t\t\t\t\\\n\t   ? segment->p_paddr != section->lma * (opb)\t\t\t\\\n\t   : segment->p_vaddr != section->vma * (opb))\t\t\t\\\n       || (strcmp (bfd_section_name (section), \".dynamic\") == 0))\t\\\n   && (segment->p_type != PT_LOAD || !section->segment_mark))\n  (IS_SECTION_IN_INPUT_SEGMENT (section, segment, bed, opb)\t\t\\\n   && section->output_section != NULL)\n\n  \/* Returns TRUE iff seg1 starts after the end of seg2.  *\/\n#define SEGMENT_AFTER_SEGMENT(seg1, seg2, field)\t\t\t\\\n  (seg1->field >= segment_end (seg2, seg2->field))\n\n  \/* Returns TRUE iff seg1 and seg2 overlap. Segments overlap iff both\n     their VMA address ranges and their LMA address ranges overlap.\n     It is possible to have overlapping VMA ranges without overlapping LMA\n     ranges.  RedBoot images for example can have both .data and .bss mapped\n\t  \/* Merge the two segments together.  *\/\n\t  if (segment2->p_vaddr < segment->p_vaddr)\n\t    {\n\t      \/* Extend SEGMENT2 to include SEGMENT and then delete\n\t\t SEGMENT.  *\/\n\t      extra_length = (segment_end (segment, segment->p_vaddr)\n\t\t\t      - segment_end (segment2, segment2->p_vaddr));\n\n\t      if (extra_length > 0)\n\t\t{\n\t\t  segment2->p_memsz += extra_length;\n\t\t  segment2->p_filesz += extra_length;\n\t    }\n\t  else\n\t    {\n\t      \/* Extend SEGMENT to include SEGMENT2 and then delete\n\t\t SEGMENT2.  *\/\n\t      extra_length = (segment_end (segment2, segment2->p_vaddr)\n\t\t\t      - segment_end (segment, segment->p_vaddr));\n\n\t      if (extra_length > 0)\n\t\t{\n\t\t  segment->p_memsz += extra_length;\n\t\t  segment->p_filesz += extra_length;\n\t\t      == (output_section->vma * opb)))\n\t\tmap->p_paddr = segment->p_vaddr;\n\n\t      \/* Match up the physical address of the segment with the\n\t\t LMA address of the output section.  *\/\n\t      if (is_contained_by (output_section, segment, map->p_paddr,\n\t\t\t\t   map->p_paddr + map->p_vaddr_offset, opb, bed)\n\t\t  || is_note (segment, section))\n\t\t{\n\t\t  if (matching_lma == NULL\n\t\t      || output_section->lma < matching_lma->lma)\n\t\t    matching_lma = output_section;\n\n\n\t      output_section = section->output_section;\n\n\t      BFD_ASSERT (output_section != NULL);\n\n\t      if (is_contained_by (output_section, segment, map->p_paddr,\n\t\t\t\t   map->p_paddr + map->p_vaddr_offset, opb, bed)\n\t\t  || is_note (segment, section))\n\t\t{\n\t\t  if (map->count == 0)\n\t\t    {\n\t\t      \/* If the first section in a segment does not start at\n\t\t\t the beginning of the segment, then something is\n\t      = phdr_adjust_seg->includes_filehdr ? iehdr->e_ehsize : 0;\n\t    map->p_paddr = phdr_adjust_seg->p_paddr + adjust;\n\t    break;\n\t  }\n    }\n\n#undef IS_SOLARIS_PT_INTERP\n#undef IS_SECTION_IN_INPUT_SEGMENT\n#undef INCLUDE_SECTION_IN_SEGMENT\n#undef SEGMENT_AFTER_SEGMENT\n#undef SEGMENT_OVERLAPS","target":0,"flaw_line_index":0,"hash":"eff275b3-a863-44a5-aa80-ace837ddc737","idx":"5cf276df-e596-4029-8b78-3223f822e34b"}
{"func_before":"static BOOL rdp_read_font_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length > 4)\n\t\tStream_Seek_UINT16(s); \/* fontSupportFlags (2 bytes) *\/\n\n\tif (length > 6)\n\t\tStream_Seek_UINT16(s); \/* pad2Octets (2 bytes) *\/\n\n\treturn TRUE;\n}","target":1,"flaw_line_index":0,"hash":"3538cb98-140a-44e5-8d38-122706d2a858","idx":"cb48d1a9-7f4a-4a76-9266-6f5eb31ac0ed"}
{"func_before":"static BOOL rdp_read_font_capability_set(wStream* s, UINT16 length, rdpSettings* settings)\n{\n\tWINPR_UNUSED(settings);\n\tif (length > 5)\n\t\tStream_Seek_UINT16(s); \/* fontSupportFlags (2 bytes) *\/\n\n\tif (length > 7)\n\t\tStream_Seek_UINT16(s); \/* pad2Octets (2 bytes) *\/\n\n\treturn TRUE;\n}","target":0,"flaw_line_index":0,"hash":"fff0bdc1-77e7-4abc-9691-db6497500dd3","idx":"4e5fba01-e7f0-4ec2-9069-999929746914"}
{"func_before":"\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}","target":1,"flaw_line_index":0,"hash":"28421ef0-e56e-49ec-8d93-43fd3d4349a5","idx":"05985c6d-502a-47a8-b8fa-74cc0f896796"}
{"func_before":"\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (size_t i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = (*pc == 0x1B || *pc >= 0x20) ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}","target":0,"flaw_line_index":0,"hash":"bad46c41-fbc1-4637-a309-e708606c6c5c","idx":"b22afdd9-7649-466f-8203-3077639d6906"}
{"func_before":"\trcu_read_unlock();\n\tsmp_rmb();\n\tif (task->mm)\n\t\tdumpable = get_dumpable(task->mm);\n\trcu_read_lock();\n\tif (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n","target":1,"flaw_line_index":0,"hash":"33329e2a-c77a-43b6-9818-cbcf74a7ceb5","idx":"375d42c8-ae18-4503-b22a-963e07df6b68"}
{"func_before":"\trcu_read_unlock();\n\tsmp_rmb();\n\tif (task->mm)\n\t\tdumpable = get_dumpable(task->mm);\n\trcu_read_lock();\n\tif (dumpable != SUID_DUMP_USER &&\n\t    !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n","target":0,"flaw_line_index":0,"hash":"b9fbeddd-3fde-40ea-86b0-54fcbfcf7f9d","idx":"525a91e2-e21f-41cf-82c4-6a91e1676f3f"}
{"func_before":"static void pp_mil_k12(fp12_t r, ep2_t *t, ep2_t *q, ep_t *p, int m, bn_t a) {\n\tfp12_t l;\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep2_t *_q = RLC_ALLOCA(ep2_t, m);\n\tint i, j, len = bn_bits(a) + 1;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tif (m == 0) {\n\t\treturn;\n\t}","target":1,"flaw_line_index":0,"hash":"c58e4051-9813-4729-b703-25779637ebde","idx":"8e016566-bb1c-40a2-8812-d798b22fb3e4"}
{"func_before":"static void pp_mil_k12(fp12_t r, ep2_t *t, ep2_t *q, ep_t *p, int m, bn_t a) {\n\tfp12_t l;\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep2_t *_q = RLC_ALLOCA(ep2_t, m);\n\tsize_t len = bn_bits(a) + 1;\n\tint i, j;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tif (m == 0) {\n\t\treturn;\n\t}","target":0,"flaw_line_index":0,"hash":"988b68f5-517c-4db1-9bc1-dc9445feea3c","idx":"e6b167a1-ef7b-424b-bd73-2fca8c58331c"}
{"func_before":"    Module &M,\n    const BytecodeGenerationOptions &genOptions) {\n  std::shared_ptr<Context> context = M.shareContext();\n  CompileResult result{Success};\n  if (cl::BytecodeFormat == cl::BytecodeFormatKind::HBC) {\n    result.bytecodeProvider = hbc::BCProviderFromSrc::createBCProviderFromSrc(\n        hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), genOptions));\n\n  } else {\n    llvm_unreachable(\"Invalid bytecode kind for execution\");\n    result = InvalidFlags;\n  }\n  return result;","target":1,"flaw_line_index":0,"hash":"0d702d9f-8114-4ef9-9e56-3de3fbdca5ca","idx":"ee9ab064-957a-4f45-b196-7a3b86834190"}
{"func_before":"    Module &M,\n    const BytecodeGenerationOptions &genOptions) {\n  std::shared_ptr<Context> context = M.shareContext();\n  CompileResult result{Success};\n  if (cl::BytecodeFormat == cl::BytecodeFormatKind::HBC) {\n    auto BM =\n        hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), genOptions);\n    if (auto N = context->getSourceErrorManager().getErrorCount()) {\n      llvh::errs() << \"Emitted \" << N << \" errors in the backend. exiting.\\n\";\n      return BackendError;\n    }\n\n    result.bytecodeProvider =\n        hbc::BCProviderFromSrc::createBCProviderFromSrc(std::move(BM));\n  } else {\n    llvm_unreachable(\"Invalid bytecode kind for execution\");\n    result = InvalidFlags;\n  }\n  return result;","target":0,"flaw_line_index":0,"hash":"99c3da91-9392-4656-bb25-2d452688a190","idx":"143d8ffe-87b1-4d97-b75a-920aef270aad"}
{"func_before":"snmp_ber_encode_string_len(unsigned char *out, uint32_t *out_len, const char *str, uint32_t length)\n{\n  uint32_t i;\n\n  str += length - 1;\n  for(i = 0; i < length; ++i) {\n    (*out_len)++;\n    *out-- = (uint8_t)*str--;\n  }\n\n  out = snmp_ber_encode_length(out, out_len, length);\n  out = snmp_ber_encode_type(out, out_len, BER_DATA_TYPE_OCTET_STRING);\n\n  return out;\n}","target":1,"flaw_line_index":0,"hash":"3eb9455c-d68d-4f35-a024-4ca0e2c92a7c","idx":"51b6b974-13cc-463f-9f26-62d279d24955"}
{"func_before":"snmp_ber_encode_string_len(snmp_packet_t *snmp_packet, const char *str, uint32_t length)\n{\n  uint32_t i;\n\n  str += length - 1;\n  for(i = 0; i < length; ++i) {\n    if(snmp_packet->used == snmp_packet->max) {\n      return 0;\n    }\n\n    *snmp_packet->out-- = (uint8_t)*str--;\n    snmp_packet->used++;\n  }\n\n  if(!snmp_ber_encode_length(snmp_packet, length)) {\n    return 0;\n  }\n\n  if(!snmp_ber_encode_type(snmp_packet, BER_DATA_TYPE_OCTET_STRING)) {\n    return 0;\n  }\n\n  return 1;\n}","target":0,"flaw_line_index":0,"hash":"e5b37d9f-6a3f-4361-9b61-dad47efd7a17","idx":"c20c1b35-61c9-49a2-8191-25cda429a57b"}
{"func_before":"static int restrictedFile(const char *filename)\n{\n\tif (!live_dangerously && !strncasecmp(filename, \"\/\", 1) &&\n\t\t strncasecmp(filename, ast_config_AST_CONFIG_DIR, strlen(ast_config_AST_CONFIG_DIR))) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"515e7c44-6643-4cde-873c-15e5cf4faa8b","idx":"40fc3f59-d62c-458a-874f-338c3805025b"}
{"func_before":"static int restrictedFile(const char *filename)\n{\n\tchar *stripped_filename;\n\tRAII_VAR(char *, path, NULL, ast_free);\n\tRAII_VAR(char *, real_path, NULL, ast_free);\n\n\tif (live_dangerously) {\n\t\treturn 0;\n\t}\n\n\tstripped_filename = ast_strip(ast_strdupa(filename));\n\n\t\/* If the file path starts with '\/', don't prepend ast_config_AST_CONFIG_DIR *\/\n\tif (stripped_filename[0] == '\/') {\n\t\treal_path = realpath(stripped_filename, NULL);\n\t} else {\n\t\tif (ast_asprintf(&path, \"%s\/%s\", ast_config_AST_CONFIG_DIR, stripped_filename) == -1) {\n\t\t\treturn -1;\n\t\t}\n\t\treal_path = realpath(path, NULL);\n\t}\n\n\tif (!real_path) {\n\t\treturn -1;\n\t}\n\n\tif (!ast_begins_with(real_path, ast_config_AST_CONFIG_DIR)) {\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"a2c4ea0c-3ee1-4d53-bed0-fef22852efb0","idx":"bbb3daa3-aa8b-47bf-89ab-38030e5cc2c7"}
{"func_before":"static int lookup1_values(int entries, int dim)\n{\n   int r = (int) floor(exp((float) log((float) entries) \/ dim));\n   if ((int) floor(pow((float) r+1, dim)) <= entries)   \/\/ (int) cast for MinGW warning;\n      ++r;                                              \/\/ floor() to avoid _ftol() when non-CRT\n   assert(pow((float) r+1, dim) > entries);\n   assert((int) floor(pow((float) r, dim)) <= entries); \/\/ (int),floor() as above\n   return r;\n}","target":1,"flaw_line_index":0,"hash":"30a7eb1b-33cb-40b3-8a7e-2dd86a7d3302","idx":"a4d71bf2-757e-4e52-af0d-5e75d1618ddc"}
{"func_before":"static int lookup1_values(int entries, int dim)\n{\n   int r = (int) floor(exp((float) log((float) entries) \/ dim));\n   if ((int) floor(pow((float) r+1, dim)) <= entries)   \/\/ (int) cast for MinGW warning;\n      ++r;                                              \/\/ floor() to avoid _ftol() when non-CRT\n   if (pow((float) r+1, dim) <= entries)\n      return -1;\n   if ((int) floor(pow((float) r, dim)) > entries)\n      return -1;\n   return r;\n}","target":0,"flaw_line_index":0,"hash":"31b296ce-3b3d-47ef-953e-b1ead4199a98","idx":"dd715929-fcc5-4070-9bda-e09357cb454d"}
{"func_before":"TEST_F(SQLiteUtilTests, test_column_type_determination) {\n  \/\/ Correct identification of text and ints\n  testTypesExpected(\"select path, inode from file where path like '%'\",\n                    TypeMap({{\"path\", TEXT_TYPE}, {\"inode\", INTEGER_TYPE}}));\n  \/\/ Correctly treating BLOBs as text\n  testTypesExpected(\"select CAST(seconds AS BLOB) as seconds FROM time\",\n                    TypeMap({{\"seconds\", TEXT_TYPE}}));\n  \/\/ Correctly treating ints cast as double as doubles\n  testTypesExpected(\"select CAST(seconds AS DOUBLE) as seconds FROM time\",\n                    TypeMap({{\"seconds\", DOUBLE_TYPE}}));\n  \/\/ Correctly treating bools as ints\n  testTypesExpected(\"select CAST(seconds AS BOOLEAN) as seconds FROM time\",\n                    TypeMap({{\"seconds\", INTEGER_TYPE}}));\n  \/\/ Correctly recognizing values from columns declared double as double, even\n  \/\/ if they happen to have integer value.  And also test multi-statement\n  \/\/ queries.\n  testTypesExpected(\n      \"CREATE TABLE test_types_table (username varchar(30) primary key, age \"\n      \"double);INSERT INTO test_types_table VALUES (\\\"mike\\\", 23); SELECT age \"\n      \"from test_types_table\",\n      TypeMap({{\"age\", DOUBLE_TYPE}}));\n}","target":1,"flaw_line_index":0,"hash":"7978b849-e988-4f21-85a8-0902c4bf03b9","idx":"ddcc9c16-5707-41d9-83ef-be786a788b8f"}
{"func_before":"TEST_F(SQLiteUtilTests, test_sqlite_authorizer) {\n  auto rc = sqliteAuthorizer(\n      nullptr, SQLITE_ATTACH, nullptr, nullptr, nullptr, nullptr);\n  EXPECT_EQ(SQLITE_DENY, rc);\n\n  rc = sqliteAuthorizer(nullptr, 534, nullptr, nullptr, nullptr, nullptr);\n  EXPECT_EQ(SQLITE_DENY, rc);\n\n  rc = sqliteAuthorizer(\n      nullptr, SQLITE_SELECT, nullptr, nullptr, nullptr, nullptr);\n  EXPECT_EQ(SQLITE_OK, rc);\n}","target":0,"flaw_line_index":0,"hash":"ae5d7cb8-15a5-4eff-a310-df225d214128","idx":"ccdedb97-a694-4550-b52e-56b31b228e5e"}
{"func_before":"    }\n\n    \/* Dig for more from OpenSSL error queue *\/\n    SSLLogErrors(action, ret, err, len, ssock);\n\n    ssock->last_err = ssl_err;\n    return GET_STATUS_FROM_SSL_ERR(ssl_err);\n}","target":1,"flaw_line_index":0,"hash":"6f0989b1-28e2-46c8-b866-ec2a03557ab1","idx":"8f0f41c8-9742-404c-9be7-f629bd396a40"}
{"func_before":"    }\n\n    \/* Dig for more from OpenSSL error queue *\/\n    SSLLogErrors(action, ret, err, len, ssock);\n\n    if (ssock)\n\tssock->last_err = ssl_err;\n    return GET_STATUS_FROM_SSL_ERR(ssl_err);\n}","target":0,"flaw_line_index":0,"hash":"b9cde4d3-621b-4117-93a2-53bf842f0ca5","idx":"dba7930a-59e9-489e-8d9c-692897f794c9"}
{"func_before":"{\n\tuint16 shortv;\n\tuint32 w, l, tw, tl;\n\tint bychunk;\n\n\t(void) TIFFGetField(in, TIFFTAG_PLANARCONFIG, &shortv);\n\tif (shortv != config && bitspersample != 8 && samplesperpixel > 1) {\n\t\tfprintf(stderr,\n\t\t    \"%s: Cannot handle different planar configuration w\/ bits\/sample != 8\\n\",\n\t\t    TIFFFileName(in));\n\t\treturn (NULL);","target":1,"flaw_line_index":0,"hash":"4ed83597-41cf-4d44-8814-2c6a650dde32","idx":"7a6e1d61-28d1-4432-ab4b-53979e5a0d1e"}
{"func_before":"{\n\tuint16 shortv;\n\tuint32 w, l, tw, tl;\n\tint bychunk;\n\n\t(void) TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &shortv);\n\tif (shortv != config && bitspersample != 8 && samplesperpixel > 1) {\n\t\tfprintf(stderr,\n\t\t    \"%s: Cannot handle different planar configuration w\/ bits\/sample != 8\\n\",\n\t\t    TIFFFileName(in));\n\t\treturn (NULL);","target":0,"flaw_line_index":0,"hash":"5cc4a9f3-0fd3-4734-af87-2bf6e9f7b9e2","idx":"eefe5f4b-56e5-4492-968c-e27bea295e60"}
{"func_before":"\t\t\t(IPADDR_IS_V6(ip) ? server->connrec->own_ip6 :\n\t\t\t server->connrec->own_ip4);\n\t\tport = server->connrec->proxy != NULL ?\n\t\t\tserver->connrec->proxy_port : server->connrec->port;\n\t\thandle = server->connrec->use_ssl ?\n\t\t\tnet_connect_ip_ssl(ip, port, own_ip, server->connrec->ssl_cert, server->connrec->ssl_pkey,\nserver->connrec->ssl_cafile, server->connrec->ssl_capath, server->connrec->ssl_verify) :\n\t\t\tnet_connect_ip(ip, port, own_ip);\n\t} else {\n\t\thandle = net_connect_unix(unix_socket);\n\t}","target":1,"flaw_line_index":0,"hash":"261510a9-6d3f-4e34-b64e-dbf459c73507","idx":"a8f1e5ec-9b9a-400d-8aff-58f4d822d995"}
{"func_before":"\t\t\t(IPADDR_IS_V6(ip) ? server->connrec->own_ip6 :\n\t\t\t server->connrec->own_ip4);\n\t\tport = server->connrec->proxy != NULL ?\n\t\t\tserver->connrec->proxy_port : server->connrec->port;\n\t\thandle = server->connrec->use_ssl ?\n\t\t\tnet_connect_ip_ssl(ip, port, server->connrec->address, own_ip, server->connrec->ssl_cert, server->connrec->ssl_pkey,\nserver->connrec->ssl_cafile, server->connrec->ssl_capath, server->connrec->ssl_verify) :\n\t\t\tnet_connect_ip(ip, port, own_ip);\n\t} else {\n\t\thandle = net_connect_unix(unix_socket);\n\t}","target":0,"flaw_line_index":0,"hash":"9d2d25f9-0edd-4b01-88ff-eae5a42c921c","idx":"29f5d6b9-7c89-40b7-b8fd-910125f826ed"}
{"func_before":"static void iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\n\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n\t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n\t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t}\n}","target":1,"flaw_line_index":0,"hash":"780a81db-9649-48ce-abfe-dadfc95db9c2","idx":"78b6ad40-7f0d-42b6-b976-ec39806c0aa1"}
{"func_before":"static int iwl_sta_ucode_activate(struct iwl_priv *priv, u8 sta_id)\n{\n\tif (sta_id >= IWLAGN_STATION_COUNT) {\n\t\tIWL_ERR(priv, \"invalid sta_id %u\", sta_id);\n\t\treturn -EINVAL;\n\t}\n\tif (!(priv->stations[sta_id].used & IWL_STA_DRIVER_ACTIVE))\n\t\tIWL_ERR(priv, \"ACTIVATE a non DRIVER active station id %u \"\n\t\t\t\"addr %pM\\n\",\n\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\n\tif (priv->stations[sta_id].used & IWL_STA_UCODE_ACTIVE) {\n\t\tIWL_DEBUG_ASSOC(priv,\n\t\t\t\t\"STA id %u addr %pM already present in uCode \"\n\t\t\t\t\"(according to driver)\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t} else {\n\t\tpriv->stations[sta_id].used |= IWL_STA_UCODE_ACTIVE;\n\t\tIWL_DEBUG_ASSOC(priv, \"Added STA id %u addr %pM to uCode\\n\",\n\t\t\t\tsta_id, priv->stations[sta_id].sta.sta.addr);\n\t}\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"699aaced-9fc1-47c9-a34b-75e2021e431d","idx":"b97ece88-e052-46b2-a36e-8f660b0665d8"}
{"func_before":"{\n\t\/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t *\/\n\tu64 nsec = (u64)jiffies * TICK_NSEC;\n\tvalue->tv_sec = div_long_long_rem(nsec, NSEC_PER_SEC, &value->tv_nsec);\n}","target":1,"flaw_line_index":0,"hash":"58fcdec4-97be-4697-8a5d-5c66363b5701","idx":"af2b5ee7-dbca-434f-acfd-73758251e69d"}
{"func_before":"{\n\t\/*\n\t * Convert jiffies to nanoseconds and separate with\n\t * one divide.\n\t *\/\n\tu32 rem;\n\tvalue->tv_sec = div_u64_rem((u64)jiffies * TICK_NSEC,\n\t\t\t\t    NSEC_PER_SEC, &rem);\n\tvalue->tv_nsec = rem;\n}","target":0,"flaw_line_index":0,"hash":"11742402-4ba2-40ea-ba86-3744944cf523","idx":"7268a9e8-af65-4701-867f-2d237d5051ae"}
{"func_before":"static void follow_dotdot(struct nameidata *nd)\n{\n\tif (!nd->root.mnt)\n\t\tset_root(nd);\n\n\twhile(1) {\n\t\tstruct dentry *old = nd->path.dentry;\n\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\t\/* rare case of legitimate dget_parent()... *\/\n\t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n\t\t\tdput(old);\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n}","target":1,"flaw_line_index":0,"hash":"655785af-ceb1-48d3-9a1d-f84f1036c0e0","idx":"c7c5e375-3f14-434e-ad30-293303f03c12"}
{"func_before":"static int follow_dotdot(struct nameidata *nd)\n{\n\tif (!nd->root.mnt)\n\t\tset_root(nd);\n\n\twhile(1) {\n\t\tstruct dentry *old = nd->path.dentry;\n\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\t\/* rare case of legitimate dget_parent()... *\/\n\t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n\t\t\tdput(old);\n\t\t\tif (unlikely(!path_connected(&nd->path)))\n\t\t\t\treturn -ENOENT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"1fe0a624-8cb3-4e12-9495-3ea179933130","idx":"9b710780-81ed-4873-a33e-d5e7f9530b8b"}
{"func_before":"\t\t    exit(0);\n\t\tcase '~':\n\t\t    if (pkt->cnt > 0) {\n\t\t\tq = dir;\n\t\t\tif (pkt->esc) {\n\t\t\t    printf(\"%s aborted packet:\\n     \", dir);\n\t\t\t    q = \"    \";\n\t\t\t}\n\t\t\tnb = pkt->cnt;\n\t\t\tp = pkt->buf;\n\t\t\tpkt->cnt = 0;\n\t\tdefault:\n\t\t    if (pkt->esc) {\n\t\t\tc ^= 0x20;\n\t\t\tpkt->esc = 0;\n\t\t    }\n\t\t    pkt->buf[pkt->cnt++] = c;\n\t\t    break;\n\t\t}\n\t    }\n\t    break;\n\tcase 3:","target":1,"flaw_line_index":0,"hash":"ed47ed5a-446e-4843-bcff-6ca4ccef066b","idx":"64405548-49ca-451a-8ba6-f0a4ae78a7b8"}
{"func_before":"\t\tcase '~':\n\t\t    if (pkt->cnt > 0) {\n\t\t\tq = dir;\n\t\t\tif (pkt->esc) {\n\t\t\t    printf(\"%s aborted packet:\\n     \", dir);\n\t\t\t    q = \"    \";\n\t\t\t}\n\t\t\tif (pkt->cnt >= sizeof(pkt->buf)) {\n\t\t\t    printf(\"%s over-long packet truncated:\\n     \", dir);\n\t\t\t    q = \"    \";\n\t\t\t}\n\t\t\tnb = pkt->cnt;\n\t\t\tp = pkt->buf;\n\t\t\tpkt->cnt = 0;\n\t\tdefault:\n\t\t    if (pkt->esc) {\n\t\t\tc ^= 0x20;\n\t\t\tpkt->esc = 0;\n\t\t    }\n\t\t    if (pkt->cnt < sizeof(pkt->buf))\n\t\t\tpkt->buf[pkt->cnt++] = c;\n\t\t    break;\n\t\t}\n\t    }\n\t    break;\n\tcase 3:","target":0,"flaw_line_index":0,"hash":"b027d465-dd30-4062-a43d-9f9387b32a60","idx":"71625dab-fc6f-4953-96ac-b47b6bb8aae1"}
{"func_before":"    void resize (std::size_t new_size_) { _buf_size = new_size_; }","target":1,"flaw_line_index":0,"hash":"7f2c9353-c46e-4716-8bdd-784a24213584","idx":"8c953d2c-fb7b-4e88-8e5f-7f15dccda1b1"}
{"func_before":"    void resize (std::size_t new_size_) { LIBZMQ_UNUSED (new_size_); }","target":0,"flaw_line_index":0,"hash":"2e7ae0b1-6621-4fc4-ad46-4d675a65b870","idx":"d15e55e9-b77f-4ccf-8fee-82184cc22acc"}
{"func_before":"static VALUE from_document(VALUE klass, VALUE document)\n{\n  xmlDocPtr doc;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n\n  Data_Get_Struct(document, xmlDoc, doc);\n\n  \/* In case someone passes us a node. ugh. *\/\n  doc = doc->doc;\n\n  ctx = xmlRelaxNGNewDocParserCtxt(doc);\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n\n  return rb_schema;\n}","target":1,"flaw_line_index":0,"hash":"32780928-001b-4b51-b8c3-848fe5c3ea92","idx":"49078e88-8272-4c36-ab9c-59d82e902a0d"}
{"func_before":"static VALUE from_document(int argc, VALUE *argv, VALUE klass)\n{\n  VALUE document;\n  VALUE parse_options;\n  xmlDocPtr doc;\n  xmlRelaxNGParserCtxtPtr ctx;\n  xmlRelaxNGPtr schema;\n  VALUE errors;\n  VALUE rb_schema;\n  int scanned_args = 0;\n\n  scanned_args = rb_scan_args(argc, argv, \"11\", &document, &parse_options);\n\n  Data_Get_Struct(document, xmlDoc, doc);\n  doc = doc->doc; \/* In case someone passes us a node. ugh. *\/\n\n  if (scanned_args == 1) {\n    parse_options = rb_const_get(rb_const_get(mNokogiriXml, rb_intern(\"ParseOptions\")), rb_intern(\"DEFAULT_SCHEMA\"));\n  }\n\n  ctx = xmlRelaxNGNewDocParserCtxt(doc);\n\n  errors = rb_ary_new();\n  xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher);\n    return Qnil;\n  }\n\n  rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema);\n  rb_iv_set(rb_schema, \"@errors\", errors);\n  rb_iv_set(rb_schema, \"@parse_options\", parse_options);\n\n  return rb_schema;\n}","target":0,"flaw_line_index":0,"hash":"9ff988af-1d13-4735-8cf6-2feaf5c1460b","idx":"3d8d3359-f714-455e-95b3-88821bbe28ad"}
{"func_before":"        int          Read(void* pDestBuffer, int nSize)\n        {\n            if ( m_nPos + nSize >= m_nLen )\n                nSize = m_nLen - m_nPos - 1;\n\n            memcpy( pDestBuffer, (m_sFile + m_nPos), nSize );\n            m_nPos += nSize;\n\n            return nSize;","target":1,"flaw_line_index":0,"hash":"c96cacda-7549-4515-8b89-aae5aa99e136","idx":"cba81fc4-9532-460e-b552-85c68401475b"}
{"func_before":"        int          Read(void* pDestBuffer, unsigned int nSize)\n        {\n            if (m_nPos >= m_nLen)\n                nSize = 0;\n            else if (nSize > (m_nLen - m_nPos))\n                nSize = m_nLen - m_nPos;\n\n            memcpy( pDestBuffer, (m_sFile + m_nPos), nSize );\n            m_nPos += nSize;\n\n            return nSize;","target":0,"flaw_line_index":0,"hash":"ccc3981c-8674-4e9d-884a-d753cd830a33","idx":"8d447d11-d7fb-42d1-abc4-96da0041f1de"}
{"func_before":"\n    const int dxw = (dxx - (1 << (16 + shift))) * (w - 1);\n    const int dyh = (dyy - (1 << (16 + shift))) * (h - 1);\n    const int dxh = dxy * (h - 1);\n    const int dyw = dyx * (w - 1);\n    int need_emu  =  (unsigned) ix >= width  - w ||\n                     (unsigned) iy >= height - h;\n\n    if ( \/\/ non-constant fullpel offset (3% of blocks)\n        ((ox ^ (ox + dxw)) | (ox ^ (ox + dxh)) | (ox ^ (ox + dxw + dxh)) |\n         (oy ^ (oy + dyw)) | (oy ^ (oy + dyh)) | (oy ^ (oy + dyw + dyh))) >> (16 + shift) ||\n        \/\/ uses more than 16 bits of subpel mv (only at huge resolution)","target":1,"flaw_line_index":0,"hash":"81f05d09-4aa0-4391-ba34-fe922598dfad","idx":"39a5dfae-c1ae-41c9-b553-bed1ba3f2f10"}
{"func_before":"\n    const int dxw = (dxx - (1 << (16 + shift))) * (w - 1);\n    const int dyh = (dyy - (1 << (16 + shift))) * (h - 1);\n    const int dxh = dxy * (h - 1);\n    const int dyw = dyx * (w - 1);\n    int need_emu  =  (unsigned) ix >= width  - w || width < w ||\n                     (unsigned) iy >= height - h || height< h\n                     ;\n\n    if ( \/\/ non-constant fullpel offset (3% of blocks)\n        ((ox ^ (ox + dxw)) | (ox ^ (ox + dxh)) | (ox ^ (ox + dxw + dxh)) |\n         (oy ^ (oy + dyw)) | (oy ^ (oy + dyh)) | (oy ^ (oy + dyw + dyh))) >> (16 + shift) ||\n        \/\/ uses more than 16 bits of subpel mv (only at huge resolution)","target":0,"flaw_line_index":0,"hash":"83c666c2-e2e7-4b9f-bdf3-d3fd3dd4f5e4","idx":"a217701c-fd1f-4678-9bca-d3d1c3699740"}
{"func_before":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n  output->type = input->type;\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input->dims);","target":1,"flaw_line_index":0,"hash":"c5ab60b8-77a6-45cc-bd25-959ad9cd2ddd","idx":"d6cb9643-32d3-41c7-8b32-e367da24a066"}
{"func_before":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);\n  output->type = input->type;\n  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input->dims);","target":0,"flaw_line_index":0,"hash":"1c78e12f-8556-4f23-a1f6-111e96f7e831","idx":"6a6929a2-706e-4bfc-a11b-bca00867def7"}
{"func_before":"\t\t    isTiled(tif) ? \"Tiles\" : \"Strips\");\n\t\tfor (s = 0; s < td->td_nstrips; s++)\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tfprintf(fd, \"    %3lu: [%8I64u, %8I64u]\\n\",\n\t\t\t    (unsigned long) s,\n\t\t\t    (unsigned __int64) td->td_stripoffset[s],\n\t\t\t    (unsigned __int64) td->td_stripbytecount[s]);\n#else\n\t\t\tfprintf(fd, \"    %3lu: [%8llu, %8llu]\\n\",\n\t\t\t    (unsigned long) s,\n\t\t\t    (unsigned long long) td->td_stripoffset[s],\n\t\t\t    (unsigned long long) td->td_stripbytecount[s]);\n#endif\n\t}\n}","target":1,"flaw_line_index":0,"hash":"f7cc581b-1c34-41c4-9074-972bfca05ae6","idx":"d98fff94-ca77-41b9-98ce-788150f4092f"}
{"func_before":"\t\t    isTiled(tif) ? \"Tiles\" : \"Strips\");\n\t\tfor (s = 0; s < td->td_nstrips; s++)\n#if defined(__WIN32__) && (defined(_MSC_VER) || defined(__MINGW32__))\n\t\t\tfprintf(fd, \"    %3lu: [%8I64u, %8I64u]\\n\",\n\t\t\t    (unsigned long) s,\n\t\t\t    td->td_stripoffset ? (unsigned __int64) td->td_stripoffset[s] : 0,\n\t\t\t    td->td_stripbytecount ? (unsigned __int64) td->td_stripbytecount[s] : 0);\n#else\n\t\t\tfprintf(fd, \"    %3lu: [%8llu, %8llu]\\n\",\n\t\t\t    (unsigned long) s,\n\t\t\t    td->td_stripoffset ? (unsigned long long) td->td_stripoffset[s] : 0,\n\t\t\t    td->td_stripbytecount ? (unsigned long long) td->td_stripbytecount[s] : 0);\n#endif\n\t}\n}","target":0,"flaw_line_index":0,"hash":"c3c09dc5-a415-4c9c-a12a-baad2ca3de5f","idx":"26789840-0f25-41e4-b94f-8127eca3ec5c"}
{"func_before":"        \/\/ effect\n        if (pat->data[i][index]==-1) {\n          sprintf(id,\"..##PE%d_%d_%d\",k,i,j);\n          ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        } else {\n          sprintf(id,\"%.2X##PE%d_%d_%d\",pat->data[i][index],k,i,j);\n          if (pat->data[i][index]<0x10) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[pat->data[i][index]]]);\n          } else if (pat->data[i][index]<0x20) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n          } else if (pat->data[i][index]<0x30) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);\n          } else if (pat->data[i][index]<0x48) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n          } else if (pat->data[i][index]<0x90) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else if (pat->data[i][index]<0xa0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);\n          } else if (pat->data[i][index]<0xc0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else if (pat->data[i][index]<0xd0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);\n          } else if (pat->data[i][index]<0xe0) {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else {\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[pat->data[i][index]-0xe0]]);\n          }\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffect) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  ","target":1,"flaw_line_index":0,"hash":"fecf03f6-7507-473b-a039-f14421adc87d","idx":"6eb04035-2543-4052-8e05-4b907385ff73"}
{"func_before":"        \/\/ effect\n        if (pat->data[i][index]==-1) {\n          sprintf(id,\"..##PE%d_%d_%d\",k,i,j);\n          ImGui::PushStyleColor(ImGuiCol_Text,inactiveColor);\n        } else {\n          if (pat->data[i][index]>0xff) {\n            sprintf(id,\"??##PE%d_%d_%d\",k,i,j);\n            ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n          } else {\n            const unsigned char data=pat->data[i][index];\n            sprintf(id,\"%.2X##PE%d_%d_%d\",data,k,i,j);\n            if (data<0x10) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[fxColors[data]]);\n            } else if (data<0x20) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n            } else if (data<0x30) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_SECONDARY]);\n            } else if (data<0x48) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SYS_PRIMARY]);\n            } else if (data<0x90) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else if (data<0xa0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_MISC]);\n            } else if (data<0xc0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else if (data<0xd0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_SPEED]);\n            } else if (data<0xe0) {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[GUI_COLOR_PATTERN_EFFECT_INVALID]);\n            } else {\n              ImGui::PushStyleColor(ImGuiCol_Text,uiColors[extFxColors[data-0xe0]]);\n            }\n          }\n        }\n        ImGui::SameLine(0.0f,0.0f);\n        if (cursorEffect) {\n          ImGui::PushStyleColor(ImGuiCol_Header,uiColors[GUI_COLOR_PATTERN_CURSOR]);  ","target":0,"flaw_line_index":0,"hash":"a64ab2b0-3e3f-4a49-bea8-bbf1beb1c6e5","idx":"315ab95a-15f3-4fe5-8e71-7e0c1a85fd88"}
{"func_before":"{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint16* wp = (uint16*) cp0;\n\ttmsize_t wc = cc \/ 2;\n\n\tassert((cc%(2*stride))==0);\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] + (unsigned int)wp[0]) & 0xffff); wp++)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n}","target":1,"flaw_line_index":0,"hash":"c4e32e2b-fa8a-4f55-8e4f-0e38e58fb6b7","idx":"e9c231c0-bb29-465a-8448-2c9d9d532b6b"}
{"func_before":"{\n\ttmsize_t stride = PredictorState(tif)->stride;\n\tuint16* wp = (uint16*) cp0;\n\ttmsize_t wc = cc \/ 2;\n\n    if((cc%(2*stride))!=0)\n    {\n        TIFFErrorExt(tif->tif_clientdata, \"horAcc16\",\n                     \"%s\", \"cc%(2*stride))!=0\");\n        return 0;\n    }\n\n\tif (wc > stride) {\n\t\twc -= stride;\n\t\tdo {\n\t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] + (unsigned int)wp[0]) & 0xffff); wp++)\n\t\t\twc -= stride;\n\t\t} while (wc > 0);\n\t}\n\treturn 1;\n}","target":0,"flaw_line_index":0,"hash":"595916c9-d66d-47b0-8072-64380de9162d","idx":"c8059b96-2197-41d9-9b99-0b1f351e91c4"}
{"func_before":"PJ_DEF(pj_status_t) pjstun_parse_msg( void *buf, pj_size_t buf_len, \n\t\t\t\t      pjstun_msg *msg)\n{\n    pj_uint16_t msg_type, msg_len;\n    char *p_attr;\n\n    PJ_CHECK_STACK();\n\n    msg->hdr = (pjstun_msg_hdr*)buf;\n    msg_type = pj_ntohs(msg->hdr->type);\n    }\n\n    msg->attr_count = 0;\n    p_attr = (char*)buf + sizeof(pjstun_msg_hdr);\n\n    while (msg_len > 0) {\n\tpjstun_attr_hdr **attr = &msg->attr[msg->attr_count];\n\tpj_uint32_t len;\n\tpj_uint16_t attr_type;\n\n\t*attr = (pjstun_attr_hdr*)p_attr;\n\t}\n\n\tmsg_len = (pj_uint16_t)(msg_len - len);\n\tp_attr += len;\n\t++msg->attr_count;\n    }\n\n    return PJ_SUCCESS;\n}","target":1,"flaw_line_index":0,"hash":"e358d0a6-c301-4899-a2e5-6d14c0e7f2df","idx":"e33fa2fd-22a6-4a25-b774-1d763a695f18"}
{"func_before":"PJ_DEF(pj_status_t) pjstun_parse_msg( void *buf, pj_size_t buf_len, \n\t\t\t\t      pjstun_msg *msg)\n{\n    pj_uint16_t msg_type, msg_len;\n    char *p_attr;\n    int attr_max_cnt = PJ_ARRAY_SIZE(msg->attr);\n\n    PJ_CHECK_STACK();\n\n    msg->hdr = (pjstun_msg_hdr*)buf;\n    msg_type = pj_ntohs(msg->hdr->type);\n    }\n\n    msg->attr_count = 0;\n    p_attr = (char*)buf + sizeof(pjstun_msg_hdr);\n\n    while (msg_len > 0 && msg->attr_count < attr_max_cnt) {\n\tpjstun_attr_hdr **attr = &msg->attr[msg->attr_count];\n\tpj_uint32_t len;\n\tpj_uint16_t attr_type;\n\n\t*attr = (pjstun_attr_hdr*)p_attr;\n\n\tmsg_len = (pj_uint16_t)(msg_len - len);\n\tp_attr += len;\n\t++msg->attr_count;\n    }\n    if (msg->attr_count == attr_max_cnt) {\n\tPJ_LOG(4, (THIS_FILE, \"Warning: max number attribute %d reached.\",\n\t\t   attr_max_cnt));\n    }\n\n    return PJ_SUCCESS;\n}","target":0,"flaw_line_index":0,"hash":"61b052a5-cfde-40e5-bc44-7192ab6dc882","idx":"0551fb77-65bf-4336-9079-870130076922"}
{"func_before":"\n   \/\/Retrieve the length of the DHCP message\n   length = netBufferGetLength(buffer) - offset;\n\n   \/\/Make sure the DHCP message is valid\n   if(length < sizeof(DhcpMessage))\n      return;\n   if(length > DHCP_MAX_MSG_SIZE)\n      return;\n\n   \/\/Point to the beginning of the DHCP message\n   message = netBufferAt(buffer, offset);\n   \/\/Sanity check\n   \/\/Dump the contents of the message for debugging purpose\n   dhcpDumpMessage(message, length);\n\n   \/\/The DHCP server shall respond with a BOOTREPLY opcode\n   if(message->op != DHCP_OPCODE_BOOTREPLY)\n      return;\n   \/\/Enforce hardware type\n   if(message->htype != DHCP_HARDWARE_TYPE_ETH)\n      return;\n   \/\/Check the length of the hardware address\n   if(message->hlen != sizeof(MacAddr))\n      return;\n   \/\/Check magic cookie\n   if(message->magicCookie != HTONL(DHCP_MAGIC_COOKIE))\n      return;\n\n   \/\/The DHCP Message Type option must be included in every DHCP message","target":1,"flaw_line_index":0,"hash":"7cb57bec-c7cf-4a8a-95d9-f9df862f9799","idx":"7b09fdcd-bedb-489a-b6dc-e84c7afd7e78"}
{"func_before":"\n   \/\/Retrieve the length of the DHCP message\n   length = netBufferGetLength(buffer) - offset;\n\n   \/\/Make sure the DHCP message is valid\n   if(length < sizeof(DhcpMessage) || length > DHCP_MAX_MSG_SIZE)\n      return;\n\n   \/\/Point to the beginning of the DHCP message\n   message = netBufferAt(buffer, offset);\n   \/\/Sanity check\n   dhcpDumpMessage(message, length);\n\n   \/\/The DHCP server shall respond with a BOOTREPLY opcode\n   if(message->op != DHCP_OPCODE_BOOTREPLY)\n      return;\n\n   \/\/Enforce hardware type\n   if(message->htype != DHCP_HARDWARE_TYPE_ETH)\n      return;\n\n   \/\/Check the length of the hardware address\n   if(message->hlen != sizeof(MacAddr))\n      return;\n\n   \/\/Check magic cookie\n   if(message->magicCookie != HTONL(DHCP_MAGIC_COOKIE))\n      return;\n\n   \/\/The DHCP Message Type option must be included in every DHCP message","target":0,"flaw_line_index":0,"hash":"95622081-d780-4423-959a-2abd7a1cc458","idx":"b1bc56d8-d4f9-40c4-a9ac-7e20ccd8bcbc"}
{"func_before":"void bn_rec_naf(int8_t *naf, int *len, const bn_t k, int w) {\n\tint i, l;\n\tbn_t t;\n\tdig_t t0, mask;\n\tint8_t u_i;\n","target":1,"flaw_line_index":0,"hash":"be094f8a-1651-44be-ac1b-69c6e239d90f","idx":"7c73ed61-c1e1-4afc-b1a5-c1d6c8a6c10c"}
{"func_before":"void bn_rec_naf(int8_t *naf, size_t *len, const bn_t k, size_t w) {\n\tint i, l;\n\tbn_t t;\n\tdig_t t0, mask;\n\tint8_t u_i;\n","target":0,"flaw_line_index":0,"hash":"fc4c0b32-7b25-44aa-8cc7-9d97f11f2e00","idx":"28088777-088b-4225-8258-7139201dff32"}
{"func_before":"    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}","target":1,"flaw_line_index":0,"hash":"4cc2030d-593e-4d57-8184-a6477bb3a927","idx":"66913e27-aa5b-46ca-9920-af4f48f79e8d"}
{"func_before":"    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->sym_next)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}","target":0,"flaw_line_index":0,"hash":"0264a3c4-8501-4e09-a520-db7e8db03e1c","idx":"26578744-2c94-4188-a775-84a02486317c"}
{"func_before":"                         const Proto *p) {\n  int i;\n  int actual = cast_int(L->top - ci->func) - 1;  \/* number of arguments *\/\n  int nextra = actual - nfixparams;  \/* number of extra arguments *\/\n  ci->u.l.nextraargs = nextra;\n  checkstackGC(L, p->maxstacksize + 1);\n  \/* copy function to the top of the stack *\/\n  setobjs2s(L, L->top++, ci->func);\n  \/* move fixed parameters to the top of the stack *\/\n  for (i = 1; i <= nfixparams; i++) {\n    setobjs2s(L, L->top++, ci->func + i);","target":1,"flaw_line_index":0,"hash":"906ecc89-fdf0-4ee7-881c-0d78a096bc43","idx":"52713657-743a-4ed9-90c2-26c2075b8590"}
{"func_before":"                         const Proto *p) {\n  int i;\n  int actual = cast_int(L->top - ci->func) - 1;  \/* number of arguments *\/\n  int nextra = actual - nfixparams;  \/* number of extra arguments *\/\n  ci->u.l.nextraargs = nextra;\n  luaD_checkstack(L, p->maxstacksize + 1);\n  \/* copy function to the top of the stack *\/\n  setobjs2s(L, L->top++, ci->func);\n  \/* move fixed parameters to the top of the stack *\/\n  for (i = 1; i <= nfixparams; i++) {\n    setobjs2s(L, L->top++, ci->func + i);","target":0,"flaw_line_index":0,"hash":"b1b75567-a126-4b09-8e30-b95a009ba0f6","idx":"ba3a6df1-79c4-40d9-b900-5f974f559772"}
{"func_before":"\t    break;\n\t  }\n\tcase 'T':\n\t  {\n\t    time_t t;\n\t    struct tm *lt;\n\t    const char *tstring;\n\t    char buffer[sizeof(\"Www Mmm dd hh:mm:ss yyyyy\\n\")];\n\t    uint32_t x;\n\n\t    switch (atoi(fmt + 1)) {\n\t    case 1:\n\t\tx = GET_LE_U_4(buf);\n\t    default:\n\t\tt = 0;\n\t\tbreak;\n\t    }\n\t    if (t != 0) {\n\t\tlt = localtime(&t);\n\t\tif (lt != NULL) {\n\t\t    strftime(buffer, sizeof(buffer), \"%a %b %e %T %Y%n\", lt);\n\t\t    tstring = buffer;\n\t\t}\n\t\telse\n\t\t    tstring = \"(Can't convert time)\\n\";\n\t    } else\n\t\ttstring = \"NULL\\n\";\n\t    ND_PRINT(\"%s\", tstring);\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }","target":1,"flaw_line_index":0,"hash":"7839ecfd-96e8-49e4-bdac-d674ac5d3f74","idx":"5e296004-04b5-49a5-a458-e542aa7fcc59"}
{"func_before":"\t\tfmt++;\n\t    break;\n\t  }\n\tcase 'T':\n\t  {\n\t    time_t t;\n\t    const char *tstring;\n\t    char buffer[sizeof(\"Www Mmm dd hh:mm:ss yyyyy\")];\n\t    uint32_t x;\n\n\t    switch (atoi(fmt + 1)) {\n\t    case 1:\n\t\tx = GET_LE_U_4(buf);\n\t    default:\n\t\tt = 0;\n\t\tbreak;\n\t    }\n\t    if (t != 0) {\n\t\t    tstring = nd_format_time(buffer, sizeof(buffer), \"%a %b %e %T %Y\",\n\t\t    localtime(&t));\n\t    } else\n\t\ttstring = \"NULL\";\n\t    ND_PRINT(\"%s\\n\", tstring);\n\t    fmt++;\n\t    while (ND_ASCII_ISDIGIT(*fmt))\n\t\tfmt++;\n\t    break;\n\t  }","target":0,"flaw_line_index":0,"hash":"74442e09-908b-4462-8cc6-9f3363f3becd","idx":"dc9e729f-ab2c-4956-ab04-6c13c749bfc6"}
{"func_before":"int l2tp_recv(int fd, struct l2tp_packet_t **p, struct in_pktinfo *pkt_info,\n\t      const char *secret, size_t secret_len)\n{\n\tint n, length;\n\tuint8_t *buf;\n\tstruct l2tp_hdr_t *hdr;\n\tstruct l2tp_avp_t *avp;\n\tstruct l2tp_dict_attr_t *da;\n\tstruct l2tp_attr_t *attr, *RV = NULL;\n\tuint8_t *ptr;\n\tstruct l2tp_packet_t *pack;\n\tstruct sockaddr_in addr;\n\tsocklen_t len = sizeof(addr);\n\tstruct msghdr msg;\n\tchar msg_control[128];\n\tstruct cmsghdr *cmsg;\n\tuint16_t orig_avp_len;\n\tvoid *orig_avp_val;\n\n  *p = NULL;\n\n\tif (pkt_info) {\n\t\tmemset(&msg, 0, sizeof(msg));\n\t\tmsg.msg_control = msg_control;\n\t\tmsg.msg_controllen = 128;\n\n\t\tn = recvmsg(fd, &msg, MSG_PEEK);\n\n\t\tif (n < 0) {\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn -1;\n\t\t\tlog_error(\"l2tp: recvmsg: %s\\n\", strerror(errno));\n\t\t\treturn 0;\n\t\treturn 0;\n\t}\n\thdr = (struct l2tp_hdr_t *)buf;\n\tptr = (uint8_t *)(hdr + 1);\n\n\tn = recvfrom(fd, buf, L2TP_MAX_PACKET_SIZE, 0, &addr, &len);\n\n\tif (n < 0) {\n\t\tmempool_free(buf);\n\t\tif (errno == EAGAIN) {\n\t\t\treturn -1;\n\t\t} else if (errno == ECONNREFUSED) {\n\t\t}\n\t\tlog_error(\"l2tp: recv: %s\\n\", strerror(errno));\n\t\treturn 0;\n\t}\n\n\tif (n < 6) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: short packet received (%i\/%zu)\\n\", n, sizeof(*hdr));\n\t\tgoto out_err_hdr;\n\t}\n\n\tif (hdr->T == 0)\n\t\tgoto out_err_hdr;\n\n\tif (n < ntohs(hdr->length)) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: short packet received (%i\/%i)\\n\", n, ntohs(hdr->length));\n\t\tgoto out_err_hdr;\n\t}\n\n\tif (hdr->ver == 2) {\n\t\tif (hdr->L == 0) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect message received (L=0)\\n\");\n\t\t\tif (!conf_avp_permissive)\n\t\t\t    goto out_err_hdr;\n\t\t}\n\n\t\tif (hdr->S == 0) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect message received (S=0)\\n\");\n\t\t\tif (!conf_avp_permissive)\n\t\t\t    goto out_err_hdr;\n\t\t}\n\n\t\tif (hdr->O == 1) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect message received (O=1)\\n\");\n\t\t\tif (!conf_avp_permissive)\n\t\t\t    goto out_err_hdr;\n\t\t}\n\t} else if (hdr->ver != 3) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: protocol version %i is not supported\\n\", hdr->ver);\n\t\tgoto out_err_hdr;\n\t}\n\n\tpack = mempool_alloc(pack_pool);\n\tif (!pack) {\n\tmemset(pack, 0, sizeof(*pack));\n\tINIT_LIST_HEAD(&pack->attrs);\n\n\tmemcpy(&pack->addr, &addr, sizeof(addr));\n\tmemcpy(&pack->hdr, hdr, sizeof(*hdr));\n\tlength = ntohs(hdr->length) - sizeof(*hdr);\n\n\twhile (length) {\n\t\t*(uint16_t *)ptr = ntohs(*(uint16_t *)ptr);\n\t\tavp = (struct l2tp_avp_t *)ptr;\n\n\t\tif (avp->length > length) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect avp received (exceeds message length)\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (avp->vendor)\n\t\t\tgoto skip;\n\n\t\tda = l2tp_dict_find_attr_by_id(ntohs(avp->type));\n\t\tif (!da) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: unknown avp received (type=%i, M=%u)\\n\", ntohs(avp->type), avp->M);\n\t\t\tif (avp->M && !conf_avp_permissive)\n\t\t\t\tgoto out_err;\n\t\t} else {\n\t\t\tif (da->M != -1 && da->M != avp->M) {\n\t\t\t\tif (conf_verbose)\n\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, M=%i, must be %i)\\n\", ntohs(avp->type), avp->M, da->M);\n\t\t\t\tif (!conf_avp_permissive)\n\t\t\t\t    goto out_err;\n\t\t\t}\n\n\t\t\tif (da->H != -1 && da->H != avp->H) {\n\t\t\t\tif (conf_verbose)\n\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, H=%i, must be %i)\\n\", ntohs(avp->type), avp->H, da->H);\n\t\t\t\tif (!conf_avp_permissive)\n\t\t\t\t    goto out_err;\n\t\t\t}\n\n\t\t\tif (avp->H) {\n\t\t\t\tif (!RV) {\n\t\t\t\t\tif (conf_verbose)\n\t\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, H=1, but Random-Vector is not received)\\n\", ntohs(avp->type));\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\t\t\t  ntohs(avp->type));\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tif (decode_avp(avp, RV, secret, secret_len) < 0)\n\t\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\tattr = mempool_alloc(attr_pool);\n\t\t\tmemset(attr, 0, sizeof(*attr));\n\t\t\tlist_add_tail(&attr->entry, &pack->attrs);\n\n\t\t\tif (avp->H) {\n\t\t\t\torig_avp_len = ntohs(*(uint16_t *)avp->val) + sizeof(*avp);\n\t\t\t\torig_avp_val = avp->val + sizeof(uint16_t);\n\t\t\t} else {\n\t\t\t\torig_avp_len = avp->length;\n\t\t\t\torig_avp_val = avp->val;\n\t\t\t}\n\n\t\t\tattr->attr = da;\n\t\t\tattr->M = avp->M;\n\t\t\tattr->H = 0;\n\t\t\tattr->length = orig_avp_len - sizeof(*avp);\n\n\t\t\tif (attr->attr->id == Random_Vector)\n\t\t\t\tRV = attr;\n\n\t\t\tswitch (da->type) {\n\t\t\t\t\tattr->val.string[attr->length] = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nskip:\n\t\tptr += avp->length;\n\t\tlength -= avp->length;\n\t}\n\n\t*p = pack;\n\n\tmempool_free(buf);","target":1,"flaw_line_index":0,"hash":"fa31ca82-0efe-4a6c-9748-d45fff442997","idx":"aa5e6c8a-5d6d-4d86-995e-59d9739ad397"}
{"func_before":"int l2tp_recv(int fd, struct l2tp_packet_t **p, struct in_pktinfo *pkt_info,\n\t      const char *secret, size_t secret_len)\n{\n\tstruct l2tp_packet_t *pack;\n\tstruct l2tp_hdr_t *hdr;\n\tstruct l2tp_avp_t *avp;\n\tstruct l2tp_attr_t *RV = NULL;\n\tstruct sockaddr_in addr;\n\tsocklen_t addr_len;\n\tuint16_t orig_avp_len;\n\tvoid *orig_avp_val;\n\tuint8_t *buf, *ptr;\n\tint n, length;\n\n\t*p = NULL;\n\n\tif (pkt_info) {\n\t\tstruct msghdr msg;\n\t\tstruct cmsghdr *cmsg;\n\t\tchar msg_control[128];\n\n\t\tmemset(&msg, 0, sizeof(msg));\n\t\tmsg.msg_control = msg_control;\n\t\tmsg.msg_controllen = sizeof(msg_control);\n\n\t\tn = recvmsg(fd, &msg, MSG_PEEK);\n\t\tif (n < 0) {\n\t\t\tif (errno == EAGAIN)\n\t\t\t\treturn -1;\n\t\t\tlog_error(\"l2tp: recvmsg: %s\\n\", strerror(errno));\n\t\t\treturn 0;\n\t\treturn 0;\n\t}\n\thdr = (struct l2tp_hdr_t *)buf;\n\tptr = (uint8_t *)(hdr + 1);\n\n\taddr_len = sizeof(addr);\n\tn = recvfrom(fd, buf, L2TP_MAX_PACKET_SIZE, 0, &addr, &addr_len);\n\tif (n < 0) {\n\t\tmempool_free(buf);\n\t\tif (errno == EAGAIN) {\n\t\t\treturn -1;\n\t\t} else if (errno == ECONNREFUSED) {\n\t\t}\n\t\tlog_error(\"l2tp: recv: %s\\n\", strerror(errno));\n\t\treturn 0;\n\t}\n\n\tif (n < sizeof(*hdr)) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: short packet received (%i\/%zu)\\n\", n, sizeof(*hdr));\n\t\tgoto out_err_hdr;\n\t}\n\n\thdr->flags = ntohs(hdr->flags);\n\tif (!(hdr->flags & L2TP_FLAG_T))\n\t\tgoto out_err_hdr;\n\tif (!(hdr->flags & L2TP_FLAG_L)) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: incorrect control message received (L=0)\\n\");\n\t\tgoto out_err_hdr;\n\t}\n\tif (!(hdr->flags & L2TP_FLAG_S)) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: incorrect control message received (S=0)\\n\");\n\t\tgoto out_err_hdr;\n\t}\n\tswitch (hdr->flags & L2TP_VER_MASK) {\n\tcase 2:\n\t\tif (hdr->flags & L2TP_FLAG_O) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect control message received (O=1)\\n\");\n\t\t\tgoto out_err_hdr;\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tbreak;\n\tdefault:\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: protocol version %i is not supported\\n\",\n\t\t\t\t hdr->flags & L2TP_VER_MASK);\n\t\tgoto out_err_hdr;\n\t}\n\n\tlength = ntohs(hdr->length);\n\tif (length < sizeof(*hdr)) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: short packet received (%i\/%zu)\\n\", length, sizeof(*hdr));\n\t\tgoto out_err_hdr;\n\t} else if (n < length) {\n\t\tif (conf_verbose)\n\t\t\tlog_warn(\"l2tp: short packet received (%i\/%i)\\n\", n, length);\n\t\tgoto out_err_hdr;\n\t}\n\n\tpack = mempool_alloc(pack_pool);\n\tif (!pack) {\n\tmemset(pack, 0, sizeof(*pack));\n\tINIT_LIST_HEAD(&pack->attrs);\n\n\tmemcpy(&pack->addr, &addr, sizeof(addr));\n\tmemcpy(&pack->hdr, hdr, sizeof(*hdr));\n\tlength -= sizeof(*hdr);\n\n\twhile (length > 0) {\n\t\tstruct l2tp_dict_attr_t *da;\n\t\tstruct l2tp_attr_t *attr;\n\t\tuint16_t avp_len;\n\n\t\tif (length < sizeof(*avp)) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: short avp received\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tavp = (struct l2tp_avp_t *)ptr;\n\t\tavp->flags = ntohs(avp->flags);\n\t\tavp_len = avp->flags & L2TP_AVP_LEN_MASK;\n\t\tif (avp_len < sizeof(*avp)) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: short avp received\\n\");\n\t\t\tgoto out_err;\n\t\t} else if (length < avp_len) {\n\t\t\tif (conf_verbose)\n\t\t\t\tlog_warn(\"l2tp: incorrect avp received (exceeds message length)\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (avp->vendor)\n\t\t\tgoto skip;\n\n\t\tda = l2tp_dict_find_attr_by_id(ntohs(avp->type));\n\t\tif (!da) {\n\t\t\tif (conf_verbose) {\n\t\t\t\tlog_warn(\"l2tp: unknown avp received (type=%i, M=%u)\\n\",\n\t\t\t\t\t ntohs(avp->type), !!(avp->flags & L2TP_AVP_FLAG_M));\n\t\t\t}\n\t\t\tif ((avp->flags & L2TP_AVP_FLAG_M) && !conf_avp_permissive)\n\t\t\t\tgoto out_err;\n\t\t} else {\n\t\t\tif (da->M != -1 && !da->M != !(avp->flags & L2TP_AVP_FLAG_M)) {\n\t\t\t\tif (conf_verbose) {\n\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, M=%i, must be %i)\\n\",\n\t\t\t\t\t\t ntohs(avp->type), !!(avp->flags & L2TP_AVP_FLAG_M), da->M);\n\t\t\t\t}\n\t\t\t\tif (!conf_avp_permissive)\n\t\t\t\t    goto out_err;\n\t\t\t}\n\n\t\t\tif (da->H != -1 && !da->H != !(avp->flags & L2TP_AVP_FLAG_H)) {\n\t\t\t\tif (conf_verbose) {\n\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, H=%i, must be %i)\\n\",\n\t\t\t\t\t\t ntohs(avp->type), !!(avp->flags & L2TP_AVP_FLAG_H), da->H);\n\t\t\t\t}\n\t\t\t\tif (!conf_avp_permissive)\n\t\t\t\t    goto out_err;\n\t\t\t}\n\n\t\t\tif (avp->flags & L2TP_AVP_FLAG_H) {\n\t\t\t\tif (!RV) {\n\t\t\t\t\tif (conf_verbose)\n\t\t\t\t\t\tlog_warn(\"l2tp: incorrect avp received (type=%i, H=1, but Random-Vector is not received)\\n\", ntohs(avp->type));\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\t\t\t  ntohs(avp->type));\n\t\t\t\t\tgoto out_err;\n\t\t\t\t}\n\t\t\t\tif (decode_avp(avp, RV, secret, secret_len) < 0)\n\t\t\t\t\tgoto out_err;\n\n\t\t\t\torig_avp_len = ntohs(*(uint16_t *)avp->val) + sizeof(*avp);\n\t\t\t\torig_avp_val = avp->val + sizeof(uint16_t);\n\t\t\t} else {\n\t\t\t\torig_avp_len = avp_len;\n\t\t\t\torig_avp_val = avp->val;\n\t\t\t}\n\n\t\t\tattr = mempool_alloc(attr_pool);\n\t\t\tmemset(attr, 0, sizeof(*attr));\n\t\t\tattr->attr = da;\n\t\t\tattr->M = !!(avp->flags & L2TP_AVP_FLAG_M);\n\t\t\tattr->H = 0;\n\t\t\tattr->length = orig_avp_len - sizeof(*avp);\n\t\t\tlist_add_tail(&attr->entry, &pack->attrs);\n\n\t\t\tif (attr->attr->id == Random_Vector)\n\t\t\t\tRV = attr;\n\n\t\t\tswitch (da->type) {\n\t\t\t\t\tattr->val.string[attr->length] = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nskip:\n\t\tptr += avp_len;\n\t\tlength -= avp_len;\n\t}\n\n\t*p = pack;\n\n\tmempool_free(buf);","target":0,"flaw_line_index":0,"hash":"6ed1a28d-6c97-4855-9c9f-ca7a198687d0","idx":"86b3d63d-1b03-4227-a00f-972b2283ef1c"}
{"func_before":"void *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_realloc called with %x,%zu\\n\", ptr, size));\n\tresult = realloc(ptr, size);\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p\\n\", ptr, size, result));\n\treturn result;\n}","target":1,"flaw_line_index":0,"hash":"7af2ceb6-fe43-4cae-9deb-a1d30fee2186","idx":"5a2fe60b-cb2d-47db-9370-e975de14fe05"}
{"func_before":"void *jas_realloc(void *ptr, size_t size)\n{\n\tvoid *result;\n\tJAS_DBGLOG(101, (\"jas_realloc(%x, %zu)\\n\", ptr, size));\n\tresult = realloc(ptr, size);\n\tJAS_DBGLOG(100, (\"jas_realloc(%p, %zu) -> %p\\n\", ptr, size, result));\n\treturn result;\n}","target":0,"flaw_line_index":0,"hash":"cda356ba-b435-43f5-a543-2eacf96cc71e","idx":"27347159-368a-44c9-bb4d-5ee4540ffd03"}
{"func_before":"auto ReferenceHandle::New(Local<Value> value, MaybeLocal<Object> options) -> unique_ptr<ReferenceHandle> {\n\tauto inherit = ReadOption<bool>(options, StringTable::Get().inheritUnsafe, false);\n\treturn std::make_unique<ReferenceHandle>(value, inherit);\n}","target":1,"flaw_line_index":0,"hash":"51e90361-0683-4e6f-89e1-2b91c32b5e01","idx":"8f8991b3-43ac-4eef-ad93-2268bfee07a2"}
{"func_before":"auto ReferenceHandle::New(Local<Value> value, MaybeLocal<Object> options) -> unique_ptr<ReferenceHandle> {\n\tauto inherit = ReadOption<bool>(options, StringTable::Get().unsafeInherit, false);\n\treturn std::make_unique<ReferenceHandle>(value, inherit);\n}","target":0,"flaw_line_index":0,"hash":"3beb16d2-bd47-4cb0-8570-4cdf040c33df","idx":"c398f81e-bbd4-4489-9eac-3a00e93f2a4b"}
{"func_before":"  static void setAppend(SetType& set, const VariantType& v) {\n    auto value_type = type(v);\n    if (value_type != HPHP::serialize::Type::INT64 &&\n        value_type != HPHP::serialize::Type::STRING) {\n      throw HPHP::serialize::UnserializeError(\n          \"Unsupported keyset element of type \" +\n          folly::to<std::string>(value_type));\n    }\n    set.append(v);\n  }","target":1,"flaw_line_index":0,"hash":"6d2a89c2-6308-4fe4-a16d-7a5f28c6772c","idx":"0b5bd250-7629-4d9a-a9a1-832423728abe"}
{"func_before":"  static void setAppend(SetType& set, const VariantType& v) {\n    if (!v.isInteger() && !v.isString()) {\n      throw HPHP::serialize::UnserializeError(\n        \"Keysets can only contain integers or strings\"\n      );\n    }\n    set.append(v);\n  }","target":0,"flaw_line_index":0,"hash":"b83f988b-ad2c-42da-8dd4-26f960f183d8","idx":"a90f2094-41ab-4a25-bdb2-fa7768a063bb"}
{"func_before":"\tatomic_dec(&chip->active);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n\n __error:\n\tif (chip) {\n\t\tif (!chip->num_interfaces)\n\t\t\tsnd_card_free(chip->card);\n\t\tatomic_dec(&chip->active);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}","target":1,"flaw_line_index":0,"hash":"c38d6805-d86b-41f1-ab1b-8ca81d2778fc","idx":"ff2ec47b-c901-4427-ae3d-8cb23900737d"}
{"func_before":"\tmutex_unlock(&register_mutex);\n\treturn 0;\n\n __error:\n\tif (chip) {\n\t\t\/* chip->active is inside the chip->card object,\n\t\t * decrement before memory is possibly returned.\n\t\t *\/\n\t\tatomic_dec(&chip->active);\n\t\tif (!chip->num_interfaces)\n\t\t\tsnd_card_free(chip->card);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}","target":0,"flaw_line_index":0,"hash":"70b996d7-1655-4b20-b03c-f29e53604092","idx":"4dacfa97-2f9c-41b7-8872-50281ce0f881"}
{"func_before":"\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (at && length) {\n        SWITCH(data->part[data->num_of_part].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            size_t offset = 0;\n            data->part[data->num_of_part].content[\n                data->part[data->num_of_part].content_length] = 0;\n            break;\n\n        DEFAULT\n            ogs_log_hexdump(OGS_LOG_FATAL, (unsigned char *)at, length);\n            ogs_error(\"Unknown content_type [%s]\",\n                    data->part[data->num_of_part].content_type);\n        END\n    }\n    return 0;\n}","target":1,"flaw_line_index":0,"hash":"007955a6-3906-44be-88ef-761c2efa9a76","idx":"44773414-0afb-4de6-9149-eb18b36a1e9f"}
{"func_before":"\n    ogs_assert(parser);\n    data = multipart_parser_get_data(parser);\n    ogs_assert(data);\n\n    if (data->num_of_part < OGS_SBI_MAX_NUM_OF_PART && at && length) {\n        SWITCH(data->part[data->num_of_part].content_type)\n        CASE(OGS_SBI_CONTENT_JSON_TYPE)\n        CASE(OGS_SBI_CONTENT_5GNAS_TYPE)\n        CASE(OGS_SBI_CONTENT_NGAP_TYPE)\n            size_t offset = 0;\n            memcpy(data->part[data->num_of_part].content + offset, at, length);\n            data->part[data->num_of_part].content[\n                data->part[data->num_of_part].content_length] = 0;\n            break;\n\n        DEFAULT\n            ogs_error(\"Unknown content_type [%s]\",\n                    data->part[data->num_of_part].content_type);\n            ogs_log_hexdump(OGS_LOG_ERROR, (unsigned char *)at, length);\n        END\n    }\n    return 0;\n}","target":0,"flaw_line_index":0,"hash":"ac7fc5cd-29bc-4214-88ea-b8a563e4fb95","idx":"4795b3a0-a59b-4c56-9b8d-ffd0966a9bcc"}
{"func_before":"    pj_str_t str;\n\n    ctx->last_error = PJMEDIA_SDP_EINTIME;\n\n    \/* check equal sign *\/\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    \/* t= *\/","target":1,"flaw_line_index":0,"hash":"683ad85f-1cff-4f8a-9ef7-c55740654cb3","idx":"8c28d225-f733-46a6-9163-255e46096692"}
{"func_before":"    pj_str_t str;\n\n    ctx->last_error = PJMEDIA_SDP_EINTIME;\n\n    \/* check equal sign *\/\n    if (scanner->curptr+1 >= scanner->end || *(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    \/* t= *\/","target":0,"flaw_line_index":0,"hash":"8d401c2c-94ff-4f87-91f4-1832c98c4302","idx":"f7afa3fa-0257-4840-a71f-7d474ce52d35"}
{"func_before":"R_API RBinJavaAttrInfo *r_bin_java_stack_map_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 offset = 0;\n\tRBinJavaStackMapFrame *stack_frame = NULL, *new_stack_frame = NULL;\n\tif (sz < 10) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tIFDBG eprintf(\"r_bin_java_stack_map_table_attr_new: New stack map allocated.\\n\");\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->info.stack_map_table_attr.stack_map_frame_entries = r_list_newf (r_bin_java_stack_frame_free);\n\t\/\/ IFDBG r_bin_java_print_source_code_file_attr_summary(attr);","target":1,"flaw_line_index":0,"hash":"fd2ec7e0-cd9b-4026-ac17-66cfa4f3dec1","idx":"e081d3ce-a917-49a9-bab5-f5bfdaa77f68"}
{"func_before":"R_API RBinJavaAttrInfo *r_bin_java_stack_map_table_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) {\n\tut32 i = 0;\n\tut64 offset = 0;\n\tif (sz < 8) {\n\t\treturn NULL;\n\t}\n\tRBinJavaStackMapFrame *stack_frame = NULL, *new_stack_frame = NULL;\n\tif (sz < 10) {\n\t\treturn NULL;\n\t}\n\tRBinJavaAttrInfo *attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset);\n\toffset += 6;\n\tIFDBG eprintf (\"r_bin_java_stack_map_table_attr_new: New stack map allocated.\\n\");\n\tif (!attr) {\n\t\treturn NULL;\n\t}\n\tattr->info.stack_map_table_attr.stack_map_frame_entries = r_list_newf (r_bin_java_stack_frame_free);\n\t\/\/ IFDBG r_bin_java_print_source_code_file_attr_summary(attr);","target":0,"flaw_line_index":0,"hash":"1e949dbd-75d3-4644-96f9-edb8368c0d5e","idx":"868d9c99-0318-4cfa-bb3c-b91685647c92"}
{"func_before":"mptctl_hp_hostinfo(unsigned long arg, unsigned int data_size)\n{\n\thp_host_info_t\t__user *uarg = (void __user *) arg;\n\tMPT_ADAPTER\t\t*ioc;\n\tstruct pci_dev\t\t*pdev;\n\tchar                    *pbuf=NULL;\n\tdma_addr_t\t\tbuf_dma;\n\thp_host_info_t\t\tkarg;\n\tCONFIGPARMS\t\tcfg;\n\tConfigPageHeader_t\thdr;\n\tint\t\t\tiocnum;\n\tint\t\t\trc, cim_rev;\n\tToolboxIstwiReadWriteRequest_t\t*IstwiRWRequest;\n\tMPT_FRAME_HDR\t\t*mf = NULL;\n\tunsigned long\t\ttimeleft;\n\tint\t\t\tretval;\n\t\t\t\"Unable to read in hp_host_info struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tif (((iocnum = mpt_verify_adapter(karg.hdr.iocnum, &ioc)) < 0) ||\n\t    (ioc == NULL)) {\n\t\tprintk(KERN_DEBUG MYNAM \"%s::mptctl_hp_hostinfo() @%d - ioc%d not found!\\n\",\n\t\t\t\t__FILE__, __LINE__, iocnum);\n\t\treturn -ENODEV;\n\t}\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \": mptctl_hp_hostinfo called.\\n\",\n\t    ioc->name));\n\n\t\/* Fill in the data and return the structure to the calling\n\t * program","target":1,"flaw_line_index":0,"hash":"ca9fd4b1-822d-4d4d-8efe-6dc044fa4462","idx":"804d0526-1553-4965-9c54-2883523543b2"}
{"func_before":"mptctl_hp_hostinfo(MPT_ADAPTER *ioc, unsigned long arg, unsigned int data_size)\n{\n\thp_host_info_t\t__user *uarg = (void __user *) arg;\n\tstruct pci_dev\t\t*pdev;\n\tchar                    *pbuf=NULL;\n\tdma_addr_t\t\tbuf_dma;\n\thp_host_info_t\t\tkarg;\n\tCONFIGPARMS\t\tcfg;\n\tConfigPageHeader_t\thdr;\n\tint\t\t\trc, cim_rev;\n\tToolboxIstwiReadWriteRequest_t\t*IstwiRWRequest;\n\tMPT_FRAME_HDR\t\t*mf = NULL;\n\tunsigned long\t\ttimeleft;\n\tint\t\t\tretval;\n\t\tprintk(KERN_ERR MYNAM \"%s@%d::mptctl_hp_host_info - \"\n\t\t\t\"Unable to read in hp_host_info struct @ %p\\n\",\n\t\t\t\t__FILE__, __LINE__, uarg);\n\t\treturn -EFAULT;\n\t}\n\n\tdctlprintk(ioc, printk(MYIOC_s_DEBUG_FMT \": mptctl_hp_hostinfo called.\\n\",\n\t    ioc->name));\n\n\t\/* Fill in the data and return the structure to the calling\n\t * program","target":0,"flaw_line_index":0,"hash":"3de31d78-4bc9-4dfe-99c8-14e4e29fb325","idx":"3624a693-7b67-464a-84fc-4fdb4eb90bb6"}
{"func_before":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteLocalResponseNormParams*>(node->builtin_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  if (output->type == kTfLiteFloat32) {\n#define TF_LITE_LOCAL_RESPONSE_NORM(type)                            \\\n  tflite::LocalResponseNormalizationParams op_params;                \\\n  op_params.range = params->radius;                                  \\","target":1,"flaw_line_index":0,"hash":"8018e427-32e2-4281-821e-2b4338205c3d","idx":"9c7b42df-4038-47ae-943b-09131bb8898e"}
{"func_before":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteLocalResponseNormParams*>(node->builtin_data);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  if (output->type == kTfLiteFloat32) {\n#define TF_LITE_LOCAL_RESPONSE_NORM(type)                            \\\n  tflite::LocalResponseNormalizationParams op_params;                \\\n  op_params.range = params->radius;                                  \\","target":0,"flaw_line_index":0,"hash":"4c9cb7f0-cd2d-4cf2-8fb1-fea5536ee7ea","idx":"f8aeb76b-28d6-4e31-8bbe-dd69b265635e"}
{"func_before":"__global__ void UnsortedSegmentCustomKernel(const Index input_outer_dim_size,\n                                            const Index inner_dim_size,\n                                            const Index output_outer_dim_size,\n                                            const Index* segment_ids,\n                                            const T* input, T* output) {\n  const Index input_total_size = input_outer_dim_size * inner_dim_size;\n  const Index output_total_size = output_outer_dim_size * inner_dim_size;\n  for (int input_index : GpuGridRangeX(input_total_size)) {\n    const Index input_segment_index = input_index \/ inner_dim_size;\n    const Index segment_offset = input_index % inner_dim_size;\n    const Index output_segment_index = segment_ids[input_segment_index];\n    if (output_segment_index < 0 || output_segment_index >= output_total_size) {\n      continue;\n    }\n    const Index output_index =\n        output_segment_index * inner_dim_size + segment_offset;\n    KernelReductionFunctor()(output + output_index, ldg(input + input_index));\n  }\n}","target":1,"flaw_line_index":0,"hash":"e9ea9326-ea85-4a84-ae96-63e1a38e155a","idx":"80ce663e-0f37-4d28-a93c-7d14338a1828"}
{"func_before":"__global__ void UnsortedSegmentCustomKernel(const int64 input_outer_dim_size,\n                                            const int64 inner_dim_size,\n                                            const int64 output_outer_dim_size,\n                                            const Index* segment_ids,\n                                            const T* input, T* output) {\n  const int64 input_total_size = input_outer_dim_size * inner_dim_size;\n  for (int64 input_index : GpuGridRangeX(input_total_size)) {\n    const int64 input_segment_index = input_index \/ inner_dim_size;\n    const int64 segment_offset = input_index % inner_dim_size;\n    const Index output_segment_index = segment_ids[input_segment_index];\n    if (output_segment_index < 0 ||\n        output_segment_index >= output_outer_dim_size) {\n      continue;\n    }\n    const int64 output_index =\n        output_segment_index * inner_dim_size + segment_offset;\n    KernelReductionFunctor()(output + output_index, ldg(input + input_index));\n  }\n}","target":0,"flaw_line_index":0,"hash":"2cf4114f-a24a-4c84-954b-b42c45b6df26","idx":"347f91a6-a58b-487f-ab01-a049d7621ae3"}
{"func_before":"void jbd2_journal_wait_updates(journal_t *journal)\n{\n\ttransaction_t *commit_transaction = journal->j_running_transaction;\n\n\tif (!commit_transaction)\n\t\treturn;\n\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (atomic_read(&commit_transaction->t_updates)) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&commit_transaction->t_updates)) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n}","target":1,"flaw_line_index":0,"hash":"4cb13c7b-00ae-4d6f-a6f5-271c0cc4dba3","idx":"5f351700-fe2c-443b-8c2f-f8173afec52e"}
{"func_before":"void jbd2_journal_wait_updates(journal_t *journal)\n{\n\tDEFINE_WAIT(wait);\n\n\twhile (1) {\n\t\t\/*\n\t\t * Note that the running transaction can get freed under us if\n\t\t * this transaction is getting committed in\n\t\t * jbd2_journal_commit_transaction() ->\n\t\t * jbd2_journal_free_transaction(). This can only happen when we\n\t\t * release j_state_lock -> schedule() -> acquire j_state_lock.\n\t\t * Hence we should everytime retrieve new j_running_transaction\n\t\t * value (after j_state_lock release acquire cycle), else it may\n\t\t * lead to use-after-free of old freed transaction.\n\t\t *\/\n\t\ttransaction_t *transaction = journal->j_running_transaction;\n\n\t\tif (!transaction)\n\t\t\tbreak;\n\n\t\tspin_lock(&transaction->t_handle_lock);\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!atomic_read(&transaction->t_updates)) {\n\t\t\tspin_unlock(&transaction->t_handle_lock);\n\t\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&transaction->t_handle_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tschedule();\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n}","target":0,"flaw_line_index":0,"hash":"754ed29e-358c-4236-971d-dce88df245f6","idx":"b5550330-83af-4e64-af28-3ade1c96ec3c"}
{"func_before":"\t\tapplog(LOG_INFO, \"Failed to get nonce1 in initiate_stratum\");\n\t\tfree(sessionid);\n\t\tgoto out;\n\t}\n\tn2size = json_integer_value(json_array_get(res_val, 2));\n\tif (!n2size) {\n\t\tapplog(LOG_INFO, \"Failed to get n2size in initiate_stratum\");\n\t\tfree(sessionid);\n\t\tfree(nonce1);\n\t\tgoto out;\n\t}","target":1,"flaw_line_index":0,"hash":"b47486e6-dd92-41ba-870e-d48ea05319b3","idx":"e86ccbbe-6706-43d6-a603-f902a474dff7"}
{"func_before":"\t\tapplog(LOG_INFO, \"Failed to get nonce1 in initiate_stratum\");\n\t\tfree(sessionid);\n\t\tgoto out;\n\t}\n\tn2size = json_integer_value(json_array_get(res_val, 2));\n\tif (n2size < 1)\n\t{\n\t\tapplog(LOG_INFO, \"Failed to get n2size in initiate_stratum\");\n\t\tfree(sessionid);\n\t\tfree(nonce1);\n\t\tgoto out;\n\t}","target":0,"flaw_line_index":0,"hash":"60038601-8ce1-420e-8d4f-bab6bfa3a3e0","idx":"73f2011a-3b94-4887-81aa-ba71b884a53b"}
{"func_before":"static void ep2_mul_sim_plain(ep2_t r, const ep2_t p, const bn_t k,\n\t\tconst ep2_t q, const bn_t m, const ep2_t *t) {\n\tint i, l, l0, l1, n0, n1, w, gen;\n\tint8_t naf0[2 * RLC_FP_BITS + 1], naf1[2 * RLC_FP_BITS + 1], *_k, *_m;\n\tep2_t t0[1 << (EP_WIDTH - 2)];\n\tep2_t t1[1 << (EP_WIDTH - 2)];\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {","target":1,"flaw_line_index":0,"hash":"c6d56401-d6b4-47d7-84da-d0c1b0245a27","idx":"7450fcb1-de61-4cb3-8cd3-9510e7592604"}
{"func_before":"static void ep2_mul_sim_plain(ep2_t r, const ep2_t p, const bn_t k,\n\t\tconst ep2_t q, const bn_t m, const ep2_t *t) {\n\tint i, n0, n1, w, gen;\n\tint8_t naf0[2 * RLC_FP_BITS + 1], naf1[2 * RLC_FP_BITS + 1], *_k, *_m;\n\tep2_t t0[1 << (EP_WIDTH - 2)];\n\tep2_t t1[1 << (EP_WIDTH - 2)];\n\tsize_t l, l0, l1;\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {","target":0,"flaw_line_index":0,"hash":"cc97c442-cbe1-4c9d-ad06-bdfedf5aa98b","idx":"f4179f5b-0db7-4193-9b79-f26723b33396"}
{"func_before":"\t\t\t\tCICPspeakerLayoutIdx = gf_bs_read_int(ctx->bs, 6);\n\t\t\t} else {\n\t\t\t\tnumSpeakers = (s32) gf_mpegh_escaped_value(ctx->bs, 5, 8, 16) + 1;\n\t\t\t\t\/\/TODO ...\n\t\t\t}\n\n\t\t\tmhas_dmx_check_pid(filter, ctx, pl, sr, frame_len, CICPspeakerLayoutIdx, numSpeakers, start + pay_start, (u32) mhas_size);\n\n\t\t\thas_cfg = GF_TRUE;\n\t\t}\n\t\t\/\/audio truncation\n\t\telse if (mhas_type==17) {\n\t\t\tBool isActive = gf_bs_read_int(ctx->bs, 1);\n\t\t\t\/*Bool ati_reserved = *\/gf_bs_read_int(ctx->bs, 1);","target":1,"flaw_line_index":0,"hash":"153198c7-fe01-40d9-8569-383be2d497d8","idx":"2c891dc3-2847-4e5e-ba0a-ae135174d155"}
{"func_before":"\t\t\t\tCICPspeakerLayoutIdx = gf_bs_read_int(ctx->bs, 6);\n\t\t\t} else {\n\t\t\t\tnumSpeakers = (s32) gf_mpegh_escaped_value(ctx->bs, 5, 8, 16) + 1;\n\t\t\t\t\/\/TODO ...\n\t\t\t}\n\t\t\tif (sr) {\n\t\t\t\tmhas_dmx_check_pid(filter, ctx, pl, sr, frame_len, CICPspeakerLayoutIdx, numSpeakers, start + pay_start, (u32) mhas_size);\n\n\t\t\t\thas_cfg = GF_TRUE;\n\t\t\t}\n\t\t}\n\t\t\/\/audio truncation\n\t\telse if (mhas_type==17) {\n\t\t\tBool isActive = gf_bs_read_int(ctx->bs, 1);\n\t\t\t\/*Bool ati_reserved = *\/gf_bs_read_int(ctx->bs, 1);","target":0,"flaw_line_index":0,"hash":"2e638fce-58cf-4a71-acea-278791cebf6d","idx":"e6add677-cdb1-4b90-b6f9-95f5fb4dd255"}
{"func_before":"\n\tstrncpy(full_path, vol->UNC, unc_len);\n\tpos = full_path + unc_len;\n\n\tif (pplen) {\n\t\t*pos++ = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos, vol->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t*pos = '\\0'; \/* add trailing null *\/\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));","target":1,"flaw_line_index":0,"hash":"95b54792-662c-4a68-94b4-227ad2bbd9cb","idx":"6f1e82d4-9826-467a-9405-3c607a610d28"}
{"func_before":"\n\tstrncpy(full_path, vol->UNC, unc_len);\n\tpos = full_path + unc_len;\n\n\tif (pplen) {\n\t\t*pos = CIFS_DIR_SEP(cifs_sb);\n\t\tstrncpy(pos + 1, vol->prepath, pplen);\n\t\tpos += pplen;\n\t}\n\n\t*pos = '\\0'; \/* add trailing null *\/\n\tconvert_delimiter(full_path, CIFS_DIR_SEP(cifs_sb));","target":0,"flaw_line_index":0,"hash":"e7d4a273-0eda-4098-9204-1392852691cc","idx":"3951ea2b-2ce6-46f7-9629-1237c07afe83"}
{"func_before":"void ep4_read_bin(ep4_t a, const uint8_t *bin, int len) {\n\tif (len == 1) {\n\t\tif (bin[0] == 0) {\n\t\t\tep4_set_infty(a);\n\t\t\treturn;\n\t\t} else {","target":1,"flaw_line_index":0,"hash":"54be496d-d22f-4a06-a93e-cd70ddb5bcc5","idx":"87370f44-bd23-484c-b942-3ac86ff8bfd1"}
{"func_before":"void ep4_read_bin(ep4_t a, const uint8_t *bin, size_t len) {\n\tif (len == 1) {\n\t\tif (bin[0] == 0) {\n\t\t\tep4_set_infty(a);\n\t\t\treturn;\n\t\t} else {","target":0,"flaw_line_index":0,"hash":"278ff396-1a38-45ce-a60d-d75fe949f447","idx":"bb6e35cf-17fb-4255-8c91-eea40d19d175"}
{"func_before":"void* chk_malloc(size_t bytes)\n{\n    char* buffer = (char*)dlmalloc(bytes + CHK_OVERHEAD_SIZE);\n    if (buffer) {\n        memset(buffer, CHK_SENTINEL_VALUE, bytes + CHK_OVERHEAD_SIZE);\n        size_t offset = dlmalloc_usable_size(buffer) - sizeof(size_t);\n        *(size_t *)(buffer + offset) = bytes;\n        buffer += CHK_SENTINEL_HEAD_SIZE;","target":1,"flaw_line_index":0,"hash":"f11ba05e-bdb3-427e-b08d-b3f39e40cec7","idx":"68a1dd99-8094-4b36-a8b4-6250cfb7a60c"}
{"func_before":"void* chk_malloc(size_t bytes)\n{\n    size_t size = bytes + CHK_OVERHEAD_SIZE;\n    if (size < bytes) { \/\/ Overflow.\n        return NULL;\n    }\n    uint8_t* buffer = (uint8_t*) dlmalloc(size);\n    if (buffer) {\n        memset(buffer, CHK_SENTINEL_VALUE, bytes + CHK_OVERHEAD_SIZE);\n        size_t offset = dlmalloc_usable_size(buffer) - sizeof(size_t);\n        *(size_t *)(buffer + offset) = bytes;\n        buffer += CHK_SENTINEL_HEAD_SIZE;","target":0,"flaw_line_index":0,"hash":"e2390c0b-7c8d-4f16-b10f-a2045da5919a","idx":"1abac2fa-1f11-48b1-bec7-0f70e35fabfd"}
{"func_before":"void ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, int len) {\n\tbn_t k;\n\tfp_t t;\n\tep_t q;\n\tint neg;\n\t\/* enough space for two field elements plus extra bytes for uniformity *\/\n\t\tep_new(q);\n\n\t\t\/* figure out which hash function to use *\/\n\t\tconst int abNeq0 = (ep_curve_opt_a() != RLC_ZERO) &&\n\t\t\t\t(ep_curve_opt_b() != RLC_ZERO);\n\t\tvoid (*const map_fn)(ep_t, fp_t) =(ep_curve_is_ctmap() ||\n\t\t\t\tabNeq0) ? ep_map_sswu : ep_map_svdw;\n\n#define EP_MAP_CONVERT_BYTES(IDX)                                       \\\n    do {                                                                \\\n      bn_read_bin(k, uniform_bytes + IDX * len_per_elm, len_per_elm);   \\\n      fp_prime_conv(t, k);                                              \\\n    } while (0)\n\n#define EP_MAP_APPLY_MAP(PT)                                    \\\n    do {                                                        \\\n      \/* check sign of t *\/                                     \\\n      neg = fp_sgn0(t, k);                                      \\\n      \/* convert *\/                                             \\\n      map_fn(PT, t);                                            \\\n      \/* compare sign of y and sign of t; fix if necessary *\/   \\\n      neg = neg != fp_sgn0(PT->y, k);                             \\\n      fp_neg(t, PT->y);                                          \\\n      dv_copy_cond(PT->y, t, RLC_FP_DIGS, neg);                  \\\n    } while (0)\n\n\t\t\/* first map invocation *\/\n\t\tEP_MAP_CONVERT_BYTES(0);\n\t\tEP_MAP_APPLY_MAP(p);\n\t\tTMPL_MAP_CALL_ISOMAP(ep, p);","target":1,"flaw_line_index":0,"hash":"69117674-327c-4099-87fd-f1b05dfc6b75","idx":"60d4dfd2-12df-474c-9284-ad2c2f801cac"}
{"func_before":"void ep_map_from_field(ep_t p, const uint8_t *uniform_bytes, size_t len) {\n\tbn_t k;\n\tfp_t t;\n\tep_t q;\n\tint neg;\n\t\/* enough space for two field elements plus extra bytes for uniformity *\/\n\t\tep_new(q);\n\n\t\t\/* figure out which hash function to use *\/\n\t\tconst int abNeq0 = (ep_curve_opt_a() != RLC_ZERO) &&\n\t\t\t\t(ep_curve_opt_b() != RLC_ZERO);\n\t\tvoid (*const map_fn)(ep_t, fp_t) = (ep_curve_is_ctmap() ||\n\t\t\t\tabNeq0) ? ep_map_sswu : ep_map_svdw;\n\n#define EP_MAP_CONVERT_BYTES(IDX)\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tbn_read_bin(k, uniform_bytes + IDX * len_per_elm, len_per_elm);\t\\\n\t\t\tfp_prime_conv(t, k);\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} while (0)\n\n#define EP_MAP_APPLY_MAP(PT)\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\/* check sign of t *\/\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tneg = fp_sgn0(t, k);\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\/* convert *\/\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tmap_fn(PT, t);\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\t\/* compare sign of y and sign of t; fix if necessary *\/\t\t\t\\\n\t\t\tneg = neg != fp_sgn0(PT->y, k);\t\t\t\t\t\t\t\t\t\\\n\t\t\tfp_neg(t, PT->y);\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tdv_copy_cond(PT->y, t, RLC_FP_DIGS, neg);\t\t\t\t\t\t\\\n\t\t} while (0)\n\n\t\t\/* first map invocation *\/\n\t\tEP_MAP_CONVERT_BYTES(0);\n\t\tEP_MAP_APPLY_MAP(p);\n\t\tTMPL_MAP_CALL_ISOMAP(ep, p);","target":0,"flaw_line_index":0,"hash":"07a21a8d-ed99-4e11-98c9-1648c8990715","idx":"658b56a4-0fff-4976-908d-9e5bc214d81d"}
{"func_before":"\n\tcl_showMouseRate = Cvar_Get( \"cl_showmouserate\", \"0\", 0 );\n\n\tcl_allowDownload = Cvar_Get( \"cl_allowDownload\", \"0\", CVAR_ARCHIVE );\n#ifdef USE_CURL_DLOPEN\n\tcl_cURLLib = Cvar_Get(\"cl_cURLLib\", DEFAULT_CURL_LIB, CVAR_ARCHIVE);\n#endif\n\n\t\/\/ init autoswitch so the ui will have it correctly even\n\t\/\/ if the cgame hasn't been started\n\tCvar_Get( \"cg_autoswitch\", \"2\", CVAR_ARCHIVE );","target":1,"flaw_line_index":0,"hash":"8974e298-9810-4e6a-9d7b-fadb8fb69244","idx":"f257e513-9a2e-4193-b134-97346887cdae"}
{"func_before":"\n\tcl_showMouseRate = Cvar_Get( \"cl_showmouserate\", \"0\", 0 );\n\n\tcl_allowDownload = Cvar_Get( \"cl_allowDownload\", \"0\", CVAR_ARCHIVE );\n#ifdef USE_CURL_DLOPEN\n\tcl_cURLLib = Cvar_Get(\"cl_cURLLib\", DEFAULT_CURL_LIB, CVAR_ARCHIVE | CVAR_PROTECTED);\n#endif\n\n\t\/\/ init autoswitch so the ui will have it correctly even\n\t\/\/ if the cgame hasn't been started\n\tCvar_Get( \"cg_autoswitch\", \"2\", CVAR_ARCHIVE );","target":0,"flaw_line_index":0,"hash":"7f3eeb99-2161-44da-b7c7-981f8ce7bf64","idx":"e8de15ec-626d-47c6-af20-20d6d8d0b48e"}
{"func_before":"\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;","target":1,"flaw_line_index":0,"hash":"e9f344aa-35c0-424b-a780-7ed6e52f67c5","idx":"0ff0182e-9745-4735-b3c8-fc2caa26bbce"}
{"func_before":"\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;","target":0,"flaw_line_index":0,"hash":"72a88702-d3ce-4027-a5e9-96d82b3f1b54","idx":"9f31652c-6768-42cd-8084-0b9539255644"}
{"func_before":"\t} pe_opt;\n\tstruct pe_image_section_hdr *section_hdr;\n\tchar sname[9], epbuff[4096], *tempfile;\n\tuint32_t epsize;\n\tssize_t bytes, at;\n\tunsigned int i, found, upx_success = 0, min = 0, max = 0, err, overlays = 0;\n\tunsigned int ssize = 0, dsize = 0, dll = 0, pe_plus = 0, corrupted_cur;\n\tint (*upxfn)(const char *, uint32_t, char *, uint32_t *, uint32_t, uint32_t, uint32_t) = NULL;\n\tconst char *src = NULL;\n\tchar *dest = NULL;\n\tint ndesc, ret = CL_CLEAN, upack = 0, native=0;\n\tsize_t fsize;\n\tuint32_t valign, falign, hdr_size, j;\n\tstruct cli_exe_section *exe_sections;\n\tchar timestr[32];\n\tstruct pe_image_data_dir *dirs;\n\tstruct cli_bc_ctx *bc_ctx;\n\tfmap_t *map;\n    hdr_size = PESALIGN(hdr_size, valign); \/* Aligned headers virtual size *\/\n\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"NumberOfSections\", nsections);\n#endif\n\n    for(i = 0; i < nsections; i++) {\n\tstrncpy(sname, (char *) section_hdr[i].Name, 8);\n\tsname[8] = 0;\n\texe_sections[i].rva = PEALIGN(EC32(section_hdr[i].VirtualAddress), valign);\n\texe_sections[i].vsz = PESALIGN(EC32(section_hdr[i].VirtualSize), valign);\n\texe_sections[i].raw = PEALIGN(EC32(section_hdr[i].PointerToRawData), falign);\n\texe_sections[i].rsz = PESALIGN(EC32(section_hdr[i].SizeOfRawData), falign);\n\texe_sections[i].chr = EC32(section_hdr[i].Characteristics);\n\texe_sections[i].urva = EC32(section_hdr[i].VirtualAddress); \/* Just in case *\/\n\texe_sections[i].uvsz = EC32(section_hdr[i].VirtualSize);\n\texe_sections[i].uraw = EC32(section_hdr[i].PointerToRawData);\n\texe_sections[i].ursz = EC32(section_hdr[i].SizeOfRawData);\n\n#if HAVE_JSON\n        add_section_info(ctx, &exe_sections[i]);\n\n        if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS) {\n\t    free(exe_sections);\n\t    return CL_VIRUS;\n\t}\n\n\tif (exe_sections[i].rsz) { \/* Don't bother with virtual only sections *\/\n\t    if (exe_sections[i].raw >= fsize) { \/* really broken *\/\n\t      cli_dbgmsg(\"Broken PE file - Section %d starts beyond the end of file (Offset@ %lu, Total filesize %lu)\\n\", i, (unsigned long)exe_sections[i].raw, (unsigned long)fsize);\n\t      cli_dbgmsg(\"------------------------------------\\n\");\n\t\tfree(section_hdr);\n\t\tfree(exe_sections);\n\t\tif(DETECT_BROKEN_PE) {\n\t\t    cli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n\t\t    return CL_VIRUS;\n\t\t}\n\t\treturn CL_CLEAN; \/* no ninjas to see here! move along! *\/\n\t    }\n\n\t    if(SCAN_ALGO && (DCONF & PE_CONF_POLIPOS) && !*sname && exe_sections[i].vsz > 40000 && exe_sections[i].vsz < 70000 && exe_sections[i].chr == 0xe0000060) polipos = i;\n\n\t    \/* check hash section sigs *\/\n\t    if((DCONF & PE_CONF_MD5SECT) && ctx->engine->hm_mdb) {\n\t        ret = scan_pe_mdb(ctx, &exe_sections[i]);","target":1,"flaw_line_index":0,"hash":"2d091837-261a-480c-9efb-7578e3e9e58c","idx":"182231ff-9233-4230-95f7-734952e77ab1"}
{"func_before":"\t} pe_opt;\n\tstruct pe_image_section_hdr *section_hdr;\n\tchar sname[9], epbuff[4096], *tempfile;\n\tuint32_t epsize;\n\tssize_t bytes, at;\n\tunsigned int i, j, found, upx_success = 0, min = 0, max = 0, err, overlays = 0, rescan = 1;\n\tunsigned int ssize = 0, dsize = 0, dll = 0, pe_plus = 0, corrupted_cur;\n\tint (*upxfn)(const char *, uint32_t, char *, uint32_t *, uint32_t, uint32_t, uint32_t) = NULL;\n\tconst char *src = NULL;\n\tchar *dest = NULL;\n\tint ndesc, ret = CL_CLEAN, upack = 0, native=0;\n\tsize_t fsize;\n\tuint32_t valign, falign, hdr_size;\n\tstruct cli_exe_section *exe_sections;\n\tchar timestr[32];\n\tstruct pe_image_data_dir *dirs;\n\tstruct cli_bc_ctx *bc_ctx;\n\tfmap_t *map;\n\n#if HAVE_JSON\n    cli_jsonint(pe_json, \"NumberOfSections\", nsections);\n#endif\n\n    while (rescan==1) {\n        rescan=0;\n        for (i=0; i < nsections; i++) {\n            exe_sections[i].rva = PEALIGN(EC32(section_hdr[i].VirtualAddress), valign);\n            exe_sections[i].vsz = PESALIGN(EC32(section_hdr[i].VirtualSize), valign);\n            exe_sections[i].raw = PEALIGN(EC32(section_hdr[i].PointerToRawData), falign);\n            exe_sections[i].rsz = PESALIGN(EC32(section_hdr[i].SizeOfRawData), falign);\n            exe_sections[i].chr = EC32(section_hdr[i].Characteristics);\n            exe_sections[i].urva = EC32(section_hdr[i].VirtualAddress); \/* Just in case *\/\n            exe_sections[i].uvsz = EC32(section_hdr[i].VirtualSize);\n            exe_sections[i].uraw = EC32(section_hdr[i].PointerToRawData);\n            exe_sections[i].ursz = EC32(section_hdr[i].SizeOfRawData);\n\n            if (exe_sections[i].rsz) { \/* Don't bother with virtual only sections *\/\n                if (!CLI_ISCONTAINED(0, fsize, exe_sections[i].uraw, exe_sections[i].ursz)\n                    || exe_sections[i].raw >= fsize) {\n                    cli_dbgmsg(\"Broken PE file - Section %d starts or exists beyond the end of file (Offset@ %lu, Total filesize %lu)\\n\", i, (unsigned long)exe_sections[i].raw, (unsigned long)fsize);\n                    if (nsections == 1) {\n                        free(section_hdr);\n                        free(exe_sections);\n\n                        if(DETECT_BROKEN_PE) {\n                            cli_append_virus(ctx, \"Heuristics.Broken.Executable\");\n                            return CL_VIRUS;\n                        }\n\n                        return CL_CLEAN; \/* no ninjas to see here! move along! *\/\n                    }\n\n                    for (j=i; j < nsections-1; j++)\n                        memcpy(&exe_sections[j], &exe_sections[j+1], sizeof(struct cli_exe_section));\n\n                    for (j=i; j < nsections-1; j++)\n                        memcpy(&section_hdr[j], &section_hdr[j+1], sizeof(struct pe_image_section_hdr));\n\n                    nsections--;\n                    rescan=1;\n                    break;\n                }\n            }\n        }\n    }\n\n    for(i = 0; i < nsections; i++) {\n        strncpy(sname, (char *) section_hdr[i].Name, 8);\n        sname[8] = 0;\n\n#if HAVE_JSON\n        add_section_info(ctx, &exe_sections[i]);\n\n        if (cli_json_timeout_cycle_check(ctx, &toval) != CL_SUCCESS) {\n\t    free(section_hdr);\n\t    free(exe_sections);\n\t    return CL_VIRUS;\n\t}\n\n\tif (exe_sections[i].rsz) { \/* Don't bother with virtual only sections *\/\n\t    if(SCAN_ALGO && (DCONF & PE_CONF_POLIPOS) && !*sname && exe_sections[i].vsz > 40000 && exe_sections[i].vsz < 70000 && exe_sections[i].chr == 0xe0000060) polipos = i;\n\n\t    \/* check hash section sigs *\/\n\t    if((DCONF & PE_CONF_MD5SECT) && ctx->engine->hm_mdb) {\n\t        ret = scan_pe_mdb(ctx, &exe_sections[i]);","target":0,"flaw_line_index":0,"hash":"63d126c6-1c75-4a6f-ab11-cb9a27ee4314","idx":"e4e507f3-62de-4076-87f3-c73e1599ceeb"}
{"func_before":"zend_function *spl_filesystem_object_get_method_check(zval **object_ptr, char *method, int method_len, const struct _zend_literal *key TSRMLS_DC) \/* {{{ *\/\n{\n\tspl_filesystem_object *fsobj = zend_object_store_get_object(*object_ptr TSRMLS_CC);\n\t\n\tif (fsobj->u.dir.entry.d_name[0] == '\\0' && fsobj->orig_path == NULL) {\n\t\tmethod = \"_bad_state_ex\";\n\t\tmethod_len = sizeof(\"_bad_state_ex\") - 1;\n\t\tkey = NULL;\n\t}\n\t\n\treturn zend_get_std_object_handlers()->get_method(object_ptr, method, method_len, key TSRMLS_CC);\n}","target":1,"flaw_line_index":0,"hash":"ed11efc8-7876-4246-a5e4-f2872a6096df","idx":"c01493fd-c5a4-4eec-9718-aa6524de3f68"}
{"func_before":"zend_function *spl_filesystem_object_get_method_check(zval **object_ptr, char *method, int method_len, const struct _zend_literal *key TSRMLS_DC) \/* {{{ *\/\n{\n\tspl_filesystem_object *fsobj = zend_object_store_get_object(*object_ptr TSRMLS_CC);\n\n\tif (fsobj->u.dir.entry.d_name[0] == '\\0' && fsobj->orig_path == NULL) {\n\t\tmethod = \"_bad_state_ex\";\n\t\tmethod_len = sizeof(\"_bad_state_ex\") - 1;\n\t\tkey = NULL;\n\t}\n\n\treturn zend_get_std_object_handlers()->get_method(object_ptr, method, method_len, key TSRMLS_CC);\n}","target":0,"flaw_line_index":0,"hash":"e3674540-8eb6-4b6f-acfc-f8192e5f16e2","idx":"0e999bbe-2171-4c95-b86f-708846294e4b"}
{"func_before":"    njs_index_t unused)\n{\n    njs_int_t           ret;\n    njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n    njs_frame_t         *frame, *async_frame;\n    njs_function_t      *function;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *top, *async;\n\n    ctx = vm->top_frame->function->context;\n\n    }\n\n    async_frame = ctx->await;\n    async = &async_frame->native;\n    async->previous = vm->top_frame;\n\n    function = async->function;\n\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n    top = vm->top_frame;\n    *njs_scope_value(vm, ctx->index) = *value;\n    vm->retval = *value;\n\n    vm->top_frame->retval = &vm->retval;\n\n    function->context = ctx->capability;\n    function->await = ctx;\n\n    ret = njs_vmcode_interpreter(vm, ctx->pc);\n\n    function->context = NULL;\n    function->await = NULL;\n\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n","target":1,"flaw_line_index":0,"hash":"82930adb-7cb6-448e-931d-9be94572185c","idx":"c547a527-1468-4bad-afe6-6f014778bf00"}
{"func_before":"njs_await_fulfilled(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs,\n    njs_index_t unused)\n{\n    njs_int_t           ret;\n    njs_value_t         **cur_local, **cur_closures, **cur_temp, *value;\n    njs_frame_t         *frame, *async_frame;\n    njs_async_ctx_t     *ctx;\n    njs_native_frame_t  *top, *async;\n\n    ctx = vm->top_frame->function->context;\n\n        goto failed;\n    }\n\n    async_frame = ctx->await;\n    async = &async_frame->native;\n    async->previous = vm->top_frame;\n\n    cur_local = vm->levels[NJS_LEVEL_LOCAL];\n    cur_closures = vm->levels[NJS_LEVEL_CLOSURE];\n    cur_temp = vm->levels[NJS_LEVEL_TEMP];\n    top = vm->top_frame;\n    *njs_scope_value(vm, ctx->index) = *value;\n    vm->retval = *value;\n\n    vm->top_frame->retval = &vm->retval;\n\n    ret = njs_vmcode_interpreter(vm, ctx->pc, ctx->capability, ctx);\n\n    vm->levels[NJS_LEVEL_LOCAL] = cur_local;\n    vm->levels[NJS_LEVEL_CLOSURE] = cur_closures;\n    vm->levels[NJS_LEVEL_TEMP] = cur_temp;\n","target":0,"flaw_line_index":0,"hash":"9ffefbf1-0aa8-4de6-8834-fea8c60a92a3","idx":"daeddf0c-dedc-41cc-8d51-40c9c1b58266"}
{"func_before":"\n\tif (!userData || !userDataSize || *userData) return GF_BAD_PARAM;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\n\t}\n\treturn GF_BAD_PARAM;\n","target":1,"flaw_line_index":0,"hash":"2134d7d2-48a3-4202-a1d8-52e23a7ee1b5","idx":"5dd16f96-fa1d-43f9-9769-7fab76ab81ca"}
{"func_before":"\n\tif (!userData || !userDataSize || *userData) return GF_BAD_PARAM;\n\n\ti=0;\n\twhile ((map = (GF_UserDataMap*)gf_list_enum(udta->recordList, &i))) {\n\t\tif ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && UUID && !memcmp(map->uuid, UUID, 16)) goto found;\n\t\telse if (map->boxType == UserDataType) goto found;\n\n\t}\n\treturn GF_BAD_PARAM;\n","target":0,"flaw_line_index":0,"hash":"e49f36e1-2a85-43cb-888b-aac83da30997","idx":"b7633276-5500-4259-81f8-0af97854f72e"}
{"func_before":"\t\t\t\t int tcas_size,\n\t\t\t\t const gnutls_x509_crl_t * CRLs,\n\t\t\t\t int crls_size, unsigned int flags)\n{\n  int i = 0, ret;\n  unsigned int status = 0, output;\n\n  if (clist_size > 1)\n    {\n      \/* Check if the last certificate in the path is self signed.\n       * In that case ignore it (a certificate is trusted only if it\n\n\t  for (j = 0; j < tcas_size; j++)\n\t    {\n\t      if (check_if_same_cert (certificate_list[i],\n\t\t\t\t      trusted_cas[j]) == 0)\n\t\t{\n\t\t  clist_size = i;\n\t\t  break;\n\t\t}\n\t    }\n\t  \/* clist_size may have been changed which gets out of loop *\/\n   *\n   * If no CAs are present returns CERT_INVALID. Thus works\n   * in self signed etc certificates.\n   *\/\n  ret = _gnutls_verify_certificate2 (certificate_list[clist_size - 1],\n\t\t\t\t     trusted_cas, tcas_size, flags, &output);\n  if (ret == 0)\n    {\n      \/* if the last certificate in the certificate\n       * list is invalid, then the certificate is not\n       * trusted.\n\t  status |= GNUTLS_CERT_INVALID;\n\t  return status;\n\t}\n    }\n#endif\n\n  \/* Check activation\/expiration times\n   *\/\n  if (!(flags & GNUTLS_VERIFY_DISABLE_TIME_CHECKS))\n    {\n      time_t t, now = time (0);\n\n      for (i = 0; i < clist_size; i++)\n\t{\n\t  t = gnutls_x509_crt_get_activation_time (certificate_list[i]);\n\t  if (t == (time_t) - 1 || now < t)\n\t    {\n\t      status |= GNUTLS_CERT_NOT_ACTIVATED;\n\t      status |= GNUTLS_CERT_INVALID;\n\t      return status;\n\t    }\n\n\t  t = gnutls_x509_crt_get_expiration_time (certificate_list[i]);\n\t  if (t == (time_t) - 1 || now > t)\n\t    {\n\t      status |= GNUTLS_CERT_EXPIRED;\n\t      status |= GNUTLS_CERT_INVALID;\n\t      return status;\n\t    }\n\t}\n    }\n\n      if (!(flags & GNUTLS_VERIFY_ALLOW_ANY_X509_V1_CA_CRT))\n\tflags &= ~(GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT);\n      if ((ret =\n\t   _gnutls_verify_certificate2 (certificate_list[i - 1],\n\t\t\t\t\t&certificate_list[i], 1, flags,\n\t\t\t\t\tNULL)) == 0)\n\t{\n\t  status |= GNUTLS_CERT_INVALID;\n\t  return status;\n\t}\n    }","target":1,"flaw_line_index":0,"hash":"34c8172e-4992-4f72-a24c-fa69548b7e00","idx":"ecad28ef-222d-47d8-82df-9629dfe51c52"}
{"func_before":"\t\t\t\t const gnutls_x509_crl_t * CRLs,\n\t\t\t\t int crls_size, unsigned int flags)\n{\n  int i = 0, ret;\n  unsigned int status = 0, output;\n  time_t now = time (0);\n  gnutls_x509_crt_t issuer = NULL;\n\n  if (clist_size > 1)\n    {\n      \/* Check if the last certificate in the path is self signed.\n       * In that case ignore it (a certificate is trusted only if it\n\t  for (j = 0; j < tcas_size; j++)\n\t    {\n\t      if (check_if_same_cert (certificate_list[i],\n\t\t\t\t      trusted_cas[j]) == 0)\n\t\t{\n\t\t  \/* explicity time check for trusted CA that we remove from\n\t\t   * list. GNUTLS_VERIFY_DISABLE_TRUSTED_TIME_CHECKS\n\t\t   *\/\n\t\t  if (!(flags&GNUTLS_VERIFY_DISABLE_TRUSTED_TIME_CHECKS) && !(flags&GNUTLS_VERIFY_DISABLE_TIME_CHECKS))\n\t\t    {\n\t\t      status |= check_time(trusted_cas[j], now);\n\t\t      if (status != 0)\n\t\t        {\n\t\t          return status;\n                        }\n\t\t    }\n\t\t  clist_size = i;\n\t\t  break;\n\t\t}\n\t    }\n\t  \/* clist_size may have been changed which gets out of loop *\/\n   *\n   * If no CAs are present returns CERT_INVALID. Thus works\n   * in self signed etc certificates.\n   *\/\n  ret = _gnutls_verify_certificate2 (certificate_list[clist_size - 1],\n\t\t\t\t     trusted_cas, tcas_size, flags, &output, &issuer);\n  if (ret == 0)\n    {\n      \/* if the last certificate in the certificate\n       * list is invalid, then the certificate is not\n       * trusted.\n\t  return status;\n\t}\n    }\n#endif\n\n\n  \/* Check activation\/expiration times\n   *\/\n  if (!(flags & GNUTLS_VERIFY_DISABLE_TIME_CHECKS))\n    {\n      \/* check the time of the issuer first *\/\n      if (!(flags&GNUTLS_VERIFY_DISABLE_TRUSTED_TIME_CHECKS))\n        {\n          if (issuer == NULL)\n            {\n              gnutls_assert();\n              return GNUTLS_E_INTERNAL_ERROR;\n            }\n\n          status |= check_time(issuer, now);\n          if (status != 0)\n            {\n              return status;\n            }\n        }\n\n      for (i = 0; i < clist_size; i++)\n\t{\n\t  status |= check_time(certificate_list[i], now);\n\t  if (status != 0)\n\t    {\n\t      return status;\n\t    }\n\t}\n    }\n\n      if (!(flags & GNUTLS_VERIFY_ALLOW_ANY_X509_V1_CA_CRT))\n\tflags &= ~(GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT);\n      if ((ret =\n\t   _gnutls_verify_certificate2 (certificate_list[i - 1],\n\t\t\t\t\t&certificate_list[i], 1, flags,\n\t\t\t\t\tNULL, NULL)) == 0)\n\t{\n\t  status |= GNUTLS_CERT_INVALID;\n\t  return status;\n\t}\n    }","target":0,"flaw_line_index":0,"hash":"e674eb9d-7568-4c5f-ada6-8ea42d7e1011","idx":"7cae7101-d0fb-49e0-9bea-56d2ebcc17fc"}
{"func_before":"            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN: \/* fall through *\/\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n\t    snprintf(buf + offset, buflen - offset, \", RD: %s, Source-AS %s\",\n\t\tbgp_vpn_rd_print(ndo, pptr),\n\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\tEXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));\n            pptr += BGP_VPN_RD_LEN;\n\n            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n            \/*","target":1,"flaw_line_index":0,"hash":"ae01568e-3ca4-409b-8730-e2e57ace2906","idx":"5cff3d0c-6e68-40a0-88ba-e6f103c7c26c"}
{"func_before":"            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN: \/* fall through *\/\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN + 4);\n            offset = strlen(buf);\n\t    snprintf(buf + offset, buflen - offset, \", RD: %s, Source-AS %s\",\n\t\tbgp_vpn_rd_print(ndo, pptr),\n\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\tEXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));\n            pptr += BGP_VPN_RD_LEN + 4;\n\n            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n            \/*","target":0,"flaw_line_index":0,"hash":"b780bca8-c375-45f6-b477-27cb72a88a42","idx":"f64b15bb-f8c8-49f8-9e9b-b7a618dd1724"}
{"func_before":"    void CFontFileType1::DecryptEexec(unsigned char** ppEexecBuffer, int nLen)\n    {\n        \/\/   Type1,      ASCII \n        \/\/ (, ,     ).\n        unsigned char *sCur = (unsigned char*)(*ppEexecBuffer);\n        while( sCur < (unsigned char*)(*ppEexecBuffer) + nLen && ( ' ' == *sCur || '\\t' == *sCur || '\\r' == *sCur || '\\n' == *sCur ) )\n            ++sCur;\n\n        \/\/          : ASKII   .\n        \/\/       , ,  ASCII.\n        bool bASCII = false;\n\n        if ( isxdigit( sCur[0] ) && isxdigit( sCur[1] ) && isxdigit( sCur[2] ) && isxdigit( sCur[3] ) )\n            bASCII = true;\n\n        if ( bASCII )\n            ASCIIHexDecode( &sCur, sCur + nLen, sCur, nLen );\n","target":1,"flaw_line_index":0,"hash":"1962ad32-8359-4b24-b88c-53da20411725","idx":"a728820a-ccc8-44ac-af36-358cf9413f24"}
{"func_before":"    {\n        \/\/   Type1,      ASCII \n        \/\/ (, ,     ).\n        unsigned char *sCur = (unsigned char*)(*ppEexecBuffer);\n        while( sCur < (unsigned char*)(*ppEexecBuffer) + nLen && ( ' ' == *sCur || '\\t' == *sCur || '\\r' == *sCur || '\\n' == *sCur ) )\n        {\n            ++sCur;\n            --nLen;\n        }\n\n        \/\/          : ASKII   .\n        \/\/       , ,  ASCII.\n        bool bASCII = false;\n\n        if ( nLen > 3 && isxdigit( sCur[0] ) && isxdigit( sCur[1] ) && isxdigit( sCur[2] ) && isxdigit( sCur[3] ) )\n            bASCII = true;\n\n        if ( bASCII )\n            ASCIIHexDecode( &sCur, sCur + nLen, sCur, nLen );\n","target":0,"flaw_line_index":0,"hash":"e6c2d752-7d5c-4e7a-b838-bfca04e60f40","idx":"ba978161-463f-490c-9407-f5a29149dac8"}
{"func_before":"\t\/* we have no mappings outside the BMP *\/\n\tif (code_key_a > 0xFFFFU)\n\t\treturn 0;\n\n\tcode_key = (unsigned short) code_key_a;\n\t\n\twhile (l <= h) {\n\t\tm = l + (h - l) \/ 2;\n\t\tif (code_key < m->un_code_point)\n\t\t\th = m - 1;\n\t\telse if (code_key > m->un_code_point)","target":1,"flaw_line_index":0,"hash":"8bff5957-de1b-4803-87b6-96ad2a5665b3","idx":"01e562bf-e337-474a-8983-74ec9fd25f48"}
{"func_before":"\t\/* we have no mappings outside the BMP *\/\n\tif (code_key_a > 0xFFFFU)\n\t\treturn 0;\n\n\tcode_key = (unsigned short) code_key_a;\n\n\twhile (l <= h) {\n\t\tm = l + (h - l) \/ 2;\n\t\tif (code_key < m->un_code_point)\n\t\t\th = m - 1;\n\t\telse if (code_key > m->un_code_point)","target":0,"flaw_line_index":0,"hash":"013de703-fbd6-4973-8b4a-f21ea12054e1","idx":"adea1db2-f630-474b-90f5-30b26ca49657"}
{"func_before":"\n    const int64_t out_height = sizes(0);\n    const int64_t out_width = sizes(1);\n\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(\n        context,\n        context->allocate_output(\n            0, TensorShape({batch_size, out_height, out_width, channels}),\n            &output));\n\n    \/\/ Return if the output is empty.\n    if (output->NumElements() == 0) return;\n\n    typename TTypes<T, 4>::ConstTensor input_data(input.tensor<T, 4>());","target":1,"flaw_line_index":0,"hash":"f20ce318-579b-41d3-a658-f05dfc029764","idx":"6f7b0ebc-9b23-420b-8405-2d1a4eb5841b"}
{"func_before":"\n    const int64_t out_height = sizes(0);\n    const int64_t out_width = sizes(1);\n\n    Tensor* output = nullptr;\n    TensorShape shape;\n    OP_REQUIRES_OK(context,\n                   TensorShape::BuildTensorShape(\n                       {batch_size, out_height, out_width, channels}, &shape));\n    OP_REQUIRES_OK(context, context->allocate_output(0, shape, &output));\n\n    \/\/ Return if the output is empty.\n    if (output->NumElements() == 0) return;\n\n    typename TTypes<T, 4>::ConstTensor input_data(input.tensor<T, 4>());","target":0,"flaw_line_index":0,"hash":"ce23fbfc-465d-41cb-bbd5-4856274d66e2","idx":"042cd387-a316-47dd-acee-5e9cf347f6e8"}
{"func_before":"\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\telse {\n\t\t\t\tinode->i_ctime = ext4_current_time(inode);\n\t\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t\t\tif (error == 0)\n\t\t\t\t\tacl = NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;","target":1,"flaw_line_index":0,"hash":"076e35a6-8fb5-46dc-af3e-09b38c7c9d5b","idx":"53780365-6471-4d98-b95b-f5f8b4d3aa40"}
{"func_before":"\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_update_mode(inode, &inode->i_mode, &acl);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tinode->i_ctime = ext4_current_time(inode);\n\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT;","target":0,"flaw_line_index":0,"hash":"afc6e692-e201-4a47-a661-6b7702a6ac0a","idx":"d2cf08d2-a0bd-4342-a543-0a374e45a650"}
{"func_before":"\t\t\tif (env->used_map_cnt >= MAX_USED_MAPS) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\n\t\t\t\/* remember this map *\/\n\t\t\tenv->used_maps[env->used_map_cnt++] = map;\n\n\t\t\t\/* hold the map. If the program is rejected by verifier,\n\t\t\t * the map will be released by release_maps() or it\n\t\t\t * will be used by the valid program until it's unloaded\n\t\t\t * and all maps are released in free_bpf_prog_info()\n\t\t\t *\/\n\t\t\tbpf_map_inc(map, false);\n\t\t\tfdput(f);\nnext_insn:\n\t\t\tinsn++;\n\t\t\ti++;\n\t\t}","target":1,"flaw_line_index":0,"hash":"2479e8b3-8f4a-42fe-889e-99de4adad811","idx":"aed0d6d4-da0f-4e38-90e6-d146e131fea9"}
{"func_before":"\n\t\t\tif (env->used_map_cnt >= MAX_USED_MAPS) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn -E2BIG;\n\t\t\t}\n\n\t\t\t\/* hold the map. If the program is rejected by verifier,\n\t\t\t * the map will be released by release_maps() or it\n\t\t\t * will be used by the valid program until it's unloaded\n\t\t\t * and all maps are released in free_bpf_prog_info()\n\t\t\t *\/\n\t\t\tmap = bpf_map_inc(map, false);\n\t\t\tif (IS_ERR(map)) {\n\t\t\t\tfdput(f);\n\t\t\t\treturn PTR_ERR(map);\n\t\t\t}\n\t\t\tenv->used_maps[env->used_map_cnt++] = map;\n\n\t\t\tfdput(f);\nnext_insn:\n\t\t\tinsn++;\n\t\t\ti++;\n\t\t}","target":0,"flaw_line_index":0,"hash":"902476be-b181-48ec-b8a9-a37c0b53170c","idx":"cf6e20d1-22ed-48cb-b813-f251ec8e10fc"}
{"func_before":"void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)\n{\n\tnsc_encode_argb_to_aycocg(context, bmpdata, rowstride);\n\n\tif (context->ChromaSubsamplingLevel)\n\t{\n\t\tnsc_encode_subsampling(context);\n\t}\n}","target":1,"flaw_line_index":0,"hash":"250172e9-cf31-407e-bd64-633d85f5c542","idx":"82d0f88f-dd4d-434d-941b-59b5dd4ea969"}
{"func_before":"BOOL nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)\n{\n\tif (!context || !bmpdata || (rowstride == 0))\n\t\treturn FALSE;\n\n\tif (!nsc_encode_argb_to_aycocg(context, bmpdata, rowstride))\n\t\treturn FALSE;\n\n\tif (context->ChromaSubsamplingLevel)\n\t{\n\t\tif (!nsc_encode_subsampling(context))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}","target":0,"flaw_line_index":0,"hash":"dd888e76-25ac-4409-9fa7-8be5c4837ebe","idx":"e0a0b391-f5dc-4764-af43-68138c363546"}
{"func_before":"int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint                     result = 0;\n\tltv_t                   *pLtv;\n\tbool_t                  ltvAllocated = FALSE;\n\tENCSTRCT                sEncryption;\n\n#ifdef USE_WDS\n\thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  \/* USE_WDS *\/\n\t\/*------------------------------------------------------------------------*\/\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\t\t\t\t\tmemcpy((void *)lp->StationName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);","target":1,"flaw_line_index":0,"hash":"a4c3d25b-aa68-4b36-ab4c-9b984a440d2c","idx":"51b4dcfb-f1b6-4cce-8964-c2252b3bf024"}
{"func_before":"{\n\tint                     result = 0;\n\tltv_t                   *pLtv;\n\tbool_t                  ltvAllocated = FALSE;\n\tENCSTRCT                sEncryption;\n\tsize_t\t\t\tlen;\n\n#ifdef USE_WDS\n\thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  \/* USE_WDS *\/\n\t\/*------------------------------------------------------------------------*\/\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\t\t\t\t\tlen = min_t(size_t, pLtv->u.u16[0], sizeof(lp->StationName));\n\t\t\t\t\tstrlcpy(lp->StationName, &pLtv->u.u8[2], len);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);","target":0,"flaw_line_index":0,"hash":"5f75df69-fd19-4eca-b036-02bf5b27f839","idx":"7b05fe06-1a66-4f29-962f-671cf16596a1"}
{"func_before":"ext4_xattr_cache_insert(struct mb_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tstruct mb_cache_entry *ce;\n\tint error;\n\n\tce = mb_cache_entry_alloc(ext4_mb_cache, GFP_NOFS);\n\tif (!ce) {\n\t\tea_bdebug(bh, \"out of memory\");\n\t\treturn;\n\t}\n\terror = mb_cache_entry_insert(ce, bh->b_bdev, bh->b_blocknr, hash);\n\tif (error) {\n\t\tmb_cache_entry_free(ce);\n\t\tif (error == -EBUSY) {\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t\t\terror = 0;\n\t\t}\n\t} else {\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n\t\tmb_cache_entry_release(ce);\n\t}\n}","target":1,"flaw_line_index":0,"hash":"79473bf4-bfac-4af1-a743-72fda1f53e45","idx":"342d485f-159b-4882-bca4-87f810881e2d"}
{"func_before":"ext4_xattr_cache_insert(struct mb2_cache *ext4_mb_cache, struct buffer_head *bh)\n{\n\t__u32 hash = le32_to_cpu(BHDR(bh)->h_hash);\n\tint error;\n\n\terror = mb2_cache_entry_create(ext4_mb_cache, GFP_NOFS, hash,\n\t\t\t\t       bh->b_blocknr);\n\tif (error) {\n\t\tif (error == -EBUSY)\n\t\t\tea_bdebug(bh, \"already in cache\");\n\t} else\n\t\tea_bdebug(bh, \"inserting [%x]\", (int)hash);\n}","target":0,"flaw_line_index":0,"hash":"b5ab2fe3-11c0-4c52-bf71-b40e7a69eab3","idx":"90a34e16-9d64-428e-8575-1866f093aef2"}
{"func_before":"static int em_jcxz(struct x86_emulate_ctxt *ctxt)\n{\n\tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0)\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\n\treturn X86EMUL_CONTINUE;\n}","target":1,"flaw_line_index":0,"hash":"094ffb77-f367-4cd9-bd08-6ad931714065","idx":"1c1df3c2-b955-415f-b460-9c6dae4643ac"}
{"func_before":"static int em_jcxz(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\tif (address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) == 0)\n\t\trc = jmp_rel(ctxt, ctxt->src.val);\n\n\treturn rc;\n}","target":0,"flaw_line_index":0,"hash":"2278c217-7b9b-46ce-95f3-5c4ffac6c5e5","idx":"b72fecaa-56c5-4d87-906b-13bc10c6a191"}
{"func_before":"\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct gnttab_copy **gopp)\n{\n\tstruct gnttab_copy *gop = *gopp;\n\tu16 pending_idx = *((u16 *)skb->data);\n\tstruct pending_tx_info *pending_tx_info = netbk->pending_tx_info;\n\tstruct xenvif *vif = pending_tx_info[pending_idx].vif;\n\tstruct xen_netif_tx_request *txp;\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tint nr_frags = shinfo->nr_frags;\n\tint i, err, start;\n\n\t\/* Check status of header. *\/\n\terr = gop->status;\n\tif (unlikely(err)) {\n\t\tpending_ring_idx_t index;\n\t\tindex = pending_index(netbk->pending_prod++);\n\t\ttxp = &pending_tx_info[pending_idx].req;\n\t\tmake_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);\n\t\tnetbk->pending_ring[index] = pending_idx;\n\t\txenvif_put(vif);\n\t}\n\n\t\/* Skip first skb fragment if it is on same page as header fragment. *\/\n\tstart = (frag_get_pending_idx(&shinfo->frags[0]) == pending_idx);\n\n\tfor (i = start; i < nr_frags; i++) {\n\t\tint j, newerr;\n\t\tpending_ring_idx_t index;\n\n\t\tpending_idx = frag_get_pending_idx(&shinfo->frags[i]);\n\n\t\t\/* Check error status: if okay then remember grant handle. *\/\n\t\tnewerr = (++gop)->status;\n\t\tif (likely(!newerr)) {\n\t\t\t\/* Had a previous error? Invalidate this fragment. *\/\n\t\t\tif (unlikely(err))\n\t\t\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\/* Error on this fragment: respond to client with an error. *\/\n\t\ttxp = &netbk->pending_tx_info[pending_idx].req;\n\t\tmake_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);\n\t\tindex = pending_index(netbk->pending_prod++);\n\t\tnetbk->pending_ring[index] = pending_idx;\n\t\txenvif_put(vif);\n\n\t\t\/* Not the first error? Preceding frags already invalidated. *\/\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\t\/* First error: invalidate header and preceding fragments. *\/\n\t\tpending_idx = *((u16 *)skb->data);\n\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\tfor (j = start; j < i; j++) {\n\t\t\tpending_idx = frag_get_pending_idx(&shinfo->frags[j]);\n\t\t\txen_netbk_idx_release(netbk, pending_idx);\n\t\t}\n\n\t\t\/* Remember the error: invalidate all subsequent fragments. *\/\n\t\terr = newerr;\n\t}","target":1,"flaw_line_index":0,"hash":"8080ca04-c548-4674-a3db-0ed00a2c7c58","idx":"9b6031dc-90ce-443b-88e8-d93d66aee77e"}
{"func_before":"static int xen_netbk_tx_check_gop(struct xen_netbk *netbk,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct gnttab_copy **gopp)\n{\n\tstruct gnttab_copy *gop = *gopp;\n\tu16 pending_idx = *((u16 *)skb->data);\n\tstruct skb_shared_info *shinfo = skb_shinfo(skb);\n\tint nr_frags = shinfo->nr_frags;\n\tint i, err, start;\n\n\t\/* Check status of header. *\/\n\terr = gop->status;\n\tif (unlikely(err))\n\t\txen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_ERROR);\n\n\t\/* Skip first skb fragment if it is on same page as header fragment. *\/\n\tstart = (frag_get_pending_idx(&shinfo->frags[0]) == pending_idx);\n\n\tfor (i = start; i < nr_frags; i++) {\n\t\tint j, newerr;\n\n\t\tpending_idx = frag_get_pending_idx(&shinfo->frags[i]);\n\n\t\t\/* Check error status: if okay then remember grant handle. *\/\n\t\tnewerr = (++gop)->status;\n\t\tif (likely(!newerr)) {\n\t\t\t\/* Had a previous error? Invalidate this fragment. *\/\n\t\t\tif (unlikely(err))\n\t\t\t\txen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\/* Error on this fragment: respond to client with an error. *\/\n\t\txen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_ERROR);\n\n\t\t\/* Not the first error? Preceding frags already invalidated. *\/\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\t\/* First error: invalidate header and preceding fragments. *\/\n\t\tpending_idx = *((u16 *)skb->data);\n\t\txen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);\n\t\tfor (j = start; j < i; j++) {\n\t\t\tpending_idx = frag_get_pending_idx(&shinfo->frags[j]);\n\t\t\txen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);\n\t\t}\n\n\t\t\/* Remember the error: invalidate all subsequent fragments. *\/\n\t\terr = newerr;\n\t}","target":0,"flaw_line_index":0,"hash":"43b15f22-e27a-448c-bf81-da639c38bf24","idx":"40af7ef6-7b18-4377-b2c8-e82b67e4f6b8"}
{"func_before":"\t}\n\n\t\/* Management addresses *\/\n\tTAILQ_FOREACH(mgmt, &chassis->c_mgmt, m_entries) {\n\t\tproto = lldpd_af_to_lldp_proto(mgmt->m_family);\n\t\tassert(proto != LLDP_MGMT_ADDR_NONE);\n\t\tif (!(\n\t\t\t  POKE_START_LLDP_TLV(LLDP_TLV_MGMT_ADDR) &&\n\t\t\t  \/* Size of the address, including its type *\/\n\t\t\t  POKE_UINT8(mgmt->m_addrsize + 1) &&\n\t\t\t  POKE_UINT8(proto) &&","target":1,"flaw_line_index":0,"hash":"5323d926-20a6-4d18-b12a-b134661c2009","idx":"e5df47f6-60d0-45ac-bd98-954f6066a36b"}
{"func_before":"\t}\n\n\t\/* Management addresses *\/\n\tTAILQ_FOREACH(mgmt, &chassis->c_mgmt, m_entries) {\n\t\tproto = lldpd_af_to_lldp_proto(mgmt->m_family);\n\t\tif (proto == LLDP_MGMT_ADDR_NONE) continue;\n\t\tif (!(\n\t\t\t  POKE_START_LLDP_TLV(LLDP_TLV_MGMT_ADDR) &&\n\t\t\t  \/* Size of the address, including its type *\/\n\t\t\t  POKE_UINT8(mgmt->m_addrsize + 1) &&\n\t\t\t  POKE_UINT8(proto) &&","target":0,"flaw_line_index":0,"hash":"460217f0-26c9-4f62-8e24-3efa483db232","idx":"474cb069-dddb-412a-aed5-55e434cef502"}
{"func_before":"\n   \/\/Parse the WWW-Authenticate field\n   while(token != NULL)\n   {\n      \/\/Check whether a separator is present\n      separator = strchr(token, '=');\n\n      \/\/Separator found?\n      if(separator != NULL)\n      {\n         \/\/Split the string","target":1,"flaw_line_index":0,"hash":"b3d6ce00-b26a-4e5d-a44a-fb0a8bfcd2c3","idx":"a71fbd02-8b91-4e2c-a37a-51c6c3acf389"}
{"func_before":"\n   \/\/Parse the WWW-Authenticate field\n   while(token != NULL)\n   {\n      \/\/Check whether a separator is present\n      separator = osStrchr(token, '=');\n\n      \/\/Separator found?\n      if(separator != NULL)\n      {\n         \/\/Split the string","target":0,"flaw_line_index":0,"hash":"72def7ca-a2d2-4d7d-a08f-7c4cc3d02f4f","idx":"a6583b53-fd3d-4552-8ea6-113088c24aa7"}
{"func_before":"LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n\tif(!file) return 0;\n\tstr = openmpt_module_get_instrument_name(file->mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval>=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n\t}\n\tretval = (int)tmpretval;\n\tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n\t}\n\topenmpt_free_string(str);\n\treturn retval;\n}","target":1,"flaw_line_index":0,"hash":"82a87c00-7563-484b-9013-99ebfa34ed33","idx":"d5e998e1-ec9d-46ca-885f-691e4b615933"}
{"func_before":"LIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tchar buf[32];\n\tif(!file) return 0;\n\tstr = openmpt_module_get_instrument_name(file->mod,qual-1);\n\tmemset(buf,0,32);\n\tif(str){\n\t\tstrncpy(buf,str,31);\n\t\topenmpt_free_string(str);\n\t}\n\tif(buff){\n\t\tstrncpy(buff,buf,32);\n\t}\n\treturn (unsigned int)strlen(buf);\n}","target":0,"flaw_line_index":0,"hash":"2ce9a9a9-bba0-4c0d-8587-78ae6bbaff5b","idx":"10f9ecc6-b62f-4a70-8b8a-6794fbef342b"}
{"func_before":"static void wdm_in_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc = urb->context;\n\tint status = urb->status;\n\n\tspin_lock(&desc->iuspin);\n\tclear_bit(WDM_RESPONDING, &desc->flags);\n\n\tif (status) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdesc->rerr = status;\n\tdesc->reslength = urb->actual_length;\n\tmemmove(desc->ubuf + desc->length, desc->inbuf, desc->reslength);\n\tdesc->length += desc->reslength;\nskip_error:\n\twake_up(&desc->wait);\n\n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);","target":1,"flaw_line_index":0,"hash":"48fe496c-7633-4222-b8b3-458682e6f659","idx":"d9e83627-e513-4446-a160-b216ba6d018d"}
{"func_before":"static void wdm_in_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc = urb->context;\n\tint status = urb->status;\n\tint length = urb->actual_length;\n\n\tspin_lock(&desc->iuspin);\n\tclear_bit(WDM_RESPONDING, &desc->flags);\n\n\tif (status) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdesc->rerr = status;\n\tif (length + desc->length > desc->wMaxCommand) {\n\t\t\/* The buffer would overflow *\/\n\t\tset_bit(WDM_OVERFLOW, &desc->flags);\n\t} else {\n\t\t\/* we may already be in overflow *\/\n\t\tif (!test_bit(WDM_OVERFLOW, &desc->flags)) {\n\t\t\tmemmove(desc->ubuf + desc->length, desc->inbuf, length);\n\t\t\tdesc->length += length;\n\t\t\tdesc->reslength = length;\n\t\t}\n\t}\nskip_error:\n\twake_up(&desc->wait);\n\n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock(&desc->iuspin);","target":0,"flaw_line_index":0,"hash":"e9fac44b-09c8-484d-8cf6-290dd9c832a4","idx":"d5dcaa28-f313-4cbf-b558-593237774ce8"}
{"func_before":"\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = IPPROTO_TCP;\n\t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\t\tfinal_p = fl6_update_dst(&fl6, np->opt, &final);\n\t\tfl6.saddr = ireq->ir_v6_loc_addr;\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = ireq->ir_mark;\n\t\tfl6.fl6_dport = ireq->ir_rmt_port;\n\t\tfl6.fl6_sport = inet_sk(sk)->inet_sport;","target":1,"flaw_line_index":0,"hash":"9aaf5680-5f93-4cb7-b1bc-56757c04f350","idx":"edcfe3d2-06d4-4bf1-a049-c00a7ac74cf0"}
{"func_before":"\t\tstruct in6_addr *final_p, final;\n\t\tstruct flowi6 fl6;\n\t\tmemset(&fl6, 0, sizeof(fl6));\n\t\tfl6.flowi6_proto = IPPROTO_TCP;\n\t\tfl6.daddr = ireq->ir_v6_rmt_addr;\n\t\tfinal_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);\n\t\tfl6.saddr = ireq->ir_v6_loc_addr;\n\t\tfl6.flowi6_oif = sk->sk_bound_dev_if;\n\t\tfl6.flowi6_mark = ireq->ir_mark;\n\t\tfl6.fl6_dport = ireq->ir_rmt_port;\n\t\tfl6.fl6_sport = inet_sk(sk)->inet_sport;","target":0,"flaw_line_index":0,"hash":"5b11eef6-a3b6-4f11-9d7d-6b8cf5bfaa7c","idx":"28dfb3b3-e255-4db4-84b4-f24fdd4718c1"}
{"func_before":"    int\t\tdir,\n    int\t\tcont_s_ipos)  \/\/ next ^X<> will set initial_pos\n{\n    char_u\t*str = str_arg;\n    char_u\t*p;\n    int\t\tactual_len;\t\t\/\/ Take multi-byte characters\n    int\t\tactual_compl_length;\t\/\/ into account.\n    int\t\tmin_len;\n    int\t\tflags = 0;\n\n    if (p_ic && curbuf->b_p_inf && len > 0)\n    {\n\t\/\/ Infer case of completed part.\n\n\t\/\/ Find actual length of completion.\n\tif (has_mbyte)\n\t{\n\t    p = str;\n\t    actual_len = 0;\n\t    while (*p != NUL)\n\t    {\n\t\tMB_PTR_ADV(p);\n\t\t++actual_len;\n\t    }\n\t}\n\telse\n\t    actual_len = len;\n\n\t\/\/ Find actual length of original text.\n\tif (has_mbyte)\n\t{\n\t    p = compl_orig_text;\n\t    actual_compl_length = 0;\n\t    while (*p != NUL)\n\t    {\n\t\tMB_PTR_ADV(p);\n\t\t++actual_compl_length;\n\t    }\n\t}\n\telse\n\t    actual_compl_length = compl_length;\n\n\t\/\/ \"actual_len\" may be smaller than \"actual_compl_length\" when using\n\t\/\/ thesaurus, only use the minimum when comparing.\n\tmin_len = actual_len < actual_compl_length\n\t\t\t\t\t   ? actual_len : actual_compl_length;\n\n\tstr = ins_compl_infercase_gettext(str, actual_len, actual_compl_length,\n\t\t\t\t\t\t\t\tmin_len);\n    }\n    if (cont_s_ipos)\n\tflags |= CP_CONT_S_IPOS;\n    if (icase)\n\tflags |= CP_ICASE;\n\n    return ins_compl_add(str, len, fname, NULL, NULL, dir, flags, FALSE);\n}","target":1,"flaw_line_index":0,"hash":"66babfb7-314c-4ff1-b06e-c88764e4bf21","idx":"749048a3-7866-4a63-ada9-f254e253a0d6"}
{"func_before":"    int\t\tdir,\n    int\t\tcont_s_ipos)  \/\/ next ^X<> will set initial_pos\n{\n    char_u\t*str = str_arg;\n    char_u\t*p;\n    int\t\tchar_len;\t\t\/\/ count multi-byte characters\n    int\t\tcompl_char_len;\n    int\t\tmin_len;\n    int\t\tflags = 0;\n    int\t\tres;\n    char_u\t*tofree = NULL;\n\n    if (p_ic && curbuf->b_p_inf && len > 0)\n    {\n\t\/\/ Infer case of completed part.\n\n\t\/\/ Find actual length of completion.\n\tif (has_mbyte)\n\t{\n\t    p = str;\n\t    char_len = 0;\n\t    while (*p != NUL)\n\t    {\n\t\tMB_PTR_ADV(p);\n\t\t++char_len;\n\t    }\n\t}\n\telse\n\t    char_len = len;\n\n\t\/\/ Find actual length of original text.\n\tif (has_mbyte)\n\t{\n\t    p = compl_orig_text;\n\t    compl_char_len = 0;\n\t    while (*p != NUL)\n\t    {\n\t\tMB_PTR_ADV(p);\n\t\t++compl_char_len;\n\t    }\n\t}\n\telse\n\t    compl_char_len = compl_length;\n\n\t\/\/ \"char_len\" may be smaller than \"compl_char_len\" when using\n\t\/\/ thesaurus, only use the minimum when comparing.\n\tmin_len = char_len < compl_char_len ? char_len : compl_char_len;\n\n\tstr = ins_compl_infercase_gettext(str, char_len,\n\t\t\t\t\t  compl_char_len, min_len, &tofree);\n    }\n    if (cont_s_ipos)\n\tflags |= CP_CONT_S_IPOS;\n    if (icase)\n\tflags |= CP_ICASE;\n\n    res = ins_compl_add(str, len, fname, NULL, NULL, dir, flags, FALSE);\n    vim_free(tofree);\n    return res;\n}","target":0,"flaw_line_index":0,"hash":"822006a0-28df-4b56-9773-f080dc113c94","idx":"de615fe9-2d67-4c86-bbe8-cd075acb9306"}
{"func_before":"    SRTP_PROTECTION_PROFILE *profile;\n    int rc, i, crypto_idx = -1;\n    pjmedia_srtp_crypto *tx, *rx;\n    pj_status_t status = PJ_SUCCESS;\n\n    pj_lock_acquire(ds->ossl_lock);\n\n    if (!ds->ossl_ssl[idx]) {\n        status = PJ_EGONE;\n        goto on_return;\n    }\n        pj_memcpy(k2+key_len, p, salt_len);\n        ds->got_keys = PJ_TRUE;\n    }\n\non_return:\n    pj_lock_release(ds->ossl_lock);\n    return status;\n}","target":1,"flaw_line_index":0,"hash":"1123679d-07e4-4d9a-824d-01fe6ce9354c","idx":"2849d886-7038-4264-a999-78d5cf59638f"}
{"func_before":"    SRTP_PROTECTION_PROFILE *profile;\n    int rc, i, crypto_idx = -1;\n    pjmedia_srtp_crypto *tx, *rx;\n    pj_status_t status = PJ_SUCCESS;\n\n    DTLS_LOCK(ds);\n\n    if (!ds->ossl_ssl[idx]) {\n        status = PJ_EGONE;\n        goto on_return;\n    }\n        pj_memcpy(k2+key_len, p, salt_len);\n        ds->got_keys = PJ_TRUE;\n    }\n\non_return:\n    DTLS_UNLOCK(ds);\n    return status;\n}","target":0,"flaw_line_index":0,"hash":"93e55312-68bd-443e-8c55-78d00303f26c","idx":"033f3919-20bf-4b47-9050-5634b43e95a5"}
{"func_before":"\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_SET_IRQS) {\n\t\tstruct vfio_irq_set hdr;\n\t\tu8 *data = NULL;\n\t\tint ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||\n\t\t    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |\n\t\t\t\t  VFIO_IRQ_SET_ACTION_TYPE_MASK))\n\t\t\treturn -EINVAL;\n\n\t\tif (!(hdr.flags & VFIO_IRQ_SET_DATA_NONE)) {\n\t\t\tsize_t size;\n\t\t\tint max = vfio_pci_get_irq_count(vdev, hdr.index);\n\n\t\t\tif (hdr.flags & VFIO_IRQ_SET_DATA_BOOL)\n\t\t\t\tsize = sizeof(uint8_t);\n\t\t\telse if (hdr.flags & VFIO_IRQ_SET_DATA_EVENTFD)\n\t\t\t\tsize = sizeof(int32_t);\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (hdr.argsz - minsz < hdr.count * size ||\n\t\t\t    hdr.start >= max || hdr.start + hdr.count > max)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t   hdr.count * size);\n\t\t\tif (IS_ERR(data))","target":1,"flaw_line_index":0,"hash":"23e71bbd-728c-449f-a078-61a9ee914da5","idx":"f344353c-a33d-4663-aa6c-2ea886fcc6ef"}
{"func_before":"\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\n\t} else if (cmd == VFIO_DEVICE_SET_IRQS) {\n\t\tstruct vfio_irq_set hdr;\n\t\tsize_t size;\n\t\tu8 *data = NULL;\n\t\tint max, ret = 0;\n\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\n\t\tif (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||\n\t\t    hdr.count >= (U32_MAX - hdr.start) ||\n\t\t    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |\n\t\t\t\t  VFIO_IRQ_SET_ACTION_TYPE_MASK))\n\t\t\treturn -EINVAL;\n\n\t\tmax = vfio_pci_get_irq_count(vdev, hdr.index);\n\t\tif (hdr.start >= max || hdr.start + hdr.count > max)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (hdr.flags & VFIO_IRQ_SET_DATA_TYPE_MASK) {\n\t\tcase VFIO_IRQ_SET_DATA_NONE:\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_BOOL:\n\t\t\tsize = sizeof(uint8_t);\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_EVENTFD:\n\t\t\tsize = sizeof(int32_t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (size) {\n\t\t\tif (hdr.argsz - minsz < hdr.count * size)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t   hdr.count * size);\n\t\t\tif (IS_ERR(data))","target":0,"flaw_line_index":0,"hash":"c4a430b4-bc89-4e40-af34-85abc5eff088","idx":"94cc916d-2ec0-4d9d-9c57-bf4dc1874432"}
{"func_before":"   \/\/Unable to retrieve the Request-URI?\n   if(token == NULL)\n      return ERROR_INVALID_REQUEST;\n\n   \/\/Check whether a query string is present\n   s = strchr(token, '?');\n\n   \/\/Query string found?\n   if(s != NULL)\n   {\n      \/\/Split the string","target":1,"flaw_line_index":0,"hash":"086d2f80-a986-46e9-ad3f-18086186a432","idx":"28ae2cc4-6fe5-45ce-aee4-4276ce41fc79"}
{"func_before":"   \/\/Unable to retrieve the Request-URI?\n   if(token == NULL)\n      return ERROR_INVALID_REQUEST;\n\n   \/\/Check whether a query string is present\n   s = osStrchr(token, '?');\n\n   \/\/Query string found?\n   if(s != NULL)\n   {\n      \/\/Split the string","target":0,"flaw_line_index":0,"hash":"bbfd3401-9d23-4249-ae61-ff47ad47800c","idx":"ba6518a0-a678-4c7a-aa2a-3399a7b27b4b"}
{"func_before":"    char_u\t*func_name;\n    char_u\t*lambda_name;\n    ufunc_T\t*ufunc;\n    int\t\tr = FAIL;\n    compiletype_T   compile_type;\n    isn_T\t*funcref_isn = NULL;\n\n    if (eap->forceit)\n    {\n\temsg(_(e_cannot_use_bang_with_nested_def));\n\treturn NULL;\n\tlambda_name = NULL;\n    }\n    else\n    {\n\t\/\/ Define a local variable for the function reference.\n\tlvar_T\t*lvar = reserve_local(cctx, func_name, name_end - name_start,\n\t\t\t\t\t\t    TRUE, ufunc->uf_func_type);\n\n\tif (lvar == NULL)\n\t    goto theend;\n\tif (generate_FUNCREF(cctx, ufunc, &funcref_isn) == FAIL)\n\t    goto theend;\n\tr = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);\n\tcompile_type = CT_PROFILE;\n#endif\n    if (func_needs_compiling(ufunc, compile_type)\n\t    && compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)\n    {\n\tfunc_ptr_unref(ufunc);\n\tgoto theend;\n    }\n\n#ifdef FEAT_PROFILE\n    \/\/ When the outer function is compiled for profiling, the nested function","target":1,"flaw_line_index":0,"hash":"f26835a2-e6f3-487f-b3fb-a61df254fed5","idx":"66fe87c3-8444-4fdb-979b-85cc419a948c"}
{"func_before":"    char_u\t*lambda_name;\n    ufunc_T\t*ufunc;\n    int\t\tr = FAIL;\n    compiletype_T   compile_type;\n    isn_T\t*funcref_isn = NULL;\n    lvar_T\t*lvar = NULL;\n\n    if (eap->forceit)\n    {\n\temsg(_(e_cannot_use_bang_with_nested_def));\n\treturn NULL;\n\tlambda_name = NULL;\n    }\n    else\n    {\n\t\/\/ Define a local variable for the function reference.\n\tlvar = reserve_local(cctx, func_name, name_end - name_start,\n\t\t\t\t\t\t    TRUE, ufunc->uf_func_type);\n\tif (lvar == NULL)\n\t    goto theend;\n\tif (generate_FUNCREF(cctx, ufunc, &funcref_isn) == FAIL)\n\t    goto theend;\n\tr = generate_STORE(cctx, ISN_STORE, lvar->lv_idx, NULL);\n#endif\n    if (func_needs_compiling(ufunc, compile_type)\n\t    && compile_def_function(ufunc, TRUE, compile_type, cctx) == FAIL)\n    {\n\tfunc_ptr_unref(ufunc);\n\tif (lvar != NULL)\n\t    \/\/ Now the local variable can't be used.\n\t    *lvar->lv_name = '\/';  \/\/ impossible value\n\tgoto theend;\n    }\n\n#ifdef FEAT_PROFILE\n    \/\/ When the outer function is compiled for profiling, the nested function","target":0,"flaw_line_index":0,"hash":"773f6cb0-b1e2-4c66-a9dd-ef4adffdece5","idx":"a870ceeb-a392-4b82-b0a6-4a28d9dcab2c"}
{"func_before":"void CLASS foveon_load_camf()\n{\n  unsigned type, wide, high, i, j, row, col, diff;\n  ushort huff[258], vpred[2][2] = {{512,512},{512,512}}, hpred[2];\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  type = get4();  get4();  get4();\n  wide = get4();\n  high = get4();\n  if (type == 2) {\n    fread (meta_data, 1, meta_length, ifp);\n    for (i=0; i < meta_length; i++) {\n      high = (high * 1597 + 51749) % 244944;\n      wide = high * (INT64) 301593171 >> 24;","target":1,"flaw_line_index":0,"hash":"e3bd7852-daae-429f-a980-38acc5f1016e","idx":"9c420323-ca7e-4349-bfad-9bd3be9aa88f"}
{"func_before":"void CLASS foveon_load_camf()\n{\n  unsigned type, wide, high, i, j, row, col, diff;\n  ushort huff[1024], vpred[2][2] = {{512,512},{512,512}}, hpred[2];\n\n  fseek (ifp, meta_offset, SEEK_SET);\n  type = get4();  get4();  get4();\n  wide = get4();\n  high = get4();\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(wide>32767 || high > 32767 || wide*high > 20000000)\n     throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  if (type == 2) {\n    fread (meta_data, 1, meta_length, ifp);\n    for (i=0; i < meta_length; i++) {\n      high = (high * 1597 + 51749) % 244944;\n      wide = high * (INT64) 301593171 >> 24;","target":0,"flaw_line_index":0,"hash":"637fa1cf-326d-4952-a9f6-a7e0f9ed3d91","idx":"8e3950c4-f5a1-4904-a378-32be6186f127"}
{"func_before":"    void reposition(int pos) { ptr = start + pos; }","target":1,"flaw_line_index":0,"hash":"a9f0be43-1906-43e7-a242-64ac8a3a956a","idx":"e5c7b0bb-cac9-45ec-bb74-d28626fbaa78"}
{"func_before":"    void reposition(size_t pos) { ptr = start + pos; }","target":0,"flaw_line_index":0,"hash":"31eacbd2-6f82-4a94-9593-2001d4525fb5","idx":"7329e43e-4687-43dd-b779-381247dfb472"}
{"func_before":"void test_parser(void) {\n\tint i, retval;\n\tbzrtpPacket_t *zrtpPacket;\n\n\t\/* Create zrtp Context to use H0-H3 chains and others *\/\n\tbzrtpContext_t *context87654321 = bzrtp_createBzrtpContext(0x87654321);\n\tbzrtpContext_t *context12345678 = bzrtp_createBzrtpContext(0x12345678);\n\n\n\t\/* replace created H by the patterns one to be able to generate the correct packet *\/\n\tmemcpy (context12345678->channelContext[0]->selfH[0], H12345678[0], 32);\n\tmemcpy (context12345678->channelContext[0]->selfH[1], H12345678[1], 32);\n\tmemcpy (context12345678->channelContext[0]->selfH[2], H12345678[2], 32);\n\tmemcpy (context12345678->channelContext[0]->selfH[3], H12345678[3], 32);\n\tmemcpy (context87654321->channelContext[0]->selfH[0], H87654321[0], 32);\n\tmemcpy (context87654321->channelContext[0]->selfH[1], H87654321[1], 32);\n\tmemcpy (context87654321->channelContext[0]->selfH[2], H87654321[2], 32);\n\tmemcpy (context87654321->channelContext[0]->selfH[3], H87654321[3], 32);\n\n\t\/* preset the key agreement algo in the contexts *\/\n\tcontext87654321->channelContext[0]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k;\n\tcontext12345678->channelContext[0]->keyAgreementAlgo = ZRTP_KEYAGREEMENT_DH3k;\n\tcontext87654321->channelContext[0]->cipherAlgo = ZRTP_CIPHER_AES1;\n\tcontext12345678->channelContext[0]->cipherAlgo = ZRTP_CIPHER_AES1;\n\tcontext87654321->channelContext[0]->hashAlgo = ZRTP_HASH_S256;\n\tcontext12345678->channelContext[0]->hashAlgo = ZRTP_HASH_S256;\n\n\tupdateCryptoFunctionPointers(context87654321->channelContext[0]);\n\tupdateCryptoFunctionPointers(context12345678->channelContext[0]);\n\n\t\/* set the zrtp and mac keys *\/\n\tcontext87654321->channelContext[0]->mackeyi = (uint8_t *)malloc(32);\n\tcontext12345678->channelContext[0]->mackeyi = (uint8_t *)malloc(32);\n\tcontext87654321->channelContext[0]->mackeyr = (uint8_t *)malloc(32);\n\tcontext12345678->channelContext[0]->mackeyr = (uint8_t *)malloc(32);\n\n\tcontext87654321->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(16);\n\tcontext12345678->channelContext[0]->zrtpkeyi = (uint8_t *)malloc(16);\n\tcontext87654321->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(16);\n\tcontext12345678->channelContext[0]->zrtpkeyr = (uint8_t *)malloc(16);\n\n\tmemcpy(context12345678->channelContext[0]->mackeyi, mackeyi, 32);\n\tmemcpy(context12345678->channelContext[0]->mackeyr, mackeyr, 32);\n\tmemcpy(context12345678->channelContext[0]->zrtpkeyi, zrtpkeyi, 16);\n\tmemcpy(context12345678->channelContext[0]->zrtpkeyr, zrtpkeyr, 16);\n\tmemcpy(context87654321->channelContext[0]->mackeyi, mackeyi, 32);\n\tmemcpy(context87654321->channelContext[0]->mackeyr, mackeyr, 32);\n\tmemcpy(context87654321->channelContext[0]->zrtpkeyi, zrtpkeyi, 16);\n\tmemcpy(context87654321->channelContext[0]->zrtpkeyr, zrtpkeyr, 16);\n\n\t\/* set the role: 87654321 is initiator in our exchange pattern *\/\n\tcontext12345678->channelContext[0]->role = RESPONDER;\n\n\tfor (i=0; i<TEST_PACKET_NUMBER; i++) {\n\t\tuint8_t freePacketFlag = 1;\n\t\t\/* parse a packet string from patterns *\/\n\t\tzrtpPacket = bzrtp_packetCheck(patternZRTPPackets[i], patternZRTPMetaData[i][0], (patternZRTPMetaData[i][1])-1, &retval);\n\t\tretval +=  bzrtp_packetParser((patternZRTPMetaData[i][2]==0x87654321)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x87654321)?context12345678->channelContext[0]:context87654321->channelContext[0], patternZRTPPackets[i], patternZRTPMetaData[i][0], zrtpPacket);\n\t\t\/*printf(\"parsing Ret val is %x index is %d\\n\", retval, i);*\/\n\t\t\/* We must store some packets in the context if we want to be able to parse further packets *\/\n\t\tif (zrtpPacket->messageType==MSGTYPE_HELLO) {\n\t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n\t\t\t\tcontext12345678->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t} else {\n\t\t\t\tcontext87654321->channelContext[0]->peerPackets[HELLO_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t}\n\t\t\tfreePacketFlag = 0;\n\t\t}\n\t\tif (zrtpPacket->messageType==MSGTYPE_COMMIT) {\n\t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n\t\t\t\tcontext12345678->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t} else {\n\t\t\t\tcontext87654321->channelContext[0]->peerPackets[COMMIT_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t}\n\t\t\tfreePacketFlag = 0;\n\t\t}\n\t\tif (zrtpPacket->messageType==MSGTYPE_DHPART1 || zrtpPacket->messageType==MSGTYPE_DHPART2) {\n\t\t\tif (patternZRTPMetaData[i][2]==0x87654321) {\n\t\t\t\tcontext12345678->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t} else {\n\t\t\t\tcontext87654321->channelContext[0]->peerPackets[DHPART_MESSAGE_STORE_ID] = zrtpPacket;\n\t\t\t}\n\t\t\tfreePacketFlag = 0;\n\t\t}\n\t\t\/* free the packet string as will be created again by the packetBuild function and might have been copied by packetParser *\/\n\t\tfree(zrtpPacket->packetString);\n\t\t\/* build a packet string from the parser packet*\/\n\t\tretval = bzrtp_packetBuild((patternZRTPMetaData[i][2]==0x12345678)?context12345678:context87654321, (patternZRTPMetaData[i][2]==0x12345678)?context12345678->channelContext[0]:context87654321->channelContext[0], zrtpPacket, patternZRTPMetaData[i][1]);\n\t\t\/* if (retval ==0) {\n\t\t\tpacketDump(zrtpPacket, 1);\n\t\t} else {\n\t\t\tbzrtp_message(\"Ret val is %x index is %d\\n\", retval, i);\n\t\t}*\/\n\n\t\t\/* check they are the same *\/\n\t\tif (zrtpPacket->packetString != NULL) {\n\t\t\tCU_ASSERT_TRUE(memcmp(zrtpPacket->packetString, patternZRTPPackets[i], patternZRTPMetaData[i][0]) == 0);\n\t\t} else {\n\t\t\tCU_FAIL(\"Unable to build packet\");\n\t\t}\n\n\t\tif (freePacketFlag == 1) {\n\t\t\tbzrtp_freeZrtpPacket(zrtpPacket);\n\t\t}\n\t}\n\n\tbzrtp_destroyBzrtpContext(context87654321, 0x87654321);\n\tbzrtp_destroyBzrtpContext(context12345678, 0x12345678);\n\n}","target":1,"flaw_line_index":0,"hash":"540af806-6042-4b24-b29c-c610a6e2d2e5","idx":"6790df88-a86b-4d15-96bb-cdb046d3a1c7"}
{"func_before":"void test_parser(void) {\n\ttest_parser_param(0);\n}","target":0,"flaw_line_index":0,"hash":"227c8860-09b3-48c2-b872-d8f42ceab073","idx":"e70e0a35-7db8-4a91-9a7b-43c64eb36be8"}
{"func_before":"PlayerGeneric::~PlayerGeneric()\n{\n\tif (mixer)\n\t\tdelete mixer;\n\n\tif (player)\n\t{\n\t\tif (mixer->isActive() && !mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\tdelete player;\n\t}\n\n\tdelete[] audioDriverName;\n\t\n\tdelete listener;\n}","target":1,"flaw_line_index":0,"hash":"3b17b5d3-475c-4028-9c21-6f6d47b86735","idx":"4babd0c4-c44f-43bf-8ff9-85b6375a3bde"}
{"func_before":"PlayerGeneric::~PlayerGeneric()\n{\n\n\tif (player)\n\t{\n\t\tif (mixer && mixer->isActive() && !mixer->isDeviceRemoved(player))\n\t\t\tmixer->removeDevice(player);\n\t\tdelete player;\n\t}\n\t\n\tif (mixer)\n\t\tdelete mixer;\n\n\tdelete[] audioDriverName;\n\t\n\tdelete listener;\n}","target":0,"flaw_line_index":0,"hash":"0f708c65-68d7-4f4c-a373-3ed387262fbc","idx":"5878c658-eea7-4a92-b113-b39ef773eaa7"}
{"func_before":"            ether_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            return l2info.header_len;\n        }\n\n        if (p[0] == 0x03) { \/* Cisco style NLPID encaps ? *\/\n            isoclns_print(ndo, p + 1, l2info.length - 1, l2info.caplen - 1);\n            \/* FIXME check if frame was recognized *\/\n            return l2info.header_len;\n        }\n\n        if(juniper_ppp_heuristic_guess(ndo, p, l2info.length) != 0) \/* PPPoA vcmux encaps ? *\/","target":1,"flaw_line_index":0,"hash":"9560b322-678f-492e-9842-252690ac4430","idx":"668a9e33-60e7-4575-a107-4a5be46132a9"}
{"func_before":"            ether_print(ndo, p, l2info.length, l2info.caplen, NULL, NULL);\n            return l2info.header_len;\n        }\n\n        if (p[0] == 0x03) { \/* Cisco style NLPID encaps ? *\/\n            isoclns_print(ndo, p + 1, l2info.length - 1);\n            \/* FIXME check if frame was recognized *\/\n            return l2info.header_len;\n        }\n\n        if(juniper_ppp_heuristic_guess(ndo, p, l2info.length) != 0) \/* PPPoA vcmux encaps ? *\/","target":0,"flaw_line_index":0,"hash":"a7abd8a5-4d18-43c7-9870-89cfa02ef0b9","idx":"25b9ec93-307d-4ca9-8123-4c10a2441bc3"}
{"func_before":"                csRes = ParaNdis_CheckRxChecksum(\n                    pContext,\n                    pHeader->flags,\n                    &pBuffersDesc->PhysicalPages[PARANDIS_FIRST_RX_DATA_PAGE],\n                    pPacketInfo->dataLength,\n                    nBytesStripped);\n                if (csRes.value)\n                {\n                    NDIS_TCP_IP_CHECKSUM_NET_BUFFER_LIST_INFO qCSInfo;\n                    qCSInfo.Value = NULL;\n                    qCSInfo.Receive.IpChecksumFailed = csRes.flags.IpFailed;","target":1,"flaw_line_index":0,"hash":"932946a6-5d95-4771-bc38-5a44048de12f","idx":"5e474e23-d709-43ab-aeba-471782a2f173"}
{"func_before":"                csRes = ParaNdis_CheckRxChecksum(\n                    pContext,\n                    pHeader->flags,\n                    &pBuffersDesc->PhysicalPages[PARANDIS_FIRST_RX_DATA_PAGE],\n                    pPacketInfo->dataLength,\n                    nBytesStripped, TRUE);\n                if (csRes.value)\n                {\n                    NDIS_TCP_IP_CHECKSUM_NET_BUFFER_LIST_INFO qCSInfo;\n                    qCSInfo.Value = NULL;\n                    qCSInfo.Receive.IpChecksumFailed = csRes.flags.IpFailed;","target":0,"flaw_line_index":0,"hash":"8c8e021c-6634-48cf-a44b-3d8905f51a47","idx":"02ca8fbf-5ebb-4b09-ac23-164cb9230126"}
{"func_before":"label (const uint8_t * src, size_t srclen, uint8_t * dst, size_t * dstlen,\n       int flags)\n{\n  size_t plen;\n  uint32_t *p;\n  int rc;\n  size_t tmpl;\n\n  if (_idn2_ascii_p (src, srclen))\n    {\n      if (flags & IDN2_ALABEL_ROUNDTRIP)\n\t\/* FIXME implement this MAY:\n\n\t   If the input to this procedure appears to be an A-label\n\t   (i.e., it starts in \"xn--\", interpreted\n\t   case-insensitively), the lookup application MAY attempt to\n\t   convert it to a U-label, first ensuring that the A-label is\n\t   entirely in lowercase (converting it to lowercase if\n\t   necessary), and apply the tests of Section 5.4 and the\n\t   conversion of Section 5.5 to that form. *\/\n\treturn IDN2_INVALID_FLAGS;\n\n      if (srclen > IDN2_LABEL_MAX_LENGTH)\n\treturn IDN2_TOO_BIG_LABEL;\n      if (srclen > *dstlen)\n\treturn IDN2_TOO_BIG_DOMAIN;\n\n      memcpy (dst, src, srclen);\n      *dstlen = srclen;\n      return IDN2_OK;\n    }\n\n  rc = _idn2_u8_to_u32_nfc (src, srclen, &p, &plen, flags & IDN2_NFC_INPUT);\n  if (rc != IDN2_OK)\n    return rc;\n\n  if (!(flags & IDN2_TRANSITIONAL))\n    {\n      rc = _idn2_label_test(\n\tTEST_NFC |\n\t((flags & IDN2_USE_STD3_ASCII_RULES) ? 0 : TEST_ALLOW_STD3_DISALLOWED),\n\tp, plen);\n\n      if (rc != IDN2_OK)\n\t{\n\t  free(p);\n\t  return rc;\n\t}\n    }\n\n  dst[0] = 'x';\n  dst[1] = 'n';\n\n  tmpl = *dstlen - 4;\n  rc = _idn2_punycode_encode (plen, p, &tmpl, (char *) dst + 4);\n  free (p);\n  if (rc != IDN2_OK)\n    return rc;\n\n  *dstlen = 4 + tmpl;\n\n  return IDN2_OK;\n}","target":1,"flaw_line_index":0,"hash":"f85c54bc-be40-4289-ac01-958854ff0899","idx":"3c2606ab-0a0d-47f1-9e68-60a6a89c0886"}
{"func_before":"label (const uint8_t * src, size_t srclen, uint8_t * dst, size_t * dstlen,\n       int flags)\n{\n  size_t plen;\n  uint32_t *p;\n  const uint8_t *src_org = NULL;\n  uint8_t *src_allocated = NULL;\n  int rc, check_roundtrip = 0;\n  size_t tmpl, srclen_org = 0;\n  uint32_t label_u32[IDN2_LABEL_MAX_LENGTH];\n  size_t label32_len = IDN2_LABEL_MAX_LENGTH;\n\n  if (_idn2_ascii_p (src, srclen)) {\n    if (!(flags & IDN2_NO_ALABEL_ROUNDTRIP) && srclen >= 4 && memcmp (src, \"xn--\", 4) == 0) {\n      \/*\n\t If the input to this procedure appears to be an A-label\n\t (i.e., it starts in \"xn--\", interpreted\n\t case-insensitively), the lookup application MAY attempt to\n\t convert it to a U-label, first ensuring that the A-label is\n\t entirely in lowercase (converting it to lowercase if\n\t necessary), and apply the tests of Section 5.4 and the\n\t conversion of Section 5.5 to that form. *\/\n      rc = _idn2_punycode_decode (srclen - 4, (char *) src + 4, &label32_len, label_u32);\n      if (rc)\n\treturn rc;\n\n      check_roundtrip = 1;\n      src_org = src;\n      srclen_org = srclen;\n\n      srclen = IDN2_LABEL_MAX_LENGTH;\n      src = src_allocated = u32_to_u8 (label_u32, label32_len, NULL, &srclen);\n      if (!src) {\n\tif (errno == ENOMEM)\n\t  return IDN2_MALLOC;\n\treturn IDN2_ENCODING_ERROR;\n      }\n    } else {\n      if (srclen > IDN2_LABEL_MAX_LENGTH)\n\treturn IDN2_TOO_BIG_LABEL;\n      if (srclen > *dstlen)\n\treturn IDN2_TOO_BIG_DOMAIN;\n\n      memcpy (dst, src, srclen);\n      *dstlen = srclen;\n      return IDN2_OK;\n    }\n  }\n\n  rc = _idn2_u8_to_u32_nfc (src, srclen, &p, &plen, flags & IDN2_NFC_INPUT);\n  if (rc != IDN2_OK)\n    goto out;\n\n  if (!(flags & IDN2_TRANSITIONAL))\n    {\n      rc = _idn2_label_test(\n\tTEST_NFC |\n\t((flags & IDN2_USE_STD3_ASCII_RULES) ? 0 : TEST_ALLOW_STD3_DISALLOWED),\n\tp, plen);\n\n      if (rc != IDN2_OK)\n\t{\n\t  free (p);\n\t  goto out;\n\t}\n    }\n\n  dst[0] = 'x';\n  dst[1] = 'n';\n\n  tmpl = *dstlen - 4;\n  rc = _idn2_punycode_encode (plen, p, &tmpl, (char *) dst + 4);\n  free (p);\n  if (rc != IDN2_OK)\n    goto out;\n\n\n  *dstlen = 4 + tmpl;\n\n  if (check_roundtrip)\n    {\n      if (srclen_org != *dstlen || memcmp (src_org, dst, srclen_org))\n      {\n        rc = IDN2_ALABEL_ROUNDTRIP_FAILED;\n\tgoto out;\n      }\n    }\n\n  rc = IDN2_OK;\n\nout:\n  free (src_allocated);\n  return rc;\n}","target":0,"flaw_line_index":0,"hash":"c2871d6d-5002-4f56-bf7a-e7f0cd836c47","idx":"5c4a93b7-53c2-451c-904c-3fe04e92cbab"}
{"func_before":"\n    if (!mount_point.isEmpty())\n        return mount_point;\n\n    mount_point = \"%1\/.%2\/mount\/%3\";\n    const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::TempLocation);\n\n    mount_point = mount_point.arg(tmp_paths.isEmpty() ? \"\/tmp\" : tmp_paths.first()).arg(qApp->applicationName()).arg(name);\n\n    if (!QDir::current().mkpath(mount_point)) {\n        dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(mount_point));\n\n        return QString();","target":1,"flaw_line_index":0,"hash":"7bf668e7-d012-47c7-bc91-f5c187b44733","idx":"5d9ffe84-7d89-405e-b35e-22640996659a"}
{"func_before":"\n    if (!mount_point.isEmpty())\n        return mount_point;\n\n    mount_point = \"%1\/.%2\/mount\/%3\";\n    const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::RuntimeLocation);\n\n    mount_point = mount_point.arg(tmp_paths.isEmpty() ? \"\/run\/user\/0\" : tmp_paths.first()).arg(qApp->applicationName()).arg(name);\n\n    if (!QDir::current().mkpath(mount_point)) {\n        dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(mount_point));\n\n        return QString();","target":0,"flaw_line_index":0,"hash":"0595f952-f3b5-4c8a-8343-e9161c733c0f","idx":"afc9d791-d7cd-42c6-9ab1-1875ffafde8d"}
{"func_before":"\t\terr = -ENOENT;\n\t\tdst_vma = find_vma(dst_mm, dst_start);\n\t\tif (!dst_vma || !is_vm_hugetlb_page(dst_vma))\n\t\t\tgoto out_unlock;\n\t\t\/*\n\t\t * Only allow __mcopy_atomic_hugetlb on userfaultfd\n\t\t * registered ranges.\n\t\t *\/\n\t\tif (!dst_vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto out_unlock;\n\n\t\tif (dst_start < dst_vma->vm_start ||","target":1,"flaw_line_index":0,"hash":"8f614692-56a0-4c93-9c61-2e66e355045b","idx":"9b087465-23ed-452f-bb79-45455e7f0e66"}
{"func_before":"\t\terr = -ENOENT;\n\t\tdst_vma = find_vma(dst_mm, dst_start);\n\t\tif (!dst_vma || !is_vm_hugetlb_page(dst_vma))\n\t\t\tgoto out_unlock;\n\t\t\/*\n\t\t * Check the vma is registered in uffd, this is\n\t\t * required to enforce the VM_MAYWRITE check done at\n\t\t * uffd registration time.\n\t\t *\/\n\t\tif (!dst_vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto out_unlock;\n\n\t\tif (dst_start < dst_vma->vm_start ||","target":0,"flaw_line_index":0,"hash":"f02ac2a4-0939-46b7-a4b5-18dfe4d452a8","idx":"4d6e45cd-9c03-4b4c-95ec-0861a5ef6068"}
{"func_before":"static void validate_dex_header(const dex_header* dh,\n                                size_t dexsize,\n                                int support_dex_version) {\n  bool supported = false;\n  switch (support_dex_version) {\n  case 38:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V38, sizeof(dh->magic));\n  always_assert_log(\n      dh->file_size == dexsize,\n      \"Reported size in header (%zu) does not match file size (%u)\\n\",\n      dexsize,\n      dh->file_size);\n  auto off = (uint64_t)dh->class_defs_off;\n  auto limit = off + dh->class_defs_size * sizeof(dex_class_def);\n  always_assert_log(off < dexsize, \"class_defs_off out of range\");\n  always_assert_log(limit <= dexsize, \"invalid class_defs_size\");\n}","target":1,"flaw_line_index":0,"hash":"eeb93c04-44fa-4774-bddc-8db9dcd3c846","idx":"854c0d7d-545b-46f6-bc02-cb14587abad3"}
{"func_before":"static void validate_dex_header(const dex_header* dh,\n                                size_t dexsize,\n                                int support_dex_version) {\n  always_assert_log(sizeof(dex_header) <= dexsize,\n                    \"Header size (%lu) is larger than file size (%zu)\\n\",\n                    dexsize,\n                    sizeof(dex_header));\n  bool supported = false;\n  switch (support_dex_version) {\n  case 38:\n    supported = supported ||\n                !memcmp(dh->magic, DEX_HEADER_DEXMAGIC_V38, sizeof(dh->magic));\n  always_assert_log(\n      dh->file_size == dexsize,\n      \"Reported size in header (%zu) does not match file size (%u)\\n\",\n      dexsize,\n      dh->file_size);\n\n  auto str_ids_off = (uint64_t)dh->string_ids_off;\n  auto str_ids_limit =\n      str_ids_off + dh->string_ids_size * sizeof(dex_string_id);\n  always_assert_log(str_ids_off < dexsize, \"string_ids_off out of range\");\n  always_assert_log(str_ids_limit <= dexsize, \"invalid string_ids_size\");\n\n  auto type_ids_off = (uint64_t)dh->type_ids_off;\n  auto type_ids_limit = type_ids_off + dh->type_ids_size * sizeof(dex_type_id);\n  always_assert_log(type_ids_off < dexsize, \"type_ids_off out of range\");\n  always_assert_log(type_ids_limit <= dexsize, \"invalid type_ids_size\");\n\n  auto proto_ids_off = (uint64_t)dh->proto_ids_off;\n  auto proto_ids_limit =\n      proto_ids_off + dh->proto_ids_size * sizeof(dex_proto_id);\n  always_assert_log(proto_ids_off < dexsize, \"proto_ids_off out of range\");\n  always_assert_log(proto_ids_limit <= dexsize, \"invalid proto_ids_size\");\n\n  auto field_ids_off = (uint64_t)dh->field_ids_off;\n  auto field_ids_limit =\n      field_ids_off + dh->field_ids_size * sizeof(dex_field_id);\n  always_assert_log(field_ids_off < dexsize, \"field_ids_off out of range\");\n  always_assert_log(field_ids_limit <= dexsize, \"invalid field_ids_size\");\n\n  auto meth_ids_off = (uint64_t)dh->method_ids_off;\n  auto meth_ids_limit =\n      meth_ids_off + dh->method_ids_size * sizeof(dex_method_id);\n  always_assert_log(meth_ids_off < dexsize, \"method_ids_off out of range\");\n  always_assert_log(meth_ids_limit <= dexsize, \"invalid method_ids_size\");\n\n  auto cls_defs_off = (uint64_t)dh->class_defs_off;\n  auto cls_defs_limit =\n      cls_defs_off + dh->class_defs_size * sizeof(dex_class_def);\n  always_assert_log(cls_defs_off < dexsize, \"class_defs_off out of range\");\n  always_assert_log(cls_defs_limit <= dexsize, \"invalid class_defs_size\");\n}","target":0,"flaw_line_index":0,"hash":"0025d953-5af1-4e91-aa7d-01b2ce3b63a1","idx":"be63f874-012e-4dda-a856-e0c3f360d216"}
{"func_before":"      timer.reset(new GpuTimer(parent_));\n      \/\/ The start and stop of the timer should be as close to the Cudnn call as\n      \/\/ possible. It is still possible for other threads to issue workload on\n      \/\/ to this stream. So it could take multiple profiling measurements.\n      if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n        return tsl::Status(port::error::INTERNAL, \"Failed to start timer\");\n      }\n    }\n\n    RETURN_IF_CUDNN_ERROR(cudnnRNNBackwardData_v8(\n        \/*handle=*\/cudnn.handle(), \/*rnnDesc=*\/rnn_desc.handle(),\n          \/*reserveSpace=*\/reserve_space_data->opaque()));\n    }\n\n    if (is_profiling) {\n      if (!timer->Stop(AsGpuStream(stream))) {\n        return tsl::Status(port::error::INTERNAL, \"Failed to stop timer\");\n      }\n      auto algo_desc = *rnn_desc.algorithm_config().algorithm();\n      output_profile_result->set_algorithm(algo_desc);\n      output_profile_result->set_elapsed_time_in_ms(\n          timer->GetElapsedMilliseconds());\n    timer.reset(new GpuTimer(parent_));\n    \/\/ The start and stop of the timer should be as close to the Cudnn call as\n    \/\/ possible. It is still possible for other threads to issue workload on\n    \/\/ to this stream. So it could take multiple profiling measurements.\n    if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n      return tsl::Status(port::error::INTERNAL, \"Failed to start timer\");\n    }\n  }\n\n  if (input_desc.is_var_seq_lengths()) {\n    RETURN_IF_CUDNN_ERROR(cudnnRNNBackwardDataEx(\n    }\n  }\n\n  if (is_profiling) {\n    if (!timer->Stop(AsGpuStream(stream))) {\n      return tsl::Status(port::error::INTERNAL, \"Failed to stop timer\");\n    }\n    auto algo_desc = *rnn_desc.algorithm_config().algorithm();\n    output_profile_result->set_algorithm(algo_desc);\n    output_profile_result->set_elapsed_time_in_ms(\n        timer->GetElapsedMilliseconds());","target":1,"flaw_line_index":0,"hash":"6d7b1222-8809-46e6-b811-5b240e124317","idx":"07f8c8d0-47c6-4f92-814c-684d0bbd5d65"}
{"func_before":"      timer.reset(new GpuTimer(parent_));\n      \/\/ The start and stop of the timer should be as close to the Cudnn call as\n      \/\/ possible. It is still possible for other threads to issue workload on\n      \/\/ to this stream. So it could take multiple profiling measurements.\n      if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n        return tsl::Status(tsl::error::INTERNAL, \"Failed to start timer\");\n      }\n    }\n\n    RETURN_IF_CUDNN_ERROR(cudnnRNNBackwardData_v8(\n        \/*handle=*\/cudnn.handle(), \/*rnnDesc=*\/rnn_desc.handle(),\n          \/*reserveSpace=*\/reserve_space_data->opaque()));\n    }\n\n    if (is_profiling) {\n      if (!timer->Stop(AsGpuStream(stream))) {\n        return tsl::Status(tsl::error::INTERNAL, \"Failed to stop timer\");\n      }\n      auto algo_desc = *rnn_desc.algorithm_config().algorithm();\n      output_profile_result->set_algorithm(algo_desc);\n      output_profile_result->set_elapsed_time_in_ms(\n          timer->GetElapsedMilliseconds());\n    timer.reset(new GpuTimer(parent_));\n    \/\/ The start and stop of the timer should be as close to the Cudnn call as\n    \/\/ possible. It is still possible for other threads to issue workload on\n    \/\/ to this stream. So it could take multiple profiling measurements.\n    if (!timer->Init() || !timer->Start(AsGpuStream(stream))) {\n      return tsl::Status(tsl::error::INTERNAL, \"Failed to start timer\");\n    }\n  }\n\n  if (input_desc.is_var_seq_lengths()) {\n    RETURN_IF_CUDNN_ERROR(cudnnRNNBackwardDataEx(\n    }\n  }\n\n  if (is_profiling) {\n    if (!timer->Stop(AsGpuStream(stream))) {\n      return tsl::Status(tsl::error::INTERNAL, \"Failed to stop timer\");\n    }\n    auto algo_desc = *rnn_desc.algorithm_config().algorithm();\n    output_profile_result->set_algorithm(algo_desc);\n    output_profile_result->set_elapsed_time_in_ms(\n        timer->GetElapsedMilliseconds());","target":0,"flaw_line_index":0,"hash":"6705c79c-b450-4bc8-8d03-d10e0130be70","idx":"8a062979-3876-4faf-a486-be18ab2f2cff"}
{"func_before":"  void Compute(OpKernelContext* context) override {\n    CHECK_EQ(3, context->num_inputs());\n    const Tensor& input = context->input(0);\n    const int depth = input.dim_size(input.dims() - 1);  \/\/ last dimension size.\n    const Tensor& min = context->input(1);\n    OP_REQUIRES(context, min.dim_size(0) == depth,\n                InvalidArgument(\"min has incorrect size, expected \", depth,\n                                \" was \", min.dim_size(0)));\n    const Tensor& max = context->input(2);\n    OP_REQUIRES(context, max.dim_size(0) == depth,\n                InvalidArgument(\"max has incorrect size, expected \", depth,\n                                \" was \", max.dim_size(0)));\n\n    Tensor* output;","target":1,"flaw_line_index":0,"hash":"44c76d4d-a895-4dbc-96cb-134c4e05095e","idx":"34919257-4a1d-4e86-bf4c-3990f8127721"}
{"func_before":"  void Compute(OpKernelContext* context) override {\n    CHECK_EQ(3, context->num_inputs());\n    const Tensor& input = context->input(0);\n    const int depth = input.dim_size(input.dims() - 1);  \/\/ last dimension size.\n    const Tensor& min = context->input(1);\n    const Tensor& max = context->input(2);\n\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsVector(min.shape()),\n        InvalidArgument(\"`min` must be rank 1 but is rank \", min.dims()));\n    OP_REQUIRES(context, min.dim_size(0) == depth,\n                InvalidArgument(\"min has incorrect size, expected \", depth,\n                                \" was \", min.dim_size(0)));\n    OP_REQUIRES(\n        context, TensorShapeUtils::IsVector(max.shape()),\n        InvalidArgument(\"`max` must be rank 1 but is rank \", max.dims()));\n    OP_REQUIRES(context, max.dim_size(0) == depth,\n                InvalidArgument(\"max has incorrect size, expected \", depth,\n                                \" was \", max.dim_size(0)));\n\n    Tensor* output;","target":0,"flaw_line_index":0,"hash":"64ab2779-95c2-4b6d-816e-10c8400822ce","idx":"09091c37-65ad-49d1-8b77-62835bb86b9d"}
{"func_before":"  static TfLiteRegistration registration = {\n      .init = nullptr,\n      .free = nullptr,\n      .prepare =\n          [](TfLiteContext* context, TfLiteNode* node) {\n            const TfLiteTensor* input = tflite::GetInput(context, node, 0);\n            TfLiteTensor* output = tflite::GetOutput(context, node, 0);\n            TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n            output->type = kTfLiteFloat32;\n            return context->ResizeTensor(context, output, output_dims);\n          },\n      .invoke =\n          [](TfLiteContext* context, TfLiteNode* node) {\n            TfLiteTensor* output = tflite::GetOutput(context, node, 0);\n            std::fill(output->data.f,\n                      output->data.f + tflite::NumElements(output), 7.0f);\n            return kTfLiteOk;\n          },\n      .profiling_string = nullptr,","target":1,"flaw_line_index":0,"hash":"6dfc1d65-7eb1-443e-991c-5e9b0507b05b","idx":"710cf2f8-a3b9-4b97-a2c8-c3b20dfa6153"}
{"func_before":"  static TfLiteRegistration registration = {\n      .init = nullptr,\n      .free = nullptr,\n      .prepare =\n          [](TfLiteContext* context, TfLiteNode* node) {\n            const TfLiteTensor* input;\n            TF_LITE_ENSURE_OK(context,\n                              tflite::GetInputSafe(context, node, 0, &input));\n            TfLiteTensor* output;\n            TF_LITE_ENSURE_OK(context,\n                              tflite::GetOutputSafe(context, node, 0, &output));\n            TfLiteIntArray* output_dims = TfLiteIntArrayCopy(input->dims);\n            output->type = kTfLiteFloat32;\n            return context->ResizeTensor(context, output, output_dims);\n          },\n      .invoke =\n          [](TfLiteContext* context, TfLiteNode* node) {\n            TfLiteTensor* output;\n            TF_LITE_ENSURE_OK(context,\n                              tflite::GetOutputSafe(context, node, 0, &output));\n            std::fill(output->data.f,\n                      output->data.f + tflite::NumElements(output), 7.0f);\n            return kTfLiteOk;\n          },\n      .profiling_string = nullptr,","target":0,"flaw_line_index":0,"hash":"3efc675c-8491-4229-8cb9-c419b2733ea8","idx":"7bb60525-36ae-44e9-abdf-e1c7a5b609aa"}
{"func_before":"    if (!UnsortedSegmentReductionDoValidation(this, context, data, segment_ids,\n                                              num_segments)) {\n      return;\n    }\n    const auto segment_flat = segment_ids.flat<Index>();\n    const Index output_rows = internal::SubtleMustCopy(static_cast<Index>(\n        num_segments.dtype() == DT_INT32 ? num_segments.scalar<int32>()()\n                                         : num_segments.scalar<int64>()()));\n    OP_REQUIRES(context, output_rows >= 0,\n                errors::InvalidArgument(\"Input num_segments == \", output_rows,\n                                        \" must not be negative.\"));\n      output_shape.AddDim(data.dim_size(i));\n    }\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    auto output_flat = output->flat_outer_dims<T>();\n    auto data_ptr = data.template flat<T>().data();\n    reduction_functor_(context, output_rows, segment_ids.shape(), segment_flat,\n                       data.NumElements(), data_ptr, output_flat);\n  }","target":1,"flaw_line_index":0,"hash":"83d0c8f5-9f0e-43c3-b1ef-12f5e8a3b161","idx":"0c3bc40a-187c-4bd2-a661-8b0e27859094"}
{"func_before":"    if (!UnsortedSegmentReductionDoValidation(this, context, data, segment_ids,\n                                              num_segments)) {\n      return;\n    }\n    const auto segment_flat = segment_ids.flat<Index>();\n    const int64 output_rows = internal::SubtleMustCopy(static_cast<int64>(\n        num_segments.dtype() == DT_INT32 ? num_segments.scalar<int32>()()\n                                         : num_segments.scalar<int64>()()));\n    OP_REQUIRES(context, output_rows >= 0,\n                errors::InvalidArgument(\"Input num_segments == \", output_rows,\n                                        \" must not be negative.\"));\n      output_shape.AddDim(data.dim_size(i));\n    }\n    Tensor* output = nullptr;\n    OP_REQUIRES_OK(context, context->allocate_output(0, output_shape, &output));\n    auto output_flat = output->flat_outer_dims<T>();\n    auto data_flat = data.flat_inner_outer_dims<T, 2>(segment_ids.dims() - 1);\n    reduction_functor_(context, segment_ids.shape(), segment_flat, data_flat,\n                       output_flat);\n  }","target":0,"flaw_line_index":0,"hash":"c0a76a17-537a-455b-819d-53e27d391cad","idx":"ca59055b-cd80-453f-a5ae-a8327ef7f5dd"}
{"func_before":"static bool caller_is_in_ancestor(pid_t pid, const char *contrl, const char *cg, char **nextcg)\n{\n\tchar fnam[PROCLEN];\n\tFILE *f;\n\tbool answer = false;\n\tchar *line = NULL;\n\tsize_t len = 0;\n\tint ret;\n\n\tret = snprintf(fnam, PROCLEN, \"\/proc\/%d\/cgroup\", pid);\n\tif (ret < 0 || ret >= PROCLEN)\n\t\treturn false;\n\tif (!(f = fopen(fnam, \"r\")))\n\t\treturn false;\n\n\twhile (getline(&line, &len, f) != -1) {\n\t\tchar *c1, *c2, *linecmp;\n\t\tif (!line[0])\n\t\t\tcontinue;\n\t\tc1 = strchr(line, ':');\n\t\tif (!c1)\n\t\t\tgoto out;\n\t\tc1++;\n\t\tc2 = strchr(c1, ':');\n\t\tif (!c2)\n\t\t\tgoto out;\n\t\t*c2 = '\\0';\n\t\tif (strcmp(c1, contrl) != 0)\n\t\t\tcontinue;\n\t\tc2++;\n\t\tstripnewline(c2);\n\t\tprune_init_slice(c2);\n\t\t\/*\n\t\t * callers pass in '\/' for root cgroup, otherwise they pass\n\t\t * in a cgroup without leading '\/'\n\t\t *\/\n\t\tlinecmp = *cg == '\/' ? c2 : c2+1;\n\t\tif (strncmp(linecmp, cg, strlen(linecmp)) != 0) {\n\t\t\tif (nextcg)\n\t\t\t\t*nextcg = get_next_cgroup_dir(linecmp, cg);\n\t\t\tgoto out;\n\t\t}\n\t\tanswer = true;\n\t\tgoto out;\n\t}\n\nout:\n\tfclose(f);\n\tfree(line);\n\treturn answer;\n}","target":1,"flaw_line_index":0,"hash":"774a1639-a6a5-4e29-b195-90f6a713c3ad","idx":"01e647c7-9e92-40b3-b050-288fefa990c1"}
{"func_before":"static bool caller_is_in_ancestor(pid_t pid, const char *contrl, const char *cg, char **nextcg)\n{\n\tbool answer = false;\n\tchar *c2 = get_pid_cgroup(pid, contrl);\n\tchar *linecmp;\n\n\tif (!c2)\n\t\treturn false;\n\tprune_init_slice(c2);\n\n\t\/*\n\t * callers pass in '\/' for root cgroup, otherwise they pass\n\t * in a cgroup without leading '\/'\n\t *\/\n\tlinecmp = *cg == '\/' ? c2 : c2+1;\n\tif (strncmp(linecmp, cg, strlen(linecmp)) != 0) {\n\t\tif (nextcg) {\n\t\t\t*nextcg = get_next_cgroup_dir(linecmp, cg);\n\t\t}\n\t\tgoto out;\n\t}\n\tanswer = true;\n\nout:\n\tfree(c2);\n\treturn answer;\n}","target":0,"flaw_line_index":0,"hash":"ec4bee52-990b-43c0-9566-f917d7b2e86b","idx":"3825c919-4ab3-4ba1-8141-e904423fbddf"}
{"func_before":"void HeaderMapImpl::addCopy(const LowerCaseString& key, uint64_t value) {\n  auto* entry = getExistingInline(key.get());\n  if (entry != nullptr) {\n    char buf[32];\n    StringUtil::itoa(buf, sizeof(buf), value);\n    appendToHeader(entry->value(), buf);\n    return;\n  }\n  HeaderString new_key;\n  new_key.setCopy(key.get().c_str(), key.get().size());\n  HeaderString new_value;","target":1,"flaw_line_index":0,"hash":"958e74bf-2edb-475a-9443-4c4be41cb41c","idx":"cc5d3c86-2369-494b-aef8-e46e8302ce08"}
{"func_before":"void HeaderMapImpl::addCopy(const LowerCaseString& key, uint64_t value) {\n  auto* entry = getExistingInline(key.get());\n  if (entry != nullptr) {\n    char buf[32];\n    StringUtil::itoa(buf, sizeof(buf), value);\n    const uint64_t added_size = appendToHeader(entry->value(), buf);\n    addSize(added_size);\n    return;\n  }\n  HeaderString new_key;\n  new_key.setCopy(key.get().c_str(), key.get().size());\n  HeaderString new_value;","target":0,"flaw_line_index":0,"hash":"af544343-b8c1-4e7e-b154-ce5ac572a713","idx":"986f3a46-764b-439c-bd61-32fe6f1afc68"}
{"func_before":"\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT\/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}","target":1,"flaw_line_index":0,"hash":"eaddeb30-1fcf-4a53-bbc7-756ab8655db5","idx":"4db41355-9245-4939-aec6-e8df8dbfdd71"}
{"func_before":"\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT\/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}","target":0,"flaw_line_index":0,"hash":"4a3f0aa1-5d0d-4122-90a4-672d34c2e553","idx":"1486eabc-aa24-4981-b0bb-5f1e680bd907"}
{"func_before":"\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\t\n\te = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n\tif (e) return e;\n\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\tgf_bs_write_int(bs, 0, 7);","target":1,"flaw_line_index":0,"hash":"c5b994fe-313b-4f95-92b8-6438447528fc","idx":"add57646-ed51-4232-af22-0451cbea35cb"}
{"func_before":"\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DEC3;\n\te = gf_isom_box_write_header(s, bs);\n\tif (ptr->cfg.is_ec3) s->type = GF_ISOM_BOX_TYPE_DAC3;\n\tif (e) return e;\n\n\te = gf_odf_ac3_cfg_write_bs(&ptr->cfg, bs);\n\tif (e) return e;\n\n\tif (ptr->cfg.atmos_ec3_ext || ptr->cfg.complexity_index_type) {\n\t\tgf_bs_write_int(bs, 0, 7);","target":0,"flaw_line_index":0,"hash":"f06c3254-cee3-4d21-9a8e-68a30c9d7b5b","idx":"1bb3eccb-e2ff-44b2-aabd-28ab3288f857"}
{"func_before":"\t\/* Seek left *\/\n\tint leftLimit, rightLimit;\n\tint i;\n\tint restoreAlphaBleding;\n\n\tif (border < 0) {\n\t\t\/* Refuse to fill to a non-solid border *\/\n\t\treturn;\n\t}\n\n\tleftLimit = (-1);\n\n\trestoreAlphaBleding = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;","target":1,"flaw_line_index":0,"hash":"1fbac53b-6920-4cbf-8fc3-572aa507f7e0","idx":"8f41b738-784f-4e00-9cbf-93a3408771ca"}
{"func_before":"\t\/* Seek left *\/\n\tint leftLimit, rightLimit;\n\tint i;\n\tint restoreAlphaBleding;\n\n\tif (border < 0 || color < 0) {\n\t\t\/* Refuse to fill to a non-solid border *\/\n\t\treturn;\n\t}\n\n\tif (!im->trueColor) {\n\t\tif ((color > (im->colorsTotal - 1)) || (border > (im->colorsTotal - 1))) {\n\t\t\treturn;\n\t\t}\n    }\n\n\tleftLimit = (-1);\n\n\trestoreAlphaBleding = im->alphaBlendingFlag;\n\tim->alphaBlendingFlag = 0;","target":0,"flaw_line_index":0,"hash":"a3baad55-126b-48c4-9dfc-2e5bda8793b3","idx":"19299e9c-495a-42ba-be58-3e40ce486cb8"}
{"func_before":"\n    PROCNAME(\"pixBlockconvTiled\");\n\n    if (!pix)\n        return (PIX *)ERROR_PTR(\"pix not defined\", procName, NULL);\n    if (wc < 0) wc = 0;\n    if (hc < 0) hc = 0;\n    pixGetDimensions(pix, &w, &h, &d);\n    if (w < 2 * wc + 3 || h < 2 * hc + 3) {\n        wc = L_MAX(0, L_MIN(wc, (w - 3) \/ 2));\n        hc = L_MAX(0, L_MIN(hc, (h - 3) \/ 2));\n        L_WARNING(\"kernel too large; reducing!\\n\", procName);\n        L_INFO(\"wc = %d, hc = %d\\n\", procName, wc, hc);\n    }\n    if (wc == 0 && hc == 0)   \/* no-op *\/\n        return pixCopy(NULL, pix);\n    if (nx <= 1 && ny <= 1)\n        return pixBlockconv(pix, wc, hc);\n\n        \/* Test to see if the tiles are too small.  The required\n         * condition is that the tile dimensions must be at least\n         * (wc + 2) x (hc + 2). *\/\n    xrat = w \/ nx;","target":1,"flaw_line_index":0,"hash":"cf4ece73-3972-4ead-acc6-3dd35965189c","idx":"81a7db1c-6ea2-44ca-a827-75235bbefc47"}
{"func_before":"\n    PROCNAME(\"pixBlockconvTiled\");\n\n    if (!pix)\n        return (PIX *)ERROR_PTR(\"pix not defined\", procName, NULL);\n    if (wc <= 0 || hc <= 0)   \/* no-op *\/\n        return pixCopy(NULL, pix);\n    if (nx <= 1 && ny <= 1)\n        return pixBlockconv(pix, wc, hc);\n    pixGetDimensions(pix, &w, &h, &d);\n    if (w < 2 * wc + 3 || h < 2 * hc + 3) {\n        L_ERROR(\"kernel is too large: w = %d, wc = %d, h = %d, hc = %d\\n\",\n                procName, w, wc, h, hc);\n        return pixCopy(NULL, pix);\n    }\n\n        \/* Test to see if the tiles are too small.  The required\n         * condition is that the tile dimensions must be at least\n         * (wc + 2) x (hc + 2). *\/\n    xrat = w \/ nx;","target":0,"flaw_line_index":0,"hash":"e39f9475-9313-40f1-8a05-cf63f861b0f8","idx":"de14b97a-ade9-4598-a2a2-7312860cfef3"}
{"func_before":"      reinterpret_cast<TfLiteDepthToSpaceParams*>(node->builtin_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,","target":1,"flaw_line_index":0,"hash":"e5b3f6c1-2b4e-4f30-98ad-739074ed7946","idx":"6f2b0247-90a2-4027-b2e6-5a48c3bd183a"}
{"func_before":"      reinterpret_cast<TfLiteDepthToSpaceParams*>(node->builtin_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4);\n\n  auto data_type = output->type;\n  TF_LITE_ENSURE(context,","target":0,"flaw_line_index":0,"hash":"0f168af6-b97d-4b82-bb6c-a06c970d9542","idx":"b82ae661-0ac8-4644-93a4-f63496dd8f94"}
{"func_before":"    s_poll_free(fds);\n    fds=NULL;\n#if 0\n    str_stats(); \/* main thread allocation tracking *\/\n#endif\n    log_flush(LOG_MODE_ERROR);\n    log_close(SINK_SYSLOG|SINK_OUTFILE);\n}","target":1,"flaw_line_index":0,"hash":"0872170b-69ea-432b-942f-c07b2b4e9b32","idx":"ce065c89-ba75-4a2e-95cd-dc19123a9ba5"}
{"func_before":"    s_poll_free(fds);\n    fds=NULL;\n#if 0\n    str_stats(); \/* main thread allocation tracking *\/\n#endif\n    log_flush(LOG_MODE_BUFFER); \/* no more logs *\/\n    log_close(SINK_SYSLOG|SINK_OUTFILE);\n}","target":0,"flaw_line_index":0,"hash":"630faa84-ff55-452a-9f34-c0044702be83","idx":"7c3e6da5-df78-44f2-a2ae-d108f8d56c44"}
{"func_before":"GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) \/\/ size is in longs not bytes.\n{\n\tif (ms)\n\t{\n\t\tint32_t nestsize = (int32_t)ms->nest_size[ms->nest_level];\n\t\tif (nestsize == 0 && ms->nest_level == 0)\n\t\t\tnestsize = ms->buffer_size_longs;\n\n\t\tif (size + 2 <= nestsize) return GPMF_OK;\n\t}","target":1,"flaw_line_index":0,"hash":"c37ca311-acc8-4ea5-9a7a-be7772f65f6d","idx":"b416718b-29fd-42c4-affc-b56de66626f6"}
{"func_before":"GPMF_ERR IsValidSize(GPMF_stream *ms, uint32_t size) \/\/ size is in longs not bytes.\n{\n\tif (ms)\n\t{\n\t\tuint32_t nestsize = (uint32_t)ms->nest_size[ms->nest_level];\n\t\tif (nestsize == 0 && ms->nest_level == 0)\n\t\t\tnestsize = ms->buffer_size_longs;\n\n\t\tif (size + 2 <= nestsize) return GPMF_OK;\n\t}","target":0,"flaw_line_index":0,"hash":"19456fd3-91b2-4e26-b428-b0fe96eb8a5b","idx":"bd10f2f1-0279-46bb-b4cc-3817aab552bc"}
{"func_before":"\t\t\t      GFP_KERNEL);\n\t\tif (!iov)\n\t\t\tgoto out;\n\t}\n\n\t\/*\n\t *      Save the user-mode address (verify_iovec will change the\n\t *      kernel msghdr to use the kernel address space)\n\t *\/\n\n\tuaddr = (__force void __user *)msg_sys->msg_name;\n\tuaddr_len = COMPAT_NAMELEN(msg);\n\tif (MSG_CMSG_COMPAT & flags) {\n\t\terr = verify_compat_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n\t} else\n\t\terr = verify_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n\tif (err < 0)\n\t\tgoto out_freeiov;\n\ttotal_len = err;\n\n\tcmsg_ptr = (unsigned long)msg_sys->msg_control;\n\tmsg_sys->msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\terr = (nosec ? sock_recvmsg_nosec : sock_recvmsg)(sock, msg_sys,\n\t\t\t\t\t\t\t  total_len, flags);","target":1,"flaw_line_index":0,"hash":"c00ba469-f092-420b-8198-2c43cbc4b4fe","idx":"089f7263-d498-4b72-bd72-9fa0fa314e3e"}
{"func_before":"\t\t\t      GFP_KERNEL);\n\t\tif (!iov)\n\t\t\tgoto out;\n\t}\n\n\t\/* Save the user-mode address (verify_iovec will change the\n\t * kernel msghdr to use the kernel address space)\n\t *\/\n\tuaddr = (__force void __user *)msg_sys->msg_name;\n\tuaddr_len = COMPAT_NAMELEN(msg);\n\tif (MSG_CMSG_COMPAT & flags)\n\t\terr = verify_compat_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n\telse\n\t\terr = verify_iovec(msg_sys, iov, &addr, VERIFY_WRITE);\n\tif (err < 0)\n\t\tgoto out_freeiov;\n\ttotal_len = err;\n\n\tcmsg_ptr = (unsigned long)msg_sys->msg_control;\n\tmsg_sys->msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);\n\n\t\/* We assume all kernel code knows the size of sockaddr_storage *\/\n\tmsg_sys->msg_namelen = 0;\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\terr = (nosec ? sock_recvmsg_nosec : sock_recvmsg)(sock, msg_sys,\n\t\t\t\t\t\t\t  total_len, flags);","target":0,"flaw_line_index":0,"hash":"1a6955bd-3eb6-4bd8-a56c-3174a521850d","idx":"fca0db50-b952-443f-8b58-f69c733d05bc"}
{"func_before":"static inline int fpregs_state_valid(struct fpu *fpu, unsigned int cpu)\n{\n\treturn fpu == this_cpu_read_stable(fpu_fpregs_owner_ctx) && cpu == fpu->last_cpu;\n}","target":1,"flaw_line_index":0,"hash":"7362bdc8-1770-4bea-9843-2809b0f3d654","idx":"2261ecbc-7d0d-4ef9-b6db-1b8044b8c983"}
{"func_before":"static inline int fpregs_state_valid(struct fpu *fpu, unsigned int cpu)\n{\n\treturn fpu == this_cpu_read(fpu_fpregs_owner_ctx) && cpu == fpu->last_cpu;\n}","target":0,"flaw_line_index":0,"hash":"55dd65c9-c303-431a-8b33-981a0005bdf6","idx":"f8fa8a0b-6720-44a1-b46c-bbb5a434d850"}
{"func_before":"void ep_map(ep_t p, const uint8_t *msg, int len) {\n\tep_map_dst(p, msg, len, (const uint8_t *)\"RELIC\", 5);\n}","target":1,"flaw_line_index":0,"hash":"2af1b305-5ae1-45c0-9413-960fdd4f7269","idx":"bcb0ffbd-3449-4cb9-a230-500c4d678078"}
{"func_before":"void ep_map(ep_t p, const uint8_t *msg, size_t len) {\n\tep_map_dst(p, msg, len, (const uint8_t *)\"RELIC\", 5);\n}","target":0,"flaw_line_index":0,"hash":"eeac7789-e6ac-468c-8410-dc21dc999e05","idx":"d24c19f2-862e-4e98-aff7-422fedadc2d3"}
{"func_before":"unserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)\n{\n    int\t\ti;\n    u_entry_T\t*uep;\n    char_u\t**array;\n    char_u\t*line;\n    int\t\tline_len;\n\n    uep = (u_entry_T *)U_ALLOC_LINE(sizeof(u_entry_T));\n    if (uep == NULL)\n    uep->ue_bot = undo_read_4c(bi);\n    uep->ue_lcount = undo_read_4c(bi);\n    uep->ue_size = undo_read_4c(bi);\n    if (uep->ue_size > 0)\n    {\n\tarray = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);\n\tif (array == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tvim_memset(array, 0, sizeof(char_u *) * uep->ue_size);\n    }\n    else\n\tarray = NULL;\n    uep->ue_array = array;\n\n    for (i = 0; i < uep->ue_size; ++i)\n    {\n\tline_len = undo_read_4c(bi);","target":1,"flaw_line_index":0,"hash":"3934c1a7-9393-4a3e-8f1f-27fa12ec2518","idx":"d472a369-e9b7-4227-9707-f468aba66d47"}
{"func_before":"unserialize_uep(bufinfo_T *bi, int *error, char_u *file_name)\n{\n    int\t\ti;\n    u_entry_T\t*uep;\n    char_u\t**array = NULL;\n    char_u\t*line;\n    int\t\tline_len;\n\n    uep = (u_entry_T *)U_ALLOC_LINE(sizeof(u_entry_T));\n    if (uep == NULL)\n    uep->ue_bot = undo_read_4c(bi);\n    uep->ue_lcount = undo_read_4c(bi);\n    uep->ue_size = undo_read_4c(bi);\n    if (uep->ue_size > 0)\n    {\n\tif (uep->ue_size < LONG_MAX \/ (int)sizeof(char_u *))\n\t    array = (char_u **)U_ALLOC_LINE(sizeof(char_u *) * uep->ue_size);\n\tif (array == NULL)\n\t{\n\t    *error = TRUE;\n\t    return uep;\n\t}\n\tvim_memset(array, 0, sizeof(char_u *) * uep->ue_size);\n    }\n    uep->ue_array = array;\n\n    for (i = 0; i < uep->ue_size; ++i)\n    {\n\tline_len = undo_read_4c(bi);","target":0,"flaw_line_index":0,"hash":"e6b439a5-c2fd-440f-a789-ed5218fb3003","idx":"d0194d5f-400b-47cd-bb14-c0915513335a"}
{"func_before":"void bpf_map_inc(struct bpf_map *map, bool uref)\n{\n\tatomic_inc(&map->refcnt);\n\tif (uref)\n\t\tatomic_inc(&map->usercnt);\n}","target":1,"flaw_line_index":0,"hash":"f996c440-7035-4d50-99f3-854dada801ed","idx":"de6f5172-8e6b-45ca-bacf-51ee50128ded"}
{"func_before":"struct bpf_map *bpf_map_inc(struct bpf_map *map, bool uref)\n{\n\tif (atomic_inc_return(&map->refcnt) > BPF_MAX_REFCNT) {\n\t\tatomic_dec(&map->refcnt);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\tif (uref)\n\t\tatomic_inc(&map->usercnt);\n\treturn map;\n}","target":0,"flaw_line_index":0,"hash":"516cae53-3bfc-476b-b73f-9de6a256cbfa","idx":"d0ab7319-3486-4147-9c1f-a57586f52ff0"}
{"func_before":"\tcurswant = curbuf->b_visual.vi_curswant;\n    }\n    lnum = rex.lnum + rex.reg_firstlnum;\n    if (lnum < top.lnum || lnum > bot.lnum)\n\treturn FALSE;\n\n    if (mode == 'v')\n    {\n\tcol = (colnr_T)(rex.input - rex.line);\n\tif ((lnum == top.lnum && col < top.col)\n\t\t|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))\n\t    return FALSE;\n    }\n    else if (mode == Ctrl_V)\n\t    start = start2;\n\tif (end2 > end)\n\t    end = end2;\n\tif (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)\n\t    end = MAXCOL;\n\tcols = win_linetabsize(wp, rex.line, (colnr_T)(rex.input - rex.line));\n\tif (cols < start || cols > end - (*p_sel == 'e'))\n\t    return FALSE;\n    }\n    return TRUE;\n}","target":1,"flaw_line_index":0,"hash":"ca1dd12b-53e6-4c8f-9780-0af5584c0081","idx":"f04d3609-d6e2-4372-a124-f2ccb17689e1"}
{"func_before":"    }\n    lnum = rex.lnum + rex.reg_firstlnum;\n    if (lnum < top.lnum || lnum > bot.lnum)\n\treturn FALSE;\n\n    col = (colnr_T)(rex.input - rex.line);\n    if (mode == 'v')\n    {\n\tif ((lnum == top.lnum && col < top.col)\n\t\t|| (lnum == bot.lnum && col >= bot.col + (*p_sel != 'e')))\n\t    return FALSE;\n    }\n    else if (mode == Ctrl_V)\n\t    start = start2;\n\tif (end2 > end)\n\t    end = end2;\n\tif (top.col == MAXCOL || bot.col == MAXCOL || curswant == MAXCOL)\n\t    end = MAXCOL;\n\n\t\/\/ getvvcol() flushes rex.line, need to get it again\n\trex.line = reg_getline(rex.lnum);\n\trex.input = rex.line + col;\n\n\tcols = win_linetabsize(wp, rex.line, col);\n\tif (cols < start || cols > end - (*p_sel == 'e'))\n\t    return FALSE;\n    }\n    return TRUE;\n}","target":0,"flaw_line_index":0,"hash":"c8a0ed3f-d30e-4dd3-89ec-72ef24007c81","idx":"e96e5776-9c73-49ee-943f-f55a935a58c9"}
{"func_before":"\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\n\tsplit_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;\n\tsplit_flag |= EXT4_EXT_MARK_UNINIT2;\n\n\tflags |= EXT4_GET_BLOCKS_PRE_IO;\n\treturn ext4_split_extent(handle, inode, path, map, split_flag, flags);\n}","target":1,"flaw_line_index":0,"hash":"e99b3a37-5e20-4124-acce-fdfaebdc27ed","idx":"f9f3a8f0-d6c3-4cc4-9f54-735e83e40e9e"}
{"func_before":"\tee_block = le32_to_cpu(ex->ee_block);\n\tee_len = ext4_ext_get_actual_len(ex);\n\n\tsplit_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0;\n\tsplit_flag |= EXT4_EXT_MARK_UNINIT2;\n\tif (flags & EXT4_GET_BLOCKS_CONVERT)\n\t\tsplit_flag |= EXT4_EXT_DATA_VALID2;\n\tflags |= EXT4_GET_BLOCKS_PRE_IO;\n\treturn ext4_split_extent(handle, inode, path, map, split_flag, flags);\n}","target":0,"flaw_line_index":0,"hash":"70eeb376-2235-46e8-98d5-a608e58a37ae","idx":"164153bc-f47a-4740-8f30-ccf47ce61e60"}
{"func_before":"\t}\n\n\tif (unlikely(error_code & PF_RSVD))\n\t\tpgtable_bad(regs, error_code, address);\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n\n\t\/*\n\t * If we're in an interrupt, have no user context or are running\n\t * in an atomic region then we must not take the fault:\n\t *\/\n\t * likely that the page will be found in page cache at that point.\n\t *\/\n\tif (flags & FAULT_FLAG_ALLOW_RETRY) {\n\t\tif (fault & VM_FAULT_MAJOR) {\n\t\t\ttsk->maj_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n\t\t\t\t      regs, address);\n\t\t} else {\n\t\t\ttsk->min_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n\t\t\t\t      regs, address);\n\t\t}\n\t\tif (fault & VM_FAULT_RETRY) {\n\t\t\t\/* Clear FAULT_FLAG_ALLOW_RETRY to avoid any risk\n\t\t\t * of starvation. *\/","target":1,"flaw_line_index":0,"hash":"f08d8bef-9ff4-4df2-b60d-40bbaa77a01b","idx":"39090216-c7cc-4c08-8049-a8adf9b082ad"}
{"func_before":"\t}\n\n\tif (unlikely(error_code & PF_RSVD))\n\t\tpgtable_bad(regs, error_code, address);\n\n\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, regs, address);\n\n\t\/*\n\t * If we're in an interrupt, have no user context or are running\n\t * in an atomic region then we must not take the fault:\n\t *\/\n\t * likely that the page will be found in page cache at that point.\n\t *\/\n\tif (flags & FAULT_FLAG_ALLOW_RETRY) {\n\t\tif (fault & VM_FAULT_MAJOR) {\n\t\t\ttsk->maj_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1,\n\t\t\t\t      regs, address);\n\t\t} else {\n\t\t\ttsk->min_flt++;\n\t\t\tperf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1,\n\t\t\t\t      regs, address);\n\t\t}\n\t\tif (fault & VM_FAULT_RETRY) {\n\t\t\t\/* Clear FAULT_FLAG_ALLOW_RETRY to avoid any risk\n\t\t\t * of starvation. *\/","target":0,"flaw_line_index":0,"hash":"b5357f34-3060-4e9a-abd0-18004f23bfbe","idx":"df278df9-9f67-4eb3-9117-7b57470190a3"}
{"func_before":"   error_t error;\n   uint16_t status;\n   uint16_t value;\n\n   \/\/Read interrupt status register\n   status = enc28j60ReadReg(interface, ENC28J60_REG_EIR);\n\n   \/\/Check whether the link state has changed\n   if((status & EIR_LINKIF) != 0)\n   {\n      \/\/Clear PHY interrupts flags\n      enc28j60ReadPhyReg(interface, ENC28J60_PHY_REG_PHIR);\n      \/\/Clear interrupt flag\n      enc28j60ClearBit(interface, ENC28J60_REG_EIR, EIR_LINKIF);\n      \/\/Read PHY status register\n      value = enc28j60ReadPhyReg(interface, ENC28J60_PHY_REG_PHSTAT2);\n\n      \/\/Check link state\n      if((value & PHSTAT2_LSTAT) != 0)\n      {\n         \/\/Link speed\n         interface->linkSpeed = NIC_LINK_SPEED_10MBPS;\n\n#if (ENC28J60_FULL_DUPLEX_SUPPORT == ENABLED)\n      \/\/Process link state change event\n      nicNotifyLinkChange(interface);\n   }\n\n   \/\/Check whether a packet has been received?\n   if((status & EIR_PKTIF) != 0)\n   {\n      \/\/Clear interrupt flag\n      enc28j60ClearBit(interface, ENC28J60_REG_EIR, EIR_PKTIF);\n\n      \/\/Process all pending packets\n      do\n      {\n         \/\/Read incoming packet\n         \/\/No more data in the receive buffer?\n      } while(error != ERROR_BUFFER_EMPTY);\n   }\n\n   \/\/Re-enable LINKIE and PKTIE interrupts\n   enc28j60SetBit(interface, ENC28J60_REG_EIE, EIE_LINKIE | EIE_PKTIE);\n}","target":1,"flaw_line_index":0,"hash":"6c321545-3c6d-4c23-92d6-e59d5fbeffa4","idx":"f3368ebe-cc3c-4d40-b32f-51a3afc86339"}
{"func_before":"   error_t error;\n   uint16_t status;\n   uint16_t value;\n\n   \/\/Read interrupt status register\n   status = enc28j60ReadReg(interface, ENC28J60_EIR);\n\n   \/\/Check whether the link state has changed\n   if((status & ENC28J60_EIR_LINKIF) != 0)\n   {\n      \/\/Clear PHY interrupts flags\n      enc28j60ReadPhyReg(interface, ENC28J60_PHIR);\n      \/\/Clear interrupt flag\n      enc28j60ClearBit(interface, ENC28J60_EIR, ENC28J60_EIR_LINKIF);\n      \/\/Read PHY status register\n      value = enc28j60ReadPhyReg(interface, ENC28J60_PHSTAT2);\n\n      \/\/Check link state\n      if((value & ENC28J60_PHSTAT2_LSTAT) != 0)\n      {\n         \/\/Link speed\n         interface->linkSpeed = NIC_LINK_SPEED_10MBPS;\n\n#if (ENC28J60_FULL_DUPLEX_SUPPORT == ENABLED)\n      \/\/Process link state change event\n      nicNotifyLinkChange(interface);\n   }\n\n   \/\/Check whether a packet has been received?\n   if(enc28j60ReadReg(interface, ENC28J60_EPKTCNT) != 0)\n   {\n      \/\/Clear interrupt flag\n      enc28j60ClearBit(interface, ENC28J60_EIR, ENC28J60_EIR_PKTIF);\n\n      \/\/Process all pending packets\n      do\n      {\n         \/\/Read incoming packet\n         \/\/No more data in the receive buffer?\n      } while(error != ERROR_BUFFER_EMPTY);\n   }\n\n   \/\/Re-enable LINKIE and PKTIE interrupts\n   enc28j60SetBit(interface, ENC28J60_EIE, ENC28J60_EIE_LINKIE |\n      ENC28J60_EIE_PKTIE);\n}","target":0,"flaw_line_index":0,"hash":"50cdb522-2b4a-4f9b-86f7-5078897f1498","idx":"04334ce0-3e27-4c52-b2ac-35a626bafd19"}
{"func_before":"\n   \/\/Configure RMII_CRS_DV (PB7)\n   PORTB.PMR.BIT.B7 = 1;\n   MPC.PB7PFS.BYTE = 0x12;\n\n#elif defined(USE_RSK_RX63N)\n   \/\/Select MII interface mode\n   MPC.PFENET.BIT.PHYMODE = 1;\n\n   \/\/Configure ET_MDIO (P71)\n   PORT7.PMR.BIT.B1 = 1;","target":1,"flaw_line_index":0,"hash":"3755507e-b2b0-45a5-933a-28f5eeb1779f","idx":"9d713268-d8fa-4035-963f-eee7d84fb444"}
{"func_before":"\n   \/\/Configure RMII_CRS_DV (PB7)\n   PORTB.PMR.BIT.B7 = 1;\n   MPC.PB7PFS.BYTE = 0x12;\n\n#elif defined(USE_RSK_RX63N) || defined(USE_RSK_RX63N_256K)\n   \/\/Select MII interface mode\n   MPC.PFENET.BIT.PHYMODE = 1;\n\n   \/\/Configure ET_MDIO (P71)\n   PORT7.PMR.BIT.B1 = 1;","target":0,"flaw_line_index":0,"hash":"05e77d6a-aee6-4028-af50-6571eaa3541a","idx":"32d06502-43f4-4442-bf75-d9f2851c8edf"}
{"func_before":"exif_data_load_data_content (ExifData *data, ExifIfd ifd,\n\t\t\t     const unsigned char *d,\n\t\t\t     unsigned int ds, unsigned int offset, unsigned int recursion_depth)\n{\n\tExifLong o, thumbnail_offset = 0, thumbnail_length = 0;\n\tExifShort n;\n\tExifEntry *entry;\n\tunsigned int i;\n\n\t\/* check for valid ExifIfd enum range *\/\n\tif ((((int)ifd) < 0) || ( ((int)ifd) >= EXIF_IFD_COUNT))\n\t  return;\n\n\tif (recursion_depth > 12) {\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\",\n\t\t\t  \"Deep recursion detected!\");\n\t\treturn;\n\t}\n\n\t\/* Read the number of entries *\/\n\tif ((offset + 2 < offset) || (offset + 2 < 2) || (offset + 2 > ds)) {\n\t\t\t\t  \"Sub-IFD entry 0x%x ('%s') at %u.\", tag,\n\t\t\t\t  exif_tag_get_name(tag), o);\n\t\t\tswitch (tag) {\n\t\t\tcase EXIF_TAG_EXIF_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_EXIF);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_EXIF, d, ds, o, recursion_depth + 1);\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_GPS_INFO_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_GPS);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_GPS, d, ds, o, recursion_depth + 1);\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_INTEROPERABILITY_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_INTEROPERABILITY);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_INTEROPERABILITY, d, ds, o, recursion_depth + 1);\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\t\tthumbnail_offset = o;\n\t\t\t\tif (thumbnail_offset && thumbnail_length)\n\t\t\t\t\texif_data_load_data_thumbnail (data, d,","target":1,"flaw_line_index":0,"hash":"0aac0806-5ca6-470b-95da-de1dc5eda7d3","idx":"be330a64-d920-4db9-bbbe-c517e25e3fc0"}
{"func_before":"exif_data_load_data_content (ExifData *data, ExifIfd ifd,\n\t\t\t     const unsigned char *d,\n\t\t\t     unsigned int ds, unsigned int offset, unsigned int recursion_cost)\n{\n\tExifLong o, thumbnail_offset = 0, thumbnail_length = 0;\n\tExifShort n;\n\tExifEntry *entry;\n\tunsigned int i;\n\n\t\/* check for valid ExifIfd enum range *\/\n\tif ((((int)ifd) < 0) || ( ((int)ifd) >= EXIF_IFD_COUNT))\n\t  return;\n\n\tif (recursion_cost > 170) {\n\t\t\/*\n\t\t * recursion_cost is a logarithmic-scale indicator of how expensive this\n\t\t * recursive call might end up being. It is an indicator of the depth of\n\t\t * recursion as well as the potential for worst-case future recursive\n\t\t * calls. Since it's difficult to tell ahead of time how often recursion\n\t\t * will occur, this assumes the worst by assuming every tag could end up\n\t\t * causing recursion.\n\t\t * The value of 170 was chosen to limit typical EXIF structures to a\n\t\t * recursive depth of about 6, but pathological ones (those with very\n\t\t * many tags) to only 2.\n\t\t *\/\n\t\texif_log (data->priv->log, EXIF_LOG_CODE_CORRUPT_DATA, \"ExifData\",\n\t\t\t  \"Deep\/expensive recursion detected!\");\n\t\treturn;\n\t}\n\n\t\/* Read the number of entries *\/\n\tif ((offset + 2 < offset) || (offset + 2 < 2) || (offset + 2 > ds)) {\n\t\t\t\t  \"Sub-IFD entry 0x%x ('%s') at %u.\", tag,\n\t\t\t\t  exif_tag_get_name(tag), o);\n\t\t\tswitch (tag) {\n\t\t\tcase EXIF_TAG_EXIF_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_EXIF);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_EXIF, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_GPS_INFO_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_GPS);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_GPS, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_INTEROPERABILITY_IFD_POINTER:\n\t\t\t\tCHECK_REC (EXIF_IFD_INTEROPERABILITY);\n\t\t\t\texif_data_load_data_content (data, EXIF_IFD_INTEROPERABILITY, d, ds, o,\n\t\t\t\t\trecursion_cost + level_cost(n));\n\t\t\t\tbreak;\n\t\t\tcase EXIF_TAG_JPEG_INTERCHANGE_FORMAT:\n\t\t\t\tthumbnail_offset = o;\n\t\t\t\tif (thumbnail_offset && thumbnail_length)\n\t\t\t\t\texif_data_load_data_thumbnail (data, d,","target":0,"flaw_line_index":0,"hash":"107da521-585d-4900-8568-12f33917f9d0","idx":"24f47c4d-7edc-4c37-8439-e256e4959dc1"}
{"func_before":"\toffset += skb->csum_offset;\n\t*(__sum16 *)(skb->data + offset) = csum_fold(csum);\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\t\/* Check if there is enough headroom to insert fragment header. *\/\n\tif ((skb_headroom(skb) < frag_hdr_sz) &&\n\t    pskb_expand_head(skb, frag_hdr_sz, 0, GFP_ATOMIC))\n\t\tgoto out;\n\n\t\/* Find the unfragmentable header and shift it left by frag_hdr_sz\n\t * bytes to insert fragment header.","target":1,"flaw_line_index":0,"hash":"a40c453a-89b2-4afe-8d3f-bf22ede2c02b","idx":"5f12406d-80d5-4688-85c6-573feb0dcb12"}
{"func_before":"\toffset += skb->csum_offset;\n\t*(__sum16 *)(skb->data + offset) = csum_fold(csum);\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\t\/* Check if there is enough headroom to insert fragment header. *\/\n\tif ((skb_mac_header(skb) < skb->head + frag_hdr_sz) &&\n\t    pskb_expand_head(skb, frag_hdr_sz, 0, GFP_ATOMIC))\n\t\tgoto out;\n\n\t\/* Find the unfragmentable header and shift it left by frag_hdr_sz\n\t * bytes to insert fragment header.","target":0,"flaw_line_index":0,"hash":"a4065ed2-9848-4c4e-a384-33d3c9c3180e","idx":"01774f53-e952-4e8f-986b-b9b694ed14e8"}
{"func_before":"GF_Err gf_isom_set_extraction_slc(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex, const GF_SLConfig *slConfig)\n{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig **slc;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\t\/\/we must be sure we are not using a remote ESD\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tif (((GF_MPEGSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tif (((GF_MPEGAudioSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tif (((GF_MPEGVisualSampleEntryBox *)entry)->esd->desc->slConfig->predefined != SLPredef_MP4) return GF_BAD_PARAM;\n\t\tslc = & ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}","target":1,"flaw_line_index":0,"hash":"89f06078-b27d-410c-a1e3-52fb75874ba2","idx":"d7bdcaa5-e333-4509-9e9e-ab44d85fdaa5"}
{"func_before":"{\n\tGF_TrackBox *trak;\n\tGF_SampleEntryBox *entry;\n\tGF_Err e;\n\tGF_SLConfig **slc;\n\tGF_ESDBox *esds;\n\n\ttrak = gf_isom_get_track_from_file(the_file, trackNumber);\n\tif (!trak) return GF_BAD_PARAM;\n\n\te = Media_GetSampleDesc(trak->Media, StreamDescriptionIndex, &entry, NULL);\n\tif (e) return e;\n\n\t\/\/we must be sure we are not using a remote ESD\n\tswitch (entry->type) {\n\tcase GF_ISOM_BOX_TYPE_MP4S:\n\t\tesds = ((GF_MPEGSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4A:\n\t\tesds = ((GF_MPEGAudioSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGAudioSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_MP4V:\n\t\tesds = ((GF_MPEGVisualSampleEntryBox *)entry)->esd;\n\t\tif (!esds || !esds->desc || !esds->desc->slConfig || (esds->desc->slConfig->predefined != SLPredef_MP4))\n\t\t\treturn GF_ISOM_INVALID_FILE;\n\t\tslc = & ((GF_MPEGVisualSampleEntryBox *)entry)->slc;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}","target":0,"flaw_line_index":0,"hash":"e7eb3e9c-d538-4784-a968-f3c8da2f2b48","idx":"d1fb2ac5-8901-4a5b-9337-2982d1a1d516"}
{"func_before":"static int udp_push_pending_frames(struct sock *sk)\n{\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi4 *fl4 = &inet->cork.fl.u.ip4;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\n\tskb = ip_finish_skb(sk, fl4);\n\tif (!skb)\n\t\tgoto out;\n\n\terr = udp_send_skb(skb, fl4);\n\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}","target":1,"flaw_line_index":0,"hash":"523c9187-c6cc-4b5f-847c-833420c32b50","idx":"99b95227-d7bc-41ef-9b40-ed80edfa07c1"}
{"func_before":"int udp_push_pending_frames(struct sock *sk)\n{\n\tstruct udp_sock  *up = udp_sk(sk);\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct flowi4 *fl4 = &inet->cork.fl.u.ip4;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\n\tskb = ip_finish_skb(sk, fl4);\n\tif (!skb)\n\t\tgoto out;\n\n\terr = udp_send_skb(skb, fl4);\n\nout:\n\tup->len = 0;\n\tup->pending = 0;\n\treturn err;\n}","target":0,"flaw_line_index":0,"hash":"b7e55605-53df-4bee-b202-c548224ba537","idx":"e2721dd4-9b0a-4ab6-ac23-180dc430cc0e"}
{"func_before":"\n            WavpackLittleEndianToNative ((WavpackHeader *) buffer, WavpackHeaderFormat);\n#endif\n\n            if (meta_bc == 4) {\n                if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff) || *dp++ != ((csum >> 16) & 0xff) || *dp++ != ((csum >> 24) & 0xff))\n                    return FALSE;\n            }\n            else {\n                csum ^= csum >> 16;\n\n                if (*dp++ != (csum & 0xff) || *dp++ != ((csum >> 8) & 0xff))\n                    return FALSE;\n            }\n\n            checksum_passed++;\n        }","target":1,"flaw_line_index":0,"hash":"3d2d880e-b278-4843-b6c1-7d4d2a86b4a3","idx":"3a90e63e-9d2d-4901-ab2e-7bcec8f514c0"}
{"func_before":"\n            WavpackLittleEndianToNative ((WavpackHeader *) buffer, WavpackHeaderFormat);\n#endif\n\n            if (meta_bc == 4) {\n                if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff) || dp[2] != ((csum >> 16) & 0xff) || dp[3] != ((csum >> 24) & 0xff))\n                    return FALSE;\n            }\n            else {\n                csum ^= csum >> 16;\n\n                if (*dp != (csum & 0xff) || dp[1] != ((csum >> 8) & 0xff))\n                    return FALSE;\n            }\n\n            checksum_passed++;\n        }","target":0,"flaw_line_index":0,"hash":"bb43023f-1aeb-4773-95c0-0a03e4774a38","idx":"8aaa91fd-91ee-4965-98ac-9b2db1791051"}
{"func_before":"\tc2 = PTR2CHAR(str);\n\n\t\/\/ Found match\n\tif (vim_tolower(c1) == vim_tolower(c2))\n\t{\n\t    int_u\trecursiveMatches[MAX_FUZZY_MATCHES];\n\t    int\t\trecursiveScore = 0;\n\t    char_u\t*next_char;\n\n\t    \/\/ Supplied matches buffer was too short\n\t    if (nextMatch >= maxMatches)\n\t\treturn 0;\n\n\t    \/\/ \"Copy-on-Write\" srcMatches into matches\n\t    if (first_match && srcMatches)\n\t    {\n\t\tmemcpy(matches, srcMatches, nextMatch * sizeof(srcMatches[0]));\n\t\tfirst_match = FALSE;\n\t    }\n\n\t    \/\/ Recursive call that \"skips\" this match\n\t    if (has_mbyte)\n\t\tnext_char = str + (*mb_ptr2len)(str);\n\t    else\n\t\tnext_char = str + 1;\n\t    if (fuzzy_match_recursive(fuzpat, next_char, strIdx + 1,\n\t\t\t&recursiveScore, strBegin, strLen, matches,\n\t\t\trecursiveMatches,\n\t\t\tARRAY_LENGTH(recursiveMatches),\n\t\t\tnextMatch, recursionCount))","target":1,"flaw_line_index":0,"hash":"6f63d547-b21c-4699-8168-11485353d412","idx":"24ac7d4a-b6f2-4b49-b83c-fd63a71bf998"}
{"func_before":"\tc1 = PTR2CHAR(fuzpat);\n\tc2 = PTR2CHAR(str);\n\n\t\/\/ Found match\n\tif (vim_tolower(c1) == vim_tolower(c2))\n\t{\n\t    \/\/ Supplied matches buffer was too short\n\t    if (nextMatch >= maxMatches)\n\t\treturn 0;\n\n\t    int\t\trecursiveScore = 0;\n\t    int_u\trecursiveMatches[MAX_FUZZY_MATCHES];\n\t    CLEAR_FIELD(recursiveMatches);\n\n\t    \/\/ \"Copy-on-Write\" srcMatches into matches\n\t    if (first_match && srcMatches)\n\t    {\n\t\tmemcpy(matches, srcMatches, nextMatch * sizeof(srcMatches[0]));\n\t\tfirst_match = FALSE;\n\t    }\n\n\t    \/\/ Recursive call that \"skips\" this match\n\t    char_u *next_char = str + (has_mbyte ? (*mb_ptr2len)(str) : 1);\n\t    if (fuzzy_match_recursive(fuzpat, next_char, strIdx + 1,\n\t\t\t&recursiveScore, strBegin, strLen, matches,\n\t\t\trecursiveMatches,\n\t\t\tARRAY_LENGTH(recursiveMatches),\n\t\t\tnextMatch, recursionCount))","target":0,"flaw_line_index":0,"hash":"0e9336ce-edfb-41b6-a5ce-a6e285b97a44","idx":"5d80bcac-b106-4fed-823a-e2bce2faf5f5"}
{"func_before":"    fi->readx(&ih, sizeof(ih));\n    \/\/ FIXME: should add more checks for the values in 'ih'\n    unsigned const imagesize = ih.imagesize;\n    unsigned const entry = ih.entry;\n    unsigned const relocsize = ih.relocsize;\n    if (!imagesize || file_size <= imagesize || file_size <= entry || file_size <= relocsize) {\n        printWarn(getName(), \"bad header; imagesize=%#x  entry=%#x  relocsize=%#x\", imagesize,\n                  entry, relocsize);\n        return 0;\n    }\n","target":1,"flaw_line_index":0,"hash":"24373c7f-d8fb-4a57-8f1c-7fdc384b4556","idx":"77674d1b-fa27-480d-a3b9-6fe6debf200a"}
{"func_before":"    fi->readx(&ih, sizeof(ih));\n    \/\/ FIXME: should add more checks for the values in 'ih'\n    unsigned const imagesize = ih.imagesize;\n    unsigned const entry = ih.entry;\n    unsigned const relocsize = ih.relocsize;\n    if (imagesize < sizeof(ih) || entry < sizeof(ih) || file_size <= imagesize ||\n        file_size <= entry || file_size <= relocsize) {\n        printWarn(getName(), \"bad header; imagesize=%#x  entry=%#x  relocsize=%#x\", imagesize,\n                  entry, relocsize);\n        return 0;\n    }\n","target":0,"flaw_line_index":0,"hash":"2175319b-8624-4217-aa68-75878761322a","idx":"8162f991-690e-44ac-a96e-5641b2b690b0"}
{"func_before":"\tif (ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path);\n}","target":1,"flaw_line_index":0,"hash":"0d44cd89-e508-4985-95cb-90ab2dd77180","idx":"eb800ae5-f469-4314-8a2b-36be1d741c8e"}
{"func_before":"\tif (ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, rootfs);\n}","target":0,"flaw_line_index":0,"hash":"a1f6aa3c-b201-42a3-8f6c-dff822eb759b","idx":"4b077882-fd56-48ec-be91-ef55367afb56"}
{"func_before":"eth_addr_resolve(hashether_t *tp) {\n    ether_t      *eth;\n    hashmanuf_t *manuf_value;\n    const guint8 *addr = tp->addr;\n\n    if ( (eth = get_ethbyaddr(addr)) != NULL) {\n        (void) g_strlcpy(tp->resolved_name, eth->name, MAXNAMELEN);\n        tp->status = HASHETHER_STATUS_RESOLVED_NAME;\n        return tp;\n                return tp;\n            }\n        } while (mask--);\n\n        \/* Now try looking in the manufacturer table. *\/\n        manuf_value = manuf_name_lookup(addr);\n        if ((manuf_value != NULL) && (manuf_value->status != HASHETHER_STATUS_UNRESOLVED)) {\n            snprintf(tp->resolved_name, MAXNAMELEN, \"%s_%02x:%02x:%02x\",\n                    manuf_value->resolved_name, addr[3], addr[4], addr[5]);\n            tp->status = HASHETHER_STATUS_RESOLVED_DUMMY;\n            return tp;","target":1,"flaw_line_index":0,"hash":"7e12184e-1db8-48cf-b451-7a08c0638e77","idx":"e92bd674-7ace-4ab2-9b43-608c197c06e5"}
{"func_before":"eth_addr_resolve(hashether_t *tp) {\n    ether_t      *eth;\n    hashmanuf_t *manuf_value;\n    const guint8 *addr = tp->addr;\n    size_t addr_size = sizeof(tp->addr);\n\n    if ( (eth = get_ethbyaddr(addr)) != NULL) {\n        (void) g_strlcpy(tp->resolved_name, eth->name, MAXNAMELEN);\n        tp->status = HASHETHER_STATUS_RESOLVED_NAME;\n        return tp;\n                return tp;\n            }\n        } while (mask--);\n\n        \/* Now try looking in the manufacturer table. *\/\n        manuf_value = manuf_name_lookup(addr, addr_size);\n        if ((manuf_value != NULL) && (manuf_value->status != HASHETHER_STATUS_UNRESOLVED)) {\n            snprintf(tp->resolved_name, MAXNAMELEN, \"%s_%02x:%02x:%02x\",\n                    manuf_value->resolved_name, addr[3], addr[4], addr[5]);\n            tp->status = HASHETHER_STATUS_RESOLVED_DUMMY;\n            return tp;","target":0,"flaw_line_index":0,"hash":"da81aa73-e96a-4511-8edb-2010dd7a061d","idx":"bf962316-272e-499f-ba3d-21a1d9be81ef"}
{"func_before":"\n    ++*arg;\n    len = get_env_len(arg);\n    if (len == 0)\n    {\n\tsemsg(_(e_syntax_error_at_str), start - 1);\n\treturn FAIL;\n    }\n\n    \/\/ include the '$' in the name, eval_env_var() expects it.\n    name = vim_strnsave(start, len + 1);","target":1,"flaw_line_index":0,"hash":"5e4ac423-602e-4b31-84eb-63b93807eaab","idx":"1addbf79-eb62-47ce-b2a6-c5ab7132a1eb"}
{"func_before":"\n    ++*arg;\n    len = get_env_len(arg);\n    if (len == 0)\n    {\n\tsemsg(_(e_syntax_error_at_str), start);\n\treturn FAIL;\n    }\n\n    \/\/ include the '$' in the name, eval_env_var() expects it.\n    name = vim_strnsave(start, len + 1);","target":0,"flaw_line_index":0,"hash":"c921d071-11cb-44a2-a83b-082f1e77599a","idx":"0cc68da2-c4db-487e-9370-67a4b7c4fc69"}
{"func_before":"            reslevel->num_precincts_y =\n                ff_jpeg2000_ceildivpow2(reslevel->coord[1][1],\n                                        reslevel->log2_prec_height) -\n                (reslevel->coord[1][0] >> reslevel->log2_prec_height);\n\n        reslevel->band = av_malloc_array(reslevel->nbands, sizeof(*reslevel->band));\n        if (!reslevel->band)\n            return AVERROR(ENOMEM);\n\n        for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) {\n            Jpeg2000Band *band = reslevel->band + bandno;\n            for (j = 0; j < 2; j++)\n                band->coord[0][j] = ff_jpeg2000_ceildiv(band->coord[0][j], dx);\n            for (j = 0; j < 2; j++)\n                band->coord[1][j] = ff_jpeg2000_ceildiv(band->coord[1][j], dy);\n\n            band->prec = av_malloc_array(reslevel->num_precincts_x *\n                                         (uint64_t)reslevel->num_precincts_y,\n                                         sizeof(*band->prec));\n            if (!band->prec)\n                return AVERROR(ENOMEM);\n","target":1,"flaw_line_index":0,"hash":"8b757cb3-42e2-4341-b7f9-59f22bab8f9d","idx":"062e9b79-a6bd-4904-8a5d-df12132aa4c9"}
{"func_before":"            reslevel->num_precincts_y =\n                ff_jpeg2000_ceildivpow2(reslevel->coord[1][1],\n                                        reslevel->log2_prec_height) -\n                (reslevel->coord[1][0] >> reslevel->log2_prec_height);\n\n        reslevel->band = av_calloc(reslevel->nbands, sizeof(*reslevel->band));\n        if (!reslevel->band)\n            return AVERROR(ENOMEM);\n\n        for (bandno = 0; bandno < reslevel->nbands; bandno++, gbandno++) {\n            Jpeg2000Band *band = reslevel->band + bandno;\n            for (j = 0; j < 2; j++)\n                band->coord[0][j] = ff_jpeg2000_ceildiv(band->coord[0][j], dx);\n            for (j = 0; j < 2; j++)\n                band->coord[1][j] = ff_jpeg2000_ceildiv(band->coord[1][j], dy);\n\n            band->prec = av_calloc(reslevel->num_precincts_x *\n                                         (uint64_t)reslevel->num_precincts_y,\n                                         sizeof(*band->prec));\n            if (!band->prec)\n                return AVERROR(ENOMEM);\n","target":0,"flaw_line_index":0,"hash":"42be3849-4257-4e44-aadb-73d50f25db9d","idx":"91b13642-5eac-499c-ad56-dede8a062316"}
{"func_before":"static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n{\n\tonig_free(*pre);\n}","target":1,"flaw_line_index":0,"hash":"132682e6-c90f-42d7-94d0-86d0ffe9aa88","idx":"dcec791b-9f28-426d-938e-49c81aca7a6d"}
{"func_before":"static void php_mb_regex_free_cache(php_mb_regex_t **pre)\n{\n\tonig_free(*pre);\n}","target":0,"flaw_line_index":0,"hash":"0fd94e2e-bd90-41c6-b75c-373a2ae0a0c9","idx":"b38c12c5-eeab-4f04-9efa-7c12218ec5ff"}
{"func_before":"void eb_read_bin(eb_t a, const uint8_t *bin, int len) {\n\tif (len == 1) {\n\t\tif (bin[0] == 0) {\n\t\t\teb_set_infty(a);\n\t\t\treturn;\n\t\t} else {","target":1,"flaw_line_index":0,"hash":"bf09db89-3679-4e2f-a52e-e1d646d8a441","idx":"fd529eb5-2d4a-4996-ab73-776943a5a9d1"}
{"func_before":"void eb_read_bin(eb_t a, const uint8_t *bin, size_t len) {\n\tif (len == 1) {\n\t\tif (bin[0] == 0) {\n\t\t\teb_set_infty(a);\n\t\t\treturn;\n\t\t} else {","target":0,"flaw_line_index":0,"hash":"3a25181b-8d48-41ed-af60-81f23e59bf7d","idx":"bde31526-fce9-4c60-9c45-36ea929fdea2"}
{"func_before":"void jas_matrix_divpow2(jas_matrix_t *matrix, int n)\n{\n\tint i;\n\tint j;\n\tjas_seqent_t *rowstart;\n\tint rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);","target":1,"flaw_line_index":0,"hash":"9b51eb9f-6351-4195-844c-a200cdacc4e9","idx":"8021316e-44c5-43ee-876d-c93f5943f371"}
{"func_before":"void jas_matrix_divpow2(jas_matrix_t *matrix, int n)\n{\n\tjas_matind_t i;\n\tjas_matind_t j;\n\tjas_seqent_t *rowstart;\n\tjas_matind_t rowstep;\n\tjas_seqent_t *data;\n\n\tif (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {\n\t\tassert(matrix->rows_);\n\t\trowstep = jas_matrix_rowstep(matrix);","target":0,"flaw_line_index":0,"hash":"37416a32-1ce7-46f1-a8f7-2d521f20ee46","idx":"f1f99879-ef6f-4a71-80e9-176e45016431"}
{"func_before":"\t\trt->rt_flags |= RTCF_NOTIFY;\n\n\tif (rtm->rtm_flags & RTM_F_LOOKUP_TABLE)\n\t\ttable_id = rt->rt_table_id;\n\n\tif (rtm->rtm_flags & RTM_F_FIB_MATCH)\n\t\terr = fib_dump_info(skb, NETLINK_CB(in_skb).portid,\n\t\t\t\t    nlh->nlmsg_seq, RTM_NEWROUTE, table_id,\n\t\t\t\t    rt->rt_type, res.prefix, res.prefixlen,\n\t\t\t\t    fl4.flowi4_tos, res.fi, 0);\n\telse\n\t\terr = rt_fill_info(net, dst, src, table_id, &fl4, skb,\n\t\t\t\t   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq);\n\tif (err < 0)\n\t\tgoto errout_free;\n\n\trcu_read_unlock();\n","target":1,"flaw_line_index":0,"hash":"dc886a4d-7def-4247-afc3-92713026ee0d","idx":"60532a22-fb06-4d86-aae9-8313e48077a9"}
{"func_before":"\t\trt->rt_flags |= RTCF_NOTIFY;\n\n\tif (rtm->rtm_flags & RTM_F_LOOKUP_TABLE)\n\t\ttable_id = rt->rt_table_id;\n\n\tif (rtm->rtm_flags & RTM_F_FIB_MATCH) {\n\t\tif (!res.fi) {\n\t\t\terr = fib_props[res.type].error;\n\t\t\tif (!err)\n\t\t\t\terr = -EHOSTUNREACH;\n\t\t\tgoto errout_free;\n\t\t}\n\t\terr = fib_dump_info(skb, NETLINK_CB(in_skb).portid,\n\t\t\t\t    nlh->nlmsg_seq, RTM_NEWROUTE, table_id,\n\t\t\t\t    rt->rt_type, res.prefix, res.prefixlen,\n\t\t\t\t    fl4.flowi4_tos, res.fi, 0);\n\t} else {\n\t\terr = rt_fill_info(net, dst, src, table_id, &fl4, skb,\n\t\t\t\t   NETLINK_CB(in_skb).portid, nlh->nlmsg_seq);\n\t}\n\tif (err < 0)\n\t\tgoto errout_free;\n\n\trcu_read_unlock();\n","target":0,"flaw_line_index":0,"hash":"5336e8f2-14a4-4942-a901-8f774d4c1c1a","idx":"28318e8c-6628-42c9-afbc-d134ede868ec"}
{"func_before":"static ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tchar *driver_override, *old = pdev->driver_override, *cp;\n\n\tif (count > PATH_MAX)\n\t\treturn -EINVAL;\n\n\tdriver_override = kstrndup(buf, count, GFP_KERNEL);\n\t\treturn -ENOMEM;\n\n\tcp = strchr(driver_override, '\\n');\n\tif (cp)\n\t\t*cp = '\\0';\n\n\tif (strlen(driver_override)) {\n\t\tpdev->driver_override = driver_override;\n\t} else {\n\t\tkfree(driver_override);\n\t\tpdev->driver_override = NULL;\n\t}\n\n\tkfree(old);\n\n\treturn count;\n}","target":1,"flaw_line_index":0,"hash":"075f791b-b85e-4607-bac0-31f2fe417b8b","idx":"752b8164-dd61-46b7-aa09-b6c03bba7d62"}
{"func_before":"static ssize_t driver_override_store(struct device *dev,\n\t\t\t\t     struct device_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tchar *driver_override, *old, *cp;\n\n\tif (count > PATH_MAX)\n\t\treturn -EINVAL;\n\n\tdriver_override = kstrndup(buf, count, GFP_KERNEL);\n\n\tcp = strchr(driver_override, '\\n');\n\tif (cp)\n\t\t*cp = '\\0';\n\n\tdevice_lock(dev);\n\told = pdev->driver_override;\n\tif (strlen(driver_override)) {\n\t\tpdev->driver_override = driver_override;\n\t} else {\n\t\tkfree(driver_override);\n\t\tpdev->driver_override = NULL;\n\t}\n\tdevice_unlock(dev);\n\n\tkfree(old);\n\n\treturn count;\n}","target":0,"flaw_line_index":0,"hash":"7c8a53c6-638c-44b1-b12f-baecbd8dff27","idx":"458034fc-2da2-443d-9ef7-7b262071d14d"}
{"func_before":"\t\tret = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tret = rhashtable_init(tmp_sdma_rht, &sdma_rht_params);\n\tif (ret < 0)\n\t\tgoto bail;\n\tdd->sdma_rht = tmp_sdma_rht;\n\n\tdd_dev_info(dd, \"SDMA num_sdma: %u\\n\", dd->num_sdma);\n\treturn 0;\n","target":1,"flaw_line_index":0,"hash":"cb9dfc77-4290-425c-b456-c8ee4e974434","idx":"f9a4af2b-51e8-4f2f-970c-a0c079dcf317"}
{"func_before":"\t\tret = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tret = rhashtable_init(tmp_sdma_rht, &sdma_rht_params);\n\tif (ret < 0) {\n\t\tkfree(tmp_sdma_rht);\n\t\tgoto bail;\n\t}\n\n\tdd->sdma_rht = tmp_sdma_rht;\n\n\tdd_dev_info(dd, \"SDMA num_sdma: %u\\n\", dd->num_sdma);\n\treturn 0;\n","target":0,"flaw_line_index":0,"hash":"f8354993-3ffc-4307-8f2b-cdcccac889af","idx":"1845284e-e222-48de-8868-930cb7de982b"}
{"func_before":"    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->last_lit)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}","target":1,"flaw_line_index":0,"hash":"65428fec-d0b6-42c8-a384-d71e52014e23","idx":"c0c5d06b-c473-4724-8ac2-ec6fe89bceb2"}
{"func_before":"    s->insert = 0;\n    if (flush == Z_FINISH) {\n        FLUSH_BLOCK(s, 1);\n        return finish_done;\n    }\n    if (s->sym_next)\n        FLUSH_BLOCK(s, 0);\n    return block_done;\n}","target":0,"flaw_line_index":0,"hash":"7e3a7f0f-6d4a-4339-9899-8fe33a0764c8","idx":"c02f6fac-cd4c-4ac8-82da-fd4f178fd4d3"}
{"func_before":"comics_document_render_pixbuf (EvDocument      *document,\n\t\t\t       EvRenderContext *rc)\n{\n\tGdkPixbufLoader *loader;\n\tGdkPixbuf *rotated_pixbuf, *tmp_pixbuf;\n\tchar **argv;\n\tguchar buf[4096];\n\tgboolean success;\n\tgint outpipe = -1;\n\tGPid child_pid;\n\tgssize bytes;\n\tgint width, height;\n\tgchar *filename;\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\t\n\tif (!comics_document->decompress_tmp) {\n\t\targv = extract_argv (document, rc->page->index);\n\t\tsuccess = g_spawn_async_with_pipes (NULL, argv, NULL,\n\t\t\t\t\t\t    G_SPAWN_SEARCH_PATH | \n\t\t\t\t\t\t    G_SPAWN_STDERR_TO_DEV_NULL,\n\t\t\t\t\t\t    NULL, NULL,\n\t\t\t\t\t\t    &child_pid,\n\t\t\t\t\t\t    NULL, &outpipe, NULL, NULL);\n\t\tg_strfreev (argv);\n\t\tg_return_val_if_fail (success == TRUE, NULL);\n\n\t\tloader = gdk_pixbuf_loader_new ();\n\t\tg_signal_connect (loader, \"size-prepared\",\n\t\t\t\t  G_CALLBACK (render_pixbuf_size_prepared_cb), \n\t\t\t\t  &rc->scale);\n\n\t\twhile (outpipe >= 0) {\n\t\t\tbytes = read (outpipe, buf, 4096);\n\n\t\t\tif (bytes > 0) {\n\t\t\t\tgdk_pixbuf_loader_write (loader, buf, bytes, \n\t\t\t\tNULL);\n\t\t\t} else if (bytes <= 0) {\n\t\t\t\tclose (outpipe);\n\t\t\t\tgdk_pixbuf_loader_close (loader, NULL);\n\t\t\t\toutpipe = -1;\n\t\t\t}\n\t\t}\n\t\ttmp_pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);\n\t\trotated_pixbuf =\n\t\t\tgdk_pixbuf_rotate_simple (tmp_pixbuf,\n\t\t\t\t\t\t  360 - rc->rotation);\n\t\tg_spawn_close_pid (child_pid);\n\t\tg_object_unref (loader);\n\t} else {\n\t\tfilename = \n\t\t\tg_build_filename (comics_document->dir,\n                                          (char *) comics_document->page_names->pdata[rc->page->index],\n\t\t\t\t\t  NULL);\n\n\t\tgdk_pixbuf_get_file_info (filename, &width, &height);\n\n\t\ttmp_pixbuf =\n\t\t\tgdk_pixbuf_new_from_file_at_size (\n\t\t\t\t    filename, width * (rc->scale) + 0.5,\n\t\t\t\t    height * (rc->scale) + 0.5, NULL);\n\t\trotated_pixbuf =\n\t\t\tgdk_pixbuf_rotate_simple (tmp_pixbuf,\n\t\t\t\t\t\t  360 - rc->rotation);\n\t\tg_free (filename);\n\t\tg_object_unref (tmp_pixbuf);\n\t}\n\treturn rotated_pixbuf;\n}","target":1,"flaw_line_index":0,"hash":"643ee408-90a4-4952-9a44-79217768164d","idx":"5222071b-2d3d-485f-b781-7bff0c4a3989"}
{"func_before":"comics_document_render_pixbuf (EvDocument      *document,\n\t\t\t       EvRenderContext *rc)\n{\n\tGdkPixbufLoader *loader;\n\tGdkPixbuf *tmp_pixbuf;\n\tGdkPixbuf *rotated_pixbuf = NULL;\n\tComicsDocument *comics_document = COMICS_DOCUMENT (document);\n\tconst char *page_path;\n\tGError *error = NULL;\n\n\tpage_path = g_ptr_array_index (comics_document->page_names, rc->page->index);\n\n\tif (!archive_reopen_if_needed (comics_document, page_path, &error)) {\n\t\tg_warning (\"Fatal error opening archive: %s\", error->message);\n\t\tg_error_free (error);\n\t\treturn NULL;\n\t}\n\n\tloader = gdk_pixbuf_loader_new ();\n\tg_signal_connect (loader, \"size-prepared\",\n\t\t\t  G_CALLBACK (render_pixbuf_size_prepared_cb),\n\t\t\t  rc);\n\n\twhile (1) {\n\t\tconst char *name;\n\n\t\tif (!ev_archive_read_next_header (comics_document->archive, &error)) {\n\t\t\tif (error != NULL) {\n\t\t\t\tg_warning (\"Fatal error handling archive (%s): %s\", G_STRFUNC, error->message);\n\t\t\t\tg_error_free (error);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tname = ev_archive_get_entry_pathname (comics_document->archive);\n\t\tif (g_strcmp0 (name, page_path) == 0) {\n\t\t\tsize_t size = ev_archive_get_entry_size (comics_document->archive);\n\t\t\tchar *buf;\n\t\t\tssize_t read;\n\n\t\t\tbuf = g_malloc (size);\n\t\t\tread = ev_archive_read_data (comics_document->archive, buf, size, &error);\n\t\t\tif (read <= 0) {\n\t\t\t\tif (read < 0) {\n\t\t\t\t\tg_warning (\"Fatal error reading '%s' in archive: %s\", name, error->message);\n\t\t\t\t\tg_error_free (error);\n\t\t\t\t} else {\n\t\t\t\t\tg_warning (\"Read an empty file from the archive\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgdk_pixbuf_loader_write (loader, (guchar *) buf, size, NULL);\n\t\t\t}\n\t\t\tg_free (buf);\n\t\t\tgdk_pixbuf_loader_close (loader, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttmp_pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);\n\tif (tmp_pixbuf) {\n\t\tif ((rc->rotation % 360) == 0)\n\t\t\trotated_pixbuf = g_object_ref (tmp_pixbuf);\n\t\telse\n\t\t\trotated_pixbuf = gdk_pixbuf_rotate_simple (tmp_pixbuf,\n\t\t\t\t\t\t\t\t   360 - rc->rotation);\n\t}\n\tg_object_unref (loader);\n\n\treturn rotated_pixbuf;\n}","target":0,"flaw_line_index":0,"hash":"de5249cb-155f-4ee8-850b-429bc2029b90","idx":"7fc02dad-4588-4db7-a43d-41c4fe3df99c"}
{"func_before":"perf_sw_event(u32 event_id, u64 nr, int nmi, struct pt_regs *regs, u64 addr)\n{\n\tstruct pt_regs hot_regs;\n\n\tif (static_branch(&perf_swevent_enabled[event_id])) {\n\t\tif (!regs) {\n\t\t\tperf_fetch_caller_regs(&hot_regs);\n\t\t\tregs = &hot_regs;\n\t\t}\n\t\t__perf_sw_event(event_id, nr, nmi, regs, addr);\n\t}\n}","target":1,"flaw_line_index":0,"hash":"dd9dd156-165f-4980-96bf-dc1966ccd3aa","idx":"512ca2cb-2629-4f9f-93ee-f0fe1d1d93b7"}
{"func_before":"perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)\n{\n\tstruct pt_regs hot_regs;\n\n\tif (static_branch(&perf_swevent_enabled[event_id])) {\n\t\tif (!regs) {\n\t\t\tperf_fetch_caller_regs(&hot_regs);\n\t\t\tregs = &hot_regs;\n\t\t}\n\t\t__perf_sw_event(event_id, nr, regs, addr);\n\t}\n}","target":0,"flaw_line_index":0,"hash":"c0c0f436-4e72-45d9-b831-06371fe0a85d","idx":"0eee5ce8-90d1-479a-a07a-e2b55b796bf5"}
{"func_before":"\t\t\tchassis->c_cap_available = PEEK_UINT16;\n\t\t\tchassis->c_cap_enabled = PEEK_UINT16;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_MGMT_ADDR:\n\t\t\tCHECK_TLV_SIZE(1, \"Management address\");\n\t\t\taddr_str_length = PEEK_UINT8;\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length, \"Management address\");\n\t\t\tPEEK_BYTES(addr_str_buffer, addr_str_length);\n\t\t\taddr_length = addr_str_length - 1;\n\t\t\taddr_family = addr_str_buffer[0];\n\t\t\taddr_ptr = &addr_str_buffer[1];\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length + 5, \"Management address\");\n\t\t\tiface_subtype = PEEK_UINT8;\n\t\t\tiface_number = PEEK_UINT32;\n\t\t\t\n\t\t\taf = lldpd_af_from_lldp_proto(addr_family);\n\t\t\tif (af == LLDPD_AF_UNSPEC)\n\t\t\t\tbreak;\n\t\t\tif (iface_subtype == LLDP_MGMT_IFACE_IFINDEX)\n\t\t\t\tiface = iface_number;\n\t\t\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\tbreak;\n\t\tcase LLDP_TLV_ORG:\n\t\t\tCHECK_TLV_SIZE(4, \"Organisational\");\n\t\t\tPEEK_BYTES(orgid, sizeof(orgid));\n\t\t\ttlv_subtype = PEEK_UINT8;\n\t\t\tif (memcmp(dot1, orgid, sizeof(orgid)) == 0) {\n#ifndef ENABLE_DOT1\n\t\t\t\thardware->h_rx_unrecognized_cnt++;","target":1,"flaw_line_index":0,"hash":"c60eaa1e-c69d-43e0-9426-9d95dc481587","idx":"d9465136-ad02-46c6-80d9-edf08f7dacb5"}
{"func_before":"\t\t\tchassis->c_cap_enabled = PEEK_UINT16;\n\t\t\tbreak;\n\t\tcase LLDP_TLV_MGMT_ADDR:\n\t\t\tCHECK_TLV_SIZE(1, \"Management address\");\n\t\t\taddr_str_length = PEEK_UINT8;\n\t\t\tif (addr_str_length > sizeof(addr_str_buffer)) {\n\t\t\t\tlog_warnx(\"lldp\", \"too large management address on %s\",\n\t\t\t\t    hardware->h_ifname);\n\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length, \"Management address\");\n\t\t\tPEEK_BYTES(addr_str_buffer, addr_str_length);\n\t\t\taddr_length = addr_str_length - 1;\n\t\t\taddr_family = addr_str_buffer[0];\n\t\t\taddr_ptr = &addr_str_buffer[1];\n\t\t\tCHECK_TLV_SIZE(1 + addr_str_length + 5, \"Management address\");\n\t\t\tiface_subtype = PEEK_UINT8;\n\t\t\tiface_number = PEEK_UINT32;\n\n\t\t\taf = lldpd_af_from_lldp_proto(addr_family);\n\t\t\tif (af == LLDPD_AF_UNSPEC)\n\t\t\t\tbreak;\n\t\t\tif (iface_subtype == LLDP_MGMT_IFACE_IFINDEX)\n\t\t\t\tiface = iface_number;\n\t\t\t\t\t\tgoto malformed;\n\t\t\t}\n\t\t\tTAILQ_INSERT_TAIL(&chassis->c_mgmt, mgmt, m_entries);\n\t\t\tbreak;\n\t\tcase LLDP_TLV_ORG:\n\t\t\tCHECK_TLV_SIZE(1 + (int)sizeof(orgid), \"Organisational\");\n\t\t\tPEEK_BYTES(orgid, sizeof(orgid));\n\t\t\ttlv_subtype = PEEK_UINT8;\n\t\t\tif (memcmp(dot1, orgid, sizeof(orgid)) == 0) {\n#ifndef ENABLE_DOT1\n\t\t\t\thardware->h_rx_unrecognized_cnt++;","target":0,"flaw_line_index":0,"hash":"ddeadfb6-3a28-4bcb-b89a-031f3346a51b","idx":"47946ddf-0aca-4341-a4d9-9d590b5e5ea2"}
{"func_before":"decode_rt_routing_info(netdissect_options *ndo,\n                       const u_char *pptr, char *buf, u_int buflen)\n{\n\tuint8_t route_target[8];\n\tu_int plen;\n\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   \/* get prefix length *\/\n\n\tif (0 == plen) {\n\t\tsnprintf(buf, buflen, \"default route target\");\n\t\treturn 1;\n\t}\n\n\tif (32 > plen)\n\t\treturn -1;\n\n        plen-=32; \/* adjust prefix length *\/\n\n\tif (64 < plen)\n\t\treturn -1;\n\n\tmemset(&route_target, 0, sizeof(route_target));\n\tND_TCHECK2(pptr[1], (plen + 7) \/ 8);\n\tmemcpy(&route_target, &pptr[1], (plen + 7) \/ 8);\n\tif (plen % 8) {\n\t\t((u_char *)&route_target)[(plen + 7) \/ 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"origin AS: %s, route target %s\",\n\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+1)),\n\t    bgp_vpn_rd_print(ndo, (u_char *)&route_target));\n\n\treturn 5 + (plen + 7) \/ 8;\n\ntrunc:","target":1,"flaw_line_index":0,"hash":"c577fc7c-1269-4989-82a7-55dd143a96ca","idx":"26c9761e-7620-40e5-9c99-9ae15e04fa00"}
{"func_before":"decode_rt_routing_info(netdissect_options *ndo,\n                       const u_char *pptr, char *buf, u_int buflen)\n{\n\tuint8_t route_target[8];\n\tu_int plen;\n\tchar asbuf[sizeof(astostr)]; \/* bgp_vpn_rd_print() overwrites astostr *\/\n\n\t\/* NLRI \"prefix length\" from RFC 2858 Section 4. *\/\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   \/* get prefix length *\/\n\n\t\/* NLRI \"prefix\" (ibid), valid lengths are { 0, 32, 33, ..., 96 } bits.\n\t * RFC 4684 Section 4 defines the layout of \"origin AS\" and \"route\n\t * target\" fields inside the \"prefix\" depending on its length.\n\t *\/\n\tif (0 == plen) {\n\t\t\/* Without \"origin AS\", without \"route target\". *\/\n\t\tsnprintf(buf, buflen, \"default route target\");\n\t\treturn 1;\n\t}\n\n\tif (32 > plen)\n\t\treturn -1;\n\n\t\/* With at least \"origin AS\", possibly with \"route target\". *\/\n\tND_TCHECK_32BITS(pptr + 1);\n\tas_printf(ndo, asbuf, sizeof(asbuf), EXTRACT_32BITS(pptr + 1));\n\n        plen-=32; \/* adjust prefix length *\/\n\n\tif (64 < plen)\n\t\treturn -1;\n\n\t\/* From now on (plen + 7) \/ 8 evaluates to { 0, 1, 2, ..., 8 }\n\t * and gives the number of octets in the variable-length \"route\n\t * target\" field inside this NLRI \"prefix\". Look for it.\n\t *\/\n\tmemset(&route_target, 0, sizeof(route_target));\n\tND_TCHECK2(pptr[5], (plen + 7) \/ 8);\n\tmemcpy(&route_target, &pptr[5], (plen + 7) \/ 8);\n\t\/* Which specification says to do this? *\/\n\tif (plen % 8) {\n\t\t((u_char *)&route_target)[(plen + 7) \/ 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"origin AS: %s, route target %s\",\n\t    asbuf,\n\t    bgp_vpn_rd_print(ndo, (u_char *)&route_target));\n\n\treturn 5 + (plen + 7) \/ 8;\n\ntrunc:","target":0,"flaw_line_index":0,"hash":"1689d81a-c5eb-4ac7-afdd-4bb72f28c0f7","idx":"579c525d-b03e-4ead-a1ce-f19e78368483"}
{"func_before":"\t    int off;\n\n\t    \/\/ Avoid starting halfway a multi-byte character.\n\t    if (b_insert)\n\t    {\n\t\toff = (*mb_head_off)(oldp, oldp + offset + spaces);\n\t    }\n\t    else\n\t    {\n\t\toff = (*mb_off_next)(oldp, oldp + offset);\n\t\toffset += off;\n\t    }\n\t    spaces -= off;\n\t    count -= off;\n\t}\n\tif (spaces < 0)  \/\/ can happen when the cursor was moved\n\t    spaces = 0;\n\n\tnewp = alloc(STRLEN(oldp) + s_len + count + 1);\n\tif (newp == NULL)\n\t    continue;\n\n\t\/\/ copy up to shifted part\n\tmch_memmove(newp, oldp, (size_t)(offset));\n\toldp += offset;\n\n\t\/\/ insert pre-padding\n\tvim_memset(newp + offset, ' ', (size_t)spaces);\n\tstartcol = offset + spaces;\n\n\t\/\/ copy the new text\n\tmch_memmove(newp + startcol, s, (size_t)s_len);\n\toffset += s_len;\n\n\tif (spaces && !bdp->is_short)\n\t{\n\t    \/\/ insert post-padding\n\t    vim_memset(newp + offset + spaces, ' ', (size_t)(ts_val - spaces));\n\t    \/\/ We're splitting a TAB, don't copy it.\n\t    oldp++;\n\t    \/\/ We allowed for that TAB, remember this now\n\t    count++;\n\t}\n\n\tif (spaces > 0)\n\t    offset += count;\n\tSTRMOVE(newp + offset, oldp);","target":1,"flaw_line_index":0,"hash":"449311a1-49da-45e4-88b4-824b1e8f8128","idx":"55ae3d7a-87d7-465f-ad14-f9cd641debb7"}
{"func_before":"\n\t    \/\/ Avoid starting halfway a multi-byte character.\n\t    if (b_insert)\n\t    {\n\t\toff = (*mb_head_off)(oldp, oldp + offset + spaces);\n\t\tspaces -= off;\n\t\tcount -= off;\n\t    }\n\t    else\n\t    {\n\t\t\/\/ spaces fill the gap, the character that's at the edge moves\n\t\t\/\/ right\n\t\toff = (*mb_head_off)(oldp, oldp + offset);\n\t\toffset -= off;\n\t    }\n\t}\n\tif (spaces < 0)  \/\/ can happen when the cursor was moved\n\t    spaces = 0;\n\n\t\/\/ Make sure the allocated size matches what is actually copied below.\n\tnewp = alloc(STRLEN(oldp) + spaces + s_len\n\t\t    + (spaces > 0 && !bdp->is_short ? ts_val - spaces : 0)\n\t\t\t\t\t\t\t\t  + count + 1);\n\tif (newp == NULL)\n\t    continue;\n\n\t\/\/ copy up to shifted part\n\tmch_memmove(newp, oldp, (size_t)offset);\n\toldp += offset;\n\n\t\/\/ insert pre-padding\n\tvim_memset(newp + offset, ' ', (size_t)spaces);\n\tstartcol = offset + spaces;\n\n\t\/\/ copy the new text\n\tmch_memmove(newp + startcol, s, (size_t)s_len);\n\toffset += s_len;\n\n\tif (spaces > 0 && !bdp->is_short)\n\t{\n\t    if (*oldp == TAB)\n\t    {\n\t\t\/\/ insert post-padding\n\t\tvim_memset(newp + offset + spaces, ' ',\n\t\t\t\t\t\t    (size_t)(ts_val - spaces));\n\t\t\/\/ we're splitting a TAB, don't copy it\n\t\toldp++;\n\t\t\/\/ We allowed for that TAB, remember this now\n\t\tcount++;\n\t    }\n\t    else\n\t\t\/\/ Not a TAB, no extra spaces\n\t\tcount = spaces;\n\t}\n\n\tif (spaces > 0)\n\t    offset += count;\n\tSTRMOVE(newp + offset, oldp);","target":0,"flaw_line_index":0,"hash":"980670ad-19c7-4924-bd19-c1e92b922d53","idx":"8ac7a16f-5a3c-4baf-88a7-bcd1cea8bfb8"}
{"func_before":"static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {\n\tRList *bins = r_list_newf ((RListFree)free_bin);\n\tif (!bins) {\n\t\treturn NULL;\n\t}\n\n\tchar *target_libs = NULL;\n\t\tif (!img) {\n\t\t\tgoto next;\n\t\t}\n\n\t\tut32 j;\n\t\tut16 *depArray = NULL;\n\t\tcache_imgxtr_t *extras = NULL;\n\t\tif (target_libs) {\n\t\t\tHtPU *path_to_idx = NULL;\n\t\t\tif (cache->accel) {\n\t\t\t\tdepArray = R_NEWS0 (ut16, cache->accel->depListCount);\n\t\t\t\tif (!depArray) {","target":1,"flaw_line_index":0,"hash":"a9f26502-2b60-4af4-9a72-198787390ff4","idx":"72eae754-2551-4a8d-8df4-d24b9e041c29"}
{"func_before":"static RList *create_cache_bins(RBinFile *bf, RDyldCache *cache) {\n\tRList *bins = r_list_newf ((RListFree)free_bin);\n\tut16 *depArray = NULL;\n\tcache_imgxtr_t *extras = NULL;\n\tif (!bins) {\n\t\treturn NULL;\n\t}\n\n\tchar *target_libs = NULL;\n\t\tcache_img_t *img = read_cache_images (cache->buf, hdr, hdr_offset);\n\t\tif (!img) {\n\t\t\tgoto next;\n\t\t}\n\n\t\tut32 j;\n\t\tif (target_libs) {\n\t\t\tHtPU *path_to_idx = NULL;\n\t\t\tif (cache->accel) {\n\t\t\t\tdepArray = R_NEWS0 (ut16, cache->accel->depListCount);\n\t\t\t\tif (!depArray) {","target":0,"flaw_line_index":0,"hash":"1f4bdb42-4aae-48b7-8423-39b4cd3c1f44","idx":"b0d793fb-c94e-4df5-a035-89e73a84c595"}
{"func_before":"\n\t\tzend_update_class_constants(ce TSRMLS_CC);\n\n\t\treturn_value->value.obj = spl_filesystem_object_new_ex(ce, &intern TSRMLS_CC);\n\t\tZ_TYPE_P(return_value) = IS_OBJECT;\n\t\n\t\tspl_filesystem_object_get_file_name(source TSRMLS_CC);\n\n\t\tif (ce->constructor->common.scope != spl_ce_SplFileObject) {\n\t\t\tMAKE_STD_ZVAL(arg1);\n\t\t\tMAKE_STD_ZVAL(arg2);\n\t\t} else {\n\t\t\tintern->file_name = source->file_name;\n\t\t\tintern->file_name_len = source->file_name_len;\n\t\t\tintern->_path = spl_filesystem_object_get_path(source, &intern->_path_len TSRMLS_CC);\n\t\t\tintern->_path = estrndup(intern->_path, intern->_path_len);\n\t\t\n\t\t\tintern->u.file.open_mode = \"r\";\n\t\t\tintern->u.file.open_mode_len = 1;\n\t\t\n\t\t\tif (ht && zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|sbr\", \n\t\t\t\t\t&intern->u.file.open_mode, &intern->u.file.open_mode_len, \n\t\t\t\t\t&use_include_path, &intern->u.file.zcontext) == FAILURE) {\n\t\t\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\t\t\tintern->u.file.open_mode = NULL;\n\t\t\t\tintern->file_name = NULL;\n\t\t\t\tzval_dtor(return_value);\n\t\t\t\tZ_TYPE_P(return_value) = IS_NULL;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\n\t\t\tif (spl_filesystem_file_open(intern, use_include_path, 0 TSRMLS_CC) == FAILURE) {\n\t\t\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\t\t\tzval_dtor(return_value);\n\t\t\t\tZ_TYPE_P(return_value) = IS_NULL;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SPL_FS_DIR:\t\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Operation not supported\");\n\t\treturn NULL;\n\t}\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);","target":1,"flaw_line_index":0,"hash":"88bac049-b385-4e30-ab33-bb5e29dc71d1","idx":"0bb15cfc-7616-47bf-b2f1-1052740062cc"}
{"func_before":"\n\t\tzend_update_class_constants(ce TSRMLS_CC);\n\n\t\treturn_value->value.obj = spl_filesystem_object_new_ex(ce, &intern TSRMLS_CC);\n\t\tZ_TYPE_P(return_value) = IS_OBJECT;\n\n\t\tspl_filesystem_object_get_file_name(source TSRMLS_CC);\n\n\t\tif (ce->constructor->common.scope != spl_ce_SplFileObject) {\n\t\t\tMAKE_STD_ZVAL(arg1);\n\t\t\tMAKE_STD_ZVAL(arg2);\n\t\t} else {\n\t\t\tintern->file_name = source->file_name;\n\t\t\tintern->file_name_len = source->file_name_len;\n\t\t\tintern->_path = spl_filesystem_object_get_path(source, &intern->_path_len TSRMLS_CC);\n\t\t\tintern->_path = estrndup(intern->_path, intern->_path_len);\n\n\t\t\tintern->u.file.open_mode = \"r\";\n\t\t\tintern->u.file.open_mode_len = 1;\n\n\t\t\tif (ht && zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"|sbr\",\n\t\t\t\t\t&intern->u.file.open_mode, &intern->u.file.open_mode_len,\n\t\t\t\t\t&use_include_path, &intern->u.file.zcontext) == FAILURE) {\n\t\t\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\t\t\tintern->u.file.open_mode = NULL;\n\t\t\t\tintern->file_name = NULL;\n\t\t\t\tzval_dtor(return_value);\n\t\t\t\tZ_TYPE_P(return_value) = IS_NULL;\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tif (spl_filesystem_file_open(intern, use_include_path, 0 TSRMLS_CC) == FAILURE) {\n\t\t\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\t\t\tzval_dtor(return_value);\n\t\t\t\tZ_TYPE_P(return_value) = IS_NULL;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase SPL_FS_DIR:\n\t\tzend_restore_error_handling(&error_handling TSRMLS_CC);\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0 TSRMLS_CC, \"Operation not supported\");\n\t\treturn NULL;\n\t}\n\tzend_restore_error_handling(&error_handling TSRMLS_CC);","target":0,"flaw_line_index":0,"hash":"de50ecd9-e6d5-46df-a3eb-b999179fbf54","idx":"a493ebbb-ce77-482d-92fe-32f5fe9f1c21"}
{"func_before":"  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n\n    float input_min = context->input(1).flat<float>()(0);\n    float input_max = context->input(2).flat<float>()(0);\n    float input_scale = (input_max - input_min) \/ 255.0f;\n\n    OP_REQUIRES(context, input_min < input_max,\n                errors::InvalidArgument(\n                    \"input_min must be less than input_max : \", input_min,","target":1,"flaw_line_index":0,"hash":"4a54d95b-5ef8-4c66-a47a-0571b22d3587","idx":"31853a11-1483-4c42-a4d6-8df37d99b642"}
{"func_before":"  void Compute(OpKernelContext* context) override {\n    const Tensor& input = context->input(0);\n\n    const Tensor& x_min = context->input(1);\n    const Tensor& x_max = context->input(2);\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(x_min.shape()),\n                errors::InvalidArgument(\"`x_min` must be rank 0 but is rank \",\n                                        x_min.dims()));\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(x_max.shape()),\n                errors::InvalidArgument(\"`x_max` must be rank 0 but is rank \",\n                                        x_max.dims()));\n    float input_min = x_min.scalar<float>()();\n    float input_max = x_max.scalar<float>()();\n    float input_scale = (input_max - input_min) \/ 255.0f;\n\n    OP_REQUIRES(context, input_min < input_max,\n                errors::InvalidArgument(\n                    \"input_min must be less than input_max : \", input_min,","target":0,"flaw_line_index":0,"hash":"61d7d90e-aa17-46c4-bec7-52211059428c","idx":"4f64aa81-9d46-443c-a8cf-f589c5cbec99"}
{"func_before":"\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (saddr) {\n\t\tsaddr->family = AF_IEEE802154;\n\t\tsaddr->addr = mac_cb(skb)->sa;\n\t}\n\tif (addr_len)\n\t\t*addr_len = sizeof(*saddr);\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);","target":1,"flaw_line_index":0,"hash":"4ffb86c7-e994-4ec1-b09d-6d53813a4edb","idx":"370c8444-0466-445a-ad9b-fb4fd22b4289"}
{"func_before":"\tsock_recv_ts_and_drops(msg, sk, skb);\n\n\tif (saddr) {\n\t\tsaddr->family = AF_IEEE802154;\n\t\tsaddr->addr = mac_cb(skb)->sa;\n\t\t*addr_len = sizeof(*saddr);\n\t}\n\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);","target":0,"flaw_line_index":0,"hash":"dadf251b-28ef-448a-b04a-136637c14502","idx":"f47c5f36-04f1-4cf5-a611-324e57ad12ca"}
{"func_before":"int udf_get_filename(struct super_block *sb, uint8_t *sname, uint8_t *dname,\n\t\t     int flen)\n{\n\tstruct ustr *filename, *unifilename;\n\tint len = 0;\n\n\tfilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\n\tunifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!unifilename)\n\t\tgoto out1;\n\n\tif (udf_build_ustr_exact(unifilename, sname, flen))\n\t\tgoto out2;\n\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tif (!udf_CS0toUTF8(filename, unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\tgoto out2;\n\t\t}\n\t} else\n\t\tgoto out2;\n\n\tlen = udf_translate_to_linux(dname, filename->u_name, filename->u_len,\n\t\t\t\t     unifilename->u_name, unifilename->u_len);\nout2:\n\tkfree(unifilename);\nout1:\n\tkfree(filename);","target":1,"flaw_line_index":0,"hash":"e20b0194-c491-4dd1-9121-75ac9347ba0c","idx":"c174f8cb-e1c0-4a6d-a2ff-2fd34f127067"}
{"func_before":"int udf_get_filename(struct super_block *sb, uint8_t *sname, int slen,\n\t\t     uint8_t *dname, int dlen)\n{\n\tstruct ustr *filename, *unifilename;\n\tint len = 0;\n\n\tfilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\n\tunifilename = kmalloc(sizeof(struct ustr), GFP_NOFS);\n\tif (!unifilename)\n\t\tgoto out1;\n\n\tif (udf_build_ustr_exact(unifilename, sname, slen))\n\t\tgoto out2;\n\n\tif (UDF_QUERY_FLAG(sb, UDF_FLAG_UTF8)) {\n\t\tif (!udf_CS0toUTF8(filename, unifilename)) {\n\t\t\tudf_debug(\"Failed in udf_get_filename: sname = %s\\n\",\n\t\t\tgoto out2;\n\t\t}\n\t} else\n\t\tgoto out2;\n\n\tlen = udf_translate_to_linux(dname, dlen,\n\t\t\t\t     filename->u_name, filename->u_len,\n\t\t\t\t     unifilename->u_name, unifilename->u_len);\nout2:\n\tkfree(unifilename);\nout1:\n\tkfree(filename);","target":0,"flaw_line_index":0,"hash":"2313a59d-a5bf-470f-8e2c-32f1da6ed6e4","idx":"b5336964-9d97-4ec2-889b-347e1d50926b"}
{"func_before":"    m_NaluLengthSize       = 1+(payload[4]&3);\n    AP4_UI08 num_seq_params = payload[5]&31;\n    m_SequenceParameters.EnsureCapacity(num_seq_params);\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        m_SequenceParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_SequenceParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n    AP4_UI08 num_pic_params = payload[cursor++];\n    m_PictureParameters.EnsureCapacity(num_pic_params);\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        m_PictureParameters.Append(AP4_DataBuffer());\n        AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n        m_PictureParameters[i].SetData(&payload[cursor]+2, param_length);\n        cursor += 2+param_length;\n    }\n}","target":1,"flaw_line_index":0,"hash":"5f9bf017-9ef3-41c2-81f7-c4df30d67094","idx":"56db4bf3-0bdd-4ab2-a5c5-e89bc6caa7ab"}
{"func_before":"    m_NaluLengthSize       = 1+(payload[4]&3);\n    AP4_UI08 num_seq_params = payload[5]&31;\n    m_SequenceParameters.EnsureCapacity(num_seq_params);\n    unsigned int cursor = 6;\n    for (unsigned int i=0; i<num_seq_params; i++) {\n        if (cursor+2 <= payload_size) {\n            AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n            cursor += 2;\n            if (cursor + param_length < payload_size) {\n                m_SequenceParameters.Append(AP4_DataBuffer());\n                m_SequenceParameters[i].SetData(&payload[cursor], param_length);\n                cursor += param_length;\n            }\n        }\n    }\n    AP4_UI08 num_pic_params = payload[cursor++];\n    m_PictureParameters.EnsureCapacity(num_pic_params);\n    for (unsigned int i=0; i<num_pic_params; i++) {\n        if (cursor+2 <= payload_size) {\n            AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]);\n            cursor += 2;\n            if (cursor + param_length < payload_size) {\n                m_PictureParameters.Append(AP4_DataBuffer());\n                m_PictureParameters[i].SetData(&payload[cursor], param_length);\n                cursor += param_length;\n            }\n        }\n    }\n}","target":0,"flaw_line_index":0,"hash":"97afa530-94b5-452e-8d9d-082a0a749a0d","idx":"a9d5a1d6-20ea-4267-a858-f30935c82d74"}
{"func_before":"\tthread->cpu_context.sp = (unsigned long)childregs;\n\n\tclear_ptrace_hw_breakpoint(p);\n\n\tif (clone_flags & CLONE_SETTLS)\n\t\tthread->tp_value = childregs->ARM_r3;\n\n\tthread_notify(THREAD_NOTIFY_COPY, thread);\n\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"c46e33bf-96ef-4126-af0b-226c16316037","idx":"0134b4c7-b157-4a6a-b897-7be1f7cf0c03"}
{"func_before":"\tthread->cpu_context.sp = (unsigned long)childregs;\n\n\tclear_ptrace_hw_breakpoint(p);\n\n\tif (clone_flags & CLONE_SETTLS)\n\t\tthread->tp_value[0] = childregs->ARM_r3;\n\tthread->tp_value[1] = get_tpuser();\n\n\tthread_notify(THREAD_NOTIFY_COPY, thread);\n\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"3d0c16bb-4891-4fe4-b9a7-d8ece816ba9b","idx":"d78db74b-b324-4d33-afc0-15a1d1e04049"}
{"func_before":"\n    absl::BlockingCounter shuffles_completed(2);\n    auto on_shuffled = [&]() { shuffles_completed.DecrementCount(); };\n\n    \/\/ Shuffle input into temporary tensor.\n    Tensor input_shuffled(input.dtype(), TensorShape(post_shuffle(input)));\n    input_shuffled.tensor<T, 5>().device(device, on_shuffled) =\n        input.shaped<T, 5>(pre_shuffle(input)).shuffle(shuffle);\n\n    \/\/ Shuffle filter into temporary tensor.\n    Tensor filter_shuffled(filter.dtype(), TensorShape(post_shuffle(filter)));\n    filter_shuffled.tensor<T, 5>().device(device, on_shuffled) =\n        filter.shaped<T, 5>(pre_shuffle(filter)).shuffle(shuffle);\n\n    \/\/ Wait for the completion of input\/filter shuffles.\n    shuffles_completed.Wait();\n\n    \/\/ Write group convolution results into temporary output tensor.\n    Tensor output_shuffled(output->dtype(), TensorShape(post_shuffle(*output)));\n\n    for (int64_t i = 0; i < num_groups; ++i) {\n      \/\/ TODO(ezhulenev): Run this loop using `parallelFor` (regular parallelFor\n      \/\/ will lead to deadlock, SpatialConvolution has to use async Eigen\n      \/\/ assignment). This requires small changes to Eigen to support async","target":1,"flaw_line_index":0,"hash":"b3110bcb-a955-41ee-8c66-0b579172afd4","idx":"43c78974-9989-43a1-8b9b-4c8dd75d44c0"}
{"func_before":"\n    absl::BlockingCounter shuffles_completed(2);\n    auto on_shuffled = [&]() { shuffles_completed.DecrementCount(); };\n\n    \/\/ Shuffle input into temporary tensor.\n    Tensor input_shuffled;\n    OP_REQUIRES_OK(\n        ctx, ctx->allocate_temp(input.dtype(), TensorShape(post_shuffle(input)),\n                                &input_shuffled));\n    input_shuffled.tensor<T, 5>().device(device, on_shuffled) =\n        input.shaped<T, 5>(pre_shuffle(input)).shuffle(shuffle);\n\n    \/\/ Shuffle filter into temporary tensor.\n    Tensor filter_shuffled;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(filter.dtype(),\n                                           TensorShape(post_shuffle(filter)),\n                                           &filter_shuffled));\n    filter_shuffled.tensor<T, 5>().device(device, on_shuffled) =\n        filter.shaped<T, 5>(pre_shuffle(filter)).shuffle(shuffle);\n\n    \/\/ Wait for the completion of input\/filter shuffles.\n    shuffles_completed.Wait();\n\n    \/\/ Write group convolution results into temporary output tensor.\n    Tensor output_shuffled;\n    OP_REQUIRES_OK(ctx, ctx->allocate_temp(output->dtype(),\n                                           TensorShape(post_shuffle(*output)),\n                                           &output_shuffled));\n\n    for (int64_t i = 0; i < num_groups; ++i) {\n      \/\/ TODO(ezhulenev): Run this loop using `parallelFor` (regular parallelFor\n      \/\/ will lead to deadlock, SpatialConvolution has to use async Eigen\n      \/\/ assignment). This requires small changes to Eigen to support async","target":0,"flaw_line_index":0,"hash":"3a3e23ca-dfa4-4ea6-a06e-1099814505c5","idx":"f498f535-68c0-4158-bb24-e2357e5bffdb"}
{"func_before":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteResizeBilinearParams*>(node->builtin_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  const TfLiteTensor* size = GetInput(context, node, kSizeTensor);\n\n  if (IsDynamicTensor(output)) {\n    TF_LITE_ENSURE_OK(context,\n                      ResizeOutputTensor(context, input, size, output));\n  }","target":1,"flaw_line_index":0,"hash":"d2cb8c18-aacc-4fab-bf63-bb8ba6350d75","idx":"801a7269-85bb-4087-8b25-bbb53b5cac11"}
{"func_before":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  auto* params =\n      reinterpret_cast<TfLiteResizeBilinearParams*>(node->builtin_data);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  const TfLiteTensor* size;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kSizeTensor, &size));\n\n  if (IsDynamicTensor(output)) {\n    TF_LITE_ENSURE_OK(context,\n                      ResizeOutputTensor(context, input, size, output));\n  }","target":0,"flaw_line_index":0,"hash":"f0a4696f-17b8-4fbd-a89a-6888abf42efb","idx":"94568ed2-b0c8-40b0-972d-1ed2ec61e65f"}
{"func_before":"\t\t\t\tgoto out;\n\t\t}\n\n\t\tjzon_add_bool(jobj, \"update\",\n\t\t\t      msg->u.confconn.update);\n\t\tjzon_add_str(jobj, \"tool\",\n\t\t\t      msg->u.confconn.tool);\n\t\tjzon_add_str(jobj, \"toolver\",\n\t\t\t      msg->u.confconn.toolver);\n\t\tjzon_add_int(jobj, \"status\",\n\t\t\t      msg->u.confconn.status);\n\t\tjzon_add_bool(jobj, \"selective_audio\",\n\t\t\t      msg->u.confconn.selective_audio);\n\t\tjzon_add_bool(jobj, \"selective_video\",","target":1,"flaw_line_index":0,"hash":"53b3b702-f433-452f-b3d2-65856be82b0d","idx":"8a853432-8fad-46d1-9b2e-688cbf1072a8"}
{"func_before":"\t\t\t\tgoto out;\n\t\t}\n\n\t\tjzon_add_bool(jobj, \"update\",\n\t\t\t      msg->u.confconn.update);\n\t\tjzon_add_str(jobj, \"tool\", \n\t\t\t     \"%s\", msg->u.confconn.tool);\n\t\tjzon_add_str(jobj, \"toolver\",\n\t\t\t     \"%s\", msg->u.confconn.toolver);\n\t\tjzon_add_int(jobj, \"status\",\n\t\t\t      msg->u.confconn.status);\n\t\tjzon_add_bool(jobj, \"selective_audio\",\n\t\t\t      msg->u.confconn.selective_audio);\n\t\tjzon_add_bool(jobj, \"selective_video\",","target":0,"flaw_line_index":0,"hash":"3075baf6-00bf-4df1-9acb-a034d305d7e0","idx":"7869b4c7-234c-4a2a-9087-87151bcdf2a1"}
{"func_before":"pci_vtrnd_notify(void *vsc, struct vqueue_info *vq)\n{\n\tstruct iovec iov;\n\tstruct pci_vtrnd_softc *sc;\n\tint len;\n\tuint16_t idx;\n\n\tsc = vsc;\n\n\tif (sc->vrsc_fd < 0) {\n\t\tvq_endchains(vq, 0);\n\t\treturn;\n\t}\n\n\twhile (vq_has_descs(vq)) {\n\t\tvq_getchain(vq, &idx, &iov, 1, NULL);\n\n\t\tlen = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);\n\n\t\tDPRINTF((\"vtrnd: vtrnd_notify(): %d\\r\\n\", len));\n","target":1,"flaw_line_index":0,"hash":"d15eb1a0-7181-42d4-bc91-6f87d8647ba4","idx":"44eacecd-a768-47bd-8bc6-0018738b71d7"}
{"func_before":"pci_vtrnd_notify(void *vsc, struct vqueue_info *vq)\n{\n\tstruct iovec iov;\n\tstruct pci_vtrnd_softc *sc;\n\tint len, n;\n\tuint16_t idx;\n\n\tsc = vsc;\n\n\tif (sc->vrsc_fd < 0) {\n\t\tvq_endchains(vq, 0);\n\t\treturn;\n\t}\n\n\twhile (vq_has_descs(vq)) {\n\t\tn = vq_getchain(vq, &idx, &iov, 1, NULL);\n\t\tif (n < 0) {\n\t\t\tfprintf(stderr, \"vtrnd: vtrnd_notify(): n %d\\r\\n\", n);\n\t\t\treturn;\n\t\t}\n\n\t\tlen = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);\n\n\t\tDPRINTF((\"vtrnd: vtrnd_notify(): %d\\r\\n\", len));\n","target":0,"flaw_line_index":0,"hash":"2f69cc46-e63f-43d7-8506-68f237d1fee8","idx":"fb1fb7a4-53e3-49cd-9a46-c15b14af48d9"}
{"func_before":"rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0, reasonLen=0;\n    char *reason=NULL;\n\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n\n    authResult = rfbClientSwap32IfLE(authResult);\n\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        \/* we have an error following *\/\n        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;\n        reasonLen = rfbClientSwap32IfLE(reasonLen);\n        reason = malloc((uint64_t)reasonLen+1);\n        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }\n        reason[reasonLen]=0;\n        rfbClientLog(\"VNC connection failed: %s\\n\",reason);\n        free(reason);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:","target":1,"flaw_line_index":0,"hash":"5aa43799-0c70-4d19-b1ce-1bfa51a36115","idx":"61d980bd-c1d5-4856-b616-f000e0a42d03"}
{"func_before":"rfbHandleAuthResult(rfbClient* client)\n{\n    uint32_t authResult=0;\n\n    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;\n\n    authResult = rfbClientSwap32IfLE(authResult);\n\n      break;\n    case rfbVncAuthFailed:\n      if (client->major==3 && client->minor>7)\n      {\n        \/* we have an error following *\/\n        ReadReason(client);\n        return FALSE;\n      }\n      rfbClientLog(\"VNC authentication failed\\n\");\n      return FALSE;\n    case rfbVncAuthTooMany:","target":0,"flaw_line_index":0,"hash":"5052c6e1-2440-4d39-80a0-83a9ec25f608","idx":"09868a64-3eb5-4627-981a-3556bfdace03"}
{"func_before":"static void *bpf_any_get(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\tatomic_inc(&((struct bpf_prog *)raw)->aux->refcnt);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\tbpf_map_inc(raw, true);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}","target":1,"flaw_line_index":0,"hash":"fa21f6ee-405b-4bbc-9482-d4692f67d656","idx":"4667bcc5-d249-43b8-9a0e-e1334b3572aa"}
{"func_before":"static void *bpf_any_get(void *raw, enum bpf_type type)\n{\n\tswitch (type) {\n\tcase BPF_TYPE_PROG:\n\t\traw = bpf_prog_inc(raw);\n\t\tbreak;\n\tcase BPF_TYPE_MAP:\n\t\traw = bpf_map_inc(raw, true);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}","target":0,"flaw_line_index":0,"hash":"6f0a7fb6-693e-4539-ae95-bc76da52a7ed","idx":"133b6d00-88e8-4de3-842e-dd27e358feb6"}
{"func_before":"    kadm5_server_handle_t handle = server_handle;\n\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if((mask & KADM5_PRINCIPAL) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_KEY_DATA) || (mask & KADM5_LAST_SUCCESS) ||\n       (mask & KADM5_LAST_FAILED))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if(entry == (kadm5_principal_ent_t) NULL)\n        return EINVAL;\n    if (mask & KADM5_TL_DATA) {\n        tl_data_orig = entry->tl_data;\n        while (tl_data_orig) {\n            if (tl_data_orig->tl_data_type < 256)\n                return KADM5_BAD_TL_TYPE;","target":1,"flaw_line_index":0,"hash":"0d38e85e-821b-43a1-9876-a3df56d45914","idx":"f001bff1-b0f9-4de2-9c76-9cde0c410ceb"}
{"func_before":"\n    CHECK_HANDLE(server_handle);\n\n    krb5_clear_error_message(handle->context);\n\n    if(entry == NULL)\n        return EINVAL;\n    if((mask & KADM5_PRINCIPAL) || (mask & KADM5_LAST_PWD_CHANGE) ||\n       (mask & KADM5_MOD_TIME) || (mask & KADM5_MOD_NAME) ||\n       (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||\n       (mask & KADM5_KEY_DATA) || (mask & KADM5_LAST_SUCCESS) ||\n       (mask & KADM5_LAST_FAILED))\n        return KADM5_BAD_MASK;\n    if((mask & ~ALL_PRINC_MASK))\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && entry->policy == NULL)\n        return KADM5_BAD_MASK;\n    if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))\n        return KADM5_BAD_MASK;\n    if (mask & KADM5_TL_DATA) {\n        tl_data_orig = entry->tl_data;\n        while (tl_data_orig) {\n            if (tl_data_orig->tl_data_type < 256)\n                return KADM5_BAD_TL_TYPE;","target":0,"flaw_line_index":0,"hash":"edeb60cb-f293-4297-b1ab-9cad0a8063b7","idx":"891b9449-5c6f-4231-af98-fcd258040ec8"}
{"func_before":"cdf_read_short_sector_chain(const cdf_header_t *h,\n    const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SEC_SIZE(h), i, j;\n\tscn->sst_len = cdf_count_chain(ssat, sid, CDF_SEC_SIZE(h));\n\tscn->sst_dirlen = len;\n\n\tif (sst->sst_tab == NULL || scn->sst_len == (size_t)-1)\n\t\treturn -1;","target":1,"flaw_line_index":0,"hash":"97d178b5-8406-4b67-8f45-1e09276e2ece","idx":"d1317160-dc20-4a13-a739-6118ea0ee46c"}
{"func_before":"cdf_read_short_sector_chain(const cdf_header_t *h,\n    const cdf_sat_t *ssat, const cdf_stream_t *sst,\n    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n{\n\tsize_t ss = CDF_SHORT_SEC_SIZE(h), i, j;\n\tscn->sst_len = cdf_count_chain(ssat, sid, CDF_SEC_SIZE(h));\n\tscn->sst_dirlen = len;\n\n\tif (sst->sst_tab == NULL || scn->sst_len == (size_t)-1)\n\t\treturn -1;","target":0,"flaw_line_index":0,"hash":"49640071-8c08-4d91-b6ab-946b3de95022","idx":"3e21d3fb-ef08-4097-9e10-58ba55347a15"}
{"func_before":"Network::FilterStatus Context::onUpstreamData(int data_length, bool end_of_stream) {\n  if (!wasm_->onUpstreamData_) {\n    return Network::FilterStatus::Continue;\n  }\n  auto result = wasm_->onUpstreamData_(this, id_, static_cast<uint32_t>(data_length),\n                                       static_cast<uint32_t>(end_of_stream));\n  \/\/ TODO(PiotrSikora): pull Proxy-WASM's FilterStatus values.","target":1,"flaw_line_index":0,"hash":"c167c3bf-714a-4cb9-a00b-8474a456610d","idx":"c584af20-c92a-4735-9c5a-68c9627ef4b3"}
{"func_before":"Network::FilterStatus Context::onUpstreamData(int data_length, bool end_of_stream) {\n  if (!in_vm_context_created_ || !wasm_->onUpstreamData_) {\n    return Network::FilterStatus::Continue;\n  }\n  auto result = wasm_->onUpstreamData_(this, id_, static_cast<uint32_t>(data_length),\n                                       static_cast<uint32_t>(end_of_stream));\n  \/\/ TODO(PiotrSikora): pull Proxy-WASM's FilterStatus values.","target":0,"flaw_line_index":0,"hash":"90a9b214-a786-4f60-8c43-4f255d007e11","idx":"6c79bb88-0f26-4232-a3d0-d133f70240cf"}
{"func_before":"nft_meta_get_eval_time(enum nft_meta_keys key,\n\t\t       u32 *dest)\n{\n\tswitch (key) {\n\tcase NFT_META_TIME_NS:\n\t\tnft_reg_store64(dest, ktime_get_real_ns());\n\t\tbreak;\n\tcase NFT_META_TIME_DAY:\n\t\tnft_reg_store8(dest, nft_meta_weekday());\n\t\tbreak;\n\tcase NFT_META_TIME_HOUR:","target":1,"flaw_line_index":0,"hash":"ffd21a27-66d1-4eee-ab33-63338af01460","idx":"fa04df7f-9544-4c5d-9629-a05f8b40401d"}
{"func_before":"nft_meta_get_eval_time(enum nft_meta_keys key,\n\t\t       u32 *dest)\n{\n\tswitch (key) {\n\tcase NFT_META_TIME_NS:\n\t\tnft_reg_store64((u64 *)dest, ktime_get_real_ns());\n\t\tbreak;\n\tcase NFT_META_TIME_DAY:\n\t\tnft_reg_store8(dest, nft_meta_weekday());\n\t\tbreak;\n\tcase NFT_META_TIME_HOUR:","target":0,"flaw_line_index":0,"hash":"e6d33b82-145f-4c3a-8326-e595f955f598","idx":"97e5386c-3822-4a5a-b3bb-68571fe3c3df"}
{"func_before":"static void send(node_t *node, node_t *child, byte *fout) {\n\tif (node->parent) {\n\t\tsend(node->parent, node, fout);\n\t}\n\tif (child) {\n\t\tif (node->right == child) {\n\t\t\tadd_bit(1, fout);\n\t\t} else {\n\t\t\tadd_bit(0, fout);\n\t\t}","target":1,"flaw_line_index":0,"hash":"e4588795-e54c-4907-a372-6a4e0f20f126","idx":"b5894f24-490e-4887-bdc8-2b5d0c627a24"}
{"func_before":"static void send(node_t *node, node_t *child, byte *fout, int maxoffset) {\n\tif (node->parent) {\n\t\tsend(node->parent, node, fout, maxoffset);\n\t}\n\tif (child) {\n\t\tif (bloc >= maxoffset) {\n\t\t\tbloc = maxoffset + 1;\n\t\t\treturn;\n\t\t}\n\t\tif (node->right == child) {\n\t\t\tadd_bit(1, fout);\n\t\t} else {\n\t\t\tadd_bit(0, fout);\n\t\t}","target":0,"flaw_line_index":0,"hash":"224eacb3-3545-4280-901f-259a7fe24207","idx":"91a2fc04-85df-4ace-b1b8-17169e6df2b4"}
{"func_before":"static void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\treturn crypto_alloc_skcipher(name, type, mask);\n}","target":1,"flaw_line_index":0,"hash":"0b355009-514b-4510-bde6-f590d09140a2","idx":"49ccdd1d-bfdf-4dc6-895a-a8a03e3aff51"}
{"func_before":"static void *skcipher_bind(const char *name, u32 type, u32 mask)\n{\n\tstruct skcipher_tfm *tfm;\n\tstruct crypto_skcipher *skcipher;\n\n\ttfm = kzalloc(sizeof(*tfm), GFP_KERNEL);\n\tif (!tfm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tskcipher = crypto_alloc_skcipher(name, type, mask);\n\tif (IS_ERR(skcipher)) {\n\t\tkfree(tfm);\n\t\treturn ERR_CAST(skcipher);\n\t}\n\n\ttfm->skcipher = skcipher;\n\n\treturn tfm;\n}","target":0,"flaw_line_index":0,"hash":"4c791101-3200-410a-9337-86a2be197ca4","idx":"8cbaa5c7-af85-45fe-9f92-48f63f643061"}
{"func_before":"_dl_dst_count (const char *name, int is_path)\n{\n  size_t cnt = 0;\n\n  do\n    {\n      size_t len = 1;\n\n      \/* $ORIGIN is not expanded for SUID\/GUID programs.  *\/\n      if ((((!__libc_enable_secure\n\t     && strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t    || (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t   && (name[len] == '\\0' || name[len] == '\/'\n\t       || (is_path && name[len] == ':')))\n\t  || (name[1] == '{'\n\t      && ((!__libc_enable_secure\n\t\t   && strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t  || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t      && (len = 11) != 0))))\n\t++cnt;\n\n      name = strchr (name + len, '$');","target":1,"flaw_line_index":0,"hash":"272874bf-203b-41f8-9815-4f91e67c3652","idx":"829ec779-74d5-473d-b7d6-cf103d326248"}
{"func_before":"_dl_dst_count (const char *name, int is_path)\n{\n  const char *const start = name;\n  size_t cnt = 0;\n\n  do\n    {\n      size_t len = 1;\n\n      \/* $ORIGIN is not expanded for SUID\/GUID programs.\n\n\t Note that it is no bug that the strings in the first two `strncmp'\n\t calls are longer than the sequence which is actually tested.  *\/\n      if ((((strncmp (&name[1], \"ORIGIN}\", 6) == 0\n\t     && (!__libc_enable_secure\n\t\t || ((name[7] == '\\0' || (is_path && name[7] == ':'))\n\t\t     && (name == start || (is_path && name[-1] == ':'))))\n\t     && (len = 7) != 0)\n\t    || (strncmp (&name[1], \"PLATFORM}\", 8) == 0 && (len = 9) != 0))\n\t   && (name[len] == '\\0' || name[len] == '\/'\n\t       || (is_path && name[len] == ':')))\n\t  || (name[1] == '{'\n\t      && ((strncmp (&name[2], \"ORIGIN}\", 7) == 0\n\t\t   && (!__libc_enable_secure\n\t\t       || ((name[9] == '\\0' || (is_path && name[9] == ':'))\n\t\t\t   && (name == start || (is_path && name[-1] == ':'))))\n\t\t   && (len = 9) != 0)\n\t\t  || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t      && (len = 11) != 0))))\n\t++cnt;\n\n      name = strchr (name + len, '$');","target":0,"flaw_line_index":0,"hash":"e49f47d6-e9e2-4dff-adf6-bb4796b76b90","idx":"828bc83a-0047-4a97-9bf9-34b12a9b66a7"}
{"func_before":"\t\t\tcontinue;\n\t\tpage = vm_normal_page(vma, address, *pte);\n\t\tBUG_ON(!page || PageAnon(page));\n\n\t\tif (locked_vma) {\n\t\t\tmlock_vma_page(page);   \/* no-op if already mlocked *\/\n\t\t\tif (page == check_page)\n\t\t\t\tret = SWAP_MLOCK;\n\t\t\tcontinue;\t\/* don't unmap *\/\n\t\t}\n\n\t\tif (ptep_clear_flush_young_notify(vma, address, pte))\n\t\t\tcontinue;","target":1,"flaw_line_index":0,"hash":"8ae0e0bb-aca4-4126-9314-8b7c0fcf5076","idx":"18fb47f4-77d4-4979-bdab-75eb5233fd48"}
{"func_before":"\t\t\tcontinue;\n\t\tpage = vm_normal_page(vma, address, *pte);\n\t\tBUG_ON(!page || PageAnon(page));\n\n\t\tif (locked_vma) {\n\t\t\tif (page == check_page) {\n\t\t\t\t\/* we know we have check_page locked *\/\n\t\t\t\tmlock_vma_page(page);\n\t\t\t\tret = SWAP_MLOCK;\n\t\t\t} else if (trylock_page(page)) {\n\t\t\t\t\/*\n\t\t\t\t * If we can lock the page, perform mlock.\n\t\t\t\t * Otherwise leave the page alone, it will be\n\t\t\t\t * eventually encountered again later.\n\t\t\t\t *\/\n\t\t\t\tmlock_vma_page(page);\n\t\t\t\tunlock_page(page);\n\t\t\t}\n\t\t\tcontinue;\t\/* don't unmap *\/\n\t\t}\n\n\t\tif (ptep_clear_flush_young_notify(vma, address, pte))\n\t\t\tcontinue;","target":0,"flaw_line_index":0,"hash":"ddd58c12-fe99-459f-8fc9-31dfa0ccd079","idx":"a4bcc9e6-110b-4fcc-bae4-4ec565cb95b7"}
{"func_before":"\n  Array return_val;\n\n  for (int server_id = 0; server_id < server_count; server_id++) {\n    memcached_stat_st *stat;\n    char stats_key[30] = {0};\n    size_t key_len;\n\n    LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n      memcached_server_instance_by_position(&data->m_memcache, server_id);\n    const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n    in_port_t port = LMCD_SERVER_PORT(instance);\n\n    Array server_stats = memcache_build_stats(&data->m_memcache, stat, &ret);\n    if (ret != MEMCACHED_SUCCESS) {\n      continue;\n    }\n\n    key_len = snprintf(stats_key, sizeof(stats_key), \"%s:%d\", hostname, port);\n\n    return_val.set(String(stats_key, key_len, CopyString), server_stats);\n  }\n\n  free(stats);\n  return return_val;\n}","target":1,"flaw_line_index":0,"hash":"81bc0f4d-fc4d-46ee-a73a-431a864e7efd","idx":"fb7126b2-04e6-47f8-a2b4-4d6dfa5e03cc"}
{"func_before":"  int server_count = memcached_server_count(&data->m_memcache);\n\n  Array return_val;\n\n  for (int server_id = 0; server_id < server_count; server_id++) {\n    memcached_stat_st *stat;\n    LMCD_SERVER_POSITION_INSTANCE_TYPE instance =\n      memcached_server_instance_by_position(&data->m_memcache, server_id);\n    const char *hostname = LMCD_SERVER_HOSTNAME(instance);\n    in_port_t port = LMCD_SERVER_PORT(instance);\n\n    Array server_stats = memcache_build_stats(&data->m_memcache, stat, &ret);\n    if (ret != MEMCACHED_SUCCESS) {\n      continue;\n    }\n\n    auto const port_str = folly::to<std::string>(port);\n    auto const key_len = strlen(hostname) + 1 + port_str.length();\n    auto key = String(key_len, ReserveString);\n    key += hostname;\n    key += \":\";\n    key += port_str;\n    return_val.set(key, server_stats);\n  }\n\n  free(stats);\n  return return_val;\n}","target":0,"flaw_line_index":0,"hash":"8b8c20af-58db-4e45-ae56-303ddeb775a2","idx":"ab098d2c-1551-431d-8181-73c011361991"}
{"func_before":"    const int crop_height = crops.dimension(1);\n    const int crop_width = crops.dimension(2);\n    const int depth = crops.dimension(3);\n\n    \/\/ Sharding across boxes.\n    auto CropAndResizePerBox = [&](int start_box, int limit_box) {\n      for (int b = start_box; b < limit_box; ++b) {\n        const float y1 = boxes(b, 0);\n        const float x1 = boxes(b, 1);\n        const float y2 = boxes(b, 2);\n        const float x2 = boxes(b, 3);","target":1,"flaw_line_index":0,"hash":"35b6f47d-a682-4c89-bc33-4b844e6a5d5f","idx":"eb4429bf-e16b-4e69-bf3a-86c5b4852bdd"}
{"func_before":"    const int crop_height = crops.dimension(1);\n    const int crop_width = crops.dimension(2);\n    const int depth = crops.dimension(3);\n\n    \/\/ Sharding across boxes.\n    auto CropAndResizePerBox = [&](int64 start_box, int64 limit_box) {\n      for (int b = start_box; b < limit_box; ++b) {\n        const float y1 = boxes(b, 0);\n        const float x1 = boxes(b, 1);\n        const float y2 = boxes(b, 2);\n        const float x2 = boxes(b, 3);","target":0,"flaw_line_index":0,"hash":"f1e7f1f3-67c1-4d4d-9c73-6494afb3302d","idx":"e414f90f-476b-4efc-81a2-86772874945d"}
{"func_before":"\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id > 255))\n\t\treturn -1;\n\tsi->pps = &avc->pps[pps_id];\n\tsi->pps->id = pps_id;\n\tif (!si->pps->slice_group_count)\n\t\treturn -2;","target":1,"flaw_line_index":0,"hash":"f77fc56a-445b-4298-9239-5ad505e62317","idx":"0ff31dee-5ffa-4992-a48c-9d7f7f81dd94"}
{"func_before":"\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id >= 255))\n\t\treturn -1;\n\tsi->pps = &avc->pps[pps_id];\n\tsi->pps->id = pps_id;\n\tif (!si->pps->slice_group_count)\n\t\treturn -2;","target":0,"flaw_line_index":0,"hash":"7e3ad3ec-489b-4ace-be41-f75777a973c1","idx":"bb5c49e9-9dcd-4ddf-9713-631c124649fe"}
{"func_before":"    HANDLE\t    hPipeIn = INVALID_HANDLE_VALUE;\n    HANDLE\t    hPipeOut = INVALID_HANDLE_VALUE;\n    char\t    in_name[80], out_name[80];\n    channel_T\t    *channel = NULL;\n\n    create_vterm(term, term->tl_rows, term->tl_cols);\n\n    vim_snprintf(in_name, sizeof(in_name), \"\\\\\\\\.\\\\pipe\\\\vim-%d-in-%d\",\n\t    GetCurrentProcessId(),\n\t    curbuf->b_fnum);\n    hPipeIn = CreateNamedPipe(in_name, PIPE_ACCESS_OUTBOUND,","target":1,"flaw_line_index":0,"hash":"c0631cb3-5e11-4fe9-8b42-5a92b55243e6","idx":"8837a061-fc9a-4215-b675-332e85bb5641"}
{"func_before":"    HANDLE\t    hPipeIn = INVALID_HANDLE_VALUE;\n    HANDLE\t    hPipeOut = INVALID_HANDLE_VALUE;\n    char\t    in_name[80], out_name[80];\n    channel_T\t    *channel = NULL;\n\n    if (create_vterm(term, term->tl_rows, term->tl_cols) == FAIL)\n\treturn FAIL;\n\n    vim_snprintf(in_name, sizeof(in_name), \"\\\\\\\\.\\\\pipe\\\\vim-%d-in-%d\",\n\t    GetCurrentProcessId(),\n\t    curbuf->b_fnum);\n    hPipeIn = CreateNamedPipe(in_name, PIPE_ACCESS_OUTBOUND,","target":0,"flaw_line_index":0,"hash":"c664e098-4b44-41e4-b1e4-a78e87577870","idx":"5a8871c8-8e2f-4294-91ff-278669b4bb41"}
{"func_before":"\tif (!var->szKey) {\n\t\tpe_printf (\"Warning: malloc (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {\n\t\tpe_printf (\"Warning: read (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += TRANSLATION_UTF_16_LEN;","target":1,"flaw_line_index":0,"hash":"13648fa8-e95f-42d9-8a47-65fafa733bde","idx":"323c6c8e-34fa-4f8a-a57e-04c176807299"}
{"func_before":"\tif (!var->szKey) {\n\t\tpe_printf (\"Warning: malloc (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\tif (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) != TRANSLATION_UTF_16_LEN) {\n\t\tpe_printf (\"Warning: read (Var szKey)\\n\");\n\t\tfree_Var (var);\n\t\treturn NULL;\n\t}\n\t*curAddr += TRANSLATION_UTF_16_LEN;","target":0,"flaw_line_index":0,"hash":"748d928a-b30d-467a-be5d-b00c30047200","idx":"141fb9a1-9b4a-4d88-b102-c08868788480"}
{"func_before":"  if(index > size())\n    return v;\n\n  ConstIterator endIt;\n\n  if(length < 0xffffffff && length + index < size())\n    endIt = d->data.begin() + index + length;\n  else\n    endIt = d->data.end();\n\n  v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt);","target":1,"flaw_line_index":0,"hash":"ed366e27-a3ae-4f4f-ac34-5195b3faef9e","idx":"430be448-0d64-4104-a347-63505543ef47"}
{"func_before":"  if(index > size())\n    return v;\n\n  ConstIterator endIt;\n\n  if(length < size() - index)\n    endIt = d->data.begin() + index + length;\n  else\n    endIt = d->data.end();\n\n  v.d->data.insert(v.d->data.begin(), ConstIterator(d->data.begin() + index), endIt);","target":0,"flaw_line_index":0,"hash":"f1082169-c1a4-4b4e-8b3f-0cf10e5f1fec","idx":"a6e7ce2e-d0fe-4778-83f1-a7188bf3e996"}
{"func_before":"\n\t\/* get the atapi capabilities page *\/\n\tpcd_probe_capabilities();\n\n\tif (register_blkdev(major, name)) {\n\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++)\n\t\t\tput_disk(cd->disk);\n\t\treturn -EBUSY;\n\t}\n\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (cd->present) {","target":1,"flaw_line_index":0,"hash":"74e056ad-72a5-42c7-9df8-c06cb349e5f9","idx":"f77851ed-02fb-4e90-bc4a-77c33988c532"}
{"func_before":"\n\t\/* get the atapi capabilities page *\/\n\tpcd_probe_capabilities();\n\n\tif (register_blkdev(major, name)) {\n\t\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\t\tif (!cd->disk)\n\t\t\t\tcontinue;\n\n\t\t\tblk_cleanup_queue(cd->disk->queue);\n\t\t\tblk_mq_free_tag_set(&cd->tag_set);\n\t\t\tput_disk(cd->disk);\n\t\t}\n\t\treturn -EBUSY;\n\t}\n\n\tfor (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) {\n\t\tif (cd->present) {","target":0,"flaw_line_index":0,"hash":"ca6a81b0-2fb2-4849-914e-d5787dd6c7fd","idx":"e8e5cf28-7416-489a-b732-d85852b76bad"}
{"func_before":"\t\t}\n\t\tbuffer[lpc%600] = 0;\n\t\tqb_log(LOG_INFO, \"Message %d %d - %s\", lpc, lpc%600, buffer);\n\t}\n\n        qb_log_blackbox_write_to_file(\"blackbox.dump\");\n        qb_log_blackbox_print_from_file(\"blackbox.dump\");\n\tunlink(\"blackbox.dump\");\n\tqb_log_fini();\n}","target":1,"flaw_line_index":0,"hash":"5a6cba7b-b04d-4178-bc66-d657a93af464","idx":"e2cff5ea-692b-43d2-8bfb-44f4567423bc"}
{"func_before":"\t\t}\n\t\tbuffer[lpc%600] = 0;\n\t\tqb_log(LOG_INFO, \"Message %d %d - %s\", lpc, lpc%600, buffer);\n\t}\n\n        rc = qb_log_blackbox_write_to_file(\"blackbox.dump\");\n\tck_assert_int_gt(rc, 0);\n        rc = qb_log_blackbox_print_from_file(\"blackbox.dump\");\n\tck_assert_int_le(rc, 0);\n\tunlink(\"blackbox.dump\");\n\tqb_log_fini();\n}","target":0,"flaw_line_index":0,"hash":"7b926e6d-fdc7-40b8-a4b6-7f5f5417b0f8","idx":"30e83402-daa3-488d-ae64-0d54b4a14230"}
{"func_before":"int TLSInStream::overrun(int itemSize, int nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"TLSInStream overrun: max itemSize exceeded\");\n\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n\n  while (end < start + itemSize) {\n    int n = readTLS((U8*) end, start + bufSize - end, wait);\n    if (!wait && n == 0)\n      return 0;\n    end += n;\n  }\n\n  if (itemSize * nItems > end - ptr)\n    nItems = (end - ptr) \/ itemSize;\n\n  return nItems;\n}","target":1,"flaw_line_index":0,"hash":"38f453c1-186f-4c83-bc51-4000e2317f57","idx":"b877a8eb-2b81-4308-9922-1f9dd3d962db"}
{"func_before":"size_t TLSInStream::overrun(size_t itemSize, size_t nItems, bool wait)\n{\n  if (itemSize > bufSize)\n    throw Exception(\"TLSInStream overrun: max itemSize exceeded\");\n\n  if (end - ptr != 0)\n    memmove(start, ptr, end - ptr);\n\n  offset += ptr - start;\n  end -= ptr - start;\n  ptr = start;\n\n  while (end < start + itemSize) {\n    size_t n = readTLS((U8*) end, start + bufSize - end, wait);\n    if (!wait && n == 0)\n      return 0;\n    end += n;\n  }\n\n  if (itemSize * nItems > (size_t)(end - ptr))\n    nItems = (end - ptr) \/ itemSize;\n\n  return nItems;\n}","target":0,"flaw_line_index":0,"hash":"f98bb927-25f8-4167-b747-2f470c221b4a","idx":"168cb620-13a7-4a3b-a2c3-2ed7031a06bc"}
{"func_before":"TEST_P(ResizeRealtimeTest, DISABLED_TestExternalResizeSmallerWidthBiggerSize) {\n  ResizingVideoSource video;\n  video.flag_codec_ = true;\n  video.smaller_width_larger_size_ = true;\n  DefaultConfig();\n  \/\/ Disable internal resize for this test.","target":1,"flaw_line_index":0,"hash":"2a4167d3-551e-4e81-93e2-b628bed66583","idx":"6b605293-f4f9-4be2-9fe8-a72eaa80e1c3"}
{"func_before":"TEST_P(ResizeRealtimeTest, TestExternalResizeSmallerWidthBiggerSize) {\n  ResizingVideoSource video;\n  video.flag_codec_ = true;\n  video.smaller_width_larger_size_ = true;\n  DefaultConfig();\n  \/\/ Disable internal resize for this test.","target":0,"flaw_line_index":0,"hash":"90ca73c5-513b-45ce-98cc-2ec0eeb816bf","idx":"188d1b5a-4171-4f2c-bc74-28ed607fd329"}
{"func_before":"        }\n        if (stop < 0)\n            stop += length;\n    }\n    if (unlikely(stop <= start))\n        return PyUnicode_FromUnicode(NULL, 0);\n    length = stop - start;\n    cstring += start;\n    if (decode_func) {\n        return decode_func(cstring, length, errors);\n    } else {","target":1,"flaw_line_index":0,"hash":"0d858554-7518-4b63-901a-3b3ad5c22c25","idx":"0ba96ab3-aabd-4f7d-8005-5856ccd4cef8"}
{"func_before":"        }\n        if (stop < 0)\n            stop += length;\n    }\n    if (unlikely(stop <= start))\n        return __Pyx_NewRef(__pyx_empty_unicode);\n    length = stop - start;\n    cstring += start;\n    if (decode_func) {\n        return decode_func(cstring, length, errors);\n    } else {","target":0,"flaw_line_index":0,"hash":"8ccc990c-1d00-4918-9b62-f94abf48d51d","idx":"eb25c44d-faca-4052-858a-aa9b41517998"}
{"func_before":"\n\t\/*\n\t * Now load segment descriptors. If fault happens at this stage\n\t * it is handled in a context of new task\n\t *\/\n\tret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl, true);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl, true);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl, true);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl, true);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl, true);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\treturn X86EMUL_CONTINUE;\n}","target":1,"flaw_line_index":0,"hash":"8b36838e-ed04-4a47-8e31-70d8c9d61c0a","idx":"686bfc1a-3433-4e87-8fb0-23030476eea7"}
{"func_before":"\n\t\/*\n\t * Now load segment descriptors. If fault happens at this stage\n\t * it is handled in a context of new task\n\t *\/\n\tret = __load_segment_descriptor(ctxt, tss->ldt, VCPU_SREG_LDTR, cpl,\n\t\t\t\t\ttrue, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->es, VCPU_SREG_ES, cpl,\n\t\t\t\t\ttrue, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->cs, VCPU_SREG_CS, cpl,\n\t\t\t\t\ttrue, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ss, VCPU_SREG_SS, cpl,\n\t\t\t\t\ttrue, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\tret = __load_segment_descriptor(ctxt, tss->ds, VCPU_SREG_DS, cpl,\n\t\t\t\t\ttrue, NULL);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n\n\treturn X86EMUL_CONTINUE;\n}","target":0,"flaw_line_index":0,"hash":"2da027fa-5336-4cf4-ba78-1fdee46015ae","idx":"ad888c76-3e7a-418c-8423-82a2d26391e4"}
{"func_before":"        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_READ)) {\n            return;\n        }\n    }\n\n    DPRINTF(\"Data ready tag=0x%x len=%zd\\n\", r->req.tag, r->iov.iov_len);\n\n    n = r->iov.iov_len \/ 512;\n    r->sector += n;\n    r->sector_count -= n;\n    scsi_req_data(&r->req, r->iov.iov_len);\n}","target":1,"flaw_line_index":0,"hash":"bf2149f9-ce2b-4b60-b466-3dd4acfa32cf","idx":"64ae805f-fc9d-453c-b4dd-e82c3516124f"}
{"func_before":"        if (scsi_handle_rw_error(r, -ret, SCSI_REQ_STATUS_RETRY_READ)) {\n            return;\n        }\n    }\n\n    DPRINTF(\"Data ready tag=0x%x len=%zd\\n\", r->req.tag, r->qiov.size);\n\n    n = r->qiov.size \/ 512;\n    r->sector += n;\n    r->sector_count -= n;\n    scsi_req_data(&r->req, r->qiov.size);\n}","target":0,"flaw_line_index":0,"hash":"4d2babc3-21d7-4c82-ada0-ce9527842e10","idx":"501ac572-413f-4c81-ae13-0f7e167a7039"}
{"func_before":"\n\t*last = 0;\n\n\t\/* now that we have the line, handle it *\/\n\tif (blocktyp == PFA_ASCII) {\n\t    if (strncmp(line, \"currentfile eexec\", 17) == 0 && isspace(line[17])) {\n\t\tchar saved_p;\n\t\t\/* assert(line == buffer); *\/\n\t\tfor (line += 18; isspace(*line); line++)\n\t\t    \/* nada *\/;\n\t\tsaved_p = *line;\n\t\t*line = 0;\n\t\tfr->output_ascii(buffer, line - buffer);\n\t\t*line = saved_p;\n\n\t\/* check immediately after \"currentfile eexec\" for ASCII or binary *\/\n\tif (blocktyp == PFA_EEXEC_TEST) {\n\t    \/* 8.Feb.2004: fix bug if first character in a binary eexec block\n\t       is 0, reported by Werner Lemberg *\/\n\t    for (; line < last && isspace(*line); line++)\n\t\t\/* nada *\/;\n\t    if (line == last)\n\t\tcontinue;\n\t    else if (last >= line + 4 && isxdigit(line[0]) && isxdigit(line[1])\n\t\t     && isxdigit(line[2]) && isxdigit(line[3]))\n\t\tblocktyp = PFA_HEX;\n\t    else\n\t\tblocktyp = PFA_BINARY;\n\t    memmove(buffer, line, last - line + 1);\n\t    last = buffer + (last - line);","target":1,"flaw_line_index":0,"hash":"3af8266e-8a88-4ead-b65f-7a0b0d92649f","idx":"28abe927-4b10-4967-8f67-8920a54bdb65"}
{"func_before":"\n\t*last = 0;\n\n\t\/* now that we have the line, handle it *\/\n\tif (blocktyp == PFA_ASCII) {\n\t    if (strncmp(line, \"currentfile eexec\", 17) == 0 && isspace((unsigned char) line[17])) {\n\t\tchar saved_p;\n\t\t\/* assert(line == buffer); *\/\n\t\tfor (line += 18; isspace((unsigned char) *line); line++)\n\t\t    \/* nada *\/;\n\t\tsaved_p = *line;\n\t\t*line = 0;\n\t\tfr->output_ascii(buffer, line - buffer);\n\t\t*line = saved_p;\n\n\t\/* check immediately after \"currentfile eexec\" for ASCII or binary *\/\n\tif (blocktyp == PFA_EEXEC_TEST) {\n\t    \/* 8.Feb.2004: fix bug if first character in a binary eexec block\n\t       is 0, reported by Werner Lemberg *\/\n\t    for (; line < last && isspace((unsigned char) *line); line++)\n\t\t\/* nada *\/;\n\t    if (line == last)\n\t\tcontinue;\n\t    else if (last >= line + 4 && isxdigit((unsigned char) line[0])\n                     && isxdigit((unsigned char) line[1])\n\t\t     && isxdigit((unsigned char) line[2])\n                     && isxdigit((unsigned char) line[3]))\n\t\tblocktyp = PFA_HEX;\n\t    else\n\t\tblocktyp = PFA_BINARY;\n\t    memmove(buffer, line, last - line + 1);\n\t    last = buffer + (last - line);","target":0,"flaw_line_index":0,"hash":"6f24057c-30a9-4bc1-8fc7-abe95eeefd84","idx":"0e0e9fc1-cec5-4618-96bd-63ebd12a7f6b"}
{"func_before":"void ConnPoolImplBase::checkForIdleAndCloseIdleConnsIfDraining() {\n  if (is_draining_for_deletion_) {\n    closeIdleConnectionsForDrainingPool();\n  }\n\n  if (isIdleImpl()) {\n    ENVOY_LOG(debug, \"invoking idle callbacks - is_draining_for_deletion_={}\",\n              is_draining_for_deletion_);\n    for (const Instance::IdleCb& cb : idle_callbacks_) {\n      cb();\n    }\n  }\n}","target":1,"flaw_line_index":0,"hash":"c979394d-97d7-4fb0-b639-626951706684","idx":"0d54fb93-aa26-490a-96ce-bf1ad7e02637"}
{"func_before":"void ConnPoolImplBase::checkForIdleAndCloseIdleConnsIfDraining() {\n  if (is_draining_for_deletion_) {\n    closeIdleConnectionsForDrainingPool();\n  }\n\n  checkForIdleAndNotify();\n}","target":0,"flaw_line_index":0,"hash":"4c1367af-c261-41ef-b971-938735dfd875","idx":"4ed4c681-b4de-4a91-bdea-75280e18f8a1"}
{"func_before":"  absl::MutexLock lock(&mu_);\n\n  TF_ASSIGN_OR_RETURN(Platform * platform, LookupByNameLocked(target));\n  if (platform->Initialized()) {\n    return tsl::Status(\n        port::error::FAILED_PRECONDITION,\n        absl::StrCat(\"platform \\\"\", target, \"\\\" is already initialized\"));\n  }\n\n  TF_RETURN_IF_ERROR(platform->Initialize(options));\n","target":1,"flaw_line_index":0,"hash":"08472a76-2dbb-4776-90ae-b243c71629ab","idx":"c21a987c-7ee0-4417-9737-92512159a202"}
{"func_before":"  absl::MutexLock lock(&mu_);\n\n  TF_ASSIGN_OR_RETURN(Platform * platform, LookupByNameLocked(target));\n  if (platform->Initialized()) {\n    return tsl::Status(\n        tsl::error::FAILED_PRECONDITION,\n        absl::StrCat(\"platform \\\"\", target, \"\\\" is already initialized\"));\n  }\n\n  TF_RETURN_IF_ERROR(platform->Initialize(options));\n","target":0,"flaw_line_index":0,"hash":"99fa824e-aafb-4189-ab71-c4497899e2dc","idx":"31d2cde3-22cd-4103-8c77-6a49d4948191"}
{"func_before":"\tar2 = kzalloc(sizeof (struct ati_remote2), GFP_KERNEL);\n\tif (!ar2)\n\t\treturn -ENOMEM;\n\n\tar2->udev = udev;\n\n\tar2->intf[0] = interface;\n\tar2->ep[0] = &alt->endpoint[0].desc;\n\n\tar2->intf[1] = usb_ifnum_to_if(udev, 1);\n\tr = usb_driver_claim_interface(&ati_remote2_driver, ar2->intf[1], ar2);\n\tif (r)\n\t\tgoto fail1;\n\talt = ar2->intf[1]->cur_altsetting;\n\tar2->ep[1] = &alt->endpoint[0].desc;\n\n\tr = ati_remote2_urb_init(ar2);\n\tif (r)\n\t\tgoto fail2;\n\n\tar2->channel_mask = channel_mask;\n\tar2->mode_mask = mode_mask;\n\n\tr = ati_remote2_setup(ar2, ar2->channel_mask);\n\tif (r)\n\t\tgoto fail2;\n\n\tusb_make_path(udev, ar2->phys, sizeof(ar2->phys));\n\tstrlcat(ar2->phys, \"\/input0\", sizeof(ar2->phys));\n\n\tstrlcat(ar2->name, \"ATI Remote Wonder II\", sizeof(ar2->name));\n\n\tr = sysfs_create_group(&udev->dev.kobj, &ati_remote2_attr_group);\n\tif (r)\n\t\tgoto fail2;\n\n\tr = ati_remote2_input_init(ar2);\n\tif (r)\n\t\tgoto fail3;\n\n\tusb_set_intfdata(interface, ar2);\n\n\tinterface->needs_remote_wakeup = 1;\n\n\treturn 0;\n\n fail3:\n\tsysfs_remove_group(&udev->dev.kobj, &ati_remote2_attr_group);\n fail2:\n\tati_remote2_urb_cleanup(ar2);\n\tusb_driver_release_interface(&ati_remote2_driver, ar2->intf[1]);\n fail1:\n\tkfree(ar2);\n\n\treturn r;","target":1,"flaw_line_index":0,"hash":"1663b165-bdde-4e99-9cf8-7fae34ddc8d9","idx":"10c3d79a-81f8-439e-ae73-229ae6553e69"}
{"func_before":"\tif (!ar2)\n\t\treturn -ENOMEM;\n\n\tar2->udev = udev;\n\n\t\/* Sanity check, first interface must have an endpoint *\/\n\tif (alt->desc.bNumEndpoints < 1 || !alt->endpoint) {\n\t\tdev_err(&interface->dev,\n\t\t\t\"%s(): interface 0 must have an endpoint\\n\", __func__);\n\t\tr = -ENODEV;\n\t\tgoto fail1;\n\t}\n\tar2->intf[0] = interface;\n\tar2->ep[0] = &alt->endpoint[0].desc;\n\n\t\/* Sanity check, the device must have two interfaces *\/\n\tar2->intf[1] = usb_ifnum_to_if(udev, 1);\n\tif ((udev->actconfig->desc.bNumInterfaces < 2) || !ar2->intf[1]) {\n\t\tdev_err(&interface->dev, \"%s(): need 2 interfaces, found %d\\n\",\n\t\t\t__func__, udev->actconfig->desc.bNumInterfaces);\n\t\tr = -ENODEV;\n\t\tgoto fail1;\n\t}\n\n\tr = usb_driver_claim_interface(&ati_remote2_driver, ar2->intf[1], ar2);\n\tif (r)\n\t\tgoto fail1;\n\n\t\/* Sanity check, second interface must have an endpoint *\/\n\talt = ar2->intf[1]->cur_altsetting;\n\tif (alt->desc.bNumEndpoints < 1 || !alt->endpoint) {\n\t\tdev_err(&interface->dev,\n\t\t\t\"%s(): interface 1 must have an endpoint\\n\", __func__);\n\t\tr = -ENODEV;\n\t\tgoto fail2;\n\t}\n\tar2->ep[1] = &alt->endpoint[0].desc;\n\n\tr = ati_remote2_urb_init(ar2);\n\tif (r)\n\t\tgoto fail3;\n\n\tar2->channel_mask = channel_mask;\n\tar2->mode_mask = mode_mask;\n\n\tr = ati_remote2_setup(ar2, ar2->channel_mask);\n\tif (r)\n\t\tgoto fail3;\n\n\tusb_make_path(udev, ar2->phys, sizeof(ar2->phys));\n\tstrlcat(ar2->phys, \"\/input0\", sizeof(ar2->phys));\n\n\tstrlcat(ar2->name, \"ATI Remote Wonder II\", sizeof(ar2->name));\n\n\tr = sysfs_create_group(&udev->dev.kobj, &ati_remote2_attr_group);\n\tif (r)\n\t\tgoto fail3;\n\n\tr = ati_remote2_input_init(ar2);\n\tif (r)\n\t\tgoto fail4;\n\n\tusb_set_intfdata(interface, ar2);\n\n\tinterface->needs_remote_wakeup = 1;\n\n\treturn 0;\n\n fail4:\n\tsysfs_remove_group(&udev->dev.kobj, &ati_remote2_attr_group);\n fail3:\n\tati_remote2_urb_cleanup(ar2);\n fail2:\n\tusb_driver_release_interface(&ati_remote2_driver, ar2->intf[1]);\n fail1:\n\tkfree(ar2);\n\n\treturn r;","target":0,"flaw_line_index":0,"hash":"274c0319-e9f3-406a-b3ed-51513818d4de","idx":"8d1c7cb9-3838-4faf-b881-ac14c4db78cc"}
{"func_before":"inline bool CDRMessage::addBinaryPropertySeq(CDRMessage_t* msg, const BinaryPropertySeq& binary_properties, const std::string& property_limit)\n{\n    bool returnedValue = false;\n\n    if(msg->pos + 4 <  msg->max_size)\n    {\n        uint32_t position = 0;\n        uint32_t number_to_serialize = 0;\n        for(auto it = binary_properties.begin(); it != binary_properties.end() &&\n                it->name().compare(property_limit) != 0; ++it)","target":1,"flaw_line_index":0,"hash":"4d1cba9d-19e0-4b57-a099-6caa8e69bf1f","idx":"0925e97b-8025-4ab1-9693-7d41a6513f0c"}
{"func_before":"inline bool CDRMessage::addBinaryPropertySeq(CDRMessage_t* msg, const BinaryPropertySeq& binary_properties, const std::string& property_limit)\n{\n    assert(msg);\n\n    bool returnedValue = false;\n\n    if(msg->pos + 4 <=  msg->max_size)\n    {\n        uint32_t position = 0;\n        uint32_t number_to_serialize = 0;\n        for(auto it = binary_properties.begin(); it != binary_properties.end() &&\n                it->name().compare(property_limit) != 0; ++it)","target":0,"flaw_line_index":0,"hash":"c718d2b2-0124-4a15-bf76-4eccd71c9a09","idx":"7656bcc8-d6da-4b84-8cfc-f330d82fb078"}
{"func_before":"  void readDataAvailable(size_t len) noexcept override {\n    std::cerr << \"readDataAvailable, len \" << len << std::endl;\n\n    currentBuffer.length = len;\n\n    wcb_->setSocket(socket_);\n\n    \/\/ Write back the same data.\n    socket_->write(wcb_, currentBuffer.buffer, len, writeFlags);\n\n    buffers.push_back(currentBuffer);","target":1,"flaw_line_index":0,"hash":"076230ad-135e-4945-9d30-c7c016ab0675","idx":"4508f782-3d5b-471f-80e1-6a1bcf600793"}
{"func_before":"  void readDataAvailable(size_t len) noexcept override {\n    std::cerr << \"readDataAvailable, len \" << len << std::endl;\n\n    currentBuffer.length = len;\n\n    if (wcb_) {\n      wcb_->setSocket(socket_);\n    }\n\n    \/\/ Write back the same data.\n    socket_->write(wcb_, currentBuffer.buffer, len, writeFlags);\n\n    buffers.push_back(currentBuffer);","target":0,"flaw_line_index":0,"hash":"cbd92374-1819-47d7-b5c6-1202b9228a40","idx":"5ee70afd-4ec4-43c8-adf5-cfa6b6202713"}
{"func_before":"\t\tverdef->vd_ndx = READ16 (dfs, j)\n\t\tverdef->vd_cnt = READ16 (dfs, j)\n\t\tverdef->vd_hash = READ32 (dfs, j)\n\t\tverdef->vd_aux = READ32 (dfs, j)\n\t\tverdef->vd_next = READ32 (dfs, j)\n\t\tvstart += verdef->vd_aux;\n\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n","target":1,"flaw_line_index":0,"hash":"7caf97c7-5263-4b5d-a90c-ef28f24796bb","idx":"9825d5c1-a953-4a89-a9a4-2f2bca38dad0"}
{"func_before":"\t\tverdef->vd_ndx = READ16 (dfs, j)\n\t\tverdef->vd_cnt = READ16 (dfs, j)\n\t\tverdef->vd_hash = READ32 (dfs, j)\n\t\tverdef->vd_aux = READ32 (dfs, j)\n\t\tverdef->vd_next = READ32 (dfs, j)\n\t\tint vdaux = verdef->vd_aux;\n\t\tif (vdaux < 1) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n\t\tvstart += vdaux;\n\t\tif (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) {\n\t\t\tsdb_free (sdb_verdef);\n\t\t\tgoto out_error;\n\t\t}\n","target":0,"flaw_line_index":0,"hash":"fe40cf44-81c1-49d4-a7e7-6690f6d2c9de","idx":"c0e66b9f-e2e6-4e8d-a072-e85c3ae720d0"}
{"func_before":"  \/\/   with 0 output.\n  \/\/ * The delegation code need to be changed to handle 0 output ops. However\n  \/\/   everything still works fine when variable ops aren't used.\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 0);\n\n  const TfLiteTensor* input_resource_id_tensor =\n      GetInput(context, node, kInputVariableId);\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumElements(input_resource_id_tensor), 1);\n\n  return kTfLiteOk;\n}","target":1,"flaw_line_index":0,"hash":"9aad1917-2b87-4433-877e-0fd9d01df07e","idx":"a46c60c8-9b20-46ac-a94d-9c73c8623cd7"}
{"func_before":"  \/\/   with 0 output.\n  \/\/ * The delegation code need to be changed to handle 0 output ops. However\n  \/\/   everything still works fine when variable ops aren't used.\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 0);\n\n  const TfLiteTensor* input_resource_id_tensor;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputVariableId,\n                                          &input_resource_id_tensor));\n  TF_LITE_ENSURE_EQ(context, input_resource_id_tensor->type, kTfLiteInt32);\n  TF_LITE_ENSURE_EQ(context, NumElements(input_resource_id_tensor), 1);\n\n  return kTfLiteOk;\n}","target":0,"flaw_line_index":0,"hash":"c3f6e0a2-1b5c-4d7d-97cd-b628db6e2d48","idx":"00fb1e52-3e1d-4af5-856e-58103f0309e4"}
{"func_before":"jp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\n\tif (!(box = jas_malloc(sizeof(jp2_box_t)))) {\n\t\treturn 0;\n\t}\n\tmemset(box, 0, sizeof(jp2_box_t));\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}","target":1,"flaw_line_index":0,"hash":"70221e03-fd20-43e7-831e-aae694b055ef","idx":"88a4fb28-0d52-4380-b908-7deed1cc3c77"}
{"func_before":"jp2_box_t *jp2_box_create(int type)\n{\n\tjp2_box_t *box;\n\tjp2_boxinfo_t *boxinfo;\n\tif (!(box = jp2_box_create0())) {\n\t\treturn 0;\n\t}\n\tbox->type = type;\n\tbox->len = 0;\n\tif (!(boxinfo = jp2_boxinfolookup(type))) {\n\t\treturn 0;\n\t}","target":0,"flaw_line_index":0,"hash":"50c9a49a-f9b0-4372-a748-89801fa0255b","idx":"d84e22e4-6aa2-43e2-9559-01dfdc20bece"}
{"func_before":"mp_capable_print(netdissect_options *ndo,\n                 const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_capable *mpc = (const struct mp_capable *) opt;\n\n        if (!(opt_len == 12 && flags & TH_SYN) &&\n            !(opt_len == 20 && (flags & (TH_SYN | TH_ACK)) == TH_ACK))\n                return 0;\n\n        if (MP_CAPABLE_OPT_VERSION(mpc->sub_ver) != 0) {\n                ND_PRINT((ndo, \" Unknown Version (%d)\", MP_CAPABLE_OPT_VERSION(mpc->sub_ver)));","target":1,"flaw_line_index":0,"hash":"6556b215-94f3-4212-8fb0-66e29bf5ba3b","idx":"7e0de76a-b7a4-4984-b79d-68c9adf967de"}
{"func_before":"mp_capable_print(netdissect_options *ndo,\n                 const u_char *opt, u_int opt_len, u_char flags)\n{\n        const struct mp_capable *mpc = (const struct mp_capable *) opt;\n\n        if (!(opt_len == 12 && (flags & TH_SYN)) &&\n            !(opt_len == 20 && (flags & (TH_SYN | TH_ACK)) == TH_ACK))\n                return 0;\n\n        if (MP_CAPABLE_OPT_VERSION(mpc->sub_ver) != 0) {\n                ND_PRINT((ndo, \" Unknown Version (%d)\", MP_CAPABLE_OPT_VERSION(mpc->sub_ver)));","target":0,"flaw_line_index":0,"hash":"6c958b42-1937-4408-af11-db9c94c7c356","idx":"a6fb172f-b4d8-4b16-8a28-cbdafb7cd130"}
{"func_before":"Ta3AST_FromNodeObject(const node *n, PyCompilerFlags *flags,\n                     PyObject *filename, int feature_version,\n                     PyArena *arena)\n{\n    int i, j, k, num;\n    asdl_seq *stmts = NULL;\n    asdl_seq *type_ignores = NULL;\n    stmt_ty s;\n\n    c.c_arena = arena;\n    \/* borrowed reference *\/\n    c.c_filename = filename;\n    c.c_normalize = NULL;\n    c.c_normalize_args = NULL;\n    c.c_feature_version = feature_version;\n\n    if (TYPE(n) == encoding_decl)\n        n = CHILD(n, 0);\n\n                goto out;\n\n            for (i = 0; i < num; i++) {\n                type_ignore_ty ti = TypeIgnore(LINENO(CHILD(ch, i)), arena);\n                if (!ti)\n                    goto out;\n                asdl_seq_SET(type_ignores, i, ti);\n            }\n\n            res = Module(stmts, type_ignores, arena);\n            break;\n        case eval_input: {\n            goto out;\n    }\n out:\n    if (c.c_normalize) {\n        Py_DECREF(c.c_normalize);\n        PyTuple_SET_ITEM(c.c_normalize_args, 1, NULL);\n        Py_DECREF(c.c_normalize_args);\n    }\n    return res;\n}","target":1,"flaw_line_index":0,"hash":"1de91c2a-4fa6-45e2-a215-effcecb7ffc9","idx":"86853544-83c9-4d4d-b299-1540f12a65e3"}
{"func_before":"Ta3AST_FromNodeObject(const node *n, PyCompilerFlags *flags,\n                      PyObject *filename, int feature_version,\n                      PyArena *arena)\n{\n    int i, j, k, num;\n    asdl_seq *stmts = NULL;\n    asdl_seq *type_ignores = NULL;\n    stmt_ty s;\n    expr_ty ret, arg;\n\n    c.c_arena = arena;\n    \/* borrowed reference *\/\n    c.c_filename = filename;\n    c.c_normalize = NULL;\n    c.c_feature_version = feature_version;\n\n    if (TYPE(n) == encoding_decl)\n        n = CHILD(n, 0);\n\n                goto out;\n\n            for (i = 0; i < num; i++) {\n                type_ignore_ty ti = TypeIgnore(LINENO(CHILD(ch, i)), arena);\n                if (!ti)\n                   goto out;\n               asdl_seq_SET(type_ignores, i, ti);\n            }\n\n            res = Module(stmts, type_ignores, arena);\n            break;\n        case eval_input: {\n                         \"invalid node %d for Ta3AST_FromNode\", TYPE(n));\n            goto out;\n    }\n out:\n    if (c.c_normalize) {\n        Py_DECREF(c.c_normalize);\n    }\n    return res;\n}","target":0,"flaw_line_index":0,"hash":"ea0c0fc3-ada5-4c65-bdfb-d6574dfc2044","idx":"2dfc31c9-ece3-44a4-8c3f-ae7fdfb58cd6"}
{"func_before":"  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n\n  bool adj_x = op_context.params->adj_x;\n  bool adj_y = op_context.params->adj_y;\n\n  const TfLiteTensor* lhs_data = GetInput(context, node, kInputLHSTensor);\n  const TfLiteTensor* rhs_data = GetInput(context, node, kInputRHSTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  \/\/ Note that quantized inference requires that all tensors have their\n  \/\/ parameters set. This is usually done during quantized training.\n  if (lhs_data->type == kTfLiteInt8) {\n    double real_multiplier = 0.0;","target":1,"flaw_line_index":0,"hash":"5481f469-6d1e-4636-8fbb-1c8dc03022c6","idx":"4bca2e9b-ae1d-432a-94f8-ebb24e35c3ef"}
{"func_before":"  OpData* op_data = reinterpret_cast<OpData*>(node->user_data);\n\n  bool adj_x = op_context.params->adj_x;\n  bool adj_y = op_context.params->adj_y;\n\n  const TfLiteTensor* lhs_data;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputLHSTensor, &lhs_data));\n  const TfLiteTensor* rhs_data;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputRHSTensor, &rhs_data));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  \/\/ Note that quantized inference requires that all tensors have their\n  \/\/ parameters set. This is usually done during quantized training.\n  if (lhs_data->type == kTfLiteInt8) {\n    double real_multiplier = 0.0;","target":0,"flaw_line_index":0,"hash":"2767e003-90b5-422f-8bb1-92871d50a4fe","idx":"32358ce6-a7b9-4905-a000-c195247e4b17"}
{"func_before":"\n\tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(*sax));\n\t\tsax->sax25_family = AF_NETROM;\n\t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n\t\t\t      AX25_ADDR_LEN);\n\t}\n\n\tmsg->msg_namelen = sizeof(*sax);\n\n\tskb_free_datagram(sk, skb);\n\n\trelease_sock(sk);\n\treturn copied;","target":1,"flaw_line_index":0,"hash":"6ee71103-a2fa-4421-b31f-1049f07910b9","idx":"c4f6f856-1b45-4893-8a2a-9eb98754db49"}
{"func_before":"\tif (sax != NULL) {\n\t\tmemset(sax, 0, sizeof(*sax));\n\t\tsax->sax25_family = AF_NETROM;\n\t\tskb_copy_from_linear_data_offset(skb, 7, sax->sax25_call.ax25_call,\n\t\t\t      AX25_ADDR_LEN);\n\t\tmsg->msg_namelen = sizeof(*sax);\n\t}\n\n\tskb_free_datagram(sk, skb);\n\n\trelease_sock(sk);\n\treturn copied;","target":0,"flaw_line_index":0,"hash":"a2daae70-93a5-4a72-909e-a42d97b6626f","idx":"16cc220c-fa5c-4258-9706-da5085bb34c4"}
{"func_before":"tvb_get_manuf_name_if_known(tvbuff_t *tvb, gint offset)\n{\n    return get_manuf_name_if_known(tvb_get_ptr(tvb, offset, 3));\n}","target":1,"flaw_line_index":0,"hash":"f2aefe90-dd2a-4fb7-a251-3ceec45da4bb","idx":"c70fdf22-903e-4545-a672-042ebda2677b"}
{"func_before":"tvb_get_manuf_name_if_known(tvbuff_t *tvb, gint offset)\n{\n    guint8 buf[6] = { 0 };\n    tvb_memcpy(tvb, buf, offset, 3);\n    return get_manuf_name_if_known(buf, sizeof(buf));\n}","target":0,"flaw_line_index":0,"hash":"75d84b5e-a167-4c82-ae11-b91b8f01fdff","idx":"41c31af4-cc3d-47ea-9223-a72599fc8727"}
{"func_before":"static void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.time_page) {\n\t\tkvm_release_page_dirty(vcpu->arch.time_page);\n\t\tvcpu->arch.time_page = NULL;\n\t}\n}","target":1,"flaw_line_index":0,"hash":"c2341f30-429c-4a6b-adf0-d35108934f48","idx":"7e0c5426-fa8b-4d60-a77f-113f6dd1143e"}
{"func_before":"static void kvmclock_reset(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.pv_time_enabled = false;\n}","target":0,"flaw_line_index":0,"hash":"6b4f0715-5484-40ec-a1f5-8f55658330a6","idx":"fa9dfb6a-0a22-4771-b058-2ff2d4ba1f5a"}
{"func_before":"static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t\/* This is the main host *\/\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\t\/* That's us.  Be sure we keep track of the peer call number *\/\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&","target":1,"flaw_line_index":0,"hash":"13ec7a80-8aee-4377-9a1e-9f2de5a811f4","idx":"af5f97a9-d8b7-4429-83fc-a3c9995ab1d9"}
{"func_before":"static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t\/* This is the main host *\/\n\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n\t\t\t\/* That's us.  Be sure we keep track of the peer call number *\/\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&","target":0,"flaw_line_index":0,"hash":"7b27238c-dff8-4e62-8f75-65dc24f35a61","idx":"6fd8d90c-b594-40e0-bef1-48ca65d466ec"}
{"func_before":"      FloatTensorToQuantized<quint8>(filter_float, filter_min, filter_max);\n  AddInputFromArray<quint8>(image_quantized.shape(),\n                            image_quantized.flat<quint8>());\n  AddInputFromArray<quint8>(filter_quantized.shape(),\n                            filter_quantized.flat<quint8>());\n  AddInputFromArray<float>(TensorShape({1}), {image_min});\n  AddInputFromArray<float>(TensorShape({1}), {image_max});\n  AddInputFromArray<float>(TensorShape({1}), {filter_min});\n  AddInputFromArray<float>(TensorShape({1}), {filter_max});\n  TF_ASSERT_OK(RunOpKernel());\n  const int expected_width = image_width;\n  const int expected_height = image_height * filter_count;\n  Tensor expected_float(\n      DT_FLOAT, TensorShape({image_batch_count, expected_height, expected_width,","target":1,"flaw_line_index":0,"hash":"246a4107-5d52-46f1-95f4-2ab530a614be","idx":"1985b71e-906b-4f94-aaf5-eb246ceeccab"}
{"func_before":"      FloatTensorToQuantized<quint8>(filter_float, filter_min, filter_max);\n  AddInputFromArray<quint8>(image_quantized.shape(),\n                            image_quantized.flat<quint8>());\n  AddInputFromArray<quint8>(filter_quantized.shape(),\n                            filter_quantized.flat<quint8>());\n  AddInputFromArray<float>(TensorShape({}), {image_min});\n  AddInputFromArray<float>(TensorShape({}), {image_max});\n  AddInputFromArray<float>(TensorShape({}), {filter_min});\n  AddInputFromArray<float>(TensorShape({}), {filter_max});\n  TF_ASSERT_OK(RunOpKernel());\n  const int expected_width = image_width;\n  const int expected_height = image_height * filter_count;\n  Tensor expected_float(\n      DT_FLOAT, TensorShape({image_batch_count, expected_height, expected_width,","target":0,"flaw_line_index":0,"hash":"203ea19c-0f3f-4855-baaf-13753e883884","idx":"42ff4400-5417-4eed-8e62-1b545f34fdb2"}
{"func_before":"static void ed_mul_sim_plain(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\t\tconst bn_t m, const ed_t *t) {\n\tint i, l, l0, l1, n0, n1, w, gen;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;\n\ted_t t0[1 << (ED_WIDTH - 2)];\n\ted_t t1[1 << (ED_WIDTH - 2)];\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (ED_WIDTH - 2)); i++) {","target":1,"flaw_line_index":0,"hash":"554c0984-8aa6-4db5-9c31-3a8bf6e43362","idx":"a7261def-bddc-4892-a567-1a4bd0a520e7"}
{"func_before":"static void ed_mul_sim_plain(ed_t r, const ed_t p, const bn_t k, const ed_t q,\n\t\tconst bn_t m, const ed_t *t) {\n\tint i, n0, n1, w, gen;\n\tint8_t naf0[RLC_FP_BITS + 1], naf1[RLC_FP_BITS + 1], *_k, *_m;\n\ted_t t0[1 << (ED_WIDTH - 2)];\n\ted_t t1[1 << (ED_WIDTH - 2)];\n\tsize_t l, l0, l1;\n\n\tRLC_TRY {\n\t\tgen = (t == NULL ? 0 : 1);\n\t\tif (!gen) {\n\t\t\tfor (i = 0; i < (1 << (ED_WIDTH - 2)); i++) {","target":0,"flaw_line_index":0,"hash":"184eded5-9deb-4281-8e15-102764bdb718","idx":"3b5c0105-b4b3-442d-8892-5b0896e12263"}
{"func_before":"\t\t}\n\t}\n\n\t\/* initial estimate *\/\n\tif (oldlen < 64) {\n\t\tmaxlen = 128;\t\n\t} else {\n\t\tmaxlen = 2 * oldlen;\n\t\tif (maxlen < oldlen) {\n\t\t\tzend_error_noreturn(E_ERROR, \"Input string is too long\");\n\t\t\treturn NULL;","target":1,"flaw_line_index":0,"hash":"a787d9ac-9f8c-4c99-966c-071e420d0d7d","idx":"dd385f16-f537-4a37-af2c-ce7a361cc18e"}
{"func_before":"\t\t}\n\t}\n\n\t\/* initial estimate *\/\n\tif (oldlen < 64) {\n\t\tmaxlen = 128;\n\t} else {\n\t\tmaxlen = 2 * oldlen;\n\t\tif (maxlen < oldlen) {\n\t\t\tzend_error_noreturn(E_ERROR, \"Input string is too long\");\n\t\t\treturn NULL;","target":0,"flaw_line_index":0,"hash":"f3c57173-5992-43a2-b836-b029c736d0eb","idx":"e49995cb-753e-4063-9f9a-6251afaee1ea"}
{"func_before":"    {\n#ifdef DO_NOT_COPY_TRUSTED_CERTS_STRING\n        result = HTTPAPI_OK;\n        http_instance->certificate = (char*)value;\n#else\n        int len;\n\n        if (http_instance->certificate)\n        {\n            free(http_instance->certificate);\n        }\n\n        len = (int)strlen((char*)value);\n        http_instance->certificate = (char*)malloc((len + 1) * sizeof(char));\n        if (http_instance->certificate == NULL)\n        {\n            \/*Codes_SRS_HTTPAPI_COMPACT_21_062: [ If any memory allocation get fail, the HTTPAPI_SetOption shall return HTTPAPI_ALLOC_FAILED. ]*\/\n            result = HTTPAPI_ALLOC_FAILED;\n            LogInfo(\"unable to allocate memory for the certificate in HTTPAPI_SetOption\");\n        }\n#endif \/\/ DO_NOT_COPY_TRUSTED_CERTS_STRING\n    }\n    else if (strcmp(SU_OPTION_X509_CERT, optionName) == 0 || strcmp(OPTION_X509_ECC_CERT, optionName) == 0)\n    {\n        int len;\n        if (http_instance->x509ClientCertificate)\n        {\n            free(http_instance->x509ClientCertificate);\n        }\n\n        len = (int)strlen((char*)value);\n        http_instance->x509ClientCertificate = (char*)malloc((len + 1) * sizeof(char));\n        if (http_instance->x509ClientCertificate == NULL)\n        {\n            \/*Codes_SRS_HTTPAPI_COMPACT_21_062: [ If any memory allocation get fail, the HTTPAPI_SetOption shall return HTTPAPI_ALLOC_FAILED. ]*\/\n            result = HTTPAPI_ALLOC_FAILED;\n            LogInfo(\"unable to allocate memory for the client certificate in HTTPAPI_SetOption\");\n            result = HTTPAPI_OK;\n        }\n    }\n    else if (strcmp(SU_OPTION_X509_PRIVATE_KEY, optionName) == 0 || strcmp(OPTION_X509_ECC_KEY, optionName) == 0)\n    {\n        int len;\n        if (http_instance->x509ClientPrivateKey)\n        {\n            free(http_instance->x509ClientPrivateKey);\n        }\n\n        len = (int)strlen((char*)value);\n        http_instance->x509ClientPrivateKey = (char*)malloc((len + 1) * sizeof(char));\n        if (http_instance->x509ClientPrivateKey == NULL)\n        {\n            \/*Codes_SRS_HTTPAPI_COMPACT_21_062: [ If any memory allocation get fail, the HTTPAPI_SetOption shall return HTTPAPI_ALLOC_FAILED. ]*\/\n            result = HTTPAPI_ALLOC_FAILED;\n            LogInfo(\"unable to allocate memory for the client private key in HTTPAPI_SetOption\");","target":1,"flaw_line_index":0,"hash":"6c3663b7-98cf-4dc5-9ff8-59d6bc595b4f","idx":"e0c54800-2bc8-4175-9bbc-98448164b005"}
{"func_before":"    else if (strcmp(OPTION_TRUSTED_CERT, optionName) == 0)\n    {\n#ifdef DO_NOT_COPY_TRUSTED_CERTS_STRING\n        result = HTTPAPI_OK;\n        http_instance->certificate = (char*)value;\n#else\n\n        if (http_instance->certificate)\n        {\n            free(http_instance->certificate);\n        }\n\n        size_t len = strlen((char*)value);\n        size_t malloc_size = safe_add_size_t(len, 1);\n        malloc_size = safe_multiply_size_t(malloc_size, sizeof(char));\n        if (malloc_size == SIZE_MAX)\n        {\n            LogError(\"Invalid malloc size\");\n            http_instance->certificate = NULL;\n        }\n        else\n        {\n            http_instance->certificate = (char*)malloc(malloc_size);\n        }\n\n        if (http_instance->certificate == NULL)\n        {\n            \/*Codes_SRS_HTTPAPI_COMPACT_21_062: [ If any memory allocation get fail, the HTTPAPI_SetOption shall return HTTPAPI_ALLOC_FAILED. ]*\/\n            result = HTTPAPI_ALLOC_FAILED;\n            LogInfo(\"unable to allocate memory for the certificate in HTTPAPI_SetOption\");\n            result = HTTPAPI_OK;\n        }\n#endif \/\/ DO_NOT_COPY_TRUSTED_CERTS_STRING\n    }\n    else if (strcmp(SU_OPTION_X509_CERT, optionName) == 0 || strcmp(OPTION_X509_ECC_CERT, optionName) == 0)\n    {\n        if (http_instance->x509ClientCertificate)\n        {\n            free(http_instance->x509ClientCertificate);\n        }\n\n        size_t len = strlen((char*)value);\n        size_t malloc_size = safe_add_size_t(len, 1);\n        malloc_size = safe_multiply_size_t(malloc_size, sizeof(char));\n        if (malloc_size == SIZE_MAX)\n        {\n            LogError(\"Invalid malloc size\");\n            http_instance->x509ClientCertificate = NULL;\n        }\n        else\n        {\n            http_instance->x509ClientCertificate = (char*)malloc(malloc_size);\n        }\n\n        if (http_instance->x509ClientCertificate == NULL)\n        {\n            \/*Codes_SRS_HTTPAPI_COMPACT_21_062: [ If any memory allocation get fail, the HTTPAPI_SetOption shall return HTTPAPI_ALLOC_FAILED. ]*\/\n            result = HTTPAPI_ALLOC_FAILED;\n            LogInfo(\"unable to allocate memory for the client certificate in HTTPAPI_SetOption\");\n            (void)strcpy(http_instance->x509ClientCertificate, (const char*)value);\n            result = HTTPAPI_OK;\n        }\n    }\n    else if (strcmp(SU_OPTION_X509_PRIVATE_KEY, optionName) == 0 || strcmp(OPTION_X509_ECC_KEY, optionName) == 0)\n    {\n        if (http_instance->x509ClientPrivateKey)\n        {\n            free(http_instance->x509ClientPrivateKey);\n        }\n\n        size_t len = strlen((char*)value);\n        size_t malloc_size = safe_add_size_t(len, 1);\n        malloc_size = safe_multiply_size_t(malloc_size, sizeof(char));\n        if (malloc_size == SIZE_MAX)\n        {\n            LogError(\"Invalid malloc size\");\n            http_instance->x509ClientPrivateKey = NULL;\n        }\n        else\n        {\n            http_instance->x509ClientPrivateKey = (char*)malloc(malloc_size);\n        }\n\n        if (http_instance->x509ClientPrivateKey == NULL)\n        {\n            \/*Codes_SRS_HTTPAPI_COMPACT_21_062: [ If any memory allocation get fail, the HTTPAPI_SetOption shall return HTTPAPI_ALLOC_FAILED. ]*\/\n            result = HTTPAPI_ALLOC_FAILED;\n            LogInfo(\"unable to allocate memory for the client private key in HTTPAPI_SetOption\");","target":0,"flaw_line_index":0,"hash":"b3b16b2f-a89d-4a1a-af8b-add1d3fde71c","idx":"3aa84cfc-e35b-4661-a630-965cbd7778d2"}
{"func_before":"flatpak_proxy_client_init (FlatpakProxyClient *client)\n{\n  init_side (client, &client->client_side);\n  init_side (client, &client->bus_side);\n\n  client->auth_end_offset = AUTH_END_INIT_OFFSET;\n  client->rewrite_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);\n  client->get_owner_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);\n  client->unique_id_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n}","target":1,"flaw_line_index":0,"hash":"13f12849-a55f-47a4-9f16-1f9cfa4971d2","idx":"0b047e82-2063-4494-970b-0d91314bba08"}
{"func_before":"flatpak_proxy_client_init (FlatpakProxyClient *client)\n{\n  init_side (client, &client->client_side);\n  init_side (client, &client->bus_side);\n\n  client->auth_buffer = g_byte_array_new ();\n  client->rewrite_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);\n  client->get_owner_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);\n  client->unique_id_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL);\n}","target":0,"flaw_line_index":0,"hash":"e5f28934-52ca-45c1-b745-1d9e59e2e51f","idx":"de34e714-1ca9-456f-b407-0e94654e53b3"}
{"func_before":"  }\n\n  header_parsing_state_ = HeaderParsingState::Value;\n  current_header_value_.append(data, length);\n\n  const uint32_t total =\n      current_header_field_.size() + current_header_value_.size() + current_header_map_->byteSize();\n  if (total > (max_request_headers_kb_ * 1024)) {\n    error_code_ = Http::Code::RequestHeaderFieldsTooLarge;\n    sendProtocolError();\n    throw CodecProtocolException(\"headers size exceeds limit\");\n  }","target":1,"flaw_line_index":0,"hash":"7dcd3d3f-26d2-4795-b5c6-bfc5f0ff0f8e","idx":"81b49752-ae20-4b4d-acee-aaa4335e6ef6"}
{"func_before":"  }\n\n  header_parsing_state_ = HeaderParsingState::Value;\n  current_header_value_.append(data, length);\n\n  \/\/ Verify that the cached value in byte size exists.\n  ASSERT(current_header_map_->byteSize().has_value());\n  const uint32_t total = current_header_field_.size() + current_header_value_.size() +\n                         current_header_map_->byteSize().value();\n  if (total > (max_request_headers_kb_ * 1024)) {\n    error_code_ = Http::Code::RequestHeaderFieldsTooLarge;\n    sendProtocolError();\n    throw CodecProtocolException(\"headers size exceeds limit\");\n  }","target":0,"flaw_line_index":0,"hash":"799e0177-0120-40d9-81e1-b54858747720","idx":"89dcfc8f-280f-4fce-8159-fc4f2c9137b1"}
{"func_before":"GF_Err gf_isom_get_text_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex, GF_TextSampleDescriptor **out_desc)\n{\n\tGF_TrackBox *trak;\n\tu32 i;\n\tBool is_qt_text = GF_FALSE;\n\tGF_Tx3gSampleEntryBox *txt;\n\n\tif (!descriptionIndex || !out_desc) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tif (!txt) return GF_BAD_PARAM;\n\tswitch (txt->type) {\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tis_qt_text = GF_TRUE;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t(*out_desc) = (GF_TextSampleDescriptor *) gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\tif (! (*out_desc) ) return GF_OUT_OF_MEM;\n\t(*out_desc)->back_color = txt->back_color;\n\t(*out_desc)->default_pos = txt->default_box;\n\t(*out_desc)->default_style = txt->default_style;\n\t(*out_desc)->displayFlags = txt->displayFlags;\n\t(*out_desc)->vert_justif = txt->vertical_justification;\n\t(*out_desc)->horiz_justif = txt->horizontal_justification;\n\tif (is_qt_text) {\n\t\tGF_TextSampleEntryBox *qt_txt = (GF_TextSampleEntryBox *) txt;\n\t\tif (qt_txt->textName) {\n\t\t\t(*out_desc)->font_count = 1;\n\t\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord));\n\t\t\t(*out_desc)->fonts[0].fontName = gf_strdup(qt_txt->textName);\n\t\t}\n\t} else {\n\t\t(*out_desc)->font_count = txt->font_table->entry_count;\n\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * txt->font_table->entry_count);\n\t\tfor (i=0; i<txt->font_table->entry_count; i++) {\n\t\t\t(*out_desc)->fonts[i].fontID = txt->font_table->fonts[i].fontID;\n\t\t\tif (txt->font_table->fonts[i].fontName)","target":1,"flaw_line_index":0,"hash":"69d3dd70-906c-4947-90a0-0fe3e7eb567c","idx":"85d0d8cc-41a6-4e0a-afe6-fc5ceeede73d"}
{"func_before":"GF_Err gf_isom_get_text_description(GF_ISOFile *movie, u32 trackNumber, u32 descriptionIndex, GF_TextSampleDescriptor **out_desc)\n{\n\tGF_TrackBox *trak;\n\tu32 i;\n\tGF_Tx3gSampleEntryBox *txt = NULL;\n\tGF_TextSampleEntryBox *qt_txt = NULL;\n\tif (!descriptionIndex || !out_desc) return GF_BAD_PARAM;\n\n\ttrak = gf_isom_get_track_from_file(movie, trackNumber);\n\tif (!trak || !trak->Media) return GF_BAD_PARAM;\n\n\tif (!txt) return GF_BAD_PARAM;\n\tswitch (txt->type) {\n\tcase GF_ISOM_BOX_TYPE_TX3G:\n\t\tbreak;\n\tcase GF_ISOM_BOX_TYPE_TEXT:\n\t\tqt_txt = (GF_TextSampleEntryBox *)txt;\n\t\ttxt = NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\t(*out_desc) = (GF_TextSampleDescriptor *) gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\tif (! (*out_desc) ) return GF_OUT_OF_MEM;\n\n\tif (qt_txt) {\n\t\t(*out_desc)->back_color = rgb_48_to_32(qt_txt->background_color);\n\t\t(*out_desc)->default_pos = qt_txt->default_box;\n\t\t(*out_desc)->default_style.style_flags = qt_txt->fontFace;\n\t\t(*out_desc)->default_style.text_color = rgb_48_to_32(qt_txt->foreground_color);\n\t\t(*out_desc)->displayFlags = qt_txt->displayFlags;\n\t\t(*out_desc)->vert_justif = -1;\n\t\t(*out_desc)->horiz_justif = qt_txt->textJustification;\n\t\tif (qt_txt->textName) {\n\t\t\t(*out_desc)->font_count = 1;\n\t\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord));\n\t\t\t(*out_desc)->fonts[0].fontName = gf_strdup(qt_txt->textName);\n\t\t}\n\t} else {\n\t\t(*out_desc)->back_color = txt->back_color;\n\t\t(*out_desc)->default_pos = txt->default_box;\n\t\t(*out_desc)->default_style = txt->default_style;\n\t\t(*out_desc)->displayFlags = txt->displayFlags;\n\t\t(*out_desc)->vert_justif = txt->vertical_justification;\n\t\t(*out_desc)->horiz_justif = txt->horizontal_justification;\n\t\t(*out_desc)->font_count = txt->font_table->entry_count;\n\t\t(*out_desc)->fonts = (GF_FontRecord *) gf_malloc(sizeof(GF_FontRecord) * txt->font_table->entry_count);\n\t\tfor (i=0; i<txt->font_table->entry_count; i++) {\n\t\t\t(*out_desc)->fonts[i].fontID = txt->font_table->fonts[i].fontID;\n\t\t\tif (txt->font_table->fonts[i].fontName)","target":0,"flaw_line_index":0,"hash":"c946c015-eeec-4285-b9a6-79b589c72ec6","idx":"3a29fda5-9422-4af0-8720-af7649bf9e00"}
{"func_before":"    memset(reply.enc_part.ciphertext.data, 0,\n           reply.enc_part.ciphertext.length);\n    free(reply.enc_part.ciphertext.data);\n\ncleanup:\n    assert(status != NULL);\n    if (reply_key)\n        krb5_free_keyblock(kdc_context, reply_key);\n    if (errcode)\n        emsg = krb5_get_error_message (kdc_context, errcode);\n","target":1,"flaw_line_index":0,"hash":"48b84a79-d24a-4b8b-9fff-42ef62484f4e","idx":"3c1c2147-97c2-4726-98ef-74987d6de11c"}
{"func_before":"    memset(reply.enc_part.ciphertext.data, 0,\n           reply.enc_part.ciphertext.length);\n    free(reply.enc_part.ciphertext.data);\n\ncleanup:\n    if (status == NULL)\n        status = \"UNKNOWN_REASON\";\n    if (reply_key)\n        krb5_free_keyblock(kdc_context, reply_key);\n    if (errcode)\n        emsg = krb5_get_error_message (kdc_context, errcode);\n","target":0,"flaw_line_index":0,"hash":"e7b5a886-4cde-44b3-8ca0-6a9c0c03a88f","idx":"3a856c0e-b3ea-4bc3-8ca7-e0c49eaf973c"}
{"func_before":"void CNativeControlEmbed::CreateObjectInContext(const std::string& name, JSSmart<CJSContext> context)\n{\n    v8::Isolate* current = CV8Worker::GetCurrent();\n    context->m_internal->m_global->Set(current, name.c_str(), v8::FunctionTemplate::New(current, NSNativeControl::CreateNativeObject));\n}","target":1,"flaw_line_index":0,"hash":"4bdddb4f-4405-4769-a7f2-fe09dfe3b4ba","idx":"d59b5b37-26c0-4556-bdd2-f5f3cd53dc64"}
{"func_before":"void CNativeControlEmbed::CreateObjectInContext(const std::string& name, JSSmart<CJSContext> context)\n{\n\tv8::Isolate* current = CV8Worker::GetCurrent();\n\tcontext->m_internal->m_global->Set(current, name.c_str(), v8::FunctionTemplate::New(current, NSNativeControl::CreateNativeObject));\n}","target":0,"flaw_line_index":0,"hash":"5374c17c-1a07-4369-9106-97f777e704ec","idx":"d3be871c-c539-4357-a018-49d9617196c0"}
{"func_before":"                    auto ret = LZ4_decompress_safe(reinterpret_cast<const char*>(in.data()), reinterpret_cast<char*>(out.data()),\n                                                   in.size(), out.size());\n                    if (ret < 0) {\n                        throw std::runtime_error(\"CQL frame LZ4 uncompression failure\");\n                    }\n                    return out.size();\n                });\n                on_compression_buffer_use();\n                return uncomp;\n            });\n        } else if (_compression == cql_compression::snappy) {","target":1,"flaw_line_index":0,"hash":"fe303da6-29ba-4356-be17-0103cf89b15f","idx":"ab4bee0a-d24e-433a-b702-7c21be8bcb2b"}
{"func_before":"                    auto ret = LZ4_decompress_safe(reinterpret_cast<const char*>(in.data()), reinterpret_cast<char*>(out.data()),\n                                                   in.size(), out.size());\n                    if (ret < 0) {\n                        throw std::runtime_error(\"CQL frame LZ4 uncompression failure\");\n                    }\n                    if (ret != out.size()) {\n                        throw std::runtime_error(\"Malformed CQL frame - provided uncompressed size different than real uncompressed size\");\n                    }\n                    return static_cast<size_t>(ret);\n                });\n                on_compression_buffer_use();\n                return uncomp;\n            });\n        } else if (_compression == cql_compression::snappy) {","target":0,"flaw_line_index":0,"hash":"8900081a-3d93-407d-b610-dd11b01e7044","idx":"4f18d91a-d782-4191-bc59-69f7f901cb7b"}
{"func_before":"static mongo_message *mongo_message_create( int len , int id , int responseTo , int op ) {\n    mongo_message *mm = ( mongo_message * )bson_malloc( len );\n\n    if ( !id )\n        id = rand();\n\n    \/* native endian (converted on send) *\/\n    mm->head.len = len;\n    mm->head.id = id;\n    mm->head.responseTo = responseTo;\n    mm->head.op = op;\n\n    return mm;","target":1,"flaw_line_index":0,"hash":"005ab0e3-f40c-4a06-aa6e-b878e7675399","idx":"f8305dea-0527-4199-b58a-2438f023246f"}
{"func_before":"static mongo_message *mongo_message_create( size_t len , int id , int responseTo , int op ) {\n    mongo_message *mm = ( mongo_message * )bson_malloc( len );\n\n    if ( !id )\n        id = rand();\n\n    \/* native endian (converted on send) *\/\n    mm->head.len = ( int )len;\n    mm->head.id = id;\n    mm->head.responseTo = responseTo;\n    mm->head.op = op;\n\n    return mm;","target":0,"flaw_line_index":0,"hash":"99c84b7c-5ba2-4a65-9d3f-191ad172db81","idx":"cc64530f-d215-4a48-992a-a04fd3a544de"}
{"func_before":"    \/* Collect section files and check for duplicates. *\/\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                    xkb_file_type_to_string(file->file_type));\n            continue;\n        }\n\n        if (files[file->file_type]) {\n            log_err(ctx,","target":1,"flaw_line_index":0,"hash":"01d74725-bcb4-4746-8831-27daa284fa1b","idx":"0597d692-9941-4635-bbbb-9204df54085d"}
{"func_before":"    \/* Collect section files and check for duplicates. *\/\n    for (file = (XkbFile *) file->defs; file;\n         file = (XkbFile *) file->common.next) {\n        if (file->file_type < FIRST_KEYMAP_FILE_TYPE ||\n            file->file_type > LAST_KEYMAP_FILE_TYPE) {\n            if (file->file_type == FILE_TYPE_GEOMETRY) {\n                log_vrb(ctx, 1,\n                        \"Geometry sections are not supported; ignoring\\n\");\n            } else {\n                log_err(ctx, \"Cannot define %s in a keymap file\\n\",\n                        xkb_file_type_to_string(file->file_type));\n            }\n            continue;\n        }\n\n        if (files[file->file_type]) {\n            log_err(ctx,","target":0,"flaw_line_index":0,"hash":"0d30087a-7535-4671-a101-05b7937d6f93","idx":"2bc2c796-d3ef-4f59-b579-85d8698eb973"}
{"func_before":"\t\tmigration_entry_wait(mm, pmd, address);\n\t\tgoto retry;\n\t}\n\tif ((flags & FOLL_NUMA) && pte_protnone(pte))\n\t\tgoto no_page;\n\tif ((flags & FOLL_WRITE) && !pte_write(pte)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\treturn NULL;\n\t}\n\n\tpage = vm_normal_page(vma, address, pte);","target":1,"flaw_line_index":0,"hash":"083129fe-5943-45cc-abed-d9f241750232","idx":"e23d0329-0c4b-4d0d-943a-68279cc07f2d"}
{"func_before":"\t\tmigration_entry_wait(mm, pmd, address);\n\t\tgoto retry;\n\t}\n\tif ((flags & FOLL_NUMA) && pte_protnone(pte))\n\t\tgoto no_page;\n\tif ((flags & FOLL_WRITE) && !can_follow_write_pte(pte, flags)) {\n\t\tpte_unmap_unlock(ptep, ptl);\n\t\treturn NULL;\n\t}\n\n\tpage = vm_normal_page(vma, address, pte);","target":0,"flaw_line_index":0,"hash":"811ab2de-1460-4638-ab31-d87c645ffe79","idx":"dc12b8e2-6c60-4b23-a5a3-516c8adc47c7"}
{"func_before":"void ep2_mul_basic(ep2_t r, const ep2_t p, const bn_t k) {\n\tint i, l;\n\tep2_t t;\n\n\tep2_null(t);\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\t\tep2_copy(t, p);\n\t\t} else {\n\t\t\tep2_set_infty(t);\n\t\t}\n\n\t\tfor (i = l - 2; i >= 0; i--) {\n\t\t\tep2_dbl(t, t);\n\t\t\tif (bn_get_bit(k, i)) {\n\t\t\t\tep2_add(t, t, p);\n\t\t\t}\n\t\t}","target":1,"flaw_line_index":0,"hash":"22485520-e025-480e-9280-48ca02f9fe14","idx":"95e3f3ca-8be5-47c3-a146-9c4a8b96f445"}
{"func_before":"void ep2_mul_basic(ep2_t r, const ep2_t p, const bn_t k) {\n\tsize_t l;\n\tep2_t t;\n\n\tep2_null(t);\n\n\tif (bn_is_zero(k) || ep2_is_infty(p)) {\n\t\t\tep2_copy(t, p);\n\t\t} else {\n\t\t\tep2_set_infty(t);\n\t\t}\n\n\t\tfor (int i = l - 2; i >= 0; i--) {\n\t\t\tep2_dbl(t, t);\n\t\t\tif (bn_get_bit(k, i)) {\n\t\t\t\tep2_add(t, t, p);\n\t\t\t}\n\t\t}","target":0,"flaw_line_index":0,"hash":"7df3b8b9-6c2e-4c5a-b708-f5549f8279c8","idx":"a40010d7-7d71-4d91-adf1-c8b502f95550"}
{"func_before":"Ta3AST_FromNode(const node *n, PyCompilerFlags *flags, const char *filename_str,\n               int feature_version, PyArena *arena)\n{\n    mod_ty mod;\n    PyObject *filename;\n    filename = PyUnicode_DecodeFSDefault(filename_str);\n    if (filename == NULL)","target":1,"flaw_line_index":0,"hash":"da4d5ea5-ed74-4cf7-8396-47185478b01d","idx":"635f9032-1834-4309-ab92-7c9c23bcc0ac"}
{"func_before":"Ta3AST_FromNode(const node *n, PyCompilerFlags *flags, const char *filename_str,\n                int feature_version, PyArena *arena)\n{\n    mod_ty mod;\n    PyObject *filename;\n    filename = PyUnicode_DecodeFSDefault(filename_str);\n    if (filename == NULL)","target":0,"flaw_line_index":0,"hash":"d8d6de19-ac28-4fb9-bc49-f212805f1ede","idx":"1f8f838c-3b2e-47d8-ac9e-4e0f5afe8984"}
{"func_before":"\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct rusage r;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t}\n\n\tif (!err) {\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;","target":1,"flaw_line_index":0,"hash":"45352f0b-882d-4dc0-930d-553b19594d23","idx":"3ca2e63c-10d9-4f16-a599-dcebc0fefe9b"}
{"func_before":"{\n\tstruct rusage r;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);\n\tint signo = 0;\n\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t\tif (ru && copy_to_user(ru, &r, sizeof(struct rusage)))\n\t\t\treturn -EFAULT;\n\t}\n\tif (!infop)\n\t\treturn err;","target":0,"flaw_line_index":0,"hash":"5e5e69e0-aae7-401b-a0e9-2c46891bf535","idx":"4706e4c6-136b-4c5a-b6fc-60d18fd67a98"}
{"func_before":"\t\tgoto error;\n\t}\n\n\t\/* Does the number of components indicated in the IHDR box match\n\t  the value specified in the code stream? *\/\n\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(uint,\n\t  jas_image_numcmpts(dec->image))) {\n\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t}\n\n\t\/* At least one component must be present. *\/\n\t}\n\n\t\/* Determine if all components have the same data type. *\/\n\tsamedtype = true;\n\tdtype = jas_image_cmptdtype(dec->image, 0);\n\tfor (i = 1; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {\n\t\t\tsamedtype = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\t}\n\n\tif (dec->bpcc) {\n\t\t\/* Is the number of components indicated in the BPCC box\n\t\t  consistent with the code stream data? *\/\n\t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(uint, jas_image_numcmpts(\n\t\t  dec->image))) {\n\t\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t\t}\n\t\t\/* Is the component data type information indicated in the BPCC\n\t\t  box consistent with the code stream data? *\/\n\t\tif (!samedtype) {\n\t\t\tfor (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image));\n\t\t\t  ++i) {\n\t\t\t\tif (jas_image_cmptdtype(dec->image, i) !=\n\t\t\t\t  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {\n\t\t\t\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t\t\t\t}\n\t}\n\n\t\/* Determine the number of channels (which is essentially the number\n\t  of components after any palette mappings have been applied). *\/\n\tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :\n\t  JAS_CAST(uint, jas_image_numcmpts(dec->image));\n\n\t\/* Perform a basic sanity check on the CMAP box if present. *\/\n\tif (dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t\/* Is the component number reasonable? *\/\n\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(uint,\n\t\t\t  jas_image_numcmpts(dec->image))) {\n\t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t\/* Is the LUT index reasonable? *\/\n\t\t}\n\t}\n\n\t\/* Mark all components as being of unknown type. *\/\n\n\tfor (i = 0; i < JAS_CAST(uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n\t}\n\n\t\/* Determine the type of each component. *\/\n\tif (dec->cdef) {","target":1,"flaw_line_index":0,"hash":"a58f64b4-8d6f-47a7-bf60-033fd2e07b67","idx":"946636a3-55bb-4f8c-87fd-2495bdecec73"}
{"func_before":"\t\tgoto error;\n\t}\n\n\t\/* Does the number of components indicated in the IHDR box match\n\t  the value specified in the code stream? *\/\n\tif (dec->ihdr->data.ihdr.numcmpts != JAS_CAST(jas_uint,\n\t  jas_image_numcmpts(dec->image))) {\n\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t}\n\n\t\/* At least one component must be present. *\/\n\t}\n\n\t\/* Determine if all components have the same data type. *\/\n\tsamedtype = true;\n\tdtype = jas_image_cmptdtype(dec->image, 0);\n\tfor (i = 1; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tif (jas_image_cmptdtype(dec->image, i) != dtype) {\n\t\t\tsamedtype = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\t}\n\n\tif (dec->bpcc) {\n\t\t\/* Is the number of components indicated in the BPCC box\n\t\t  consistent with the code stream data? *\/\n\t\tif (dec->bpcc->data.bpcc.numcmpts != JAS_CAST(jas_uint, jas_image_numcmpts(\n\t\t  dec->image))) {\n\t\t\tjas_eprintf(\"warning: number of components mismatch\\n\");\n\t\t}\n\t\t\/* Is the component data type information indicated in the BPCC\n\t\t  box consistent with the code stream data? *\/\n\t\tif (!samedtype) {\n\t\t\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\t\t\t  ++i) {\n\t\t\t\tif (jas_image_cmptdtype(dec->image, i) !=\n\t\t\t\t  JP2_BPCTODTYPE(dec->bpcc->data.bpcc.bpcs[i])) {\n\t\t\t\t\tjas_eprintf(\"warning: component data type mismatch\\n\");\n\t\t\t\t}\n\t}\n\n\t\/* Determine the number of channels (which is essentially the number\n\t  of components after any palette mappings have been applied). *\/\n\tdec->numchans = dec->cmap ? dec->cmap->data.cmap.numchans :\n\t  JAS_CAST(jas_uint, jas_image_numcmpts(dec->image));\n\n\t\/* Perform a basic sanity check on the CMAP box if present. *\/\n\tif (dec->cmap) {\n\t\tfor (i = 0; i < dec->numchans; ++i) {\n\t\t\t\/* Is the component number reasonable? *\/\n\t\t\tif (dec->cmap->data.cmap.ents[i].cmptno >= JAS_CAST(jas_uint,\n\t\t\t  jas_image_numcmpts(dec->image))) {\n\t\t\t\tjas_eprintf(\"error: invalid component number in CMAP box\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t\/* Is the LUT index reasonable? *\/\n\t\t}\n\t}\n\n\t\/* Mark all components as being of unknown type. *\/\n\n\tfor (i = 0; i < JAS_CAST(jas_uint, jas_image_numcmpts(dec->image)); ++i) {\n\t\tjas_image_setcmpttype(dec->image, i, JAS_IMAGE_CT_UNKNOWN);\n\t}\n\n\t\/* Determine the type of each component. *\/\n\tif (dec->cdef) {","target":0,"flaw_line_index":0,"hash":"8e4bfde4-55df-468d-b391-eeb425fb7574","idx":"5b9143d6-0f65-48b8-b212-fbf84886692e"}
{"func_before":"void Huff_offsetReceive (node_t *node, int *ch, byte *fin, int *offset) {\n\tbloc = *offset;\n\twhile (node && node->symbol == INTERNAL_NODE) {\n\t\tif (get_bit(fin)) {\n\t\t\tnode = node->right;\n\t\t} else {\n\t\t\tnode = node->left;\n\t\t}","target":1,"flaw_line_index":0,"hash":"177d3f32-56bf-43bf-8de1-61ce250754f0","idx":"25d680be-bd01-4bd1-a13d-03f13a813b87"}
{"func_before":"void Huff_offsetReceive (node_t *node, int *ch, byte *fin, int *offset, int maxoffset) {\n\tbloc = *offset;\n\twhile (node && node->symbol == INTERNAL_NODE) {\n\t\tif (bloc >= maxoffset) {\n\t\t\t*ch = 0;\n\t\t\t*offset = maxoffset + 1;\n\t\t\treturn;\n\t\t}\n\t\tif (get_bit(fin)) {\n\t\t\tnode = node->right;\n\t\t} else {\n\t\t\tnode = node->left;\n\t\t}","target":0,"flaw_line_index":0,"hash":"ed40db39-9532-4482-a69e-8c430d205149","idx":"85a94184-3b3a-421c-bdf9-3dc1b79465e7"}
{"func_before":"\n    \/*\n     * fill the structure.\n     *\/\n    ret->value = xmlStrdup(value);\n    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n\t\/*\n\t * Operating in streaming mode, attr is gonna disappear\n\t *\/\n\tret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;","target":1,"flaw_line_index":0,"hash":"c1c1b291-33a9-44bf-9f55-3f672fbe5196","idx":"f3af3569-c885-42b3-8029-65f4e5c95909"}
{"func_before":"\n    \/*\n     * fill the structure.\n     *\/\n    ret->value = xmlStrdup(value);\n    if (xmlIsStreaming(ctxt)) {\n\t\/*\n\t * Operating in streaming mode, attr is gonna disappear\n\t *\/\n\tret->name = xmlStrdup(attr->name);\n\tret->attr = NULL;","target":0,"flaw_line_index":0,"hash":"47707b1f-eaa0-4eff-8632-113cb039ea90","idx":"33bec62f-0cf3-4bcb-84d8-718e3e3d5c53"}
{"func_before":"static void _ltc_ecc_free_public_key(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\n\tcrypto_bignum_free(s->x);\n\tcrypto_bignum_free(s->y);\n}","target":1,"flaw_line_index":0,"hash":"7679481d-75e9-4da8-bd9f-0e5517506502","idx":"e25f542f-7658-4f24-ba82-bbdfa1489e78"}
{"func_before":"static void _ltc_ecc_free_public_key(struct ecc_public_key *s)\n{\n\tif (!s)\n\t\treturn;\n\n\tcrypto_bignum_free(&s->x);\n\tcrypto_bignum_free(&s->y);\n}","target":0,"flaw_line_index":0,"hash":"92398d59-ad7b-4f90-9f54-f7ad332d121e","idx":"879183b4-318b-4c47-81fd-69f49c2424c2"}
{"func_before":"\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint iskew = imagew - tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\n\t(void) spp;\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb + tilew > imagew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );","target":1,"flaw_line_index":0,"hash":"d6e45ea3-9827-47f7-ae2d-996f8a66b20a","idx":"6c34f724-c240-44e5-9e76-32db25079fe8"}
{"func_before":"\tint status = 1;\n\ttsize_t tilesize = TIFFTileSize(in);\n\ttdata_t tilebuf;\n\tuint32 imagew = TIFFScanlineSize(in);\n\tuint32 tilew  = TIFFTileRowSize(in);\n\tint64 iskew = (int64)imagew - (int64)tilew;\n\tuint8* bufp = (uint8*) buf;\n\tuint32 tw, tl;\n\tuint32 row;\n\n\t(void) spp;\n\t\t\t\t    (unsigned long) col,\n\t\t\t\t    (unsigned long) row);\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (colb > iskew) {\n\t\t\t\tuint32 width = imagew - colb;\n\t\t\t\tuint32 oskew = tilew - width;\n\t\t\t\tcpStripToTile(bufp + colb,\n\t\t\t\t    tilebuf, nrow, width,\n\t\t\t\t    oskew + iskew, oskew );","target":0,"flaw_line_index":0,"hash":"abf52989-ef81-4f30-a021-1c34ecb272cc","idx":"2f5cdfdb-8d23-411f-a319-1b81ff64d2c5"}
{"func_before":"\t\treturn 1;\t\/* Default location *\/\n\toptions += 3;\n\t\/*todo: use simple_strtoll with >32bit ext3 *\/\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\text3_msg(sb, \"error: invalid sb specification: %s\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;","target":1,"flaw_line_index":0,"hash":"51cb0e06-775b-4f1f-86ff-75d6be8a2133","idx":"0f29b687-136f-4a45-bdf5-87083cf882a2"}
{"func_before":"\t\treturn 1;\t\/* Default location *\/\n\toptions += 3;\n\t\/*todo: use simple_strtoll with >32bit ext3 *\/\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\text3_msg(sb, KERN_ERR, \"error: invalid sb specification: %s\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;","target":0,"flaw_line_index":0,"hash":"3febb4b1-3807-4ed9-a0af-0c6e3a674f46","idx":"ffaff412-0ae3-4e79-a097-63320a03caae"}
{"func_before":"    int matched = UNSPEC;\n    debug_decl(hostlist_matches, SUDOERS_DEBUG_MATCH);\n\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = host_matches(parse_tree, pw, lhost, shost, m);\n\tif (matched != UNSPEC)\n\t    break;\n    }\n    debug_return_int(matched);\n}","target":1,"flaw_line_index":0,"hash":"e2272159-772d-4e73-8a22-9b5573d3dc56","idx":"aa13073c-f542-477f-ae8c-7f79656c23ab"}
{"func_before":"    int matched = UNSPEC;\n    debug_decl(hostlist_matches, SUDOERS_DEBUG_MATCH);\n\n    TAILQ_FOREACH_REVERSE(m, list, member_list, entries) {\n\tmatched = host_matches(parse_tree, pw, lhost, shost, m);\n\tif (SPECIFIED(matched))\n\t    break;\n    }\n    debug_return_int(matched);\n}","target":0,"flaw_line_index":0,"hash":"3a02cb02-e714-4d37-aa63-055ff8eddac4","idx":"8a9d3705-1a30-4243-b26e-9fcbe3c407dc"}
{"func_before":"\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n\n    FreeStmt((ParseCommon *) &append);\n\n    return expr;\n}","target":1,"flaw_line_index":0,"hash":"9b8897c0-90a0-4dc8-833d-28a888e5ce51","idx":"b4fb5b1f-a257-4e33-b971-fcb77130c057"}
{"func_before":"\n    darray_append(expr->keysym_list.symsMapIndex, nSyms);\n    darray_append(expr->keysym_list.symsNumEntries, numEntries);\n    darray_concat(expr->keysym_list.syms, append->keysym_list.syms);\n\n    FreeStmt((ParseCommon *) append);\n\n    return expr;\n}","target":0,"flaw_line_index":0,"hash":"4e818624-425a-4a8f-94df-e7b789429dbb","idx":"a25660d9-e497-41d4-817e-7d05c7b3d78b"}
{"func_before":"\tclt->pcpu_path = alloc_percpu(typeof(*clt->pcpu_path));\n\tif (!clt->pcpu_path) {\n\t\tkfree(clt);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tuuid_gen(&clt->paths_uuid);\n\tINIT_LIST_HEAD_RCU(&clt->paths_list);\n\tclt->paths_num = paths_num;\n\tclt->paths_up = MAX_PATHS_NUM;\n\tclt->port = port;\n\tclt->link_ev = link_ev;\n\tclt->mp_policy = MP_POLICY_MIN_INFLIGHT;\n\tstrscpy(clt->sessname, sessname, sizeof(clt->sessname));\n\tinit_waitqueue_head(&clt->permits_wait);\n\tmutex_init(&clt->paths_ev_mutex);\n\tmutex_init(&clt->paths_mutex);\n\n\tclt->dev.class = rtrs_clt_dev_class;\n\tclt->dev.release = rtrs_clt_dev_release;\n\terr = dev_set_name(&clt->dev, \"%s\", sessname);\n\tif (err)\n\t\tgoto err;\n\t\/*\n\t * Suppress user space notification until\n\t * sysfs files are created\n\t *\/\n\tdev_set_uevent_suppress(&clt->dev, true);\n\terr = device_register(&clt->dev);\n\tif (err) {\n\t\tput_device(&clt->dev);\n\t\tgoto err;\n\t}\n\n\tclt->kobj_paths = kobject_create_and_add(\"paths\", &clt->dev.kobj);\n\tif (!clt->kobj_paths) {\n\t\terr = -ENOMEM;\n\t\tgoto err_dev;\n\t}\n\terr = rtrs_clt_create_sysfs_root_files(clt);\n\tif (err) {\n\t\tkobject_del(clt->kobj_paths);\n\t\tkobject_put(clt->kobj_paths);\n\t\tgoto err_dev;\n\t}\n\tdev_set_uevent_suppress(&clt->dev, false);\n\tkobject_uevent(&clt->dev.kobj, KOBJ_ADD);\n\n\treturn clt;\nerr_dev:\n\tdevice_unregister(&clt->dev);\nerr:\n\tfree_percpu(clt->pcpu_path);\n\tkfree(clt);\n\treturn ERR_PTR(err);\n}","target":1,"flaw_line_index":0,"hash":"407e7670-130a-4824-abc6-26759cb25fd5","idx":"c056006a-4922-4ade-ab53-3cce5b2738a8"}
{"func_before":"\tif (!clt->pcpu_path) {\n\t\tkfree(clt);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tclt->dev.class = rtrs_clt_dev_class;\n\tclt->dev.release = rtrs_clt_dev_release;\n\tuuid_gen(&clt->paths_uuid);\n\tINIT_LIST_HEAD_RCU(&clt->paths_list);\n\tclt->paths_num = paths_num;\n\tclt->paths_up = MAX_PATHS_NUM;\n\tclt->port = port;\n\tclt->mp_policy = MP_POLICY_MIN_INFLIGHT;\n\tstrscpy(clt->sessname, sessname, sizeof(clt->sessname));\n\tinit_waitqueue_head(&clt->permits_wait);\n\tmutex_init(&clt->paths_ev_mutex);\n\tmutex_init(&clt->paths_mutex);\n\tdevice_initialize(&clt->dev);\n\n\terr = dev_set_name(&clt->dev, \"%s\", sessname);\n\tif (err)\n\t\tgoto err_put;\n\n\t\/*\n\t * Suppress user space notification until\n\t * sysfs files are created\n\t *\/\n\tdev_set_uevent_suppress(&clt->dev, true);\n\terr = device_add(&clt->dev);\n\tif (err)\n\t\tgoto err_put;\n\n\tclt->kobj_paths = kobject_create_and_add(\"paths\", &clt->dev.kobj);\n\tif (!clt->kobj_paths) {\n\t\terr = -ENOMEM;\n\t\tgoto err_del;\n\t}\n\terr = rtrs_clt_create_sysfs_root_files(clt);\n\tif (err) {\n\t\tkobject_del(clt->kobj_paths);\n\t\tkobject_put(clt->kobj_paths);\n\t\tgoto err_del;\n\t}\n\tdev_set_uevent_suppress(&clt->dev, false);\n\tkobject_uevent(&clt->dev.kobj, KOBJ_ADD);\n\n\treturn clt;\nerr_del:\n\tdevice_del(&clt->dev);\nerr_put:\n\tfree_percpu(clt->pcpu_path);\n\tput_device(&clt->dev);\n\treturn ERR_PTR(err);\n}","target":0,"flaw_line_index":0,"hash":"9dde57f4-ce67-4669-b201-b673494deb03","idx":"c5a954df-a129-44d2-a21b-976782263e49"}
{"func_before":"\t\t\t      u32 result)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_FW_DOWNLOAD);\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_KERNEL);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:","target":1,"flaw_line_index":0,"hash":"1e949c7e-454a-4019-8e21-62b3be30aa4b","idx":"2b596c69-ed38-468e-81ec-75df10ac1ed7"}
{"func_before":"\t\t\t      u32 result)\n{\n\tstruct sk_buff *msg;\n\tvoid *hdr;\n\n\tmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\thdr = genlmsg_put(msg, 0, 0, &nfc_genl_family, 0,\n\t\t\t  NFC_CMD_FW_DOWNLOAD);\n\t    nla_put_u32(msg, NFC_ATTR_DEVICE_INDEX, dev->idx))\n\t\tgoto nla_put_failure;\n\n\tgenlmsg_end(msg, hdr);\n\n\tgenlmsg_multicast(&nfc_genl_family, msg, 0, 0, GFP_ATOMIC);\n\n\treturn 0;\n\nnla_put_failure:\nfree_msg:","target":0,"flaw_line_index":0,"hash":"e8601495-0021-4f17-993f-5504853423f9","idx":"510d2955-7261-4c29-865e-1cf82baafed1"}
{"func_before":"\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tdisconnect = !IS_MNT_LOCKED_AND_LAZY(p);\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);","target":1,"flaw_line_index":0,"hash":"5d842c5e-9b7f-45be-851c-038b6d656eca","idx":"e7c7449b-c9c1-4551-b3d5-18602dbc4b4e"}
{"func_before":"\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tdisconnect = !(((how & UMOUNT_CONNECTED) &&\n\t\t\t\tmnt_has_parent(p) &&\n\t\t\t\t(p->mnt_parent->mnt.mnt_flags & MNT_UMOUNT)) ||\n\t\t\t       IS_MNT_LOCKED_AND_LAZY(p));\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);","target":0,"flaw_line_index":0,"hash":"9739e4fb-62fe-444c-b7f2-8c714afd4d6b","idx":"e374b1d2-45ff-4c69-a0e8-ead847f6250b"}
{"func_before":"\n    trail = 0;\n    length = info->name.length;\n\n    if (dir != NULL) {\n        length = dir->length;\n\n        if (length == 0) {\n            return NJS_DECLINED;\n        }\n","target":1,"flaw_line_index":0,"hash":"db988b00-46ca-477c-a456-9b0836babf60","idx":"294fa650-907d-43ea-a5e5-d850db66c7cb"}
{"func_before":"\n    trail = 0;\n    length = info->name.length;\n\n    if (dir != NULL) {\n        length += dir->length;\n\n        if (length == 0) {\n            return NJS_DECLINED;\n        }\n","target":0,"flaw_line_index":0,"hash":"798ce19f-652f-41eb-a063-fc212a2c4d0f","idx":"97d70e27-bc28-42aa-a491-9f86317a9513"}
{"func_before":"l2tp_proxy_auth_type_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_authentype2str,\n\t\t\t     \"AuthType-#%u\", EXTRACT_16BITS(ptr))));\n}","target":1,"flaw_line_index":0,"hash":"17be5c36-6428-47f0-b149-219a5c307f8a","idx":"65e21f52-f1e1-4cb0-b304-ecc60f6bb993"}
{"func_before":"l2tp_proxy_auth_type_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\n\tif (length < 2) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tND_PRINT((ndo, \"%s\", tok2str(l2tp_authentype2str,\n\t\t\t     \"AuthType-#%u\", EXTRACT_16BITS(ptr))));\n}","target":0,"flaw_line_index":0,"hash":"d43d995f-3c30-46a1-a3dc-7bab13f77bcd","idx":"449487fd-92d5-40f9-a0bf-11901e309e20"}
{"func_before":"static void labeljumps(JF, js_JumpList *jump, int baddr, int caddr)\n{\n\twhile (jump) {\n\t\tif (jump->type == STM_BREAK)\n\t\t\tlabelto(J, F, jump->inst, baddr);\n\t\tif (jump->type == STM_CONTINUE)\n\t\t\tlabelto(J, F, jump->inst, caddr);\n\t\tjump = jump->next;\n\t}\n}","target":1,"flaw_line_index":0,"hash":"6c9f322c-a03c-4500-923d-a3137c440004","idx":"8159d198-e0fb-4fab-b6f0-930157c30463"}
{"func_before":"static void labeljumps(JF, js_Ast *stm, int baddr, int caddr)\n{\n\tjs_JumpList *jump = stm->jumps;\n\twhile (jump) {\n\t\tjs_JumpList *next = jump->next;\n\t\tif (jump->type == STM_BREAK)\n\t\t\tlabelto(J, F, jump->inst, baddr);\n\t\tif (jump->type == STM_CONTINUE)\n\t\t\tlabelto(J, F, jump->inst, caddr);\n\t\tjs_free(J, jump);\n\t\tjump = next;\n\t}\n\tstm->jumps = NULL;\n}","target":0,"flaw_line_index":0,"hash":"55548d01-e3d4-4907-b47f-2fccf16ee654","idx":"468e3cda-d10b-48bb-9c4c-111cead39339"}
{"func_before":"static inline void xen_evtchn_handle_events(unsigned cpu)\n{\n\treturn evtchn_ops->handle_events(cpu);\n}","target":1,"flaw_line_index":0,"hash":"37e48c48-1dd0-4a8c-abe7-0c4a5a65a120","idx":"8a3e9c60-462f-4242-8e8e-ada131bab711"}
{"func_before":"static inline void xen_evtchn_handle_events(unsigned cpu,\n\t\t\t\t\t    struct evtchn_loop_ctrl *ctrl)\n{\n\treturn evtchn_ops->handle_events(cpu, ctrl);\n}","target":0,"flaw_line_index":0,"hash":"6b35bead-8bde-4d56-b930-959d6c84d196","idx":"e2cb0637-8c50-4283-b855-cb43c5f8f2cf"}
{"func_before":"                dt_offsets[n_off] = elf_unsigned_dynamic(k);  \/\/ zero if not found\n            }\n        }\n        if (file_size <= dt_offsets[n_off]) {\n            char msg[60]; snprintf(msg, sizeof(msg), \"bad DT_{%#x} = %#x (beyond EOF)\",\n                dt_names[k], dt_offsets[n_off]);\n                throwCantPack(msg);\n        }\n        n_off += !!dt_offsets[n_off];\n    }\n    dt_offsets[n_off++] = file_size;  \/\/ sentinel","target":1,"flaw_line_index":0,"hash":"5eb1d929-e8f5-4d46-9fb4-82f515ac148c","idx":"66760c51-976f-46e4-a06b-4943e7ade16e"}
{"func_before":"                dt_offsets[n_off] = elf_unsigned_dynamic(k);  \/\/ zero if not found\n            }\n        }\n        if (file_size <= dt_offsets[n_off]) {\n            char msg[60]; snprintf(msg, sizeof(msg), \"bad DT_{%#x} = %#x (beyond EOF)\",\n                k, dt_offsets[n_off]);\n                throwCantPack(msg);\n        }\n        n_off += !!dt_offsets[n_off];\n    }\n    dt_offsets[n_off++] = file_size;  \/\/ sentinel","target":0,"flaw_line_index":0,"hash":"058d2af1-b028-45b6-acb5-834402db84e1","idx":"d4a64de2-4fd8-40ba-9849-dd0e35a23169"}
{"func_before":"static INLINE UINT16 ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair)\n{\n\tUINT16 AvId;\n\n\tData_Read_UINT16(&pAvPair->AvId, AvId);\n\n\treturn AvId;\n}","target":1,"flaw_line_index":0,"hash":"ea49fee6-4f51-4f21-b117-68e7824e996b","idx":"a92cceb6-7859-44e2-88c7-9763649ab3a4"}
{"func_before":"static INLINE BOOL ntlm_av_pair_get_id(const NTLM_AV_PAIR* pAvPair, size_t size, UINT16* pair)\n{\n\tUINT16 AvId;\n\tif (!pAvPair || !pair)\n\t\treturn FALSE;\n\n\tif (size < sizeof(NTLM_AV_PAIR))\n\t\treturn FALSE;\n\n\tData_Read_UINT16(&pAvPair->AvId, AvId);\n\n\t*pair = AvId;\n\treturn TRUE;\n}","target":0,"flaw_line_index":0,"hash":"dcf97fd0-2a35-4245-92d4-8e670f709367","idx":"0b6e9c78-2a91-47cc-a587-6536fdc8c183"}
{"func_before":"mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t   struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sk_buff\t\t*skb;\n\tstruct sock\t\t*sk = sock->sk;\n\tstruct sockaddr_mISDN\t*maddr;\n\n\tint\t\tcopied, err;\n\n\tif (*debug & DEBUG_SOCKET)\n\t\tprintk(KERN_DEBUG \"%s: len %d, flags %x ch.nr %d, proto %x\\n\",\n\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tif (msg->msg_namelen >= sizeof(struct sockaddr_mISDN)) {\n\t\tmsg->msg_namelen = sizeof(struct sockaddr_mISDN);\n\t\tmaddr = (struct sockaddr_mISDN *)msg->msg_name;\n\t\tmaddr->family = AF_ISDN;\n\t\tmaddr->dev = _pms(sk)->dev->id;\n\t\tif ((sk->sk_protocol == ISDN_P_LAPD_TE) ||\n\t\t    (sk->sk_protocol == ISDN_P_LAPD_NT)) {\n\t\t\tmaddr->channel = (mISDN_HEAD_ID(skb) >> 16) & 0xff;\n\t\t} else {\n\t\t\tmaddr->channel = _pms(sk)->ch.nr;\n\t\t\tmaddr->sapi = _pms(sk)->ch.addr & 0xFF;\n\t\t\tmaddr->tei =  (_pms(sk)->ch.addr >> 8) & 0xFF;\n\t\t}\n\t} else {\n\t\tif (msg->msg_namelen)\n\t\t\tprintk(KERN_WARNING \"%s: too small namelen %d\\n\",\n\t\t\t       __func__, msg->msg_namelen);\n\t\tmsg->msg_namelen = 0;\n\t}\n\n\tcopied = skb->len + MISDN_HEADER_LEN;\n\tif (len < copied) {\n\t\tif (flags & MSG_PEEK)","target":1,"flaw_line_index":0,"hash":"7fffbda6-5439-45bb-81d7-58de7a712922","idx":"75c88755-d9a0-4d2b-8383-5eaee29432b9"}
{"func_before":"mISDN_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t   struct msghdr *msg, size_t len, int flags)\n{\n\tstruct sk_buff\t\t*skb;\n\tstruct sock\t\t*sk = sock->sk;\n\n\tint\t\tcopied, err;\n\n\tif (*debug & DEBUG_SOCKET)\n\t\tprintk(KERN_DEBUG \"%s: len %d, flags %x ch.nr %d, proto %x\\n\",\n\n\tskb = skb_recv_datagram(sk, flags, flags & MSG_DONTWAIT, &err);\n\tif (!skb)\n\t\treturn err;\n\n\tif (msg->msg_name) {\n\t\tstruct sockaddr_mISDN *maddr = msg->msg_name;\n\n\t\tmaddr->family = AF_ISDN;\n\t\tmaddr->dev = _pms(sk)->dev->id;\n\t\tif ((sk->sk_protocol == ISDN_P_LAPD_TE) ||\n\t\t    (sk->sk_protocol == ISDN_P_LAPD_NT)) {\n\t\t\tmaddr->channel = (mISDN_HEAD_ID(skb) >> 16) & 0xff;\n\t\t} else {\n\t\t\tmaddr->channel = _pms(sk)->ch.nr;\n\t\t\tmaddr->sapi = _pms(sk)->ch.addr & 0xFF;\n\t\t\tmaddr->tei =  (_pms(sk)->ch.addr >> 8) & 0xFF;\n\t\t}\n\t\tmsg->msg_namelen = sizeof(*maddr);\n\t}\n\n\tcopied = skb->len + MISDN_HEADER_LEN;\n\tif (len < copied) {\n\t\tif (flags & MSG_PEEK)","target":0,"flaw_line_index":0,"hash":"db18b44c-3e6e-4c16-83a4-f3652a918254","idx":"e2a59488-b584-4b8d-b10c-35663d52cd71"}
{"func_before":"\n        while (x < sz) {\n            int acc_samples = 0;\n            int dst_offset = 0;\n\n            while (nb_frame <= s->nb_frames) {\n                AVFrame *cur_frame = s->frames[nb_frame];\n                int cur_frame_samples = cur_frame->nb_samples;\n                int nb_samples = 0;\n\n                if (acc_samples < spf) {","target":1,"flaw_line_index":0,"hash":"85f823ff-e18a-4a70-b0cb-59e224da692a","idx":"2792c8c7-4103-4408-9daa-82061ae9353c"}
{"func_before":"\n        while (x < sz) {\n            int acc_samples = 0;\n            int dst_offset = 0;\n\n            while (nb_frame < s->nb_frames) {\n                AVFrame *cur_frame = s->frames[nb_frame];\n                int cur_frame_samples = cur_frame->nb_samples;\n                int nb_samples = 0;\n\n                if (acc_samples < spf) {","target":0,"flaw_line_index":0,"hash":"e47007ac-a551-4c75-826f-03152bc1faae","idx":"fab71430-9787-4081-99b5-e91632322c85"}
{"func_before":"\tunsigned char *p = to;\n\n\t\/* Reserve one byte for terminating \\0 *\/\n\ttolen--;\n\twhile (elen < fromlen) {\n\t\tpc = (struct pathComponent *)(from + elen);\n\t\tswitch (pc->componentType) {\n\t\tcase 1:\n\t\t\t\/*\n\t\t\t * Symlink points to some place which should be agreed\n \t\t\t * upon between originator and receiver of the media. Ignore.\n\t\t\t *\/\n\t\t\tif (pc->lengthComponentIdent > 0)\n\t\t\t\tbreak;\n\t\t\t\/* Fall through *\/\n\t\tcase 2:\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tp = to;\n\t\t\tmemcpy(p, \".\/\", 2);\n\t\t\tp += 2;\n\t\t\ttolen -= 2;\n\t\t\t\/* that would be . - just ignore *\/\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n\t\t\t\t\t\t    pc->lengthComponentIdent,\n\t\t\t\t\t\t    p, tolen);\n\t\t\tp += comp_len;\n\t\t\ttolen -= comp_len;\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\t*p++ = '\/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\t}\n\t\telen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n\t}\n\tif (p > to + 1)\n\t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';","target":1,"flaw_line_index":0,"hash":"b83a38e8-7af7-480b-acec-094ae0066ea0","idx":"33e05be6-87a9-4403-a135-52ce83c3f5e2"}
{"func_before":"\n\t\/* Reserve one byte for terminating \\0 *\/\n\ttolen--;\n\twhile (elen < fromlen) {\n\t\tpc = (struct pathComponent *)(from + elen);\n\t\telen += sizeof(struct pathComponent);\n\t\tswitch (pc->componentType) {\n\t\tcase 1:\n\t\t\t\/*\n\t\t\t * Symlink points to some place which should be agreed\n \t\t\t * upon between originator and receiver of the media. Ignore.\n\t\t\t *\/\n\t\t\tif (pc->lengthComponentIdent > 0) {\n\t\t\t\telen += pc->lengthComponentIdent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\/* Fall through *\/\n\t\tcase 2:\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\tp = to;\n\t\t\tp += 2;\n\t\t\ttolen -= 2;\n\t\t\t\/* that would be . - just ignore *\/\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\telen += pc->lengthComponentIdent;\n\t\t\tif (elen > fromlen)\n\t\t\t\treturn -EIO;\n\t\t\tcomp_len = udf_get_filename(sb, pc->componentIdent,\n\t\t\t\t\t\t    pc->lengthComponentIdent,\n\t\t\t\t\t\t    p, tolen);\n\t\t\tp += comp_len;\n\t\t\ttolen -= comp_len;\n\t\t\tif (tolen == 0)\n\t\t\t\treturn -ENAMETOOLONG;\n\t\t\t*p++ = '\/';\n\t\t\ttolen--;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (p > to + 1)\n\t\tp[-1] = '\\0';\n\telse\n\t\tp[0] = '\\0';","target":0,"flaw_line_index":0,"hash":"f6a2b9ea-b5f5-475d-8b21-9504dd623542","idx":"310564c7-fba8-4765-9691-108bed751f20"}
{"func_before":"  *eventPP = s;\n\n  for (;;) {\n    const char *next = s; \/* XmlContentTok doesn't always set the last arg *\/\n    int tok = XmlContentTok(enc, s, end, &next);\n#ifdef XML_DTD\n    const char *accountAfter\n        = ((tok == XML_TOK_TRAILING_RSQB) || (tok == XML_TOK_TRAILING_CR))\n              ? (haveMore ? s \/* i.e. 0 bytes *\/ : end)\n              : next;\n    if (! accountingDiffTolerated(parser, tok, s, accountAfter, __LINE__,\n      const XML_Char *name;\n      ENTITY *entity;\n      XML_Char ch = (XML_Char)XmlPredefinedEntityName(\n          enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);\n      if (ch) {\n#ifdef XML_DTD\n        \/* NOTE: We are replacing 4-6 characters original input for 1 character\n         *       so there is no amplification and hence recording without\n         *       protection. *\/\n        accountingDiffTolerated(parser, tok, (char *)&ch,\n                                ((char *)&ch) + sizeof(XML_Char), __LINE__,\n                                XML_ACCOUNT_ENTITY_EXPANSION);\n#endif \/* XML_DTD *\/\n        if (parser->m_characterDataHandler)\n          parser->m_characterDataHandler(parser->m_handlerArg, &ch, 1);\n        else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        break;","target":1,"flaw_line_index":0,"hash":"07aa98f1-fe12-4ed6-883d-70b40874952f","idx":"2330d969-a6b3-4391-98c2-e60cf603f6ea"}
{"func_before":"  *eventPP = s;\n\n  for (;;) {\n    const char *next = s; \/* XmlContentTok doesn't always set the last arg *\/\n    int tok = XmlContentTok(enc, s, end, &next);\n#if defined(XML_DTD) || XML_GE == 1\n    const char *accountAfter\n        = ((tok == XML_TOK_TRAILING_RSQB) || (tok == XML_TOK_TRAILING_CR))\n              ? (haveMore ? s \/* i.e. 0 bytes *\/ : end)\n              : next;\n    if (! accountingDiffTolerated(parser, tok, s, accountAfter, __LINE__,\n      const XML_Char *name;\n      ENTITY *entity;\n      XML_Char ch = (XML_Char)XmlPredefinedEntityName(\n          enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);\n      if (ch) {\n#if defined(XML_DTD) || XML_GE == 1\n        \/* NOTE: We are replacing 4-6 characters original input for 1 character\n         *       so there is no amplification and hence recording without\n         *       protection. *\/\n        accountingDiffTolerated(parser, tok, (char *)&ch,\n                                ((char *)&ch) + sizeof(XML_Char), __LINE__,\n                                XML_ACCOUNT_ENTITY_EXPANSION);\n#endif \/* defined(XML_DTD) || XML_GE == 1 *\/\n        if (parser->m_characterDataHandler)\n          parser->m_characterDataHandler(parser->m_handlerArg, &ch, 1);\n        else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        break;","target":0,"flaw_line_index":0,"hash":"a69359d6-c044-4c42-9f3a-6684fe43024e","idx":"2b6169c5-f6a1-4bbf-85c3-1518c67b409b"}
{"func_before":"\t\t * fs is remounted read-only or the mount fails because it's busy...\n\t\t * MS_REMOUNT|MS_BIND|MS_RDONLY seems to work for kernels as low as\n\t\t * 2.6.32...\n\t\t *\/\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"proc\",                                              \"%r\/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r\/proc\/sys\/net\",                                   \"%r\/proc\/net\",                  NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r\/proc\/sys\",                                       \"%r\/proc\/sys\",                  NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r\/proc\/sys\",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r\/proc\/net\",                                       \"%r\/proc\/sys\/net\",              NULL,       MS_MOVE,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r\/proc\/sysrq-trigger\",                             \"%r\/proc\/sysrq-trigger\",        NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r\/proc\/sysrq-trigger\",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \"proc\",                                              \"%r\/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RW,     \"sysfs\",                                             \"%r\/sys\",                       \"sysfs\",    0,                              NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RO,     \"sysfs\",                                             \"%r\/sys\",                       \"sysfs\",    MS_RDONLY,                      NULL },\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmflags = add_required_remount_flags(source, destination,\n\t\t\t\t\tdefault_mounts[i].flags);\n\t\t\tr = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);\n\t\t\tsaved_errno = errno;\n\t\t\tif (r < 0 && errno == ENOENT) {\n\t\t\t\tINFO(\"Mount source or target for %s on %s doesn't exist. Skipping.\", source, destination);\n\t\t\t\tr = 0;\n\t\t\t}","target":1,"flaw_line_index":0,"hash":"03239129-3598-4458-ab9f-dc70a9fc6f62","idx":"199abafd-6af5-4c05-a117-40059e26333f"}
{"func_before":"\t\t * fs is remounted read-only or the mount fails because it's busy...\n\t\t * MS_REMOUNT|MS_BIND|MS_RDONLY seems to work for kernels as low as\n\t\t * 2.6.32...\n\t\t *\/\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"proc\",                                              \"%r\/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t\/* proc\/tty is used as a temporary placeholder for proc\/sys\/net which we'll move back in a few steps *\/\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r\/proc\/sys\/net\",                                   \"%r\/proc\/tty\",                  NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r\/proc\/sys\",                                       \"%r\/proc\/sys\",                  NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r\/proc\/sys\",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r\/proc\/tty\",                                       \"%r\/proc\/sys\/net\",              NULL,       MS_MOVE,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r\/proc\/sysrq-trigger\",                             \"%r\/proc\/sysrq-trigger\",        NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r\/proc\/sysrq-trigger\",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \"proc\",                                              \"%r\/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RW,     \"sysfs\",                                             \"%r\/sys\",                       \"sysfs\",    0,                              NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RO,     \"sysfs\",                                             \"%r\/sys\",                       \"sysfs\",    MS_RDONLY,                      NULL },\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmflags = add_required_remount_flags(source, destination,\n\t\t\t\t\tdefault_mounts[i].flags);\n\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n\t\t\tsaved_errno = errno;\n\t\t\tif (r < 0 && errno == ENOENT) {\n\t\t\t\tINFO(\"Mount source or target for %s on %s doesn't exist. Skipping.\", source, destination);\n\t\t\t\tr = 0;\n\t\t\t}","target":0,"flaw_line_index":0,"hash":"f0930971-0c90-499a-9534-344569cfd994","idx":"1adb3d67-5738-4e89-a794-8b1d690d4e9f"}
{"func_before":"cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n{\n\tconst char *b = (const char *)sst->sst_tab;\n\tconst char *e = ((const char *)p) + tail;\n\t(void)&line;\n\tif (e >= b && (size_t)(e - b) <= CDF_SEC_SIZE(h) * sst->sst_len)\n\t\treturn 0;\n\tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n\t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n\t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n\t    CDF_SEC_SIZE(h) * sst->sst_len, CDF_SEC_SIZE(h), sst->sst_len));\n\terrno = EFTYPE;\n\treturn -1;\n}","target":1,"flaw_line_index":0,"hash":"e8a29ae1-f44e-4a45-92af-cd2ee47bc7b2","idx":"77b2d919-fe14-485b-874d-ed1122b7b6c6"}
{"func_before":"cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n    const void *p, size_t tail, int line)\n{\n\tconst char *b = (const char *)sst->sst_tab;\n\tconst char *e = ((const char *)p) + tail;\n\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n\t(void)&line;\n\tif (e >= b && (size_t)(e - b) <= ss * sst->sst_len)\n\t\treturn 0;\n\tDPRINTF((\"%d: offset begin %p < end %p || %\" SIZE_T_FORMAT \"u\"\n\t    \" > %\" SIZE_T_FORMAT \"u [%\" SIZE_T_FORMAT \"u %\"\n\t    SIZE_T_FORMAT \"u]\\n\", line, b, e, (size_t)(e - b),\n\t    ss * sst->sst_len, ss, sst->sst_len));\n\terrno = EFTYPE;\n\treturn -1;\n}","target":0,"flaw_line_index":0,"hash":"1a30afb3-9485-47b5-8f8a-d6f92182addc","idx":"87abd965-a3ab-40fa-9bb8-ac23239de989"}
{"func_before":"\tmemset(control, 0, sizeof(rzip_control));\n\tcontrol->msgout = stderr;\n\tcontrol->msgerr = stderr;\n\tregister_outputfile(control, control->msgout);\n\tcontrol->flags = FLAG_SHOW_PROGRESS | FLAG_KEEP_FILES | FLAG_THRESHOLD;\n\tcontrol->suffix = \".lrz\";\n\tcontrol->compression_level = 7;\n\tcontrol->ramsize = get_ram(control);\n\tif (unlikely(control->ramsize == -1))\n\t\treturn false;\n\t\/* for testing single CPU *\/","target":1,"flaw_line_index":0,"hash":"b8b34a00-c192-456d-86b9-f07fcaf31d30","idx":"850d4acd-cdfd-43c9-bf0e-180177d34b55"}
{"func_before":"\tmemset(control, 0, sizeof(rzip_control));\n\tcontrol->msgout = stderr;\n\tcontrol->msgerr = stderr;\n\tregister_outputfile(control, control->msgout);\n\tcontrol->flags = FLAG_SHOW_PROGRESS | FLAG_KEEP_FILES | FLAG_THRESHOLD;\n\tcontrol->suffix = strdup(\".lrz\");\n\tcontrol->compression_level = 7;\n\tcontrol->ramsize = get_ram(control);\n\tif (unlikely(control->ramsize == -1))\n\t\treturn false;\n\t\/* for testing single CPU *\/","target":0,"flaw_line_index":0,"hash":"17a22d5d-7fda-4ae4-bcab-71d90f0faf30","idx":"3ec89bc4-9b74-4bef-b75d-6f57b33a10f9"}
{"func_before":"{\n    static chrand_ret           ret;\n    krb5_keyblock               *k;\n    int                         nkeys;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name,\n        service_name;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_chrand_ret, &ret);\n                 &client_name, &service_name, rqstp);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\nexit_func:\n    free_server_handle(handle);\n    return &ret;\n}","target":1,"flaw_line_index":0,"hash":"ba00f02c-dcb6-4a07-89d5-b11ff05695e5","idx":"43c47931-a424-4772-b8cc-d1e382bae4aa"}
{"func_before":"{\n    static chrand_ret           ret;\n    krb5_keyblock               *k;\n    int                         nkeys;\n    char                        *prime_arg, *funcname;\n    gss_buffer_desc             client_name = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc             service_name = GSS_C_EMPTY_BUFFER;\n    OM_uint32                   minor_stat;\n    kadm5_server_handle_t       handle;\n    const char                  *errmsg = NULL;\n\n    xdr_free(xdr_chrand_ret, &ret);\n\n        if (errmsg != NULL)\n            krb5_free_error_message(handle->context, errmsg);\n    }\n    free(prime_arg);\nexit_func:\n    gss_release_buffer(&minor_stat, &client_name);\n    gss_release_buffer(&minor_stat, &service_name);\n    free_server_handle(handle);\n    return &ret;\n}","target":0,"flaw_line_index":0,"hash":"dd4a4b56-3554-4fe5-a342-988c2181850d","idx":"8aee5f12-5ccf-4cb9-97c2-643f88445d17"}
{"func_before":"static int jas_iccgetuint16(jas_stream_t *in, jas_iccuint16_t *val)\n{\n\tulonglong tmp;\n\tif (jas_iccgetuint(in, 2, &tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"3d923d7e-9ceb-4f0c-b59e-2b1f892c4169","idx":"4dc7ad35-7392-4a27-815a-4a69723f4f00"}
{"func_before":"static int jas_iccgetuint16(jas_stream_t *in, jas_iccuint16_t *val)\n{\n\tjas_ulonglong tmp;\n\tif (jas_iccgetuint(in, 2, &tmp))\n\t\treturn -1;\n\t*val = tmp;\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"aa9be9c3-ec61-4534-98c4-3847db57e92a","idx":"420a11a8-b91e-444c-b041-ecbba4578d40"}
{"func_before":"        }\n        return 0;\n    }\n\n    \/* now wait for the next timestamp *\/\n    if (buf->pts == AV_NOPTS_VALUE) {\n        return write_to_fifo(s->fifo, buf);\n    }\n\n    \/* number of output frames *\/\n    delta = av_rescale_q_rnd(buf->pts - s->pts, inlink->time_base,","target":1,"flaw_line_index":0,"hash":"82563407-d44c-4910-b04f-ec6365aee00e","idx":"45b6489d-e510-4a72-8f94-75834deb7b1b"}
{"func_before":"        }\n        return 0;\n    }\n\n    \/* now wait for the next timestamp *\/\n    if (buf->pts == AV_NOPTS_VALUE || av_fifo_size(s->fifo) <= 0) {\n        return write_to_fifo(s->fifo, buf);\n    }\n\n    \/* number of output frames *\/\n    delta = av_rescale_q_rnd(buf->pts - s->pts, inlink->time_base,","target":0,"flaw_line_index":0,"hash":"f8848ba6-712a-46aa-86e1-331a3d391ac2","idx":"75b678aa-d989-4bef-a52a-3e0a12adfdca"}
{"func_before":"static char *clean_path(char *path)\n{\n\tchar *ch;\n\tchar *ch2;\n\tchar *str;\n\tstr = xmalloc(strlen(path));\n\tch = path;\n\tch2 = str;\n\twhile (true) {\n\t\t*ch2 = *ch;\n\t\tch++;","target":1,"flaw_line_index":0,"hash":"a94deda0-7d76-4b1d-a0fe-14795695045d","idx":"56d45792-de40-4191-a25a-ff9ab5cb95ed"}
{"func_before":"static char *clean_path(char *path)\n{\n\tchar *ch;\n\tchar *ch2;\n\tchar *str;\n\tstr = xmalloc(strlen(path) + 1);\n\tch = path;\n\tch2 = str;\n\twhile (true) {\n\t\t*ch2 = *ch;\n\t\tch++;","target":0,"flaw_line_index":0,"hash":"5df9283b-8fbe-449c-86d6-d40fd14d495a","idx":"a473c8fa-e36c-4b0a-afa2-57e81df59096"}
{"func_before":"    if (readState.atStop()) {\n      structInfo.unionExt->clear(object);\n      readState.readStructEnd(iprot);\n      return;\n    }\n    const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo);\n    \/\/ Found it.\n    if (fieldInfo) {\n      void* unionVal = getMember(*fieldInfo, object);\n      \/\/ Default construct and placement new into the member union.\n      structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](\n          unionVal);\n      read(iprot, *fieldInfo->typeInfo, readState, unionVal);\n      const_cast<FieldID&>(activeUnionMemberId(\n          object, structInfo.unionExt->unionTypeOffset)) = fieldInfo->id;\n    } else {\n      skip(iprot, readState);\n    }\n    readState.readFieldEnd(iprot);\n    readState.readFieldBegin(iprot);","target":1,"flaw_line_index":0,"hash":"d5c87ec4-a806-4634-b015-f64db172a534","idx":"ddcc604d-6e3e-4855-b952-2d1274429d69"}
{"func_before":"    if (readState.atStop()) {\n      structInfo.unionExt->clear(object);\n      readState.readStructEnd(iprot);\n      return;\n    }\n    if (const auto* fieldInfo = findFieldInfo(iprot, readState, structInfo)) {\n      auto& activeId = const_cast<int&>(getActiveId(object, structInfo));\n      if (activeId != 0) {\n        structInfo.unionExt->clear(object);\n      }\n      void* value = getMember(*fieldInfo, object);\n      structInfo.unionExt->initMember[fieldInfo - structInfo.fieldInfos](value);\n      read(iprot, *fieldInfo->typeInfo, readState, value);\n      activeId = fieldInfo->id;\n    } else {\n      skip(iprot, readState);\n    }\n    readState.readFieldEnd(iprot);\n    readState.readFieldBegin(iprot);","target":0,"flaw_line_index":0,"hash":"29b67628-eed1-4607-9ff3-f3617d851374","idx":"90641cc8-255b-454f-9860-edad87765508"}
{"func_before":"static CYTHON_SMALL_CODE int __pyx_pymod_exec_bufferedreader(PyObject *__pyx_pyinit_module)\n#endif\n#endif\n{\n  PyObject *__pyx_t_1 = NULL;\n  __Pyx_RefNannyDeclarations\n  #if CYTHON_PEP489_MULTI_PHASE_INIT\n  if (__pyx_m) {\n    if (__pyx_m == __pyx_pyinit_module) return 0;\n    PyErr_SetString(PyExc_RuntimeError, \"Module 'bufferedreader' has already been imported. Re-initialisation is not supported.\");\n      if (unlikely(PyDict_SetItemString(modules, \"clickhouse_driver.bufferedreader\", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)\n    }\n  }\n  #endif\n  \/*--- Builtin init code ---*\/\n  if (__Pyx_InitCachedBuiltins() < 0) goto __pyx_L1_error;\n  \/*--- Constants init code ---*\/\n  if (__Pyx_InitCachedConstants() < 0) goto __pyx_L1_error;\n  \/*--- Global type\/function init code ---*\/\n  (void)__Pyx_modinit_global_init_code();\n  (void)__Pyx_modinit_variable_export_code();\n  (void)__Pyx_modinit_function_export_code();\n  if (unlikely(__Pyx_modinit_type_init_code() != 0)) goto __pyx_L1_error;\n  if (unlikely(__Pyx_modinit_type_import_code() != 0)) goto __pyx_L1_error;\n  (void)__Pyx_modinit_variable_import_code();\n  (void)__Pyx_modinit_function_import_code();\n  \/*--- Execution code ---*\/\n  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)\n  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)","target":1,"flaw_line_index":0,"hash":"088f9ca2-0138-4248-8b2d-ffd821e3e28f","idx":"c30d90a6-7070-4df2-a11c-44b9855660ea"}
{"func_before":"static CYTHON_SMALL_CODE int __pyx_pymod_exec_bufferedreader(PyObject *__pyx_pyinit_module)\n#endif\n#endif\n{\n  PyObject *__pyx_t_1 = NULL;\n  int __pyx_lineno = 0;\n  const char *__pyx_filename = NULL;\n  int __pyx_clineno = 0;\n  __Pyx_RefNannyDeclarations\n  #if CYTHON_PEP489_MULTI_PHASE_INIT\n  if (__pyx_m) {\n    if (__pyx_m == __pyx_pyinit_module) return 0;\n    PyErr_SetString(PyExc_RuntimeError, \"Module 'bufferedreader' has already been imported. Re-initialisation is not supported.\");\n      if (unlikely(PyDict_SetItemString(modules, \"clickhouse_driver.bufferedreader\", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)\n    }\n  }\n  #endif\n  \/*--- Builtin init code ---*\/\n  if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  \/*--- Constants init code ---*\/\n  if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)\n  \/*--- Global type\/function init code ---*\/\n  (void)__Pyx_modinit_global_init_code();\n  (void)__Pyx_modinit_variable_export_code();\n  (void)__Pyx_modinit_function_export_code();\n  if (unlikely(__Pyx_modinit_type_init_code() < 0)) __PYX_ERR(0, 1, __pyx_L1_error)\n  if (unlikely(__Pyx_modinit_type_import_code() < 0)) __PYX_ERR(0, 1, __pyx_L1_error)\n  (void)__Pyx_modinit_variable_import_code();\n  (void)__Pyx_modinit_function_import_code();\n  \/*--- Execution code ---*\/\n  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)\n  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)","target":0,"flaw_line_index":0,"hash":"d91dc9b0-d8d6-41c0-bb7e-8b9ab237224a","idx":"7bf162f0-795f-4ee9-9d4f-313dca0db717"}
{"func_before":"    NPT_InputStreamReference stream;\n    NPT_File                 file(file_path);\n    NPT_FileInfo             file_info;\n    \n    \/\/ prevent hackers from accessing files outside of our root\n    if ((file_path.Find(\"\/..\") >= 0) || (file_path.Find(\"\\\\..\") >= 0) ||\n        NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n    \/\/ check for range requests","target":1,"flaw_line_index":0,"hash":"f1e89d81-5139-435e-a67f-6eee5bb0ba73","idx":"329e52e7-83c2-47b7-9f17-a841cec7b1cc"}
{"func_before":"    NPT_InputStreamReference stream;\n    NPT_File                 file(file_path);\n    NPT_FileInfo             file_info;\n    \n    \/\/ prevent hackers from accessing files outside of our root\n    if ((file_path.Find(\"..\/\") >= 0) || (file_path.Find(\"..\\\\\") >= 0) ||\n        NPT_FAILED(NPT_File::GetInfo(file_path, &file_info))) {\n        return NPT_ERROR_NO_SUCH_ITEM;\n    }\n    \n    \/\/ check for range requests","target":0,"flaw_line_index":0,"hash":"85207c59-d521-4dea-8a22-a980b1dc4b40","idx":"41f21deb-1283-4017-aec6-de738743377e"}
{"func_before":"spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    return gss_get_mic_iov(minor_status, context_handle, qop_req, iov,\n\t\t\t   iov_count);\n}","target":1,"flaw_line_index":0,"hash":"26a3683f-3455-4a5c-a811-d7f8bab3f717","idx":"7977de3f-c215-4fd3-8cad-df7619404c4a"}
{"func_before":"spnego_gss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    spnego_gss_ctx_id_t sc = (spnego_gss_ctx_id_t)context_handle;\n\n    if (sc->ctx_handle == GSS_C_NO_CONTEXT)\n\t    return (GSS_S_NO_CONTEXT);\n\n    return gss_get_mic_iov(minor_status, sc->ctx_handle, qop_req, iov,\n\t\t\t   iov_count);\n}","target":0,"flaw_line_index":0,"hash":"85af7d6c-d512-4497-84d1-afee68a527f8","idx":"4f57f6a5-ca6c-445d-95c7-86941e4d5a0d"}
{"func_before":"header_gets (SF_PRIVATE *psf, char *ptr, int bufsize)\n{\tint\t\tk ;\n\n\tfor (k = 0 ; k < bufsize - 1 ; k++)\n\t{\tif (psf->headindex < psf->headend)\n\t\t{\tptr [k] = psf->header [psf->headindex] ;\n\t\t\tpsf->headindex ++ ;\n\t\t\t}\n\t\telse\n\t\t{\tpsf->headend += psf_fread (psf->header + psf->headend, 1, 1, psf) ;\n\t\t\tptr [k] = psf->header [psf->headindex] ;\n\t\t\tpsf->headindex = psf->headend ;\n\t\t\t} ;\n\n\t\tif (ptr [k] == '\\n')\n\t\t\tbreak ;\n\t\t} ;","target":1,"flaw_line_index":0,"hash":"8f599546-f483-41e2-a61a-8c7696a099d5","idx":"768e2e06-8578-46a2-8639-1fdc73da4970"}
{"func_before":"header_gets (SF_PRIVATE *psf, char *ptr, int bufsize)\n{\tint\t\tk ;\n\n\tif (psf->header.indx + bufsize >= psf->header.len && psf_bump_header_allocation (psf, bufsize))\n\t\treturn 0 ;\n\n\tfor (k = 0 ; k < bufsize - 1 ; k++)\n\t{\tif (psf->header.indx < psf->header.end)\n\t\t{\tptr [k] = psf->header.ptr [psf->header.indx] ;\n\t\t\tpsf->header.indx ++ ;\n\t\t\t}\n\t\telse\n\t\t{\tpsf->header.end += psf_fread (psf->header.ptr + psf->header.end, 1, 1, psf) ;\n\t\t\tptr [k] = psf->header.ptr [psf->header.indx] ;\n\t\t\tpsf->header.indx = psf->header.end ;\n\t\t\t} ;\n\n\t\tif (ptr [k] == '\\n')\n\t\t\tbreak ;\n\t\t} ;","target":0,"flaw_line_index":0,"hash":"a3816b6c-f96d-4336-867d-f116fe1f0968","idx":"374294ec-911c-40eb-b7ee-0ff932986ab0"}
{"func_before":"static bool read_header_from_file(zckCtx *zck) {\n    \/* Verify that lead_size and header_length have been set *\/\n    if(zck->lead_size == 0 || zck->header_length == 0) {\n        set_error(zck, \"Lead and header sizes are both 0.  Have you run zck_read_lead() yet?\");\n        return false;\n    }\n\n    \/* Allocate header and store any extra bytes at beginning of header *\/\n    zck->header = zrealloc(zck->header, zck->lead_size + zck->header_length);","target":1,"flaw_line_index":0,"hash":"f69e5003-8b47-4d70-8327-05e4fd6781a7","idx":"51c5e1cc-bfac-44b3-9bc9-c4768778fa1b"}
{"func_before":"static bool read_header_from_file(zckCtx *zck) {\n    \/* Verify that lead_size and header_length have been set and are legit *\/\n    if(zck->lead_size == 0 || zck->header_length == 0) {\n        set_error(zck, \"Lead and header sizes are both 0.  Have you run zck_read_lead() yet?\");\n        return false;\n    }\n    if((zck->lead_size > zck->lead_size + zck->header_length) ||\n       (zck->header_length > zck->lead_size + zck->header_length)) {\n        zck_log(ZCK_LOG_ERROR, \"Integer overflow when reading header\");\n        return false;\n    }\n\n    \/* Allocate header and store any extra bytes at beginning of header *\/\n    zck->header = zrealloc(zck->header, zck->lead_size + zck->header_length);","target":0,"flaw_line_index":0,"hash":"8b37f1ac-0acd-4601-a15e-96b8bf62a128","idx":"0861ad88-ff29-4e55-9451-9bd4c989fc8a"}
{"func_before":"         *     and the cache timeout adjusted, but these changes are\n         *     not persistent.\n         *\n         **********\/\n\n#ifndef NETSNMP_NO_WRITE_SUPPORT\n        case MODE_SET_RESERVE1:\n            \/*\n             * Validate the new assignments\n             *\/\n            switch (table_info->colnum) {\n                    _free_extension( extension, eptr );\n                    break;\n                }\n            }\n            break;\n#endif \/* !NETSNMP_NO_WRITE_SUPPORT *\/ \n\n        default:\n            netsnmp_set_request_error(reqinfo, request, SNMP_ERR_GENERR);\n            return SNMP_ERR_GENERR;\n        }\n    }\n\n#ifndef NETSNMP_NO_WRITE_SUPPORT\n    \/*\n     * If we're marking a given row as active,\n     *  then we need to check that it's ready.\n     *\/\n    if (need_to_validate) {\n                    return SNMP_ERR_INCONSISTENTVALUE;\n                }\n            }\n        }\n    }\n#endif \/* !NETSNMP_NO_WRITE_SUPPORT *\/\n    \n    return SNMP_ERR_NOERROR;\n}","target":1,"flaw_line_index":0,"hash":"c249757e-2bc1-44bd-a6b3-6dbf2c794ac3","idx":"0283e336-9ecf-48a9-99b3-c960a071e01d"}
{"func_before":"         *     and the cache timeout adjusted, but these changes are\n         *     not persistent.\n         *\n         **********\/\n\n#if !defined(NETSNMP_NO_WRITE_SUPPORT) && ENABLE_EXTEND_WRITE_ACCESS\n        case MODE_SET_RESERVE1:\n            \/*\n             * Validate the new assignments\n             *\/\n            switch (table_info->colnum) {\n                    _free_extension( extension, eptr );\n                    break;\n                }\n            }\n            break;\n#endif \/* !NETSNMP_NO_WRITE_SUPPORT and ENABLE_EXTEND_WRITE_ACCESS *\/\n\n        default:\n            netsnmp_set_request_error(reqinfo, request, SNMP_ERR_GENERR);\n            return SNMP_ERR_GENERR;\n        }\n    }\n\n#if !defined(NETSNMP_NO_WRITE_SUPPORT) && ENABLE_EXTEND_WRITE_ACCESS\n    \/*\n     * If we're marking a given row as active,\n     *  then we need to check that it's ready.\n     *\/\n    if (need_to_validate) {\n                    return SNMP_ERR_INCONSISTENTVALUE;\n                }\n            }\n        }\n    }\n#endif \/* !NETSNMP_NO_WRITE_SUPPORT && ENABLE_EXTEND_WRITE_ACCESS *\/\n    \n    return SNMP_ERR_NOERROR;\n}","target":0,"flaw_line_index":0,"hash":"e3bf3276-8c6b-46f6-b7e2-99a57f78bbac","idx":"8c594c02-b8ef-4c73-b0d2-895adbac6374"}
{"func_before":"{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct urb *urb, *curr_urb = NULL;\n\tstruct max3421_ep *max3421_ep;\n\tint epnum, force_toggles = 0;\n\tstruct usb_host_endpoint *ep;\n\tstruct list_head *pos;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\t\t\t * Initialization via SETUP Token:\n\t\t\t *\/\n\t\t\tusb_settoggle(urb->dev, epnum, 0, 1);\n\t\t\tusb_settoggle(urb->dev, epnum, 1, 1);\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_SETUP;\n\t\t\tforce_toggles = 1;\n\t\t} else\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_TRANSFER;\n\t}\n\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\n\tmax3421_ep->last_active = max3421_hcd->frame_number;\n\tmax3421_set_address(hcd, urb->dev, epnum, force_toggles);\n\tmax3421_set_speed(hcd, urb->dev);\n\tmax3421_next_transfer(hcd, 0);\n\treturn 1;\n}","target":1,"flaw_line_index":0,"hash":"22444c73-cf92-4720-9384-f3c65fce8fc9","idx":"ac1a0148-9b09-4356-962f-31090b066995"}
{"func_before":"{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct urb *urb, *curr_urb = NULL;\n\tstruct max3421_ep *max3421_ep;\n\tint epnum;\n\tstruct usb_host_endpoint *ep;\n\tstruct list_head *pos;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\t\t\t * See USB 2.0 spec section 8.6.1\n\t\t\t * Initialization via SETUP Token:\n\t\t\t *\/\n\t\t\tusb_settoggle(urb->dev, epnum, 0, 1);\n\t\t\tusb_settoggle(urb->dev, epnum, 1, 1);\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_SETUP;\n\t\t} else\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_TRANSFER;\n\t}\n\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\n\tmax3421_ep->last_active = max3421_hcd->frame_number;\n\tmax3421_set_address(hcd, urb->dev, epnum);\n\tmax3421_set_speed(hcd, urb->dev);\n\tmax3421_next_transfer(hcd, 0);\n\treturn 1;\n}","target":0,"flaw_line_index":0,"hash":"833c88f4-8a78-4887-b136-4996ff2721a7","idx":"225293c9-dabf-4363-b817-631c6378cf3e"}
{"func_before":"\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);","target":1,"flaw_line_index":0,"hash":"fb62126b-0d18-449c-a8d3-afbfe4ae7126","idx":"ed8719bb-0d9e-480d-926d-ebe1d64f005a"}
{"func_before":"\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);","target":0,"flaw_line_index":0,"hash":"3859b23a-01aa-4b15-85ea-56acb4436ead","idx":"6a443852-f6a2-419b-8a04-5e3f01a7eccb"}
{"func_before":"\t\t\tbreak;\n\t\t}\n\t\t\/* Stop if we don't have enough data *\/\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t\/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL *\/","target":1,"flaw_line_index":0,"hash":"d7ab3f11-ef13-40d0-8731-529d5ab7b452","idx":"451094d2-6f40-4f47-81ac-031554a26afd"}
{"func_before":"\t\t\tbreak;\n\t\t}\n\t\t\/* Stop if we don't have enough data *\/\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t\/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL *\/","target":0,"flaw_line_index":0,"hash":"341cbffd-b206-4cdb-b964-34397a03cadd","idx":"e1bf0128-caf6-4961-9d27-d1ea2b0cb9bf"}
{"func_before":"static void eb_mul_sim_kbltz(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m, const eb_t *t) {\n\tint i, l, l0, l1, n0, n1, w, g;\n\tint8_t u, tnaf0[RLC_FB_BITS + 8], tnaf1[RLC_FB_BITS + 8], *_k, *_m;\n\teb_t t0[1 << (EB_WIDTH - 2)];\n\teb_t t1[1 << (EB_WIDTH - 2)];\n\n\tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\teb_null(t0[i]);\n\t\teb_null(t1[i]);\n\t}","target":1,"flaw_line_index":0,"hash":"95d5d65a-eb6c-4d99-812f-63bc931c6fbd","idx":"80c82fe4-d7cf-4efe-91b2-1e0fdf813b98"}
{"func_before":"static void eb_mul_sim_kbltz(eb_t r, const eb_t p, const bn_t k, const eb_t q,\n\t\tconst bn_t m, const eb_t *t) {\n\tint i, n0, n1, w, g;\n\tint8_t u, tnaf0[RLC_FB_BITS + 8], tnaf1[RLC_FB_BITS + 8], *_k, *_m;\n\teb_t t0[1 << (EB_WIDTH - 2)];\n\teb_t t1[1 << (EB_WIDTH - 2)];\n\tsize_t l, l0, l1;\n\n\tfor (i =  0; i < (1 << (EB_WIDTH - 2)); i++) {\n\t\teb_null(t0[i]);\n\t\teb_null(t1[i]);\n\t}","target":0,"flaw_line_index":0,"hash":"3f468ba4-b22e-44d1-b7bd-42b2174cef52","idx":"bd5696b9-76f8-4945-bfae-c59fd9df31cc"}
{"func_before":"    addrToUrlSafeString(&RemoteAddr, urlAddr);\n    sprintf(rtspTargetUrl, \"rtsp:\/\/%s\", urlAddr);\n    currentSeqNumber = 1;\n    hasSessionId = 0;\n\n    switch (ServerMajorVersion) {\n        case 3:\n            rtspClientVersion = 10;\n            break;\n        case 4:\n            rtspClientVersion = 11;\n            rtspClientVersion = 14;\n            break;\n    }\n    \n    \/\/ Gen 5 servers use ENet to do the RTSP handshake\n    if (ServerMajorVersion >= 5) {\n        ENetAddress address;\n        ENetEvent event;\n        \n        enet_address_set_address(&address, (struct sockaddr *)&RemoteAddr, RemoteAddrLen);\n        enet_address_set_port(&address, 48010);\n        RTSP_MESSAGE response;\n        char* sessionId;\n        int error = -1;\n\n        if (!setupStream(&response,\n                         ServerMajorVersion >= 5 ? \"streamid=audio\/0\/0\" : \"streamid=audio\",\n                         &error)) {\n            Limelog(\"RTSP SETUP streamid=audio request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n    {\n        RTSP_MESSAGE response;\n        int error = -1;\n\n        if (!setupStream(&response,\n                         ServerMajorVersion >= 5 ? \"streamid=video\/0\/0\" : \"streamid=video\",\n                         &error)) {\n            Limelog(\"RTSP SETUP streamid=video request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n        }\n\n        freeMessage(&response);\n    }\n    \n    if (ServerMajorVersion >= 5) {\n        RTSP_MESSAGE response;\n        int error = -1;\n\n        if (!setupStream(&response, \"streamid=control\/1\/0\", &error)) {\n            Limelog(\"RTSP SETUP streamid=control request failed: %d\\n\", error);\n    \n    ret = 0;\n    \nExit:\n    \/\/ Cleanup the ENet stuff\n    if (ServerMajorVersion >= 5) {\n        if (peer != NULL) {\n            enet_peer_disconnect_now(peer, 0);\n            peer = NULL;\n        }\n        ","target":1,"flaw_line_index":0,"hash":"085a646a-b194-4323-a0d1-0e99a8f26896","idx":"1998d1ca-68a0-464a-99ef-9e7f22b5a4ec"}
{"func_before":"    addrToUrlSafeString(&RemoteAddr, urlAddr);\n    sprintf(rtspTargetUrl, \"rtsp:\/\/%s\", urlAddr);\n    currentSeqNumber = 1;\n    hasSessionId = 0;\n\n    switch (AppVersionQuad[0]) {\n        case 3:\n            rtspClientVersion = 10;\n            break;\n        case 4:\n            rtspClientVersion = 11;\n            rtspClientVersion = 14;\n            break;\n    }\n    \n    \/\/ Gen 5 servers use ENet to do the RTSP handshake\n    if (AppVersionQuad[0] >= 5) {\n        ENetAddress address;\n        ENetEvent event;\n        \n        enet_address_set_address(&address, (struct sockaddr *)&RemoteAddr, RemoteAddrLen);\n        enet_address_set_port(&address, 48010);\n        RTSP_MESSAGE response;\n        char* sessionId;\n        int error = -1;\n\n        if (!setupStream(&response,\n                         AppVersionQuad[0] >= 5 ? \"streamid=audio\/0\/0\" : \"streamid=audio\",\n                         &error)) {\n            Limelog(\"RTSP SETUP streamid=audio request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n    {\n        RTSP_MESSAGE response;\n        int error = -1;\n\n        if (!setupStream(&response,\n                         AppVersionQuad[0] >= 5 ? \"streamid=video\/0\/0\" : \"streamid=video\",\n                         &error)) {\n            Limelog(\"RTSP SETUP streamid=video request failed: %d\\n\", error);\n            ret = error;\n            goto Exit;\n        }\n        }\n\n        freeMessage(&response);\n    }\n    \n    if (AppVersionQuad[0] >= 5) {\n        RTSP_MESSAGE response;\n        int error = -1;\n\n        if (!setupStream(&response, \"streamid=control\/1\/0\", &error)) {\n            Limelog(\"RTSP SETUP streamid=control request failed: %d\\n\", error);\n    \n    ret = 0;\n    \nExit:\n    \/\/ Cleanup the ENet stuff\n    if (AppVersionQuad[0] >= 5) {\n        if (peer != NULL) {\n            enet_peer_disconnect_now(peer, 0);\n            peer = NULL;\n        }\n        ","target":0,"flaw_line_index":0,"hash":"9934dd11-9053-4d5d-a64f-3093e5b97676","idx":"f4ee6b72-6d8e-4ab2-a7b3-da6001f522e4"}
{"func_before":"    } else {\n      output_tree_ids.setConstant(latest_tree);\n      auto do_work = [&resource, &bucketized_features, &cached_tree_ids,\n                      &cached_node_ids, &output_partial_logits,\n                      &output_node_ids, latest_tree,\n                      this](int32 start, int32 end) {\n        for (int32 i = start; i < end; ++i) {\n          int32 tree_id = cached_tree_ids(i);\n          int32 node_id = cached_node_ids(i);\n          std::vector<float> partial_tree_logits(logits_dimension_, 0.0);\n","target":1,"flaw_line_index":0,"hash":"1f2846f5-79b9-4b58-bf09-7c8a6c429e2c","idx":"0befc171-abd3-4a0c-ad82-253b7f601fce"}
{"func_before":"    } else {\n      output_tree_ids.setConstant(latest_tree);\n      auto do_work = [&resource, &bucketized_features, &cached_tree_ids,\n                      &cached_node_ids, &output_partial_logits,\n                      &output_node_ids, latest_tree,\n                      this](int64 start, int64 end) {\n        for (int32 i = start; i < end; ++i) {\n          int32 tree_id = cached_tree_ids(i);\n          int32 node_id = cached_node_ids(i);\n          std::vector<float> partial_tree_logits(logits_dimension_, 0.0);\n","target":0,"flaw_line_index":0,"hash":"4f051035-873d-46f3-95d1-29de0fa0c4f2","idx":"7a475a0c-29b7-4b72-8cfa-7b6b7c56f5d9"}
{"func_before":"\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\tWARN_ON(sk->sk_wmem_queued);\n\tWARN_ON(sk->sk_forward_alloc);\n\n\tkfree(inet->opt);\n\tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\n\tsk_refcnt_debug_dec(sk);\n}","target":1,"flaw_line_index":0,"hash":"e141d6fa-b334-46c8-b868-7de5930f216f","idx":"b738d1b0-e11a-49c4-b2ab-222463a176b7"}
{"func_before":"\tWARN_ON(atomic_read(&sk->sk_rmem_alloc));\n\tWARN_ON(atomic_read(&sk->sk_wmem_alloc));\n\tWARN_ON(sk->sk_wmem_queued);\n\tWARN_ON(sk->sk_forward_alloc);\n\n\tkfree(rcu_dereference_protected(inet->inet_opt, 1));\n\tdst_release(rcu_dereference_check(sk->sk_dst_cache, 1));\n\tsk_refcnt_debug_dec(sk);\n}","target":0,"flaw_line_index":0,"hash":"fff311fd-5bdf-45c5-9e56-5fc50a7c83de","idx":"8c368dd4-919e-4bab-83a9-b52f8db34506"}
{"func_before":"\t\tGF_SAFEALLOC(op, LHEVC_OperatingPoint);\n\t\tif (!op) return GF_OUT_OF_MEM;\n\t\top->output_layer_set_idx = gf_bs_read_u16(bs);\n\t\top->max_temporal_id = gf_bs_read_u8(bs);\n\t\top->layer_count = gf_bs_read_u8(bs);\n\t\tif (op->layer_count > GF_ARRAY_LENGTH(op->layers_info))\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\tfor (j = 0; j < op->layer_count; j++) {\n\t\t\top->layers_info[j].ptl_idx = gf_bs_read_u8(bs);\n\t\t\top->layers_info[j].layer_id = gf_bs_read_int(bs, 6);\n\t\t\top->layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t\top->layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;","target":1,"flaw_line_index":0,"hash":"a098f3ef-c7b2-4d41-971b-335e844fa06e","idx":"2a608ae6-d970-41d7-84e4-c26c50b55028"}
{"func_before":"\t\tGF_SAFEALLOC(op, LHEVC_OperatingPoint);\n\t\tif (!op) return GF_OUT_OF_MEM;\n\t\top->output_layer_set_idx = gf_bs_read_u16(bs);\n\t\top->max_temporal_id = gf_bs_read_u8(bs);\n\t\top->layer_count = gf_bs_read_u8(bs);\n\t\tif (op->layer_count > GF_ARRAY_LENGTH(op->layers_info)) {\n\t\t\tgf_free(op);\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t\tfor (j = 0; j < op->layer_count; j++) {\n\t\t\top->layers_info[j].ptl_idx = gf_bs_read_u8(bs);\n\t\t\top->layers_info[j].layer_id = gf_bs_read_int(bs, 6);\n\t\t\top->layers_info[j].is_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;\n\t\t\top->layers_info[j].is_alternate_outputlayer = gf_bs_read_int(bs, 1) ? GF_TRUE : GF_FALSE;","target":0,"flaw_line_index":0,"hash":"f097ce6c-df92-44ea-9a13-cd7edd4aef03","idx":"f88fc31e-492e-4570-8fc1-9d1694509e54"}
{"func_before":"\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\tkfree(vch);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn rpdev_ctrl;\n}","target":1,"flaw_line_index":0,"hash":"0c72ccfa-5bd6-4a7c-93bb-120048caa6c8","idx":"488564a2-3fa0-41c0-b5cd-4d7bdaa365f9"}
{"func_before":"\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\t\/* vch will be free in virtio_rpmsg_release_device() *\/\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn rpdev_ctrl;\n}","target":0,"flaw_line_index":0,"hash":"eda2e59f-7b9e-47cb-907e-090fb9bdaea2","idx":"864dd0f8-9f40-4116-890f-2e6e48ab0c9d"}
{"func_before":"\t\tif (prop_size>4) {\n\t\t\ttag_size-=2;\n\t\t\tprop_type = gf_bs_read_u16(bs);\n\t\t\tprop_size -= 6;\n\t\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)\n\t\t\t\/\/add 2 extra bytes for UTF16 case string dump\n\t\t\tdata2 = gf_malloc(sizeof(char) * (prop_size+2));\n\t\t\tgf_bs_read_data(bs, data2, prop_size);\n\t\t\tdata2[prop_size] = 0;\n\t\t\tdata2[prop_size+1] = 0;\n\t\t\ttag_size-=prop_size;\n\t\t} else {\n\t\t\tprop_size = 0;\n\t\t}\n\t\tGF_SAFEALLOC(tag, GF_XtraTag)","target":1,"flaw_line_index":0,"hash":"240c8790-8eb7-41f9-ac01-f908e1070519","idx":"6d6d4f41-7b4c-4c8c-960a-69003f4822d5"}
{"func_before":"\t\tif (prop_size>4) {\n\t\t\ttag_size-=2;\n\t\t\tprop_type = gf_bs_read_u16(bs);\n\t\t\tprop_size -= 6;\n\t\t\tISOM_DECREASE_SIZE_NO_ERR(ptr, prop_size)\n\t\t\t\/\/add 3 extra bytes for UTF16 case string dump (3 because we need 0-aligned short value)\n\t\t\tdata2 = gf_malloc(sizeof(char) * (prop_size+3));\n\t\t\tgf_bs_read_data(bs, data2, prop_size);\n\t\t\tdata2[prop_size] = 0;\n\t\t\tdata2[prop_size+1] = 0;\n\t\t\tdata2[prop_size+2] = 0;\n\t\t\ttag_size-=prop_size;\n\t\t} else {\n\t\t\tprop_size = 0;\n\t\t}\n\t\tGF_SAFEALLOC(tag, GF_XtraTag)","target":0,"flaw_line_index":0,"hash":"13c9265d-26ca-4f37-ac7e-bac33269792a","idx":"59299325-0703-4f44-a72b-e82fa75cc01e"}
{"func_before":"  void Compute(OpKernelContext* ctx) override {\n    \/\/ This call processes inputs 1 and 2 to write output 0.\n    ReshapeOp::Compute(ctx);\n\n    const float input_min_float = ctx->input(2).flat<float>()(0);\n    const float input_max_float = ctx->input(3).flat<float>()(0);\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));\n    output_min->flat<float>()(0) = input_min_float;\n\n    Tensor* output_max = nullptr;","target":1,"flaw_line_index":0,"hash":"5815aac8-09b3-47e7-9038-3603d9a9a737","idx":"0d433466-b767-4785-9ba0-0c8ebb00ddfb"}
{"func_before":"  void Compute(OpKernelContext* ctx) override {\n    \/\/ This call processes inputs 1 and 2 to write output 0.\n    ReshapeOp::Compute(ctx);\n    if (!ctx->status().ok()) {\n      return;\n    }\n\n    const auto& input_min_float_tensor = ctx->input(2);\n    const auto& input_min_float_shape = input_min_float_tensor.shape();\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsScalar(input_min_float_shape) ||\n                    (TensorShapeUtils::IsVector(input_min_float_shape) &&\n                     (input_min_float_shape.dim_size(0) == 1)),\n                errors::InvalidArgument(\n                    \"input_min must be a scalar or a vector of 1 element\"));\n    const float input_min_float = input_min_float_tensor.flat<float>()(0);\n    const auto& input_max_float_tensor = ctx->input(3);\n    const auto& input_max_float_shape = input_max_float_tensor.shape();\n    OP_REQUIRES(ctx,\n                TensorShapeUtils::IsScalar(input_max_float_shape) ||\n                    (TensorShapeUtils::IsVector(input_max_float_shape) &&\n                     (input_max_float_shape.dim_size(0) == 1)),\n                errors::InvalidArgument(\n                    \"input_max must be a scalar or a vector of 1 element\"));\n    const float input_max_float = input_max_float_tensor.flat<float>()(0);\n\n    Tensor* output_min = nullptr;\n    OP_REQUIRES_OK(ctx, ctx->allocate_output(1, TensorShape({}), &output_min));\n    output_min->flat<float>()(0) = input_min_float;\n\n    Tensor* output_max = nullptr;","target":0,"flaw_line_index":0,"hash":"3838bf63-510f-4cdb-90e3-d9b073f04ef2","idx":"68949a25-2805-4f40-8401-e17ac7ce53cd"}
{"func_before":"        connectionLostPackets(lastPacketInStream, streamPacketIndex);\n    }\n    lastPacketInStream = streamPacketIndex;\n\n    \/\/ If this is the first packet, skip the frame header (if one exists)\n    if (firstPacket && ServerMajorVersion >= 5) {\n        currentPos.offset += 8;\n        currentPos.length -= 8;\n    }\n\n    if (firstPacket && isIdrFrameStart(&currentPos))","target":1,"flaw_line_index":0,"hash":"8ae3cfa1-beb6-47e3-8a23-ace4c6b8d87e","idx":"63ea69ee-d86f-43fe-bc66-e5f3526ab6af"}
{"func_before":"        connectionLostPackets(lastPacketInStream, streamPacketIndex);\n    }\n    lastPacketInStream = streamPacketIndex;\n\n    \/\/ If this is the first packet, skip the frame header (if one exists)\n    if (firstPacket && AppVersionQuad[0] >= 5) {\n        currentPos.offset += 8;\n        currentPos.length -= 8;\n    }\n\n    if (firstPacket && isIdrFrameStart(&currentPos))","target":0,"flaw_line_index":0,"hash":"a124e5ee-dd4d-458c-be9e-fe856d06a60e","idx":"3be02aff-a5e1-4d4e-95a5-4ba769729bf8"}
{"func_before":"void AverageEvalQuantizedUint8(TfLiteContext* context, TfLiteNode* node,\n                               TfLitePoolParams* params, OpData* data,\n                               const TfLiteTensor* input,\n                               TfLiteTensor* output) {\n  int32_t activation_min;\n  int32_t activation_max;\n  (void)CalculateActivationRangeQuantized(context, params->activation, output,\n                                          &activation_min, &activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                         \\\n  tflite::PoolParams op_params;                                            \\\n  op_params.stride_height = params->stride_height;                         \\\n  op_params.stride_width = params->stride_width;                           \\\n  op_params.filter_height = params->filter_height;                         \\\n  op_params.filter_width = params->filter_width;                           \\\n  op_params.padding_values.height = data->padding.height;                  \\\n  op_params.padding_values.width = data->padding.width;                    \\\n  op_params.quantized_activation_min = activation_min;                     \\\n  op_params.quantized_activation_max = activation_max;                     \\\n  type::AveragePool(op_params, GetTensorShape(input),                      \\\n                    GetTensorData<uint8_t>(input), GetTensorShape(output), \\\n                    GetTensorData<uint8_t>(output))\n  if (kernel_type == kReference) {\n    TF_LITE_AVERAGE_POOL(reference_ops);\n  } else {\n    TF_LITE_AVERAGE_POOL(optimized_ops);\n  }\n#undef TF_LITE_AVERAGE_POOL\n}","target":1,"flaw_line_index":0,"hash":"ea3ff1eb-63cf-4fac-908f-0d8a2c0021e4","idx":"4037c9b0-8195-4f84-839d-583725a1e048"}
{"func_before":"TfLiteStatus AverageEvalQuantizedUint8(TfLiteContext* context, TfLiteNode* node,\n                                       TfLitePoolParams* params, OpData* data,\n                                       const TfLiteTensor* input,\n                                       TfLiteTensor* output) {\n  int32_t activation_min;\n  int32_t activation_max;\n  (void)CalculateActivationRangeQuantized(context, params->activation, output,\n                                          &activation_min, &activation_max);\n#define TF_LITE_AVERAGE_POOL(type)                                            \\\n  tflite::PoolParams op_params;                                               \\\n  op_params.stride_height = params->stride_height;                            \\\n  op_params.stride_width = params->stride_width;                              \\\n  op_params.filter_height = params->filter_height;                            \\\n  op_params.filter_width = params->filter_width;                              \\\n  op_params.padding_values.height = data->padding.height;                     \\\n  op_params.padding_values.width = data->padding.width;                       \\\n  op_params.quantized_activation_min = activation_min;                        \\\n  op_params.quantized_activation_max = activation_max;                        \\\n  TF_LITE_ENSURE(context, type::AveragePool(op_params, GetTensorShape(input), \\\n                                            GetTensorData<uint8_t>(input),    \\\n                                            GetTensorShape(output),           \\\n                                            GetTensorData<uint8_t>(output)))\n  if (kernel_type == kReference) {\n    TF_LITE_AVERAGE_POOL(reference_ops);\n  } else {\n    TF_LITE_AVERAGE_POOL(optimized_ops);\n  }\n#undef TF_LITE_AVERAGE_POOL\n  return kTfLiteOk;\n}","target":0,"flaw_line_index":0,"hash":"eb050626-b304-4c0b-ab68-2d09f42d1b16","idx":"da7a64a2-85b8-44b6-929f-6d5d203d4064"}
{"func_before":"static void ep2_mul_naf_imp(ep2_t r, const ep2_t p, const bn_t k) {\n\tint l, i, n;\n\tint8_t naf[RLC_FP_BITS + 1];\n\tep2_t t[1 << (EP_WIDTH - 2)];\n\n\tRLC_TRY {\n\t\t\/* Prepare the precomputation table. *\/\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep2_null(t[i]);\n\t\t\tep2_new(t[i]);\n\t\t}\n\t\t\/* Compute the precomputation table. *\/\n\t\tep2_tab(t, p, EP_WIDTH);\n\t\t\/* Compute the w-NAF representation of k. *\/\n\t\tl = sizeof(naf);\n\t\tbn_rec_naf(naf, &l, k, EP_WIDTH);\n\n\t\tep2_set_infty(r);\n\t\tfor (i = l - 1; i >= 0; i--) {\n\t\t\tep2_dbl(r, r);\n\n\t\t\tn = naf[i];\n\t\t\tif (n > 0) {\n\t\t\t\tep2_add(r, r, t[n \/ 2]);\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t\/* Free the precomputation table. *\/\n\t\tfor (i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep2_free(t[i]);\n\t\t}\n\t}\n}","target":1,"flaw_line_index":0,"hash":"5b84e8a9-36e6-4cdc-a428-1e629b72bd9f","idx":"8008c77a-2151-48cd-a6f8-f10ef3222a46"}
{"func_before":"static void ep2_mul_naf_imp(ep2_t r, const ep2_t p, const bn_t k) {\n\tsize_t l, n;\n\tint8_t naf[RLC_FP_BITS + 1];\n\tep2_t t[1 << (EP_WIDTH - 2)];\n\n\tRLC_TRY {\n\t\t\/* Prepare the precomputation table. *\/\n\t\tfor (int i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep2_null(t[i]);\n\t\t\tep2_new(t[i]);\n\t\t}\n\t\t\/* Compute the precomputation table. *\/\n\t\tep2_tab(t, p, EP_WIDTH);\n\t\t\/* Compute the w-NAF representation of k. *\/\n\t\tl = sizeof(naf);\n\t\tbn_rec_naf(naf, &l, k, EP_WIDTH);\n\n\t\tep2_set_infty(r);\n\t\tfor (int i = l - 1; i >= 0; i--) {\n\t\t\tep2_dbl(r, r);\n\n\t\t\tn = naf[i];\n\t\t\tif (n > 0) {\n\t\t\t\tep2_add(r, r, t[n \/ 2]);\n\tRLC_CATCH_ANY {\n\t\tRLC_THROW(ERR_CAUGHT);\n\t}\n\tRLC_FINALLY {\n\t\t\/* Free the precomputation table. *\/\n\t\tfor (int i = 0; i < (1 << (EP_WIDTH - 2)); i++) {\n\t\t\tep2_free(t[i]);\n\t\t}\n\t}\n}","target":0,"flaw_line_index":0,"hash":"7d0d3041-c083-494e-9af9-f2c3f4c803e9","idx":"b68ec1c1-81f5-4244-ac75-e70ec1659848"}
{"func_before":"\tif (ctxt->ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR)\n\t\tsize = offsetof(struct fxregs_state, xmm_space[8 * 16\/4]);\n\telse\n\t\tsize = offsetof(struct fxregs_state, xmm_space[0]);\n\n\treturn segmented_write(ctxt, ctxt->memop.addr.mem, &fx_state, size);\n}","target":1,"flaw_line_index":0,"hash":"4be8b0c7-1c9b-46ec-8ac4-9fa21178888b","idx":"38a7dd44-7014-4372-a611-3cf8c8fd9d39"}
{"func_before":"\tif (ctxt->ops->get_cr(ctxt, 4) & X86_CR4_OSFXSR)\n\t\tsize = offsetof(struct fxregs_state, xmm_space[8 * 16\/4]);\n\telse\n\t\tsize = offsetof(struct fxregs_state, xmm_space[0]);\n\n\treturn segmented_write_std(ctxt, ctxt->memop.addr.mem, &fx_state, size);\n}","target":0,"flaw_line_index":0,"hash":"89d09234-d8ab-4471-9bc2-948643618a49","idx":"0806b791-5de6-4ce5-bfe3-7a0c65a199ba"}
{"func_before":"\t\t\t\t   const pj_str_t *cnonce,\n\t\t\t\t   pj_uint32_t nc,\n\t\t\t\t   const pj_str_t *method)\n{\n    const pj_str_t pjsip_AKAv1_MD5_STR = { \"AKAv1-MD5\", 9 };\n    pj_bool_t algo_sha256 = PJ_FALSE;\n\n    \/* Check if algo is sha256 *\/\n#if PJSIP_AUTH_HAS_DIGEST_SHA256\n    algo_sha256 = (pj_stricmp(&chal->algorithm, &pjsip_SHA256_STR)==0);\n#endif\n\t\t\t\t\t    method, cred);\n\t}\n\telse {\n\t    \/* Convert digest to string and store in chal->response. *\/\n\t    if (algo_sha256) {\n\t\tpjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &cred->response, &cred->nonce, NULL,\n\t\t\t\t\t  NULL,  NULL, uri, &chal->realm,\n\t\t\t\t\t  cred_info, method);\n\t    } else {\n\t\tpjsip_auth_create_digest( &cred->response, &cred->nonce, NULL,\n\t\t\t\t\t  NULL,  NULL, uri, &chal->realm,\n\t\t\t\t\t  cred_info, method);\n\t    }\n\t}\n\n    } else if (has_auth_qop(pool, &chal->qop)) {\n\t\/* Server requires quality of protection.\n\t\t\t\t\t    method, cred);\n\t}\n\telse {\n\t    \/* Convert digest to string and store in chal->response. *\/\n\t    if (algo_sha256) {\n\t\tpjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &cred->response, &cred->nonce,\n\t\t\t\t\t  &cred->nc, &cred->cnonce,\n\t\t\t\t\t  &pjsip_AUTH_STR, uri,\n\t\t\t\t\t  &chal->realm, cred_info,\n\t\t\t\t\t  method);\n\t    } else {\n\t\tpjsip_auth_create_digest( &cred->response, &cred->nonce,\n\t\t\t\t\t  &cred->nc, &cred->cnonce,\n\t\t\t\t\t  &pjsip_AUTH_STR, uri,\n\t\t\t\t\t  &chal->realm, cred_info,\n\t\t\t\t\t  method);\n\t    }\n\t}\n\n    } else {\n\t\/* Server requires quality protection that we don't support. *\/\n\tPJ_LOG(4,(THIS_FILE, \"Unsupported qop offer %.*s\",\n\t\t  chal->qop.slen, chal->qop.ptr));\n\treturn PJSIP_EINVALIDQOP;\n    }\n\n    return PJ_SUCCESS;\n}","target":1,"flaw_line_index":0,"hash":"792ab5af-0cc2-412c-8b9d-f80626c5ff7f","idx":"e5a3660d-204a-4a96-b0e2-a7c6a89e9128"}
{"func_before":"\t\t\t\t   pj_uint32_t nc,\n\t\t\t\t   const pj_str_t *method)\n{\n    const pj_str_t pjsip_AKAv1_MD5_STR = { \"AKAv1-MD5\", 9 };\n    pj_bool_t algo_sha256 = PJ_FALSE;\n    pj_status_t status = PJ_SUCCESS;\n\n    \/* Check if algo is sha256 *\/\n#if PJSIP_AUTH_HAS_DIGEST_SHA256\n    algo_sha256 = (pj_stricmp(&chal->algorithm, &pjsip_SHA256_STR)==0);\n#endif\n\t\t\t\t\t    method, cred);\n\t}\n\telse {\n\t    \/* Convert digest to string and store in chal->response. *\/\n\t    if (algo_sha256) {\n\t\tstatus = pjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &cred->response, &cred->nonce, NULL,\n\t\t\t\t\t  NULL,  NULL, uri, &chal->realm,\n\t\t\t\t\t  cred_info, method);\n\t    } else {\n\t\tstatus = pjsip_auth_create_digest( &cred->response, \n\t\t\t\t\t  &cred->nonce, NULL, NULL, NULL, uri, \n\t\t\t\t\t  &chal->realm, cred_info, method);\n\t    }\n\t}\n\n    } else if (has_auth_qop(pool, &chal->qop)) {\n\t\/* Server requires quality of protection.\n\t\t\t\t\t    method, cred);\n\t}\n\telse {\n\t    \/* Convert digest to string and store in chal->response. *\/\n\t    if (algo_sha256) {\n\t\tstatus = pjsip_auth_create_digestSHA256(\n\t\t\t\t\t  &cred->response, &cred->nonce,\n\t\t\t\t\t  &cred->nc, &cred->cnonce,\n\t\t\t\t\t  &pjsip_AUTH_STR, uri,\n\t\t\t\t\t  &chal->realm, cred_info,\n\t\t\t\t\t  method);\n\t    } else {\n\t\tstatus = pjsip_auth_create_digest( &cred->response, \n\t\t\t\t\t  &cred->nonce, &cred->nc, \n\t\t\t\t          &cred->cnonce, &pjsip_AUTH_STR, \n\t\t\t\t\t  uri, &chal->realm, \n\t\t\t\t\t  cred_info, method);\n\t    }\n\t}\n\n    } else {\n\t\/* Server requires quality protection that we don't support. *\/\n\tPJ_LOG(4,(THIS_FILE, \"Unsupported qop offer %.*s\",\n\t\t  chal->qop.slen, chal->qop.ptr));\n\treturn PJSIP_EINVALIDQOP;\n    }\n\n    return status;\n}","target":0,"flaw_line_index":0,"hash":"ec2ff706-e4cb-430d-8aa9-dae9fe53dc06","idx":"35105c0c-023f-48fb-a169-6fd1d2c4595d"}
{"func_before":"\t\tfh = (struct frag_hdr*)__skb_push(skb, sizeof(struct frag_hdr));\n\t\t__skb_push(skb, hlen);\n\t\tskb_reset_network_header(skb);\n\t\tmemcpy(skb_network_header(skb), tmp_hdr, hlen);\n\n\t\tipv6_select_ident(fh);\n\t\tfh->nexthdr = nexthdr;\n\t\tfh->reserved = 0;\n\t\tfh->frag_off = htons(IP6_MF);\n\t\tfrag_id = fh->identification;\n\n\t\t *\tBuild fragment header.\n\t\t *\/\n\t\tfh->nexthdr = nexthdr;\n\t\tfh->reserved = 0;\n\t\tif (!frag_id) {\n\t\t\tipv6_select_ident(fh);\n\t\t\tfrag_id = fh->identification;\n\t\t} else\n\t\t\tfh->identification = frag_id;\n\n\t\t\/*","target":1,"flaw_line_index":0,"hash":"f7d7dbb1-5556-4305-a5e3-600043bd75be","idx":"1ef5e782-940a-4130-8109-69d8ec834f98"}
{"func_before":"\t\tfh = (struct frag_hdr*)__skb_push(skb, sizeof(struct frag_hdr));\n\t\t__skb_push(skb, hlen);\n\t\tskb_reset_network_header(skb);\n\t\tmemcpy(skb_network_header(skb), tmp_hdr, hlen);\n\n\t\tipv6_select_ident(fh, rt);\n\t\tfh->nexthdr = nexthdr;\n\t\tfh->reserved = 0;\n\t\tfh->frag_off = htons(IP6_MF);\n\t\tfrag_id = fh->identification;\n\n\t\t *\tBuild fragment header.\n\t\t *\/\n\t\tfh->nexthdr = nexthdr;\n\t\tfh->reserved = 0;\n\t\tif (!frag_id) {\n\t\t\tipv6_select_ident(fh, rt);\n\t\t\tfrag_id = fh->identification;\n\t\t} else\n\t\t\tfh->identification = frag_id;\n\n\t\t\/*","target":0,"flaw_line_index":0,"hash":"2c2afd20-f9fe-427d-a13b-316608394654","idx":"10c3c9c7-3fb3-477e-914e-6182c73b46a5"}
{"func_before":"static int persistent_prepare_exception(struct dm_exception_store *store,\n\t\t\t\t\tstruct dm_exception *e)\n{\n\tstruct pstore *ps = get_info(store);\n\tuint32_t stride;\n\tchunk_t next_free;\n\tsector_t size = get_dev_size(dm_snap_cow(store->snap)->bdev);\n\n\t\/* Is there enough room ? *\/\n\tif (size < ((ps->next_free + 1) * store->chunk_size))\n\t\treturn -ENOSPC;\n\n\t\/*\n\t * Move onto the next free pending, making sure to take\n\t * into account the location of the metadata chunks.\n\t *\/\n\tstride = (ps->exceptions_per_area + 1);\n\tnext_free = ++ps->next_free;\n\tif (sector_div(next_free, stride) == 1)\n\t\tps->next_free++;\n\n\tatomic_inc(&ps->pending_count);\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"0dd1ec2c-f8c2-4d5c-adb2-e80183a05fa9","idx":"998d486e-19a3-48a2-9f81-8464d5bbb162"}
{"func_before":"static int persistent_prepare_exception(struct dm_exception_store *store,\n\t\t\t\t\tstruct dm_exception *e)\n{\n\tstruct pstore *ps = get_info(store);\n\tsector_t size = get_dev_size(dm_snap_cow(store->snap)->bdev);\n\n\t\/* Is there enough room ? *\/\n\tif (size < ((ps->next_free + 1) * store->chunk_size))\n\t\treturn -ENOSPC;\n\n\t\/*\n\t * Move onto the next free pending, making sure to take\n\t * into account the location of the metadata chunks.\n\t *\/\n\tps->next_free++;\n\tskip_metadata(ps);\n\n\tatomic_inc(&ps->pending_count);\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"691dd88e-f729-4e00-8ea7-bba27cf726d5","idx":"ea6c27a3-bff8-4359-922f-2bfbb1a85e31"}
{"func_before":"\tint haveBits;\n\tint inPrefix;\n\tUINT32 count;\n\tUINT32 distance;\n\tBYTE* pbSegment;\n\tsize_t cbSegment = segmentSize - 1;\n\n\tif ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1))\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(stream, flags); \/* header (1 byte) *\/\n\tzgfx->OutputCount = 0;\n\tpbSegment = Stream_Pointer(stream);\n\tStream_Seek(stream, cbSegment);\n\n\tif (!(flags & PACKET_COMPRESSED))\n\t{\n\t\tzgfx_history_buffer_ring_write(zgfx, pbSegment, cbSegment);\n\t\tCopyMemory(zgfx->OutputBuffer, pbSegment, cbSegment);\n\t\tzgfx->OutputCount = cbSegment;\n\t\treturn TRUE;\n\t}\n\n\t\t\t\t\tc = (BYTE)(ZGFX_TOKEN_TABLE[opIndex].valueBase + zgfx->bits);\n\t\t\t\t\tzgfx->HistoryBuffer[zgfx->HistoryIndex] = c;\n\n\t\t\t\t\tif (++zgfx->HistoryIndex == zgfx->HistoryBufferSize)\n\t\t\t\t\t\tzgfx->HistoryIndex = 0;\n\n\t\t\t\t\tzgfx->OutputBuffer[zgfx->OutputCount++] = c;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tzgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tzgfx_GetBits(zgfx, extra);\n\t\t\t\t\t\t\tcount += zgfx->bits;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tzgfx_history_buffer_ring_read(zgfx, distance, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);\n\t\t\t\t\t\tzgfx_history_buffer_ring_write(zgfx, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);\n\t\t\t\t\t\tzgfx->OutputCount += count;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\t\/* Unencoded *\/\n\t\t\t\t\t\tzgfx_GetBits(zgfx, 15);\n\t\t\t\t\t\tcount = zgfx->bits;\n\t\t\t\t\t\tzgfx->cBitsRemaining -= zgfx->cBitsCurrent;\n\t\t\t\t\t\tzgfx->cBitsCurrent = 0;\n\t\t\t\t\t\tzgfx->BitsCurrent = 0;\n\t\t\t\t\t\tCopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]), zgfx->pbInputCurrent, count);\n\t\t\t\t\t\tzgfx_history_buffer_ring_write(zgfx, zgfx->pbInputCurrent, count);\n\t\t\t\t\t\tzgfx->pbInputCurrent += count;\n\t\t\t\t\t\tzgfx->cBitsRemaining -= (8 * count);\n\t\t\t\t\t\tzgfx->OutputCount += count;","target":1,"flaw_line_index":0,"hash":"2f51bea6-c842-4519-8249-89030a1e8f4c","idx":"6d926cdf-ae05-411c-b273-08421327a67c"}
{"func_before":"\tint haveBits;\n\tint inPrefix;\n\tUINT32 count;\n\tUINT32 distance;\n\tBYTE* pbSegment;\n\tsize_t cbSegment;\n\n\tif (!zgfx || !stream)\n\t\treturn FALSE;\n\n\tcbSegment = segmentSize - 1;\n\n\tif ((Stream_GetRemainingLength(stream) < segmentSize) || (segmentSize < 1) ||\n\t    (segmentSize > UINT32_MAX))\n\t\treturn FALSE;\n\n\tStream_Read_UINT8(stream, flags); \/* header (1 byte) *\/\n\tzgfx->OutputCount = 0;\n\tpbSegment = Stream_Pointer(stream);\n\tStream_Seek(stream, cbSegment);\n\n\tif (!(flags & PACKET_COMPRESSED))\n\t{\n\t\tzgfx_history_buffer_ring_write(zgfx, pbSegment, cbSegment);\n\n\t\tif (cbSegment > sizeof(zgfx->OutputBuffer))\n\t\t\treturn FALSE;\n\n\t\tCopyMemory(zgfx->OutputBuffer, pbSegment, cbSegment);\n\t\tzgfx->OutputCount = cbSegment;\n\t\treturn TRUE;\n\t}\n\n\t\t\t\t\tzgfx->HistoryBuffer[zgfx->HistoryIndex] = c;\n\n\t\t\t\t\tif (++zgfx->HistoryIndex == zgfx->HistoryBufferSize)\n\t\t\t\t\t\tzgfx->HistoryIndex = 0;\n\n\t\t\t\t\tif (zgfx->OutputCount >= sizeof(zgfx->OutputBuffer))\n\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\tzgfx->OutputBuffer[zgfx->OutputCount++] = c;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tzgfx_GetBits(zgfx, ZGFX_TOKEN_TABLE[opIndex].valueBits);\n\n\t\t\t\t\t\t\tzgfx_GetBits(zgfx, extra);\n\t\t\t\t\t\t\tcount += zgfx->bits;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tzgfx_history_buffer_ring_read(zgfx, distance, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);\n\t\t\t\t\t\tzgfx_history_buffer_ring_write(zgfx, &(zgfx->OutputBuffer[zgfx->OutputCount]), count);\n\t\t\t\t\t\tzgfx->OutputCount += count;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tzgfx_GetBits(zgfx, 15);\n\t\t\t\t\t\tcount = zgfx->bits;\n\t\t\t\t\t\tzgfx->cBitsRemaining -= zgfx->cBitsCurrent;\n\t\t\t\t\t\tzgfx->cBitsCurrent = 0;\n\t\t\t\t\t\tzgfx->BitsCurrent = 0;\n\n\t\t\t\t\t\tif (count > sizeof(zgfx->OutputBuffer) - zgfx->OutputCount)\n\t\t\t\t\t\t\treturn FALSE;\n\n\t\t\t\t\t\tCopyMemory(&(zgfx->OutputBuffer[zgfx->OutputCount]), zgfx->pbInputCurrent, count);\n\t\t\t\t\t\tzgfx_history_buffer_ring_write(zgfx, zgfx->pbInputCurrent, count);\n\t\t\t\t\t\tzgfx->pbInputCurrent += count;\n\t\t\t\t\t\tzgfx->cBitsRemaining -= (8 * count);\n\t\t\t\t\t\tzgfx->OutputCount += count;","target":0,"flaw_line_index":0,"hash":"8f58624c-7d9c-4d8a-8d4d-e125e2913a49","idx":"82ebb9ed-d02b-485d-8ea4-4345232d31b2"}
{"func_before":"\n    if (!seq) {\n        goto bail;\n    }\n    \n    n = Jsi_ObjGetLength(interp, obj);    \n    if (n == 0) {\n        goto bail;\n    }\n    Jsi_Number nstart;\n    if (op == 2) {","target":1,"flaw_line_index":0,"hash":"ef785199-7550-49c2-9500-70dda7ec05c4","idx":"ce630ae9-ff76-4002-8b2a-3e637c8ba7b3"}
{"func_before":"\n    if (!seq) {\n        goto bail;\n    }\n    \n    n = jsi_SizeOfArray(interp, obj);    \n    if (n == 0) {\n        goto bail;\n    }\n    Jsi_Number nstart;\n    if (op == 2) {","target":0,"flaw_line_index":0,"hash":"7a8d7113-7434-4431-b9bb-051e37e301d2","idx":"d716e77e-342b-45f7-b9fa-3d48d3883eba"}
{"func_before":"\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_mutex;\n\t}\n\n\ttruncate_pagecache(inode, ioffset);\n\n\t\/* Wait for existing dio to complete *\/\n\text4_inode_block_unlocked_dio(inode);\n\tinode_dio_wait(inode);\n\n\tcredits = ext4_writepage_trans_blocks(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out_dio;\n\t}\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\nout_stop:\n\text4_journal_stop(handle);\nout_dio:\n\text4_inode_resume_unlocked_dio(inode);\nout_mutex:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}","target":1,"flaw_line_index":0,"hash":"fa3aab89-d1f0-41db-b91e-313e09808778","idx":"46095e8e-90d4-48dc-b646-bee74e7e7a65"}
{"func_before":"\t\/* Currently just for extent based files *\/\n\tif (!ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_mutex;\n\t}\n\n\t\/* Wait for existing dio to complete *\/\n\text4_inode_block_unlocked_dio(inode);\n\tinode_dio_wait(inode);\n\n\t\/*\n\t * Prevent page faults from reinstantiating pages we have released from\n\t * page cache.\n\t *\/\n\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\ttruncate_pagecache(inode, ioffset);\n\n\tcredits = ext4_writepage_trans_blocks(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tgoto out_mmap;\n\t}\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\nout_stop:\n\text4_journal_stop(handle);\nout_mmap:\n\tup_write(&EXT4_I(inode)->i_mmap_sem);\n\text4_inode_resume_unlocked_dio(inode);\nout_mutex:\n\tmutex_unlock(&inode->i_mutex);\n\treturn ret;\n}","target":0,"flaw_line_index":0,"hash":"f9c521b3-e794-414a-a99b-d8677089d87a","idx":"72d893dc-03b6-4d1e-b1f6-2f6d522d1304"}
{"func_before":"  switch (opt) {\n    case  ' ': return;  \/* ignore white spaces *\/\n    case '>': h->endian = BIG; return;\n    case '<': h->endian = LITTLE; return;\n    case '!': {\n      int a = getnum(L, fmt, MAXALIGN);\n      if (!isp2(a))\n        luaL_error(L, \"alignment %d is not a power of 2\", a);\n      h->align = a;\n      return;\n    }","target":1,"flaw_line_index":0,"hash":"02f65ae7-2674-4462-abb8-2fb7f27a4c49","idx":"36e3f527-d4f4-431f-9aaa-e0e2968d8043"}
{"func_before":"  switch (opt) {\n    case  ' ': return;  \/* ignore white spaces *\/\n    case '>': h->endian = BIG; return;\n    case '<': h->endian = LITTLE; return;\n    case '!': {\n      int a = getnum(fmt, MAXALIGN);\n      if (!isp2(a))\n        luaL_error(L, \"alignment %d is not a power of 2\", a);\n      h->align = a;\n      return;\n    }","target":0,"flaw_line_index":0,"hash":"16cd7c2b-d85d-4483-bb16-5f424d3f9954","idx":"6054eeab-0fbe-449d-b77a-bdd8d2e215fe"}
{"func_before":"TfLiteStatus GreaterEqualEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  bool requires_broadcast = !HaveSameShapes(input1, input2);\n  switch (input1->type) {\n    case kTfLiteFloat32:\n      Comparison<float, reference_ops::GreaterEqualFn>(input1, input2, output,\n                                                       requires_broadcast);","target":1,"flaw_line_index":0,"hash":"9f130efe-895a-4236-8b51-2650a1022ee1","idx":"6d150455-32a8-4242-bd45-828718a992cc"}
{"func_before":"TfLiteStatus GreaterEqualEval(TfLiteContext* context, TfLiteNode* node) {\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  bool requires_broadcast = !HaveSameShapes(input1, input2);\n  switch (input1->type) {\n    case kTfLiteFloat32:\n      Comparison<float, reference_ops::GreaterEqualFn>(input1, input2, output,\n                                                       requires_broadcast);","target":0,"flaw_line_index":0,"hash":"954f733b-b005-46c8-b071-8589245f4dd4","idx":"5f58991b-69ab-4439-bde2-dcb3f37feba8"}
{"func_before":"void decodingXOR(char* extractedString, char* keyString, char* xoredString, int bufferLength)\n{\n\tint i;\n\n\tif(isCodingInverted){\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n\t\t}\n\t}else{\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[keyString[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n\t\t}\n\t}\n}","target":1,"flaw_line_index":0,"hash":"3daec4c6-08d4-4832-ac2f-6b305c18ea3e","idx":"19f49051-38f2-4095-930f-6d533c2c7dc9"}
{"func_before":"void decodingXOR(char* extractedString, char* keyString, char* xoredString, int bufferLength)\n{\n\tint i;\n\tchar* tablenumber;\n\n\tif(usingKeyFile){\n\t\ttablenumber = scramblingTablesOrder;\n\t}else{\n\t\ttablenumber = keyString;\n\t}\n\n\tif(isCodingInverted){\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[tablenumber[i] & (1+2+4+8)][(unsigned char)extractedString[i]] ^ keyString[i];\n\t\t}\n\t}else{\n\t\tfor (i = 0; i < bufferLength; ++i)\n\t\t{\n\t\t\txoredString[i] = unscrambleAsciiTables[tablenumber[i] & (1+2+4+8)][(unsigned char)(extractedString[i] ^ keyString[i])];\n\t\t}\n\t}\n}","target":0,"flaw_line_index":0,"hash":"b5fcbf31-a469-4165-874c-33006983d1ba","idx":"6a09412e-ae53-4c60-bea9-57faafa7fc99"}
{"func_before":"    int ret;\n\n    if (!s->initialized) {\n        ff_vp8_decode_init(avctx);\n        s->initialized = 1;\n        if (s->has_alpha)\n            avctx->pix_fmt = AV_PIX_FMT_YUVA420P;\n    }\n    s->lossless = 0;\n\n    if (data_size > INT_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");\n        return AVERROR_PATCHWELCOME;","target":1,"flaw_line_index":0,"hash":"2c681863-2717-4058-9665-fb31fd5409fe","idx":"c353dd97-61d2-4b7e-aa65-e68f91999f8b"}
{"func_before":"    AVPacket pkt;\n    int ret;\n\n    if (!s->initialized) {\n        ff_vp8_decode_init(avctx);\n        s->initialized = 1;\n    }\n    avctx->pix_fmt = s->has_alpha ? AV_PIX_FMT_YUVA420P : AV_PIX_FMT_YUV420P;\n    s->lossless = 0;\n\n    if (data_size > INT_MAX) {\n        av_log(avctx, AV_LOG_ERROR, \"unsupported chunk size\\n\");\n        return AVERROR_PATCHWELCOME;","target":0,"flaw_line_index":0,"hash":"b64f5f94-0832-4073-9f82-09559d36e940","idx":"f65930b5-b0c2-44e1-ae4f-79de23f07b6c"}
{"func_before":"\t\t\t\t}\n\t\t\t\tQ_strcat( params, sizeof( params ), token );\n\t\t\t}\n\n\t\t\tif ( strlen( params ) ) { \/\/ copy the params into the event\n\t\t\t\tcurEvent->params = G_Alloc( strlen( params ) + 1 );\n\t\t\t\tQ_strncpyz( curEvent->params, params, strlen( params ) + 1 );\n\t\t\t}\n\n\t\t\t\/\/ parse the actions for this event\n\t\t\twhile ( ( token = COM_Parse( &pScript ) ) && ( token[0] != '}' ) )\n\n\t\t\t\t\ttoken = COM_ParseExt( &pScript, qfalse );\n\t\t\t\t}\n\n\t\t\t\tif ( strlen( params ) ) { \/\/ copy the params into the event\n\t\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].params = G_Alloc( strlen( params ) + 1 );\n\t\t\t\t\tQ_strncpyz( curEvent->stack.items[curEvent->stack.numItems].params, params, strlen( params ) + 1 );\n\t\t\t\t}\n\n\t\t\t\tcurEvent->stack.numItems++;\n\n\t\t}\n\t}\n\n\t\/\/ alloc and copy the events into the cast_state_t for this cast\n\tif ( numEventItems > 0 ) {\n\t\tcs->castScriptEvents = G_Alloc( sizeof( cast_script_event_t ) * numEventItems );\n\t\tmemcpy( cs->castScriptEvents, cast_temp_events, sizeof( cast_script_event_t ) * numEventItems );\n\t\tcs->numCastScriptEvents = numEventItems;\n\n\t\tcs->castScriptStatus.castScriptEventIndex = -1;\n\t}","target":1,"flaw_line_index":0,"hash":"05d286f5-4f52-4d73-96c4-7d783e151e84","idx":"a4d35cf3-cff3-478e-bb68-a2f6d0a8c745"}
{"func_before":"\t\t\t\t}\n\t\t\t\tQ_strcat( params, sizeof( params ), token );\n\t\t\t}\n\n\t\t\tif ( strlen( params ) ) { \/\/ copy the params into the event\n\t\t\t\tcurEvent->params = trap_Alloc( strlen( params ) + 1 );\n\t\t\t\tQ_strncpyz( curEvent->params, params, strlen( params ) + 1 );\n\t\t\t}\n\n\t\t\t\/\/ parse the actions for this event\n\t\t\twhile ( ( token = COM_Parse( &pScript ) ) && ( token[0] != '}' ) )\n\n\t\t\t\t\ttoken = COM_ParseExt( &pScript, qfalse );\n\t\t\t\t}\n\n\t\t\t\tif ( strlen( params ) ) { \/\/ copy the params into the event\n\t\t\t\t\tcurEvent->stack.items[curEvent->stack.numItems].params = trap_Alloc( strlen( params ) + 1 );\n\t\t\t\t\tQ_strncpyz( curEvent->stack.items[curEvent->stack.numItems].params, params, strlen( params ) + 1 );\n\t\t\t\t}\n\n\t\t\t\tcurEvent->stack.numItems++;\n\n\t\t}\n\t}\n\n\t\/\/ alloc and copy the events into the cast_state_t for this cast\n\tif ( numEventItems > 0 ) {\n\t\tcs->castScriptEvents = trap_Alloc( sizeof( cast_script_event_t ) * numEventItems );\n\t\tmemcpy( cs->castScriptEvents, cast_temp_events, sizeof( cast_script_event_t ) * numEventItems );\n\t\tcs->numCastScriptEvents = numEventItems;\n\n\t\tcs->castScriptStatus.castScriptEventIndex = -1;\n\t}","target":0,"flaw_line_index":0,"hash":"f4c8fdd7-389d-46f5-b02b-7e2548d3cf34","idx":"bf9aace5-c808-4b90-8140-d7bad157aa8a"}
{"func_before":"static int nfs4_intent_set_file(struct nameidata *nd, struct path *path, struct nfs4_state *state)\n{\n\tstruct file *filp;\n\tint ret;\n\n\t\/* If the open_intent is for execute, we have an extra check to make *\/\n\tif (nd->intent.open.flags & FMODE_EXEC) {\n\t\tret = nfs_may_open(state->inode,\n\t\t\t\tstate->owner->so_cred,\n\t\t\t\tnd->intent.open.flags);\n\t\tif (ret < 0)\n\t\t\tgoto out_close;\n\t\tctx->state = state;\n\t\treturn 0;\n\t}\n\tret = PTR_ERR(filp);\nout_close:\n\tnfs4_close_sync(path, state, nd->intent.open.flags);\n\treturn ret;\n}","target":1,"flaw_line_index":0,"hash":"d91e862e-fa83-4b89-acaf-9a4d1d9212e9","idx":"570180ae-70c9-40d5-a26e-a693679a0f04"}
{"func_before":"static int nfs4_intent_set_file(struct nameidata *nd, struct path *path, struct nfs4_state *state, fmode_t fmode)\n{\n\tstruct file *filp;\n\tint ret;\n\n\t\/* If the open_intent is for execute, we have an extra check to make *\/\n\tif (fmode & FMODE_EXEC) {\n\t\tret = nfs_may_open(state->inode,\n\t\t\t\tstate->owner->so_cred,\n\t\t\t\tnd->intent.open.flags);\n\t\tif (ret < 0)\n\t\t\tgoto out_close;\n\t\tctx->state = state;\n\t\treturn 0;\n\t}\n\tret = PTR_ERR(filp);\nout_close:\n\tnfs4_close_sync(path, state, fmode & (FMODE_READ|FMODE_WRITE));\n\treturn ret;\n}","target":0,"flaw_line_index":0,"hash":"2c5e5565-c795-43d5-93d1-29b69eae1a64","idx":"ed6dee68-b55c-4de1-b3fd-3f138658bf52"}
{"func_before":"\t\t\t\tuint8_t i, pad_byte = *(priv->sym_plain_buffer + block_size - 1);\n\n\t\t\t\tsc_log(ctx, \"Found padding byte %02x\", pad_byte);\n\t\t\t\tif (pad_byte == 0 || pad_byte > block_size)\n\t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);\n\t\t\t\tsdata = priv->sym_plain_buffer + block_size - pad_byte;\n\t\t\t\tfor (i = 0; i < pad_byte; i++)\n\t\t\t\t\tif (sdata[i] != pad_byte)\n\t\t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);\n\t\t\t\treturn_len = block_size - pad_byte;\n\t\t\t}\n\t\t\t*outlen = return_len;\n\t\t\t\/* application can request buffer size or actual buffer size is too small *\/\n\t\t\tif (out == NULL)\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t\t\tif (return_len > *outlen)\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);\n\t\t\tmemcpy(out, priv->sym_plain_buffer, return_len);\n\t\t\tsc_log(ctx, \"C_DecryptFinal %zu bytes\", *outlen);\n\t\t\treturn SC_SUCCESS;\n\t\t} else {\n\t\t\t\/* C_EncryptFinalize *\/","target":1,"flaw_line_index":0,"hash":"5e460a30-50d2-4bd1-80d0-a5176898ef0a","idx":"f375e2a4-2fd5-445f-b70d-fe299c9299e9"}
{"func_before":"\t\t\t\tuint8_t i, pad_byte = *(priv->sym_plain_buffer + block_size - 1);\n\n\t\t\t\tsc_log(ctx, \"Found padding byte %02x\", pad_byte);\n\t\t\t\tif (pad_byte == 0 || pad_byte > block_size)\n\t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);\n\t\t\t\tsdata = priv->sym_plain_buffer + block_size;\n\t\t\t\tfor (i = 0; i < pad_byte; i++)\n\t\t\t\t\tif (*(--sdata) != pad_byte)\n\t\t\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_WRONG_PADDING);\n\t\t\t\treturn_len = block_size - pad_byte;\n\t\t\t}\n\t\t\t\/* application can request buffer size or actual buffer size is too small *\/\n\t\t\tif (out == NULL) {\n\t\t\t\t*outlen = return_len;\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_SUCCESS);\n\t\t\t}\n\t\t\tif (return_len > *outlen)\n\t\t\t\tLOG_FUNC_RETURN(ctx, SC_ERROR_BUFFER_TOO_SMALL);\n\t\t\t*outlen = return_len;\n\t\t\tmemcpy(out, priv->sym_plain_buffer, return_len);\n\t\t\tsc_log(ctx, \"C_DecryptFinal %zu bytes\", *outlen);\n\t\t\treturn SC_SUCCESS;\n\t\t} else {\n\t\t\t\/* C_EncryptFinalize *\/","target":0,"flaw_line_index":0,"hash":"b5639562-b05e-4138-bf02-ab88fd1ca24e","idx":"4f8265d1-4c97-43a5-a6f4-8d3bf47615ef"}
{"func_before":"\tchar\t   *str = PG_GETARG_CSTRING(0);\n\tPATH\t   *path;\n\tint\t\t\tisopen;\n\tchar\t   *s;\n\tint\t\t\tnpts;\n\tint\t\t\tsize;\n\tint\t\t\tdepth = 0;\n\n\tif ((npts = pair_count(str, ',')) <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t{\n\t\ts++;\n\t\tdepth++;\n\t}\n\n\tsize = offsetof(PATH, p[0]) +sizeof(path->p[0]) * npts;\n\tpath = (PATH *) palloc(size);\n\n\tSET_VARSIZE(path, size);\n\tpath->npts = npts;\n","target":1,"flaw_line_index":0,"hash":"0eb1b724-6d1f-44be-83f9-112c1b4a3838","idx":"66c8a7df-5333-4dc0-a5a5-e360357a3f6d"}
{"func_before":"\tPATH\t   *path;\n\tint\t\t\tisopen;\n\tchar\t   *s;\n\tint\t\t\tnpts;\n\tint\t\t\tsize;\n\tint\t\t\tbase_size;\n\tint\t\t\tdepth = 0;\n\n\tif ((npts = pair_count(str, ',')) <= 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_TEXT_REPRESENTATION),\n\t{\n\t\ts++;\n\t\tdepth++;\n\t}\n\n\tbase_size = sizeof(path->p[0]) * npts;\n\tsize = offsetof(PATH, p[0]) + base_size;\n\n\t\/* Check for integer overflow *\/\n\tif (base_size \/ npts != sizeof(path->p[0]) || size <= base_size)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"too many points requested\")));\n\n\tpath = (PATH *) palloc(size);\n\n\tSET_VARSIZE(path, size);\n\tpath->npts = npts;\n","target":0,"flaw_line_index":0,"hash":"3e52a4f5-831b-4e48-8f90-401bcf958f74","idx":"9299a08e-9049-4e87-a784-4b8814fad15d"}
{"func_before":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const auto* params = static_cast<TfLiteLSTMParams*>(node->builtin_data);\n  OpData* op_data = static_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n\n  const TfLiteTensor* input_to_input_weights =\n      GetOptionalInputTensor(context, node, kInputToInputWeightsTensor);\n  const TfLiteTensor* input_to_forget_weights =\n      GetInput(context, node, kInputToForgetWeightsTensor);\n  const TfLiteTensor* input_to_cell_weights =\n      GetInput(context, node, kInputToCellWeightsTensor);\n  const TfLiteTensor* input_to_output_weights =\n      GetInput(context, node, kInputToOutputWeightsTensor);\n\n  const TfLiteTensor* recurrent_to_input_weights =\n      GetOptionalInputTensor(context, node, kRecurrentToInputWeightsTensor);\n  const TfLiteTensor* recurrent_to_forget_weights =\n      GetInput(context, node, kRecurrentToForgetWeightsTensor);\n  const TfLiteTensor* recurrent_to_cell_weights =\n      GetInput(context, node, kRecurrentToCellWeightsTensor);\n  const TfLiteTensor* recurrent_to_output_weights =\n      GetInput(context, node, kRecurrentToOutputWeightsTensor);\n\n  const TfLiteTensor* cell_to_input_weights =\n      GetOptionalInputTensor(context, node, kCellToInputWeightsTensor);\n  const TfLiteTensor* cell_to_forget_weights =\n      GetOptionalInputTensor(context, node, kCellToForgetWeightsTensor);\n  const TfLiteTensor* output_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kOutputLayerNormCoefficientsTensor);\n\n  const TfLiteTensor* input_gate_bias =\n      GetOptionalInputTensor(context, node, kInputGateBiasTensor);\n  const TfLiteTensor* forget_gate_bias =\n      GetInput(context, node, kForgetGateBiasTensor);\n  const TfLiteTensor* cell_gate_bias =\n      GetInput(context, node, kCellGateBiasTensor);\n  const TfLiteTensor* output_gate_bias =\n      GetInput(context, node, kOutputGateBiasTensor);\n\n  const TfLiteTensor* projection_weights =\n      GetOptionalInputTensor(context, node, kProjectionWeightsTensor);\n  const TfLiteTensor* projection_bias =\n      GetOptionalInputTensor(context, node, kProjectionBiasTensor);\n\n  TfLiteTensor* output_state =\n      GetVariableInput(context, node, kOutputStateTensor);\n  TF_LITE_ENSURE(context, output_state != nullptr);\n  TfLiteTensor* cell_state = GetVariableInput(context, node, kCellStateTensor);\n  TF_LITE_ENSURE(context, cell_state != nullptr);\n\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  switch (input_to_output_weights->type) {\n    case kTfLiteFloat32: {\n      \/\/ Index the scratch buffers pointers to the global scratch buffer.\n      TfLiteTensor* scratch_buffer = GetTemporary(context, node, 0);\n      return lstm_eval::EvalFloat(\n          input, input_to_input_weights, input_to_forget_weights,\n          input_to_cell_weights, input_to_output_weights,\n          recurrent_to_input_weights, recurrent_to_forget_weights,\n          recurrent_to_cell_weights, recurrent_to_output_weights,\n    case kTfLiteUInt8:\n    case kTfLiteInt8: {\n      const bool is_hybrid = (input->type == kTfLiteFloat32);\n      const bool is_sparse = input_to_output_weights->sparsity != nullptr;\n      if (is_hybrid) {\n        TfLiteTensor* row_sums = GetTemporary(context, node, kRowSums);\n        const int row_sums_size = row_sums->dims->data[0];\n        if (is_sparse) {\n          TfLiteTensor* input_to_input_weights_ledger =\n              &context->tensors[op_data->ledger_index +\n                                kInputToInputWeightsLedgerOffset];\n            row_sums_size, &op_data->compute_row_sums,\n            CpuBackendContext::GetFromContext(context));\n      } else {\n        const int num_intermediate_tensors = node->intermediates->size;\n        if (num_intermediate_tensors == 5) {\n          TfLiteTensor* scratch0 = GetTemporary(context, node, 0);\n          TfLiteTensor* scratch1 = GetTemporary(context, node, 1);\n          TfLiteTensor* scratch2 = GetTemporary(context, node, 2);\n          TfLiteTensor* scratch3 = GetTemporary(context, node, 3);\n          TfLiteTensor* scratch4 = GetTemporary(context, node, 4);\n          TfLiteTensor* scratch5 = GetTemporary(context, node, 5);\n          return lstm_eval::EvalInteger8x8_16(\n              input, input_to_input_weights, input_to_forget_weights,\n              input_to_cell_weights, input_to_output_weights,\n              recurrent_to_input_weights, recurrent_to_forget_weights,\n              recurrent_to_cell_weights, recurrent_to_output_weights,\n              projection_bias, params, &op_data->integer_lstm_param,\n              output_state, cell_state, output, scratch0, scratch1, scratch2,\n              scratch3, scratch4, scratch5,\n              CpuBackendContext::GetFromContext(context));\n        } else {\n          TfLiteTensor* scratch0 = GetTemporary(context, node, 0);\n          TfLiteTensor* scratch1 = GetTemporary(context, node, 1);\n          TfLiteTensor* scratch2 = GetTemporary(context, node, 2);\n          TfLiteTensor* scratch3 = GetTemporary(context, node, 3);\n          TfLiteTensor* scratch4 = GetTemporary(context, node, 4);\n          TfLiteTensor* scratch5 = GetTemporary(context, node, 5);\n          TfLiteTensor* scratch6 = GetTemporary(context, node, 6);\n          TfLiteTensor* scratch7 = GetTemporary(context, node, 7);\n          return lstm_eval::EvalInteger8x8_8(\n              input, input_to_input_weights, input_to_forget_weights,\n              input_to_cell_weights, input_to_output_weights,\n              recurrent_to_input_weights, recurrent_to_forget_weights,\n              recurrent_to_cell_weights, recurrent_to_output_weights,","target":1,"flaw_line_index":0,"hash":"3c3ab4fb-672a-4fa8-b51f-db41b589237d","idx":"2bbb38e2-717b-41be-a1bf-a332263d386d"}
{"func_before":"TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) {\n  const auto* params = static_cast<TfLiteLSTMParams*>(node->builtin_data);\n  OpData* op_data = static_cast<OpData*>(node->user_data);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n\n  const TfLiteTensor* input_to_input_weights =\n      GetOptionalInputTensor(context, node, kInputToInputWeightsTensor);\n  const TfLiteTensor* input_to_forget_weights;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputToForgetWeightsTensor,\n                                 &input_to_forget_weights));\n  const TfLiteTensor* input_to_cell_weights;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputToCellWeightsTensor,\n                                 &input_to_cell_weights));\n  const TfLiteTensor* input_to_output_weights;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputToOutputWeightsTensor,\n                                 &input_to_output_weights));\n\n  const TfLiteTensor* recurrent_to_input_weights =\n      GetOptionalInputTensor(context, node, kRecurrentToInputWeightsTensor);\n  const TfLiteTensor* recurrent_to_forget_weights;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kRecurrentToForgetWeightsTensor,\n                                 &recurrent_to_forget_weights));\n  const TfLiteTensor* recurrent_to_cell_weights;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kRecurrentToCellWeightsTensor,\n                                 &recurrent_to_cell_weights));\n  const TfLiteTensor* recurrent_to_output_weights;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kRecurrentToOutputWeightsTensor,\n                                 &recurrent_to_output_weights));\n\n  const TfLiteTensor* cell_to_input_weights =\n      GetOptionalInputTensor(context, node, kCellToInputWeightsTensor);\n  const TfLiteTensor* cell_to_forget_weights =\n      GetOptionalInputTensor(context, node, kCellToForgetWeightsTensor);\n  const TfLiteTensor* output_layer_norm_coefficients =\n      GetOptionalInputTensor(context, node, kOutputLayerNormCoefficientsTensor);\n\n  const TfLiteTensor* input_gate_bias =\n      GetOptionalInputTensor(context, node, kInputGateBiasTensor);\n  const TfLiteTensor* forget_gate_bias;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kForgetGateBiasTensor,\n                                          &forget_gate_bias));\n  const TfLiteTensor* cell_gate_bias;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kCellGateBiasTensor,\n                                          &cell_gate_bias));\n  const TfLiteTensor* output_gate_bias;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kOutputGateBiasTensor,\n                                          &output_gate_bias));\n\n  const TfLiteTensor* projection_weights =\n      GetOptionalInputTensor(context, node, kProjectionWeightsTensor);\n  const TfLiteTensor* projection_bias =\n      GetOptionalInputTensor(context, node, kProjectionBiasTensor);\n\n  TfLiteTensor* output_state =\n      GetVariableInput(context, node, kOutputStateTensor);\n  TFLITE_DCHECK(output_state != nullptr);\n  TfLiteTensor* cell_state = GetVariableInput(context, node, kCellStateTensor);\n  TFLITE_DCHECK(cell_state != nullptr);\n\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  switch (input_to_output_weights->type) {\n    case kTfLiteFloat32: {\n      \/\/ Index the scratch buffers pointers to the global scratch buffer.\n      TfLiteTensor* scratch_buffer;\n      TF_LITE_ENSURE_OK(context,\n                        GetTemporarySafe(context, node, 0, &scratch_buffer));\n      return lstm_eval::EvalFloat(\n          input, input_to_input_weights, input_to_forget_weights,\n          input_to_cell_weights, input_to_output_weights,\n          recurrent_to_input_weights, recurrent_to_forget_weights,\n          recurrent_to_cell_weights, recurrent_to_output_weights,\n    case kTfLiteUInt8:\n    case kTfLiteInt8: {\n      const bool is_hybrid = (input->type == kTfLiteFloat32);\n      const bool is_sparse = input_to_output_weights->sparsity != nullptr;\n      if (is_hybrid) {\n        TfLiteTensor* row_sums;\n        TF_LITE_ENSURE_OK(context,\n                          GetTemporarySafe(context, node, kRowSums, &row_sums));\n        const int row_sums_size = row_sums->dims->data[0];\n        if (is_sparse) {\n          TfLiteTensor* input_to_input_weights_ledger =\n              &context->tensors[op_data->ledger_index +\n                                kInputToInputWeightsLedgerOffset];\n            row_sums_size, &op_data->compute_row_sums,\n            CpuBackendContext::GetFromContext(context));\n      } else {\n        const int num_intermediate_tensors = node->intermediates->size;\n        if (num_intermediate_tensors == 5) {\n          TfLiteTensor* scratch0;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 0, &scratch0));\n          TfLiteTensor* scratch1;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 1, &scratch1));\n          TfLiteTensor* scratch2;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 2, &scratch2));\n          TfLiteTensor* scratch3;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 3, &scratch3));\n          TfLiteTensor* scratch4;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 4, &scratch4));\n          TfLiteTensor* scratch5;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 5, &scratch5));\n          return lstm_eval::EvalInteger8x8_16(\n              input, input_to_input_weights, input_to_forget_weights,\n              input_to_cell_weights, input_to_output_weights,\n              recurrent_to_input_weights, recurrent_to_forget_weights,\n              recurrent_to_cell_weights, recurrent_to_output_weights,\n              projection_bias, params, &op_data->integer_lstm_param,\n              output_state, cell_state, output, scratch0, scratch1, scratch2,\n              scratch3, scratch4, scratch5,\n              CpuBackendContext::GetFromContext(context));\n        } else {\n          TfLiteTensor* scratch0;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 0, &scratch0));\n          TfLiteTensor* scratch1;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 1, &scratch1));\n          TfLiteTensor* scratch2;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 2, &scratch2));\n          TfLiteTensor* scratch3;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 3, &scratch3));\n          TfLiteTensor* scratch4;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 4, &scratch4));\n          TfLiteTensor* scratch5;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 5, &scratch5));\n          TfLiteTensor* scratch6;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 6, &scratch6));\n          TfLiteTensor* scratch7;\n          TF_LITE_ENSURE_OK(context,\n                            GetTemporarySafe(context, node, 7, &scratch7));\n          return lstm_eval::EvalInteger8x8_8(\n              input, input_to_input_weights, input_to_forget_weights,\n              input_to_cell_weights, input_to_output_weights,\n              recurrent_to_input_weights, recurrent_to_forget_weights,\n              recurrent_to_cell_weights, recurrent_to_output_weights,","target":0,"flaw_line_index":0,"hash":"559b9b26-6c06-4717-af02-03e4038265e5","idx":"7e088e42-6371-4114-be60-edb896107d2c"}
{"func_before":"    int vfyflags = 0;\n    OM_uint32 ret;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (! ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    \/* parse the token, leave the data in message_buffer, setting conf_state *\/","target":1,"flaw_line_index":0,"hash":"c8905056-48e1-4c43-af87-3940611c501b","idx":"2b8b9ff2-d411-45ae-ae23-c301d7020f0d"}
{"func_before":"    int vfyflags = 0;\n    OM_uint32 ret;\n\n    ctx = (krb5_gss_ctx_id_rec *) context_handle;\n\n    if (ctx->terminated || !ctx->established) {\n        *minor_status = KG_CTX_INCOMPLETE;\n        return(GSS_S_NO_CONTEXT);\n    }\n\n    \/* parse the token, leave the data in message_buffer, setting conf_state *\/","target":0,"flaw_line_index":0,"hash":"aaa2f5b1-f8e0-4c4a-964f-6429cae4cd9d","idx":"464524bd-3333-4496-b465-f8bd2f448db0"}
{"func_before":"static int perf_trace_event_perm(struct ftrace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\t\/* The ftrace function trace is allowed only for root. *\/\n\tif (ftrace_event_is_function(tp_event) &&\n\t    perf_paranoid_kernel() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t\/* No tracing, just counting, so no obvious leak *\/\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;","target":1,"flaw_line_index":0,"hash":"4647aa68-c957-46b5-8a25-09ad07b88195","idx":"2f2ea8ed-a46a-4ae8-8028-bcab22c05f27"}
{"func_before":"static int perf_trace_event_perm(struct ftrace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\t\/* The ftrace function trace is allowed only for root. *\/\n\tif (ftrace_event_is_function(tp_event) &&\n\t    perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t\/* No tracing, just counting, so no obvious leak *\/\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;","target":0,"flaw_line_index":0,"hash":"1535a690-622b-41cd-a49b-f20eff886ca4","idx":"2dd28dd6-4daa-4818-be10-43ee4cbc32aa"}
{"func_before":"bool ConstantFolding::SimplifyReshape(const GraphProperties& properties,\n                                      bool use_shape_info, NodeDef* node) {\n  if (!use_shape_info || node->attr().count(\"T\") == 0 ||\n      !IsSimplifiableReshape(*node, properties)) {\n    return false;\n  }\n  DataType output_type = node->attr().at(\"T\").type();\n  node->set_op(\"Identity\");\n  EraseRegularNodeAttributes(node);","target":1,"flaw_line_index":0,"hash":"ab1ee5df-52b8-40e4-9370-b0b435b6ba65","idx":"a275ed5b-a4b1-4800-936a-7528b766b739"}
{"func_before":"bool ConstantFolding::SimplifyReshape(const GraphProperties& properties,\n                                      bool use_shape_info, NodeDef* node) {\n  if (!use_shape_info || node->attr().count(\"T\") == 0 ||\n      !IsSimplifiableReshape(*node, properties).ok()) {\n    return false;\n  }\n  DataType output_type = node->attr().at(\"T\").type();\n  node->set_op(\"Identity\");\n  EraseRegularNodeAttributes(node);","target":0,"flaw_line_index":0,"hash":"b8d5df2e-3b0d-4ae4-be57-77b4a8ea8d3c","idx":"6b7aa7c7-f723-43d7-aa13-8c1ba39dc22b"}
{"func_before":"\n\t\/* Add propogated mounts to the tmp_list *\/\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}","target":1,"flaw_line_index":0,"hash":"58b93a18-c1b4-4939-9263-6c3f8dd4d88c","idx":"0b2e54cb-75f3-4e25-960e-435a9398b223"}
{"func_before":"\t\/* Add propogated mounts to the tmp_list *\/\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tdisconnect = !IS_MNT_LOCKED_AND_LAZY(p);\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\t\/* Don't forget about p *\/\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}","target":0,"flaw_line_index":0,"hash":"27b8999e-d6d4-4d37-b71d-5d595d5e320c","idx":"1f58dc01-ac2a-406b-8a2e-454575db6344"}
{"func_before":"\t}\n\tif (parse_key_constraints(e->request, NULL, &death, &seconds, &confirm,\n\t    NULL, &dest_constraints, &ndest_constraints) != 0) {\n\t\terror_f(\"failed to parse constraints\");\n\t\tgoto send;\n\t}\n\tif (e->nsession_ids != 0 && !remote_add_provider) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": remote addition of \"\n\t\t    \"providers is disabled\", provider);\n\t\tgoto send;\n\t}\n\t\t\t} else {\n\t\t\t\tid->comment = xstrdup(canonical_provider);\n\t\t\t}\n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tid->dest_constraints = dest_constraints;\n\t\t\tid->ndest_constraints = ndest_constraints;\n\t\t\tdest_constraints = NULL; \/* transferred *\/\n\t\t\tndest_constraints = 0;\n\t\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t\tidtab->nentries++;\n\t\t\tsuccess = 1;\n\t\t}\n\t\t\/* XXX update constraints for existing keys *\/","target":1,"flaw_line_index":0,"hash":"123058cc-1418-4a15-92fe-ccf035abcf60","idx":"c9e3241c-eeff-48ed-abbc-707a18418f92"}
{"func_before":"\tif (parse_key_constraints(e->request, NULL, &death, &seconds, &confirm,\n\t    NULL, &dest_constraints, &ndest_constraints) != 0) {\n\t\terror_f(\"failed to parse constraints\");\n\t\tgoto send;\n\t}\n\tdump_dest_constraints(__func__, dest_constraints, ndest_constraints);\n\tif (e->nsession_ids != 0 && !remote_add_provider) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": remote addition of \"\n\t\t    \"providers is disabled\", provider);\n\t\tgoto send;\n\t}\n\t\t\t} else {\n\t\t\t\tid->comment = xstrdup(canonical_provider);\n\t\t\t}\n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tid->dest_constraints = dup_dest_constraints(\n\t\t\t    dest_constraints, ndest_constraints);\n\t\t\tid->ndest_constraints = ndest_constraints;\n\t\t\tTAILQ_INSERT_TAIL(&idtab->idlist, id, next);\n\t\t\tidtab->nentries++;\n\t\t\tsuccess = 1;\n\t\t}\n\t\t\/* XXX update constraints for existing keys *\/","target":0,"flaw_line_index":0,"hash":"2c6ce0ec-eccd-4505-bd15-02c25e980fba","idx":"e33eab26-3381-4506-b42b-4b0e6cd33db4"}
{"func_before":"static void tokenadd(struct jv_parser* p, char c) {\n  assert(p->tokenpos <= p->tokenlen);\n  if (p->tokenpos == p->tokenlen) {\n    p->tokenlen = p->tokenlen*2 + 256;\n    p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);\n  }\n  assert(p->tokenpos < p->tokenlen);\n  p->tokenbuf[p->tokenpos++] = c;","target":1,"flaw_line_index":0,"hash":"124680c9-f293-4aab-91b7-ea8b3ab58275","idx":"a38cd8c1-f5bb-48f3-9efe-fa73d9e54a26"}
{"func_before":"static void tokenadd(struct jv_parser* p, char c) {\n  assert(p->tokenpos <= p->tokenlen);\n  if (p->tokenpos >= (p->tokenlen - 1)) {\n    p->tokenlen = p->tokenlen*2 + 256;\n    p->tokenbuf = jv_mem_realloc(p->tokenbuf, p->tokenlen);\n  }\n  assert(p->tokenpos < p->tokenlen);\n  p->tokenbuf[p->tokenpos++] = c;","target":0,"flaw_line_index":0,"hash":"2d32b41c-77e3-4b51-b21a-be2a82b3cc84","idx":"b55cc479-10d4-4530-b255-0a824dece208"}
{"func_before":"int sss_certmap_get_search_filter(struct sss_certmap_ctx *ctx,\n                                  const uint8_t *der_cert, size_t der_size,\n                                  char **_filter, char ***_domains)\n{\n    int ret;\n    struct match_map_rule *r;\n    struct priority_list *p;\n    struct sss_cert_content *cert_content = NULL;\n    char *filter = NULL;\n    char **domains = NULL;\n    size_t c;\n\n    if (_filter == NULL || _domains == NULL) {\n        return EINVAL;\n    }\n\n    ret = sss_cert_get_content(ctx, der_cert, der_size, &cert_content);\n    if (ret != 0) {\n        CM_DEBUG(ctx, \"Failed to get certificate content [%d].\", ret);\n        return ret;\n    }\n\n    if (ctx->prio_list == NULL) {\n        if (ctx->default_mapping_rule == NULL) {\n            CM_DEBUG(ctx, \"No matching or mapping rules available.\");\n            return EINVAL;\n        }\n\n        ret = get_filter(ctx, ctx->default_mapping_rule, cert_content, &filter);\n        goto done;\n    }\n\n    for (p = ctx->prio_list; p != NULL; p = p->next) {\n        for (r = p->rule_list; r != NULL; r = r->next) {\n            ret = do_match(ctx, r->parsed_match_rule, cert_content);\n            if (ret == 0) {\n                \/* match *\/\n                ret = get_filter(ctx, r->parsed_mapping_rule, cert_content,\n                                 &filter);\n                if (ret != 0) {\n                    CM_DEBUG(ctx, \"Failed to get filter\");\n                    goto done;\n                }\n\n                if (r->domains != NULL) {\n                    for (c = 0; r->domains[c] != NULL; c++);\n                    domains = talloc_zero_array(ctx, char *, c + 1);\n                    if (domains == NULL) {\n                        ret = ENOMEM;\n                        goto done;\n                    }\n\n                    for (c = 0; r->domains[c] != NULL; c++) {\n                        domains[c] = talloc_strdup(domains, r->domains[c]);\n                        if (domains[c] == NULL) {\n                            ret = ENOMEM;\n                            goto done;\n                        }\n                    }\n                }\n\n                ret = 0;\n                goto done;\n            }\n        }\n    }\n\n    ret = ENOENT;\n\ndone:\n    talloc_free(cert_content);\n    if (ret == 0) {\n        *_filter = filter;\n        *_domains = domains;\n    } else {\n        talloc_free(filter);\n        talloc_free(domains);\n    }\n\n    return ret;\n}","target":1,"flaw_line_index":0,"hash":"4001a6b5-7b8f-4e41-a61e-0ec0d37b0c70","idx":"9505c5c0-c52e-4241-acd2-bf7347741e34"}
{"func_before":"int sss_certmap_get_search_filter(struct sss_certmap_ctx *ctx,\n                                  const uint8_t *der_cert, size_t der_size,\n                                  char **_filter, char ***_domains)\n{\n    return expand_mapping_rule_ex(ctx, der_cert, der_size, true,\n                                  _filter, _domains);\n}","target":0,"flaw_line_index":0,"hash":"1ce2f905-73b5-4213-9ef1-8c5994969d94","idx":"0cb144c2-721a-4ec3-adf8-8acaca05bbab"}
{"func_before":"_rsvg_io_get_file_path (const gchar * filename,\n                        const gchar * base_uri)\n{\n    gchar *absolute_filename;\n\n    if (g_file_test (filename, G_FILE_TEST_EXISTS) || g_path_is_absolute (filename)) {\n        absolute_filename = g_strdup (filename);\n    } else {\n        gchar *tmpcdir;\n        gchar *base_filename;\n","target":1,"flaw_line_index":0,"hash":"45256b92-e1f8-467a-81c1-1cb11f338adf","idx":"7185ceab-29dc-4063-99d2-18a730d20249"}
{"func_before":"_rsvg_io_get_file_path (const gchar * filename,\n                        const gchar * base_uri)\n{\n    gchar *absolute_filename;\n\n    if (g_path_is_absolute (filename)) {\n        absolute_filename = g_strdup (filename);\n    } else {\n        gchar *tmpcdir;\n        gchar *base_filename;\n","target":0,"flaw_line_index":0,"hash":"0aefd6bc-9a44-4488-8aae-ca2aba94f3f0","idx":"c6ae7904-678b-4249-9c17-bf0ac9bc2016"}
{"func_before":"\tpitem *item;\n\n\t\/* Limit the size of the queue to prevent DOS attacks *\/\n\tif (pqueue_size(queue->q) >= 100)\n\t\treturn 0;\n\t\t\n\trdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));\n\titem = pitem_new(priority, rdata);\n\tif (rdata == NULL || item == NULL)\n\t\t{\n\t\tif (rdata != NULL) OPENSSL_free(rdata);\n\tmemset(&(s->s3->rbuf), 0, sizeof(SSL3_BUFFER));\n\tmemset(&(s->s3->rrec), 0, sizeof(SSL3_RECORD));\n\t\n\tif (!ssl3_setup_buffers(s))\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(0);\n\t\t}\n\n\t\/* insert should not fail, since duplicates are dropped *\/\n\tif (pqueue_insert(queue->q, item) == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(0);\n\t\t}\n\n\treturn(1);\n\t}","target":1,"flaw_line_index":0,"hash":"9c55b9cc-ecb9-4cfd-881e-4109eda79c2a","idx":"3565a013-f895-470a-83c6-0417d06648d2"}
{"func_before":"\tpitem *item;\n\n\t\/* Limit the size of the queue to prevent DOS attacks *\/\n\tif (pqueue_size(queue->q) >= 100)\n\t\treturn 0;\n\n\trdata = OPENSSL_malloc(sizeof(DTLS1_RECORD_DATA));\n\titem = pitem_new(priority, rdata);\n\tif (rdata == NULL || item == NULL)\n\t\t{\n\t\tif (rdata != NULL) OPENSSL_free(rdata);\n\tmemset(&(s->s3->rrec), 0, sizeof(SSL3_RECORD));\n\t\n\tif (!ssl3_setup_buffers(s))\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tif (rdata->rbuf.buf != NULL)\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(-1);\n\t\t}\n\n\t\/* insert should not fail, since duplicates are dropped *\/\n\tif (pqueue_insert(queue->q, item) == NULL)\n\t\t{\n\t\tSSLerr(SSL_F_DTLS1_BUFFER_RECORD, ERR_R_INTERNAL_ERROR);\n\t\tif (rdata->rbuf.buf != NULL)\n\t\t\tOPENSSL_free(rdata->rbuf.buf);\n\t\tOPENSSL_free(rdata);\n\t\tpitem_free(item);\n\t\treturn(-1);\n\t\t}\n\n\treturn(1);\n\t}","target":0,"flaw_line_index":0,"hash":"c3a19514-fbd5-4a2a-9e72-03b8abca3efd","idx":"cf6ac12b-ac84-4ae5-b5b2-8f8d6c98cff5"}
{"func_before":"                    goto trunc;\n                ND_TCHECK_16BITS(p);\n                if (*(p+1) == 0x81 ||\n                    *(p+1) == 0x82 ||\n                    *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1, ndo->ndo_snapend - p - 1);\n                else\n                    isoclns_print(ndo, p, length, ndo->ndo_snapend - p);\n                break;\n\tdefault:\n                if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;","target":1,"flaw_line_index":0,"hash":"1436a61d-0cc4-4ed7-8dc5-9b0a2c2ffba6","idx":"c5024683-f546-4770-9b1e-c7a80645bfac"}
{"func_before":"                    goto trunc;\n                ND_TCHECK_16BITS(p);\n                if (*(p+1) == 0x81 ||\n                    *(p+1) == 0x82 ||\n                    *(p+1) == 0x83)\n                    isoclns_print(ndo, p + 1, length - 1);\n                else\n                    isoclns_print(ndo, p, length);\n                break;\n\tdefault:\n                if (!ndo->ndo_eflag)\n                        ND_PRINT((ndo, \"unknown CHDLC protocol (0x%04x)\", proto));\n                break;","target":0,"flaw_line_index":0,"hash":"715aa45e-2fe4-4014-8891-c6827e0ad5f6","idx":"4fedd9fe-225c-494c-91b1-2e441763535d"}
{"func_before":"             NUMA        *nax,\n             NUMA        *nay,\n             l_int32      plotstyle,\n             const char  *plottitle)\n{\nchar       buf[L_BUF_SIZE];\nchar       emptystring[] = \"\";\nchar      *datastr, *title;\nl_int32    n, i;\nl_float32  valx, valy, startx, delx;\nSARRAY    *sa;\n        sarrayAddString(gplot->plottitles, emptystring, L_COPY);\n    }\n\n        \/* Generate and save data filename *\/\n    gplot->nplots++;\n    snprintf(buf, L_BUF_SIZE, \"%s.data.%d\", gplot->rootname, gplot->nplots);\n    sarrayAddString(gplot->datanames, buf, L_COPY);\n\n        \/* Generate data and save as a string *\/\n    sa = sarrayCreate(n);\n    for (i = 0; i < n; i++) {\n        if (nax)\n            numaGetFValue(nax, i, &valx);\n        else\n            valx = startx + i * delx;\n        numaGetFValue(nay, i, &valy);\n        snprintf(buf, L_BUF_SIZE, \"%f %f\\n\", valx, valy);\n        sarrayAddString(sa, buf, L_COPY);\n    }\n    datastr = sarrayToString(sa, 0);\n    sarrayAddString(gplot->plotdata, datastr, L_INSERT);\n    sarrayDestroy(&sa);","target":1,"flaw_line_index":0,"hash":"c551da5a-8e08-4d80-ae7d-c578806d717c","idx":"9be30070-dd13-40c2-bef2-6509bb372131"}
{"func_before":"             NUMA        *nax,\n             NUMA        *nay,\n             l_int32      plotstyle,\n             const char  *plottitle)\n{\nchar       buf[L_BUFSIZE];\nchar       emptystring[] = \"\";\nchar      *datastr, *title;\nl_int32    n, i;\nl_float32  valx, valy, startx, delx;\nSARRAY    *sa;\n        sarrayAddString(gplot->plottitles, emptystring, L_COPY);\n    }\n\n        \/* Generate and save data filename *\/\n    gplot->nplots++;\n    snprintf(buf, L_BUFSIZE, \"%s.data.%d\", gplot->rootname, gplot->nplots);\n    sarrayAddString(gplot->datanames, buf, L_COPY);\n\n        \/* Generate data and save as a string *\/\n    sa = sarrayCreate(n);\n    for (i = 0; i < n; i++) {\n        if (nax)\n            numaGetFValue(nax, i, &valx);\n        else\n            valx = startx + i * delx;\n        numaGetFValue(nay, i, &valy);\n        snprintf(buf, L_BUFSIZE, \"%f %f\\n\", valx, valy);\n        sarrayAddString(sa, buf, L_COPY);\n    }\n    datastr = sarrayToString(sa, 0);\n    sarrayAddString(gplot->plotdata, datastr, L_INSERT);\n    sarrayDestroy(&sa);","target":0,"flaw_line_index":0,"hash":"f7f32f8b-9894-4bb6-b4be-f476de3d037f","idx":"5c722502-bbe5-4188-a213-26a4b394057d"}
{"func_before":"static void pp_mil_k24(fp24_t r, ep4_t *t, ep4_t *q, ep_t *p, int m, bn_t a) {\n\tfp24_t l;\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep4_t *_q = RLC_ALLOCA(ep4_t, m);\n\tint i, j, len = bn_bits(a) + 1;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tif (m == 0) {\n\t\treturn;\n\t}","target":1,"flaw_line_index":0,"hash":"ca00c9c3-9a7d-4a4e-b2eb-e9bd47014d80","idx":"575dffa8-0ca0-4cb1-b629-5303b1122409"}
{"func_before":"static void pp_mil_k24(fp24_t r, ep4_t *t, ep4_t *q, ep_t *p, int m, bn_t a) {\n\tfp24_t l;\n\tep_t *_p = RLC_ALLOCA(ep_t, m);\n\tep4_t *_q = RLC_ALLOCA(ep4_t, m);\n\tsize_t len = bn_bits(a) + 1;\n\tint i, j;\n\tint8_t s[RLC_FP_BITS + 1];\n\n\tif (m == 0) {\n\t\treturn;\n\t}","target":0,"flaw_line_index":0,"hash":"f71146bc-81b1-4938-bffb-befdb5904a88","idx":"ef4a35d5-368d-43de-a207-df7750628eef"}
{"func_before":"\n\tkenter(\"\");\n\n\tif (ctx->index_key.type == &key_type_keyring)\n\t\treturn ERR_PTR(-EPERM);\n\n\tuser = key_user_lookup(current_fsuid());\n\tif (!user)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconstruct_get_dest_keyring(&dest_keyring);\n\n\tret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);\n\tkey_user_put(user);\n\n\tif (ret == 0) {\n\t\t\tgoto construction_failed;\n\t\t}\n\t} else if (ret == -EINPROGRESS) {\n\t\tret = 0;\n\t} else {\n\t\tgoto couldnt_alloc_key;\n\t}\n\n\tkey_put(dest_keyring);\n\tkleave(\" = key %d\", key_serial(key));\n\treturn key;\n\nconstruction_failed:\n\tkey_negate_and_link(key, key_negative_timeout, NULL, NULL);\n\tkey_put(key);\ncouldnt_alloc_key:\n\tkey_put(dest_keyring);\n\tkleave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}","target":1,"flaw_line_index":0,"hash":"d37196a9-b2a0-4ac0-9c30-4094592dd55c","idx":"da009a21-8460-4dfb-baf4-0def53c49179"}
{"func_before":"\tkenter(\"\");\n\n\tif (ctx->index_key.type == &key_type_keyring)\n\t\treturn ERR_PTR(-EPERM);\n\n\tret = construct_get_dest_keyring(&dest_keyring);\n\tif (ret)\n\t\tgoto error;\n\n\tuser = key_user_lookup(current_fsuid());\n\tif (!user) {\n\t\tret = -ENOMEM;\n\t\tgoto error_put_dest_keyring;\n\t}\n\n\tret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);\n\tkey_user_put(user);\n\n\tif (ret == 0) {\n\t\t\tgoto construction_failed;\n\t\t}\n\t} else if (ret == -EINPROGRESS) {\n\t\tret = 0;\n\t} else {\n\t\tgoto error_put_dest_keyring;\n\t}\n\n\tkey_put(dest_keyring);\n\tkleave(\" = key %d\", key_serial(key));\n\treturn key;\n\nconstruction_failed:\n\tkey_negate_and_link(key, key_negative_timeout, NULL, NULL);\n\tkey_put(key);\nerror_put_dest_keyring:\n\tkey_put(dest_keyring);\nerror:\n\tkleave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}","target":0,"flaw_line_index":0,"hash":"3c2af078-f26d-401e-9158-c707dab871bc","idx":"52e05daf-8f9a-49ae-9137-efcc5362f746"}
{"func_before":"        extent+=image->columns*sizeof(uint64);\n#else\n        extent+=image->columns*sizeof(uint32);\n#endif\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n        stride=TIFFVStripSize(tiff,1);\n        strip_id=0;","target":1,"flaw_line_index":0,"hash":"b97e29be-1dc8-44d7-a0d7-cdadfcc0e6b2","idx":"7a8b22cc-e30c-4692-b98b-04b91b8fabc8"}
{"func_before":"        extent+=image->columns*sizeof(uint64);\n#else\n        extent+=image->columns*sizeof(uint32);\n#endif\n        strip_pixels=(unsigned char *) AcquireQuantumMemory(extent,\n          2*sizeof(*strip_pixels));\n        if (strip_pixels == (unsigned char *) NULL)\n          ThrowTIFFException(ResourceLimitError,\"MemoryAllocationFailed\");\n        (void) memset(strip_pixels,0,extent*sizeof(*strip_pixels));\n        stride=TIFFVStripSize(tiff,1);\n        strip_id=0;","target":0,"flaw_line_index":0,"hash":"e25869a2-05de-4b00-bf79-0f2f63acd997","idx":"169835dd-0172-4a31-a145-12b2d909dcaa"}
{"func_before":"\n  snprintf(dirpath_tmp, 256, \"%s\/kheaders-%s\", get_tmp_dir(),\n           uname_data.release);\n  dirpath = std::string(dirpath_tmp);\n\n  if (file_exists(dirpath_tmp))\n    return 0;\n\n  \/\/ First time so extract it\n  return extract_kheaders(dirpath, uname_data);\n}","target":1,"flaw_line_index":0,"hash":"0c30d6cd-6f9e-4438-9715-25d6ced4d7af","idx":"d739ff4a-8c42-4d1e-add9-36ee7bea95ad"}
{"func_before":"\n  snprintf(dirpath_tmp, 256, \"%s\/kheaders-%s\", get_tmp_dir(),\n           uname_data.release);\n  dirpath = std::string(dirpath_tmp);\n\n  if (file_exists_and_ownedby(dirpath_tmp, 0))\n    return 0;\n\n  \/\/ First time so extract it\n  return extract_kheaders(dirpath, uname_data);\n}","target":0,"flaw_line_index":0,"hash":"4716b763-cce7-4b2f-bbaf-42361985175c","idx":"5a661096-5a39-4a3c-8cda-2eba7956a836"}
{"func_before":"        if (existingSessionId.isNull()) {\n            m_auth->setSession(session.exec());\n        } else {\n            \/\/we only want to unlock the session if we can lock in, so we want to go via PAM auth, but not start a new session\n            \/\/by not setting the session and the helper will emit authentication and then quit\n            connect(m_auth, &Auth::authentication, this, [=](){\n                qDebug() << \"activating existing seat\";\n                OrgFreedesktopLogin1ManagerInterface manager(Logind::serviceName(), Logind::managerPath(), QDBusConnection::systemBus());\n                manager.UnlockSession(existingSessionId);\n                manager.ActivateSession(existingSessionId);\n            });","target":1,"flaw_line_index":0,"hash":"d163efc9-3896-4a53-88ae-842b88300e1a","idx":"dfa6cb5d-aa5b-4443-b30f-08dfee11a5cc"}
{"func_before":"        if (existingSessionId.isNull()) {\n            m_auth->setSession(session.exec());\n        } else {\n            \/\/we only want to unlock the session if we can lock in, so we want to go via PAM auth, but not start a new session\n            \/\/by not setting the session and the helper will emit authentication and then quit\n            connect(m_auth, &Auth::authentication, this, [=](const QString &, bool success){\n                if(!success)\n                    return;\n                qDebug() << \"activating existing seat\";\n                OrgFreedesktopLogin1ManagerInterface manager(Logind::serviceName(), Logind::managerPath(), QDBusConnection::systemBus());\n                manager.UnlockSession(existingSessionId);\n                manager.ActivateSession(existingSessionId);\n            });","target":0,"flaw_line_index":0,"hash":"fc603261-2233-42c6-ac24-d550919b6a8b","idx":"0018061c-53e1-4e53-9dba-c14bf3c395af"}
{"func_before":"                r = log_error_errno(errno, \"Failed to get input name: %m\");\n                goto fail;\n        }\n\n        (void) button_set_mask(b);\n\n        r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to add button event: %m\");\n                goto fail;\n        }","target":1,"flaw_line_index":0,"hash":"f283e8d7-3879-48af-abd8-aa909047ef38","idx":"5ac23dbf-acc4-423d-8048-4a1a13267eab"}
{"func_before":"                r = log_error_errno(errno, \"Failed to get input name: %m\");\n                goto fail;\n        }\n\n        (void) button_set_mask(b);\n        \n        b->io_event_source = sd_event_source_unref(b->io_event_source);\n        r = sd_event_add_io(b->manager->event, &b->io_event_source, b->fd, EPOLLIN, button_dispatch, b);\n        if (r < 0) {\n                log_error_errno(r, \"Failed to add button event: %m\");\n                goto fail;\n        }","target":0,"flaw_line_index":0,"hash":"ae55605b-cf0c-47cc-b71c-37c4463f66c3","idx":"78c50c87-f8c5-4b8e-88dc-8150d4b8a0dc"}
{"func_before":"\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes too much\",\n\t\t           name, end - start);\n\t\treturn FALSE;\n\t}\n\tdiff = start - end;\n\tif (diff > 0)\n\t{\n\t\tWLog_Print(update->log, WLOG_DEBUG,\n\t\t           \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes short, skipping\", name, diff);\n\t\tStream_Seek(s, diff);\n\t}\n\treturn rc;\n}","target":1,"flaw_line_index":0,"hash":"cf714850-76de-42c4-b346-72dd71ec2222","idx":"b21d919f-288a-46c2-b6d5-9c643a1404ba"}
{"func_before":"\t{\n\t\tWLog_Print(update->log, WLOG_WARN, \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes too much\",\n\t\t           name, end - start);\n\t\treturn FALSE;\n\t}\n\tdiff = end - start;\n\tif (diff > 0)\n\t{\n\t\tWLog_Print(update->log, WLOG_DEBUG,\n\t\t           \"SECONDARY_ORDER %s: read %\" PRIuz \"bytes short, skipping\", name, diff);\n\t\tif (!Stream_SafeSeek(s, diff))\n\t\t\treturn FALSE;\n\t}\n\treturn rc;\n}","target":0,"flaw_line_index":0,"hash":"ffe7b377-25cc-4cc8-9de6-57e0be812e49","idx":"8582c60c-0b77-49b4-bc32-7b13bbb17091"}
{"func_before":"\n    vector<char> errMsg(BUF_LEN, 0);\n\n    strncpy(keyArray->data(), _key, BUF_LEN);\n    *errStatus = 0;\n    unsigned int encryptedLen = 0;\n\n    sgx_status_t status = trustedEncryptKeyAES(eid, errStatus, errMsg.data(), keyArray->data(), encryptedKey->data(), &encryptedLen);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, *errStatus, errMsg.data());\n","target":1,"flaw_line_index":0,"hash":"bb5e61c4-9237-4891-bed4-5f16301925f2","idx":"75fe5142-8ec4-426d-93ae-ba16c02944f1"}
{"func_before":"\n    vector<char> errMsg(BUF_LEN, 0);\n\n    strncpy(keyArray->data(), _key, BUF_LEN);\n    *errStatus = 0;\n\n    uint64_t encryptedLen = 0;\n\n    sgx_status_t status = trustedEncryptKeyAES(eid, errStatus, errMsg.data(), keyArray->data(), encryptedKey->data(), &encryptedLen);\n\n    HANDLE_TRUSTED_FUNCTION_ERROR(status, *errStatus, errMsg.data());\n","target":0,"flaw_line_index":0,"hash":"6ed71782-ac89-4f8b-92fb-07276898bf1a","idx":"bdae8cf1-0aaa-444e-82a1-b4ec0c94ed7c"}
{"func_before":"{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (ehdri.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64\n    || sizeof(Elf64_Phdr) != e_phentsize\n    || (Elf64_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf64_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {","target":1,"flaw_line_index":0,"hash":"afe6a6d0-e8ee-4f0a-8904-676666815ad3","idx":"cfde203e-66b2-4772-b6cc-b23b07290b69"}
{"func_before":"{\n    e_type  = get_te16(&ehdri.e_type);\n    e_phnum = get_te16(&ehdri.e_phnum);\n    e_shnum = get_te16(&ehdri.e_shnum);\n    unsigned const e_phentsize = get_te16(&ehdri.e_phentsize);\n    if (memcmp((char const *)&ehdri, \"\\x7f\\x45\\x4c\\x46\", 4)  \/\/ \"\\177ELF\"\n    || ehdri.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64\n    || sizeof(Elf64_Phdr) != e_phentsize\n    || (Elf64_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::be_policy != bele)\n    || (Elf64_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA]\n            && &N_BELE_RTP::le_policy != bele)) {","target":0,"flaw_line_index":0,"hash":"ca281463-c874-4ffe-a472-d6e16e4abff4","idx":"96a41397-ee44-4e48-92d6-c25a46766659"}
{"func_before":"static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES];\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tstruct page *localpage = NULL;\n\tint ret;\n\n\tif (buflen < PAGE_SIZE) {\n\t\t\/* As long as we're doing a round trip to the server anyway,\n\t\t * let's be prepared for a page of acl data. *\/\n\t\tlocalpage = alloc_page(GFP_KERNEL);\n\t\tresp_buf = page_address(localpage);\n\t\tif (localpage == NULL)\n\t\t\treturn -ENOMEM;\n\t\targs.acl_pages[0] = localpage;\n\t\targs.acl_pgbase = 0;\n\t\targs.acl_len = PAGE_SIZE;\n\t} else {\n\t\tresp_buf = buf;\n\t\tbuf_to_pages(buf, buflen, args.acl_pages, &args.acl_pgbase);\n\t}\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode), &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\tif (res.acl_len > args.acl_len)\n\t\tnfs4_write_cached_acl(inode, NULL, res.acl_len);\n\telse\n\t\tnfs4_write_cached_acl(inode, resp_buf, res.acl_len);\n\tif (buf) {\n\t\tret = -ERANGE;\n\t\tif (res.acl_len > buflen)\n\t\t\tgoto out_free;\n\t\tif (localpage)\n\t\t\tmemcpy(buf, resp_buf, res.acl_len);\n\t}\n\tret = res.acl_len;\nout_free:\n\tif (localpage)\n\t\t__free_page(localpage);\n\treturn ret;\n}","target":1,"flaw_line_index":0,"hash":"5d983bb8-4f63-4bef-9ef1-04cdb1bf3c1f","idx":"0fb4cbc1-e192-48ce-9545-3b3c5466d3bc"}
{"func_before":"static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tint ret = -ENOMEM, npages, i, acl_len = 0;\n\n\tnpages = (buflen + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. *\/\n\tif (npages == 0)\n\t\tnpages = 1;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\tif (npages > 1) {\n\t\t\/* for decoding across pages *\/\n\t\targs.acl_scratch = alloc_page(GFP_KERNEL);\n\t\tif (!args.acl_scratch)\n\t\t\tgoto out_free;\n\t}\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\t\/* Let decode_getfacl know not to fail if the ACL data is larger than\n\t * the page we send as a guess *\/\n\tif (buf == NULL)\n\t\tres.acl_flags |= NFS4_ACL_LEN_REQUEST;\n\tresp_buf = page_address(pages[0]);\n\n\tdprintk(\"%s  buf %p buflen %ld npages %d args.acl_len %ld\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\n\tacl_len = res.acl_len - res.acl_data_offset;\n\tif (acl_len > args.acl_len)\n\t\tnfs4_write_cached_acl(inode, NULL, acl_len);\n\telse\n\t\tnfs4_write_cached_acl(inode, resp_buf + res.acl_data_offset,\n\t\t\t\t      acl_len);\n\tif (buf) {\n\t\tret = -ERANGE;\n\t\tif (acl_len > buflen)\n\t\t\tgoto out_free;\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset,\n\t\t\t\tres.acl_len);\n\t}\n\tret = acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (args.acl_scratch)\n\t\t__free_page(args.acl_scratch);\n\treturn ret;\n}","target":0,"flaw_line_index":0,"hash":"72054876-45d0-4034-afb5-a2c4e5b0ef8a","idx":"7cf704c7-13bf-4842-8ca0-85289d5cd7ef"}
{"func_before":"MONGO_EXPORT bson_type bson_iterator_next( bson_iterator *i ) {\n    int ds;\n\n    if ( i->first ) {\n        i->first = 0;\n        return ( bson_type )( *i->cur );\n    }","target":1,"flaw_line_index":0,"hash":"2b971258-587e-4553-b691-ad65b802672f","idx":"4a529ec3-072e-4311-a34c-982cf90855f5"}
{"func_before":"MONGO_EXPORT bson_type bson_iterator_next( bson_iterator *i ) {\n    size_t ds;\n\n    if ( i->first ) {\n        i->first = 0;\n        return ( bson_type )( *i->cur );\n    }","target":0,"flaw_line_index":0,"hash":"5af524f0-422f-4b74-b543-491dbaa854bf","idx":"16d626d9-35de-49a2-ac9c-908a339ecb73"}
{"func_before":"void ModifiablePixelBuffer::fillRect(const Rect& r, const void* pix)\n{\n  int stride;\n  U8 *buf;\n  int w, h, b;\n\n  w = r.width();\n  h = r.height();\n  b = format.bpp\/8;\n\n  if (h == 0)\n    return;\n\n  buf = getBufferRW(r, &stride);\n\n  if (b == 1) {\n    while (h--) {\n      memset(buf, *(const U8*)pix, w);\n      buf += stride * b;\n      memcpy(buf, start, w * b);\n      buf += stride * b;\n    }\n  }\n\n  commitBufferRW(r);\n}","target":1,"flaw_line_index":0,"hash":"9731d0e8-359a-4b7b-b4a1-2bcae71be618","idx":"ac805359-e91a-4d99-a898-3a691fc782eb"}
{"func_before":"void ModifiablePixelBuffer::fillRect(const Rect& r, const void* pix)\n{\n  int stride;\n  U8 *buf;\n  int w, h, b;\n  Rect drect;\n\n  drect = r;\n  if (!drect.enclosed_by(getRect())) {\n    vlog.error(\"Destination rect %dx%d at %d,%d exceeds framebuffer %dx%d\",\n               drect.width(), drect.height(), drect.tl.x, drect.tl.y, width_, height_);\n    drect = drect.intersect(getRect());\n  }\n\n  if (drect.is_empty())\n    return;\n\n  w = drect.width();\n  h = drect.height();\n  b = format.bpp\/8;\n\n  if (h == 0)\n    return;\n\n  buf = getBufferRW(drect, &stride);\n\n  if (b == 1) {\n    while (h--) {\n      memset(buf, *(const U8*)pix, w);\n      buf += stride * b;\n      memcpy(buf, start, w * b);\n      buf += stride * b;\n    }\n  }\n\n  commitBufferRW(drect);\n}","target":0,"flaw_line_index":0,"hash":"0851d0f4-d587-4dc2-9625-a61630690ef2","idx":"4080aa6b-714d-45df-a79c-6fa88801ab0f"}
{"func_before":"static Jsi_RC NumberToPrecisionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[100];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<=0) return JSI_ERROR;\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf),\"%.*\" JSI_NUMFFMT, prec, num);\n    if (num<0)\n        prec++;\n    buf[prec+1] = 0;","target":1,"flaw_line_index":0,"hash":"d3fda624-0055-44f6-8f0e-1a1563df3d75","idx":"2614e371-7a20-4733-b76b-80928207dbb9"}
{"func_before":"static Jsi_RC NumberToPrecisionCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,\n    Jsi_Value **ret, Jsi_Func *funcPtr)\n{\n    char buf[JSI_MAX_NUMBER_STRING*2];\n    int prec = 0, skip = 0;\n    Jsi_Number num;\n    Jsi_Value *v;\n    ChkStringN(_this, funcPtr, v);\n    if (Jsi_GetIntFromValue(interp, Jsi_ValueArrayIndex(interp, args, skip), &prec) != JSI_OK)\n        return JSI_ERROR;\n    if (prec<=0 || prec>JSI_MAX_NUMBER_STRING) return Jsi_LogError(\"precision must be between 1 and %d\", JSI_MAX_NUMBER_STRING);\n    Jsi_GetDoubleFromValue(interp, v, &num);\n    snprintf(buf, sizeof(buf),\"%.*\" JSI_NUMFFMT, prec, num);\n    if (num<0)\n        prec++;\n    buf[prec+1] = 0;","target":0,"flaw_line_index":0,"hash":"8c1a9301-df4e-4c15-923e-4fb481cb7e6a","idx":"bb71cbb3-63fe-4c60-a7e2-5c9bb7c6213e"}
{"func_before":"static int em_loop(struct x86_emulate_ctxt *ctxt)\n{\n\tregister_address_increment(ctxt, reg_rmw(ctxt, VCPU_REGS_RCX), -1);\n\tif ((address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) != 0) &&\n\t    (ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))\n\t\tjmp_rel(ctxt, ctxt->src.val);\n\n\treturn X86EMUL_CONTINUE;\n}","target":1,"flaw_line_index":0,"hash":"480c9c46-cd19-4fab-8169-88b5cc3d0ff3","idx":"850b8523-0477-4f89-bd77-9be1a12b5e5a"}
{"func_before":"static int em_loop(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc = X86EMUL_CONTINUE;\n\n\tregister_address_increment(ctxt, reg_rmw(ctxt, VCPU_REGS_RCX), -1);\n\tif ((address_mask(ctxt, reg_read(ctxt, VCPU_REGS_RCX)) != 0) &&\n\t    (ctxt->b == 0xe2 || test_cc(ctxt->b ^ 0x5, ctxt->eflags)))\n\t\trc = jmp_rel(ctxt, ctxt->src.val);\n\n\treturn rc;\n}","target":0,"flaw_line_index":0,"hash":"df0c806c-bf6e-4235-90c9-7d8ef65165d8","idx":"950cbcdc-a599-4643-b8e6-12401a4e3a3b"}
{"func_before":"   }\n\n   \/\/Write the hash table to the DM9000 controller\n   for(i = 0; i < 8; i++)\n   {\n      dm9000WriteReg(DM9000_REG_MAR0 + i, hashTable[i]);\n   }\n\n   \/\/Debug message\n   TRACE_DEBUG(\"  MAR = %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" \"\n      \"%02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \"\\r\\n\",\n      dm9000ReadReg(DM9000_REG_MAR0), dm9000ReadReg(DM9000_REG_MAR1),\n      dm9000ReadReg(DM9000_REG_MAR2), dm9000ReadReg(DM9000_REG_MAR3),\n      dm9000ReadReg(DM9000_REG_MAR4), dm9000ReadReg(DM9000_REG_MAR5),\n      dm9000ReadReg(DM9000_REG_MAR6), dm9000ReadReg(DM9000_REG_MAR7));\n\n   \/\/Successful processing\n   return NO_ERROR;\n}","target":1,"flaw_line_index":0,"hash":"c132f881-5dd6-4a7e-aaf3-f95ba6cd12de","idx":"97af69de-76f6-4e10-a567-c79ce3b83b34"}
{"func_before":"   }\n\n   \/\/Write the hash table to the DM9000 controller\n   for(i = 0; i < 8; i++)\n   {\n      dm9000WriteReg(DM9000_MAR0 + i, hashTable[i]);\n   }\n\n   \/\/Debug message\n   TRACE_DEBUG(\"  MAR = %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" \"\n      \"%02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \" %02\" PRIX8 \"\\r\\n\",\n      dm9000ReadReg(DM9000_MAR0), dm9000ReadReg(DM9000_MAR1),\n      dm9000ReadReg(DM9000_MAR2), dm9000ReadReg(DM9000_MAR3),\n      dm9000ReadReg(DM9000_MAR4), dm9000ReadReg(DM9000_MAR5),\n      dm9000ReadReg(DM9000_MAR6), dm9000ReadReg(DM9000_MAR7));\n\n   \/\/Successful processing\n   return NO_ERROR;\n}","target":0,"flaw_line_index":0,"hash":"c5b4cfeb-f7ac-450e-bba8-8409bcaabf78","idx":"bb955f89-7690-4cb1-b72c-49b60014b4c0"}
{"func_before":"\tretval = copy_strings_kernel (1, &iname_addr, bprm);\n\tif (retval < 0)\n\t\tgoto _error;\n\tbprm->argc ++;\n\n\tbprm->interp = iname;\t\/* for binfmt_script *\/\n\n\tinterp_file = open_exec (iname);\n\tretval = PTR_ERR (interp_file);\n\tif (IS_ERR (interp_file))\n\t\tgoto _error;","target":1,"flaw_line_index":0,"hash":"f94df6d4-7751-4f0d-adea-4c7c3e4def5c","idx":"3e13846f-eaf1-43b4-adad-ebe8688fc9a1"}
{"func_before":"\tretval = copy_strings_kernel (1, &iname_addr, bprm);\n\tif (retval < 0)\n\t\tgoto _error;\n\tbprm->argc ++;\n\n\t\/* Update interp in case binfmt_script needs it. *\/\n\tretval = bprm_change_interp(iname, bprm);\n\tif (retval < 0)\n\t\tgoto _error;\n\n\tinterp_file = open_exec (iname);\n\tretval = PTR_ERR (interp_file);\n\tif (IS_ERR (interp_file))\n\t\tgoto _error;","target":0,"flaw_line_index":0,"hash":"6b858a32-ecfa-4b30-85f0-67eb330996dd","idx":"d4a3b919-0832-4ef4-8751-b0e3aa923ef7"}
{"func_before":"void Curl_detach_connnection(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  if(conn)\n    Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);\n  data->conn = NULL;\n}","target":1,"flaw_line_index":0,"hash":"32b2bc71-b796-4f1b-a09c-736e5c7acab9","idx":"4814debd-1e76-4afb-a6ef-e0cb0a3d829f"}
{"func_before":"void Curl_detach_connnection(struct Curl_easy *data)\n{\n  struct connectdata *conn = data->conn;\n  if(conn) {\n    Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);\n    Curl_ssl_detach_conn(data, conn);\n  }\n  data->conn = NULL;\n}","target":0,"flaw_line_index":0,"hash":"4573edbd-c62b-4d43-88fb-a6455142a4b1","idx":"3c4b1b00-4083-4944-acf0-a88e20c3d6d1"}
{"func_before":"void RegKey::setBinary(const TCHAR* valname, const void* value, int length) const {\n  LONG result = RegSetValueEx(key, valname, 0, REG_BINARY, (const BYTE*)value, length);\n  if (result != ERROR_SUCCESS) throw rdr::SystemException(\"setBinary\", result);\n}","target":1,"flaw_line_index":0,"hash":"875ee838-c60c-4290-a406-db12f463fc6b","idx":"48668dbd-7473-4662-98a3-f8a87cc8e647"}
{"func_before":"void RegKey::setBinary(const TCHAR* valname, const void* value, size_t length) const {\n  LONG result = RegSetValueEx(key, valname, 0, REG_BINARY, (const BYTE*)value, length);\n  if (result != ERROR_SUCCESS) throw rdr::SystemException(\"setBinary\", result);\n}","target":0,"flaw_line_index":0,"hash":"dcae91b7-c785-4a83-a4ec-2ccdf287790f","idx":"f7143501-b4dd-4d41-be62-b04b5e3bc20a"}
{"func_before":"    oe_off_t offset)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    if (!file)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_pread_ocall(&ret, file->host_fd, buf, count, offset) !=\n        OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\ndone:\n    return ret;\n}","target":1,"flaw_line_index":0,"hash":"24dcfe2b-b147-4b77-aa58-46570fb2f2f4","idx":"bae41d67-3b45-489a-ba20-4db7eaf374a7"}
{"func_before":"    oe_off_t offset)\n{\n    ssize_t ret = -1;\n    file_t* file = _cast_file(desc);\n\n    \/*\n     * According to the POSIX specification, when the count is greater\n     * than SSIZE_MAX, the result is implementation-defined. OE raises an\n     * error in this case.\n     * Refer to\n     * https:\/\/pubs.opengroup.org\/onlinepubs\/9699919799\/functions\/pread.html for\n     * for more detail.\n     *\/\n    if (!file || count > OE_SSIZE_MAX)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    if (oe_syscall_pread_ocall(&ret, file->host_fd, buf, count, offset) !=\n        OE_OK)\n        OE_RAISE_ERRNO(OE_EINVAL);\n\n    \/*\n     * Guard the special case that a host sets an arbitrarily large value.\n     * The returned value should not exceed count.\n     *\/\n    if (ret > (ssize_t)count)\n    {\n        ret = -1;\n        OE_RAISE_ERRNO(OE_EINVAL);\n    }\n\ndone:\n    return ret;\n}","target":0,"flaw_line_index":0,"hash":"901eaf65-39b6-458e-8f6c-801a6626e244","idx":"b53dcdbd-ec3b-4ebc-93c2-a9d95c998298"}
{"func_before":"\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (0 == err) {\n\t\t\/* Search if there are some non-printable characters *\/\n\t\tfor (cp = field; '\\0' != *cp; cp++) {\n\t\t\tif (!isprint (*cp)) {\n\t\t\t\terr = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n","target":1,"flaw_line_index":0,"hash":"7158191d-b39d-46e5-8086-2a481c57c781","idx":"0fb41eea-55d3-4fc3-a974-db9e0250fe49"}
{"func_before":"\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (0 == err) {\n\t\t\/* Search if there are non-printable or control characters *\/\n\t\tfor (cp = field; '\\0' != *cp; cp++) {\n\t\t\tif (!isprint (*cp)) {\n\t\t\t\terr = 1;\n\t\t\t}\n\t\t\tif (!iscntrl (*cp)) {\n\t\t\t\terr = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n","target":0,"flaw_line_index":0,"hash":"233bdb39-0c53-415e-acf8-3deb286ba774","idx":"5e002bc5-7182-4183-9f19-c7b3012b940d"}
{"func_before":"    dictionary *ubridge_config = NULL;\n    const char *value;\n    const char *bridge_name;\n    int i, nsec;\n\n    if ((ubridge_config = iniparser_load(filename)) == NULL) {\n       return FALSE;\n    }\n\n    nsec = iniparser_getnsec(ubridge_config);\n    for (i = 0; i < nsec; i++) {","target":1,"flaw_line_index":0,"hash":"d747cd1f-8ed5-4bbc-876e-64ef74f68aa6","idx":"9582622f-7cd7-42c5-a2ea-74bd10150c61"}
{"func_before":"    dictionary *ubridge_config = NULL;\n    const char *value;\n    const char *bridge_name;\n    int i, nsec;\n\n    if ((ubridge_config = iniparser_load(filename, HIDE_ERRORED_LINE_CONTENT)) == NULL) {\n       return FALSE;\n    }\n\n    nsec = iniparser_getnsec(ubridge_config);\n    for (i = 0; i < nsec; i++) {","target":0,"flaw_line_index":0,"hash":"e222a122-e764-4728-a06f-ce485f65b97b","idx":"d49bfb9c-cd54-4d9b-9769-0242c38689b9"}
{"func_before":"\tstruct sk_buff *skb = (struct sk_buff *)(long) ctx;\n\tstruct nlattr *nla;\n\n\tif (skb_is_nonlinear(skb))\n\t\treturn 0;\n\n\tif (A > skb->len - sizeof(struct nlattr))\n\t\treturn 0;\n\n\tnla = (struct nlattr *) &skb->data[A];\n\tif (nla->nla_len > A - skb->len)\n\t\treturn 0;\n\n\tnla = nla_find_nested(nla, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;","target":1,"flaw_line_index":0,"hash":"0335824c-6bfa-4722-903e-f88b0fe09c59","idx":"a157996b-d796-454e-b195-fa597464bb8b"}
{"func_before":"\tstruct nlattr *nla;\n\n\tif (skb_is_nonlinear(skb))\n\t\treturn 0;\n\n\tif (skb->len < sizeof(struct nlattr))\n\t\treturn 0;\n\n\tif (A > skb->len - sizeof(struct nlattr))\n\t\treturn 0;\n\n\tnla = (struct nlattr *) &skb->data[A];\n\tif (nla->nla_len > skb->len - A)\n\t\treturn 0;\n\n\tnla = nla_find_nested(nla, X);\n\tif (nla)\n\t\treturn (void *) nla - (void *) skb->data;","target":0,"flaw_line_index":0,"hash":"9d3ee665-f26f-4b83-9a98-672e96d20497","idx":"e0f911d7-9921-42ed-92b1-594ebd4c2047"}
{"func_before":"int rand_check(uint8_t *buf, int size) {\n\tint count = 0;\n\n\tfor (int i = 1; i < size; i++) {\n\t\tif (buf[i] == buf[i - 1]) {\n\t\t\tcount++;","target":1,"flaw_line_index":0,"hash":"06180087-e336-44da-8da0-83466587d7b4","idx":"ff1cd56e-13b5-4612-9099-ceb9894aecc9"}
{"func_before":"int rand_check(uint8_t *buf, size_t size) {\n\tint count = 0;\n\n\tfor (int i = 1; i < size; i++) {\n\t\tif (buf[i] == buf[i - 1]) {\n\t\t\tcount++;","target":0,"flaw_line_index":0,"hash":"46828644-9e6c-4f24-950b-5fe82eba1d5a","idx":"4ef24339-2025-4bda-bad2-071be84d1ffb"}
{"func_before":"\tbmp_info_t *info;\n\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n\tuint_fast16_t numcmpts;\n\tlong n;\n\n\tif (optstr) {\n\t\tjas_eprintf(\"warning: ignoring BMP decoder options\\n\");\n\t}\n\n\t  );\n\n\t\/* Read the bitmap header. *\/\n\tif (bmp_gethdr(in, &hdr)) {\n\t\tjas_eprintf(\"cannot get header\\n\");\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(1, (\n\t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n\t  ));\n\n\t\/* Read the bitmap information. *\/\n\tif (!(info = bmp_getinfo(in))) {\n\t\tjas_eprintf(\"cannot get info\\n\");\n\t\treturn 0;\n\t}\n\tJAS_DBGLOG(1,\n\t  (\"BMP information: len %d; width %d; height %d; numplanes %d; \"\n\t  \"depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; \"\n\t  \"mincolors %d\\n\", info->len, info->width, info->height, info->numplanes,\n\t  info->depth, info->enctype, info->siz, info->hres, info->vres,\n\t  info->numcolors, info->mincolors));\n\n\t\/* Ensure that we support this type of BMP file. *\/\n\tif (!bmp_issupported(&hdr, info)) {\n\t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\t\/* Skip over any useless data between the end of the palette\n\t  and start of the bitmap data. *\/\n\tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n\t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");\n\t\treturn 0;\n\t}\n\tif (n > 0) {\n\t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");\n\t\tif (bmp_gobble(in, n)) {\n\t\t\tbmp_info_destroy(info);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t\/* Get the number of components. *\/\n\tnumcmpts = bmp_numcmpts(info);\n\t}\n\n\t\/* Create image object. *\/\n\tif (!(image = jas_image_create(numcmpts, cmptparms,\n\t  JAS_CLRSPC_UNKNOWN))) {\n\t\tbmp_info_destroy(info);\n\t\treturn 0;\n\t}\n\n\tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t\/* Read the bitmap data. *\/\n\tif (bmp_getdata(in, info, image)) {\n\t\tbmp_info_destroy(info);\n\t\tjas_image_destroy(image);\n\t\treturn 0;\n\t}\n\n\tbmp_info_destroy(info);\n\n\treturn image;\n}","target":1,"flaw_line_index":0,"hash":"1ac1d44a-53a7-4818-9b3a-e439abc5f257","idx":"9c3ca5dc-b8fb-490e-be7f-228ca4ab7d92"}
{"func_before":"\tuint_fast16_t cmptno;\n\tjas_image_cmptparm_t cmptparms[3];\n\tjas_image_cmptparm_t *cmptparm;\n\tuint_fast16_t numcmpts;\n\tlong n;\n\n\timage = 0;\n\tinfo = 0;\n\n\tif (optstr) {\n\t\tjas_eprintf(\"warning: ignoring BMP decoder options\\n\");\n\t}\n\n\t  );\n\n\t\/* Read the bitmap header. *\/\n\tif (bmp_gethdr(in, &hdr)) {\n\t\tjas_eprintf(\"cannot get header\\n\");\n\t\tgoto error;\n\t\t\/\/return 0;\n\t}\n\tJAS_DBGLOG(1, (\n\t  \"BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\\n\",\n\t  hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off\n\t  ));\n\n\t\/* Read the bitmap information. *\/\n\tif (!(info = bmp_getinfo(in))) {\n\t\tjas_eprintf(\"cannot get info\\n\");\n\t\t\/\/return 0;\n\t\tgoto error;\n\t}\n\tJAS_DBGLOG(1,\n\t  (\"BMP information: len %ld; width %ld; height %ld; numplanes %d; \"\n\t  \"depth %d; enctype %ld; siz %ld; hres %ld; vres %ld; numcolors %ld; \"\n\t  \"mincolors %ld\\n\", JAS_CAST(long, info->len),\n\t  JAS_CAST(long, info->width), JAS_CAST(long, info->height),\n\t  JAS_CAST(long, info->numplanes), JAS_CAST(long, info->depth),\n\t  JAS_CAST(long, info->enctype), JAS_CAST(long, info->siz),\n\t  JAS_CAST(long, info->hres), JAS_CAST(long, info->vres),\n\t  JAS_CAST(long, info->numcolors), JAS_CAST(long, info->mincolors)));\n\n\tif (info->width < 0 || info->height < 0 || info->numplanes < 0 ||\n\t  info->depth < 0 || info->siz < 0 || info->hres < 0 || info->vres < 0) {\n\t\tjas_eprintf(\"corrupt bit stream\\n\");\n\t\tgoto error;\n\t}\n\n\t\/* Ensure that we support this type of BMP file. *\/\n\tif (!bmp_issupported(&hdr, info)) {\n\t\tjas_eprintf(\"error: unsupported BMP encoding\\n\");\n\t\t\/\/bmp_info_destroy(info);\n\t\t\/\/return 0;\n\t\tgoto error;\n\t}\n\n\t\/* Skip over any useless data between the end of the palette\n\t  and start of the bitmap data. *\/\n\tif ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {\n\t\tjas_eprintf(\"error: possibly bad bitmap offset?\\n\");\n\t\tgoto error;\n\t\t\/\/return 0;\n\t}\n\tif (n > 0) {\n\t\tjas_eprintf(\"skipping unknown data in BMP file\\n\");\n\t\tif (bmp_gobble(in, n)) {\n\t\t\t\/\/bmp_info_destroy(info);\n\t\t\t\/\/return 0;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t\/* Get the number of components. *\/\n\tnumcmpts = bmp_numcmpts(info);\n\t}\n\n\t\/* Create image object. *\/\n\tif (!(image = jas_image_create(numcmpts, cmptparms,\n\t  JAS_CLRSPC_UNKNOWN))) {\n\t\t\/\/bmp_info_destroy(info);\n\t\t\/\/return 0;\n\t\tgoto error;\n\t}\n\n\tif (numcmpts == 3) {\n\t\tjas_image_setclrspc(image, JAS_CLRSPC_SRGB);\n\t\tjas_image_setcmpttype(image, 0,\n\t\t  JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));\n\t}\n\n\t\/* Read the bitmap data. *\/\n\tif (bmp_getdata(in, info, image)) {\n\t\t\/\/bmp_info_destroy(info);\n\t\t\/\/jas_image_destroy(image);\n\t\t\/\/return 0;\n\t\tgoto error;\n\t}\n\n\tbmp_info_destroy(info);\n\n\treturn image;\n\nerror:\n\tif (info) {\n\t\tbmp_info_destroy(info);\n\t}\n\tif (image) {\n\t\tjas_image_destroy(image);\n\t}\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"7dd25b3e-0fb7-48a2-952c-837f075486ad","idx":"32f6270c-af13-4184-b6e1-4a039be0c03f"}
{"func_before":"  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n\n  const bool requires_broadcast = !HaveSameShapes(input1, input2);\n","target":1,"flaw_line_index":0,"hash":"756bfb91-8097-4c03-ae51-133c54aa9a5f","idx":"b2cfd714-6ea8-4462-ad3b-5d6b32cca25e"}
{"func_before":"  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n\n  const bool requires_broadcast = !HaveSameShapes(input1, input2);\n","target":0,"flaw_line_index":0,"hash":"1fc4ee83-e25f-4a7a-b86c-b645b7eea27f","idx":"29360501-2571-41b0-8b67-7718126c89c7"}
{"func_before":"    Jsi_Obj *obj = args->d.obj;\n    Jsi_Value *v;\n    assert(args->vt == JSI_VT_OBJECT);\n    if (obj->isarrlist && obj->arr)\n        return ((index < 0 || (uint)index >= obj->arrCnt) ? NULL : obj->arr[index]);\n    char unibuf[100];\n    Jsi_NumberItoA10(index, unibuf, sizeof(unibuf));\n    v = Jsi_TreeObjGetValue(args->d.obj, unibuf, 0);\n    return v;\n}","target":1,"flaw_line_index":0,"hash":"46f2a1c0-8bb4-43ca-8580-19e9e41ac81a","idx":"0fbc4031-5d78-414e-91ba-2b5c8367ad41"}
{"func_before":"    Jsi_Obj *obj = args->d.obj;\n    Jsi_Value *v;\n    assert(args->vt == JSI_VT_OBJECT);\n    if (obj->isarrlist && obj->arr)\n        return ((index < 0 || (uint)index >= obj->arrCnt) ? NULL : obj->arr[index]);\n    char unibuf[JSI_MAX_NUMBER_STRING];\n    Jsi_NumberItoA10(index, unibuf, sizeof(unibuf));\n    v = Jsi_TreeObjGetValue(args->d.obj, unibuf, 0);\n    return v;\n}","target":0,"flaw_line_index":0,"hash":"b73a0e00-ab65-4abf-88e8-119b915b9346","idx":"eb1e4d1e-4c29-449f-9a4f-a8eb743bf8ab"}
{"func_before":"\t\tgoto load;\n\t}\n\n\trpl = selector & 3;\n\n\t\/* NULL selector is not valid for TR, CS and SS (except for long mode) *\/\n\tif ((seg == VCPU_SREG_CS\n\t     || (seg == VCPU_SREG_SS\n\t\t && (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl))\n\t     || seg == VCPU_SREG_TR)\n\t    && null_selector)\n\t\tgoto exception;\n\n\t\/* TR should be in GDT only *\/\n\tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n\t\tgoto exception;\n\n\tif (null_selector) \/* for NULL selector skip all following checks *\/\n\t\tgoto load;\n\n\tret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n","target":1,"flaw_line_index":0,"hash":"d5d5dea8-724b-4b66-8a84-c518eac17d1e","idx":"32ad0ebc-b4a4-43f2-aaab-bc056c1d0313"}
{"func_before":"\t\tseg_desc.dpl = 3;\n\t\tgoto load;\n\t}\n\n\trpl = selector & 3;\n\n\t\/* TR should be in GDT only *\/\n\tif (seg == VCPU_SREG_TR && (selector & (1 << 2)))\n\t\tgoto exception;\n\n\t\/* NULL selector is not valid for TR, CS and (except for long mode) SS *\/\n\tif (null_selector) {\n\t\tif (seg == VCPU_SREG_CS || seg == VCPU_SREG_TR)\n\t\t\tgoto exception;\n\n\t\tif (seg == VCPU_SREG_SS) {\n\t\t\tif (ctxt->mode != X86EMUL_MODE_PROT64 || rpl != cpl)\n\t\t\t\tgoto exception;\n\n\t\t\t\/*\n\t\t\t * ctxt->ops->set_segment expects the CPL to be in\n\t\t\t * SS.DPL, so fake an expand-up 32-bit data segment.\n\t\t\t *\/\n\t\t\tseg_desc.type = 3;\n\t\t\tseg_desc.p = 1;\n\t\t\tseg_desc.s = 1;\n\t\t\tseg_desc.dpl = cpl;\n\t\t\tseg_desc.d = 1;\n\t\t\tseg_desc.g = 1;\n\t\t}\n\n\t\t\/* Skip all following checks *\/\n\t\tgoto load;\n\t}\n\n\tret = read_segment_descriptor(ctxt, selector, &seg_desc, &desc_addr);\n\tif (ret != X86EMUL_CONTINUE)\n\t\treturn ret;\n","target":0,"flaw_line_index":0,"hash":"aeda29a8-ba89-4447-a55e-b6516a91c6f6","idx":"9be305d5-5717-4cf1-9123-323c28578ae7"}
{"func_before":"\n  array = object_as_array(object);\n\n  if (array->items == NULL)\n  {\n    count = yr_max(64, (index + 1) * 2);\n\n    array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n\n    array->items->count = count;\n  }\n  else if (index >= array->items->count)\n  {\n    count = array->items->count * 2;\n    array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n        array->items,\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)","target":1,"flaw_line_index":0,"hash":"72f68702-b98d-4458-80e0-e0b12fe62af7","idx":"8f91a0bc-8544-4c86-b4b3-2794ca1d9d7c"}
{"func_before":"\n  array = object_as_array(object);\n\n  if (array->items == NULL)\n  {\n    count = 64;\n\n    while (count <= index)\n      count *= 2;\n\n    array->items = (YR_ARRAY_ITEMS*) yr_malloc(\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)\n    array->items->count = count;\n  }\n  else if (index >= array->items->count)\n  {\n    count = array->items->count * 2;\n\n    while (count <= index)\n      count *= 2;\n\n    array->items = (YR_ARRAY_ITEMS*) yr_realloc(\n        array->items,\n        sizeof(YR_ARRAY_ITEMS) + count * sizeof(YR_OBJECT*));\n\n    if (array->items == NULL)","target":0,"flaw_line_index":0,"hash":"19c6195b-560c-4fb8-baac-fd476853c79c","idx":"5dae0515-62fc-41cc-a43f-1ffb8c37f7d4"}
{"func_before":"  void AddBatchOffsets(Tensor* indices, const Tensor& params) {\n    int64_t batch_size = 1;  \/\/ The size of all batch dimensions.\n    for (int idx = 0; idx < batch_dims_; ++idx) {\n      batch_size *= params.dim_size(idx);\n    }\n\n    auto indices_flat = indices->flat<Index>();\n    int64_t const index_inner_size = indices->NumElements() \/ batch_size;\n    int64_t const batch_offset = params.dim_size(batch_dims_);\n    for (int64_t batch_idx = 0, dest_idx = 0; batch_idx < batch_size;","target":1,"flaw_line_index":0,"hash":"5a206bf3-f131-4f05-9fd2-6fdfb59551fa","idx":"f1caf32a-e864-4502-b59a-55cf7704a11b"}
{"func_before":"  void AddBatchOffsets(OpKernelContext* ctx, Tensor* indices,\n                       const Tensor& params) {\n    int64_t batch_size = 1;  \/\/ The size of all batch dimensions.\n    for (int idx = 0; idx < batch_dims_; ++idx) {\n      batch_size *= params.dim_size(idx);\n    }\n    OP_REQUIRES(\n        ctx, batch_size != 0,\n        errors::InvalidArgument(\n            \"Inner size of indices would result in batch_size of 0 and a \",\n            \"division by 0 in the implementation. This is illegal\"));\n\n    auto indices_flat = indices->flat<Index>();\n    int64_t const index_inner_size = indices->NumElements() \/ batch_size;\n    int64_t const batch_offset = params.dim_size(batch_dims_);\n    for (int64_t batch_idx = 0, dest_idx = 0; batch_idx < batch_size;","target":0,"flaw_line_index":0,"hash":"11b70509-96d0-4319-ada2-c8d2b56f73b2","idx":"143c4607-0f0b-43fb-aeff-10a4adb1996d"}
{"func_before":"\n    holder->packetLength = sizeof(NV_SCROLL_PACKET);\n    holder->packet.scroll.header.packetType = htonl(PACKET_TYPE_SCROLL);\n    holder->packet.scroll.magicA = MAGIC_A;\n    \/\/ On Gen 5 servers, the header code is incremented by one\n    if (ServerMajorVersion >= 5) {\n        holder->packet.scroll.magicA++;\n    }\n    holder->packet.scroll.zero1 = 0;\n    holder->packet.scroll.zero2 = 0;\n    holder->packet.scroll.scrollAmt1 = htons(scrollClicks * 120);","target":1,"flaw_line_index":0,"hash":"21683b95-56d9-49d8-9453-8ee526175afc","idx":"08e43cd0-b779-468b-b899-631eccc64481"}
{"func_before":"\n    holder->packetLength = sizeof(NV_SCROLL_PACKET);\n    holder->packet.scroll.header.packetType = htonl(PACKET_TYPE_SCROLL);\n    holder->packet.scroll.magicA = MAGIC_A;\n    \/\/ On Gen 5 servers, the header code is incremented by one\n    if (AppVersionQuad[0] >= 5) {\n        holder->packet.scroll.magicA++;\n    }\n    holder->packet.scroll.zero1 = 0;\n    holder->packet.scroll.zero2 = 0;\n    holder->packet.scroll.scrollAmt1 = htons(scrollClicks * 120);","target":0,"flaw_line_index":0,"hash":"f22c74e2-a2df-4463-a9cf-8e9cc6c4fa0d","idx":"7953f7ca-942c-4879-a16a-c072b0c4f065"}
{"func_before":"\t *\tSource addr check\n\t *\/\n\n\tif (__ipv6_addr_needs_scope_id(addr_type))\n\t\tiif = skb->dev->ifindex;\n\telse\n\t\tiif = l3mdev_master_ifindex(skb_dst(skb)->dev);\n\n\t\/*\n\t *\tMust not send error if the source does not uniquely\n\t *\tidentify a single node (RFC2463 Section 2.4).\n\t *\tWe check unspecified \/ multicast addresses here,","target":1,"flaw_line_index":0,"hash":"55b22085-c5d2-4ebb-a665-e24aac4b7698","idx":"fff1f648-ae68-403c-a2c5-87b7db63d9bd"}
{"func_before":"\t *\tSource addr check\n\t *\/\n\n\tif (__ipv6_addr_needs_scope_id(addr_type))\n\t\tiif = skb->dev->ifindex;\n\telse {\n\t\tdst = skb_dst(skb);\n\t\tiif = l3mdev_master_ifindex(dst ? dst->dev : skb->dev);\n\t}\n\n\t\/*\n\t *\tMust not send error if the source does not uniquely\n\t *\tidentify a single node (RFC2463 Section 2.4).\n\t *\tWe check unspecified \/ multicast addresses here,","target":0,"flaw_line_index":0,"hash":"cc28cb0a-fb18-4872-b0b0-fda93b7e6023","idx":"1622f090-801e-4188-9f63-49ad8ae34d4a"}
{"func_before":"\tstruct link_ref *ref = NULL;\n\n\tref = references[hash % REF_TABLE_SIZE];\n\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash)\n\t\t\treturn ref;\n\n\t\tref = ref->next;\n\t}\n\n\treturn NULL;","target":1,"flaw_line_index":0,"hash":"ed2df7d5-feff-49fb-969a-98f77c86bea4","idx":"1e25269e-acec-4774-9995-cf2ea7f2fb30"}
{"func_before":"\tstruct link_ref *ref = NULL;\n\n\tref = references[hash % REF_TABLE_SIZE];\n\n\twhile (ref != NULL) {\n\t\tif (ref->id == hash && ref->label->size == length) {\n\t\t\tif (strncasecmp((char *)ref->label->data, (char *) name, length) == 0) {\n\t\t\t\treturn ref;\n\t\t\t}\n\t\t}\n\n\t\tref = ref->next;\n\t}\n\n\treturn NULL;","target":0,"flaw_line_index":0,"hash":"b0741639-ce20-4e94-8650-ff990f6afa24","idx":"52461a29-0320-44db-b9a0-2b0028cf3229"}
{"func_before":"          f << \"###dbDataName\";\n          break;\n        }\n        data.m_name=libstoff::getString(text);\n        int positions[2];\n        for (int j=0; j<2; ++j) positions[i]=int(input->readULong(4));\n        data.m_selection=STOFFVec2i(positions[0],positions[1]);\n        m_dataList.push_back(data);\n      }\n    }\n  }","target":1,"flaw_line_index":0,"hash":"f8d54fb8-6b82-420d-8db2-aa5545354670","idx":"d721f079-328f-459a-9713-15226bc5a344"}
{"func_before":"          f << \"###dbDataName\";\n          break;\n        }\n        data.m_name=libstoff::getString(text);\n        int positions[2];\n        for (int j=0; j<2; ++j) positions[j]=int(input->readULong(4));\n        data.m_selection=STOFFVec2i(positions[0],positions[1]);\n        m_dataList.push_back(data);\n      }\n    }\n  }","target":0,"flaw_line_index":0,"hash":"35de7f06-7ca9-49d9-b9ed-fc900a92d713","idx":"b554ea97-782a-479e-adee-4b64eeaa40fe"}
{"func_before":"  void Compute(OpKernelContext* ctx) override {\n    try {\n      const Tensor& input = ctx->input(kInputTensorIndex);\n      const Tensor& input_min_vec = ctx->input(kInputMinVecIndex);\n      float* input_min_vec_data = (float*)const_cast<void*>(\n          static_cast<const void*>(input_min_vec.flat<float>().data()));\n      const Tensor& input_max_vec = ctx->input(kInputMaxVecIndex);\n      float* input_max_vec_data = (float*)const_cast<void*>(\n          static_cast<const void*>(input_max_vec.flat<float>().data()));\n\n      const Tensor& input_requested_min = ctx->input(this->kRequestMinIndex);\n      const float input_requested_min_float =\n          input_requested_min.flat<float>()(0);\n      const Tensor& input_requested_max = ctx->input(this->kRequestMaxIndex);\n      const float input_requested_max_float =\n          input_requested_max.flat<float>()(0);\n\n      size_t depth = input_min_vec.NumElements();\n      OP_REQUIRES(\n          ctx, input.dims() == 4,\n          errors::InvalidArgument(\"Current RequantizePerChannel operator\"\n                                  \"supports 4D tensors only.\"));\n      OP_REQUIRES(\n          ctx, input_min_vec.dim_size(0) == depth,\n          errors::InvalidArgument(\"input_min has incorrect size, expected \",\n                                  depth, \" was \", input_min_vec.dim_size(0)));\n      OP_REQUIRES(\n          ctx, input_max_vec.dim_size(0) == depth,\n          errors::InvalidArgument(\"input_max has incorrect size, expected \",\n                                  depth, \" was \", input_max_vec.dim_size(0)));\n\n      if (out_type_ == DT_QINT8) DCHECK(input_requested_min_float < 0.0f);\n\n      const float factor = (out_type_ == DT_QINT8) ? 127.0f : 255.0f;\n      const float requested_min_max =\n          std::max(std::abs(input_requested_min_float),\n                   std::abs(input_requested_max_float));","target":1,"flaw_line_index":0,"hash":"ac83b0ed-6191-4bb5-ae6a-f1d2098bd746","idx":"ea4360bc-8d08-4a5d-87b8-9649e7fd7948"}
{"func_before":"  void Compute(OpKernelContext* ctx) override {\n    try {\n      const Tensor& input = ctx->input(kInputTensorIndex);\n      OP_REQUIRES(\n          ctx, input.dims() == 4,\n          errors::InvalidArgument(\"Current RequantizePerChannel operator\"\n                                  \"supports 4D tensors only.\"));\n\n      const Tensor& input_min_vec = ctx->input(kInputMinVecIndex);\n      size_t depth = input_min_vec.NumElements();\n      float* input_min_vec_data = (float*)const_cast<void*>(\n          static_cast<const void*>(input_min_vec.flat<float>().data()));\n\n      const Tensor& input_max_vec = ctx->input(kInputMaxVecIndex);\n      OP_REQUIRES(\n          ctx, input_max_vec.NumElements() == depth,\n          errors::InvalidArgument(\"input_max has incorrect size, expected \",\n                                  depth, \" was \", input_max_vec.NumElements()));\n      float* input_max_vec_data = (float*)const_cast<void*>(\n          static_cast<const void*>(input_max_vec.flat<float>().data()));\n\n      const Tensor& input_requested_min = ctx->input(this->kRequestMinIndex);\n      OP_REQUIRES(\n          ctx, input_requested_min.NumElements() == 1,\n          errors::InvalidArgument(\"requested_output_min must be a scalar\"));\n      const float input_requested_min_float =\n          input_requested_min.flat<float>()(0);\n\n      const Tensor& input_requested_max = ctx->input(this->kRequestMaxIndex);\n      OP_REQUIRES(\n          ctx, input_requested_min.NumElements() == 1,\n          errors::InvalidArgument(\"requested_output_max must be a scalar\"));\n      const float input_requested_max_float =\n          input_requested_max.flat<float>()(0);\n\n      if (out_type_ == DT_QINT8) {\n        OP_REQUIRES(ctx, input_requested_min_float < 0.0f,\n                    errors::InvalidArgument(\n                        \"If out_type is QINT8, requested_output_max must be \"\n                        \"non negative, got \",\n                        input_requested_min_float));\n      }\n\n      const float factor = (out_type_ == DT_QINT8) ? 127.0f : 255.0f;\n      const float requested_min_max =\n          std::max(std::abs(input_requested_min_float),\n                   std::abs(input_requested_max_float));","target":0,"flaw_line_index":0,"hash":"546a218b-f900-4146-a280-7422e536bb0b","idx":"5d5fdbd3-6833-4724-8b12-32b972b24d4e"}
{"func_before":"static void nft_dynset_activate(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\n\tpriv->set->use++;\n}","target":1,"flaw_line_index":0,"hash":"85b3589b-1d91-4122-90e4-40909a324f41","idx":"82fa8f01-06f4-4341-9ac4-c06f4be13eab"}
{"func_before":"static void nft_dynset_activate(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tstruct nft_dynset *priv = nft_expr_priv(expr);\n\n\tnf_tables_activate_set(ctx, priv->set);\n}","target":0,"flaw_line_index":0,"hash":"5eb2c07c-db31-4c1b-bf29-c626291a55f4","idx":"56f12e3f-186f-4291-9074-0000cbd2e605"}
{"func_before":"\t\t\tret = GSS_S_FAILURE;\n\t\t}\n\t}\n\tgss_release_buffer(&tmpmin, &mechtok_out);\n\tif (ret == GSS_S_COMPLETE) {\n\t\t\/*\n\t\t * Now, switch the output context to refer to the\n\t\t * negotiated mechanism's context.\n\t\t *\/\n\t\t*context_handle = (gss_ctx_id_t)spnego_ctx->ctx_handle;\n\t\tif (actual_mech != NULL)\n\t\t\t*actual_mech = spnego_ctx->actual_mech;\n\t\tif (ret_flags != NULL)\n\t\t\t*ret_flags = spnego_ctx->ctx_flags;\n\t\trelease_spnego_ctx(&spnego_ctx);\n\t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n\t\tif (spnego_ctx != NULL) {\n\t\t\tgss_delete_sec_context(&tmpmin,\n\t\t\t\t\t       &spnego_ctx->ctx_handle,\n\t\t\t\t\t       GSS_C_NO_BUFFER);","target":1,"flaw_line_index":0,"hash":"69e2a421-f7fa-4b25-bf25-047f5c6e1d5c","idx":"406aa574-d6bc-4e39-b8cd-73e1dc51c99a"}
{"func_before":"\t\t\tret = GSS_S_FAILURE;\n\t\t}\n\t}\n\tgss_release_buffer(&tmpmin, &mechtok_out);\n\tif (ret == GSS_S_COMPLETE) {\n\t\tspnego_ctx->opened = 1;\n\t\tif (actual_mech != NULL)\n\t\t\t*actual_mech = spnego_ctx->actual_mech;\n\t\tif (ret_flags != NULL)\n\t\t\t*ret_flags = spnego_ctx->ctx_flags;\n\t} else if (ret != GSS_S_CONTINUE_NEEDED) {\n\t\tif (spnego_ctx != NULL) {\n\t\t\tgss_delete_sec_context(&tmpmin,\n\t\t\t\t\t       &spnego_ctx->ctx_handle,\n\t\t\t\t\t       GSS_C_NO_BUFFER);","target":0,"flaw_line_index":0,"hash":"ea6cdef3-1147-464a-884a-12f0a85d45c4","idx":"1c975f5a-0955-4d2a-a298-6705847006eb"}
{"func_before":"static int netlink_dump(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct netlink_callback *cb;\n\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tint len, err = -ENOBUFS;\n\tint alloc_min_size;\n\tint alloc_size;\n\n\tmutex_lock(nlk->cb_mutex);\n\t\t__netlink_sendskb(sk, skb);\n\n\tif (cb->done)\n\t\tcb->done(cb);\n\n\tnlk->cb_running = false;\n\tmutex_unlock(nlk->cb_mutex);\n\tmodule_put(cb->module);\n\tconsume_skb(cb->skb);\n\treturn 0;\n\nerrout_skb:\n\tmutex_unlock(nlk->cb_mutex);\n\tkfree_skb(skb);","target":1,"flaw_line_index":0,"hash":"831209f0-e5d3-4f72-ba00-9f6e0ca9e002","idx":"4ac07d0e-faa5-49d0-9b01-b0a4f50d4efc"}
{"func_before":"{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct netlink_callback *cb;\n\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tstruct module *module;\n\tint len, err = -ENOBUFS;\n\tint alloc_min_size;\n\tint alloc_size;\n\n\tmutex_lock(nlk->cb_mutex);\n\n\tif (cb->done)\n\t\tcb->done(cb);\n\n\tnlk->cb_running = false;\n\tmodule = cb->module;\n\tskb = cb->skb;\n\tmutex_unlock(nlk->cb_mutex);\n\tmodule_put(module);\n\tconsume_skb(skb);\n\treturn 0;\n\nerrout_skb:\n\tmutex_unlock(nlk->cb_mutex);\n\tkfree_skb(skb);","target":0,"flaw_line_index":0,"hash":"26623560-8315-47ad-8cad-87eafe044731","idx":"78eab141-8fc0-4e94-91e7-4e9a4adda733"}
{"func_before":"void md_map_sh256(uint8_t *hash, const uint8_t *msg, int len) {\n\tSHA256Context ctx;\n\n\tif (SHA256Reset(&ctx) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;","target":1,"flaw_line_index":0,"hash":"0dc58bba-1a4f-47bd-ac6c-f9eae0090bd8","idx":"d7b8dad7-3df6-4776-96e6-f6141ca97fcf"}
{"func_before":"void md_map_sh256(uint8_t *hash, const uint8_t *msg, size_t len) {\n\tSHA256Context ctx;\n\n\tif (SHA256Reset(&ctx) != shaSuccess) {\n\t\tRLC_THROW(ERR_NO_VALID);\n\t\treturn;","target":0,"flaw_line_index":0,"hash":"f095f6ac-13f8-4936-baca-1275a48f8bda","idx":"bb0c543e-a4c9-4ba0-bc8d-ef14b290efd1"}
{"func_before":"\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (int i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = *pc >= 0x20 ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}","target":1,"flaw_line_index":0,"hash":"0e32e489-695e-4187-9bf2-c98cc945c45b","idx":"b9029eea-ece5-4f67-877e-9fcc773eaabb"}
{"func_before":"\n\tINPUT_RECORD* p = pir;\n\tLPCWSTR pc = asRet;\n\tfor (int i = 0; i < nLen; i++, p++, pc++)\n\t{\n\t\tconst char ch = (*pc == 0x1B || *pc >= 0x20) ? *pc : L' ';\n\t\tp->EventType = KEY_EVENT;\n\t\tp->Event.KeyEvent.bKeyDown = TRUE;\n\t\tp->Event.KeyEvent.wRepeatCount = 1;\n\t\tp->Event.KeyEvent.uChar.UnicodeChar = ch;\n\t}","target":0,"flaw_line_index":0,"hash":"4eaf2b3d-8cb7-4ed4-b9a7-9df3278d09e4","idx":"86fb7478-560a-49fb-8b0b-b26a63e8bcf8"}
{"func_before":"\t\t\tReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tLocal<Value> val_handle,\n\t\t\tMaybeLocal<Object> maybe_options\n\t\t) :\n\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n\t\t\t\tval{TransferOut(val_handle, TransferOptions{maybe_options})},\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference} {\n\t\t\tthat.CheckDisposed();\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}","target":1,"flaw_line_index":0,"hash":"7b6a433b-7d99-426d-aea5-e33d178e66ba","idx":"e4c4975a-5499-4d2c-81e8-32824347777f"}
{"func_before":"\t\t\tReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tLocal<Value> val_handle,\n\t\t\tMaybeLocal<Object> maybe_options\n\t\t) :\n\t\tAccessorRunner{that, key_handle},\n\t\tval{TransferOut(val_handle, TransferOptions{maybe_options})} {}","target":0,"flaw_line_index":0,"hash":"5ff370e5-1454-47d5-997c-3362b944b562","idx":"4f522af2-cdad-4bc4-8136-8675de5f5dde"}
{"func_before":"int fit_image_verify(const void *fit, int image_noffset)\n{\n\tconst void\t*data;\n\tsize_t\t\tsize;\n\tint\t\tnoffset = 0;\n\tchar\t\t*err_msg = \"\";\n\n\t\/* Get image data and data length *\/\n\tif (fit_image_get_data_and_size(fit, image_noffset, &data, &size)) {\n\t\terr_msg = \"Can't get image data\/size\";\n\t\tprintf(\"error!\\n%s for '%s' hash node in '%s' image node\\n\",\n\t\t       err_msg, fit_get_name(fit, noffset, NULL),\n\t\t       fit_get_name(fit, image_noffset, NULL));\n\t\treturn 0;\n\t}\n\n\treturn fit_image_verify_with_data(fit, image_noffset, data, size);\n}","target":1,"flaw_line_index":0,"hash":"bebdc013-56b3-4598-8048-f8d69bf87277","idx":"2286aa4e-c827-431c-95e4-5232217f8ed0"}
{"func_before":"int fit_image_verify(const void *fit, int image_noffset)\n{\n\tconst char *name = fit_get_name(fit, image_noffset, NULL);\n\tconst void\t*data;\n\tsize_t\t\tsize;\n\tchar\t\t*err_msg = \"\";\n\n\tif (strchr(name, '@')) {\n\t\t\/*\n\t\t * We don't support this since libfdt considers names with the\n\t\t * name root but different @ suffix to be equal\n\t\t *\/\n\t\terr_msg = \"Node name contains @\";\n\t\tgoto err;\n\t}\n\t\/* Get image data and data length *\/\n\tif (fit_image_get_data_and_size(fit, image_noffset, &data, &size)) {\n\t\terr_msg = \"Can't get image data\/size\";\n\t\tgoto err;\n\t}\n\n\treturn fit_image_verify_with_data(fit, image_noffset, data, size);\n\nerr:\n\tprintf(\"error!\\n%s in '%s' image node\\n\", err_msg,\n\t       fit_get_name(fit, image_noffset, NULL));\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"49869a1a-14af-4f03-bbdf-ceb7fe674a44","idx":"89d2699d-e252-4970-a22c-eabd2f1671e8"}
{"func_before":"static void i8042_stop(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\tport->exists = false;\n\n\t\/*\n\t * We synchronize with both AUX and KBD IRQs because there is\n\t * a (very unlikely) chance that AUX IRQ is raised for KBD port\n\t * and vice versa.\n\t *\/\n\tsynchronize_irq(I8042_AUX_IRQ);\n\tsynchronize_irq(I8042_KBD_IRQ);\n\tport->serio = NULL;\n}","target":1,"flaw_line_index":0,"hash":"b566edba-2848-4f63-a03b-ba478dd4c49e","idx":"9aa2b250-a313-4938-b560-936c2f0cd59d"}
{"func_before":"static void i8042_stop(struct serio *serio)\n{\n\tstruct i8042_port *port = serio->port_data;\n\n\tspin_lock_irq(&i8042_lock);\n\tport->exists = false;\n\tport->serio = NULL;\n\tspin_unlock_irq(&i8042_lock);\n\n\t\/*\n\t * We need to make sure that interrupt handler finishes using\n\t * our serio port before we return from this function.\n\t * We synchronize with both AUX and KBD IRQs because there is\n\t * a (very unlikely) chance that AUX IRQ is raised for KBD port\n\t * and vice versa.\n\t *\/\n\tsynchronize_irq(I8042_AUX_IRQ);\n\tsynchronize_irq(I8042_KBD_IRQ);\n}","target":0,"flaw_line_index":0,"hash":"2ca46e62-8f6f-483c-b5ce-a5b78044ca4b","idx":"88dba5a5-3a7a-40a2-9727-b978f9ce5d24"}
{"func_before":"l2tp_call_errors_print(netdissect_options *ndo, const u_char *dat)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tuint16_t val_h, val_l;\n\n\tptr++;\t\t\/* skip \"Reserved\" *\/\n\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"CRCErr=%u \", (val_h<<16) + val_l));\n\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"FrameErr=%u \", (val_h<<16) + val_l));\n\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"HardOver=%u \", (val_h<<16) + val_l));\n\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"BufOver=%u \", (val_h<<16) + val_l));\n\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"Timeout=%u \", (val_h<<16) + val_l));\n\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"AlignErr=%u \", (val_h<<16) + val_l));\n}","target":1,"flaw_line_index":0,"hash":"8a3fd672-fdad-4e00-ae1e-8e2204effa74","idx":"58ffb048-2b80-4608-9bec-113f306d43fb"}
{"func_before":"l2tp_call_errors_print(netdissect_options *ndo, const u_char *dat, u_int length)\n{\n\tconst uint16_t *ptr = (const uint16_t *)dat;\n\tuint16_t val_h, val_l;\n\n\tif (length < 2) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tptr++;\t\t\/* skip \"Reserved\" *\/\n\tlength -= 2;\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tND_PRINT((ndo, \"CRCErr=%u \", (val_h<<16) + val_l));\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tND_PRINT((ndo, \"FrameErr=%u \", (val_h<<16) + val_l));\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tND_PRINT((ndo, \"HardOver=%u \", (val_h<<16) + val_l));\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tND_PRINT((ndo, \"BufOver=%u \", (val_h<<16) + val_l));\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tval_h = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tval_l = EXTRACT_16BITS(ptr); ptr++; length -= 2;\n\tND_PRINT((ndo, \"Timeout=%u \", (val_h<<16) + val_l));\n\n\tif (length < 4) {\n\t\tND_PRINT((ndo, \"AVP too short\"));\n\t\treturn;\n\t}\n\tval_h = EXTRACT_16BITS(ptr); ptr++;\n\tval_l = EXTRACT_16BITS(ptr); ptr++;\n\tND_PRINT((ndo, \"AlignErr=%u \", (val_h<<16) + val_l));\n}","target":0,"flaw_line_index":0,"hash":"1b7d936c-c719-4f6b-aeec-58358f4de464","idx":"3d7669f0-2998-4da6-ad05-6fbcd353e2cb"}
{"func_before":"\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tlen = ndp_msg_payload_maxlen(msg);\n\terr = myrecvfrom6(ndp->sock, msg->buf, &len, 0,\n\t\t\t  &msg->addrto, &msg->ifindex);\n\tif (err) {\n\t\terr(ndp, \"Failed to receive message\");\n\t\tgoto free_msg;\n\t}\n\tdbg(ndp, \"rcvd from: %s, ifindex: %u\",\n\t\t str_in6_addr(&msg->addrto), msg->ifindex);\n\n\tif (len < sizeof(*msg->icmp6_hdr)) {\n\t\twarn(ndp, \"rcvd icmp6 packet too short (%luB)\", len);\n\t\terr = 0;\n\t\tgoto free_msg;","target":1,"flaw_line_index":0,"hash":"7cfa832d-32fa-4cbd-ac88-e2052fd49e95","idx":"5482343a-a005-4355-b996-fa1c9e130ea3"}
{"func_before":"\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tlen = ndp_msg_payload_maxlen(msg);\n\terr = myrecvfrom6(ndp->sock, msg->buf, &len, 0,\n\t\t\t  &msg->addrto, &msg->ifindex, &msg->hoplimit);\n\tif (err) {\n\t\terr(ndp, \"Failed to receive message\");\n\t\tgoto free_msg;\n\t}\n\tdbg(ndp, \"rcvd from: %s, ifindex: %u, hoplimit: %d\",\n\t\t str_in6_addr(&msg->addrto), msg->ifindex, msg->hoplimit);\n\n\tif (msg->hoplimit != 255) {\n\t\twarn(ndp, \"ignoring packet with bad hop limit (%d)\", msg->hoplimit);\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\n\tif (len < sizeof(*msg->icmp6_hdr)) {\n\t\twarn(ndp, \"rcvd icmp6 packet too short (%luB)\", len);\n\t\terr = 0;\n\t\tgoto free_msg;","target":0,"flaw_line_index":0,"hash":"f40b8187-bcf2-407a-bd74-b568e068e83a","idx":"55e8c310-5248-40a1-8021-f68f9b3fe09e"}
{"func_before":"static PyObject *__pyx_f_17clickhouse_driver_14bufferedwriter_14BufferedWriter_write(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter *__pyx_v_self, PyObject *__pyx_v_data, int __pyx_skip_dispatch) {\n  Py_ssize_t __pyx_v_written;\n  Py_ssize_t __pyx_v_size;\n  Py_ssize_t __pyx_v_data_len;\n  char *__pyx_v_c_data;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  Py_ssize_t __pyx_t_5;\n  char *__pyx_t_6;\n  int __pyx_t_7;\n  Py_ssize_t __pyx_t_8;\n  Py_ssize_t __pyx_t_9;\n  __Pyx_RefNannySetupContext(\"write\", 0);\n  \/* Check if called by wrapper *\/\n  if (unlikely(__pyx_skip_dispatch)) ;\n  \/* Check if overridden in Python *\/\n  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {\n  }\n\n  \/* \"clickhouse_driver\/bufferedwriter.pyx\":29\n * \n *     cpdef write(self, data):\n *         cdef Py_ssize_t written = 0             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t to_write, size\n *         cdef Py_ssize_t data_len = len(data)\n *\/\n  __pyx_v_written = 0;\n\n  \/* \"clickhouse_driver\/bufferedwriter.pyx\":31\n *         cdef Py_ssize_t written = 0\n *         cdef Py_ssize_t to_write, size\n *         cdef Py_ssize_t data_len = len(data)             # <<<<<<<<<<<<<<\n *         cdef char* c_data\n * \n *\/\n  __pyx_t_5 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(0, 31, __pyx_L1_error)\n  __pyx_v_data_len = __pyx_t_5;\n *         while written < data_len:\n *             size = min(data_len - written, self.buffer_size - self.position)             # <<<<<<<<<<<<<<\n *             memcpy(&self.buffer[self.position], &c_data[written], size)\n * \n *\/\n    __pyx_t_5 = (__pyx_v_self->buffer_size - __pyx_v_self->position);\n    __pyx_t_8 = (__pyx_v_data_len - __pyx_v_written);\n    if (((__pyx_t_5 < __pyx_t_8) != 0)) {\n      __pyx_t_9 = __pyx_t_5;\n    } else {\n      __pyx_t_9 = __pyx_t_8;\n    }\n    __pyx_v_size = __pyx_t_9;\n\n    \/* \"clickhouse_driver\/bufferedwriter.pyx\":38\n *         while written < data_len:\n *             size = min(data_len - written, self.buffer_size - self.position)\n *             memcpy(&self.buffer[self.position], &c_data[written], size)             # <<<<<<<<<<<<<<\n\n  \/* \"clickhouse_driver\/bufferedwriter.pyx\":28\n *         raise NotImplementedError\n * \n *     cpdef write(self, data):             # <<<<<<<<<<<<<<\n *         cdef Py_ssize_t written = 0\n *         cdef Py_ssize_t to_write, size\n *\/\n\n  \/* function exit code *\/\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;","target":1,"flaw_line_index":0,"hash":"0e2c9a91-84ff-4c12-92c7-bed7d601fb19","idx":"374cf75c-33b8-4523-9927-c1582a3add87"}
{"func_before":"static PyObject *__pyx_f_17clickhouse_driver_14bufferedwriter_14BufferedWriter_write(struct __pyx_obj_17clickhouse_driver_14bufferedwriter_BufferedWriter *__pyx_v_self, PyObject *__pyx_v_data, int __pyx_skip_dispatch) {\n  unsigned PY_LONG_LONG __pyx_v_written;\n  unsigned PY_LONG_LONG __pyx_v_size;\n  unsigned PY_LONG_LONG __pyx_v_data_len;\n  char *__pyx_v_c_data;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  PyObject *__pyx_t_4 = NULL;\n  Py_ssize_t __pyx_t_5;\n  char *__pyx_t_6;\n  int __pyx_t_7;\n  unsigned PY_LONG_LONG __pyx_t_8;\n  unsigned PY_LONG_LONG __pyx_t_9;\n  unsigned PY_LONG_LONG __pyx_t_10;\n  int __pyx_lineno = 0;\n  const char *__pyx_filename = NULL;\n  int __pyx_clineno = 0;\n  __Pyx_RefNannySetupContext(\"write\", 0);\n  \/* Check if called by wrapper *\/\n  if (unlikely(__pyx_skip_dispatch)) ;\n  \/* Check if overridden in Python *\/\n  else if (unlikely((Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0) || (Py_TYPE(((PyObject *)__pyx_v_self))->tp_flags & (Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_HEAPTYPE)))) {\n  }\n\n  \/* \"clickhouse_driver\/bufferedwriter.pyx\":29\n * \n *     cpdef write(self, data):\n *         cdef unsigned long long written = 0             # <<<<<<<<<<<<<<\n *         cdef unsigned long long to_write, size\n *         cdef unsigned long long data_len = len(data)\n *\/\n  __pyx_v_written = 0;\n\n  \/* \"clickhouse_driver\/bufferedwriter.pyx\":31\n *         cdef unsigned long long written = 0\n *         cdef unsigned long long to_write, size\n *         cdef unsigned long long data_len = len(data)             # <<<<<<<<<<<<<<\n *         cdef char* c_data\n * \n *\/\n  __pyx_t_5 = PyObject_Length(__pyx_v_data); if (unlikely(__pyx_t_5 == ((Py_ssize_t)-1))) __PYX_ERR(0, 31, __pyx_L1_error)\n  __pyx_v_data_len = __pyx_t_5;\n *         while written < data_len:\n *             size = min(data_len - written, self.buffer_size - self.position)             # <<<<<<<<<<<<<<\n *             memcpy(&self.buffer[self.position], &c_data[written], size)\n * \n *\/\n    __pyx_t_8 = (__pyx_v_self->buffer_size - __pyx_v_self->position);\n    __pyx_t_9 = (__pyx_v_data_len - __pyx_v_written);\n    if (((__pyx_t_8 < __pyx_t_9) != 0)) {\n      __pyx_t_10 = __pyx_t_8;\n    } else {\n      __pyx_t_10 = __pyx_t_9;\n    }\n    __pyx_v_size = __pyx_t_10;\n\n    \/* \"clickhouse_driver\/bufferedwriter.pyx\":38\n *         while written < data_len:\n *             size = min(data_len - written, self.buffer_size - self.position)\n *             memcpy(&self.buffer[self.position], &c_data[written], size)             # <<<<<<<<<<<<<<\n\n  \/* \"clickhouse_driver\/bufferedwriter.pyx\":28\n *         raise NotImplementedError\n * \n *     cpdef write(self, data):             # <<<<<<<<<<<<<<\n *         cdef unsigned long long written = 0\n *         cdef unsigned long long to_write, size\n *\/\n\n  \/* function exit code *\/\n  __pyx_r = Py_None; __Pyx_INCREF(Py_None);\n  goto __pyx_L0;","target":0,"flaw_line_index":0,"hash":"0155ff40-f1c7-4ccb-96d8-70ff4f096f87","idx":"44cdc02a-f4c9-40a6-b087-81130fb05609"}
{"func_before":"static void __exit ipgre_fini(void)\n{\n\trtnl_link_unregister(&ipgre_tap_ops);\n\trtnl_link_unregister(&ipgre_link_ops);\n\tunregister_pernet_device(&ipgre_net_ops);\n\tif (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)\n\t\tprintk(KERN_INFO \"ipgre close: can't remove protocol\\n\");\n}","target":1,"flaw_line_index":0,"hash":"2b1d4229-e53d-4c9f-8a32-b565a2cad2e0","idx":"0bb8321b-3b16-493c-b725-da652ecdf311"}
{"func_before":"static void __exit ipgre_fini(void)\n{\n\trtnl_link_unregister(&ipgre_tap_ops);\n\trtnl_link_unregister(&ipgre_link_ops);\n\tif (inet_del_protocol(&ipgre_protocol, IPPROTO_GRE) < 0)\n\t\tprintk(KERN_INFO \"ipgre close: can't remove protocol\\n\");\n\tunregister_pernet_device(&ipgre_net_ops);\n}","target":0,"flaw_line_index":0,"hash":"2f8da18c-57b8-46aa-9c0b-1116a003f57f","idx":"12859024-76ee-4cd3-852d-6ed05dbc4675"}
{"func_before":"    static const char rx_str[] = \"([^\/]*)\/(.*)\";\n    static const regex rx(rx_str, sizeof(rx_str) - 1,\n\t\t\t  ECMAScript | optimize);\n    smatch match;\n    if (regex_match(a->resource, match, rx)) {\n      ceph_assert(match.size() == 3);\n\n      if (match[1] == \"user\") {\n\treturn Principal::user(std::move(a->account),\n\t\t\t       match[2]);\n      }","target":1,"flaw_line_index":0,"hash":"62fbcbfe-7f14-4dc0-b6de-4fbc79e63f06","idx":"c488fc18-ba88-4e5a-af68-6e3e546842f7"}
{"func_before":"    static const char rx_str[] = \"([^\/]*)\/(.*)\";\n    static const regex rx(rx_str, sizeof(rx_str) - 1,\n\t\t\t  ECMAScript | optimize);\n    smatch match;\n    if (regex_match(a->resource, match, rx)) {\n      if (match.size() != 3) {\n\treturn boost::none;\n      }\n\n      if (match[1] == \"user\") {\n\treturn Principal::user(std::move(a->account),\n\t\t\t       match[2]);\n      }","target":0,"flaw_line_index":0,"hash":"aea30876-f51b-4728-aa25-34cbbe95f665","idx":"9780dcc2-8fee-4639-8256-30420abaefd2"}
{"func_before":"static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tsnprintf(rblkcipher.type, CRYPTO_MAX_ALG_NAME, \"%s\", \"blkcipher\");\n\tsnprintf(rblkcipher.geniv, CRYPTO_MAX_ALG_NAME, \"%s\",\n\t\t alg->cra_blkcipher.geniv ?: \"<default>\");\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_blkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_blkcipher.ivsize;","target":1,"flaw_line_index":0,"hash":"1f4f2cb5-e647-4441-bea1-fb451534f93d","idx":"4d6856e2-8b3f-4110-81c8-78ab88f22220"}
{"func_before":"static int crypto_blkcipher_report(struct sk_buff *skb, struct crypto_alg *alg)\n{\n\tstruct crypto_report_blkcipher rblkcipher;\n\n\tstrncpy(rblkcipher.type, \"blkcipher\", sizeof(rblkcipher.type));\n\tstrncpy(rblkcipher.geniv, alg->cra_blkcipher.geniv ?: \"<default>\",\n\t\tsizeof(rblkcipher.geniv));\n\n\trblkcipher.blocksize = alg->cra_blocksize;\n\trblkcipher.min_keysize = alg->cra_blkcipher.min_keysize;\n\trblkcipher.max_keysize = alg->cra_blkcipher.max_keysize;\n\trblkcipher.ivsize = alg->cra_blkcipher.ivsize;","target":0,"flaw_line_index":0,"hash":"21d50e73-0e3c-4dc7-b34b-3a4e743195db","idx":"55ea701a-5b9d-4eef-94cc-eb78d15b1375"}
{"func_before":"\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n\t\t\t\t\t   &xattr_data,\n\t\t\t\t\t   sizeof(xattr_data), 0);\n\t}\n\telse if (rc == -ENODATA)\n\t\trc = inode->i_op->removexattr(dentry, XATTR_NAME_EVM);\n\treturn rc;\n}","target":1,"flaw_line_index":0,"hash":"80b3a539-b199-404c-b5cf-d25853f7fc59","idx":"92561e21-9ab9-40f7-b910-14e782639365"}
{"func_before":"\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n\t\t\t\t\t   &xattr_data,\n\t\t\t\t\t   sizeof(xattr_data), 0);\n\t} else if (rc == -ENODATA && inode->i_op->removexattr) {\n\t\trc = inode->i_op->removexattr(dentry, XATTR_NAME_EVM);\n\t}\n\treturn rc;\n}","target":0,"flaw_line_index":0,"hash":"a77042d8-90c2-4b3f-81e5-7824c8686361","idx":"aa1f8e39-ada7-4c75-a094-9161e5162783"}
{"func_before":"    free_AS_REP(&rep);\n\n    \/*\n     * In case of a non proxy error, build an error message.\n     *\/\n    if(ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t ret, r->e_text,\n\t\t\t\t r->server_princ,\n\t\t\t\t &r->client_princ->name,\n\t\t\t\t &r->client_princ->realm,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tif (ret)\n\t    goto out2;\n    }","target":1,"flaw_line_index":0,"hash":"88848c5b-6746-4182-a041-fceafee84a42","idx":"9bd91f3f-8e40-4774-9f46-b535b958f2cf"}
{"func_before":"    free_AS_REP(&rep);\n\n    \/*\n     * In case of a non proxy error, build an error message.\n     *\/\n    if (ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply->length == 0) {\n\tret = _kdc_fast_mk_error(context, r,\n\t\t\t\t &error_method,\n\t\t\t\t r->armor_crypto,\n\t\t\t\t &req->req_body,\n\t\t\t\t ret, r->e_text,\n\t\t\t\t r->server_princ,\n\t\t\t\t r->client_princ ?\n                                     &r->client_princ->name : NULL,\n\t\t\t\t r->client_princ ?\n                                     &r->client_princ->realm : NULL,\n\t\t\t\t NULL, NULL,\n\t\t\t\t reply);\n\tif (ret)\n\t    goto out2;\n    }","target":0,"flaw_line_index":0,"hash":"3360a148-0ea0-4664-9b43-f94e0032a29b","idx":"47c20520-2abf-4105-9a91-40b383af5555"}
{"func_before":"\t * information stored in the driver.\n\t * These commands should never time out and are unaffected\n\t * by TM and FW reloads.\n\t *\/\n\tif ((cmd & ~IOCSIZE_MASK) == (MPTIOCINFO & ~IOCSIZE_MASK)) {\n\t\treturn mptctl_getiocinfo(arg, _IOC_SIZE(cmd));\n\t} else if (cmd == MPTTARGETINFO) {\n\t\treturn mptctl_gettargetinfo(arg);\n\t} else if (cmd == MPTTEST) {\n\t\treturn mptctl_readtest(arg);\n\t} else if (cmd == MPTEVENTQUERY) {\n\t\treturn mptctl_eventquery(arg);\n\t} else if (cmd == MPTEVENTENABLE) {\n\t\treturn mptctl_eventenable(arg);\n\t} else if (cmd == MPTEVENTREPORT) {\n\t\treturn mptctl_eventreport(arg);\n\t} else if (cmd == MPTFWREPLACE) {\n\t\treturn mptctl_replace_fw(arg);\n\t}\n\n\t\/* All of these commands require an interrupt or\n\t * are unknown\/illegal.\n\t *\/\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\n\tif (cmd == MPTFWDOWNLOAD)\n\t\tret = mptctl_fw_download(arg);\n\telse if (cmd == MPTCOMMAND)\n\t\tret = mptctl_mpt_command(arg);\n\telse if (cmd == MPTHARDRESET)\n\t\tret = mptctl_do_reset(arg);\n\telse if ((cmd & ~IOCSIZE_MASK) == (HP_GETHOSTINFO & ~IOCSIZE_MASK))\n\t\tret = mptctl_hp_hostinfo(arg, _IOC_SIZE(cmd));\n\telse if (cmd == HP_GETTARGETINFO)\n\t\tret = mptctl_hp_targetinfo(arg);\n\telse\n\t\tret = -EINVAL;\n\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n","target":1,"flaw_line_index":0,"hash":"7121476a-b05e-4a23-9275-e86cca35cdb1","idx":"f5b55275-8df8-4e51-be20-aa9314ed426e"}
{"func_before":"\t * information stored in the driver.\n\t * These commands should never time out and are unaffected\n\t * by TM and FW reloads.\n\t *\/\n\tif ((cmd & ~IOCSIZE_MASK) == (MPTIOCINFO & ~IOCSIZE_MASK)) {\n\t\treturn mptctl_getiocinfo(iocp, arg, _IOC_SIZE(cmd));\n\t} else if (cmd == MPTTARGETINFO) {\n\t\treturn mptctl_gettargetinfo(iocp, arg);\n\t} else if (cmd == MPTTEST) {\n\t\treturn mptctl_readtest(iocp, arg);\n\t} else if (cmd == MPTEVENTQUERY) {\n\t\treturn mptctl_eventquery(iocp, arg);\n\t} else if (cmd == MPTEVENTENABLE) {\n\t\treturn mptctl_eventenable(iocp, arg);\n\t} else if (cmd == MPTEVENTREPORT) {\n\t\treturn mptctl_eventreport(iocp, arg);\n\t} else if (cmd == MPTFWREPLACE) {\n\t\treturn mptctl_replace_fw(iocp, arg);\n\t}\n\n\t\/* All of these commands require an interrupt or\n\t * are unknown\/illegal.\n\t *\/\n\tif ((ret = mptctl_syscall_down(iocp, nonblock)) != 0)\n\t\treturn ret;\n\n\tif (cmd == MPTFWDOWNLOAD)\n\t\tret = mptctl_fw_download(iocp, arg);\n\telse if (cmd == MPTCOMMAND)\n\t\tret = mptctl_mpt_command(iocp, arg);\n\telse if (cmd == MPTHARDRESET)\n\t\tret = mptctl_do_reset(iocp, arg);\n\telse if ((cmd & ~IOCSIZE_MASK) == (HP_GETHOSTINFO & ~IOCSIZE_MASK))\n\t\tret = mptctl_hp_hostinfo(iocp, arg, _IOC_SIZE(cmd));\n\telse if (cmd == HP_GETTARGETINFO)\n\t\tret = mptctl_hp_targetinfo(iocp, arg);\n\telse\n\t\tret = -EINVAL;\n\n\tmutex_unlock(&iocp->ioctl_cmds.mutex);\n","target":0,"flaw_line_index":0,"hash":"a308fc00-9848-44f2-8d0d-634954289fbe","idx":"513320c4-b835-401c-b5cd-c346a2309d10"}
{"func_before":"print_arrays_for(char *set)\n{\n  FILE *f;\n\n  sprintf(buf, \"%s.conf\", set);\n\n  if ((f = fopen(buf, \"r\")) == NULL) {\n    fprintf(stderr, \"%s: can't read conf file for charset %s\\n\", prog, set);\n    exit(EXIT_FAILURE);\n  }","target":1,"flaw_line_index":0,"hash":"b3e862a4-157b-4cfc-ae3c-553abd2c61a8","idx":"fecb65bf-bb96-44e3-8e98-070973d1371f"}
{"func_before":"print_arrays_for(char *set)\n{\n  FILE *f;\n\n  snprintf(buf, sizeof(buf), \"%s.conf\", set);\n\n  if ((f = fopen(buf, \"r\")) == NULL) {\n    fprintf(stderr, \"%s: can't read conf file for charset %s\\n\", prog, set);\n    exit(EXIT_FAILURE);\n  }","target":0,"flaw_line_index":0,"hash":"512e4f93-dbf0-4cfa-b5e9-becaa3293b5c","idx":"44d47d76-6fa0-4c2a-a750-fa43fec25a5f"}
{"func_before":"      explicit JpegOutput( String const& filename ) {\n         \/\/ Open the file for writing\n         if( FileHasExtension( filename )) {\n            outfile_ = std::fopen(filename.c_str(), \"wb\");\n         } else {\n            outfile_ = std::fopen( FileAddExtension( filename, \"jpg\" ).c_str(), \"wb\" );\n            DIP_THROW_RUNTIME( \"Could not open file for writing\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         if( setjmp( jerr_.setjmp_buffer )) {\n            \/\/ If we get here, the JPEG code has signaled an error.\n            DIP_THROW_RUNTIME( \"Error writing JPEG file.\" );\n         }\n         jpeg_create_compress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_dest( &cinfo_, outfile_ );\n      }","target":1,"flaw_line_index":0,"hash":"e91df1b0-43ef-4234-b3ea-25e2de9fd314","idx":"c0775cae-76b8-4dd0-ae98-b64729c038dd"}
{"func_before":"      explicit JpegOutput( String const& filename, std::jmp_buf const& setjmp_buffer ) {\n         \/\/ Open the file for writing\n         if( FileHasExtension( filename )) {\n            outfile_ = std::fopen(filename.c_str(), \"wb\");\n         } else {\n            outfile_ = std::fopen( FileAddExtension( filename, \"jpg\" ).c_str(), \"wb\" );\n            DIP_THROW_RUNTIME( \"Could not open file for writing\" );\n         }\n         cinfo_.err = jpeg_std_error( &jerr_.pub );\n         jerr_.pub.error_exit = my_error_exit;\n         jerr_.pub.output_message = my_output_message;\n         std::memcpy( jerr_.setjmp_buffer, setjmp_buffer, sizeof( setjmp_buffer ));\n         jpeg_create_compress( &cinfo_ );\n         initialized_ = true;\n         jpeg_stdio_dest( &cinfo_, outfile_ );\n      }","target":0,"flaw_line_index":0,"hash":"1b738ccc-4382-42a9-a2bf-2c3671c1b9b2","idx":"59108187-1b6e-4e6f-b13d-89cfeb46ba83"}
{"func_before":"\tretval = TRUE;\n\n    \/\/ CTRL-E means completion is Ended, go back to the typed text.\n    \/\/ but only do this, if the Popup is still visible\n    if (c == Ctrl_E)\n    {\n\tins_compl_delete();\n\tif (compl_leader != NULL)\n\t    ins_bytes(compl_leader + get_compl_len());\n\telse if (compl_first_match != NULL)\n\t    ins_bytes(compl_orig_text + get_compl_len());\n\tretval = TRUE;\n    }\n\n    auto_format(FALSE, TRUE);\n","target":1,"flaw_line_index":0,"hash":"ba6eb56b-d1b8-4678-95a5-b4316a924405","idx":"571d7255-b0c2-440d-be76-8ecf5adb5cd9"}
{"func_before":"\n    \/\/ CTRL-E means completion is Ended, go back to the typed text.\n    \/\/ but only do this, if the Popup is still visible\n    if (c == Ctrl_E)\n    {\n\tchar_u *p = NULL;\n\n\tins_compl_delete();\n\tif (compl_leader != NULL)\n\t    p = compl_leader;\n\telse if (compl_first_match != NULL)\n\t    p = compl_orig_text;\n\tif (p != NULL)\n\t{\n\t    int\t    compl_len = get_compl_len();\n\t    int\t    len = (int)STRLEN(p);\n\n\t    if (len > compl_len)\n\t\tins_bytes_len(p + compl_len, len - compl_len);\n\t}\n\tretval = TRUE;\n    }\n\n    auto_format(FALSE, TRUE);\n","target":0,"flaw_line_index":0,"hash":"9ccbf22d-9dfc-49da-a2b4-41ee3ba41b49","idx":"e2a84139-3679-45b1-8dbb-86fa9bad32c6"}
{"func_before":"\t}\n\n\tASSERT(blkno == 0);\n\terror = xfs_attr3_leaf_create(args, blkno, &bp);\n\tif (error) {\n\t\terror = xfs_da_shrink_inode(args, 0, bp);\n\t\tbp = NULL;\n\t\tif (error)\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t\/* try to put *\/\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t\/* it back *\/\n\t\tgoto out;\n\t}","target":1,"flaw_line_index":0,"hash":"cbc58e11-7be5-48b7-9f7a-1b387a802711","idx":"743cafbb-9ed8-4042-98bb-89b56031475a"}
{"func_before":"\t}\n\n\tASSERT(blkno == 0);\n\terror = xfs_attr3_leaf_create(args, blkno, &bp);\n\tif (error) {\n\t\t\/* xfs_attr3_leaf_create may not have instantiated a block *\/\n\t\tif (bp && (xfs_da_shrink_inode(args, 0, bp) != 0))\n\t\t\tgoto out;\n\t\txfs_idata_realloc(dp, size, XFS_ATTR_FORK);\t\/* try to put *\/\n\t\tmemcpy(ifp->if_u1.if_data, tmpbuffer, size);\t\/* it back *\/\n\t\tgoto out;\n\t}","target":0,"flaw_line_index":0,"hash":"c4744919-a745-4ac8-a0c2-d6f71b29b611","idx":"caed6a53-a218-4b92-a76a-73abba3a2874"}
{"func_before":"For(expr_ty target, expr_ty iter, asdl_seq * body, asdl_seq * orelse, int\n    lineno, int col_offset, int end_lineno, int end_col_offset, PyArena *arena)\n{\n    stmt_ty p;\n    if (!target) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field target is required for For\");\n        return NULL;\n    p->kind = For_kind;\n    p->v.For.target = target;\n    p->v.For.iter = iter;\n    p->v.For.body = body;\n    p->v.For.orelse = orelse;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;","target":1,"flaw_line_index":0,"hash":"60647add-f2ef-4468-81fa-d7ab74e34ba3","idx":"3be33126-b209-4725-b6d4-9eeaa3158b33"}
{"func_before":"For(expr_ty target, expr_ty iter, asdl_seq * body, asdl_seq * orelse, string\n    type_comment, int lineno, int col_offset, int end_lineno, int\n    end_col_offset, PyArena *arena)\n{\n    stmt_ty p;\n    if (!target) {\n        PyErr_SetString(PyExc_ValueError,\n                        \"field target is required for For\");\n    p->kind = For_kind;\n    p->v.For.target = target;\n    p->v.For.iter = iter;\n    p->v.For.body = body;\n    p->v.For.orelse = orelse;\n    p->v.For.type_comment = type_comment;\n    p->lineno = lineno;\n    p->col_offset = col_offset;\n    p->end_lineno = end_lineno;\n    p->end_col_offset = end_col_offset;\n    return p;","target":0,"flaw_line_index":0,"hash":"0716a228-f394-4290-b9dc-f7e531437c2d","idx":"c93cb774-199c-4feb-9b2a-d7b8155a2924"}
{"func_before":"void fp8_write_bin(uint8_t *bin, int len, const fp8_t a) {\n\tif (len != 8 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp4_write_bin(bin, 4 * RLC_FP_BYTES, a[0]);","target":1,"flaw_line_index":0,"hash":"a27aa3f6-c9a7-4a9f-b782-a4e1916e5102","idx":"0a8bf4f8-f50d-4e5e-9f93-24cb50a4f1a0"}
{"func_before":"void fp8_write_bin(uint8_t *bin, size_t len, const fp8_t a) {\n\tif (len != 8 * RLC_FP_BYTES) {\n\t\tRLC_THROW(ERR_NO_BUFFER);\n\t\treturn;\n\t}\n\tfp4_write_bin(bin, 4 * RLC_FP_BYTES, a[0]);","target":0,"flaw_line_index":0,"hash":"0bdcfe25-933c-4c05-a43b-02988d28df08","idx":"b118e447-feca-4489-9be4-f79e0643f649"}
{"func_before":"  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  const TfLiteTensor* input2 = GetInput(context, node, kInputTensor2);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n  output->type = input2->type;\n\n  const bool requires_broadcast = !HaveSameShapes(input1, input2);","target":1,"flaw_line_index":0,"hash":"ca84e8a2-0348-4674-b505-9b762228b1d6","idx":"9b015330-62e9-4714-a480-f482b81a17c1"}
{"func_before":"  OpData* data = reinterpret_cast<OpData*>(node->user_data);\n\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  const TfLiteTensor* input2;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input2->type);\n  output->type = input2->type;\n\n  const bool requires_broadcast = !HaveSameShapes(input1, input2);","target":0,"flaw_line_index":0,"hash":"24e44246-73ed-4097-a834-95817622b56d","idx":"f7cb6b15-e8a9-4f97-bc25-db8fafdddbb7"}
{"func_before":"\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tcrypto_bignum_free(s->d);\n\tcrypto_bignum_free(s->x);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}","target":1,"flaw_line_index":0,"hash":"f46f5ad2-9cea-468f-bc86-4d4515b374b3","idx":"69c30aed-274d-4f9f-b329-e5acae7d63a5"}
{"func_before":"\t\tgoto err;\n\n\treturn TEE_SUCCESS;\n\nerr:\n\tcrypto_bignum_free(&s->d);\n\tcrypto_bignum_free(&s->x);\n\n\treturn TEE_ERROR_OUT_OF_MEMORY;\n}","target":0,"flaw_line_index":0,"hash":"4a54ad68-9c07-4a34-90c5-dbc9a6d5012b","idx":"a60908bd-c0da-4497-b988-4aa3efda80d0"}
{"func_before":"MONGO_EXPORT int bson_append_code_n( bson *b, const char *name, const char *value, int len ) {\n    return bson_append_string_base( b, name, value, len, BSON_CODE );\n}","target":1,"flaw_line_index":0,"hash":"6139b633-f13c-4d64-9c4b-b5d1856251cf","idx":"a3729538-9b99-44b2-8822-b5c49c156710"}
{"func_before":"MONGO_EXPORT int bson_append_code_n( bson *b, const char *name, const char *value, size_t len ) {\n    return bson_append_string_base( b, name, value, len, BSON_CODE );\n}","target":0,"flaw_line_index":0,"hash":"97da60c6-175a-4689-9db9-807e3b062d4d","idx":"64df87f8-cc21-44e4-9edf-64c758b0d581"}
{"func_before":"#ifdef DCRAW_VERBOSE\n  if (verbose)\n    fprintf(stderr, _(\"%d-pass X-Trans interpolation...\\n\"), passes);\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n\/* Check against right pattern *\/\n  for (row = 0; row < 6; row++)\n\t  for (col = 0; col < 6; col++)\n\t\t  cstat[fcol(row,col)]++;\n\n  if(cstat[0] < 6 || cstat[0]>10 || cstat[1]< 16\n    || cstat[1]>24 || cstat[2]< 6 || cstat[2]>10 || cstat[3])\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n  cielab(0, 0);\n  ndir = 4 << (passes > 1);\n  buffer = (char *)malloc(TS * TS * (ndir * 11 + 6));\n  merror(buffer, \"xtrans_interpolate()\");\n  rgb = (ushort(*)[TS][TS][3])buffer;\n  lab = (short(*)[TS][3])(buffer + TS * TS * (ndir * 6));\n  drv = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 6 + 6));\n  homo = (char(*)[TS][TS])(buffer + TS * TS * (ndir * 10 + 6));\n\n  \/* Map a green hexagon around each non-green pixel and vice versa:\t*\/\n  for (row = 0; row < 3; row++)\n    for (col = 0; col < 3; col++)\n      for (ng = d = 0; d < 10; d += 2)\n      {\n        }\n        if (ng == g + 1)\n          FORC(8)\n          {\n            v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];\n            h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];\n            allhex[row][col][0][c ^ (g * 2 & d)] = h + v * width;\n            allhex[row][col][1][c ^ (g * 2 & d)] = h + v * TS;\n          }\n      }\n\n  \/* Set green1 and green3 to the minimum and maximum allowed values:\t*\/\n  for (row = 2; row < height - 2; row++)\n    for (min = ~(max = 0), col = 2; col < width - 2; col++)\n    {\n      if (fcol(row, col) == 1 && (min = ~(max = 0)))\n          col--;\n        }\n        break;\n      case 2:\n        if ((min = ~(max = 0)) && (col += 2) < width - 3 && row > 2)\n          row--;\n      }\n    }\n\n  for (top = 3; top < height - 19; top += TS - 16)\n    for (left = 3; left < width - 19; left += TS - 16)","target":1,"flaw_line_index":0,"hash":"7af54206-ca06-4c9c-8266-960b60663a1c","idx":"d4be4ab1-4499-4133-bdd0-73aa9ed42c06"}
{"func_before":"  if (verbose)\n    fprintf(stderr, _(\"%d-pass X-Trans interpolation...\\n\"), passes);\n#endif\n\n#ifdef LIBRAW_LIBRARY_BUILD\n  if(width < TS || height < TS)\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT; \/\/ too small image\n\/* Check against right pattern *\/\n  for (row = 0; row < 6; row++)\n\t  for (col = 0; col < 6; col++)\n\t\t  cstat[fcol(row,col)]++;\n\n  if(cstat[0] < 6 || cstat[0]>10 || cstat[1]< 16\n    || cstat[1]>24 || cstat[2]< 6 || cstat[2]>10 || cstat[3])\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n\n \/\/ Init allhex table to unreasonable values\n for(int i = 0; i < 3; i++)\n  for(int j = 0; j < 3; j++)\n   for(int k = 0; k < 2; k++)\n    for(int l = 0; l < 8; l++)\n     allhex[i][j][k][l]=32700;\n#endif\n  cielab(0, 0);\n  ndir = 4 << (passes > 1);\n  buffer = (char *)malloc(TS * TS * (ndir * 11 + 6));\n  merror(buffer, \"xtrans_interpolate()\");\n  rgb = (ushort(*)[TS][TS][3])buffer;\n  lab = (short(*)[TS][3])(buffer + TS * TS * (ndir * 6));\n  drv = (float(*)[TS][TS])(buffer + TS * TS * (ndir * 6 + 6));\n  homo = (char(*)[TS][TS])(buffer + TS * TS * (ndir * 10 + 6));\n\n  int minv=0,maxv=0,minh=0,maxh=0;\n  \/* Map a green hexagon around each non-green pixel and vice versa:\t*\/\n  for (row = 0; row < 3; row++)\n    for (col = 0; col < 3; col++)\n      for (ng = d = 0; d < 10; d += 2)\n      {\n        if (ng == g + 1)\n          FORC(8)\n          {\n            v = orth[d] * patt[g][c * 2] + orth[d + 1] * patt[g][c * 2 + 1];\n            h = orth[d + 2] * patt[g][c * 2] + orth[d + 3] * patt[g][c * 2 + 1];\n\t    minv=MIN(v,minv);\n\t    maxv=MAX(v,maxv);\n\t    minh=MIN(v,minh);\n   \t    maxh=MAX(v,maxh);\n            allhex[row][col][0][c ^ (g * 2 & d)] = h + v * width;\n            allhex[row][col][1][c ^ (g * 2 & d)] = h + v * TS;\n          }\n      }\n\n#ifdef LIBRAW_LIBRARY_BUILD\n   \/\/ Check allhex table initialization\n  for(int i = 0; i < 3; i++)\n    for(int j = 0; j < 3; j++)\n      for(int k = 0; k < 2; k++)\n        for(int l = 0; l < 8; l++)\n\t  if(allhex[i][j][k][l]>maxh+maxv*width+1 || allhex[i][j][k][l]<minh+minv*width-1)\n\t  throw LIBRAW_EXCEPTION_IO_CORRUPT;\n  int retrycount = 0;\n#endif\n  \/* Set green1 and green3 to the minimum and maximum allowed values:\t*\/\n  for (row = 2; row < height - 2; row++)\n    for (min = ~(max = 0), col = 2; col < width - 2; col++)\n    {\n      if (fcol(row, col) == 1 && (min = ~(max = 0)))\n          col--;\n        }\n        break;\n      case 2:\n        if ((min = ~(max = 0)) && (col += 2) < width - 3 && row > 2)\n\t{\n           row--;\n#ifdef LIBRAW_LIBRARY_BUILD\n\t  if(retrycount++ > width*height)\n\t  \tthrow LIBRAW_EXCEPTION_IO_CORRUPT;\n#endif\n\t}\n      }\n    }\n\n  for (top = 3; top < height - 19; top += TS - 16)\n    for (left = 3; left < width - 19; left += TS - 16)","target":0,"flaw_line_index":0,"hash":"7a2ffc28-fdb3-494a-b605-88283013c480","idx":"de815e1d-62ca-4945-b86e-6b9258898fda"}
{"func_before":"ast2obj_withitem(void* _o)\n{\n    withitem_ty o = (withitem_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_INCREF(Py_None);\n        return Py_None;\n    }\n\n    result = PyType_GenericNew(withitem_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_expr(o->context_expr);","target":1,"flaw_line_index":0,"hash":"ea16cf2a-64f6-4cd1-9d4e-e9291faccc19","idx":"a73beff3-48a3-449c-9b43-8d614ccf29a2"}
{"func_before":"ast2obj_withitem(void* _o)\n{\n    withitem_ty o = (withitem_ty)_o;\n    PyObject *result = NULL, *value = NULL;\n    if (!o) {\n        Py_RETURN_NONE;\n    }\n\n    result = PyType_GenericNew(withitem_type, NULL, NULL);\n    if (!result) return NULL;\n    value = ast2obj_expr(o->context_expr);","target":0,"flaw_line_index":0,"hash":"839077f4-950f-48b3-8b61-fb8f3d865201","idx":"fce25373-9351-4fda-9f71-7d0c9dadb9e7"}
{"func_before":"\t\t\t\t\t\t  unsigned long opt),\n\t\t unsigned long opt, u32 timeout, u8 *hci_status)\n{\n\tint ret;\n\n\tif (!test_bit(HCI_UP, &hdev->flags))\n\t\treturn -ENETDOWN;\n\n\t\/* Serialize all requests *\/\n\thci_req_sync_lock(hdev);\n\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\thci_req_sync_unlock(hdev);\n\n\treturn ret;\n}","target":1,"flaw_line_index":0,"hash":"32db91d5-cbe7-4d75-afb9-c9e6be031d3a","idx":"26f19a60-2b12-433f-954d-8f35b3edede1"}
{"func_before":"int hci_req_sync(struct hci_dev *hdev, int (*req)(struct hci_request *req,\n\t\t\t\t\t\t  unsigned long opt),\n\t\t unsigned long opt, u32 timeout, u8 *hci_status)\n{\n\tint ret;\n\n\t\/* Serialize all requests *\/\n\thci_req_sync_lock(hdev);\n\t\/* check the state after obtaing the lock to protect the HCI_UP\n\t * against any races from hci_dev_do_close when the controller\n\t * gets removed.\n\t *\/\n\tif (test_bit(HCI_UP, &hdev->flags))\n\t\tret = __hci_req_sync(hdev, req, opt, timeout, hci_status);\n\telse\n\t\tret = -ENETDOWN;\n\thci_req_sync_unlock(hdev);\n\n\treturn ret;\n}","target":0,"flaw_line_index":0,"hash":"d7a8ee7c-e979-4ca7-8c6e-d7ab678785ef","idx":"f5448d2a-0b76-4b48-830b-4005a89bfb97"}
{"func_before":"    int errStatus = 0;\n    vector <uint8_t> encr_pr_key(BUF_LEN, 0);\n    vector<char> pub_key_x(BUF_LEN, 0);\n    vector<char> pub_key_y(BUF_LEN, 0);\n\n    uint32_t enc_len = 0;\n\n    sgx_status_t status = trustedGenerateEcdsaKeyAES(eid, &errStatus,\n                                        errMsg.data(), encr_pr_key.data(), &enc_len,\n                                        pub_key_x.data(), pub_key_y.data());\n","target":1,"flaw_line_index":0,"hash":"536ca409-0b3b-4b91-8442-f254c1dbe3dc","idx":"b2e3e0dc-e7ad-4af7-a1c7-749628288847"}
{"func_before":"    int errStatus = 0;\n    vector <uint8_t> encr_pr_key(BUF_LEN, 0);\n    vector<char> pub_key_x(BUF_LEN, 0);\n    vector<char> pub_key_y(BUF_LEN, 0);\n\n    uint64_t enc_len = 0;\n\n    sgx_status_t status = trustedGenerateEcdsaKeyAES(eid, &errStatus,\n                                        errMsg.data(), encr_pr_key.data(), &enc_len,\n                                        pub_key_x.data(), pub_key_y.data());\n","target":0,"flaw_line_index":0,"hash":"e6907999-138f-49b6-9f69-7af9d0781828","idx":"91426cf2-a7d3-4f27-aa1f-fbc0e766537c"}
{"func_before":"int TLSOutStream::length()\n{\n  return offset + ptr - start;\n}","target":1,"flaw_line_index":0,"hash":"da187529-38e4-472e-8838-acf4f656d8c6","idx":"3718eb6f-3158-4bd8-9c17-4191acc4d876"}
{"func_before":"size_t TLSOutStream::length()\n{\n  return offset + ptr - start;\n}","target":0,"flaw_line_index":0,"hash":"499b252e-8392-42cf-a72b-54ad9a745fe6","idx":"9fa254b7-16d0-4d96-acf1-27172c5ec7d9"}
{"func_before":"        while (pqueue_peek(s->d1->unprocessed_rcds.q))\n            {\n            dtls1_get_unprocessed_record(s);\n            if ( ! dtls1_process_record(s))\n                return(0);\n            dtls1_buffer_record(s, &(s->d1->processed_rcds), \n                s->s3->rrec.seq_num);\n            }\n        }\n\n    \/* sync epoch numbers once all the unprocessed records \n     * have been processed *\/","target":1,"flaw_line_index":0,"hash":"5e247827-dd04-46c4-bbf2-0768ded86f64","idx":"32b006f2-a09e-4b8f-b9db-bbb0e1cac2b1"}
{"func_before":"        while (pqueue_peek(s->d1->unprocessed_rcds.q))\n            {\n            dtls1_get_unprocessed_record(s);\n            if ( ! dtls1_process_record(s))\n                return(0);\n            if(dtls1_buffer_record(s, &(s->d1->processed_rcds),\n                s->s3->rrec.seq_num)<0)\n                return -1;\n            }\n        }\n\n    \/* sync epoch numbers once all the unprocessed records \n     * have been processed *\/","target":0,"flaw_line_index":0,"hash":"69f96d09-2ecc-4ac0-ae9f-ac909f07bbc3","idx":"fdae7213-5845-4172-a40b-ae439856b464"}
{"func_before":"static void Rp_test(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint opts;\n\tResub m;\n\n\tre = js_toregexp(J, 0);\n\ttext = js_tostring(J, 1);\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\n\tif (!js_regexec(re->prog, text, &m, opts)) {\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\tjs_pushboolean(J, 1);\n\t\treturn;\n\t}","target":1,"flaw_line_index":0,"hash":"4d4f788f-c0da-4de4-b8f5-06b496ac7834","idx":"5f7f1980-5fa9-47c7-aba1-e909bdda7c4c"}
{"func_before":"static void Rp_test(js_State *J)\n{\n\tjs_Regexp *re;\n\tconst char *text;\n\tint result;\n\tint opts;\n\tResub m;\n\n\tre = js_toregexp(J, 0);\n\ttext = js_tostring(J, 1);\n\t\t\ttext += re->last;\n\t\t\topts |= REG_NOTBOL;\n\t\t}\n\t}\n\n\tresult = js_regexec(re->prog, text, &m, opts);\n\tif (result < 0)\n\t\tjs_error(J, \"regexec failed\");\n\tif (result == 0) {\n\t\tif (re->flags & JS_REGEXP_G)\n\t\t\tre->last = re->last + (m.sub[0].ep - text);\n\t\tjs_pushboolean(J, 1);\n\t\treturn;\n\t}","target":0,"flaw_line_index":0,"hash":"5cd50284-4c72-4479-981f-e4670ea36851","idx":"b1fb6260-c0b7-402f-8704-931c4b4db109"}
{"func_before":"bool QHstsHeaderParser::parse(const QList<QPair<QByteArray, QByteArray>> &headers)\n{\n    for (const auto &h : headers) {\n        \/\/ We use '==' since header name was already 'trimmed' for us:\n        if (h.first == \"Strict-Transport-Security\") {\n            header = h.second;\n            \/\/ RFC6797, 8.1:\n            \/\/\n            \/\/  The UA MUST ignore any STS header fields not conforming to the\n            \/\/ grammar specified in Section 6.1 (\"Strict-Transport-Security HTTP","target":1,"flaw_line_index":0,"hash":"7298fa78-2987-4b7d-b56f-d8125ce203fe","idx":"45c573ad-e808-4113-9fed-0e987b55b5f4"}
{"func_before":"bool QHstsHeaderParser::parse(const QList<QPair<QByteArray, QByteArray>> &headers)\n{\n    for (const auto &h : headers) {\n        \/\/ We compare directly because header name was already 'trimmed' for us:\n        if (h.first.compare(\"Strict-Transport-Security\", Qt::CaseInsensitive) == 0) {\n            header = h.second;\n            \/\/ RFC6797, 8.1:\n            \/\/\n            \/\/  The UA MUST ignore any STS header fields not conforming to the\n            \/\/ grammar specified in Section 6.1 (\"Strict-Transport-Security HTTP","target":0,"flaw_line_index":0,"hash":"e8216fba-c5ac-438e-a5b5-c510667603eb","idx":"d42b6f18-620b-4af4-8319-311744c00c93"}
{"func_before":"\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\tskb_dst_drop(skb);\n}","target":1,"flaw_line_index":0,"hash":"b987a269-a6bc-4c71-8016-088a3a803679","idx":"409fa272-1896-4e25-af7f-6abc70dc48aa"}
{"func_before":"\t\tpktinfo->ipi_spec_dst.s_addr = fib_compute_spec_dst(skb);\n\t} else {\n\t\tpktinfo->ipi_ifindex = 0;\n\t\tpktinfo->ipi_spec_dst.s_addr = 0;\n\t}\n\t\/* We need to keep the dst for __ip_options_echo()\n\t * We could restrict the test to opt.ts_needtime || opt.srr,\n\t * but the following is good enough as IP options are not often used.\n\t *\/\n\tif (unlikely(IPCB(skb)->opt.optlen))\n\t\tskb_dst_force(skb);\n\telse\n\t\tskb_dst_drop(skb);\n}","target":0,"flaw_line_index":0,"hash":"5791e051-f662-4c03-9787-7f28cc95329d","idx":"2d1d0f58-4fcf-4a7d-b2e7-7965f2e4bd0f"}
{"func_before":"sysUpTime_handler(snmp_varbind_t *varbind, uint32_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}","target":1,"flaw_line_index":0,"hash":"2c9ec68b-c742-4ea0-a6af-d60fecb43566","idx":"7ba84984-87ac-45b5-90bf-daa02ec15315"}
{"func_before":"sysUpTime_handler(snmp_varbind_t *varbind, snmp_oid_t *oid)\n{\n  snmp_api_set_time_ticks(varbind, oid, clock_seconds() * 100);\n}","target":0,"flaw_line_index":0,"hash":"24197718-a00a-45ee-9ba4-47a57f203ce7","idx":"cf9ebd42-fc63-4353-9c62-c3c0fa55f7a4"}
{"func_before":"\t    {\n\t\tcheck_unchanged = FALSE;\n\n\t\t\/\/ 2. 3. 4. 5.: inserted\/deleted lines touching this diff.\n\t\tif (deleted > 0)\n\t\t{\n\t\t    if (dp->df_lnum[idx] >= line1)\n\t\t    {\n\t\t\toff = dp->df_lnum[idx] - lnum_deleted;\n\t\t\tif (last <= line2)\n\t\t\t{\n\t\t\t    \/\/ 4. delete all lines of diff\n\t\t\t    if (dp->df_next != NULL\n\t\t\t\t    && dp->df_next->df_lnum[idx] - 1 <= line2)\n\t\t\t\tn = deleted - dp->df_count[idx];\n\t\t\t    dp->df_count[idx] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    \/\/ 5. delete lines at or just before top of diff\n\t\t\t    n = off;\n\t\t\t    dp->df_count[idx] -= line2 - dp->df_lnum[idx] + 1;\n\t\t\t    check_unchanged = TRUE;\n\t\t\t}\n\t\t\tdp->df_lnum[idx] = line1;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\toff = 0;\n\t\t\tif (last < line2)\n\t\t\t{\n\t\t\t    \/\/ 2. delete at end of diff\n\t\t\t    dp->df_count[idx] -= last - lnum_deleted + 1;\n\t\t\t    if (dp->df_next != NULL","target":1,"flaw_line_index":0,"hash":"e8cf5fb6-57e0-41bc-b550-39a6511718ac","idx":"5b8667fa-ecc2-4082-97e1-b693bfbd9242"}
{"func_before":"\t\tcheck_unchanged = FALSE;\n\n\t\t\/\/ 2. 3. 4. 5.: inserted\/deleted lines touching this diff.\n\t\tif (deleted > 0)\n\t\t{\n\t\t    off = 0;\n\t\t    if (dp->df_lnum[idx] >= line1)\n\t\t    {\n\t\t\tif (last <= line2)\n\t\t\t{\n\t\t\t    \/\/ 4. delete all lines of diff\n\t\t\t    if (dp->df_next != NULL\n\t\t\t\t    && dp->df_next->df_lnum[idx] - 1 <= line2)\n\t\t\t    dp->df_count[idx] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    \/\/ 5. delete lines at or just before top of diff\n\t\t\t    off = dp->df_lnum[idx] - lnum_deleted;\n\t\t\t    n = off;\n\t\t\t    dp->df_count[idx] -= line2 - dp->df_lnum[idx] + 1;\n\t\t\t    check_unchanged = TRUE;\n\t\t\t}\n\t\t\tdp->df_lnum[idx] = line1;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (last < line2)\n\t\t\t{\n\t\t\t    \/\/ 2. delete at end of diff\n\t\t\t    dp->df_count[idx] -= last - lnum_deleted + 1;\n\t\t\t    if (dp->df_next != NULL","target":0,"flaw_line_index":0,"hash":"60ad33ca-57ec-45fd-a359-8ca39109669e","idx":"1cc8c111-4347-4e6a-9035-7404216c5e3a"}
{"func_before":"{\n    \/\/ Only make the change visible if there is not another with a bigger sequence number.\n    \/\/ TODO Revisar si no hay que incluirlo.\n    if (!thereIsUpperRecordOf(change->writerGUID, change->sequenceNumber))\n    {\n        \/\/ Update Ownership strength.\n        if (EXCLUSIVE_OWNERSHIP_QOS == m_att.ownershipKind)\n        {\n            auto writer = std::find_if(matched_writers_.begin(), matched_writers_.end(),\n                            [change](const RemoteWriterInfo_t& item)\n                            {\n                                return item.guid == change->writerGUID;\n                            });\n            assert(matched_writers_.end() != writer);\n            change->reader_info.writer_ownership_strength = writer->ownership_strength;\n        }\n        else\n        {\n            auto payload_length = change->serializedPayload.length;\n            auto guid = change->writerGUID;\n            auto seq = change->sequenceNumber;\n\n            Time_t::now(change->reader_info.receptionTimestamp);\n            SequenceNumber_t previous_seq = update_last_notified(change->writerGUID, change->sequenceNumber);\n            ++total_unread_;\n\n            on_data_notify(guid, change->sourceTimestamp);\n\n            auto listener = getListener();","target":1,"flaw_line_index":0,"hash":"01177258-e530-4b0f-a430-76d23dd4e0c3","idx":"15d1bd5a-a83c-4f7c-ba1f-1cc1ba948dab"}
{"func_before":"{\n    \/\/ Only make the change visible if there is not another with a bigger sequence number.\n    \/\/ TODO Revisar si no hay que incluirlo.\n    if (!thereIsUpperRecordOf(change->writerGUID, change->sequenceNumber))\n    {\n        bool update_notified = true;\n\n        decltype(matched_writers_)::iterator writer = matched_writers_.end();\n        if ((EXCLUSIVE_OWNERSHIP_QOS == m_att.ownershipKind) ||\n                (m_trustedWriterEntityId == change->writerGUID.entityId))\n        {\n            writer = std::find_if(matched_writers_.begin(), matched_writers_.end(),\n                            [change](const RemoteWriterInfo_t& item)\n                            {\n                                return item.guid == change->writerGUID;\n                            });\n            bool is_matched = matched_writers_.end() != writer;\n            update_notified = is_matched;\n        }\n\n        \/\/ Update Ownership strength.\n        if (EXCLUSIVE_OWNERSHIP_QOS == m_att.ownershipKind)\n        {\n            assert(matched_writers_.end() != writer);\n            change->reader_info.writer_ownership_strength = writer->ownership_strength;\n        }\n        else\n        {\n            auto payload_length = change->serializedPayload.length;\n            auto guid = change->writerGUID;\n            auto seq = change->sequenceNumber;\n\n            Time_t::now(change->reader_info.receptionTimestamp);\n            SequenceNumber_t previous_seq{ 0, 0 };\n            if (update_notified)\n            {\n                previous_seq = update_last_notified(change->writerGUID, change->sequenceNumber);\n            }\n            ++total_unread_;\n\n            on_data_notify(guid, change->sourceTimestamp);\n\n            auto listener = getListener();","target":0,"flaw_line_index":0,"hash":"5956b1e6-c9aa-442f-8cbc-87faea9b12ab","idx":"9968cc55-90e6-4a66-afbe-fa9e71f560ae"}
{"func_before":"\t\t\t__set_bit(CONFIG_TEST_BIT, &debug);\n\t\t\t__set_bit(DONT_RESPAWN_BIT, &debug);\n\t\t\t__set_bit(DONT_FORK_BIT, &debug);\n\t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n\t\t\tif (optarg && optarg[0]) {\n\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tfprintf(stderr, \"Unable to open config-test log file %s\\n\", optarg);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tdup2(fd, STDERR_FILENO);","target":1,"flaw_line_index":0,"hash":"87429dee-985c-4502-a40f-5d901f9021f2","idx":"92b3c779-11f1-431c-90f4-7e270eb54cb9"}
{"func_before":"\t\t\t__set_bit(CONFIG_TEST_BIT, &debug);\n\t\t\t__set_bit(DONT_RESPAWN_BIT, &debug);\n\t\t\t__set_bit(DONT_FORK_BIT, &debug);\n\t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n\t\t\tif (optarg && optarg[0]) {\n\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tfprintf(stderr, \"Unable to open config-test log file %s\\n\", optarg);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tdup2(fd, STDERR_FILENO);","target":0,"flaw_line_index":0,"hash":"2873d76d-23bc-4bbf-ac48-64a3b89c31c5","idx":"c5ae80fa-1c1f-447c-b9d2-b7a5872cda30"}
{"func_before":"read_subpkt(cdk_stream_t inp, cdk_subpkt_t * r_ctx, size_t * r_nbytes)\n{\n\tbyte c, c1;\n\tsize_t size, nread, n;\n\tcdk_subpkt_t node;\n\tcdk_error_t rc;\n\n\tif (!inp || !r_nbytes)\n\t\t_gnutls_write_log(\"read_subpkt:\\n\");\n\n\tn = 0;\n\t*r_nbytes = 0;\n\tc = cdk_stream_getc(inp);\n\tn++;\n\tif (c == 255) {\n\t\tsize = read_32(inp);\n\t\tn += 4;\n\t} else if (c >= 192 && c < 255) {\n\t\tc1 = cdk_stream_getc(inp);\n\t\tn++;\n\t\tif (c1 == 0)\n\t\t\treturn 0;\n\t\tsize = ((c - 192) << 8) + c1 + 192;\n\t} else if (c < 192)","target":1,"flaw_line_index":0,"hash":"c7b7a872-91e2-4745-94b8-8e4da7952c9a","idx":"ae6491fc-0674-416d-aac8-d9ad3e7a9ff8"}
{"func_before":"read_subpkt(cdk_stream_t inp, cdk_subpkt_t * r_ctx, size_t * r_nbytes)\n{\n\tint c, c1;\n\tsize_t size, nread, n;\n\tcdk_subpkt_t node;\n\tcdk_error_t rc;\n\n\tif (!inp || !r_nbytes)\n\n\tn = 0;\n\t*r_nbytes = 0;\n\tc = cdk_stream_getc(inp);\n\tn++;\n\n\tif (c == 255) {\n\t\tsize = read_32(inp);\n\t\tif (size == (u32)-1)\n\t\t\treturn CDK_Inv_Packet;\n\n\t\tn += 4;\n\t} else if (c >= 192 && c < 255) {\n\t\tc1 = cdk_stream_getc(inp);\n\t\tif (c1 == EOF)\n\t\t\treturn CDK_Inv_Packet;\n\n\t\tn++;\n\t\tif (c1 == 0)\n\t\t\treturn 0;\n\t\tsize = ((c - 192) << 8) + c1 + 192;\n\t} else if (c < 192)","target":0,"flaw_line_index":0,"hash":"24e7bf95-b1ee-4c68-ad91-78b5f7fdc840","idx":"9c7968f7-6b6d-4106-9b22-227b79525ae6"}
{"func_before":"static int b_unpack (lua_State *L) {\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);\n  size_t ld;\n  const char *data = luaL_checklstring(L, 2, &ld);\n  size_t pos = luaL_optinteger(L, 3, 1) - 1;\n  int n = 0;  \/* number of results *\/\n  defaultoptions(&h);\n  while (*fmt) {\n    int opt = *fmt++;\n    size_t size = optsize(L, opt, &fmt);\n    pos += gettoalign(pos, &h, opt, size);\n    luaL_argcheck(L, pos+size <= ld, 2, \"data string too short\");\n    \/* stack space for item + next position *\/\n    luaL_checkstack(L, 2, \"too many results\");\n    switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i':  case 'I': {  \/* integer types *\/","target":1,"flaw_line_index":0,"hash":"804ad336-c3c9-4339-9dae-f10815cb48f6","idx":"ece08a6d-0b25-42af-9110-b457ca769ce2"}
{"func_before":"static int b_unpack (lua_State *L) {\n  Header h;\n  const char *fmt = luaL_checkstring(L, 1);\n  size_t ld;\n  const char *data = luaL_checklstring(L, 2, &ld);\n  size_t pos = luaL_optinteger(L, 3, 1);\n  luaL_argcheck(L, pos > 0, 3, \"offset must be 1 or greater\");\n  pos--; \/* Lua indexes are 1-based, but here we want 0-based for C\n          * pointer math. *\/\n  int n = 0;  \/* number of results *\/\n  defaultoptions(&h);\n  while (*fmt) {\n    int opt = *fmt++;\n    size_t size = optsize(L, opt, &fmt);\n    pos += gettoalign(pos, &h, opt, size);\n    luaL_argcheck(L, size <= ld && pos <= ld - size,\n                   2, \"data string too short\");\n    \/* stack space for item + next position *\/\n    luaL_checkstack(L, 2, \"too many results\");\n    switch (opt) {\n      case 'b': case 'B': case 'h': case 'H':\n      case 'l': case 'L': case 'T': case 'i':  case 'I': {  \/* integer types *\/","target":0,"flaw_line_index":0,"hash":"12004f07-bbb7-4959-97ee-58186141d952","idx":"846a2159-5296-4dba-a474-eb53c91bb3c7"}
{"func_before":"\t\t\t\t\t\t\tprintf(\"chunked transfer-encoding!\\n\");\n#endif\n\t\t\t\t\t\t\tchunked = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twhile(header_buf[i]=='\\r' || header_buf[i] == '\\n')\n\t\t\t\t\t\ti++;\n\t\t\t\t\tlinestart = i;\n\t\t\t\t\tcolon = linestart;\n\t\t\t\t\tvaluestart = 0;\n\t\t\t\t}","target":1,"flaw_line_index":0,"hash":"b0919615-56ce-4c84-b824-561d9225796b","idx":"ac94cdae-a312-4bb2-b055-c57839370da6"}
{"func_before":"\t\t\t\t\t\t\tprintf(\"chunked transfer-encoding!\\n\");\n#endif\n\t\t\t\t\t\t\tchunked = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\twhile((i < (int)header_buf_used) && (header_buf[i]=='\\r' || header_buf[i] == '\\n'))\n\t\t\t\t\t\ti++;\n\t\t\t\t\tlinestart = i;\n\t\t\t\t\tcolon = linestart;\n\t\t\t\t\tvaluestart = 0;\n\t\t\t\t}","target":0,"flaw_line_index":0,"hash":"5ec77f26-0d9d-4c4b-9975-fd62e19564e2","idx":"a29812d8-6a13-4493-9aa5-87c7929d091c"}
{"func_before":"            ogs_app()->pool.sess * OGS_MAX_NUM_OF_PDR);\n    ogs_pool_init(&ogs_pfcp_pdr_teid_pool, ogs_pfcp_pdr_pool.size);\n    ogs_pool_random_id_generate(&ogs_pfcp_pdr_teid_pool);\n\n    pdr_random_to_index = ogs_calloc(\n            sizeof(ogs_pool_id_t), ogs_pfcp_pdr_pool.size);\n    ogs_assert(pdr_random_to_index);\n    for (i = 0; i < ogs_pfcp_pdr_pool.size; i++)\n        pdr_random_to_index[ogs_pfcp_pdr_teid_pool.array[i]] = i;\n\n    ogs_pool_init(&ogs_pfcp_rule_pool,","target":1,"flaw_line_index":0,"hash":"7eb0d76a-7dff-4f71-9dcb-15b720996a9c","idx":"8724f3bb-ae1f-4ab5-8f84-431942bb9381"}
{"func_before":"            ogs_app()->pool.sess * OGS_MAX_NUM_OF_PDR);\n    ogs_pool_init(&ogs_pfcp_pdr_teid_pool, ogs_pfcp_pdr_pool.size);\n    ogs_pool_random_id_generate(&ogs_pfcp_pdr_teid_pool);\n\n    pdr_random_to_index = ogs_calloc(\n            sizeof(ogs_pool_id_t), ogs_pfcp_pdr_pool.size+1);\n    ogs_assert(pdr_random_to_index);\n    for (i = 0; i < ogs_pfcp_pdr_pool.size; i++)\n        pdr_random_to_index[ogs_pfcp_pdr_teid_pool.array[i]] = i;\n\n    ogs_pool_init(&ogs_pfcp_rule_pool,","target":0,"flaw_line_index":0,"hash":"2ed5691b-2b03-47f3-977a-d1a2e9dba9fc","idx":"12271e3d-16e1-41cf-b28e-788b8ced1485"}
{"func_before":"minimask_equal(const struct minimask *a, const struct minimask *b)\n{\n    return !memcmp(a, b, sizeof *a\n                   + MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks)));\n}","target":1,"flaw_line_index":0,"hash":"66e0c9fc-bbba-45bb-b7ed-a8dd353eaa7d","idx":"7a7e7e4f-cbe9-4adf-8ae9-de463387f293"}
{"func_before":"minimask_equal(const struct minimask *a, const struct minimask *b)\n{\n    \/* At first glance, it might seem that this can be reasonably optimized\n     * into a single memcmp() for the total size of the region.  Such an\n     * optimization will work OK with most implementations of memcmp() that\n     * proceed from the start of the regions to be compared to the end in\n     * reasonably sized chunks.  However, memcmp() is not required to be\n     * implemented that way, and an implementation that, for example, compares\n     * all of the bytes in both regions without early exit when it finds a\n     * difference, or one that compares, say, 64 bytes at a time, could access\n     * an unmapped region of memory if minimasks 'a' and 'b' have different\n     * lengths.  By first checking that the maps are the same with the first\n     * memcmp(), we verify that 'a' and 'b' have the same length and therefore\n     * ensure that the second memcmp() is safe. *\/\n    return (!memcmp(a, b, sizeof *a)\n            && !memcmp(a + 1, b + 1,\n                       MINIFLOW_VALUES_SIZE(miniflow_n_values(&a->masks))));\n}","target":0,"flaw_line_index":0,"hash":"ba9eb5e6-8136-475e-8908-cab0af197f77","idx":"26bd528e-077a-4188-a0f8-264eca1f3b26"}
{"func_before":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n\n  auto* params = reinterpret_cast<TfLiteShapeParams*>(node->builtin_data);\n  switch (params->out_type) {\n    case kTfLiteInt32:\n      output->type = kTfLiteInt32;","target":1,"flaw_line_index":0,"hash":"2efacf7f-663b-4bc8-94e3-52d876d1ab4f","idx":"a30b121a-7873-44b7-b4e5-6f4a5bbc9f4a"}
{"func_before":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  auto* params = reinterpret_cast<TfLiteShapeParams*>(node->builtin_data);\n  switch (params->out_type) {\n    case kTfLiteInt32:\n      output->type = kTfLiteInt32;","target":0,"flaw_line_index":0,"hash":"6c29ad5c-0d1d-49c4-8098-5b3eb677bbc4","idx":"80f47dce-b12b-4781-b8b1-a7326f7bb654"}
{"func_before":"bgp_capability_parse (struct peer *peer, u_char *pnt, u_char length,\n\t\t      u_char **error)\n{\n  int ret;\n  u_char *end;\n  struct capability cap;\n\n  end = pnt + length;\n\n  while (pnt < end)\n    {\n      afi_t afi;\n      safi_t safi;\n\n      \/* Fetch structure to the byte stream. *\/\n      memcpy (&cap, pnt, sizeof (struct capability));\n\n      afi = ntohs(cap.mpc.afi);\n      safi = cap.mpc.safi;\n\n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s OPEN has CAPABILITY code: %d, length %d\",\n\t\t   peer->host, cap.code, cap.length);\n\n      \/* We need at least capability code and capability length. *\/\n      if (pnt + 2 > end)\n\t{\n\t  zlog_info (\"%s Capability length error\", peer->host);\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t  return -1;\n\t}\n\n      \/* Capability length check. *\/\n      if (pnt + (cap.length + 2) > end)\n\t{\n\t  zlog_info (\"%s Capability length error\", peer->host);\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t  return -1;\n\t}\n\n      \/* We know MP Capability Code. *\/\n      if (cap.code == CAPABILITY_CODE_MP)\n\t{\n\t  if (BGP_DEBUG (normal, NORMAL))\n\t    zlog_debug (\"%s OPEN has MP_EXT CAP for afi\/safi: %u\/%u\",\n\t\t       peer->host, afi, safi);\n\n\t  \/* Ignore capability when override-capability is set. *\/\n\t  if (! CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n\t    {\n\t      \/* Set negotiated value. *\/\n\t      ret = bgp_capability_mp (peer, &cap);\n\n\t      \/* Unsupported Capability. *\/\n\t      if (ret < 0)\n\t\t{\n\t\t  \/* Store return data. *\/\n\t\t  memcpy (*error, &cap, cap.length + 2);\n\t\t  *error += cap.length + 2;\n\t\t}\n\t    }\n\t}\n      else if (cap.code == CAPABILITY_CODE_REFRESH\n\t       || cap.code == CAPABILITY_CODE_REFRESH_OLD)\n\t{\n\t  \/* Check length. *\/\n\t  if (cap.length != CAPABILITY_CODE_REFRESH_LEN)\n\t    {\n\t      zlog_info (\"%s Route Refresh Capability length error %d\",\n\t\t\t peer->host, cap.length);\n\t      bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t      return -1;\n\t    }\n\n\t  if (BGP_DEBUG (normal, NORMAL))\n\t    zlog_debug (\"%s OPEN has ROUTE-REFRESH capability(%s) for all address-families\",\n\t\t       peer->host,\n\t\t       cap.code == CAPABILITY_CODE_REFRESH_OLD ? \"old\" : \"new\");\n\n\t  \/* BGP refresh capability *\/\n\t  if (cap.code == CAPABILITY_CODE_REFRESH_OLD)\n\t    SET_FLAG (peer->cap, PEER_CAP_REFRESH_OLD_RCV);\n\t  else\n\t    SET_FLAG (peer->cap, PEER_CAP_REFRESH_NEW_RCV);\n\t}\n      else if (cap.code == CAPABILITY_CODE_ORF\n\t       || cap.code == CAPABILITY_CODE_ORF_OLD)\n\tbgp_capability_orf (peer, &cap, pnt + sizeof (struct capability));\n      else if (cap.code == CAPABILITY_CODE_RESTART)\n       {\n         struct graceful_restart_af graf;\n         u_int16_t restart_flag_time;\n         int restart_bit = 0;\n         u_char *restart_pnt;\n         u_char *restart_end;\n\n         \/* Check length. *\/\n         if (cap.length < CAPABILITY_CODE_RESTART_LEN)\n           {\n             zlog_info (\"%s Graceful Restart Capability length error %d\",\n                        peer->host, cap.length);\n             bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n             return -1;\n           }\n\n         SET_FLAG (peer->cap, PEER_CAP_RESTART_RCV);\n         restart_flag_time = ntohs(cap.mpc.afi);\n         if (CHECK_FLAG (restart_flag_time, RESTART_R_BIT))\n           restart_bit = 1;\n         UNSET_FLAG (restart_flag_time, 0xF000);\n\t peer->v_gr_restart = restart_flag_time;\n\n         if (BGP_DEBUG (normal, NORMAL))\n           {\n             zlog_debug (\"%s OPEN has Graceful Restart capability\", peer->host);\n             zlog_debug (\"%s Peer has%srestarted. Restart Time : %d\",\n                        peer->host, restart_bit ? \" \" : \" not \",\n\t\t\tpeer->v_gr_restart);\n           }\n\n         restart_pnt = pnt + 4;\n         restart_end = pnt + cap.length + 2;\n\n         while (restart_pnt < restart_end)\n           {\n             memcpy (&graf, restart_pnt, sizeof (struct graceful_restart_af));\n\n             afi = ntohs(graf.afi);\n             safi = graf.safi;\n\n             if (CHECK_FLAG (graf.flag, RESTART_F_BIT))\n\t\tSET_FLAG (peer->af_cap[afi][safi], PEER_CAP_RESTART_AF_PRESERVE_RCV);\n\n             if (strcmp (afi_safi_print (afi, safi), \"Unknown\") == 0)\n               {\n                  if (BGP_DEBUG (normal, NORMAL))\n                    zlog_debug (\"%s Addr-family %d\/%d(afi\/safi) not supported. I gnore the Graceful Restart capability\",\n                               peer->host, afi, safi);\n               }\n             else if (! peer->afc[afi][safi])\n               {\n                  if (BGP_DEBUG (normal, NORMAL))\n                     zlog_debug (\"%s Addr-family %d\/%d(afi\/safi) not enabled. Ignore the Graceful Restart capability\",\n                                peer->host, afi, safi);\n               }\n             else\n               {\n                 if (BGP_DEBUG (normal, NORMAL))\n                   zlog_debug (\"%s Address family %s is%spreserved\", peer->host,\n\t\t\t       afi_safi_print (afi, safi),\n\t\t\t       CHECK_FLAG (peer->af_cap[afi][safi],\n\t\t\t       PEER_CAP_RESTART_AF_PRESERVE_RCV)\n\t\t\t       ? \" \" : \" not \");\n\n                   SET_FLAG (peer->af_cap[afi][safi], PEER_CAP_RESTART_AF_RCV);\n               }\n             restart_pnt += 4;\n           }\n       }\n      else if (cap.code == CAPABILITY_CODE_DYNAMIC)\n\t{\n\t  \/* Check length. *\/\n\t  if (cap.length != CAPABILITY_CODE_DYNAMIC_LEN)\n\t    {\n\t      zlog_info (\"%s Dynamic Capability length error %d\",\n\t\t\t peer->host, cap.length);\n\t      bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t      return -1;\n\t    }\n\n\t  if (BGP_DEBUG (normal, NORMAL))\n\t    zlog_debug (\"%s OPEN has DYNAMIC capability\", peer->host);\n\n\t  SET_FLAG (peer->cap, PEER_CAP_DYNAMIC_RCV);\n\t}\n \n      else if (cap.code > 128)\n\t{\n\t  \/* We don't send Notification for unknown vendor specific\n\t     capabilities.  It seems reasonable for now...  *\/\n\t  zlog_warn (\"%s Vendor specific capability %d\",\n\t\t     peer->host, cap.code);\n\t}\n      else\n\t{\n\t  zlog_warn (\"%s unrecognized capability code: %d - ignored\",\n\t\t     peer->host, cap.code);\n\t  memcpy (*error, &cap, cap.length + 2);\n\t  *error += cap.length + 2;\n\t}\n\n      pnt += cap.length + 2;\n    }\n  return 0;\n}","target":1,"flaw_line_index":0,"hash":"a83bd63e-bc73-4201-a200-84b5183cfae0","idx":"bad4a6e0-3f78-45d2-919d-b55f48e104bf"}
{"func_before":"bgp_capability_parse (struct peer *peer, size_t length, u_char **error)\n{\n  int ret;\n  struct stream *s = BGP_INPUT (peer);\n  size_t end = stream_get_getp (s) + length;\n  \n  assert (STREAM_READABLE (s) >= length);\n  \n  while (stream_get_getp (s) < end)\n    {\n      size_t start;\n      u_char *sp = stream_pnt (s);\n      struct capability_header caphdr;\n      \n      \/* We need at least capability code and capability length. *\/\n      if (stream_get_getp(s) + 2 > end)\n\t{\n\t  zlog_info (\"%s Capability length error (< header)\", peer->host);\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t  return -1;\n\t}\n      \n      caphdr.code = stream_getc (s);\n      caphdr.length = stream_getc (s);\n      start = stream_get_getp (s);\n      \n      \/* Capability length check sanity check. *\/\n      if (start + caphdr.length > end)\n\t{\n\t  zlog_info (\"%s Capability length error (< length)\", peer->host);\n\t  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n\t  return -1;\n\t}\n      \n      if (BGP_DEBUG (normal, NORMAL))\n\tzlog_debug (\"%s OPEN has %s capability (%u), length %u\",\n\t\t   peer->host,\n\t\t   LOOKUP (capcode_str, caphdr.code),\n\t\t   caphdr.code, caphdr.length);\n      \n      \/* Length sanity check, type-specific, for known capabilities *\/\n      switch (caphdr.code)\n        {\n          case CAPABILITY_CODE_MP:\n          case CAPABILITY_CODE_REFRESH:\n          case CAPABILITY_CODE_REFRESH_OLD:\n          case CAPABILITY_CODE_ORF:\n          case CAPABILITY_CODE_ORF_OLD:\n          case CAPABILITY_CODE_RESTART:\n          case CAPABILITY_CODE_DYNAMIC:\n              \/* Check length. *\/\n              if (caphdr.length < cap_minsizes[caphdr.code])\n                {\n                  zlog_info (\"%s %s Capability length error: got %u,\"\n                             \" expected at least %u\",\n                             peer->host, \n                             LOOKUP (capcode_str, caphdr.code),\n                             caphdr.length, cap_minsizes[caphdr.code]);\n                  bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);\n                  return -1;\n                }\n          \/* we deliberately ignore unknown codes, see below *\/\n          default:\n            break;\n        }\n      \n      switch (caphdr.code)\n        {\n          case CAPABILITY_CODE_MP:\n            {\n              \/* Ignore capability when override-capability is set. *\/\n              if (! CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))\n                {\n                  \/* Set negotiated value. *\/\n                  ret = bgp_capability_mp (peer, &caphdr);\n\n                  \/* Unsupported Capability. *\/\n                  if (ret < 0)\n                    {\n                      \/* Store return data. *\/\n                      memcpy (*error, sp, caphdr.length + 2);\n                      *error += caphdr.length + 2;\n                    }\n                }\n            }\n            break;\n          case CAPABILITY_CODE_REFRESH:\n          case CAPABILITY_CODE_REFRESH_OLD:\n            {\n              \/* BGP refresh capability *\/\n              if (caphdr.code == CAPABILITY_CODE_REFRESH_OLD)\n                SET_FLAG (peer->cap, PEER_CAP_REFRESH_OLD_RCV);\n              else\n                SET_FLAG (peer->cap, PEER_CAP_REFRESH_NEW_RCV);\n            }\n            break;\n          case CAPABILITY_CODE_ORF:\n          case CAPABILITY_CODE_ORF_OLD:\n            if (bgp_capability_orf (peer, &caphdr))\n              return -1;\n            break;\n          case CAPABILITY_CODE_RESTART:\n            if (bgp_capability_restart (peer, &caphdr))\n              return -1;\n            break;\n          case CAPABILITY_CODE_DYNAMIC:\n            SET_FLAG (peer->cap, PEER_CAP_DYNAMIC_RCV);\n            break;\n          default:\n            if (caphdr.code > 128)\n              {\n                \/* We don't send Notification for unknown vendor specific\n                   capabilities.  It seems reasonable for now...  *\/\n                zlog_warn (\"%s Vendor specific capability %d\",\n                           peer->host, caphdr.code);\n              }\n            else\n              {\n                zlog_warn (\"%s unrecognized capability code: %d - ignored\",\n                           peer->host, caphdr.code);\n                memcpy (*error, sp, caphdr.length + 2);\n                *error += caphdr.length + 2;\n              }\n          }\n      if (stream_get_getp(s) != (start + caphdr.length))\n        {\n          if (stream_get_getp(s) > (start + caphdr.length))\n            zlog_warn (\"%s Cap-parser for %s read past cap-length, %u!\",\n                       peer->host, LOOKUP (capcode_str, caphdr.code),\n                       caphdr.length);\n          stream_set_getp (s, start + caphdr.length);\n        }\n    }\n  return 0;\n}","target":0,"flaw_line_index":0,"hash":"54bd1591-751c-4c57-8039-227b605ec667","idx":"0b93e6f0-a00d-4359-a719-552b4a66b827"}
{"func_before":"static void gf_isom_write_tx3g(GF_Tx3gSampleEntryBox *a, GF_BitStream *bs, u32 sidx, u32 sidx_offset)\n{\n\tu32 size, j, fount_count;\n\tBool is_qt_text = (a->type==GF_ISOM_BOX_TYPE_TEXT) ? GF_TRUE : GF_FALSE;\n\tconst char *qt_fontname = NULL;\n\tvoid gpp_write_rgba(GF_BitStream *bs, u32 col);\n\tvoid gpp_write_box(GF_BitStream *bs, GF_BoxRecord *rec);\n\tvoid gpp_write_style(GF_BitStream *bs, GF_StyleRecord *rec);\n\n\n\tif (sidx_offset) gf_bs_write_u8(bs, sidx + sidx_offset);\n\n\t\/*SINCE WINCE HAS A READONLY VERSION OF MP4 WE MUST DO IT BY HAND*\/\n\tsize = 8 + 18 + 8 + 12;\n\tsize += 8 + 2;\n\tfount_count = 0;\n\tif (is_qt_text) {\n\t\tGF_TextSampleEntryBox *qt = (GF_TextSampleEntryBox *)a;\n\t\tif (qt->textName) {\n\t\t\tqt_fontname = qt->textName;\n\t\t\tfount_count = 1;\n\t\t}\n\t} else {\n\t\tif (a->font_table) {\n\t\t\tfount_count = a->font_table->entry_count;\n\t\t\tfor (j=0; j<fount_count; j++) {\n\t\t\t\tsize += 3;\n\t\t\t\tif (a->font_table->fonts[j].fontName) size += (u32) strlen(a->font_table->fonts[j].fontName);\n\t\t\t}\n\t\t}\n\t}\n\t\/*write TextSampleEntry box*\/\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, a->type);\n\tgf_bs_write_data(bs, a->reserved, 6);\n\tgf_bs_write_u16(bs, a->dataReferenceIndex);\n\tgf_bs_write_u32(bs, a->displayFlags);\n\tgf_bs_write_u8(bs, a->horizontal_justification);\n\tgf_bs_write_u8(bs, a->vertical_justification);\n\tgpp_write_rgba(bs, a->back_color);\n\tgpp_write_box(bs, &a->default_box);\n\tgpp_write_style(bs, &a->default_style);\n\t\/*write font table box*\/\n\tsize -= (8 + 18 + 8 + 12);\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FTAB);\n\n\tgf_bs_write_u16(bs, fount_count);\n\tfor (j=0; j<fount_count; j++) {\n\t\tif (is_qt_text) {\n\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\tif (qt_fontname) {\n\t\t\t\tu32 len = (u32) strlen(qt_fontname);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, qt_fontname, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_write_u16(bs, a->font_table->fonts[j].fontID);\n\t\t\tif (a->font_table->fonts[j].fontName) {\n\t\t\t\tu32 len = (u32) strlen(a->font_table->fonts[j].fontName);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, a->font_table->fonts[j].fontName, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t}\n\t}","target":1,"flaw_line_index":0,"hash":"daa50da3-5391-4d35-85db-586b8ba5da27","idx":"fcfc3fdb-5c11-4d50-9e8b-0eab83384882"}
{"func_before":"static void gf_isom_write_tx3g(GF_Tx3gSampleEntryBox *_a, GF_BitStream *bs, u32 sidx, u32 sidx_offset)\n{\n\tu32 size, j, fount_count;\n\tconst char *qt_fontname = NULL;\n\tvoid gpp_write_rgba(GF_BitStream *bs, u32 col);\n\tvoid gpp_write_box(GF_BitStream *bs, GF_BoxRecord *rec);\n\tvoid gpp_write_style(GF_BitStream *bs, GF_StyleRecord *rec);\n\n\tGF_TextSampleEntryBox *qt = (_a->type==GF_ISOM_BOX_TYPE_TEXT) ? (GF_TextSampleEntryBox *)_a : NULL;\n\tGF_Tx3gSampleEntryBox *ttxt = (_a->type!=GF_ISOM_BOX_TYPE_TEXT) ? (GF_Tx3gSampleEntryBox *)_a : NULL;\n\n\tif (sidx_offset) gf_bs_write_u8(bs, sidx + sidx_offset);\n\n\t\/*SINCE WINCE HAS A READONLY VERSION OF MP4 WE MUST DO IT BY HAND*\/\n\tsize = 8 + 18 + 8 + 12;\n\tsize += 8 + 2;\n\tfount_count = 0;\n\tif (qt && qt->textName) {\n\t\tqt_fontname = qt->textName;\n\t\tfount_count = 1;\n\t} else if (ttxt && ttxt->font_table) {\n\t\tfount_count = ttxt->font_table->entry_count;\n\t\tfor (j=0; j<fount_count; j++) {\n\t\t\tsize += 3;\n\t\t\tif (ttxt->font_table->fonts[j].fontName)\n\t\t\t\tsize += (u32) strlen(ttxt->font_table->fonts[j].fontName);\n\t\t}\n\t}\n\t\/*write TextSampleEntry box*\/\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_TX3G);\n\tgf_bs_write_data(bs, _a->reserved, 6);\n\tgf_bs_write_u16(bs, _a->dataReferenceIndex);\n\tgf_bs_write_u32(bs, _a->displayFlags);\n\tif (qt) {\n\t\tGF_StyleRecord sr;\n\t\tmemset(&sr, 0, sizeof(GF_StyleRecord));\n\t\tgf_bs_write_u8(bs, qt->textJustification);\n\t\tgf_bs_write_u8(bs, (u8) -1);\n\t\tgpp_write_rgba(bs, rgb_48_to_32(qt->background_color) );\n\t\tgpp_write_box(bs, &qt->default_box);\n\t\tsr.text_color = rgb_48_to_32(qt->foreground_color);\n\t\tsr.style_flags = qt->fontFace;\n\t\tgpp_write_style(bs, &sr);\n\t} else {\n\t\tgf_bs_write_u8(bs, ttxt->horizontal_justification);\n\t\tgf_bs_write_u8(bs, ttxt->vertical_justification);\n\t\tgpp_write_rgba(bs, ttxt->back_color);\n\t\tgpp_write_box(bs, &ttxt->default_box);\n\t\tgpp_write_style(bs, &ttxt->default_style);\n\t}\n\t\/*write font table box*\/\n\tsize -= (8 + 18 + 8 + 12);\n\tgf_bs_write_u32(bs, size);\n\tgf_bs_write_u32(bs, GF_ISOM_BOX_TYPE_FTAB);\n\n\tgf_bs_write_u16(bs, fount_count);\n\tfor (j=0; j<fount_count; j++) {\n\t\tif (qt) {\n\t\t\tgf_bs_write_u16(bs, 0);\n\t\t\tif (qt_fontname) {\n\t\t\t\tu32 len = (u32) strlen(qt_fontname);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, qt_fontname, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tgf_bs_write_u16(bs, ttxt->font_table->fonts[j].fontID);\n\t\t\tif (ttxt->font_table->fonts[j].fontName) {\n\t\t\t\tu32 len = (u32) strlen(ttxt->font_table->fonts[j].fontName);\n\t\t\t\tgf_bs_write_u8(bs, len);\n\t\t\t\tgf_bs_write_data(bs, ttxt->font_table->fonts[j].fontName, len);\n\t\t\t} else {\n\t\t\t\tgf_bs_write_u8(bs, 0);\n\t\t\t}\n\t\t}\n\t}","target":0,"flaw_line_index":0,"hash":"e0734ab4-fd88-441c-8f30-45f19978b881","idx":"fccfb8f4-914b-453f-8e11-5f49bec2c4b4"}
{"func_before":"{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    int32_t len;\n    uint8_t command;\n    uint8_t *outbuf;\n    int rc;\n\n    command = buf[0];\n    outbuf = (uint8_t *)r->iov.iov_base;\n    DPRINTF(\"Command: lun=%d tag=0x%x data=0x%02x\", req->lun, req->tag, buf[0]);\n\n#ifdef DEBUG_SCSI\n    {\n        int i;\n    case READ_CAPACITY_10:\n    case READ_TOC:\n    case GET_CONFIGURATION:\n    case SERVICE_ACTION_IN_16:\n    case VERIFY_10:\n        rc = scsi_disk_emulate_command(r, outbuf);\n        if (rc < 0) {\n            return 0;\n        }\n\n        r->iov.iov_len = rc;","target":1,"flaw_line_index":0,"hash":"d46104bf-cbe7-4f0c-8494-ea1fa21e4427","idx":"71971c3c-b150-4f0e-ab93-1b941f323730"}
{"func_before":"static int32_t scsi_send_command(SCSIRequest *req, uint8_t *buf)\n{\n    SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n    int32_t len;\n    uint8_t command;\n    int rc;\n\n    command = buf[0];\n    DPRINTF(\"Command: lun=%d tag=0x%x data=0x%02x\", req->lun, req->tag, buf[0]);\n\n#ifdef DEBUG_SCSI\n    {\n        int i;\n    case READ_CAPACITY_10:\n    case READ_TOC:\n    case GET_CONFIGURATION:\n    case SERVICE_ACTION_IN_16:\n    case VERIFY_10:\n        rc = scsi_disk_emulate_command(r);\n        if (rc < 0) {\n            return 0;\n        }\n\n        r->iov.iov_len = rc;","target":0,"flaw_line_index":0,"hash":"3490e768-2571-4c2b-831f-093a63056790","idx":"b43e9263-02d6-423d-b944-7f76486ab209"}
{"func_before":"\tfor (row = 0; row < imagelength; row += tilelength) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth; col += tw) {\n\t\t\t\/*\n\t\t\t * Tile is clipped horizontally.  Calculate\n\t\t\t * visible portion and skewing factors.\n\t\t\t *\/\n\t\t\tif (colb + tilew > imagew) {","target":1,"flaw_line_index":0,"hash":"1d322e6b-0073-4fea-9424-282984255423","idx":"f1609186-f423-476a-8f86-440297dcfce4"}
{"func_before":"\tfor (row = 0; row < imagelength; row += tilelength) {\n\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n\t\tuint32 colb = 0;\n\t\tuint32 col;\n\n\t\tfor (col = 0; col < imagewidth && colb < imagew; col += tw) {\n\t\t\t\/*\n\t\t\t * Tile is clipped horizontally.  Calculate\n\t\t\t * visible portion and skewing factors.\n\t\t\t *\/\n\t\t\tif (colb + tilew > imagew) {","target":0,"flaw_line_index":0,"hash":"c8a62576-1e31-409b-82da-256219da5031","idx":"03f7e3b8-63e6-4a7e-92bd-ef9e409f0045"}
{"func_before":"static char *fstrndup(const char *ptr, unsigned long len) {\n  char *result;\n  if (len <= 0) return NULL;\n  result = ALLOC_N(char, len);\n  memccpy(result, ptr, 0, len);\n  return result;\n}","target":1,"flaw_line_index":0,"hash":"9c33cb47-36ba-4090-814f-dfaad2c5237c","idx":"d599661d-b113-4cfb-8b16-a8b4bc83e971"}
{"func_before":"static char *fstrndup(const char *ptr, unsigned long len) {\n  char *result;\n  if (len <= 0) return NULL;\n  result = ALLOC_N(char, len);\n  memcpy(result, ptr, len);\n  return result;\n}","target":0,"flaw_line_index":0,"hash":"48e1f843-086b-4ccc-af7c-bec1c40fb871","idx":"8c6e7488-8ae9-40f7-88ba-f75f0f15b4ab"}
{"func_before":"doProlog(XML_Parser parser, const ENCODING *enc, const char *s, const char *end,\n         int tok, const char *next, const char **nextPtr, XML_Bool haveMore) {\n#ifdef XML_DTD\n  static const XML_Char externalSubsetName[] = {ASCII_HASH, '\\0'};\n#endif \/* XML_DTD *\/\n  static const XML_Char atypeCDATA[]\n      = {ASCII_C, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\\0'};\n         *\/\n        if (parser->m_entityDeclHandler && role == XML_ROLE_ENTITY_PUBLIC_ID)\n          handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_DOCTYPE_CLOSE:\n      if (parser->m_doctypeName) {\n        parser->m_startDoctypeDeclHandler(\n            parser->m_handlerArg, parser->m_doctypeName, parser->m_doctypeSysid,\n            parser->m_doctypePubid, 0);\n        poolClear(&parser->m_tempPool);","target":1,"flaw_line_index":0,"hash":"196b2774-5d91-4fba-b0e0-0e0d48134b22","idx":"8ddcbd4e-088d-4e1c-9e9e-bddbe5cfd207"}
{"func_before":"doProlog(XML_Parser parser, const ENCODING *enc, const char *s, const char *end,\n         int tok, const char *next, const char **nextPtr, XML_Bool haveMore,\n         XML_Bool allowClosingDoctype) {\n#ifdef XML_DTD\n  static const XML_Char externalSubsetName[] = {ASCII_HASH, '\\0'};\n#endif \/* XML_DTD *\/\n  static const XML_Char atypeCDATA[]\n      = {ASCII_C, ASCII_D, ASCII_A, ASCII_T, ASCII_A, '\\0'};\n        if (parser->m_entityDeclHandler && role == XML_ROLE_ENTITY_PUBLIC_ID)\n          handleDefault = XML_FALSE;\n      }\n      break;\n    case XML_ROLE_DOCTYPE_CLOSE:\n      if (allowClosingDoctype != XML_TRUE) {\n        \/* Must not close doctype from within expanded parameter entities *\/\n        return XML_ERROR_INVALID_TOKEN;\n      }\n\n      if (parser->m_doctypeName) {\n        parser->m_startDoctypeDeclHandler(\n            parser->m_handlerArg, parser->m_doctypeName, parser->m_doctypeSysid,\n            parser->m_doctypePubid, 0);\n        poolClear(&parser->m_tempPool);","target":0,"flaw_line_index":0,"hash":"3e21ef8a-f53d-4544-bc75-4470f0c0b2f0","idx":"aa152fea-611d-4118-a218-81b7ff6c2d48"}
{"func_before":"\thwc = &event->hw;\n\talpha_perf_event_update(event, hwc, idx, alpha_pmu->pmc_max_period[idx]+1);\n\tdata.period = event->hw.last_period;\n\n\tif (alpha_perf_event_set_period(event, hwc, idx)) {\n\t\tif (perf_event_overflow(event, 1, &data, regs)) {\n\t\t\t\/* Interrupts coming too quickly; \"throttle\" the\n\t\t\t * counter, i.e., disable it for a little while.\n\t\t\t *\/\n\t\t\talpha_pmu_stop(event, 0);\n\t\t}","target":1,"flaw_line_index":0,"hash":"66b369c8-3c8d-48c3-b94a-9331acd265f0","idx":"05b4f8fb-2a36-4b0e-b1c4-8c1993f0a858"}
{"func_before":"\thwc = &event->hw;\n\talpha_perf_event_update(event, hwc, idx, alpha_pmu->pmc_max_period[idx]+1);\n\tdata.period = event->hw.last_period;\n\n\tif (alpha_perf_event_set_period(event, hwc, idx)) {\n\t\tif (perf_event_overflow(event, &data, regs)) {\n\t\t\t\/* Interrupts coming too quickly; \"throttle\" the\n\t\t\t * counter, i.e., disable it for a little while.\n\t\t\t *\/\n\t\t\talpha_pmu_stop(event, 0);\n\t\t}","target":0,"flaw_line_index":0,"hash":"20d9eff2-737d-48fd-a91f-8e3a33e61b19","idx":"96adf8a6-6443-4a4d-b748-618d7e8aa58a"}
{"func_before":"\telse\n\t{\n\t\tbit_not_hex = true;\n\t\tsp = input_string;\n\t}\n\n\tslen = strlen(sp);\n\t\/* Determine bitlength from input string *\/\n\tif (bit_not_hex)\n\t\tbitlen = slen;\n\telse\n\t\tbitlen = slen * 4;\n\n\t\/*\n\t * Sometimes atttypmod is not supplied. If it is supplied we need to make\n\t * sure that the bitstring fits.\n\t *\/","target":1,"flaw_line_index":0,"hash":"1cd0077f-cf84-4a67-a42c-9d85a7db3031","idx":"85dbdee7-f7b8-4efb-a589-5827091d15e5"}
{"func_before":"\t{\n\t\tbit_not_hex = true;\n\t\tsp = input_string;\n\t}\n\n\t\/*\n\t * Determine bitlength from input string.  MaxAllocSize ensures a regular\n\t * input is small enough, but we must check hex input.\n\t *\/\n\tslen = strlen(sp);\n\tif (bit_not_hex)\n\t\tbitlen = slen;\n\telse\n\t{\n\t\tif (slen > VARBITMAXLEN \/ 4)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_PROGRAM_LIMIT_EXCEEDED),\n\t\t\t\t errmsg(\"bit string length exceeds the maximum allowed (%d)\",\n\t\t\t\t\t\tVARBITMAXLEN)));\n\t\tbitlen = slen * 4;\n\t}\n\n\t\/*\n\t * Sometimes atttypmod is not supplied. If it is supplied we need to make\n\t * sure that the bitstring fits.\n\t *\/","target":0,"flaw_line_index":0,"hash":"f7342320-e74f-42a3-86c8-7c73f92141e0","idx":"887c6223-18f6-418c-b982-0e31d3b908b3"}
{"func_before":"\n\tpn = ppp_pernet(net);\n\n\tpch->ppp = NULL;\n\tpch->chan = chan;\n\tpch->chan_net = net;\n\tchan->ppp = pch;\n\tinit_ppp_file(&pch->file, CHANNEL);\n\tpch->file.hdrlen = chan->hdrlen;\n#ifdef CONFIG_PPP_MULTILINK\n\tpch->lastseq = -1;","target":1,"flaw_line_index":0,"hash":"d436440f-a486-418b-8fa4-e3e8e8146c2b","idx":"37022d98-ac50-4d61-b2fc-e6f5cfa69647"}
{"func_before":"\n\tpn = ppp_pernet(net);\n\n\tpch->ppp = NULL;\n\tpch->chan = chan;\n\tpch->chan_net = get_net(net);\n\tchan->ppp = pch;\n\tinit_ppp_file(&pch->file, CHANNEL);\n\tpch->file.hdrlen = chan->hdrlen;\n#ifdef CONFIG_PPP_MULTILINK\n\tpch->lastseq = -1;","target":0,"flaw_line_index":0,"hash":"3543895b-49aa-468f-b2c0-06e2b85fe078","idx":"a0bf5a31-c366-4bb6-8cc8-26d6556cbf2c"}
{"func_before":"        if (len > size)\n            len = size;\n        memcpy(buf, s->buf_ptr, len);\n        s->buf_ptr += len;\n    } else {\n        int64_t target_end = s->end_off ? s->end_off : s->filesize;\n        if ((!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off >= target_end)\n            return AVERROR_EOF;\n        len = ffurl_read(s->hd, buf, size);\n        if (!len && (!s->willclose || s->chunksize < 0) &&\n            target_end >= 0 && s->off < target_end) {\n            av_log(h, AV_LOG_ERROR,\n                   \"Stream ends prematurely at %\"PRId64\", should be %\"PRId64\"\\n\",\n                   s->off, target_end\n                  );\n            return AVERROR(EIO);\n        }\n    }","target":1,"flaw_line_index":0,"hash":"5a4bad24-d8dd-4795-8258-dd09a44cf600","idx":"87e8307e-bb71-4af8-a42d-54978cef231b"}
{"func_before":"        if (len > size)\n            len = size;\n        memcpy(buf, s->buf_ptr, len);\n        s->buf_ptr += len;\n    } else {\n        uint64_t target_end = s->end_off ? s->end_off : s->filesize;\n        if ((!s->willclose || s->chunksize == UINT64_MAX) && s->off >= target_end)\n            return AVERROR_EOF;\n        len = ffurl_read(s->hd, buf, size);\n        if (!len && (!s->willclose || s->chunksize == UINT64_MAX) && s->off < target_end) {\n            av_log(h, AV_LOG_ERROR,\n                   \"Stream ends prematurely at %\"PRIu64\", should be %\"PRIu64\"\\n\",\n                   s->off, target_end\n                  );\n            return AVERROR(EIO);\n        }\n    }","target":0,"flaw_line_index":0,"hash":"b87603bc-5ebd-4ef4-9469-49c5d60530eb","idx":"83deab68-d21c-4f0a-aadd-b11df6f5697f"}
{"func_before":"\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (s->target_offset == sizeof(struct ip6t_entry) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t    t->verdict < 0 &&\n\t\t    unconditional(&s->ipv6)) {\n\t\t\t\/* Tail of chains: STANDARD target (return\/policy) *\/\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];\n\t\t}","target":1,"flaw_line_index":0,"hash":"37094b26-99d5-4ebb-acd1-e028a0c6a9c5","idx":"ad2f1aca-6a31-4fda-8e0f-fc9431f20374"}
{"func_before":"\t\t*chainname = t->target.data;\n\t\t(*rulenum) = 0;\n\t} else if (s == e) {\n\t\t(*rulenum)++;\n\n\t\tif (unconditional(s) &&\n\t\t    strcmp(t->target.u.kernel.target->name,\n\t\t\t   XT_STANDARD_TARGET) == 0 &&\n\t\t    t->verdict < 0) {\n\t\t\t\/* Tail of chains: STANDARD target (return\/policy) *\/\n\t\t\t*comment = *chainname == hookname\n\t\t\t\t? comments[NF_IP6_TRACE_COMMENT_POLICY]\n\t\t\t\t: comments[NF_IP6_TRACE_COMMENT_RETURN];\n\t\t}","target":0,"flaw_line_index":0,"hash":"7ef8bde3-7380-419a-8bb0-85d6cbcee3b5","idx":"ec1d0b94-50a5-4af2-9c24-bd5d85cd47f9"}
{"func_before":"    Jsi_Number nstart = 0, nend = 0; \/\/ TODO: merge with code in ArraySliceCmd.\n    Jsi_Value *value = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1),\n        *end = Jsi_ValueArrayIndex(interp, args, 2);\n    Jsi_Obj *obj = _this->d.obj;\n    n = Jsi_ObjGetLength(interp, obj);\n\n    if (start && Jsi_GetNumberFromValue(interp, start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;","target":1,"flaw_line_index":0,"hash":"30a8b56f-eeca-4f8c-8d13-cc9a0c4e5a70","idx":"fb5a5223-97ca-42c4-86bf-483fefdf53a3"}
{"func_before":"    Jsi_Number nstart = 0, nend = 0; \/\/ TODO: merge with code in ArraySliceCmd.\n    Jsi_Value *value = Jsi_ValueArrayIndex(interp, args, 0),\n        *start = Jsi_ValueArrayIndex(interp, args, 1),\n        *end = Jsi_ValueArrayIndex(interp, args, 2);\n    Jsi_Obj *obj = _this->d.obj;\n    n = jsi_SizeOfArray(interp, obj);\n\n    if (start && Jsi_GetNumberFromValue(interp, start, &nstart) == JSI_OK) {\n        istart = (int)nstart;\n        if (istart > n)\n            goto bail;","target":0,"flaw_line_index":0,"hash":"5e0cd927-8ca8-4394-b21f-32730e8c193e","idx":"137df440-e3ea-43cd-b992-ac5a5c8a0711"}
{"func_before":"\tdata.period = event->hw.last_period;\n\tregs = get_irq_regs();\n\n\tif (regs && !perf_exclude_event(event, regs)) {\n\t\tif (!(event->attr.exclude_idle && current->pid == 0))\n\t\t\tif (perf_event_overflow(event, 0, &data, regs))\n\t\t\t\tret = HRTIMER_NORESTART;\n\t}\n\n\tperiod = max_t(u64, 10000, event->hw.sample_period);\n\thrtimer_forward_now(hrtimer, ns_to_ktime(period));","target":1,"flaw_line_index":0,"hash":"4993b8e8-96f1-4393-8f90-7145c342b4eb","idx":"3e41c1cd-db39-4179-beeb-516fa44b5984"}
{"func_before":"\tdata.period = event->hw.last_period;\n\tregs = get_irq_regs();\n\n\tif (regs && !perf_exclude_event(event, regs)) {\n\t\tif (!(event->attr.exclude_idle && current->pid == 0))\n\t\t\tif (perf_event_overflow(event, &data, regs))\n\t\t\t\tret = HRTIMER_NORESTART;\n\t}\n\n\tperiod = max_t(u64, 10000, event->hw.sample_period);\n\thrtimer_forward_now(hrtimer, ns_to_ktime(period));","target":0,"flaw_line_index":0,"hash":"ebbb91d9-b2a7-422b-8b46-1e974fb6efba","idx":"df2111ab-d49c-4bc0-9ebf-88c88786af41"}
{"func_before":"static RList *r_bin_wasm_get_data_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\n\tRList *ret = NULL;\n\tRBinWasmDataEntry *ptr = NULL;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tut32 len =  sec->payload_len;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\tsize_t n = 0;\n\n\twhile (i < len && r < count) {\n\n\t\tif (!(ptr = R_NEW0 (RBinWasmDataEntry))) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!(n = consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tptr->offset.len = n;\n\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) {\t\n\t\t\tfree (ptr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tptr->data = sec->payload_data + i;\n\n\t\tr_list_append (ret, ptr);\n\n\t\tr += 1;\n\n\t}\n\n\treturn ret;\n}","target":1,"flaw_line_index":0,"hash":"35182032-7e29-417b-85ff-3090eaeda833","idx":"52d537fd-b998-4671-8574-80b96145c982"}
{"func_before":"static RList *r_bin_wasm_get_data_entries (RBinWasmObj *bin, RBinWasmSection *sec) {\n\tRList *ret = NULL;\n\tRBinWasmDataEntry *ptr = NULL;\n\tut32 len =  sec->payload_len;\n\n\tif (!(ret = r_list_newf ((RListFree)free))) {\n\t\treturn NULL;\n\t}\n\n\tut8* buf = bin->buf->buf + (ut32)sec->payload_data;\n\tint buflen = bin->buf->length - (ut32)sec->payload_data;\n\tut32 count = sec->count;\n\tut32 i = 0, r = 0;\n\tsize_t n = 0;\n\n\twhile (i < len && len < buflen && r < count) {\n\t\tif (!(ptr = R_NEW0 (RBinWasmDataEntry))) {\n\t\t\treturn ret;\n\t\t}\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->index, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (i + 4 >= buflen) {\n\t\t\tgoto beach;\n\t\t}\n\t\tif (!(n = consume_init_expr (buf + i, buf + len, R_BIN_WASM_END_OF_CODE, NULL, &i))) {\n\t\t\tgoto beach;\n\t\t}\n\t\tptr->offset.len = n;\n\t\tif (!(consume_u32 (buf + i, buf + len, &ptr->size, &i))) {\t\n\t\t\tgoto beach;\n\t\t}\n\t\tif (i + 4 >= buflen) {\n\t\t\tgoto beach;\n\t\t}\n\t\tptr->data = sec->payload_data + i;\n\n\t\tr_list_append (ret, ptr);\n\n\t\tr += 1;\n\n\t}\n\treturn ret;\nbeach:\n\tfree (ptr);\n\treturn ret;\n}","target":0,"flaw_line_index":0,"hash":"2767680c-60de-49b9-b2e4-1dad31d13e86","idx":"e0053626-8a3e-4b32-a3f2-e0d900f99a03"}
{"func_before":"\tint repl_op;\n\tint opreturn = 0;\n\tint mod_count = 0;\n\tint not_an_error = 0;\n\tint fixup_tombstone = 0;\n\tint ec_locked = 0;\n\n\tslapi_pblock_get( pb, SLAPI_BACKEND, &be);\n\tslapi_pblock_get( pb, SLAPI_PLUGIN_PRIVATE, &li );\n\tslapi_pblock_get( pb, SLAPI_TARGET_ADDRESS, &addr );\n\tslapi_pblock_get( pb, SLAPI_MODIFY_MODS, &mods );\n\t}\n\t *\/\n\tif ( MANAGE_ENTRY_BEFORE_DBLOCK(li)) {\n\t\t\/* find and lock the entry we are about to modify *\/\n\t\tif (fixup_tombstone) {\n\t\t\te = find_entry2modify_only_ext( pb, be, addr, TOMBSTONE_INCLUDED, &txn );\n\t\t} else {\n\t\t\te = find_entry2modify( pb, be, addr, &txn );\n\t\t}\n\t\tif (e == NULL) {\n\t\t\tldap_result_code= -1;\n\t\t\tgoto error_return; \/* error result sent by find_entry2modify() *\/\n\t\t}\n\t}\n\n\ttxn.back_txn_txn = NULL; \/* ready to create the child transaction *\/\n\n\t\tif (0 == retry_count) { \/* just once *\/\n\t\t\tif ( !MANAGE_ENTRY_BEFORE_DBLOCK(li)) {\n\t\t\t\t\/* find and lock the entry we are about to modify *\/\n\t\t\t\tif (fixup_tombstone) {\n\t\t\t\t\te = find_entry2modify_only_ext( pb, be, addr, TOMBSTONE_INCLUDED, &txn );\n\t\t\t\t} else {\n\t\t\t\t\te = find_entry2modify( pb, be, addr, &txn );\n\t\t\t\t}\n\t\t\t\tif (e == NULL) {\n\t\t\t\t\tldap_result_code= -1;\n\t\t\t\t\tgoto error_return; \/* error result sent by find_entry2modify() *\/\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif ( !is_fixup_operation && !fixup_tombstone)\n\t\tif (not_an_error) {\n\t\t\t\/* This is mainly used by urp.  Solved conflict is not an error.\n\t\t\t * And we don't want the supplier to halt sending the updates. *\/\n\t\t\tldap_result_code = LDAP_SUCCESS;\n\t\t}\n\t\tslapi_send_ldap_result( pb, ldap_result_code, NULL, ldap_result_message, 0, NULL );\n\t}\n\n\t\/* free our backups *\/\n\tldap_mods_free(mods_original, 1);\n\tbackentry_free(&original_entry);","target":1,"flaw_line_index":0,"hash":"b678e54c-4e3f-4aba-87ca-511ab6af7552","idx":"8d144196-1ef8-4ce3-91fd-9b0035bac5f9"}
{"func_before":"\tint opreturn = 0;\n\tint mod_count = 0;\n\tint not_an_error = 0;\n\tint fixup_tombstone = 0;\n\tint ec_locked = 0;\n\tint result_sent = 0;\n\n\tslapi_pblock_get( pb, SLAPI_BACKEND, &be);\n\tslapi_pblock_get( pb, SLAPI_PLUGIN_PRIVATE, &li );\n\tslapi_pblock_get( pb, SLAPI_TARGET_ADDRESS, &addr );\n\tslapi_pblock_get( pb, SLAPI_MODIFY_MODS, &mods );\n\t}\n\t *\/\n\tif ( MANAGE_ENTRY_BEFORE_DBLOCK(li)) {\n\t\t\/* find and lock the entry we are about to modify *\/\n\t\tif (fixup_tombstone) {\n\t\t\te = find_entry2modify_only_ext( pb, be, addr, TOMBSTONE_INCLUDED, &txn, &result_sent );\n\t\t} else {\n\t\t\te = find_entry2modify( pb, be, addr, &txn, &result_sent );\n\t\t}\n\t\tif (e == NULL) {\n\t\t\tldap_result_code = -1;\n\t\t\tgoto error_return; \/* error result sent by find_entry2modify() *\/\n\t\t}\n\t}\n\n\ttxn.back_txn_txn = NULL; \/* ready to create the child transaction *\/\n\n\t\tif (0 == retry_count) { \/* just once *\/\n\t\t\tif ( !MANAGE_ENTRY_BEFORE_DBLOCK(li)) {\n\t\t\t\t\/* find and lock the entry we are about to modify *\/\n\t\t\t\tif (fixup_tombstone) {\n\t\t\t\t\te = find_entry2modify_only_ext( pb, be, addr, TOMBSTONE_INCLUDED, &txn, &result_sent );\n\t\t\t\t} else {\n\t\t\t\t\te = find_entry2modify( pb, be, addr, &txn, &result_sent );\n\t\t\t\t}\n\t\t\t\tif (e == NULL) {\n\t\t\t\t\tldap_result_code = -1;\n\t\t\t\t\tgoto error_return; \/* error result sent by find_entry2modify() *\/\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif ( !is_fixup_operation && !fixup_tombstone)\n\t\tif (not_an_error) {\n\t\t\t\/* This is mainly used by urp.  Solved conflict is not an error.\n\t\t\t * And we don't want the supplier to halt sending the updates. *\/\n\t\t\tldap_result_code = LDAP_SUCCESS;\n\t\t}\n\t\tif (!result_sent) {\n\t\t\t\/* result is already sent in find_entry. *\/\n\t\t\tslapi_send_ldap_result( pb, ldap_result_code, NULL, ldap_result_message, 0, NULL );\n\t\t}\n\t}\n\n\t\/* free our backups *\/\n\tldap_mods_free(mods_original, 1);\n\tbackentry_free(&original_entry);","target":0,"flaw_line_index":0,"hash":"e58561e5-7076-4908-a510-6fd726f0acf8","idx":"89b98893-5f77-4b81-a25c-2bb87a253dc5"}
{"func_before":"    int i;\n    int ret = 0;\n\n    DefragInit();\n\n    p1 = BuildTestPacket(id, 0, 1, 'A', 8);\n    if (p1 == NULL)\n        goto end;\n    p2 = BuildTestPacket(id, 1, 1, 'B', 8);\n    if (p2 == NULL)\n        goto end;\n    p3 = BuildTestPacket(id, 2, 0, 'C', 3);\n    if (p3 == NULL)\n        goto end;\n\n    if (Defrag(NULL, NULL, p3, NULL) != NULL)\n        goto end;","target":1,"flaw_line_index":0,"hash":"f0e037ee-5a27-42dc-bf13-bff33ef58576","idx":"aeec9fbf-03c8-484a-ad6d-ba8609251bb4"}
{"func_before":"    int i;\n    int ret = 0;\n\n    DefragInit();\n\n    p1 = BuildTestPacket(IPPROTO_ICMP, id, 0, 1, 'A', 8);\n    if (p1 == NULL)\n        goto end;\n    p2 = BuildTestPacket(IPPROTO_ICMP, id, 1, 1, 'B', 8);\n    if (p2 == NULL)\n        goto end;\n    p3 = BuildTestPacket(IPPROTO_ICMP, id, 2, 0, 'C', 3);\n    if (p3 == NULL)\n        goto end;\n\n    if (Defrag(NULL, NULL, p3, NULL) != NULL)\n        goto end;","target":0,"flaw_line_index":0,"hash":"f503645f-0ec8-452f-a4fc-a5dcd167fb58","idx":"2b1a0b09-ece7-47d5-8936-3d63b8166a21"}
{"func_before":"rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tint phy_addr;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct mii_data *miidata = (struct mii_data *) &rq->ifr_ifru;\n\n\tstruct netdev_desc *desc;\n\tint i;\n\n\tphy_addr = np->phy_addr;\n\tswitch (cmd) {\n\tcase SIOCDEVPRIVATE:\n\t\tbreak;\n\n\tcase SIOCDEVPRIVATE + 1:\n\t\tmiidata->out_value = mii_read (dev, phy_addr, miidata->reg_num);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 2:\n\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->in_value);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 3:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 4:\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 5:\n\t\tnetif_stop_queue (dev);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 6:\n\t\tnetif_wake_queue (dev);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 7:\n\t\tprintk\n\t\t    (\"tx_full=%x cur_tx=%lx old_tx=%lx cur_rx=%lx old_rx=%lx\\n\",\n\t\t     netif_queue_stopped(dev), np->cur_tx, np->old_tx, np->cur_rx,\n\t\t     np->old_rx);\n\t\tbreak;\n\tcase SIOCDEVPRIVATE + 8:\n\t\tprintk(\"TX ring:\\n\");\n\t\tfor (i = 0; i < TX_RING_SIZE; i++) {\n\t\t\tdesc = &np->tx_ring[i];\n\t\t\tprintk\n\t\t\t    (\"%02x:cur:%08x next:%08x status:%08x frag1:%08x frag0:%08x\",\n\t\t\t     i,\n\t\t\t     (u32) (np->tx_ring_dma + i * sizeof (*desc)),\n\t\t\t     (u32)le64_to_cpu(desc->next_desc),\n\t\t\t     (u32)le64_to_cpu(desc->status),\n\t\t\t     (u32)(le64_to_cpu(desc->fraginfo) >> 32),\n\t\t\t     (u32)le64_to_cpu(desc->fraginfo));\n\t\t\tprintk (\"\\n\");\n\t\t}\n\t\tprintk (\"\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"f81291d9-d9ee-4c32-9c3e-6949d9adc366","idx":"2bbaf8e7-5059-40c5-9a50-997b89a49414"}
{"func_before":"rio_ioctl (struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tint phy_addr;\n\tstruct netdev_private *np = netdev_priv(dev);\n\tstruct mii_ioctl_data *miidata = if_mii(rq);\n\n\tphy_addr = np->phy_addr;\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tmiidata->phy_id = phy_addr;\n\t\tbreak;\n\tcase SIOCGMIIREG:\n\t\tmiidata->val_out = mii_read (dev, phy_addr, miidata->reg_num);\n\t\tbreak;\n\tcase SIOCSMIIREG:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tmii_write (dev, phy_addr, miidata->reg_num, miidata->val_in);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"ba5a3002-ba73-4ddc-855a-4c3898c7d26c","idx":"0c2c8b62-d90f-4557-adf3-528c779c878d"}
{"func_before":"\t\tunaligned_panic(\"Wheee. Kernel does fpu\/atomic unaligned load\/store.\");\n\t} else {\n\t\tunsigned long addr = compute_effective_address(regs, insn);\n\t\tint err;\n\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, 0, regs, addr);\n\t\tswitch (dir) {\n\t\tcase load:\n\t\t\terr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),\n\t\t\t\t\t\t\t regs),\n\t\t\t\t\t  size, (unsigned long *) addr,","target":1,"flaw_line_index":0,"hash":"1ff854ca-88d5-4ad0-9d21-b61c83a36787","idx":"5b672209-2cf1-44da-b96c-ea1192c80eb7"}
{"func_before":"\t\tunaligned_panic(\"Wheee. Kernel does fpu\/atomic unaligned load\/store.\");\n\t} else {\n\t\tunsigned long addr = compute_effective_address(regs, insn);\n\t\tint err;\n\n\t\tperf_sw_event(PERF_COUNT_SW_ALIGNMENT_FAULTS, 1, regs, addr);\n\t\tswitch (dir) {\n\t\tcase load:\n\t\t\terr = do_int_load(fetch_reg_addr(((insn>>25)&0x1f),\n\t\t\t\t\t\t\t regs),\n\t\t\t\t\t  size, (unsigned long *) addr,","target":0,"flaw_line_index":0,"hash":"5d672517-72e1-42f4-ac10-4119e69ab8b5","idx":"09e29d3d-92fc-4888-996e-0bff36afe796"}
{"func_before":"\t * We will overwrite the from and to address before we output\n\t * the sample.\n\t *\/\n\tperf_prepare_sample(&header, &data, event, &regs);\n\n\tif (perf_output_begin(&handle, event, header.size * (top - at), 1, 1))\n\t\treturn 1;\n\n\tfor (; at < top; at++) {\n\t\tdata.ip\t\t= at->from;\n\t\tdata.addr\t= at->to;","target":1,"flaw_line_index":0,"hash":"930f9095-d54c-4a5a-ad5b-4709711601d2","idx":"e7a2637b-11ab-491b-8186-8e00e2ca3fda"}
{"func_before":"\t * We will overwrite the from and to address before we output\n\t * the sample.\n\t *\/\n\tperf_prepare_sample(&header, &data, event, &regs);\n\n\tif (perf_output_begin(&handle, event, header.size * (top - at), 1))\n\t\treturn 1;\n\n\tfor (; at < top; at++) {\n\t\tdata.ip\t\t= at->from;\n\t\tdata.addr\t= at->to;","target":0,"flaw_line_index":0,"hash":"5a4d83b1-555b-46c0-a954-f03cabc264a7","idx":"d8d3d8f5-1329-40e0-b841-a46292ab99aa"}
{"func_before":"int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\n\tStream_Read_UINT16(s, fields->Len); \/* Len (2 bytes) *\/\n\tStream_Read_UINT16(s, fields->MaxLen); \/* MaxLen (2 bytes) *\/\n\tStream_Read_UINT32(s, fields->BufferOffset); \/* BufferOffset (4 bytes) *\/\n\treturn 1;\n}","target":1,"flaw_line_index":0,"hash":"148c6e54-66c0-4e51-afee-9d2c6331d2e9","idx":"b808325a-212d-4700-aac2-f74d9d710bd9"}
{"func_before":"static int ntlm_read_message_fields(wStream* s, NTLM_MESSAGE_FIELDS* fields)\n{\n\tif (Stream_GetRemainingLength(s) < 8)\n\t\treturn -1;\n\n\tStream_Read_UINT16(s, fields->Len); \/* Len (2 bytes) *\/\n\tStream_Read_UINT16(s, fields->MaxLen); \/* MaxLen (2 bytes) *\/\n\tStream_Read_UINT32(s, fields->BufferOffset); \/* BufferOffset (4 bytes) *\/\n\treturn 1;\n}","target":0,"flaw_line_index":0,"hash":"7d23aeeb-48b2-4b3f-a7fc-aa8547e7066f","idx":"2882eccc-f690-44d9-a4fa-3071af8f06ff"}
{"func_before":"      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      ThrowReaderException(CorruptImageError,\"CorruptImage\");\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)","target":1,"flaw_line_index":0,"hash":"0aa0acd7-7c89-4ab0-bcee-fca1f92e78c3","idx":"82f26bed-d3de-4f4b-aaf8-e9679d853bf4"}
{"func_before":"      (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n        \"  Reading JNG chunk type %c%c%c%c, length: %.20g\",\n        type[0],type[1],type[2],type[3],(double) length);\n\n    if (length > PNG_UINT_31_MAX || count == 0)\n      {\n        if (color_image != (Image *) NULL)\n          color_image=DestroyImage(color_image);\n        if (color_image_info != (Image *) NULL)\n          color_image_info=DestroyImageInfo(color_image_info);\n        ThrowReaderException(CorruptImageError,\"CorruptImage\");\n      }\n\n    p=NULL;\n    chunk=(unsigned char *) NULL;\n\n    if (length != 0)","target":0,"flaw_line_index":0,"hash":"198bda01-f5a0-4122-9a14-bbd05c9c8020","idx":"9f5aa0a9-1b24-4fb7-af52-7481f979f96c"}
{"func_before":"static void nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,\n                            UINT32 scanline)\n{\n\tnsc_encode_argb_to_aycocg_sse2(context, data, scanline);\n\n\tif (context->ChromaSubsamplingLevel > 0)\n\t{\n\t\tnsc_encode_subsampling_sse2(context);\n\t}\n}","target":1,"flaw_line_index":0,"hash":"00f09b71-c15e-481d-9f50-bade7f94ab80","idx":"dbce306b-062b-4cd1-8290-f05f3c74e6a9"}
{"func_before":"static BOOL nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,\n                            UINT32 scanline)\n{\n\tnsc_encode_argb_to_aycocg_sse2(context, data, scanline);\n\n\tif (context->ChromaSubsamplingLevel > 0)\n\t{\n\t\tnsc_encode_subsampling_sse2(context);\n\t}\n\n\treturn TRUE;\n}","target":0,"flaw_line_index":0,"hash":"27dbf1a7-a3d4-4f2d-954c-7977793624f2","idx":"c45a0d53-ff12-4e2c-a776-4d9b7bd83881"}
{"func_before":"static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t\/* This is the main host *\/\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\t\/* That's us.  Be sure we keep track of the peer call number *\/\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&","target":1,"flaw_line_index":0,"hash":"4f0e0c32-5027-43d4-aa36-e6df7e5a475a","idx":"4a6b9a6a-e7a2-4f52-a733-39f4f1ccde63"}
{"func_before":"static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t\/* This is the main host *\/\n\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n\t\t\t\/* That's us.  Be sure we keep track of the peer call number *\/\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&","target":0,"flaw_line_index":0,"hash":"1d2ec8b2-93aa-4f5b-93b7-84b63f83bf33","idx":"c40a7a2c-47d8-4219-9fc6-b436668b68ea"}
{"func_before":"\t\t#if (debug_dhcps)\t\n\t\tprintf(\"\\r\\n[%d]get message DHCP_MESSAGE_TYPE_REQUEST\\n\", xTaskGetTickCount());\n\t\t#endif\n#if (!IS_USE_FIXED_IP) \t\n#if (debug_dhcps)\n\t\tprintf(\"\\r\\ndhcp_server_state_machine=%d\", dhcp_server_state_machine);\n\t\tprintf(\"\\r\\ndhcps_allocated_client_address=%d.%d.%d.%d\", \n\t\t\t\tip4_addr1(&dhcps_allocated_client_address),\n\t\t\t\tip4_addr2(&dhcps_allocated_client_address),\n\t\t\t\tip4_addr3(&dhcps_allocated_client_address),\n\t\t\t\tip4_addr4(&dhcps_allocated_client_address));\n\t\tprintf(\"\\r\\nclient_request_ip=%d.%d.%d.%d\\n\", \n\t\t\t\tip4_addr1(&client_request_ip),\n\t\t\t\tip4_addr2(&client_request_ip),\n\t\t\t\tip4_addr3(&client_request_ip),\n\t\t\t\tip4_addr4(&client_request_ip));\n#endif\t\t\n\t\tif (dhcp_server_state_machine == DHCP_SERVER_STATE_OFFER) {\n\t\t\tif (ip4_addr4(&dhcps_allocated_client_address) != 0) { \n\t\t\t\tif (memcmp((void *)&dhcps_allocated_client_address, (void *)&client_request_ip, 4) == 0) {  \t\n\t\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n\t\t\t  \t} else {\n\t\t\t\t  \tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t\t  \t}\n\t\t\t} else {\n\t\t\t  \tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t\t}  \n\t\t} else if(dhcp_server_state_machine == DHCP_SERVER_STATE_IDLE){\n\t\t\tuint8_t ip_addr4 = check_client_request_ip(&client_request_ip, client_addr);\n\t\t\tif(ip_addr4 > 0){\n\t\t\t\tIP4_ADDR(&dhcps_allocated_client_address, (ip4_addr1(&dhcps_network_id)),\n\t\t\t\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), ip_addr4);\n\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n\t\t\t}else{\n\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t\t}\n\t\t} else {\n\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t}\n#else\t\t\n\t\tif (!(dhcp_server_state_machine == DHCP_SERVER_STATE_ACK ||","target":1,"flaw_line_index":0,"hash":"5f55ccc9-e3e4-4ffd-a0b0-8f791d5aca7c","idx":"f5d3cd86-e8c2-49d2-8eee-0575fcc56e0a"}
{"func_before":"\t\tprintf(\"\\r\\n[%d]get message DHCP_MESSAGE_TYPE_REQUEST\\n\", xTaskGetTickCount());\n\t\t#endif\n#if (!IS_USE_FIXED_IP) \t\n#if (debug_dhcps)\n\t\tprintf(\"\\r\\ndhcp_server_state_machine=%d\", dhcp_server_state_machine);\n#if LWIP_VERSION_MAJOR >= 2\n\t\tprintf(\"\\r\\ndhcps_allocated_client_address=%d.%d.%d.%d\", \n\t\t\t\tip4_addr1(ip_2_ip4(&dhcps_allocated_client_address)),\n\t\t\t\tip4_addr2(ip_2_ip4(&dhcps_allocated_client_address)),\n\t\t\t\tip4_addr3(ip_2_ip4(&dhcps_allocated_client_address)),\n\t\t\t\tip4_addr4(ip_2_ip4(&dhcps_allocated_client_address)));\n\t\tprintf(\"\\r\\nclient_request_ip=%d.%d.%d.%d\\n\", \n\t\t\t\tip4_addr1(ip_2_ip4(&client_request_ip)),\n\t\t\t\tip4_addr2(ip_2_ip4(&client_request_ip)),\n\t\t\t\tip4_addr3(ip_2_ip4(&client_request_ip)),\n\t\t\t\tip4_addr4(ip_2_ip4(&client_request_ip)));\n#else\n\t\tprintf(\"\\r\\ndhcps_allocated_client_address=%d.%d.%d.%d\", \n\t\t\t\tip4_addr1(&dhcps_allocated_client_address),\n\t\t\t\tip4_addr2(&dhcps_allocated_client_address),\n\t\t\t\tip4_addr3(&dhcps_allocated_client_address),\n\t\t\t\tip4_addr4(&dhcps_allocated_client_address));\n\t\tprintf(\"\\r\\nclient_request_ip=%d.%d.%d.%d\\n\", \n\t\t\t\tip4_addr1(&client_request_ip),\n\t\t\t\tip4_addr2(&client_request_ip),\n\t\t\t\tip4_addr3(&client_request_ip),\n\t\t\t\tip4_addr4(&client_request_ip));\n#endif\n\n#endif\t\t\n\n\t\t\/\/ for renew\n\t\tif((*(uint32_t *) dhcp_message_repository->ciaddr != 0) && (*(uint32_t *)&client_request_ip == 0)) {\n\t\t\tmemcpy(&client_request_ip, dhcp_message_repository->ciaddr, sizeof(client_request_ip));\n\t\t}\n\n\t\tif (dhcp_server_state_machine == DHCP_SERVER_STATE_OFFER) {\n\t\t\tuint8_t ip_addr4 = check_client_direct_request_ip(&client_request_ip, client_addr);\n\n\t\t\tif(ip_addr4 > 0){\n#if LWIP_VERSION_MAJOR >= 2\n\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(ip_2_ip4(&dhcps_network_id)),ip4_addr2(ip_2_ip4(&dhcps_network_id)),ip4_addr3(ip_2_ip4(&dhcps_network_id)),ip_addr4);\n\t\t\t\tIP4_ADDR(ip_2_ip4(&dhcps_allocated_client_address), (ip4_addr1(ip_2_ip4(&dhcps_network_id))),\n\t\t\t\t\t\tip4_addr2(ip_2_ip4(&dhcps_network_id)), ip4_addr3(ip_2_ip4(&dhcps_network_id)), ip_addr4);\n#else\n\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),ip_addr4);\n\t\t\t\tIP4_ADDR(&dhcps_allocated_client_address, (ip4_addr1(&dhcps_network_id)),\n\t\t\t\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), ip_addr4);\n#endif\n\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n\t\t\t\tbreak;\n\t\t\t}\n\n#if LWIP_VERSION_MAJOR >= 2\n\t\t\tif (ip4_addr4(ip_2_ip4(&dhcps_allocated_client_address)) != 0) \n#else\n\t\t\tif (ip4_addr4(&dhcps_allocated_client_address) != 0) \n#endif \n\t\t\t{ \n\t\t\t\tif (memcmp((void *)&dhcps_allocated_client_address, (void *)&client_request_ip, 4) == 0) {  \n#if LWIP_VERSION_MAJOR >= 2\n\t\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(ip_2_ip4(&dhcps_network_id)),ip4_addr2(ip_2_ip4(&dhcps_network_id)),ip4_addr3(ip_2_ip4(&dhcps_network_id)),ip4_addr4(ip_2_ip4(&dhcps_allocated_client_address)));\n#else\n\t\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),ip4_addr4(&dhcps_allocated_client_address));\n#endif\n\t\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n\t\t\t  \t} else {\n\t\t\t\t  \tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t\t  \t}\n\t\t\t} else {\n\t\t\t  \tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t\t}  \n#ifdef CONFIG_DHCPS_KEPT_CLIENT_INFO\n\t\t} else if(dhcp_server_state_machine == DHCP_SERVER_STATE_IDLE){\n\t\t\tuint8_t ip_addr4 = check_client_direct_request_ip(&client_request_ip, client_addr);\n\n\t\t\tif(ip_addr4 > 0){\t\t\t\n#if LWIP_VERSION_MAJOR >= 2\n\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(ip_2_ip4(&dhcps_network_id)),ip4_addr2(ip_2_ip4(&dhcps_network_id)),ip4_addr3(ip_2_ip4(&dhcps_network_id)),ip_addr4);\n\t\t\t\tIP4_ADDR(ip_2_ip4(&dhcps_allocated_client_address), (ip4_addr1(ip_2_ip4(&dhcps_network_id))),\n\t\t\t\t\t\tip4_addr2(ip_2_ip4(&dhcps_network_id)), ip4_addr3(ip_2_ip4(&dhcps_network_id)), ip_addr4);\n#else\n\t\t\t\tprintf(\"\\n\\r[%d] DHCP assign ip = %d.%d.%d.%d\\n\", xTaskGetTickCount(), ip4_addr1(&dhcps_network_id),ip4_addr2(&dhcps_network_id),ip4_addr3(&dhcps_network_id),ip_addr4);\n\t\t\t\tIP4_ADDR(&dhcps_allocated_client_address, (ip4_addr1(&dhcps_network_id)),\n\t\t\t\t\t\tip4_addr2(&dhcps_network_id), ip4_addr3(&dhcps_network_id), ip_addr4);\n#endif\n\n\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_ACK;\n\t\t\t}else{\n\t\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t\t}\n#endif\n\t\t} else {\n\t\t\tdhcp_server_state_machine = DHCP_SERVER_STATE_NAK;\n\t\t}\n#else\t\t\n\t\tif (!(dhcp_server_state_machine == DHCP_SERVER_STATE_ACK ||","target":0,"flaw_line_index":0,"hash":"3c15c2a0-6194-4d43-ac0c-b379829b357c","idx":"49b7d917-5590-4355-b50d-42a54c1a5dbd"}
{"func_before":"static int find_high_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=31;i>=0;i--) {\n\t\tif(x&(1<<i)) return i;\n\t}\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"9d33f69c-af5f-4c55-a981-8e84620e1bec","idx":"0ad9e212-efd1-4ad3-a95b-ce44a2965bab"}
{"func_before":"static int find_high_bit(unsigned int x)\n{\n\tint i;\n\tfor(i=31;i>=0;i--) {\n\t\tif(x&(1U<<(unsigned int)i)) return i;\n\t}\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"5f3095bd-7ce8-4f9a-9b09-5160874ec604","idx":"429a88be-042a-4d1e-90d2-b8a7921ed091"}
{"func_before":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input = GetInput(context, node, kInputTensor);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  output->type = input->type;\n\n  return context->ResizeTensor(context, output,\n                               TfLiteIntArrayCopy(input->dims));\n}","target":1,"flaw_line_index":0,"hash":"405e5ff1-0650-44ea-ad7a-62dfa5a5326c","idx":"c2c89156-ec97-4292-9c86-0f40d9f2fdcc"}
{"func_before":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n  const TfLiteTensor* input;\n  TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  output->type = input->type;\n\n  return context->ResizeTensor(context, output,\n                               TfLiteIntArrayCopy(input->dims));\n}","target":0,"flaw_line_index":0,"hash":"80e30ebb-9062-4b22-bf48-e73f794734ed","idx":"495acfbc-e894-4834-ac83-bf169ba0bf26"}
{"func_before":"\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"\/%s\", err_name_ptr);\n\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));","target":1,"flaw_line_index":0,"hash":"9f687956-6ab7-4261-bd1b-315d59cfd927","idx":"0bcc2a25-fada-4ba1-8c18-a46788eb6906"}
{"func_before":"\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"\/%s\", err_name_ptr);\n\tif ((fd = _open_as_other(path_name, req)) == -1) {\n\t\terror(\"Unable to open %s: Permission denied\", path_name);\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));","target":0,"flaw_line_index":0,"hash":"3ed7b4bb-3d82-47c9-9280-e54133e4bcd7","idx":"6e9add76-408c-4edb-82dd-f293b374512f"}
{"func_before":"\n\tParse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0);\n\n\tif (sfsname) {\n\t\t\/* file system ID is ASCII, not numeric, for this server OS *\/\n\t\tstatic char temp[NFSX_V3FHMAX+1];\n\n\t\t\/* Make sure string is null-terminated *\/\n\t\tstrncpy(temp, sfsname, NFSX_V3FHMAX);\n\t\ttemp[sizeof(temp) - 1] = '\\0';\n\t\t\/* Remove trailing spaces *\/\n\t\tspacep = strchr(temp, ' ');\n\t\tif (spacep)\n\t\t\t*spacep = '\\0';\n","target":1,"flaw_line_index":0,"hash":"730c1847-2772-4acd-86a2-8ec27ad978c7","idx":"4f615a1b-369d-435c-929d-8d789b4f9cb8"}
{"func_before":"\n\tParse_fh((const u_char *)dp, len, &fsid, &ino, NULL, &sfsname, 0);\n\n\tif (sfsname) {\n\t\t\/* file system ID is ASCII, not numeric, for this server OS *\/\n\t\tchar temp[NFSX_V3FHMAX+1];\n\t\tu_int stringlen;\n\n\t\t\/* Make sure string is null-terminated *\/\n\t\tstringlen = len;\n\t\tif (stringlen > NFSX_V3FHMAX)\n\t\t\tstringlen = NFSX_V3FHMAX;\n\t\tstrncpy(temp, sfsname, stringlen);\n\t\ttemp[stringlen] = '\\0';\n\t\t\/* Remove trailing spaces *\/\n\t\tspacep = strchr(temp, ' ');\n\t\tif (spacep)\n\t\t\t*spacep = '\\0';\n","target":0,"flaw_line_index":0,"hash":"cd3c25ba-636e-4583-8918-a34d3d5a0131","idx":"94de082e-f9ac-4e99-92db-89c35714cf5d"}
{"func_before":"static void ssdp_recv(int sd)\n{\n\tssize_t len;\n\tstruct sockaddr sa;\n\tsocklen_t salen;\n\tchar buf[MAX_PKT_SIZE];\n\n\tmemset(buf, 0, sizeof(buf));\n\tlen = recvfrom(sd, buf, sizeof(buf), MSG_DONTWAIT, &sa, &salen);\n\tif (len > 0) {\n\t\tbuf[len] = 0;\n\n\t\tif (sa.sa_family != AF_INET)\n\t\t\treturn;\n\n\t\tif (strstr(buf, \"M-SEARCH *\")) {\n\t\t\tsize_t i;","target":1,"flaw_line_index":0,"hash":"0d0bbea0-277a-4ca0-a8cb-950d3cedcbf9","idx":"df304f2f-6b05-4ba4-829b-200721f35d9b"}
{"func_before":"static void ssdp_recv(int sd)\n{\n\tssize_t len;\n\tstruct sockaddr sa;\n\tsocklen_t salen;\n\tchar buf[MAX_PKT_SIZE + 1];\n\n\tmemset(buf, 0, sizeof(buf));\n\tlen = recvfrom(sd, buf, sizeof(buf) - 1, MSG_DONTWAIT, &sa, &salen);\n\tif (len > 0) {\n\t\tif (sa.sa_family != AF_INET)\n\t\t\treturn;\n\n\t\tif (strstr(buf, \"M-SEARCH *\")) {\n\t\t\tsize_t i;","target":0,"flaw_line_index":0,"hash":"0c7583b0-364e-4603-800e-7ccd44ac9b54","idx":"695a7afc-5126-4bcf-8099-cd19172ae31d"}
{"func_before":"\t\t\t\t     int *errcode)\n{\n\tstruct sk_buff *skb;\n\tgfp_t gfp_mask;\n\tlong timeo;\n\tint err;\n\n\tgfp_mask = sk->sk_allocation;\n\tif (gfp_mask & __GFP_WAIT)\n\t\tgfp_mask |= __GFP_REPEAT;\n\n\t\t\tgoto failure;\n\n\t\tif (atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {\n\t\t\tskb = alloc_skb(header_len, gfp_mask);\n\t\t\tif (skb) {\n\t\t\t\tint npages;\n\t\t\t\tint i;\n\n\t\t\t\t\/* No pages, we're done... *\/\n\t\t\t\tif (!data_len)\n\t\t\t\t\tbreak;\n\n\t\t\t\tnpages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;\n\t\t\t\tskb->truesize += data_len;\n\t\t\t\tskb_shinfo(skb)->nr_frags = npages;\n\t\t\t\tfor (i = 0; i < npages; i++) {\n\t\t\t\t\tstruct page *page;\n","target":1,"flaw_line_index":0,"hash":"284ed5d3-6cb2-4183-a171-1ba5a366fcf2","idx":"de5039ac-0847-4ea8-9784-730a9a9c7532"}
{"func_before":"{\n\tstruct sk_buff *skb;\n\tgfp_t gfp_mask;\n\tlong timeo;\n\tint err;\n\tint npages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;\n\n\terr = -EMSGSIZE;\n\tif (npages > MAX_SKB_FRAGS)\n\t\tgoto failure;\n\n\tgfp_mask = sk->sk_allocation;\n\tif (gfp_mask & __GFP_WAIT)\n\t\tgfp_mask |= __GFP_REPEAT;\n\n\t\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\t\tgoto failure;\n\n\t\tif (atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {\n\t\t\tskb = alloc_skb(header_len, gfp_mask);\n\t\t\tif (skb) {\n\t\t\t\tint i;\n\n\t\t\t\t\/* No pages, we're done... *\/\n\t\t\t\tif (!data_len)\n\t\t\t\t\tbreak;\n\n\t\t\t\tskb->truesize += data_len;\n\t\t\t\tskb_shinfo(skb)->nr_frags = npages;\n\t\t\t\tfor (i = 0; i < npages; i++) {\n\t\t\t\t\tstruct page *page;\n","target":0,"flaw_line_index":0,"hash":"ad3f9926-6542-4a70-894d-d2245b41247b","idx":"21d92e2f-e639-4b6e-ad62-d421d1975a9c"}
{"func_before":"\n\tcase IPV6_HOPOPTS:\n\tcase IPV6_RTHDRDSTOPTS:\n\tcase IPV6_RTHDR:\n\tcase IPV6_DSTOPTS:\n\t{\n\n\t\tlock_sock(sk);\n\t\tlen = ipv6_getsockopt_sticky(sk, np->opt,\n\t\t\t\t\t     optname, optval, len);\n\t\trelease_sock(sk);\n\t\t\/* check if ipv6_getsockopt_sticky() returns err code *\/\n\t\tif (len < 0)\n\t\t\treturn len;\n\t\treturn put_user(len, optlen);","target":1,"flaw_line_index":0,"hash":"8f564439-fcd3-41f5-95c5-f92e9a96c5c5","idx":"1623fdd4-f7c2-4e80-a0f6-ddae8db84f4d"}
{"func_before":"\tcase IPV6_HOPOPTS:\n\tcase IPV6_RTHDRDSTOPTS:\n\tcase IPV6_RTHDR:\n\tcase IPV6_DSTOPTS:\n\t{\n\t\tstruct ipv6_txoptions *opt;\n\n\t\tlock_sock(sk);\n\t\topt = rcu_dereference_protected(np->opt, sock_owned_by_user(sk));\n\t\tlen = ipv6_getsockopt_sticky(sk, opt, optname, optval, len);\n\t\trelease_sock(sk);\n\t\t\/* check if ipv6_getsockopt_sticky() returns err code *\/\n\t\tif (len < 0)\n\t\t\treturn len;\n\t\treturn put_user(len, optlen);","target":0,"flaw_line_index":0,"hash":"298dd52b-1cce-4fe4-b8d1-6503bfe78184","idx":"d0c90766-dba7-4747-bcad-389b1dd2a7ba"}
{"func_before":"         \/\/No more data in the receive buffer?\n      } while(error != ERROR_BUFFER_EMPTY);\n   }\n\n   \/\/Re-enable EDMAC interrupts\n   ETHER.EESIPR0 =  ETHER_EESIPR0_TWBIP | ETHER_EESIPR0_FRIP;\n}","target":1,"flaw_line_index":0,"hash":"d8f652fa-2472-4f05-abe9-303738aa7ed2","idx":"000a1e19-ace2-4555-a21a-84270944a73a"}
{"func_before":"         \/\/No more data in the receive buffer?\n      } while(error != ERROR_BUFFER_EMPTY);\n   }\n\n   \/\/Re-enable EDMAC interrupts\n   ETHER.EESIPR0 = ETHER_EESIPR0_TWBIP | ETHER_EESIPR0_FRIP;\n}","target":0,"flaw_line_index":0,"hash":"af0785fe-eda2-4a38-a274-883d07f5110c","idx":"70f6874e-1cc8-425f-9451-60b00b9a2764"}
{"func_before":"        int          GetS32BE (int nPos, bool *pbSuccess)\n        {\n            \/\/*pbSuccess = true;\n\n            if ( nPos < 0 || nPos + 3 >= m_nLen )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];","target":1,"flaw_line_index":0,"hash":"acea9ba5-0542-4f95-b6d4-6cbe1dd83fc8","idx":"08ae8167-80b4-40c0-b066-378326f092e0"}
{"func_before":"        int          GetS32BE (const unsigned int& nPos, bool *pbSuccess)\n        {\n            \/\/*pbSuccess = true;\n\n            if ( m_nLen < 4 || nPos > (m_nLen - 4) )\n            {\n                *pbSuccess = false;\n                return 0;\n            }\n            int nRes = m_sFile[ nPos ];","target":0,"flaw_line_index":0,"hash":"1ede2eac-dca4-406e-9f13-5d0079d31a54","idx":"173248cc-19f7-4a1c-a6f0-87f7205c921f"}
{"func_before":"\t * so that we are sure __es_shrink() is done with the inode before it\n\t * is reclaimed.\n\t *\/\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end, &reserved, es);\n\tif (es && !es->es_len)\n\t\t__es_free_extent(es);\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\tif (err)\n\t\tgoto retry;\n\n\text4_es_print_tree(inode);","target":1,"flaw_line_index":0,"hash":"e616dede-ccc3-4b0a-8c9e-dc6c06ccbf40","idx":"97be56cf-167c-4869-a533-4e0c843fd89e"}
{"func_before":"\t * so that we are sure __es_shrink() is done with the inode before it\n\t * is reclaimed.\n\t *\/\n\twrite_lock(&EXT4_I(inode)->i_es_lock);\n\terr = __es_remove_extent(inode, lblk, end, &reserved, es);\n\t\/* Free preallocated extent if it didn't get used. *\/\n\tif (es) {\n\t\tif (!es->es_len)\n\t\t\t__es_free_extent(es);\n\t\tes = NULL;\n\t}\n\twrite_unlock(&EXT4_I(inode)->i_es_lock);\n\tif (err)\n\t\tgoto retry;\n\n\text4_es_print_tree(inode);","target":0,"flaw_line_index":0,"hash":"584b2817-3a96-479e-b31a-dad61025cb91","idx":"28aa7f5f-818c-4718-a16b-406a1e6b5151"}
{"func_before":"void Context::onUpstreamConnectionClose(PeerType peer_type) {\n  if (wasm_->onUpstreamConnectionClose_) {\n    wasm_->onUpstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}","target":1,"flaw_line_index":0,"hash":"45e9970e-42e1-44f4-b21b-5d128255bede","idx":"160bc1b2-8a8a-413a-870a-48032fb6c097"}
{"func_before":"void Context::onUpstreamConnectionClose(PeerType peer_type) {\n  if (in_vm_context_created_ && wasm_->onUpstreamConnectionClose_) {\n    wasm_->onUpstreamConnectionClose_(this, id_, static_cast<uint32_t>(peer_type));\n  }\n}","target":0,"flaw_line_index":0,"hash":"ef4155e9-f1ba-427c-bf8f-7304e4b72996","idx":"0643d899-ad2f-484d-bf79-3664d75d670e"}
{"func_before":"void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,\n\t\t\tint length, int offset, int total_size)\n{\n\tstruct oz_port *port = hport;\n\tstruct urb *urb;\n\tint err = 0;\n\n\t       length, offset, total_size);\n\turb = oz_find_urb_by_id(port, 0, req_id);\n\tif (!urb)\n\t\treturn;\n\tif (status == 0) {\n\t\tint copy_len;\n\t\tint required_size = urb->transfer_buffer_length;\n\n\t\tif (required_size > total_size)\n\t\t\trequired_size = total_size;\n\t\tcopy_len = required_size-offset;\n\t\tif (length <= copy_len)","target":1,"flaw_line_index":0,"hash":"9f3b73a4-bbae-4712-ab92-516280188554","idx":"4945c057-8d8f-4aca-832a-44dd1d8c486c"}
{"func_before":"void oz_hcd_get_desc_cnf(void *hport, u8 req_id, u8 status, const u8 *desc,\n\t\t\tu8 length, u16 offset, u16 total_size)\n{\n\tstruct oz_port *port = hport;\n\tstruct urb *urb;\n\tint err = 0;\n\n\t       length, offset, total_size);\n\turb = oz_find_urb_by_id(port, 0, req_id);\n\tif (!urb)\n\t\treturn;\n\tif (status == 0) {\n\t\tunsigned int copy_len;\n\t\tunsigned int required_size = urb->transfer_buffer_length;\n\n\t\tif (required_size > total_size)\n\t\t\trequired_size = total_size;\n\t\tcopy_len = required_size-offset;\n\t\tif (length <= copy_len)","target":0,"flaw_line_index":0,"hash":"183b1a67-768f-4097-82c3-0f451ebc57db","idx":"6231a92d-60f3-495d-ab54-55f8c0db6354"}
{"func_before":"\t\t    else\n\t\t\tdprev->df_next = dp;\n\t\t}\n\t    }\n\n\t    \/\/ Adjust marks.  This will change the following entries!\n\t    if (added != 0)\n\t    {\n\t\tmark_adjust(lnum, lnum + count - 1, (long)MAXLNUM, (long)added);\n\t\tif (curwin->w_cursor.lnum >= lnum)\n\t\t{\n\t\t    \/\/ Adjust the cursor position if it's in\/after the changed\n\t\t    \/\/ lines.\n#ifdef FEAT_FOLDING\n\t\tdiff_fold_update(dfree, idx_to);\n#endif\n\t\tvim_free(dfree);\n\t    }\n\t    else\n\t\t\/\/ mark_adjust() may have changed the count in a wrong way\n\t\tdp->df_count[idx_to] = new_count;\n\n\t    \/\/ When changing the current buffer, keep track of line numbers\n\t    if (idx_cur == idx_to)","target":1,"flaw_line_index":0,"hash":"bd0cf494-9eb7-4b70-b297-16bae78c5d7f","idx":"716c0eb9-226d-4c3c-8fef-21a8f0c723d1"}
{"func_before":"\t\t\tcurtab->tp_first_diff = dp;\n\t\t    else\n\t\t\tdprev->df_next = dp;\n\t\t}\n\t    }\n\n\t    if (added != 0)\n\t    {\n\t\t\/\/ Adjust marks.  This will change the following entries!\n\t\tmark_adjust(lnum, lnum + count - 1, (long)MAXLNUM, (long)added);\n\t\tif (curwin->w_cursor.lnum >= lnum)\n\t\t{\n\t\t    \/\/ Adjust the cursor position if it's in\/after the changed\n\t\t    \/\/ lines.\n#ifdef FEAT_FOLDING\n\t\tdiff_fold_update(dfree, idx_to);\n#endif\n\t\tvim_free(dfree);\n\t    }\n\n\t    \/\/ mark_adjust() may have made \"dp\" invalid.  We don't know where\n\t    \/\/ to continue then, bail out.\n\t    if (added != 0 && !valid_diff(dp))\n\t\tbreak;\n\n\t    if (dfree == NULL)\n\t\t\/\/ mark_adjust() may have changed the count in a wrong way\n\t\tdp->df_count[idx_to] = new_count;\n\n\t    \/\/ When changing the current buffer, keep track of line numbers\n\t    if (idx_cur == idx_to)","target":0,"flaw_line_index":0,"hash":"3bf0616a-48a2-409e-9f21-091a4f7282b4","idx":"3c561adb-9e2f-4195-b427-2034d73fb321"}
{"func_before":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  int num_inputs = NumInputs(node);\n  TF_LITE_ENSURE(context, num_inputs >= 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1 = GetInput(context, node, kInputTensor1);\n  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);\n  output->type = input1->type;\n\n  \/\/ Check that all input tensors have the same shape and type.\n  for (int i = kInputTensor1 + 1; i < num_inputs; ++i) {\n    const TfLiteTensor* input = GetInput(context, node, i);\n    TF_LITE_ENSURE(context, HaveSameShapes(input1, input));\n    TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input->type);\n  }\n\n  \/\/ Use the first input node's dimension to be the dimension of the output","target":1,"flaw_line_index":0,"hash":"5949b92f-b0f6-49c2-9732-db082437161d","idx":"24293e76-cb22-45cd-ada4-4adfbdbeb816"}
{"func_before":"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {\n  int num_inputs = NumInputs(node);\n  TF_LITE_ENSURE(context, num_inputs >= 2);\n  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);\n\n  const TfLiteTensor* input1;\n  TF_LITE_ENSURE_OK(context,\n                    GetInputSafe(context, node, kInputTensor1, &input1));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n  output->type = input1->type;\n\n  \/\/ Check that all input tensors have the same shape and type.\n  for (int i = kInputTensor1 + 1; i < num_inputs; ++i) {\n    const TfLiteTensor* input;\n    TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, i, &input));\n    TF_LITE_ENSURE(context, HaveSameShapes(input1, input));\n    TF_LITE_ENSURE_TYPES_EQ(context, input1->type, input->type);\n  }\n\n  \/\/ Use the first input node's dimension to be the dimension of the output","target":0,"flaw_line_index":0,"hash":"141a616e-e00e-4c63-aaf7-8015a3f0de13","idx":"d0c5b19f-7449-4a3f-a174-5694cd9ab1d4"}
{"func_before":"    CUdevice_attribute attribute, CUdevice device) {\n  int val;\n  CUresult res = cuDeviceGetAttribute(&val, attribute, device);\n  if (res != CUDA_SUCCESS) {\n    return tsl::Status(\n        port::error::INTERNAL,\n        absl::StrFormat(\"failed to get device attribute %d for device %d: %s\",\n                        attribute, device, ToString(res)));\n  }\n  return val;\n}","target":1,"flaw_line_index":0,"hash":"4932ec5c-6fc7-404a-a3e3-f84910f76c9a","idx":"3e6f3d66-e8db-487c-8aa7-194f06e15446"}
{"func_before":"    CUdevice_attribute attribute, CUdevice device) {\n  int val;\n  CUresult res = cuDeviceGetAttribute(&val, attribute, device);\n  if (res != CUDA_SUCCESS) {\n    return tsl::Status(\n        tsl::error::INTERNAL,\n        absl::StrFormat(\"failed to get device attribute %d for device %d: %s\",\n                        attribute, device, ToString(res)));\n  }\n  return val;\n}","target":0,"flaw_line_index":0,"hash":"c3a5c988-a948-4ba4-880f-ea3c0edfa7cd","idx":"33caf0f5-027c-4505-9641-16835d95d0bf"}
{"func_before":"\n    IedConnection con = IedConnection_create();\n\n    IedConnection_connect(con, &error, hostname, tcpPort);\n\n    if (error == IED_ERROR_OK) {\n\n\n        \/************************\n         * Direct control\n         ***********************\/\n\n        ControlObjectClient control\n            = ControlObjectClient_create(\"simpleIOGenericIO\/GGIO1.SPCSO1\", con);\n\n        MmsValue* ctlVal = MmsValue_newBoolean(true);\n\n        ControlObjectClient_setOrigin(control, NULL, 3);\n\n        if (ControlObjectClient_operate(control, ctlVal, 0 \/* operate now *\/)) {\n            printf(\"simpleIOGenericIO\/GGIO1.SPCSO1 operated successfully\\n\");\n        }\n        else {\n            printf(\"failed to operate simpleIOGenericIO\/GGIO1.SPCSO1\\n\");\n        }\n\n        MmsValue_delete(ctlVal);\n\n        ControlObjectClient_destroy(control);\n\n        \/* Check if status value has changed *\/\n\n        MmsValue* stVal = IedConnection_readObject(con, &error, \"simpleIOGenericIO\/GGIO1.SPCSO1.stVal\", IEC61850_FC_ST);\n\n        if (error == IED_ERROR_OK) {\n            bool state = MmsValue_getBoolean(stVal);\n            MmsValue_delete(stVal);\n\n            printf(\"New status of simpleIOGenericIO\/GGIO1.SPCSO1.stVal: %i\\n\", state);\n        }\n        else {\n            printf(\"Reading status for simpleIOGenericIO\/GGIO1.SPCSO1 failed!\\n\");\n        }\n\n\n        \/************************\n         * Select before operate\n         ***********************\/\n\n        control = ControlObjectClient_create(\"simpleIOGenericIO\/GGIO1.SPCSO2\", con);\n\n        if (ControlObjectClient_select(control)) {\n\n            ctlVal = MmsValue_newBoolean(true);\n\n            if (ControlObjectClient_operate(control, ctlVal, 0 \/* operate now *\/)) {\n                printf(\"simpleIOGenericIO\/GGIO1.SPCSO2 operated successfully\\n\");\n            }\n            else {\n                printf(\"failed to operate simpleIOGenericIO\/GGIO1.SPCSO2!\\n\");\n            }\n\n            MmsValue_delete(ctlVal);\n        }\n        else {\n            printf(\"failed to select simpleIOGenericIO\/GGIO1.SPCSO2!\\n\");\n        }\n\n        ControlObjectClient_destroy(control);\n\n\n        \/****************************************\n         * Direct control with enhanced security\n         ****************************************\/\n\n        control = ControlObjectClient_create(\"simpleIOGenericIO\/GGIO1.SPCSO3\", con);\n\n        ControlObjectClient_setCommandTerminationHandler(control, commandTerminationHandler, NULL);\n\n        ctlVal = MmsValue_newBoolean(true);\n\n        if (ControlObjectClient_operate(control, ctlVal, 0 \/* operate now *\/)) {\n            printf(\"simpleIOGenericIO\/GGIO1.SPCSO3 operated successfully\\n\");\n        }\n        else {\n            printf(\"failed to operate simpleIOGenericIO\/GGIO1.SPCSO3\\n\");\n        }\n\n        MmsValue_delete(ctlVal);\n\n        \/* Wait for command termination message *\/\n        Thread_sleep(1000);\n\n        ControlObjectClient_destroy(control);\n\n        \/* Check if status value has changed *\/\n\n       stVal = IedConnection_readObject(con, &error, \"simpleIOGenericIO\/GGIO1.SPCSO3.stVal\", IEC61850_FC_ST);\n\n        if (error == IED_ERROR_OK) {\n            bool state = MmsValue_getBoolean(stVal);\n\n            printf(\"New status of simpleIOGenericIO\/GGIO1.SPCSO3.stVal: %i\\n\", state);\n\n            MmsValue_delete(stVal);\n        }\n        else {\n            printf(\"Reading status for simpleIOGenericIO\/GGIO1.SPCSO3 failed!\\n\");\n        }\n\n        \/***********************************************\n         * Select before operate with enhanced security\n         ***********************************************\/\n\n        control = ControlObjectClient_create(\"simpleIOGenericIO\/GGIO1.SPCSO4\", con);\n\n        ControlObjectClient_setCommandTerminationHandler(control, commandTerminationHandler, NULL);\n\n        ctlVal = MmsValue_newBoolean(true);\n\n        if (ControlObjectClient_selectWithValue(control, ctlVal)) {\n\n            if (ControlObjectClient_operate(control, ctlVal, 0 \/* operate now *\/)) {\n                printf(\"simpleIOGenericIO\/GGIO1.SPCSO4 operated successfully\\n\");\n            }\n            else {\n                printf(\"failed to operate simpleIOGenericIO\/GGIO1.SPCSO4!\\n\");\n            }\n\n        }\n        else {\n            printf(\"failed to select simpleIOGenericIO\/GGIO1.SPCSO4!\\n\");\n        }\n\n        MmsValue_delete(ctlVal);\n\n        \/* Wait for command termination message *\/\n        Thread_sleep(1000);\n\n        ControlObjectClient_destroy(control);\n\n\n        \/*********************************************************************\n         * Direct control with enhanced security (expect CommandTermination-)\n         *********************************************************************\/\n\n        control = ControlObjectClient_create(\"simpleIOGenericIO\/GGIO1.SPCSO9\", con);\n\n        ControlObjectClient_setCommandTerminationHandler(control, commandTerminationHandler, NULL);\n\n        ctlVal = MmsValue_newBoolean(true);\n\n        if (ControlObjectClient_operate(control, ctlVal, 0 \/* operate now *\/)) {\n            printf(\"simpleIOGenericIO\/GGIO1.SPCSO9 operated successfully\\n\");\n        }\n        else {\n            printf(\"failed to operate simpleIOGenericIO\/GGIO1.SPCSO9\\n\");\n        }\n\n        MmsValue_delete(ctlVal);\n\n        \/* Wait for command termination message *\/\n        Thread_sleep(1000);\n\n        ControlObjectClient_destroy(control);\n\n\n        IedConnection_close(con);\n    }\n    else {\n    \tprintf(\"Connection failed!\\n\");","target":1,"flaw_line_index":0,"hash":"36e56542-12cc-4746-8723-ea9da65d49c3","idx":"cfac08ad-540b-45e6-95c9-3ce7392c0274"}
{"func_before":"\n    IedConnection con = IedConnection_create();\n\n    IedConnection_connect(con, &error, hostname, tcpPort);\n\n    if (error == IED_ERROR_OK)\n    {\n        MmsValue* ctlVal = NULL;\n        MmsValue* stVal = NULL;\n\n        \/************************\n         * Direct control\n         ***********************\/\n\n        ControlObjectClient control\n            = ControlObjectClient_create(\"simpleIOGenericIO\/GGIO1.SPCSO1\", con);\n\n        if (control)\n        {\n            ctlVal = MmsValue_newBoolean(true);\n\n            ControlObjectClient_setOrigin(control, NULL, 3);\n\n            if (ControlObjectClient_operate(control, ctlVal, 0 \/* operate now *\/)) {\n                printf(\"simpleIOGenericIO\/GGIO1.SPCSO1 operated successfully\\n\");\n            }\n            else {\n                printf(\"failed to operate simpleIOGenericIO\/GGIO1.SPCSO1\\n\");\n            }\n\n            MmsValue_delete(ctlVal);\n\n            ControlObjectClient_destroy(control);\n\n            \/* Check if status value has changed *\/\n\n            stVal = IedConnection_readObject(con, &error, \"simpleIOGenericIO\/GGIO1.SPCSO1.stVal\", IEC61850_FC_ST);\n\n            if (error == IED_ERROR_OK) {\n                bool state = MmsValue_getBoolean(stVal);\n                MmsValue_delete(stVal);\n\n                printf(\"New status of simpleIOGenericIO\/GGIO1.SPCSO1.stVal: %i\\n\", state);\n            }\n            else {\n                printf(\"Reading status for simpleIOGenericIO\/GGIO1.SPCSO1 failed!\\n\");\n            }\n\n        }\n        else {\n            printf(\"Control object simpleIOGenericIO\/GGIO1.SPCSO1 not found in server\\n\");\n        }\n\n        \/************************\n         * Select before operate\n         ***********************\/\n\n        control = ControlObjectClient_create(\"simpleIOGenericIO\/GGIO1.SPCSO2\", con);\n\n        if (control)\n        {\n            if (ControlObjectClient_select(control)) {\n\n                ctlVal = MmsValue_newBoolean(true);\n\n                if (ControlObjectClient_operate(control, ctlVal, 0 \/* operate now *\/)) {\n                    printf(\"simpleIOGenericIO\/GGIO1.SPCSO2 operated successfully\\n\");\n                }\n                else {\n                    printf(\"failed to operate simpleIOGenericIO\/GGIO1.SPCSO2!\\n\");\n                }\n\n                MmsValue_delete(ctlVal);\n            }\n            else {\n                printf(\"failed to select simpleIOGenericIO\/GGIO1.SPCSO2!\\n\");\n            }\n\n            ControlObjectClient_destroy(control);\n        }\n        else {\n            printf(\"Control object simpleIOGenericIO\/GGIO1.SPCSO2 not found in server\\n\");\n        }\n\n        \/****************************************\n         * Direct control with enhanced security\n         ****************************************\/\n\n        control = ControlObjectClient_create(\"simpleIOGenericIO\/GGIO1.SPCSO3\", con);\n\n        if (control)\n        {\n            ControlObjectClient_setCommandTerminationHandler(control, commandTerminationHandler, NULL);\n\n            ctlVal = MmsValue_newBoolean(true);\n\n            if (ControlObjectClient_operate(control, ctlVal, 0 \/* operate now *\/)) {\n                printf(\"simpleIOGenericIO\/GGIO1.SPCSO3 operated successfully\\n\");\n            }\n            else {\n                printf(\"failed to operate simpleIOGenericIO\/GGIO1.SPCSO3\\n\");\n            }\n\n            MmsValue_delete(ctlVal);\n\n            \/* Wait for command termination message *\/\n            Thread_sleep(1000);\n\n            ControlObjectClient_destroy(control);\n\n            \/* Check if status value has changed *\/\n\n            stVal = IedConnection_readObject(con, &error, \"simpleIOGenericIO\/GGIO1.SPCSO3.stVal\", IEC61850_FC_ST);\n\n            if (error == IED_ERROR_OK) {\n                bool state = MmsValue_getBoolean(stVal);\n\n                printf(\"New status of simpleIOGenericIO\/GGIO1.SPCSO3.stVal: %i\\n\", state);\n\n                MmsValue_delete(stVal);\n            }\n            else {\n                printf(\"Reading status for simpleIOGenericIO\/GGIO1.SPCSO3 failed!\\n\");\n            }\n        }\n        else {\n            printf(\"Control object simpleIOGenericIO\/GGIO1.SPCSO3 not found in server\\n\");\n        }\n\n        \/***********************************************\n         * Select before operate with enhanced security\n         ***********************************************\/\n\n        control = ControlObjectClient_create(\"simpleIOGenericIO\/GGIO1.SPCSO4\", con);\n\n        if (control)\n        {\n            ControlObjectClient_setCommandTerminationHandler(control, commandTerminationHandler, NULL);\n\n            ctlVal = MmsValue_newBoolean(true);\n\n            if (ControlObjectClient_selectWithValue(control, ctlVal)) {\n\n                if (ControlObjectClient_operate(control, ctlVal, 0 \/* operate now *\/)) {\n                    printf(\"simpleIOGenericIO\/GGIO1.SPCSO4 operated successfully\\n\");\n                }\n                else {\n                    printf(\"failed to operate simpleIOGenericIO\/GGIO1.SPCSO4!\\n\");\n                }\n\n            }\n            else {\n                printf(\"failed to select simpleIOGenericIO\/GGIO1.SPCSO4!\\n\");\n            }\n\n            MmsValue_delete(ctlVal);\n\n            \/* Wait for command termination message *\/\n            Thread_sleep(1000);\n\n            ControlObjectClient_destroy(control);\n        }\n        else {\n            printf(\"Control object simpleIOGenericIO\/GGIO1.SPCSO4 not found in server\\n\");\n        }\n\n        \/*********************************************************************\n         * Direct control with enhanced security (expect CommandTermination-)\n         *********************************************************************\/\n\n        control = ControlObjectClient_create(\"simpleIOGenericIO\/GGIO1.SPCSO9\", con);\n\n        if (control)\n        {\n            ControlObjectClient_setCommandTerminationHandler(control, commandTerminationHandler, NULL);\n\n            ctlVal = MmsValue_newBoolean(true);\n\n            if (ControlObjectClient_operate(control, ctlVal, 0 \/* operate now *\/)) {\n                printf(\"simpleIOGenericIO\/GGIO1.SPCSO9 operated successfully\\n\");\n            }\n            else {\n                printf(\"failed to operate simpleIOGenericIO\/GGIO1.SPCSO9\\n\");\n            }\n\n            MmsValue_delete(ctlVal);\n\n            \/* Wait for command termination message *\/\n            Thread_sleep(1000);\n\n            ControlObjectClient_destroy(control);\n        }\n        else {\n            printf(\"Control object simpleIOGenericIO\/GGIO1.SPCSO9 not found in server\\n\");\n        }\n\n        IedConnection_close(con);\n    }\n    else {\n    \tprintf(\"Connection failed!\\n\");","target":0,"flaw_line_index":0,"hash":"4585a2f5-35a9-487a-ace0-e68de2d045ac","idx":"a3c3d54b-0f5c-4bed-8a13-337ff10c4080"}
{"func_before":"static bool check_block(struct file *fp, u32 *size4, loff_t *pos, u32 *offset,\n\t\t\tunsigned expected_size, const char* expected_sha256)\n{\n\tksu_kernel_read_compat(fp, size4, 0x4, pos); \/\/ signer-sequence length\n\tksu_kernel_read_compat(fp, size4, 0x4, pos); \/\/ signer length\n\tksu_kernel_read_compat(fp, size4, 0x4, pos); \/\/ signed data length\n\n\t*offset += 0x4 * 2;\n\n\tif (*size4 == expected_size) {\n\t\t*offset += *size4;\n\n\t\t#define CERT_MAX_LENGTH 1024\n\t\tchar cert[CERT_MAX_LENGTH];\n\t\tif (*size4 > CERT_MAX_LENGTH) {\n\t\t\tpr_info(\"cert length overlimit\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tchar hash_str[SHA256_DIGEST_SIZE * 2 + 1];\n\t\thash_str[SHA256_DIGEST_SIZE * 2] = '\\0';\n\n\t\tbin2hex(hash_str, digest, SHA256_DIGEST_SIZE);\n\t\tpr_info(\"sha256: %s, expected: %s\\n\", hash_str, expected_sha256);\n\t\tif (strcmp(expected_sha256, hash_str) == 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;","target":1,"flaw_line_index":0,"hash":"ea3fa588-d67f-4aaf-a609-385db2ac42a8","idx":"c3d7afb6-e0ae-4250-a3ce-845cf985397e"}
{"func_before":"static bool check_block(struct file *fp, u32 *size4, loff_t *pos, u32 *offset,\n\t\t\tunsigned expected_size, const char *expected_sha256)\n{\n\tksu_kernel_read_compat(fp, size4, 0x4, pos); \/\/ signer-sequence length\n\tksu_kernel_read_compat(fp, size4, 0x4, pos); \/\/ signer length\n\tksu_kernel_read_compat(fp, size4, 0x4, pos); \/\/ signed data length\n\n\t*offset += 0x4 * 2;\n\n\tif (*size4 == expected_size) {\n\t\t*offset += *size4;\n\n#define CERT_MAX_LENGTH 1024\n\t\tchar cert[CERT_MAX_LENGTH];\n\t\tif (*size4 > CERT_MAX_LENGTH) {\n\t\t\tpr_info(\"cert length overlimit\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tchar hash_str[SHA256_DIGEST_SIZE * 2 + 1];\n\t\thash_str[SHA256_DIGEST_SIZE * 2] = '\\0';\n\n\t\tbin2hex(hash_str, digest, SHA256_DIGEST_SIZE);\n\t\tpr_info(\"sha256: %s, expected: %s\\n\", hash_str,\n\t\t\texpected_sha256);\n\t\tif (strcmp(expected_sha256, hash_str) == 0) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;","target":0,"flaw_line_index":0,"hash":"062b4bbc-11ed-4a70-aefd-0a9f59edf297","idx":"f4cf6bb4-93e2-4df9-9fe0-c9f86014967f"}
{"func_before":"\t\tif (p->tiff_ifd[raw].bytes && p->tiff_bps != 14 && p->tiff_bps != 2048)\n\t\t\tp->is_raw = 0;\n\tif (!p->dng_version && p->tiff_bps == 8 && p->tiff_compress == 1 &&\n\t\tp->tiff_ifd[raw].phint == 1) p->is_raw = 0;\n\tif (p->tiff_bps == 8 && p->tiff_samples == 4) p->is_raw = 0;\n\tfor (i=0; i < (int)p->tiff_nifds; i++)\n\t\tif (i != raw && p->tiff_ifd[i].samples == max_samp &&\n\t\t\tp->tiff_ifd[i].width * p->tiff_ifd[i].height \/ SQR(p->tiff_ifd[i].bps+1) >\n\t\t\t(int)(p->thumb_width *       p->thumb_height \/ SQR(p->thumb_misc+1))) {\n\t\t\tp->thumb_width  = p->tiff_ifd[i].width;\n\t\t\tp->thumb_height = p->tiff_ifd[i].height;\n\t\t\tp->thumb_offset = p->tiff_ifd[i].offset;\n\t\t\tp->thumb_length = p->tiff_ifd[i].bytes;\n\t\t\tp->thumb_misc   = p->tiff_ifd[i].bps;\n\t\t\tthm = i;\n\t\t}\n\tif (thm >= 0) {\n\t\tp->thumb_misc |= p->tiff_ifd[thm].samples << 5;\n\t\tswitch (p->tiff_ifd[thm].comp) {\n\t\tcase 0:\n\t\t\tp->write_thumb = &DCR_CLASS dcr_layer_thumb;","target":1,"flaw_line_index":0,"hash":"4585dad8-360f-404d-915a-b99ab87b3bf5","idx":"6eeda71e-2cc4-4279-b6d7-0919424801ef"}
{"func_before":"\t\t\tp->is_raw = 0;\n\tif (!p->dng_version && p->tiff_bps == 8 && p->tiff_compress == 1 &&\n\t\tp->tiff_ifd[raw].phint == 1) p->is_raw = 0;\n\tif (p->tiff_bps == 8 && p->tiff_samples == 4) p->is_raw = 0;\n\tfor (i=0; i < (int)p->tiff_nifds; i++)\n    {\n        int sqr_1 = SQR(p->tiff_ifd[i].bps+1); if (sqr_1 == 0) sqr_1 = 1;\n        int sqr_2 = SQR(p->thumb_misc+1); if (sqr_2 == 0) sqr_2 = 1;\n\t\tif (i != raw && p->tiff_ifd[i].samples == max_samp &&\n            p->tiff_ifd[i].width * p->tiff_ifd[i].height \/ sqr_1 >\n            (int)(p->thumb_width *       p->thumb_height \/ sqr_2)) {\n\t\t\tp->thumb_width  = p->tiff_ifd[i].width;\n\t\t\tp->thumb_height = p->tiff_ifd[i].height;\n\t\t\tp->thumb_offset = p->tiff_ifd[i].offset;\n\t\t\tp->thumb_length = p->tiff_ifd[i].bytes;\n\t\t\tp->thumb_misc   = p->tiff_ifd[i].bps;\n\t\t\tthm = i;\n\t\t}\n    }\n\tif (thm >= 0) {\n\t\tp->thumb_misc |= p->tiff_ifd[thm].samples << 5;\n\t\tswitch (p->tiff_ifd[thm].comp) {\n\t\tcase 0:\n\t\t\tp->write_thumb = &DCR_CLASS dcr_layer_thumb;","target":0,"flaw_line_index":0,"hash":"8eb8a91a-7187-49cf-8afd-094cb86cc457","idx":"f62a23ce-c809-44b1-aa83-881bc4cd5828"}
{"func_before":"\t\treturn NULL;\n\n\tname = kasprintf(GFP_KERNEL, \"%s-%u\", type, index);\n\tif (!name) {\n\t\tof_node_put(ports);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tnp = of_get_child_by_name(ports, name);\n\tkfree(name);\n\tof_node_put(ports);\n","target":1,"flaw_line_index":0,"hash":"e95119c2-2047-44f7-8f96-5dc71211bf49","idx":"c18e3710-f273-48a7-915c-6ce0cd74c85d"}
{"func_before":"\t\treturn NULL;\n\n\tname = kasprintf(GFP_KERNEL, \"%s-%u\", type, index);\n\tif (!name) {\n\t\tof_node_put(ports);\n\t\treturn NULL;\n\t}\n\tnp = of_get_child_by_name(ports, name);\n\tkfree(name);\n\tof_node_put(ports);\n","target":0,"flaw_line_index":0,"hash":"5960ec4e-1890-406b-9471-068a37c4699d","idx":"e824bf3c-6608-4c23-8c59-d2fd50d90a63"}
{"func_before":"static PyObject *__pyx_pf_17clickhouse_driver_6varint_2read_varint(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_f) {\n  Py_ssize_t __pyx_v_shift;\n  Py_ssize_t __pyx_v_result;\n  unsigned char __pyx_v_i;\n  PyObject *__pyx_v_read_one = NULL;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  unsigned char __pyx_t_4;\n  int __pyx_t_5;\n  __Pyx_RefNannySetupContext(\"read_varint\", 0);\n\n  \/* \"clickhouse_driver\/varint.pyx\":33\n *     Reads integer of variable length using LEB128.\n *     \"\"\"\n *     cdef Py_ssize_t shift = 0             # <<<<<<<<<<<<<<\n *     cdef Py_ssize_t result = 0\n *     cdef unsigned char i\n *\/\n  __pyx_v_shift = 0;\n\n  \/* \"clickhouse_driver\/varint.pyx\":34\n *     \"\"\"\n *     cdef Py_ssize_t shift = 0\n *     cdef Py_ssize_t result = 0             # <<<<<<<<<<<<<<\n *     cdef unsigned char i\n * \n *\/\n  __pyx_v_result = 0;\n\n  \/* \"clickhouse_driver\/varint.pyx\":37\n *     cdef unsigned char i\n * \n *     read_one = f.read_one             # <<<<<<<<<<<<<<\n * \n *     while True:\n *\/\n  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_f, __pyx_n_s_read_one); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 37, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_read_one = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  \/* \"clickhouse_driver\/varint.pyx\":39\n *     read_one = f.read_one\n * \n *     while True:             # <<<<<<<<<<<<<<\n *         i = read_one()\n *         result |= (i & 0x7f) << shift\n *\/\n  while (1) {\n\n    \/* \"clickhouse_driver\/varint.pyx\":40\n * \n *     while True:\n *         i = read_one()             # <<<<<<<<<<<<<<\n *         result |= (i & 0x7f) << shift\n *         shift += 7\n        __Pyx_DECREF_SET(__pyx_t_2, function);\n      }\n    }\n    __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);\n    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 40, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __pyx_t_4 = __Pyx_PyInt_As_unsigned_char(__pyx_t_1); if (unlikely((__pyx_t_4 == (unsigned char)-1) && PyErr_Occurred())) __PYX_ERR(0, 40, __pyx_L1_error)\n    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n    __pyx_v_i = __pyx_t_4;\n\n    \/* \"clickhouse_driver\/varint.pyx\":41\n *     while True:\n *         i = read_one()\n *         result |= (i & 0x7f) << shift             # <<<<<<<<<<<<<<\n *         shift += 7\n *         if i < 0x80:\n *\/\n    __pyx_v_result = (__pyx_v_result | ((__pyx_v_i & 0x7f) << __pyx_v_shift));\n\n    \/* \"clickhouse_driver\/varint.pyx\":42\n *         i = read_one()\n *         result |= (i & 0x7f) << shift\n *         shift += 7             # <<<<<<<<<<<<<<\n *         if i < 0x80:\n *             break\n *\/\n    __pyx_v_shift = (__pyx_v_shift + 7);\n\n    \/* \"clickhouse_driver\/varint.pyx\":43\n *         result |= (i & 0x7f) << shift\n *         shift += 7\n *         if i < 0x80:             # <<<<<<<<<<<<<<\n *             break\n * \n *\/\n    __pyx_t_5 = ((__pyx_v_i < 0x80) != 0);\n    if (__pyx_t_5) {\n\n      \/* \"clickhouse_driver\/varint.pyx\":44\n *         shift += 7\n *         if i < 0x80:\n *             break             # <<<<<<<<<<<<<<\n * \n *     return result\n *\/\n      goto __pyx_L4_break;\n\n      \/* \"clickhouse_driver\/varint.pyx\":43\n *         result |= (i & 0x7f) << shift\n *         shift += 7\n *         if i < 0x80:             # <<<<<<<<<<<<<<\n *             break\n * \n *\/\n    }\n  }\n  __pyx_L4_break:;\n\n  \/* \"clickhouse_driver\/varint.pyx\":46\n *             break\n * \n *     return result             # <<<<<<<<<<<<<<\n *\/\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_result); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 46, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_r = __pyx_t_1;\n  __pyx_t_1 = 0;\n  goto __pyx_L0;\n\n  \/* \"clickhouse_driver\/varint.pyx\":29\n * \n * \n * def read_varint(f):             # <<<<<<<<<<<<<<\n *     \"\"\"\n *     Reads integer of variable length using LEB128.","target":1,"flaw_line_index":0,"hash":"c3771a5c-0d75-4be0-a1b1-4463e6d0872c","idx":"85aab11a-2427-4e00-93ce-d367203024d5"}
{"func_before":"static PyObject *__pyx_pf_17clickhouse_driver_6varint_2read_varint(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_f) {\n  unsigned char __pyx_v_shift;\n  unsigned PY_LONG_LONG __pyx_v_i;\n  unsigned PY_LONG_LONG __pyx_v_result;\n  PyObject *__pyx_v_read_one = NULL;\n  PyObject *__pyx_r = NULL;\n  __Pyx_RefNannyDeclarations\n  PyObject *__pyx_t_1 = NULL;\n  PyObject *__pyx_t_2 = NULL;\n  PyObject *__pyx_t_3 = NULL;\n  unsigned PY_LONG_LONG __pyx_t_4;\n  int __pyx_t_5;\n  __Pyx_RefNannySetupContext(\"read_varint\", 0);\n\n  \/* \"clickhouse_driver\/varint.pyx\":32\n *     Reads integer of variable length using LEB128.\n *     \"\"\"\n *     cdef unsigned char shift = 0             # <<<<<<<<<<<<<<\n *     cdef unsigned long long i, result = 0\n * \n *\/\n  __pyx_v_shift = 0;\n\n  \/* \"clickhouse_driver\/varint.pyx\":33\n *     \"\"\"\n *     cdef unsigned char shift = 0\n *     cdef unsigned long long i, result = 0             # <<<<<<<<<<<<<<\n * \n *     read_one = f.read_one\n *\/\n  __pyx_v_result = 0;\n\n  \/* \"clickhouse_driver\/varint.pyx\":35\n *     cdef unsigned long long i, result = 0\n * \n *     read_one = f.read_one             # <<<<<<<<<<<<<<\n * \n *     while True:\n *\/\n  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_f, __pyx_n_s_read_one); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 35, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_v_read_one = __pyx_t_1;\n  __pyx_t_1 = 0;\n\n  \/* \"clickhouse_driver\/varint.pyx\":37\n *     read_one = f.read_one\n * \n *     while True:             # <<<<<<<<<<<<<<\n *         i = read_one()\n *         result |= (i & 0x7f) << shift\n *\/\n  while (1) {\n\n    \/* \"clickhouse_driver\/varint.pyx\":38\n * \n *     while True:\n *         i = read_one()             # <<<<<<<<<<<<<<\n *         result |= (i & 0x7f) << shift\n *         shift += 7\n        __Pyx_DECREF_SET(__pyx_t_2, function);\n      }\n    }\n    __pyx_t_1 = (__pyx_t_3) ? __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3) : __Pyx_PyObject_CallNoArg(__pyx_t_2);\n    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;\n    if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 38, __pyx_L1_error)\n    __Pyx_GOTREF(__pyx_t_1);\n    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;\n    __pyx_t_4 = __Pyx_PyInt_As_unsigned_PY_LONG_LONG(__pyx_t_1); if (unlikely((__pyx_t_4 == (unsigned PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 38, __pyx_L1_error)\n    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;\n    __pyx_v_i = __pyx_t_4;\n\n    \/* \"clickhouse_driver\/varint.pyx\":39\n *     while True:\n *         i = read_one()\n *         result |= (i & 0x7f) << shift             # <<<<<<<<<<<<<<\n *         shift += 7\n *         if i < 0x80:\n *\/\n    __pyx_v_result = (__pyx_v_result | ((__pyx_v_i & 0x7f) << __pyx_v_shift));\n\n    \/* \"clickhouse_driver\/varint.pyx\":40\n *         i = read_one()\n *         result |= (i & 0x7f) << shift\n *         shift += 7             # <<<<<<<<<<<<<<\n *         if i < 0x80:\n *             break\n *\/\n    __pyx_v_shift = (__pyx_v_shift + 7);\n\n    \/* \"clickhouse_driver\/varint.pyx\":41\n *         result |= (i & 0x7f) << shift\n *         shift += 7\n *         if i < 0x80:             # <<<<<<<<<<<<<<\n *             break\n * \n *\/\n    __pyx_t_5 = ((__pyx_v_i < 0x80) != 0);\n    if (__pyx_t_5) {\n\n      \/* \"clickhouse_driver\/varint.pyx\":42\n *         shift += 7\n *         if i < 0x80:\n *             break             # <<<<<<<<<<<<<<\n * \n *     return result\n *\/\n      goto __pyx_L4_break;\n\n      \/* \"clickhouse_driver\/varint.pyx\":41\n *         result |= (i & 0x7f) << shift\n *         shift += 7\n *         if i < 0x80:             # <<<<<<<<<<<<<<\n *             break\n * \n *\/\n    }\n  }\n  __pyx_L4_break:;\n\n  \/* \"clickhouse_driver\/varint.pyx\":44\n *             break\n * \n *     return result             # <<<<<<<<<<<<<<\n *\/\n  __Pyx_XDECREF(__pyx_r);\n  __pyx_t_1 = __Pyx_PyInt_From_unsigned_PY_LONG_LONG(__pyx_v_result); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 44, __pyx_L1_error)\n  __Pyx_GOTREF(__pyx_t_1);\n  __pyx_r = __pyx_t_1;\n  __pyx_t_1 = 0;\n  goto __pyx_L0;\n\n  \/* \"clickhouse_driver\/varint.pyx\":28\n * \n * \n * def read_varint(f):             # <<<<<<<<<<<<<<\n *     \"\"\"\n *     Reads integer of variable length using LEB128.","target":0,"flaw_line_index":0,"hash":"555b9109-7787-4fe4-8b78-9b3d34599c1d","idx":"3754b25f-9c58-41d5-aa43-f89c67c6e37c"}
{"func_before":"static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)\n{\n    \/* MPEG-4 Studio Profile only, not supported by hardware *\/\n    if (avctx->bits_per_raw_sample > 8) {\n        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);\n        return avctx->pix_fmt;\n    }\n\n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        return AV_PIX_FMT_YUV420P;","target":1,"flaw_line_index":0,"hash":"905b1484-8d3a-43c7-a28e-d7348aa79e3a","idx":"29a67d24-d0a3-484b-b83d-4c7322397ef5"}
{"func_before":"static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)\n{\n    MpegEncContext *s = avctx->priv_data;\n    \/* MPEG-4 Studio Profile only, not supported by hardware *\/\n    if (avctx->bits_per_raw_sample > 8) {\n        av_assert1(s->studio_profile);\n        return avctx->pix_fmt;\n    }\n\n    if (avctx->codec->id == AV_CODEC_ID_MSS2)\n        return AV_PIX_FMT_YUV420P;","target":0,"flaw_line_index":0,"hash":"8834848e-4b01-4985-b560-e656b0c7ba62","idx":"78fa64ca-88ed-43b4-9674-94ea1a423db2"}
{"func_before":"\n  int minFilter = -1;\n  int magFilter = -1;\n  int wrapS = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  int wrapT = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  \/\/int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  ParseIntegerProperty(&minFilter, err, o, \"minFilter\", false);\n  ParseIntegerProperty(&magFilter, err, o, \"magFilter\", false);\n  ParseIntegerProperty(&wrapS, err, o, \"wrapS\", false);\n  ParseIntegerProperty(&wrapT, err, o, \"wrapT\", false);\n  \/\/ParseIntegerProperty(&wrapR, err, o, \"wrapR\", false);  \/\/ tinygltf extension\n\n  \/\/ TODO(syoyo): Check the value is alloed one.\n  \/\/ (e.g. we allow 9728(NEAREST), but don't allow 9727)\n\n  sampler->minFilter = minFilter;\n  sampler->magFilter = magFilter;\n  sampler->wrapS = wrapS;\n  sampler->wrapT = wrapT;\n  \/\/sampler->wrapR = wrapR;\n\n  ParseExtensionsProperty(&(sampler->extensions), err, o);\n  ParseExtrasProperty(&(sampler->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {","target":1,"flaw_line_index":0,"hash":"30431b65-2d3f-49dd-9c5b-00855370bb66","idx":"69f4a412-13d2-4a03-9473-a4efafffda3a"}
{"func_before":"\n  int minFilter = -1;\n  int magFilter = -1;\n  int wrapS = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  int wrapT = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  \/\/ int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  ParseIntegerProperty(&minFilter, err, o, \"minFilter\", false);\n  ParseIntegerProperty(&magFilter, err, o, \"magFilter\", false);\n  ParseIntegerProperty(&wrapS, err, o, \"wrapS\", false);\n  ParseIntegerProperty(&wrapT, err, o, \"wrapT\", false);\n  \/\/ ParseIntegerProperty(&wrapR, err, o, \"wrapR\", false);  \/\/ tinygltf\n  \/\/ extension\n\n  \/\/ TODO(syoyo): Check the value is alloed one.\n  \/\/ (e.g. we allow 9728(NEAREST), but don't allow 9727)\n\n  sampler->minFilter = minFilter;\n  sampler->magFilter = magFilter;\n  sampler->wrapS = wrapS;\n  sampler->wrapT = wrapT;\n  \/\/ sampler->wrapR = wrapR;\n\n  ParseExtensionsProperty(&(sampler->extensions), err, o);\n  ParseExtrasProperty(&(sampler->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {","target":0,"flaw_line_index":0,"hash":"c578b31f-8461-46b0-9ad3-35ea3b57d267","idx":"3630b6c4-6f88-45ce-b99e-c29c07a70e82"}
{"func_before":"      this, std::make_unique<HostExecutor>(config.plugin_config),\n      config.ordinal);\n  auto init_status = executor->Init(config.device_options);\n  if (!init_status.ok()) {\n    return tsl::Status(\n        port::error::INTERNAL,\n        absl::StrFormat(\n            \"failed initializing StreamExecutor for device ordinal %d: %s\",\n            config.ordinal, init_status.ToString().c_str()));\n  }\n","target":1,"flaw_line_index":0,"hash":"a8daa3d6-6b6c-4576-ae4c-5774e0072c17","idx":"fbad702d-18e8-461e-af0c-a801fc7f7c79"}
{"func_before":"      this, std::make_unique<HostExecutor>(config.plugin_config),\n      config.ordinal);\n  auto init_status = executor->Init(config.device_options);\n  if (!init_status.ok()) {\n    return tsl::Status(\n        tsl::error::INTERNAL,\n        absl::StrFormat(\n            \"failed initializing StreamExecutor for device ordinal %d: %s\",\n            config.ordinal, init_status.ToString().c_str()));\n  }\n","target":0,"flaw_line_index":0,"hash":"f19a959b-22b5-4011-9755-a125af2d5cb2","idx":"4fe88797-037e-4d3e-874d-1fc88b3a33f6"}
{"func_before":"                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  if (output->type == kTfLiteFloat32 || output->type == kTfLiteInt32) {\n    EvalDiv<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteUInt8) {\n    TF_LITE_ENSURE_OK(\n        context, EvalQuantized<kernel_type>(context, node, params, data, input1,\n                                            input2, output));\n  } else {\n    context->ReportError(\n        context,\n        \"Div only supports FLOAT32, INT32 and quantized UINT8 now, got %d.\",\n        output->type);\n    return kTfLiteError;\n  }\n\n  return kTfLiteOk;\n}","target":1,"flaw_line_index":0,"hash":"03da2da5-ef43-4bd2-808f-b66ee4fb226c","idx":"81ff76fe-a4cb-455f-807f-90d68f1d4992"}
{"func_before":"                    GetInputSafe(context, node, kInputTensor2, &input2));\n  TfLiteTensor* output;\n  TF_LITE_ENSURE_OK(context,\n                    GetOutputSafe(context, node, kOutputTensor, &output));\n\n  \/\/ TODO(b\/193904910): This can written with C++ templates\n#define TF_LITE_CHECK_DIV_NON_ZERO(data_type)                       \\\n  const auto* input2_data = GetTensorData<data_type>(input2);       \\\n  const size_t input2_elements = input2->bytes \/ sizeof(data_type); \\\n  for (size_t i = 0; i < input2_elements; i++) {                    \\\n    TF_LITE_ENSURE(context, input2_data[i] != 0);                   \\\n  }\n\n  if (output->type == kTfLiteFloat32) {\n    \/\/ Div by zero seems ok in this case, just like in TF case infinities are\n    \/\/ returned. So we don't do a check at this point.\n    EvalDiv<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteInt32) {\n    TF_LITE_CHECK_DIV_NON_ZERO(int32_t);\n    EvalDiv<kernel_type>(context, node, params, data, input1, input2, output);\n  } else if (output->type == kTfLiteUInt8) {\n    TF_LITE_CHECK_DIV_NON_ZERO(uint8_t);\n    TF_LITE_ENSURE_OK(\n        context, EvalQuantized<kernel_type>(context, node, params, data, input1,\n                                            input2, output));\n  } else {\n    context->ReportError(\n        context,\n        \"Div only supports FLOAT32, INT32 and quantized UINT8 now, got %d.\",\n        output->type);\n    return kTfLiteError;\n  }\n#undef TF_LITE_CHECK_DIV_NON_ZERO\n\n  return kTfLiteOk;\n}","target":0,"flaw_line_index":0,"hash":"1aa3372b-51ee-4051-9667-3d512404e39c","idx":"3a70a439-acaa-4751-ba3e-5cb537596985"}
{"func_before":"    int pathlen = 0, selfsigned = 0;\n    mbedtls_x509_crt *parent;\n    mbedtls_x509_name *name;\n    mbedtls_x509_sequence *cur = NULL;\n    mbedtls_pk_type_t pk_type;\n\n    if( profile == NULL )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    *flags = 0;\n\n    if( cn != NULL )\n    {\n        name = &crt->subject;\n        cn_len = strlen( cn );\n    if( parent != NULL )\n    {\n        ret = x509_crt_verify_top( crt, parent, ca_crl, profile,\n                                   pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n        if( ret != 0 )\n            return( ret );\n    }\n    else\n    {\n        \/* Look for a parent upwards the chain *\/\n        for( parent = crt->next; parent != NULL; parent = parent->next )\n        if( parent != NULL )\n        {\n            ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,\n                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n        {\n            ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,\n                                       pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n    }\n\n    if( *flags != 0 )\n        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n","target":1,"flaw_line_index":0,"hash":"e5acef5a-fc6c-42ac-978e-935cc3075a24","idx":"821c2332-0ead-4910-8097-e11ec08ca452"}
{"func_before":"    mbedtls_x509_crt *parent;\n    mbedtls_x509_name *name;\n    mbedtls_x509_sequence *cur = NULL;\n    mbedtls_pk_type_t pk_type;\n\n    *flags = 0;\n\n    if( profile == NULL )\n    {\n        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;\n        goto exit;\n    }\n\n    if( cn != NULL )\n    {\n        name = &crt->subject;\n        cn_len = strlen( cn );\n    if( parent != NULL )\n    {\n        ret = x509_crt_verify_top( crt, parent, ca_crl, profile,\n                                   pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n        if( ret != 0 )\n            goto exit;\n    }\n    else\n    {\n        \/* Look for a parent upwards the chain *\/\n        for( parent = crt->next; parent != NULL; parent = parent->next )\n        if( parent != NULL )\n        {\n            ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,\n                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                goto exit;\n        }\n        else\n        {\n            ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,\n                                       pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                goto exit;\n        }\n    }\n\nexit:\n    if( ret != 0 )\n    {\n        *flags = (uint32_t) -1;\n        return( ret );\n    }\n\n    if( *flags != 0 )\n        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n","target":0,"flaw_line_index":0,"hash":"10f224d6-1d52-4d9c-bb4f-236cb73387f4","idx":"20831983-8bd9-4fcd-b53a-57c0bbbc900c"}
{"func_before":"cdf_file_property_info(struct magic_set *ms, const cdf_property_info_t *info,\n    size_t count, const uint64_t clsid[2])\n{\n        size_t i;\n        cdf_timestamp_t tp;\n        struct timespec ts;\n        char buf[64];\n        const char *str = NULL;\n        const char *s;\n        int len;\n\n        if (!NOTMIME(ms))\n\t\tstr = cdf_clsid_to_mime(clsid, clsid2mime);\n\n        for (i = 0; i < count; i++) {\n                cdf_print_property_name(buf, sizeof(buf), info[i].pi_id);\n                switch (info[i].pi_type) {\n                case CDF_NULL:","target":1,"flaw_line_index":0,"hash":"200938a0-2178-4641-a28f-4ad5ceedd55a","idx":"9c6ed766-a777-477b-9512-a2546216fa78"}
{"func_before":"cdf_file_property_info(struct magic_set *ms, const cdf_property_info_t *info,\n    size_t count, const cdf_directory_t *root_storage)\n{\n        size_t i;\n        cdf_timestamp_t tp;\n        struct timespec ts;\n        char buf[64];\n        const char *str = NULL;\n        const char *s;\n        int len;\n\n        if (!NOTMIME(ms) && root_storage)\n\t\tstr = cdf_clsid_to_mime(root_storage->d_storage_uuid, clsid2mime);\n\n        for (i = 0; i < count; i++) {\n                cdf_print_property_name(buf, sizeof(buf), info[i].pi_id);\n                switch (info[i].pi_type) {\n                case CDF_NULL:","target":0,"flaw_line_index":0,"hash":"07728ce4-38fc-4ab1-bc30-31c97ea92edd","idx":"8fdad65a-4380-4468-b43c-14732edcf908"}
{"func_before":"\t\tu16 red, green, blue;\n\t\tu8 red8, green8, blue8;\n\t\tunsigned char __user *ured;\n\t\tunsigned char __user *ugreen;\n\t\tunsigned char __user *ublue;\n\t\tint index, count, i;\n\n\t\tif (get_user(index, &c->index) ||\n\t\t    __get_user(count, &c->count) ||\n\t\t    __get_user(ured, &c->red) ||\n\t\t    __get_user(ugreen, &c->green) ||\n\t\tstruct fbcmap __user *c = (struct fbcmap __user *) arg;\n\t\tunsigned char __user *ured;\n\t\tunsigned char __user *ugreen;\n\t\tunsigned char __user *ublue;\n\t\tstruct fb_cmap *cmap = &info->cmap;\n\t\tint index, count, i;\n\t\tu8 red, green, blue;\n\n\t\tif (get_user(index, &c->index) ||\n\t\t    __get_user(count, &c->count) ||\n\t\t    __get_user(ured, &c->red) ||","target":1,"flaw_line_index":0,"hash":"8dfd9e7a-bf3e-457e-956d-c8822d8ca876","idx":"38b12c8e-2f25-43db-9531-037339ba3fcb"}
{"func_before":"\t\tu16 red, green, blue;\n\t\tu8 red8, green8, blue8;\n\t\tunsigned char __user *ured;\n\t\tunsigned char __user *ugreen;\n\t\tunsigned char __user *ublue;\n\t\tunsigned int index, count, i;\n\n\t\tif (get_user(index, &c->index) ||\n\t\t    __get_user(count, &c->count) ||\n\t\t    __get_user(ured, &c->red) ||\n\t\t    __get_user(ugreen, &c->green) ||\n\t\tstruct fbcmap __user *c = (struct fbcmap __user *) arg;\n\t\tunsigned char __user *ured;\n\t\tunsigned char __user *ugreen;\n\t\tunsigned char __user *ublue;\n\t\tstruct fb_cmap *cmap = &info->cmap;\n\t\tunsigned int index, count, i;\n\t\tu8 red, green, blue;\n\n\t\tif (get_user(index, &c->index) ||\n\t\t    __get_user(count, &c->count) ||\n\t\t    __get_user(ured, &c->red) ||","target":0,"flaw_line_index":0,"hash":"27e539a1-736d-4a1a-9481-458c52879f79","idx":"340d5bd4-6dde-45de-a306-4445440998ef"}
{"func_before":"void PDPClient::assignRemoteEndpoints(\n        ParticipantProxyData* pdata)\n{\n    {\n        eprosima::shared_lock<eprosima::shared_mutex> disc_lock(mp_builtin->getDiscoveryMutex());\n\n        \/\/ Verify if this participant is a server\n        for (auto& svr : mp_builtin->m_DiscoveryServers)\n        {\n            if (data_matches_with_prefix(svr.guidPrefix, *pdata))\n            {\n                std::unique_lock<std::recursive_mutex> lock(*getMutex());\n                svr.proxy = pdata;\n            }\n        }\n    }\n\n#if HAVE_SECURITY\n    if (mp_RTPSParticipant->security_manager().discovered_participant(*pdata))\n#endif \/\/ HAVE_SECURITY\n    {\n        perform_builtin_endpoints_matching(*pdata);\n    }\n}","target":1,"flaw_line_index":0,"hash":"fe215da8-370d-4d83-aac9-58dce4f6c3da","idx":"d698201a-66e1-4bb9-88d8-d09edd77ceb8"}
{"func_before":"void PDPClient::assignRemoteEndpoints(\n        ParticipantProxyData* pdata)\n{\n    bool ignored = false;\n    notify_and_maybe_ignore_new_participant(pdata, ignored);\n    if (!ignored)\n    {\n        {\n            eprosima::shared_lock<eprosima::shared_mutex> disc_lock(mp_builtin->getDiscoveryMutex());\n\n            \/\/ Verify if this participant is a server\n            for (auto& svr : mp_builtin->m_DiscoveryServers)\n            {\n                if (data_matches_with_prefix(svr.guidPrefix, *pdata))\n                {\n                    std::unique_lock<std::recursive_mutex> lock(*getMutex());\n                    svr.proxy = pdata;\n                }\n            }\n        }\n\n#if HAVE_SECURITY\n        if (mp_RTPSParticipant->security_manager().discovered_participant(*pdata))\n#endif \/\/ HAVE_SECURITY\n        {\n            perform_builtin_endpoints_matching(*pdata);\n        }\n    }\n}","target":0,"flaw_line_index":0,"hash":"dfd37e67-c988-40b3-b480-e509f00a11e2","idx":"b80596ce-7d85-4027-8694-52032beaa964"}
{"func_before":"void nego_process_negotiation_failure(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\tUINT32 failureCode;\n\tWLog_DBG(TAG, \"RDP_NEG_FAILURE\");\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, failureCode);\n\n\tswitch (failureCode)\n\t{\n\t\tcase SSL_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\n\t\tcase SSL_NOT_ALLOWED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_NOT_ALLOWED_BY_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\n\t\tcase SSL_CERT_NOT_ON_SERVER:\n\t\t\tWLog_ERR(TAG, \"Error: SSL_CERT_NOT_ON_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\n\t\tcase INCONSISTENT_FLAGS:\n\t\t\tWLog_ERR(TAG, \"Error: INCONSISTENT_FLAGS\");\n\t\t\tbreak;\n\n\t\tcase HYBRID_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: HYBRID_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Error: Unknown protocol security error %\" PRIu32 \"\", failureCode);\n\t\t\tbreak;\n\t}\n\n\tnego->state = NEGO_STATE_FAIL;\n}","target":1,"flaw_line_index":0,"hash":"cc3e788b-6295-4324-b90b-f1682725d666","idx":"27a28b88-d6f1-4b38-a0d6-caebb80f6e76"}
{"func_before":"BOOL nego_process_negotiation_failure(rdpNego* nego, wStream* s)\n{\n\tBYTE flags;\n\tUINT16 length;\n\tUINT32 failureCode;\n\tWLog_DBG(TAG, \"RDP_NEG_FAILURE\");\n\tif (Stream_GetRemainingLength(s) < 7)\n\t\treturn FALSE;\n\tStream_Read_UINT8(s, flags);\n\tStream_Read_UINT16(s, length);\n\tStream_Read_UINT32(s, failureCode);\n\n\tswitch (failureCode)\n\t{\n\t\tcase SSL_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\n\t\tcase SSL_NOT_ALLOWED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: SSL_NOT_ALLOWED_BY_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\n\t\tcase SSL_CERT_NOT_ON_SERVER:\n\t\t\tWLog_ERR(TAG, \"Error: SSL_CERT_NOT_ON_SERVER\");\n\t\t\tnego->sendNegoData = TRUE;\n\t\t\tbreak;\n\n\t\tcase INCONSISTENT_FLAGS:\n\t\t\tWLog_ERR(TAG, \"Error: INCONSISTENT_FLAGS\");\n\t\t\tbreak;\n\n\t\tcase HYBRID_REQUIRED_BY_SERVER:\n\t\t\tWLog_WARN(TAG, \"Error: HYBRID_REQUIRED_BY_SERVER\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWLog_ERR(TAG, \"Error: Unknown protocol security error %\" PRIu32 \"\", failureCode);\n\t\t\tbreak;\n\t}\n\n\tnego->state = NEGO_STATE_FAIL;\n\treturn TRUE;\n}","target":0,"flaw_line_index":0,"hash":"6eac1bca-521e-44d4-8f2d-b9bd58157c6d","idx":"23955c07-3341-4e4d-a834-30fb366950d3"}
{"func_before":"int MSG_ReadBits( msg_t *msg, int bits ) {\n\tint\t\t\tvalue;\n\tint\t\t\tget;\n\tqboolean\tsgn;\n\tint\t\t\ti, nbits;\n\/\/\tFILE*\tfp;\n\n\tvalue = 0;\n\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t\tsgn = qtrue;\n\t} else {\n\t\tsgn = qfalse;\n\t}\n\n\tif (msg->oob) {\n\t\tif(bits==8)\n\t\t{\n\t\t\tvalue = msg->data[msg->readcount];\n\t\t\tmsg->readcount += 1;\n\t\t\tmsg->bit += 8;\n\t\telse\n\t\t\tCom_Error(ERR_DROP, \"can't read %d bits\", bits);\n\t} else {\n\t\tnbits = 0;\n\t\tif (bits&7) {\n\t\t\tnbits = bits&7;\n\t\t\tfor(i=0;i<nbits;i++) {\n\t\t\t\tvalue |= (Huff_getBit(msg->data, &msg->bit)<<i);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif (bits) {\n\/\/\t\t\tfp = fopen(\"c:\\\\netchan.bin\", \"a\");\n\t\t\tfor(i=0;i<bits;i+=8) {\n\t\t\t\tHuff_offsetReceive (msgHuff.decompressor.tree, &get, msg->data, &msg->bit);\n\/\/\t\t\t\tfwrite(&get, 1, 1, fp);\n\t\t\t\tvalue |= (get<<(i+nbits));\n\t\t\t}\n\/\/\t\t\tfclose(fp);\n\t\t}\n\t\tmsg->readcount = (msg->bit>>3)+1;\n\t}","target":1,"flaw_line_index":0,"hash":"5a9fe450-1342-4c91-a4e7-ff83ae26969c","idx":"6eff77c9-8540-4fb3-b70a-42708db4062d"}
{"func_before":"\tint\t\t\tvalue;\n\tint\t\t\tget;\n\tqboolean\tsgn;\n\tint\t\t\ti, nbits;\n\/\/\tFILE*\tfp;\n\n\tif ( msg->readcount > msg->cursize ) {\n\t\treturn 0;\n\t}\n\n\tvalue = 0;\n\n\tif ( bits < 0 ) {\n\t\tbits = -bits;\n\t} else {\n\t\tsgn = qfalse;\n\t}\n\n\tif (msg->oob) {\n\t\tif (msg->readcount + (bits>>3) > msg->cursize) {\n\t\t\tmsg->readcount = msg->cursize + 1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(bits==8)\n\t\t{\n\t\t\tvalue = msg->data[msg->readcount];\n\t\t\tmsg->readcount += 1;\n\t\t\tmsg->bit += 8;\n\t\t\tCom_Error(ERR_DROP, \"can't read %d bits\", bits);\n\t} else {\n\t\tnbits = 0;\n\t\tif (bits&7) {\n\t\t\tnbits = bits&7;\n\t\t\tif (msg->bit + nbits > msg->cursize << 3) {\n\t\t\t\tmsg->readcount = msg->cursize + 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tfor(i=0;i<nbits;i++) {\n\t\t\t\tvalue |= (Huff_getBit(msg->data, &msg->bit)<<i);\n\t\t\t}\n\t\t\tbits = bits - nbits;\n\t\t}\n\t\tif (bits) {\n\/\/\t\t\tfp = fopen(\"c:\\\\netchan.bin\", \"a\");\n\t\t\tfor(i=0;i<bits;i+=8) {\n\t\t\t\tHuff_offsetReceive (msgHuff.decompressor.tree, &get, msg->data, &msg->bit, msg->cursize<<3);\n\/\/\t\t\t\tfwrite(&get, 1, 1, fp);\n\t\t\t\tvalue |= (get<<(i+nbits));\n\n\t\t\t\tif (msg->bit > msg->cursize<<3) {\n\t\t\t\t\tmsg->readcount = msg->cursize + 1;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\/\/\t\t\tfclose(fp);\n\t\t}\n\t\tmsg->readcount = (msg->bit>>3)+1;\n\t}","target":0,"flaw_line_index":0,"hash":"dfac04a1-616e-4586-a352-a410ee71b949","idx":"29c3ef15-e580-4f15-ac85-97a945fb8398"}
{"func_before":"int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)\n{\n\tstruct pipe_buffer *bufs;\n\tunsigned int head, tail, mask, n;\n\n\t\/*\n\t * We can shrink the pipe, if arg is greater than the ring occupancy.\n\t * Since we don't expect a lot of shrink+grow operations, just free and\n\t * allocate again like we would do for growing.  If the pipe currently\n\t * contains more buffers than arg, then return busy.\n\t *\/\n\tmask = pipe->ring_size - 1;\n\thead = pipe->head;\n\ttail = pipe->tail;\n\tn = pipe_occupancy(pipe->head, pipe->tail);\n\tif (nr_slots < n)\n\t\treturn -EBUSY;\n\n\tbufs = kcalloc(nr_slots, sizeof(*bufs),\n\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\n\t\/*\n\t * The pipe array wraps around, so just start the new one at zero\n\t * and adjust the indices.\n\t *\/\n\tpipe->ring_size = nr_slots;\n\tif (pipe->max_usage > nr_slots)\n\t\tpipe->max_usage = nr_slots;\n\tpipe->tail = tail;\n\tpipe->head = head;\n\n\t\/* This might have made more room for writers *\/\n\twake_up_interruptible(&pipe->wr_wait);\n\treturn 0;\n}","target":1,"flaw_line_index":0,"hash":"e0f4ca47-4e7f-4f31-ab54-ea9ca208c469","idx":"0fbb7654-8b03-4a34-aac9-1c722e181f9e"}
{"func_before":"int pipe_resize_ring(struct pipe_inode_info *pipe, unsigned int nr_slots)\n{\n\tstruct pipe_buffer *bufs;\n\tunsigned int head, tail, mask, n;\n\n\tbufs = kcalloc(nr_slots, sizeof(*bufs),\n\t\t       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);\n\tif (unlikely(!bufs))\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&pipe->rd_wait.lock);\n\tmask = pipe->ring_size - 1;\n\thead = pipe->head;\n\ttail = pipe->tail;\n\n\tn = pipe_occupancy(head, tail);\n\tif (nr_slots < n) {\n\t\tspin_unlock_irq(&pipe->rd_wait.lock);\n\t\tkfree(bufs);\n\t\treturn -EBUSY;\n\t}\n\n\t\/*\n\t * The pipe array wraps around, so just start the new one at zero\n\t * and adjust the indices.\n\t *\/\n\tif (pipe->max_usage > nr_slots)\n\t\tpipe->max_usage = nr_slots;\n\tpipe->tail = tail;\n\tpipe->head = head;\n\n\tspin_unlock_irq(&pipe->rd_wait.lock);\n\n\t\/* This might have made more room for writers *\/\n\twake_up_interruptible(&pipe->wr_wait);\n\treturn 0;\n}","target":0,"flaw_line_index":0,"hash":"0b63890b-9c2c-4bb9-846a-d31ed9dba631","idx":"443bc98f-f889-4ba2-b7f2-a783e303882f"}
{"func_before":"void perf_event_disable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct task_struct *task = ctx->task;\n\n\tif (!task) {\n\t\t\/*\n\t\t * Disable the event on the cpu that it's on\n\t\t *\/\n\t\tcpu_function_call(event->cpu, __perf_event_disable, event);\n\t\treturn;\n\t}\n\nretry:\n\tif (!task_function_call(task, __perf_event_disable, event))\n\t\treturn;\n\n\traw_spin_lock_irq(&ctx->lock);\n\t\/*\n\t * If the event is still active, we need to retry the cross-call.\n\t *\/\n\tif (event->state == PERF_EVENT_STATE_ACTIVE) {\n\t\traw_spin_unlock_irq(&ctx->lock);\n\t\t\/*\n\t\t * Reload the task pointer, it might have been changed by\n\t\t * a concurrent perf_event_context_sched_out().\n\t\t *\/\n\t\ttask = ctx->task;\n\t\tgoto retry;\n\t}\n\n\t\/*\n\t * Since we have the lock this context can't be scheduled\n\t * in, so we can change the state safely.\n\t *\/\n\tif (event->state == PERF_EVENT_STATE_INACTIVE) {\n\t\tupdate_group_times(event);\n\t\tevent->state = PERF_EVENT_STATE_OFF;\n\t}\n\traw_spin_unlock_irq(&ctx->lock);\n}","target":1,"flaw_line_index":0,"hash":"035bf0a1-5b13-4e27-8bb5-e346294e4f24","idx":"0c6b9529-219a-473b-9ee0-89d706b6d32c"}
{"func_before":"void perf_event_disable(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx;\n\n\tctx = perf_event_ctx_lock(event);\n\t_perf_event_disable(event);\n\tperf_event_ctx_unlock(event, ctx);\n}","target":0,"flaw_line_index":0,"hash":"6fcc89f7-27fe-4886-95d4-34010d127b74","idx":"dfbcaf41-0759-4866-bfde-c87495d6d265"}
{"func_before":"      unsigned char\n        pixel;\n\n      for (x=((ssize_t) number_pixels-3); x > 0; x-=4)\n      {\n        pixel=(unsigned char) *indexes++;\n        *q=((pixel & 0x01) << 7);\n        pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n          TransparentOpacity ? 1 : 0);\n        *q|=((pixel & 0x01) << 6);\n        p++;\n        pixel=(unsigned char) *indexes++;\n        *q|=((pixel & 0x01) << 5);\n        pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n          TransparentOpacity ? 1 : 0);\n        *q|=((pixel & 0x01) << 4);\n        p++;\n        pixel=(unsigned char) *indexes++;\n        *q|=((pixel & 0x01) << 3);\n        pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n          TransparentOpacity ? 1 : 0);\n        *q|=((pixel & 0x01) << 2);\n        p++;\n        pixel=(unsigned char) *indexes++;\n        *q|=((pixel & 0x01) << 1);\n        pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n          TransparentOpacity ? 1 : 0);\n        *q|=((pixel & 0x01) << 0);\n        p++;\n      if ((number_pixels % 4) != 0)\n        {\n          *q='\\0';\n          for (bit=3; bit >= (ssize_t) (4-(number_pixels % 4)); bit-=2)\n          {\n            pixel=(unsigned char) *indexes++;\n            *q|=((pixel & 0x01) << (unsigned char) (bit+4));\n            pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n              TransparentOpacity ? 1 : 0);\n            *q|=((pixel & 0x01) << (unsigned char) (bit+4-1));\n            p++;\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels ; x++)\n      {\n        pixel=(unsigned char) *indexes++;\n        *q=((pixel & 0xf) << 4);\n        pixel=(unsigned char) (16*QuantumScale*((Quantum) (QuantumRange-\n          GetPixelOpacity(p)))+0.5);\n        *q|=((pixel & 0xf) << 0);\n        p++;\n        q++;\n      }\n      break;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopShortPixel(quantum_info->endian,(unsigned short) GetPixelIndex(indexes+x),q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelAlpha(p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p++;\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopShortPixel(quantum_info->endian,(unsigned short) GetPixelIndex(indexes+x),q);\n        pixel=ScaleQuantumToShort((Quantum) (QuantumRange-GetPixelOpacity(p)));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p++;\n        q+=quantum_info->pad;\n      }\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopLongPixel(quantum_info->endian,(unsigned int) GetPixelIndex(indexes+x),q);\n        pixel=ScaleQuantumToLong((Quantum) (QuantumRange-GetPixelOpacity(p)));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p++;\n        q+=quantum_info->pad;\n      }\n        range;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,\n          GetPixelIndex(indexes+x),q);\n        q=PopQuantumPixel(quantum_info,\n          ScaleQuantumToAny((Quantum) (GetPixelAlpha(p)),range),q);\n        p++;\n        q+=quantum_info->pad;\n      }\n      break;\n    }","target":1,"flaw_line_index":0,"hash":"4aef9ceb-d4e5-4083-ab65-58c1d8d62c3d","idx":"a03d13bb-aa4f-4cb6-a618-0b3a37a9673f"}
{"func_before":"      unsigned char\n        pixel;\n\n      for (x=((ssize_t) number_pixels-3); x > 0; x-=4)\n      {\n        pixel=(unsigned char) ((ssize_t) *indexes++);\n        *q=((pixel & 0x01) << 7);\n        pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n          TransparentOpacity ? 1 : 0);\n        *q|=((pixel & 0x01) << 6);\n        p++;\n        pixel=(unsigned char) ((ssize_t) *indexes++);\n        *q|=((pixel & 0x01) << 5);\n        pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n          TransparentOpacity ? 1 : 0);\n        *q|=((pixel & 0x01) << 4);\n        p++;\n        pixel=(unsigned char) ((ssize_t) *indexes++);\n        *q|=((pixel & 0x01) << 3);\n        pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n          TransparentOpacity ? 1 : 0);\n        *q|=((pixel & 0x01) << 2);\n        p++;\n        pixel=(unsigned char) ((ssize_t) *indexes++);\n        *q|=((pixel & 0x01) << 1);\n        pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n          TransparentOpacity ? 1 : 0);\n        *q|=((pixel & 0x01) << 0);\n        p++;\n      if ((number_pixels % 4) != 0)\n        {\n          *q='\\0';\n          for (bit=3; bit >= (ssize_t) (4-(number_pixels % 4)); bit-=2)\n          {\n            pixel=(unsigned char) ((ssize_t) *indexes++);\n            *q|=((pixel & 0x01) << (unsigned char) (bit+4));\n            pixel=(unsigned char) (GetPixelOpacity(p) == (Quantum)\n              TransparentOpacity ? 1 : 0);\n            *q|=((pixel & 0x01) << (unsigned char) (bit+4-1));\n            p++;\n      unsigned char\n        pixel;\n\n      for (x=0; x < (ssize_t) number_pixels ; x++)\n      {\n        pixel=(unsigned char) ((ssize_t) *indexes++);\n        *q=((pixel & 0xf) << 4);\n        pixel=(unsigned char) ((ssize_t) (16*QuantumScale*((Quantum)\n          (QuantumRange-GetPixelOpacity(p)))+0.5));\n        *q|=((pixel & 0xf) << 0);\n        p++;\n        q++;\n      }\n      break;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            q=PopShortPixel(quantum_info->endian,(unsigned short)\n              ((ssize_t) GetPixelIndex(indexes+x)),q);\n            pixel=SinglePrecisionToHalf(QuantumScale*GetPixelAlpha(p));\n            q=PopShortPixel(quantum_info->endian,pixel,q);\n            p++;\n            q+=quantum_info->pad;\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopShortPixel(quantum_info->endian,(unsigned short)\n          ((ssize_t) GetPixelIndex(indexes+x)),q);\n        pixel=ScaleQuantumToShort((Quantum) (QuantumRange-GetPixelOpacity(p)));\n        q=PopShortPixel(quantum_info->endian,pixel,q);\n        p++;\n        q+=quantum_info->pad;\n      }\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopLongPixel(quantum_info->endian,(unsigned int)\n          GetPixelIndex(indexes+x),q);\n        pixel=ScaleQuantumToLong((Quantum) (QuantumRange-GetPixelOpacity(p)));\n        q=PopLongPixel(quantum_info->endian,pixel,q);\n        p++;\n        q+=quantum_info->pad;\n      }\n        range;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        q=PopQuantumPixel(quantum_info,GetPixelIndex(indexes+x),q);\n        q=PopQuantumPixel(quantum_info,ScaleQuantumToAny((Quantum)\n          (GetPixelAlpha(p)),range),q);\n        p++;\n        q+=quantum_info->pad;\n      }\n      break;\n    }","target":0,"flaw_line_index":0,"hash":"462ae24c-f5b6-42d4-ab19-70f2db9ba77c","idx":"a883a615-1769-44fa-aa8a-e98c79e9416c"}
{"func_before":"            ruby_xfree(state->array_nl);\n            state->array_nl = NULL;\n        }\n    } else {\n        if (state->array_nl) ruby_xfree(state->array_nl);\n        state->array_nl = strdup(RSTRING_PTR(array_nl));\n        state->array_nl_len = len;\n    }\n    return Qnil;\n}","target":1,"flaw_line_index":0,"hash":"35c0c46a-89e1-4146-8561-562de7f6ed3c","idx":"221b5ae2-2c07-47a4-8ccb-4f11d5bb1887"}
{"func_before":"            ruby_xfree(state->array_nl);\n            state->array_nl = NULL;\n        }\n    } else {\n        if (state->array_nl) ruby_xfree(state->array_nl);\n        state->array_nl = fstrndup(RSTRING_PTR(array_nl), len);\n        state->array_nl_len = len;\n    }\n    return Qnil;\n}","target":0,"flaw_line_index":0,"hash":"da613fc2-a545-44f5-acd6-2b2d8d44d693","idx":"ef4d7bd5-4341-49e9-8612-0ddbd70a610a"}
{"func_before":"GlyphCache::GlyphCache(const Face & face, const uint32 face_options)\n: _glyph_loader(new Loader(face, bool(face_options & gr_face_dumbRendering))),\n  _glyphs(_glyph_loader && *_glyph_loader && _glyph_loader->num_glyphs()\n        ? grzeroalloc<const GlyphFace *>(_glyph_loader->num_glyphs()) : 0),\n  _boxes(_glyph_loader && _glyph_loader->has_boxes() && _glyph_loader->num_glyphs()\n        ? grzeroalloc<GlyphBox *>(_glyph_loader->num_glyphs()) : 0),\n  _num_glyphs(_glyphs ? _glyph_loader->num_glyphs() : 0),","target":1,"flaw_line_index":0,"hash":"3a11cbcb-2504-4b40-add0-e62abbb86195","idx":"32cfff59-f0aa-4bd9-bf87-3c197f97af41"}
{"func_before":"GlyphCache::GlyphCache(const Face & face, const uint32 face_options)\n: _glyph_loader(new Loader(face)),\n  _glyphs(_glyph_loader && *_glyph_loader && _glyph_loader->num_glyphs()\n        ? grzeroalloc<const GlyphFace *>(_glyph_loader->num_glyphs()) : 0),\n  _boxes(_glyph_loader && _glyph_loader->has_boxes() && _glyph_loader->num_glyphs()\n        ? grzeroalloc<GlyphBox *>(_glyph_loader->num_glyphs()) : 0),\n  _num_glyphs(_glyphs ? _glyph_loader->num_glyphs() : 0),","target":0,"flaw_line_index":0,"hash":"5f093623-47e5-4c1b-827f-bf00331258e9","idx":"17b066db-6d29-4754-8700-55d448b2fe30"}
{"func_before":"\tstream_ctxt = (ds_stream_ctxt_t *) ctxt->ptr;\n\n\tpthread_mutex_lock(&stream_ctxt->mutex);\n\tif (stream_ctxt->dest_file == NULL) {\n\t\tstream_ctxt->dest_file = ds_open(dest_ctxt, path, mystat);\n\t\tif (stream_ctxt->dest_file == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tpthread_mutex_unlock(&stream_ctxt->mutex);\n\n\tfile = (ds_file_t *) my_malloc(sizeof(ds_file_t) +\n\t\t\t\t       sizeof(ds_stream_file_t),\n\t\t\t\t       MYF(MY_FAE));\n\tstream_file = (ds_stream_file_t *) (file + 1);\n\n\txbstream = stream_ctxt->xbstream;\n\n\txbstream_file = xb_stream_write_open(xbstream, path, mystat,","target":1,"flaw_line_index":0,"hash":"19627a3f-3b74-4b44-ba43-92158631eae3","idx":"65115d01-5d1d-4ab0-83c6-0a64e44e925e"}
{"func_before":"\n\tstream_ctxt = (ds_stream_ctxt_t *) ctxt->ptr;\n\n\tpthread_mutex_lock(&stream_ctxt->mutex);\n\tif (stream_ctxt->dest_file == NULL) {\n\t\tstream_ctxt->dest_file = ds_open(dest_ctxt, path, mystat);\n\t}\n\tpthread_mutex_unlock(&stream_ctxt->mutex);\n\tif (stream_ctxt->dest_file == NULL) {\n\t\treturn NULL;\n\t}\n\n\tfile = (ds_file_t *) my_malloc(sizeof(ds_file_t) +\n\t\t\t\t       sizeof(ds_stream_file_t),\n\t\t\t\t       MYF(MY_FAE));\n\tif (!file) {\n\t\tmsg(\"my_malloc() failed.\");\n\t\tgoto err;\n\t}\n\tstream_file = (ds_stream_file_t *) (file + 1);\n\n\txbstream = stream_ctxt->xbstream;\n\n\txbstream_file = xb_stream_write_open(xbstream, path, mystat,","target":0,"flaw_line_index":0,"hash":"82097a0e-2288-442c-afdb-7d5b051397fb","idx":"80bfe66e-4b2b-4815-a5a4-9df5704f2b57"}
{"func_before":"\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(dir->i_sb, nameptr, fname, lfi);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:","target":1,"flaw_line_index":0,"hash":"63d90c4a-2279-48f8-a230-20718b6efedf","idx":"7aaf9a2a-39f3-4da4-83cd-2bf4e43e932e"}
{"func_before":"\t\t\tgoto out_ok;\n\n\t\tif (!lfi)\n\t\t\tcontinue;\n\n\t\tflen = udf_get_filename(dir->i_sb, nameptr, lfi, fname,\n\t\t\t\t\tUDF_NAME_LEN);\n\t\tif (flen && udf_match(flen, fname, child->len, child->name))\n\t\t\tgoto out_ok;\n\t}\n\nout_err:","target":0,"flaw_line_index":0,"hash":"379bc3b6-1375-4b6e-a0e5-181fbe89c98e","idx":"7cc1d0e3-8ed5-419e-87a9-4b547288dab6"}
{"func_before":"unix_client_connect(hsm_com_client_hdl_t *hdl)\n{\n\tint\t\t\t\t\tfd, len;\n\tstruct sockaddr_un\tunix_addr;\n\n\tif ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) \n\t{\n\t\treturn HSM_COM_ERROR;\n\t}\n\n\tunix_addr.sun_family = AF_UNIX;\n\t\n\tif(strlen(hdl->c_path) >= sizeof(unix_addr.sun_path))\n\t{\n\t\tclose(fd);\n\t\treturn HSM_COM_PATH_ERR;\n\t}\n\n\tsnprintf(unix_addr.sun_path, sizeof(unix_addr.sun_path), \"%s\", hdl->c_path);\n\n\tlen = SUN_LEN(&unix_addr);\n\n\tunlink(unix_addr.sun_path);\n\n\tif(bind(fd, (struct sockaddr *)&unix_addr, len) < 0)\n\t{\n\t\tunlink(hdl->c_path);\n\t\tclose(fd);\n\n\t\treturn HSM_COM_BIND_ERR;\n\t}\n\n\tif(chmod(unix_addr.sun_path, S_IRWXU) < 0)\n\t{\n\t\tunlink(hdl->c_path);\n\t\tclose(fd);\n\t\treturn HSM_COM_CHMOD_ERR;\n\t}\n\n\tmemset(&unix_addr,0,sizeof(unix_addr));\n\n\tunix_addr.sun_family = AF_UNIX;\n\n\tlen = SUN_LEN(&unix_addr);\n\n\tif (connect(fd, (struct sockaddr *) &unix_addr, len) < 0) \n\t{\n\t\tunlink(hdl->c_path);\n\t\tclose(fd);\n\t\treturn HSM_COM_CONX_ERR;\n\t}\n\n\thdl->client_fd = fd;\n\thdl->client_state = HSM_COM_C_STATE_CT;\n\n\t\/\/ Send connection data packet\n\tif(unix_sck_send_conn(hdl, 2) != HSM_COM_OK)\n\t{\n\t\thdl->client_state = HSM_COM_C_STATE_IN;\n\t\treturn HSM_COM_SEND_ERR;\n\t}\n\n\n\n\treturn HSM_COM_OK;\n\n}","target":1,"flaw_line_index":0,"hash":"d321a098-478e-4d6b-9c14-9d6fe974cc49","idx":"656096a9-f421-4816-be43-423608717c8e"}
{"func_before":"unix_client_connect(hsm_com_client_hdl_t *hdl)\n{\n\tint\t\t\t\t\tfd, len;\n\tstruct sockaddr_un\tunix_addr;\n\thsm_com_errno_t\t\tres = HSM_COM_OK;\n\n\tif ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) \n\t{\n\t\treturn HSM_COM_ERROR;\n\t}\n\n\tunix_addr.sun_family = AF_UNIX;\n\t\n\tif(strlen(hdl->c_path) >= sizeof(unix_addr.sun_path))\n\t{\n\t\tres = HSM_COM_PATH_ERR;\n\t\tgoto cleanup;\n\t}\n\n\tsnprintf(unix_addr.sun_path, sizeof(unix_addr.sun_path), \"%s\", hdl->c_path);\n\n\tlen = SUN_LEN(&unix_addr);\n\n\tunlink(unix_addr.sun_path);\n\n\tif(bind(fd, (struct sockaddr *)&unix_addr, len) < 0)\n\t{\n\t\tres = HSM_COM_BIND_ERR;\n\t\tgoto cleanup;\n\t}\n\n\tif(chmod(unix_addr.sun_path, S_IRWXU) < 0)\n\t{\n\t\tres = HSM_COM_CHMOD_ERR;\n\t\tgoto cleanup;\n\t}\n\n\tmemset(&unix_addr,0,sizeof(unix_addr));\n\n\tunix_addr.sun_family = AF_UNIX;\n\n\tlen = SUN_LEN(&unix_addr);\n\n\tif (connect(fd, (struct sockaddr *) &unix_addr, len) < 0) \n\t{\n\t\tres = HSM_COM_CONX_ERR;\n\t\tgoto cleanup;\n\t}\n\n\thdl->client_fd = fd;\n\thdl->client_state = HSM_COM_C_STATE_CT;\n\n\t\/\/ Send connection data packet\n\tif(unix_sck_send_conn(hdl, 2) != HSM_COM_OK)\n\t{\n\t\thdl->client_state = HSM_COM_C_STATE_IN;\n\t\tres = HSM_COM_SEND_ERR;\n\t}\n\n\treturn res;\n\ncleanup:\n\tclose(fd);\n\treturn res;\n\n}","target":0,"flaw_line_index":0,"hash":"766eb4bb-abf0-4ee7-9de7-c20e1fafc117","idx":"1cd38b20-2a17-46c1-b3ce-1c85546757d2"}
{"func_before":"did_set_shortmess(optset_T *args)\n{\n    char_u\t**varp = (char_u **)args->os_varp;\n\n    return did_set_option_listflag(*varp, (char_u *)SHM_ALL, args->os_errbuf);\n}","target":1,"flaw_line_index":0,"hash":"542e1bd6-c32b-4461-91da-e15b63058a3f","idx":"7430c7ea-b481-4d19-813c-fbd15784aaea"}
{"func_before":"did_set_shortmess(optset_T *args)\n{\n    char_u\t**varp = (char_u **)args->os_varp;\n\n    return did_set_option_listflag(*varp, (char_u *)SHM_ALL, args->os_errbuf,\n\t\t    args->os_errbuflen);\n}","target":0,"flaw_line_index":0,"hash":"3e8545b6-869c-4e2e-8cce-54bef8242a69","idx":"deb143e2-5e37-4477-b2db-8540bb093d16"}
{"func_before":"            for (j = 0; j < MOBI_ATTRVALUE_MAXSIZE && length && *data != separator && *data != '>'; j++) {\n                *value++ = (char) *data++;\n                length--;\n            }\n            \/* self closing tag '\/>' *\/\n            if (*(data - 1) == '\/' && *data == '>') {\n                value--;\n            }\n            *value = '\\0';\n            \/* return offset to the beginning of the attribute value string *\/\n            return size - length - j;","target":1,"flaw_line_index":0,"hash":"bf408e77-d1b4-4ea5-9307-e545fa2e35fa","idx":"aaa72e47-d5f0-4d1a-bf40-9c641ac868f9"}
{"func_before":"            for (j = 0; j < MOBI_ATTRVALUE_MAXSIZE && length && *data != separator && *data != '>'; j++) {\n                *value++ = (char) *data++;\n                length--;\n            }\n            \/* self closing tag '\/>' *\/\n            if (length && *(data - 1) == '\/' && *data == '>') {\n                value--;\n            }\n            *value = '\\0';\n            \/* return offset to the beginning of the attribute value string *\/\n            return size - length - j;","target":0,"flaw_line_index":0,"hash":"cf747ea0-278b-4ce6-95d1-00996e331adf","idx":"afb519a6-e7f4-437c-9353-5f06600d1140"}
{"func_before":"int main(int argc, char **argv)\n{\n  test_cmp_parameters inParam;\n  FILE *fbase=NULL, *ftest=NULL;\n  int same = 0;\n  char lbase[256];\n  char strbase[256];\n  char ltest[256];\n  char strtest[256];\n\n  if( parse_cmdline_cmp(argc, argv, &inParam) == 1 )\n    {\n    compare_dump_files_help_display();\n    goto cleanup;\n    }\n  printf(\"Ok.\\n\");\n\n  while (fgets(lbase, sizeof(lbase), fbase) && fgets(ltest,sizeof(ltest),ftest))\n    {\n    int nbase = sscanf(lbase, \"%255[^\\r\\n]\", strbase);\n    int ntest = sscanf(ltest, \"%255[^\\r\\n]\", strtest);\n    assert( nbase != 255 && ntest != 255 );\n    if( nbase != 1 || ntest != 1 )\n      {\n      fprintf(stderr, \"could not parse line from files\\n\" );\n      goto cleanup;\n      }","target":1,"flaw_line_index":0,"hash":"f3875e0f-72d2-40a8-a27b-457f315b15dd","idx":"9ff1a2b0-4b14-4797-9b6b-9a3e2de39d9d"}
{"func_before":"int main(int argc, char **argv)\n{\n  test_cmp_parameters inParam;\n  FILE *fbase=NULL, *ftest=NULL;\n  int same = 0;\n  char lbase[512];\n  char strbase[512];\n  char ltest[512];\n  char strtest[512];\n\n  if( parse_cmdline_cmp(argc, argv, &inParam) == 1 )\n    {\n    compare_dump_files_help_display();\n    goto cleanup;\n    }\n  printf(\"Ok.\\n\");\n\n  while (fgets(lbase, sizeof(lbase), fbase) && fgets(ltest,sizeof(ltest),ftest))\n    {\n    int nbase = sscanf(lbase, \"%511[^\\r\\n]\", strbase);\n    int ntest = sscanf(ltest, \"%511[^\\r\\n]\", strtest);\n    assert( nbase != 511 && ntest != 511 );\n    if( nbase != 1 || ntest != 1 )\n      {\n      fprintf(stderr, \"could not parse line from files\\n\" );\n      goto cleanup;\n      }","target":0,"flaw_line_index":0,"hash":"b015e8ca-0b6e-49ec-8f3a-ba7d4bd860d4","idx":"2673e9b5-ef4f-40f1-bb9e-d68568d6025e"}
{"func_before":"\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache id: %\" PRIu32 \"\", id);\n\t\treturn FALSE;\n\t}\n\n\tif (index > glyphCache->glyphCache[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index, id);\n\t\treturn FALSE;\n\t}\n","target":1,"flaw_line_index":0,"hash":"4341793e-5f63-4cce-bf7f-3dbbbca9f9e0","idx":"d7a2a2dc-662a-4c1a-8d4c-71415041053a"}
{"func_before":"\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache id: %\" PRIu32 \"\", id);\n\t\treturn FALSE;\n\t}\n\n\tif (index >= glyphCache->glyphCache[id].number)\n\t{\n\t\tWLog_ERR(TAG, \"invalid glyph cache index: %\" PRIu32 \" in cache id: %\" PRIu32 \"\", index, id);\n\t\treturn FALSE;\n\t}\n","target":0,"flaw_line_index":0,"hash":"bbf49ac8-c5cc-4d05-a100-2f9d49f41095","idx":"1e00af7a-61f2-4df7-85d6-ff0687d6a73c"}
{"func_before":"\t\tacl = NULL;\n\n\tswitch (handler->flags) {\n\tcase ACL_TYPE_ACCESS:\n\t\tif (acl) {\n\t\t\tumode_t mode = inode->i_mode;\n\t\t\tretval = posix_acl_equiv_mode(acl, &mode);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto err_out;\n\t\t\telse {\n\t\t\t\tstruct iattr iattr;\n\t\t\t\tif (retval == 0) {\n\t\t\t\t\t\/*\n\t\t\t\t\t * ACL can be represented\n\t\t\t\t\t * by the mode bits. So don't\n\t\t\t\t\t * update ACL.\n\t\t\t\t\t *\/\n\t\t\t\t\tacl = NULL;\n\t\t\t\t\tvalue = NULL;\n\t\t\t\t\tsize = 0;\n\t\t\t\t}\n\t\t\t\t\/* Updte the mode bits *\/\n\t\t\t\tiattr.ia_mode = ((mode & S_IALLUGO) |\n\t\t\t\t\t\t (inode->i_mode & ~S_IALLUGO));\n\t\t\t\tiattr.ia_valid = ATTR_MODE;\n\t\t\t\t\/* FIXME should we update ctime ?\n\t\t\t\t * What is the following setxattr update the\n\t\t\t\t * mode ?\n\t\t\t\t *\/\n\t\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tretval = acl ? -EINVAL : 0;","target":1,"flaw_line_index":0,"hash":"aeb40a9f-1cfe-419a-a759-728d8a566a53","idx":"b12152ec-5b2c-43e0-ba8e-a9f733226c0d"}
{"func_before":"\t\tacl = NULL;\n\n\tswitch (handler->flags) {\n\tcase ACL_TYPE_ACCESS:\n\t\tif (acl) {\n\t\t\tstruct iattr iattr;\n\n\t\t\tretval = posix_acl_update_mode(inode, &iattr.ia_mode, &acl);\n\t\t\tif (retval)\n\t\t\t\tgoto err_out;\n\t\t\tif (!acl) {\n\t\t\t\t\/*\n\t\t\t\t * ACL can be represented\n\t\t\t\t * by the mode bits. So don't\n\t\t\t\t * update ACL.\n\t\t\t\t *\/\n\t\t\t\tvalue = NULL;\n\t\t\t\tsize = 0;\n\t\t\t}\n\t\t\tiattr.ia_valid = ATTR_MODE;\n\t\t\t\/* FIXME should we update ctime ?\n\t\t\t * What is the following setxattr update the\n\t\t\t * mode ?\n\t\t\t *\/\n\t\t\tv9fs_vfs_setattr_dotl(dentry, &iattr);\n\t\t}\n\t\tbreak;\n\tcase ACL_TYPE_DEFAULT:\n\t\tif (!S_ISDIR(inode->i_mode)) {\n\t\t\tretval = acl ? -EINVAL : 0;","target":0,"flaw_line_index":0,"hash":"8cc28d2c-308f-484b-aa3f-bab531565190","idx":"4a49d826-0222-4ce3-9644-0481abefa1f4"}
{"func_before":"int test_sqr(BIO *bp, BN_CTX *ctx)\n\t{\n\tBIGNUM a,c,d,e;\n\tint i;\n\n\tBN_init(&a);\n\tBN_init(&c);\n\tBN_init(&d);\n\tBN_init(&e);\n\n\tfor (i=0; i<num0; i++)\n\t\t{\n\t\tBN_bntest_rand(&a,40+i*10,0,0);\n\t\ta.neg=rand_neg();\n\t\tBN_sqr(&c,&a,ctx);\n\t\tif (bp != NULL)\n\t\t\t{\n\t\t\tif (!results)\n\t\t\t\t{\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" * \");\n\t\t\t\tBN_print(bp,&a);\n\t\t\t\tBIO_puts(bp,\" - \");\n\t\t\t\t}\n\t\t\tBN_print(bp,&c);\n\t\t\tBIO_puts(bp,\"\\n\");\n\t\t\t}\n\t\tBN_div(&d,&e,&c,&a,ctx);\n\t\tBN_sub(&d,&d,&a);\n\t\tif(!BN_is_zero(&d) || !BN_is_zero(&e))\n\t\t    {\n\t\t    fprintf(stderr,\"Square test failed!\\n\");\n\t\t    return 0;\n\t\t    }\n\t\t}\n\tBN_free(&a);\n\tBN_free(&c);\n\tBN_free(&d);\n\tBN_free(&e);\n\treturn(1);\n\t}","target":1,"flaw_line_index":0,"hash":"378f2c61-2287-4f46-910a-8a878cb05467","idx":"3b5f3351-d310-4a5c-b474-42ee7c89d62f"}
{"func_before":"int test_sqr(BIO *bp, BN_CTX *ctx)\n\t{\n\tBIGNUM *a,*c,*d,*e;\n\tint i, ret = 0;\n\n\ta = BN_new();\n\tc = BN_new();\n\td = BN_new();\n\te = BN_new();\n\tif (a == NULL || c == NULL || d == NULL || e == NULL)\n\t\t{\n\t\tgoto err;\n\t\t}\n\n\tfor (i=0; i<num0; i++)\n\t\t{\n\t\tBN_bntest_rand(a,40+i*10,0,0);\n\t\ta->neg=rand_neg();\n\t\tBN_sqr(c,a,ctx);\n\t\tif (bp != NULL)\n\t\t\t{\n\t\t\tif (!results)\n\t\t\t\t{\n\t\t\t\tBN_print(bp,a);\n\t\t\t\tBIO_puts(bp,\" * \");\n\t\t\t\tBN_print(bp,a);\n\t\t\t\tBIO_puts(bp,\" - \");\n\t\t\t\t}\n\t\t\tBN_print(bp,c);\n\t\t\tBIO_puts(bp,\"\\n\");\n\t\t\t}\n\t\tBN_div(d,e,c,a,ctx);\n\t\tBN_sub(d,d,a);\n\t\tif(!BN_is_zero(d) || !BN_is_zero(e))\n\t\t\t{\n\t\t\tfprintf(stderr,\"Square test failed!\\n\");\n\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\/* Regression test for a BN_sqr overflow bug. *\/\n\tBN_hex2bn(&a,\n\t\t\"80000000000000008000000000000001FFFFFFFFFFFFFFFE0000000000000000\");\n\tBN_sqr(c, a, ctx);\n\tif (bp != NULL)\n\t\t{\n\t\tif (!results)\n\t\t\t{\n\t\t\tBN_print(bp,a);\n\t\t\tBIO_puts(bp,\" * \");\n\t\t\tBN_print(bp,a);\n\t\t\tBIO_puts(bp,\" - \");\n\t\t\t}\n\t\tBN_print(bp,c);\n\t\tBIO_puts(bp,\"\\n\");\n\t\t}\n\tBN_mul(d, a, a, ctx);\n\tif (BN_cmp(c, d))\n\t\t{\n\t\tfprintf(stderr, \"Square test failed: BN_sqr and BN_mul produce \"\n\t\t\t\"different results!\\n\");\n\t\tgoto err;\n\t\t}\n\n\t\/* Regression test for a BN_sqr overflow bug. *\/\n\tBN_hex2bn(&a,\n\t\t\"80000000000000000000000080000001FFFFFFFE000000000000000000000000\");\n\tBN_sqr(c, a, ctx);\n\tif (bp != NULL)\n\t\t{\n\t\tif (!results)\n\t\t\t{\n\t\t\tBN_print(bp,a);\n\t\t\tBIO_puts(bp,\" * \");\n\t\t\tBN_print(bp,a);\n\t\t\tBIO_puts(bp,\" - \");\n\t\t\t}\n\t\tBN_print(bp,c);\n\t\tBIO_puts(bp,\"\\n\");\n\t\t}\n\tBN_mul(d, a, a, ctx);\n\tif (BN_cmp(c, d))\n\t\t{\n\t\tfprintf(stderr, \"Square test failed: BN_sqr and BN_mul produce \"\n\t\t\t\"different results!\\n\");\n\t\tgoto err;\n\t\t}\n\tret = 1;\nerr:\n\tif (a != NULL) BN_free(a);\n\tif (c != NULL) BN_free(c);\n\tif (d != NULL) BN_free(d);\n\tif (e != NULL) BN_free(e);\n\treturn ret;\n\t}","target":0,"flaw_line_index":0,"hash":"2dfc1bbf-bcfc-439c-971f-e23149da3362","idx":"a6e16f3e-c85a-4468-b250-be4ecdc4c924"}
{"func_before":"\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n","target":1,"flaw_line_index":0,"hash":"dec7b1b1-c35c-4c77-9007-0bf9754421ec","idx":"bc28a0a9-ba84-4f0b-91ec-8bc1dfef4e17"}
{"func_before":"\tif (!f) {\n\t\twarn(\"open %s:\", name);\n\t\treturn -1;\n\t}\n\tret = 0;\n\tif (s && (fwrite(s->s, 1, s->n, f) != s->n || fflush(f) != 0)) {\n\t\twarn(\"write %s:\", name);\n\t\tret = -1;\n\t}\n\tfclose(f);\n","target":0,"flaw_line_index":0,"hash":"e027bc44-ed17-4019-a73d-79d23512b7f5","idx":"99e53538-9733-41d0-ba11-0c7f3f23f58a"}
{"func_before":"cmdline_insert_reg(int *gotesc UNUSED)\n{\n    int\t\ti;\n    int\t\tc;\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\/\/ disallow scrolling here\n#endif\n    putcmdline('\"', TRUE);\n    --no_mapping;\n    --allow_keys;\n#ifdef FEAT_EVAL\n    \/*\n     * Insert the result of an expression.\n     * Need to save the current command line, to be able to enter\n     * a new one...\n     *\/\n    new_cmdpos = -1;\n    if (c == '=')\n    {\n\tif (ccline.cmdfirstc == '='  \/\/ can't do this recursively\n\t\tccline.cmdpos = ccline.cmdlen;\n\t    else\n\t\tccline.cmdpos = new_cmdpos;\n\t}\n#endif\n    }\n    \/\/ remove the double quote\n    redrawcmd();\n\n    \/\/ The text has been stuffed, the command line didn't change yet.\n    return CMDLINE_NOT_CHANGED;","target":1,"flaw_line_index":0,"hash":"ce3a16c2-5d77-4c01-9ce6-421586f7d280","idx":"00d96bfb-e20b-48b5-ab8e-341161cf7f61"}
{"func_before":"cmdline_insert_reg(int *gotesc UNUSED)\n{\n    int\t\ti;\n    int\t\tc;\n    int\t\tsave_new_cmdpos = new_cmdpos;\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\/\/ disallow scrolling here\n#endif\n    putcmdline('\"', TRUE);\n    extra_char = NUL;\n    --no_mapping;\n    --allow_keys;\n#ifdef FEAT_EVAL\n    \/*\n     * Insert the result of an expression.\n     *\/\n    new_cmdpos = -1;\n    if (c == '=')\n    {\n\tif (ccline.cmdfirstc == '='  \/\/ can't do this recursively\n\t    else\n\t\tccline.cmdpos = new_cmdpos;\n\t}\n#endif\n    }\n    new_cmdpos = save_new_cmdpos;\n\n    \/\/ remove the double quote\n    redrawcmd();\n\n    \/\/ The text has been stuffed, the command line didn't change yet.\n    return CMDLINE_NOT_CHANGED;","target":0,"flaw_line_index":0,"hash":"e91d0ac0-7edf-455c-ae14-08428e253672","idx":"9ed40431-46c7-4595-b9c1-179ffabd6ca2"}
{"func_before":"  if(stream.peek() == '[')\n  {\n    return LoadAsxIniInfo(stream);\n  }\n  else\n  {\n    CXBMCTinyXML xmlDoc;\n    stream >> xmlDoc;\n\n    if (xmlDoc.Error())\n    {\n      CLog::Log(LOGERROR, \"Unable to parse ASX info Error: {}\", xmlDoc.ErrorDesc());\n      return false;\n    }\n\n    TiXmlElement *pRootElement = xmlDoc.RootElement();\n\n    \/\/ lowercase every element\n    TiXmlNode *pNode = pRootElement;\n    TiXmlNode *pChild = NULL;\n    std::string value;","target":1,"flaw_line_index":0,"hash":"7de7ca96-0da0-4104-a473-07b75ed183d7","idx":"d04e3123-1e20-4b1e-9557-c5f3b74f8d66"}
{"func_before":"  {\n    return LoadAsxIniInfo(stream);\n  }\n  else\n  {\n    std::string asxstream(std::istreambuf_iterator<char>(stream), {});\n    CXBMCTinyXML xmlDoc;\n    xmlDoc.Parse(asxstream, TIXML_DEFAULT_ENCODING);\n\n    if (xmlDoc.Error())\n    {\n      CLog::Log(LOGERROR, \"Unable to parse ASX info Error: {}\", xmlDoc.ErrorDesc());\n      return false;\n    }\n\n    TiXmlElement *pRootElement = xmlDoc.RootElement();\n\n    if (!pRootElement)\n      return false;\n\n    \/\/ lowercase every element\n    TiXmlNode *pNode = pRootElement;\n    TiXmlNode *pChild = NULL;\n    std::string value;","target":0,"flaw_line_index":0,"hash":"0234b395-ae12-4812-a2ac-807acdc3158c","idx":"7c8d5f82-a8f5-4049-a91e-464a56d771b0"}
{"func_before":"                        \"indices\", SliceDebugString(indices.shape(), bad_i),\n                        \" = \", indices_flat(bad_i), \" is not in [0, \",\n                        params->dim_size(0), \")\"));\n      } else {\n        int64_t num_updates = updates.NumElements();\n        OP_REQUIRES(c, num_updates % N == 0,\n                    errors::InvalidArgument(\n                        \"shape of indices (\", indices.shape().DebugString(),\n                        \") is not compatible with the shape of updates (\",\n                        updates.shape().DebugString(), \")\"));\n        auto updates_flat = updates.shaped<T, 2>({N, num_updates \/ N});\n\n        functor::ScatterFunctor<Device, T, Index, op> functor;\n        const Index bad_i = functor(c, c->template eigen_device<Device>(),\n                                    params_flat, updates_flat, indices_flat);","target":1,"flaw_line_index":0,"hash":"5193b35f-c3ee-42d9-90f4-6ae282aedb9f","idx":"f506eeed-2566-4579-b6c2-f82734f4e36a"}
{"func_before":"                        \"indices\", SliceDebugString(indices.shape(), bad_i),\n                        \" = \", indices_flat(bad_i), \" is not in [0, \",\n                        params->dim_size(0), \")\"));\n      } else {\n        int64_t num_updates = updates.NumElements();\n        OP_REQUIRES(\n            c, TensorShapeUtils::StartsWith(updates.shape(), indices.shape()),\n            errors::InvalidArgument(\n                \"The shape of indices (\", indices.shape().DebugString(),\n                \") must be a prefix of the shape of updates (\",\n                updates.shape().DebugString(), \")\"));\n        auto updates_flat = updates.shaped<T, 2>({N, num_updates \/ N});\n\n        functor::ScatterFunctor<Device, T, Index, op> functor;\n        const Index bad_i = functor(c, c->template eigen_device<Device>(),\n                                    params_flat, updates_flat, indices_flat);","target":0,"flaw_line_index":0,"hash":"ee826bd9-aa46-4a9c-86d8-ee8a4a1d0d2a","idx":"b91c60ab-a2b2-4cb2-b341-906c49028f13"}
{"func_before":"          *strip_pixels;\n\n        \/*\n          Convert stripped TIFF image.\n        *\/\n        extent=2*TIFFStripSize(tiff);\n#if defined(TIFF_VERSION_BIG)\n        extent+=image->columns*sizeof(uint64);\n#else\n        extent+=image->columns*sizeof(uint32);\n#endif","target":1,"flaw_line_index":0,"hash":"9b058cf7-dd8e-42e1-8f46-24e8947a3066","idx":"2c14062d-fbde-49fc-821e-c2b8ffd3e522"}
{"func_before":"          *strip_pixels;\n\n        \/*\n          Convert stripped TIFF image.\n        *\/\n        extent=4*TIFFStripSize(tiff);\n#if defined(TIFF_VERSION_BIG)\n        extent+=image->columns*sizeof(uint64);\n#else\n        extent+=image->columns*sizeof(uint32);\n#endif","target":0,"flaw_line_index":0,"hash":"276e51f4-eac9-45c9-9939-ff4ac9bc91c6","idx":"8ce735bc-1138-47a1-8648-e947ec669a0d"}
{"func_before":"void acpi_ns_terminate(void)\n{\n\tacpi_status status;\n\n\tACPI_FUNCTION_TRACE(ns_terminate);\n\n#ifdef ACPI_EXEC_APP\n\t{\n\t\tunion acpi_operand_object *prev;\n\t\tunion acpi_operand_object *next;\n\n\t\t\/* Delete any module-level code blocks *\/\n\n\t\tnext = acpi_gbl_module_code_list;\n\t\twhile (next) {\n\t\t\tprev = next;\n\t\t\tnext = next->method.mutex;\n\t\t\tprev->method.mutex = NULL;\t\/* Clear the Mutex (cheated) field *\/\n\t\t\tacpi_ut_remove_reference(prev);\n\t\t}\n\t}\n#endif\n\n\t\/*\n\t * Free the entire namespace -- all nodes and all objects\n\t * attached to the nodes\n\t *\/","target":1,"flaw_line_index":0,"hash":"cdfbc778-44b2-4665-9c96-f23b81fb6625","idx":"55ca4a41-12db-4bde-810f-06b5bb592c19"}
{"func_before":"void acpi_ns_terminate(void)\n{\n\tacpi_status status;\n\tunion acpi_operand_object *prev;\n\tunion acpi_operand_object *next;\n\n\tACPI_FUNCTION_TRACE(ns_terminate);\n\n\t\/* Delete any module-level code blocks *\/\n\n\tnext = acpi_gbl_module_code_list;\n\twhile (next) {\n\t\tprev = next;\n\t\tnext = next->method.mutex;\n\t\tprev->method.mutex = NULL;\t\/* Clear the Mutex (cheated) field *\/\n\t\tacpi_ut_remove_reference(prev);\n\t}\n\n\t\/*\n\t * Free the entire namespace -- all nodes and all objects\n\t * attached to the nodes\n\t *\/","target":0,"flaw_line_index":0,"hash":"2550a77d-2f64-4446-a02c-05e8a62ebdfd","idx":"1ea13a7b-dae7-4251-ac19-8ccf0687c173"}
{"func_before":"                        for ( pTemp = pCur; *pTemp >= '0' && *pTemp <= '9'; ++pTemp ) ;\n                        if ( *pTemp )\n                        {\n                            char nChar = *pTemp;\n                            *pTemp = '\\0';\n                            nCode = atoi( pCur );\n                            *pTemp = nChar;\n                            if ( nCode == 8 && *pTemp == '#')\n                            {\n                                nCode = 0;\n                                for (++pTemp; *pTemp >= '0' && *pTemp <= '7'; ++pTemp)\n                    else if ( '\/' == nChar  )\n                    {\n                        sToken.clear();\n                        sGlyph.clear();\n\n                        while ( ( nChar = sEexec[++nIndex] ) != ' ' )\n                            sGlyph.push_back( (wchar_t)nChar );\n                    }\n                }\n            }\n            MemUtilsFree( sEexecBuffer );","target":1,"flaw_line_index":0,"hash":"d23ae42d-5593-41e4-95b7-661d61f28645","idx":"04e0fcec-60c8-470a-bb6e-458d21f58ce2"}
{"func_before":"                        if ( *pTemp )\n                        {\n                            char nChar = *pTemp;\n                            *pTemp = '\\0';\n                            nCode = atoi( pCur );\n\t\t\t\t\t\t\tif (nCode < 0) nCode = 0;\t\t\t\t\t\t\t\t\n                            *pTemp = nChar;\n                            if ( nCode == 8 && *pTemp == '#')\n                            {\n                                nCode = 0;\n                                for (++pTemp; *pTemp >= '0' && *pTemp <= '7'; ++pTemp)\n                    else if ( '\/' == nChar  )\n                    {\n                        sToken.clear();\n                        sGlyph.clear();\n\n                        while ( nIndex < nEexecLen && ( nChar = sEexec[++nIndex] ) != ' ' )\n                            sGlyph.push_back( (wchar_t)nChar );\n                    }\n                }\n            }\n            MemUtilsFree( sEexecBuffer );","target":0,"flaw_line_index":0,"hash":"07e9de60-7fd7-48d9-b8b2-21ecd47f58ed","idx":"c55748c2-c5e0-4fb7-8d75-386af19ec3e9"}
{"func_before":"FstringParser_ConcatFstring(FstringParser *state, const char **str,\n                            const char *end, int raw, int recurse_lvl,\n                            struct compiling *c, const node *n)\n{\n    FstringParser_check_invariants(state);\n\n    \/* Parse the f-string. *\/\n    while (1) {\n        PyObject *literal = NULL;\n        expr_ty expression = NULL;\n\n        \/* Add the literal, if any. *\/\n        if (!literal) {\n            \/* Do nothing. Just leave last_str alone (and possibly\n               NULL). *\/\n        } else if (!state->last_str) {\n            state->last_str = literal;\n            literal = NULL;\n        } else {\n            \/* We have a literal, concatenate it. *\/\n            assert(PyUnicode_GET_LENGTH(literal) != 0);\n            if (FstringParser_ConcatAndDel(state, literal) < 0)\n                return -1;\n            literal = NULL;\n        }\n        assert(!state->last_str ||\n               PyUnicode_GET_LENGTH(state->last_str) != 0);\n\n        \/* We've dealt with the literal now. It can't be leaked on further\n           errors. *\/\n        assert(literal == NULL);\n","target":1,"flaw_line_index":0,"hash":"3bc0527b-cf83-447b-b71c-d66725b6195d","idx":"c4036296-763a-43bc-9c05-f0128eae3577"}
{"func_before":"FstringParser_ConcatFstring(FstringParser *state, const char **str,\n                            const char *end, int raw, int recurse_lvl,\n                            struct compiling *c, const node *n)\n{\n    FstringParser_check_invariants(state);\n    state->fmode = 1;\n\n    \/* Parse the f-string. *\/\n    while (1) {\n        PyObject *literal = NULL;\n        expr_ty expression = NULL;\n        \/* Add the literal, if any. *\/\n        if (!literal) {\n            \/* Do nothing. Just leave last_str alone (and possibly\n               NULL). *\/\n        } else if (!state->last_str) {\n            \/*  Note that the literal can be zero length, if the\n                input string is \"\\\\\\n\" or \"\\\\\\r\", among others. *\/\n            state->last_str = literal;\n            literal = NULL;\n        } else {\n            \/* We have a literal, concatenate it. *\/\n            assert(PyUnicode_GET_LENGTH(literal) != 0);\n            if (FstringParser_ConcatAndDel(state, literal) < 0)\n                return -1;\n            literal = NULL;\n        }\n\n        \/* We've dealt with the literal now. It can't be leaked on further\n           errors. *\/\n        assert(literal == NULL);\n","target":0,"flaw_line_index":0,"hash":"ed5ce521-cc9e-4c44-8a29-c19d833868c9","idx":"addea7d6-508c-48e3-900b-cdaa031214b6"}
